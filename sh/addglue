#!/usr/bin/mythryl
#
#     sh/addglue all
#     sh/addglue gtk opengl
#
# Add a C library binding to the C and Mythryl codebase and recompile.
#
# This script should be invoked from the root sourcetree dirctory.
#
# Arguments are library names (i.e., names of directories under src/glu):
#
#     sh/addglue gtk opengl
#
# To add all available libraries use the special arg 'all':
#
#     sh/addglue all

stipulate
    package cmd =  commandline;							# commandline		is from   src/lib/std/commandline.pkg
    package gj  =  glue_junk;							# glue_junk		is from   src/lib/make-library-glue/glue-junk.pkg
    package lms =  list_mergesort;						# list_mergesort	is from   src/lib/src/list-mergesort.pkg
    package lp  =  library_patchpoints;						# library_patchpoints	is from   src/lib/make-library-glue/library-patchpoints.pkg
    package paf =  patchfile;							# patchfile		is from   src/lib/make-library-glue/patchfile.pkg
    package pfj =  planfile_junk;						# planfile_junk		is from   src/lib/make-library-glue/planfile-junk.pkg
    package pfs =  patchfiles;							# patchfiles		is from   src/lib/make-library-glue/patchfile.pkg
    package plf =  planfile;							# planfile		is from   src/lib/make-library-glue/planfile.pkg
    package sm  =  string_map;							# string_map		is from   src/lib/src/string-map.pkg
    #
    keys_list				=  sm::keys_list;
    vals_list				=  sm::vals_list;
    #
    sort_list_and_drop_duplicates	=  lms::sort_list_and_drop_duplicates;
    #
    print_strings			=  gj::print_strings;
    validate_glue_selections		=  gj::validate_glue_selections;
    #
    get_only_patch			=  paf::get_only_patch;
    print_patchfile			=  paf::print_patchfile;
    read_patchfile			=  paf::read_patchfile;
    set_only_patch			=  paf::set_only_patch;
    write_patchfile			=  paf::write_patchfile;
herein
    fun usage ()
	=
	{
	    printf "Usage: addglue arg...  where 'arg' is either a subdirectory in src/glu or the special word 'all'.\n";
	    exit(1);
	};

    available_glue_modules =   gj::find_available_glue_modules ();		# Find all subdirs of src/glu.
										# Returns a map from keys like
										# "opengl" to paths like "src/glu/opengl":


{
 keys =  keys_list  available_glue_modules;

 printf "Available glue modules: ";
 print_strings keys;
 printf "\n";    

 vals =  vals_list  available_glue_modules;

 printf "Glue module directories: ";
 print_strings vals;
 printf "\n";    
};

    selected_glue_modules__filename
	=
	gj::validate__selected_glue_modules__file ();				# Create $HOME/.mythryl/selected-glue-modules if it doesn't exist -- or die trying.

    selected_glue_modules__file
	=
	read_patchfile  selected_glue_modules__filename;

#   print_patchfile  selected_glue_modules__file;

    old_glue_selections =  get_only_patch  selected_glue_modules__file;

    old_glue_selections =  map  trim  old_glue_selections;			# Drop trailing newlines.

    printf "Old glue selections: ";
    print_strings old_glue_selections;
    printf "\n";    




    new_glue_selections =  cmd::get_commandline_arguments ();

printf "new_glue_selections: ";
print_strings new_glue_selections;
printf "\n";    

    new_glue_selections
	=
	validate_glue_selections  new_glue_selections  available_glue_modules   usage;

printf "new_glue_selections after validation: ";
print_strings new_glue_selections;
printf "\n";    


    final_glue_selections
	=
	sort_list_and_drop_duplicates
	    string::compare
	    (old_glue_selections @ new_glue_selections);

printf "final_glue_selections: ";
print_strings final_glue_selections;
printf "\n";    

    planfile_paths
	=
	fold_forward
	    (fn (glue_name, result)				# "opengl" or such.
		=
		{   glue_dir = the (sm::get (available_glue_modules, glue_name));
		    #
		    (glue_dir + "/etc/integration.plan")  !  result;
		}
	    ) 
	    []
	    final_glue_selections;

printf "planfile_paths: ";
print_strings planfile_paths;
printf "\n";

    paragraph_defs
	=
	plf::digest_paragraph_definitions
	    (sm::empty: plf::Digested_Paragraph_Definitions(Int))
	    "sh/addglue"
	    [ lp::append_to_patch__definition ];

    plan =  plf::read_planfiles  paragraph_defs  planfile_paths;
    

    patchfiles =  pfs::load_patchfiles  lp::patchfile_paths;

    patchfiles =  plf::map_patchfiles_per_plan  0  patchfiles  plan;		# '0' is unused.

#    summary    =  pfs::write_patchfiles  patchfiles;

#    printf "Patch summary: ";
#    print_strings summary;
#    printf "\n";

    # Remember glue selections.	
    #
#    write_patchfile  (set_only_patch  selected_glue_modules__file  (map  (fn s = s + "\n")  final_glue_selections));


    exit(0);
end;