#!/usr/bin/mythryl
#
# Add a C library binding to the C and Mythryl codebase.
#
# This script should be invoked from the root sourcetree dirctory.
#
# Arguments are library names (i.e., names of directories under src/glu):
#
#     sh/glue add gtk opengl
#
# To add all available libraries use the special arg 'all':
#
#     sh/glue add all

# To remove all libraries:
#
#     sh/glue drop all

stipulate
    package cmd =  commandline;							# commandline		is from   src/lib/std/commandline.pkg
    package gj  =  glue_junk;							# glue_junk		is from   src/lib/make-library-glue/glue-junk.pkg
    package lms =  list_mergesort;						# list_mergesort	is from   src/lib/src/list-mergesort.pkg
    package lp  =  library_patchpoints;						# library_patchpoints	is from   src/lib/make-library-glue/library-patchpoints.pkg
    package paf =  patchfile;							# patchfile		is from   src/lib/make-library-glue/patchfile.pkg
    package pfj =  planfile_junk;						# planfile_junk		is from   src/lib/make-library-glue/planfile-junk.pkg
    package pfs =  patchfiles;							# patchfiles		is from   src/lib/make-library-glue/patchfile.pkg
    package plf =  planfile;							# planfile		is from   src/lib/make-library-glue/planfile.pkg
    package psx =  posixlib;							# posixlib		is from   src/lib/std/src/psx/posixlib.pkg
    package sm  =  string_map;							# string_map		is from   src/lib/src/string-map.pkg

    keys_list				=  sm::keys_list;
    vals_list				=  sm::vals_list;

    sort_list_and_drop_duplicates	=  lms::sort_list_and_drop_duplicates;

    print_strings			=  gj::print_strings;
    validate_glue_selections		=  gj::validate_glue_selections;

    get_only_patch			=  paf::get_only_patch;
    print_patchfile			=  paf::print_patchfile;
    read_patchfile			=  paf::read_patchfile;
    set_only_patch			=  paf::set_only_patch;
    write_patchfile			=  paf::write_patchfile;

    =~     =  regex::(=~);

herein

    Op = ADD | DROP | NADA;

    fun usage ()
	=
	{   printf "Usage: glue add  arg ...  where 'arg' is either a subdirectory in src/glu or the special word 'all'.\n";
	    printf "   or: glue drop arg ...  where 'arg' is either a subdirectory in src/glu or the special word 'all'.\n";
	    printf "   or: glue               to display current glue module configuration.\n";
	    exit_x(1);
	};

    available_glue_modules =   gj::find_available_glue_modules ();		# Find all subdirs of src/glu.
										# Returns a map from keys like
										# "opengl" to paths like "src/glu/opengl":

    possible_selections    =  sm::keys_list  available_glue_modules;

    selected_glue_modules__filename
	=
	gj::validate__selected_glue_modules__file ();				# Create $HOME/.mythryl/selected-glue-modules if it doesn't exist -- or die trying.

    selected_glue_modules__file
	=
	read_patchfile  selected_glue_modules__filename;

    old_glue_selections =  get_only_patch  selected_glue_modules__file;

    old_glue_selections =  map  trim  old_glue_selections;			# Drop trailing newlines.

    new_glue_selections =  cmd::get_commandline_arguments ();


    my (op, new_glue_selections)
	=
	case new_glue_selections
	    #
	    "add"  ! rest   => (ADD,   rest);
	    "drop" ! rest   => (DROP,  rest);
	    [] 		    => (NADA,  []);
	    _		    => usage ();
	esac;

    new_glue_selections
	=
	validate_glue_selections  new_glue_selections  available_glue_modules   usage;

    old_glue_selections
	=
	sort_list_and_drop_duplicates
	    string::compare
	    old_glue_selections;

    final_glue_selections							# [ "opengl", "gtk" ], say.
	=
	case op
	    #
	    NADA => old_glue_selections;

	    ADD  => sort_list_and_drop_duplicates
			string::compare
			(old_glue_selections @ new_glue_selections);

	    DROP => {	
			glue_selections_to_drop
			    =
			    sort_list_and_drop_duplicates
				string::compare
				new_glue_selections;

			list::filter  want_this_one  old_glue_selections
			where
			    fun want_this_one  glue						# Return TRUE unless 'glue' is in 'glue_selections_to_drop'.
				=
				not (list::exists (fn element =   element == glue)  glue_selections_to_drop);
			end;
		    };
	esac;

    printf "\n";
    printf "Possible module selections: ";    apply (fn m = printf " %s" m)   possible_selections;	printf "\n"; 
    printf "Old glue module selections: ";    apply (fn m = printf " %s" m)   old_glue_selections;	printf "\n";
    printf "New glue module selections: ";    apply (fn m = printf " %s" m) final_glue_selections;	printf "\n";
    printf "\n";

    if (old_glue_selections == final_glue_selections)
	#
	printf "No net change in glue selections -- nothing to do, so exit(0)ing.\n\n";
	exit(0);
    fi;    

    planfile_paths								# [ "src/glu/opengl/etc/opengl-integration.plan", "src/glu/gtk/etc/gtk-integration.plan" ], say.
	=
	fold_forward
	    (fn (glue_name, result)						# glue_name will be "opengl" or such.
		=
		{   glue_dir = the (sm::get (available_glue_modules, glue_name));
		    #
		    (glue_dir + "/etc/" + glue_name + "-integration.plan")  !  result;
		}
	    ) 
	    []
	    final_glue_selections;

    paragraph_defs
	=
	plf::digest_paragraph_definitions
	    (sm::empty: plf::Digested_Paragraph_Definitions(Int))
	    "sh/addglue"
	    [ lp::append_to_patch__definition ];

    plan =  plf::read_planfiles  paragraph_defs  planfile_paths;		# Load into memory all changes to be made to patchfiles.
    
    patchfiles =  pfs::load_patchfiles  lp::patchfile_paths;			# Load into memory all the files which we will be patching.
    patchfiles =  pfs::empty_all_patches  patchfiles;				# Clear current contents of patches to make way for the new contents.
    patchfiles =  plf::map_patchfiles_per_plan  0  patchfiles  plan;		# Patch all patchfiles per plans.  ('0' arg is unused.)

    summary    =  pfs::write_patchfiles  patchfiles;

    summary    =  sort_list_and_drop_duplicates
		      string::compare
		      summary;

    printf "\nPatch summary:\n\n";
    apply (fn s = printf "    %s\n" s) summary;
    printf "\n";

    # Remember glue selections:
    #
    final_glue_selections'	=  (map  (fn s = s + "\n")  final_glue_selections);
    selected_glue_modules__file =  set_only_patch  selected_glue_modules__file  final_glue_selections';
    write_patchfile  selected_glue_modules__file;

    if (dir::is_file  "bin/mythryld")
	#
	psx::unlink "bin/mythryld";
	printf "Removed obsoleted bin/mythryld\n";
    fi;
    
    if (dir::is_file  "bin/mythryld-previous")
	#
	psx::unlink "bin/mythryld-previous";
	printf "Removed obsoleted bin/mythryld-previous\n";
    fi;

    apply'
        (dir::file_names "bin")
        (fn filename
	    =
	    if (filename =~ ./^mythryl-runtime/)
		filepath = "bin/" + filename;
		psx::unlink filepath;
		printf "Removed obsoleted %s\n" filepath;
	    fi
	);

    case final_glue_selections
	#
	[] =>	    printf "\n\nCodebase now configured without any glue modules.\n\n";
	#
	_  =>   {   printf "\n\nCodebase now reconfigured to support the following glue modules:\n\n";
		    apply  (fn m = printf "    %s\n" m)  final_glue_selections;
		    printf "\n";
		};
    esac;

    printf "\nNext you may want to build from the newly-patched codebase by doing:\n\n";
    printf "    make clean\n";
    printf "    make compiler\n";
    printf "    make rest\n";
    printf "    sudo make install\n";
    printf "    make check\n";
    printf "\n";
    
    exit(0);
end;
