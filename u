#! /usr/bin/mythryl
#
# Test pre-emptive microthread timeslicing.    -- 2013-04-20 CrT

stipulate
    include threadkit;									# threadkit						is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ci  =  mythryl_callable_c_library_interface;				# mythryl_callable_c_library_interface			is from   src/lib/std/src/unsafe/mythryl-callable-c-library-interface.pkg
    package hth =  hostthread;								# hostthread						is from   src/lib/std/src/hostthread.pkg
    package io  =  io_bound_task_hostthreads;						# io_bound_task_hostthreads				is from   src/lib/std/src/hostthread/io-bound-task-hostthreads.pkg
    package mps =  microthread_preemptive_scheduler;					# microthread_preemptive_scheduler			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/microthread-preemptive-scheduler.pkg
    package psx =  posixlib;								# posixlib						is from   src/lib/std/src/psx/posixlib.pkg
    #

herein

    printf "alarm handler callstats: %d %d %d\n"   *mps::alarm_handler_calls   *mps::alarm_handler_calls_with__uninterruptible_scope_mutex__set   *mps::alarm_handler_calls_with__microthread_switch_lock__set;

    mps::alarm_handler_calls                                        :=  0;
    mps::alarm_handler_calls_with__uninterruptible_scope_mutex__set :=  0;
    mps::alarm_handler_calls_with__microthread_switch_lock__set     :=  0;

    stipulate
        dummy = REF 0;
    herein
	fun worker_thread counter
	    =
	    {   for (i = 100000; i > 0; --i) {
		    if (i & 1 == 0)   dummy := *dummy + 1;
		    else	      dummy := *dummy - 1;
		    fi;
		};
		counter := *counter + 1;
		worker_thread counter;	
	    };
    end;


    counter1 = REF 0;
    counter2 = REF 0;

    fun initialize__timeslicing__task ()
	=
	{   make_thread "worker thread" .{ worker_thread  counter1; };
	    make_thread "worker thread" .{ worker_thread  counter2; };
	    #
	    thread_exit { success => TRUE };
	};

    task =  make_task "Test microthread pre-emptive timeslicing"  [ ("startup_thread", initialize__timeslicing__task) ];
    sleep_for 1.0;
    kill_task { task, success => TRUE };
    printf "counter1 d=%d  counter2 d=%d\n" *counter1 *counter2;
    printf "alarm handler callstats: %d %d %d\n"   *mps::alarm_handler_calls   *mps::alarm_handler_calls_with__uninterruptible_scope_mutex__set   *mps::alarm_handler_calls_with__microthread_switch_lock__set;
end;
