<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mythryl Types: Type Variables</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mythryl_Types__Generativity.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Generic_Packages.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc101">5.4.16</A>  Mythryl Types: Type Variables</H3><P>Suppose we want to write a library function which accepts a tuple of two strings 
and returns a tuple containing those two strings in reverse order:</P><PRE CLASS="verbatim">    api Swap_Lib { 
        swap_strings: (String, String) -&gt; (String, String);
    };

    package swap_lib: Swap_Lib {
        fun swap_strings (a, b) = (b, a);
    };
</PRE><P>After hours of debugging we get it working, and are so excited by the 
new horizons thus opened up that we immediately want the same thing 
for integers:</P><PRE CLASS="verbatim">    api Swap_Lib { 
        swap_strings: (String, String) -&gt; (String, String);
        swap_ints:    (Int,    Int)    -&gt; (Int,    Int);
    };

    package swap_lib: Swap_Lib {
        fun swap_strings (a, b) = (b, a);
        fun swap_ints    (a, b) = (b, a);
    };
</PRE><P>Wow! How about floats?</P><PRE CLASS="verbatim">    api Swap_Lib { 
        swap_strings: (String, String) -&gt; (String, String);
        swap_ints:    (Int,    Int)    -&gt; (Int,    Int);
        swap_floats:  (Float,  Float)  -&gt; (Float,  Float);
    };

    package swap_lib: Swap_Lib {
        fun swap_strings (a, b) = (b, a);
        fun swap_ints    (a, b) = (b, a);
        fun swap_floats  (a, b) = (b, a);
    };
</PRE><P>This is so much fun! Let&#X2019;s do <I>all</I> the types!</P><P>Um, wait. There are an <I>infinite number</I> of possible types in 
Mythryl. We could be at this a really, really long time.</P><P>Furthermore, the code generated by the Mythryl compiler for each of our 
functions is exactly the same; it doesn&#X2019;t actually depend on the types 
of the arguments at all.</P><P>Why cannot we just write one generic <TT>swap</TT> function and be done with it?</P><P>In a language like C, there is no way to do this. At least, no typesafe 
way: The C type system is not rich enough to have a representation for 
the <I>any type here</I> concept. (Although <TT>void*</TT> works as a 
weak approximation.)</P><P>In practice, C programmers at this point would simply bypass the type 
system by casting all arguments to <TT>void</TT> on input and casting them 
back again on output. In short, by lying to the C compiler because it 
is just too dumb to do the job otherwise.</P><P>The Mythryl type system is considerably more subtle. In Mythryl, we can 
actually do this right:</P><PRE CLASS="verbatim">    api Swap_Lib { 
        swap: (X, X) -&gt; (X, X);
    };

    package swap_lib: Swap_Lib {
        fun swap (a, b) = (b, a);
    };
</PRE><P>Here the X identifiers introduce a match-anything type variable.</P><P>Type variables do for type declarations what 
parameter variables do for function declarations: They let us 
talk concretely about arbitrary members drawn from a large 
class of possibilities. In a declaration like</P><PRE CLASS="verbatim">    fun double x   = 2.0 * x;
</PRE><P>the <TT>x</TT> lets us refer to any possible floating number which may 
become relevant during later processing. In a declaration like</P><PRE CLASS="verbatim">    swap: (X, X) -&gt; (X, X);
</PRE><P>the X lets us refer to any possible <I>type</I> which may become 
relevant during later processing.</P><P>In Mythryl any identifier consisting of a single uppercase character is 
a type variable:</P><PRE CLASS="verbatim">    A
    B
    C
    ...
    X
    Y
    Z
</PRE><P>For the (rare) cases where more semantic content is desirable, Mythryl 
also supports type variable names beginning with such a lone uppercase 
letter and then followed by an underbar and a lower-case identifier:</P><PRE CLASS="verbatim">    A_sorted_type
    Z_best_type_available
    ...
</PRE><P>Returning to our swap-library example, here is a wet run:</P><PRE CLASS="verbatim">    linux$ my

    eval:  api Swap_Lib { swap: (X, X) -&gt; (X, X); };
    eval:  package swap_lib: Swap_Lib { fun swap (a, b) = (b, a); };

    eval:  swap_lib::swap( 1, 2 );
    (2, 1)

    eval:  swap_lib::swap( "abc", "def" );
    ("def", "abc")

    eval:  swap_lib::swap( 1.23, 3.21 );
    (3.21, 1.23)
</PRE><P>In fact we can do even better and allow swapping 
not just any two-tuple of two values of the same type, 
but any two-tuple whatever:</P><PRE CLASS="verbatim">    api Swap_Lib { 
        swap: (X, Y) -&gt; (Y, X);
    };

    package swap_lib: Swap_Lib {
        fun swap (a, b) = (b, a);
    };
</PRE><P>Here the <TT>X</TT> and <TT>Y</TT> type variables can match different types.</P><P>Here is the improved version in action:</P><PRE CLASS="verbatim">    linux$ my

    eval:  api Swap_Lib { swap: (X, Y) -&gt; (Y, X); };
    eval:  package swap_lib: Swap_Lib { fun swap (a, b) = (b, a); };

    eval:  swap_lib::swap( 1, "one" );
    ("one", 1)

    eval:  swap_lib::swap( 2, ("one", { name =&gt; "Johnny", age =&gt; 21 } )  );
    (("one", { age=21, name="Johnny" }), 2)
</PRE><P>Type variables open up whole new worlds of expressiveness in programming.</P><P>There are many, many datastructures in which the code really does not 
care what type is in a given slot.</P><P>For example, binary trees usually 
care about the types of node keys, because they have to know how to compare 
them for order, but they usually do not care at all about the types of 
node values, because they just store them on request and then produce them 
upon demand.</P><P>In a language like C, binary tree implementations have to specify a 
type for such node values anyhow, greatly reducing code reusability, 
but in Mythryl we can &#X2014; and do &#X2014; write them in fully general form:</P><PRE CLASS="verbatim">    Tree(X) = EMPTY
            | NODE { key: Float, value: X, left_kid: Tree, right_kid: Tree };
</PRE><P>Here <TT>Tree(X)</TT> is essentially a compile-time type function which 
takes a type as argument and returns a new type as its result. These 
type functions are usually called <I>type constructors</I>, often truncated to <I>typ</I>.</P><P>For example, we can now start writing api declarations like</P><PRE CLASS="verbatim">    sum_integer_valued_tree:  Tree(Int) -&gt; Int;
</PRE><P>Here <TT>Tree(Int)</TT> is a new type defined in terms of existing ones.</P><P>Sometimes, of course, we may be able to build new datastructures out 
of <TT>Tree(X)</TT> without needing to reduce its generality. For 
example, maybe we have a type which is allowed to hold any pair of 
trees so long as they are of the same type:</P><PRE CLASS="verbatim">    Tree_Pair(X) = (Tree(X), Tree(X));
</PRE><P>The one real lack of generality in the above <TT>Tree</TT> definition is that 
its key type is hardwired. If we want a binary tree with integer keys, 
we need to write another declaration. Ditto if we want a binary tree with 
string keys.</P><P>We cannot abstract away from key type by using a type 
variable because the binary tree implemention actually does care about 
key type; it has to know how to compare keys in order to keep the 
tree sorted.</P><P>Thus, in order to write a single generic version of binary tree, we need 
a bigger bat. That bat is the Mythryl <I>generic package</I>, which is the subject 
of the next section.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mythryl_Types__Generativity.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Generic_Packages.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
