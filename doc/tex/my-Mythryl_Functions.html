<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mythryl Functions</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mythryl_Code_Blocks.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Mythryl_for_SML_Programmers.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Conditionals.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc193">5.7.11</A>  Mythryl Functions</H3><P>Code blocks aside, the core differences between basic SML and Mythryl function 
syntax are that</P><UL CLASS="itemize"><LI CLASS="li-itemize">Mythryl consistently uses <TT>=&gt;</TT> to flag multiway <TT>case</TT> 
style constructs and <TT>=</TT> to flag monocase bindings.</LI><LI CLASS="li-itemize">Mythryl uses a terminal <TT>end</TT> in the multiway cases.</LI><LI CLASS="li-itemize">Mythryl delimits cases with terminal semicolons rather than initial bars, 
freeing up the latter identifier for application programmer use.</LI><LI CLASS="li-itemize">Mythryl links mutually recursive functions with <TT>also</TT> rather than 
<TT>and</TT>, reserving the latter identifier for short-circuit conditionals.
</LI></UL><PRE CLASS="verbatim">    fun f x = x;                      # Monocase form.

    fun f [] =&gt; printf "Empty\n";     # Multicase form.
        f x  =&gt; printf "Nonempty;
    end;

    fun f x = g x                     # Muturally recursive case.
    also                              # Note lack of semicolon before 'also':
    fun g x = f x;                    # semicolon always marks a complete construct.

    \\ x = x;                         # Monocase form of anonymous function.

    \\ [] =&gt; printf "Empty\n";        # Multicase form of anonymous function.
       x  =&gt; printf "Nonempty\n";
    end;

    {. printf "Foo\n"; }              # Equivalent to   \\ () = printf "Foo\n";

    {. #x == #y; }                    # Equivalent to   \\ (x, y) = (x == y);
</PRE><P>The latter two forms are intended to facilitate application-programmer 
creation of functions which can be used like traditional iterative 
constructs. For example given the definition</P><PRE CLASS="verbatim">    fun foreach []         thunk =&gt;  ();
        foreach (a ! rest) thunk =&gt;  { thunk(a);   foreach rest thunk; };
    end;
</PRE><P>(which is in fact part of the Mythryl standard library) one can then write 
code like</P><PRE CLASS="verbatim">    foreach [ "red", "green", "blue" ] {.
        printf "Color %s encountered\n" #color;
    };
</PRE><P>thus obtaining most of the convenience of hardwired <TT>foreach</TT> loops 
in languages like <TT>Python</TT> without having to hammer each such construct 
explicitly into the compiler proper.</P><P>A more typical use of this construct would be to list all the files in 
the current directory:</P><PRE CLASS="verbatim">    foreach (dir::entry_names ".") {. printf "%s\n" #filename; };
</PRE><P>Since the standard library infix function invocation <TT>1 .. 10</TT> generates 
a list <TT>[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</TT> one can also write loops like </P><PRE CLASS="verbatim">    foreach (1 .. 10) {.
        printf "Loop %d\n" #i;
    };
</PRE><P>although the explicitly constructed list makes this inefficient for large 
iteration counts.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mythryl_Code_Blocks.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Mythryl_for_SML_Programmers.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Conditionals.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
