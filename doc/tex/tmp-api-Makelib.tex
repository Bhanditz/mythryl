\index[api]{Makelib}
\label{api:Makelib}
\input{top-api-Makelib.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    help : Void -> Void;
    make : String -> Bool;
    load : String -> Bool;
    use : String -> Bool;
    compile : String -> Bool;
    freeze : String -> Bool;
    freeze' : {recursively:Bool} -> String -> Bool;
    show_all : Void -> Void;
    show_apis : Void -> Void;
    show_pkgs : Void -> Void;
    show_vals : Void -> Void;
    show_types : Void -> Void;
    show_generics : Void -> Void;
    search_lib_load_path_for_file : String -> Null_Or(String );
    show_controls : Void -> Void;
    show_control : String -> Void;
    set_control : String -> String -> Void;
    show_api : String -> Void;
    show_pkg : String -> Void;
        parse_string_to_raw_declarations :
            {pp:?.standard_prettyprinter::pp::Prettyprinter, sourcecode_info:sourcecode_info::Sourcecode_Info}
            ->
            List(raw_syntax::Declaration );
        compile_raw_declaration_to_package_closure :
                {compiler_state_stack:(compiler_state::Compiler_State , List(compiler_state::Compiler_State )),
                declaration:raw_syntax::Declaration, options:List(compiler_state::Compile_And_Eval_String_Option ),
                pp:?.standard_prettyprinter::pp::Prettyprinter, sourcecode_info:sourcecode_info::Sourcecode_Info}
            ->Null_Or(
                {code_and_data_segments:code_segment::Code_And_Data_Segments,
                compiler_state_stack:(compiler_state::Compiler_State , List(compiler_state::Compiler_State )),
                compiler_verbosity:per_compile_stuff::Compiler_Verbosity,
                deep_syntax_declaration:deep_syntax::Declaration,
                export_picklehash:Null_Or(picklehash::Picklehash ),
                exported_highcode_variables:List(highcode_codetemp::Codetemp ),
                get_current_compiler_mapstack_set:Void -> compiler_state::Compiler_Mapstack_Set,
                import_trees:List(import_tree::Import_Tree ), inline_expression:Null_Or(anormcode_form::Function ),
                linking_mapstack:linking_mapstack::Picklehash_To_Heapchunk_Mapstack,
                new_symbolmapstack:symbolmapstack::Symbolmapstack, package_closure:code_segment::Package_Closure,
                top_level_pkg_etc_defs_jar:compiler_state::Compiler_Mapstack_Set_Jar}
               );
        link_and_run_package_closure :
            {pp:?.standard_prettyprinter::pp::Prettyprinter, sourcecode_info:sourcecode_info::Sourcecode_Info}
            ->  {code_and_data_segments:code_segment::Code_And_Data_Segments,
                compiler_state_stack:(compiler_state::Compiler_State , List(compiler_state::Compiler_State )),
                compiler_verbosity:per_compile_stuff::Compiler_Verbosity,
                deep_syntax_declaration:deep_syntax::Declaration,
                export_picklehash:Null_Or(picklehash::Picklehash ),
                exported_highcode_variables:List(highcode_codetemp::Codetemp ),
                get_current_compiler_mapstack_set:Void -> compiler_state::Compiler_Mapstack_Set,
                import_trees:List(import_tree::Import_Tree ), inline_expression:Null_Or(anormcode_form::Function ),
                linking_mapstack:linking_mapstack::Picklehash_To_Heapchunk_Mapstack,
                new_symbolmapstack:symbolmapstack::Symbolmapstack, package_closure:code_segment::Package_Closure,
                top_level_pkg_etc_defs_jar:compiler_state::Compiler_Mapstack_Set_Jar}
            ->
            (compiler_state::Compiler_State , List(compiler_state::Compiler_State ));
    Controller X = {get:Void -> X, set:X -> Void};
        package control
          : api {
                keep_going_after_compile_errors : Controller(Bool );
                verbose : Controller(Bool );
                warn_on_obsolete_syntax : Controller(Bool );
                debug : Controller(Bool );
                conserve_memory : Controller(Bool );
                generate_index : Controller(Bool );
                parse_caching : Controller(Int );};;
        package freezefile_db
          : api {
                Freezefile;
                known : Void -> List(Freezefile );
                describe : Freezefile -> String;
                os_string : Freezefile -> String;
                dismiss : Freezefile -> Void;
                unshare : Freezefile -> Void;};;
        package makelib_state
          : api {
                clear_state : Void -> Void;
                dump : String -> Void;
                dump_latex : {directory:String, filename_prefix:String, filename_suffix:String} -> Void;};;
        sources :
            Null_Or({architecture:String, os:String} )
            ->
            String -> Null_Or(List({derived:Bool, file:String, ilk:String} ) );
    get_makelib_preprocessor_symbol_value : String -> Controller(Null_Or(Int ) );
    load_plugin : String -> Bool;
        build_executable_heap_image :
            ?.freeze_policy::Freeze_Policy
            ->
            {heap_filename:String, libfile_to_run:String, setup:Null_Or(String ), wrapper_libfile:String}
            ->
            Null_Or(List(String ) );
        package graph
          : api {   graph :
                        String
                        ->Null_Or(
                            {graph:?.portable_graph::Graph, imports:List(freezefile_db::Freezefile ),
                            nativesrc:String -> String}
                           );};;
        package scripting_globals
          : api {
                _! : multiword_int::Int -> multiword_int::Int;
                _[]:= : (Rw_Vector(X ) , Int , X) -> Void;
                =~ : (String , String) -> Bool;
                atod : String -> Float;
                atoi : String -> Int;
                backticks__op : String -> List(String );
                basename : String -> String;
                bin_sh : String -> String;
                bin_sh' : String -> Int;
                chdir : String -> Void;
                chomp : String -> String;
                die : String -> Void;
                die_x : String -> X;
                dirname : String -> String;
                environ : Void -> List(String );
                eval : String -> Void;
                evali : String -> Int;
                evalf : String -> Float;
                evals : String -> String;
                evalli : String -> List(Int );
                evallf : String -> List(Float );
                evalls : String -> List(String );
                exit : Int -> Void;
                exit_x : Int -> X;
                explode : String -> List(Char );
                factors : Int -> List(Int );
                fields : (Char -> Bool) -> String -> List(String );
                filter : (X -> Bool) -> List(X ) -> List(X );
                fscanf : Input_Stream -> String -> Null_Or(List(printf_field::Printf_Arg ) );
                getcwd : Void -> String;
                getenv : String -> Null_Or(String );
                getpid : Void -> Int;
                getuid : Void -> Int;
                geteuid : Void -> Int;
                getppid : Void -> Int;
                getgid : Void -> Int;
                getegid : Void -> Int;
                getgroups : Void -> List(Int );
                getlogin : Void -> String;
                getpgrp : Void -> Int;
                mkdir : String -> Void;
                setgid : Int -> Void;
                setpgid : (Int , Int) -> Void;
                setsid : Void -> Int;
                setuid : Int -> Void;
                implode : List(Char ) -> String;
                in : (''a , List(''a )) -> Bool;
                iseven : Int -> Bool;
                isodd : Int -> Bool;
                isprime : Int -> Bool;
                join' : String -> String -> String -> List(String ) -> String;
                join : String -> List(String ) -> String;
                lstat : String -> ?.posix_file::stat::Stat;
                now : Void -> Float;
                product : List(Int ) -> Int;
                rename : {from:String, to:String} -> Void;
                rmdir : String -> Void;
                round : Float -> Int;
                shuffle' : random::Random_Number_Generator -> List(X ) -> List(X );
                shuffle : List(X ) -> List(X );
                sleep : Float -> Void;
                sort : ((X , X) -> Bool) -> List(X ) -> List(X );
                sorted : ((X , X) -> Bool) -> List(X ) -> Bool;
                scanf : String -> Null_Or(List(printf_field::Printf_Arg ) );
                sscanf : String -> String -> Null_Or(List(printf_field::Printf_Arg ) );
                stat : String -> ?.posix_file::stat::Stat;
                strcat : List(String ) -> String;
                strlen : String -> Int;
                strsort : List(String ) -> List(String );
                struniqsort : List(String ) -> List(String );
                sum : List(Int ) -> Int;
                symlink : {new:String, old:String} -> Void;
                time : Void -> one_word_int::Int;
                tolower : String -> String;
                toupper : String -> String;
                tokens : (Char -> Bool) -> String -> List(String );
                trim : String -> String;
                uniquesort : ((X , X) -> Order) -> List(X ) -> List(X );
                unlink : String -> Void;
                words : String -> List(String );
                dotqquotes__op : String -> List(String );
                arg0 : Void -> String;
                argv : Void -> List(String );
                isfile : String -> Bool;
                isdir : String -> Bool;
                ispipe : String -> Bool;
                issymlink : String -> Bool;
                issocket : String -> Bool;
                ischardev : String -> Bool;
                isblockdev : String -> Bool;
                mayread : String -> Bool;
                maywrite : String -> Bool;
                mayexecute : String -> Bool;
                eval_kludge_ref_int : Ref(Int );
                eval_kludge_ref_float : Ref(Float );
                eval_kludge_ref_string : Ref(String );
                eval_kludge_ref_list_int : Ref(List(Int ) );
                eval_kludge_ref_list_float : Ref(List(Float ) );
                eval_kludge_ref_list_string : Ref(List(String ) );
                exception THREAD_SCHEDULER_NOT_RUNNING;
                    package state
                      : api {
                            State  = ALIVE | FAILURE | FAILURE_DUE_TO_UNCAUGHT_EXCEPTION | SUCCESS;};;
                Apptask;
                Microthread;
                default_microthread : Microthread;
                get_current_microthread : Void -> Microthread;
                get_current_microthread's_name : Void -> String;
                get_current_microthread's_id : Void -> Int;
                get_task's_id : Apptask -> Int;
                get_task's_name : Apptask -> String;
                get_task's_state : Apptask -> state::State;
                get_task's_alive_threads_count : Apptask -> Int;
                same_task : (Apptask , Apptask) -> Bool;
                compare_task : (Apptask , Apptask) -> Order;
                same_thread : (Microthread , Microthread) -> Bool;
                compare_thread : (Microthread , Microthread) -> Order;
                hash_thread : Microthread -> Unt;
                kill_thread : {success:Bool, thread:Microthread} -> Void;
                kill_task : {success:Bool, task:Apptask} -> Void;
                get_thread's_id : Microthread -> Int;
                get_thread's_id_as_string : Microthread -> String;
                get_thread's_name : Microthread -> String;
                get_thread's_state : Microthread -> state::State;
                get_thread's_task : Microthread -> Apptask;
                get_exception_that_killed_thread : Microthread -> Null_Or(Exception );
                get_exception_that_killed_task : Apptask -> Null_Or(Exception );
                Make_Thread_Args  = THREAD_NAME String | THREAD_TASK Apptask;
                make_thread' : List(Make_Thread_Args ) -> (X -> Void) -> X -> Microthread;
                make_thread : String -> (Void -> Void) -> Microthread;
                make_task : String -> List(((String , (Void -> Void))) ) -> Apptask;
                thread_exit : {success:Bool} -> X;
                thread_done__mailop : Microthread -> ?.internal_threadkit_types::Mailop(Void );
                task_done__mailop : Apptask -> ?.internal_threadkit_types::Mailop(Void );
                yield : Void -> Void;
                run_thread__xu : Microthread -> (X -> Void) -> X -> Void;
                    make_per_thread_property :
                    (Void -> X) -> {clear:Void -> Void, get:Void -> X, peek:Void -> Null_Or(X ), set:X -> Void};
                make_boolean_per_thread_property : Void -> {get:Void -> Bool, set:Bool -> Void};
                Mailslot X;
                make_mailslot : Void -> Mailslot(X );
                same_mailslot : (Mailslot(X ) , Mailslot(X )) -> Bool;
                put_in_mailslot : (Mailslot(X ) , X) -> Void;
                take_from_mailslot : Mailslot(X ) -> X;
                put_in_mailslot' : (Mailslot(X ) , X) -> ?.internal_threadkit_types::Mailop(Void );
                take_from_mailslot' : Mailslot(X ) -> ?.internal_threadkit_types::Mailop(X );
                nonblocking_put_in_mailslot : (Mailslot(X ) , X) -> Bool;
                nonblocking_take_from_mailslot : Mailslot(X ) -> Null_Or(X );
                Maildrop X;
                exception MAY_NOT_FILL_ALREADY_FULL_MAILDROP;
                make_empty_maildrop : Void -> Maildrop(X );
                make_full_maildrop : X -> Maildrop(X );
                put_in_maildrop : (Maildrop(X ) , X) -> Void;
                take_from_maildrop : Maildrop(X ) -> X;
                take_from_maildrop' : Maildrop(X ) -> ?.internal_threadkit_types::Mailop(X );
                nonblocking_take_from_maildrop : Maildrop(X ) -> Null_Or(X );
                get_from_maildrop : Maildrop(X ) -> X;
                get_from_maildrop' : Maildrop(X ) -> ?.internal_threadkit_types::Mailop(X );
                nonblocking_get_from_maildrop : Maildrop(X ) -> Null_Or(X );
                maildrop_swap : (Maildrop(X ) , X) -> X;
                maildrop_swap' : (Maildrop(X ) , X) -> ?.internal_threadkit_types::Mailop(X );
                same_maildrop : (Maildrop(X ) , Maildrop(X )) -> Bool;
                make_run_gun : Void -> {fire_run_gun:Void -> Void, run_gun':mailop::Run_Gun};
                make_end_gun : Void -> {end_gun':mailop::End_Gun, fire_end_gun:Void -> Void};
                maildrop_to_string : (Maildrop(X ) , String) -> String;
                Oneshot_Maildrop X;
                exception MAY_NOT_FILL_ALREADY_FULL_ONESHOT_MAILDROP;
                make_oneshot_maildrop : Void -> Oneshot_Maildrop(X );
                put_in_oneshot : (Oneshot_Maildrop(X ) , X) -> Void;
                get_from_oneshot : Oneshot_Maildrop(X ) -> X;
                get_from_oneshot' : Oneshot_Maildrop(X ) -> ?.internal_threadkit_types::Mailop(X );
                nonblocking_get_from_oneshot : Oneshot_Maildrop(X ) -> Null_Or(X );
                same_oneshot_maildrop : (Oneshot_Maildrop(X ) , Oneshot_Maildrop(X )) -> Bool;
                Mailqueue X;
                make_mailqueue : ?.internal_threadkit_types::Microthread -> Mailqueue(X );
                same_mailqueue : (Mailqueue(X ) , Mailqueue(X )) -> Bool;
                put_in_mailqueue : (Mailqueue(X ) , X) -> Void;
                take_from_mailqueue : Mailqueue(X ) -> X;
                take_from_mailqueue' : Mailqueue(X ) -> ?.internal_threadkit_types::Mailop(X );
                take_all_from_mailqueue : Mailqueue(X ) -> List(X );
                take_all_from_mailqueue' : Mailqueue(X ) -> ?.internal_threadkit_types::Mailop(List(X ) );
                mailqueue_to_string : (Mailqueue(X ) , String) -> String;
                get_mailqueue_reader : Mailqueue(X ) -> ?.internal_threadkit_types::Microthread;
                get_mailqueue_id : Mailqueue(X ) -> Int;
                get_mailqueue_length : Mailqueue(X ) -> Int;
                get_mailqueue_putcount : Mailqueue(X ) -> Int;
                drop_mailqueue_tap : (Mailqueue(X ) , Ref(Void )) -> Void;
                note_mailqueue_tap : (Mailqueue(X ) , (X -> Void)) -> Ref(Void );
                Mailcaster X;
                Readqueue X;
                make_mailcaster : Void -> Mailcaster(X );
                make_readqueue : Mailcaster(X ) -> Readqueue(X );
                clone_readqueue : Readqueue(X ) -> Readqueue(X );
                receive : Readqueue(X ) -> X;
                receive' : Readqueue(X ) -> ?.internal_threadkit_types::Mailop(X );
                transmit : (Mailcaster(X ) , X) -> Void;
                Mailop X;
                Run_Gun  = Mailop(Void );
                End_Gun  = Mailop(Void );
                do_one_mailop : List(Mailop(X ) ) -> X;
                ==> : (Mailop(X ) , (X -> Y)) -> Mailop(Y );
                Replyqueue;
                make_replyqueue : Void -> Replyqueue;
                put_in_replyqueue : (Replyqueue , Mailop(Void )) -> Void;
                do_one_mailop' : Replyqueue -> List(Mailop(Void ) ) -> Void;
                replyqueue_to_string : (Replyqueue , String) -> String;
                dynamic_mailop : (Void -> Mailop(X )) -> Mailop(X );
                dynamic_mailop_with_nack : (Mailop(Void ) -> Mailop(X )) -> Mailop(X );
                never' : Mailop(X );
                always' : X -> Mailop(X );
                if_then' : (Mailop(X ) , (X -> Y)) -> Mailop(Y );
                make_exception_handling_mailop : (Mailop(X ) , (Exception -> X)) -> Mailop(X );
                cat_mailops : List(Mailop(X ) ) -> Mailop(X );
                block_until_mailop_fires : Mailop(X ) -> X;
                state_to_string : microthread::state::State -> String;
                get_or_make_current_cleanup_task : Void -> ?.internal_threadkit_types::Apptask;
                note_thread_cleanup_action : (Void -> Void) -> Void;
                note_task_cleanup_action : (Void -> Void) -> Void;
                timeout_in' : Float -> ?.Mailop(Void );
                timeout_at' : time::Time -> ?.Mailop(Void );
                sleep_for : Float -> Void;
                sleep_until : time::Time -> Void;
                start_up_thread_scheduler : (Void -> Void) -> Int;
                start_up_thread_scheduler' : time::Time -> (Void -> Void) -> Int;
                run_under_thread_scheduler : (Void -> X) -> Void;
                shut_down_thread_scheduler : Int -> X;
                spawn_to_disk : (String , ((String , List(String )) -> Int) , Null_Or(time::Time )) -> Void;
                When  = APP_SHUTDOWN | APP_STARTUP | COMPILER_STARTUP | THREADKIT_SHUTDOWN;
                when_to_string : When -> String;
                    note_startup_or_shutdown_action :
                    (String , List(When ) , (When -> Void)) -> Null_Or(((List(When ) , (When -> Void))) );
                forget_startup_or_shutdown_action : String -> Null_Or(((List(When ) , (When -> Void))) );
                exception NO_SUCH_ACTION;
                note_mailqueue : (String , mailqueue::Mailqueue(X )) -> Void;
                forget_mailqueue : String -> Void;
                note_mailslot : (String , ?.mailslot::Mailslot(X )) -> Void;
                forget_mailslot : String -> Void;
                note_imp : {at_shutdown:Void -> Void, at_startup:Void -> Void, name:String} -> Void;
                forget_imp : String -> Void;
                forget_all_mailslots_mailqueues_and_imps : Void -> Void;};;
    redump_heap : String -> Void;};
\end{verbatim}\index[fun]{redump\_heap}
\index[fun]{forget\_all\_mailslots\_mailqueues\_and\_imps}
\index[fun]{forget\_imp}
\index[fun]{note\_imp}
\index[fun]{forget\_mailslot}
\index[fun]{note\_mailslot}
\index[fun]{forget\_mailqueue}
\index[fun]{note\_mailqueue}
\index[fun]{forget\_startup\_or\_shutdown\_action}
\index[fun]{note\_startup\_or\_shutdown\_action}
\index[fun]{when\_to\_string}
\index[fun]{spawn\_to\_disk}
\index[fun]{shut\_down\_thread\_scheduler}
\index[fun]{run\_under\_thread\_scheduler}
\index[fun]{start\_up\_thread\_scheduler\_\_prime\_\_}
\index[fun]{start\_up\_thread\_scheduler}
\index[fun]{sleep\_until}
\index[fun]{sleep\_for}
\index[fun]{timeout\_at\_\_prime\_\_}
\index[fun]{timeout\_in\_\_prime\_\_}
\index[fun]{note\_task\_cleanup\_action}
\index[fun]{note\_thread\_cleanup\_action}
\index[fun]{get\_or\_make\_current\_cleanup\_task}
\index[fun]{state\_to\_string}
\index[fun]{block\_until\_mailop\_fires}
\index[fun]{cat\_mailops}
\index[fun]{make\_exception\_handling\_mailop}
\index[fun]{if\_then\_\_prime\_\_}
\index[fun]{always\_\_prime\_\_}
\index[fun]{never\_\_prime\_\_}
\index[fun]{dynamic\_mailop\_with\_nack}
\index[fun]{dynamic\_mailop}
\index[fun]{replyqueue\_to\_string}
\index[fun]{do\_one\_mailop\_\_prime\_\_}
\index[fun]{put\_in\_replyqueue}
\index[fun]{make\_replyqueue}
\index[fun]{==>}
\index[fun]{do\_one\_mailop}
\index[fun]{transmit}
\index[fun]{receive\_\_prime\_\_}
\index[fun]{receive}
\index[fun]{clone\_readqueue}
\index[fun]{make\_readqueue}
\index[fun]{make\_mailcaster}
\index[fun]{note\_mailqueue\_tap}
\index[fun]{drop\_mailqueue\_tap}
\index[fun]{get\_mailqueue\_putcount}
\index[fun]{get\_mailqueue\_length}
\index[fun]{get\_mailqueue\_id}
\index[fun]{get\_mailqueue\_reader}
\index[fun]{mailqueue\_to\_string}
\index[fun]{take\_all\_from\_mailqueue\_\_prime\_\_}
\index[fun]{take\_all\_from\_mailqueue}
\index[fun]{take\_from\_mailqueue\_\_prime\_\_}
\index[fun]{take\_from\_mailqueue}
\index[fun]{put\_in\_mailqueue}
\index[fun]{same\_mailqueue}
\index[fun]{make\_mailqueue}
\index[fun]{same\_oneshot\_maildrop}
\index[fun]{nonblocking\_get\_from\_oneshot}
\index[fun]{get\_from\_oneshot\_\_prime\_\_}
\index[fun]{get\_from\_oneshot}
\index[fun]{put\_in\_oneshot}
\index[fun]{make\_oneshot\_maildrop}
\index[fun]{maildrop\_to\_string}
\index[fun]{make\_end\_gun}
\index[fun]{make\_run\_gun}
\index[fun]{same\_maildrop}
\index[fun]{maildrop\_swap\_\_prime\_\_}
\index[fun]{maildrop\_swap}
\index[fun]{nonblocking\_get\_from\_maildrop}
\index[fun]{get\_from\_maildrop\_\_prime\_\_}
\index[fun]{get\_from\_maildrop}
\index[fun]{nonblocking\_take\_from\_maildrop}
\index[fun]{take\_from\_maildrop\_\_prime\_\_}
\index[fun]{take\_from\_maildrop}
\index[fun]{put\_in\_maildrop}
\index[fun]{make\_full\_maildrop}
\index[fun]{make\_empty\_maildrop}
\index[fun]{nonblocking\_take\_from\_mailslot}
\index[fun]{nonblocking\_put\_in\_mailslot}
\index[fun]{take\_from\_mailslot\_\_prime\_\_}
\index[fun]{put\_in\_mailslot\_\_prime\_\_}
\index[fun]{take\_from\_mailslot}
\index[fun]{put\_in\_mailslot}
\index[fun]{same\_mailslot}
\index[fun]{make\_mailslot}
\index[fun]{make\_boolean\_per\_thread\_property}
\index[fun]{make\_per\_thread\_property}
\index[fun]{run\_thread\_\_xu}
\index[fun]{yield}
\index[fun]{task\_done\_\_mailop}
\index[fun]{thread\_done\_\_mailop}
\index[fun]{thread\_exit}
\index[fun]{make\_task}
\index[fun]{make\_thread}
\index[fun]{make\_thread\_\_prime\_\_}
\index[fun]{get\_exception\_that\_killed\_task}
\index[fun]{get\_exception\_that\_killed\_thread}
\index[fun]{get\_thread\_\_prime\_\_s\_task}
\index[fun]{get\_thread\_\_prime\_\_s\_state}
\index[fun]{get\_thread\_\_prime\_\_s\_name}
\index[fun]{get\_thread\_\_prime\_\_s\_id\_as\_string}
\index[fun]{get\_thread\_\_prime\_\_s\_id}
\index[fun]{kill\_task}
\index[fun]{kill\_thread}
\index[fun]{hash\_thread}
\index[fun]{compare\_thread}
\index[fun]{same\_thread}
\index[fun]{compare\_task}
\index[fun]{same\_task}
\index[fun]{get\_task\_\_prime\_\_s\_alive\_threads\_count}
\index[fun]{get\_task\_\_prime\_\_s\_state}
\index[fun]{get\_task\_\_prime\_\_s\_name}
\index[fun]{get\_task\_\_prime\_\_s\_id}
\index[fun]{get\_current\_microthread\_\_prime\_\_s\_id}
\index[fun]{get\_current\_microthread\_\_prime\_\_s\_name}
\index[fun]{get\_current\_microthread}
\index[fun]{default\_microthread}
\index[fun]{eval\_kludge\_ref\_list\_string}
\index[fun]{eval\_kludge\_ref\_list\_float}
\index[fun]{eval\_kludge\_ref\_list\_int}
\index[fun]{eval\_kludge\_ref\_string}
\index[fun]{eval\_kludge\_ref\_float}
\index[fun]{eval\_kludge\_ref\_int}
\index[fun]{mayexecute}
\index[fun]{maywrite}
\index[fun]{mayread}
\index[fun]{isblockdev}
\index[fun]{ischardev}
\index[fun]{issocket}
\index[fun]{issymlink}
\index[fun]{ispipe}
\index[fun]{isdir}
\index[fun]{isfile}
\index[fun]{argv}
\index[fun]{arg0}
\index[fun]{dotqquotes\_\_op}
\index[fun]{words}
\index[fun]{unlink}
\index[fun]{uniquesort}
\index[fun]{trim}
\index[fun]{tokens}
\index[fun]{toupper}
\index[fun]{tolower}
\index[fun]{time}
\index[fun]{symlink}
\index[fun]{sum}
\index[fun]{struniqsort}
\index[fun]{strsort}
\index[fun]{strlen}
\index[fun]{strcat}
\index[fun]{stat}
\index[fun]{sscanf}
\index[fun]{scanf}
\index[fun]{sorted}
\index[fun]{sort}
\index[fun]{sleep}
\index[fun]{shuffle}
\index[fun]{shuffle\_\_prime\_\_}
\index[fun]{round}
\index[fun]{rmdir}
\index[fun]{rename}
\index[fun]{product}
\index[fun]{now}
\index[fun]{lstat}
\index[fun]{join}
\index[fun]{join\_\_prime\_\_}
\index[fun]{isprime}
\index[fun]{isodd}
\index[fun]{iseven}
\index[fun]{in}
\index[fun]{implode}
\index[fun]{setuid}
\index[fun]{setsid}
\index[fun]{setpgid}
\index[fun]{setgid}
\index[fun]{mkdir}
\index[fun]{getpgrp}
\index[fun]{getlogin}
\index[fun]{getgroups}
\index[fun]{getegid}
\index[fun]{getgid}
\index[fun]{getppid}
\index[fun]{geteuid}
\index[fun]{getuid}
\index[fun]{getpid}
\index[fun]{getenv}
\index[fun]{getcwd}
\index[fun]{fscanf}
\index[fun]{filter}
\index[fun]{fields}
\index[fun]{factors}
\index[fun]{explode}
\index[fun]{exit\_x}
\index[fun]{exit}
\index[fun]{evalls}
\index[fun]{evallf}
\index[fun]{evalli}
\index[fun]{evals}
\index[fun]{evalf}
\index[fun]{evali}
\index[fun]{eval}
\index[fun]{environ}
\index[fun]{dirname}
\index[fun]{die\_x}
\index[fun]{die}
\index[fun]{chomp}
\index[fun]{chdir}
\index[fun]{bin\_sh\_\_prime\_\_}
\index[fun]{bin\_sh}
\index[fun]{basename}
\index[fun]{backticks\_\_op}
\index[fun]{atoi}
\index[fun]{atod}
\index[fun]{=~}
\index[fun]{\_[]:=}
\index[fun]{\_\_\_bang\_\_}
\index[fun]{graph}
\index[fun]{build\_executable\_heap\_image}
\index[fun]{load\_plugin}
\index[fun]{get\_makelib\_preprocessor\_symbol\_value}
\index[fun]{sources}
\index[fun]{dump\_latex}
\index[fun]{dump}
\index[fun]{clear\_state}
\index[fun]{unshare}
\index[fun]{dismiss}
\index[fun]{os\_string}
\index[fun]{describe}
\index[fun]{known}
\index[fun]{parse\_caching}
\index[fun]{generate\_index}
\index[fun]{conserve\_memory}
\index[fun]{debug}
\index[fun]{warn\_on\_obsolete\_syntax}
\index[fun]{verbose}
\index[fun]{keep\_going\_after\_compile\_errors}
\index[fun]{link\_and\_run\_package\_closure}
\index[fun]{compile\_raw\_declaration\_to\_package\_closure}
\index[fun]{parse\_string\_to\_raw\_declarations}
\index[fun]{show\_pkg}
\index[fun]{show\_api}
\index[fun]{set\_control}
\index[fun]{show\_control}
\index[fun]{show\_controls}
\index[fun]{search\_lib\_load\_path\_for\_file}
\index[fun]{show\_generics}
\index[fun]{show\_types}
\index[fun]{show\_vals}
\index[fun]{show\_pkgs}
\index[fun]{show\_apis}
\index[fun]{show\_all}
\index[fun]{freeze\_\_prime\_\_}
\index[fun]{freeze}
\index[fun]{compile}
\index[fun]{use}
\index[fun]{load}
\index[fun]{make}
\index[fun]{help}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
