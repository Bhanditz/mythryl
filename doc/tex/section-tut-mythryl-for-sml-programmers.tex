
% --------------------------------------------------------------------------------
\subsection{SML vs Mythryl}
\cutdef*{subsubsection}

Mythryl is essentially {\sc SML/NJ} with a Posix face, so if you are already familiar with 
SML you will have an easy time learning Mythryl;  all you need to learn are the differences 
and the new facilities.

\cutend*

% --------------------------------------------------------------------------------
\subsection{Mythryl printf}
\cutdef*{subsubsection}

{\it (We discuss} {\tt printf} {\it early due to its frequent use in examples.)}

There have been a number of attempts to match the conciseness and 
convenience of the C {\tt printf()} function in the SML setting. 
All of them suffer by comparison.

The core problem is that C is taking advantage of the type information 
implicit in the format string, whereas the SML solutions all wind 
up replicating that type information in the argument expression.  No 
matter how cleverly this is done, it introduces enough syntactic 
redundancy to make the solution verbose and clumsy.

Mythryl bites the bullet by treating {\tt printf} (also {\tt sprintf} and 
{\tt fprintf}) as derived forms which are expanded early in the 
compiler front end into the underlying verbose syntax.

This expansion extracts the implicit type information from the format 
string, making it visible to the Mythryl typechecker, and thus making 
the entire construct work with a satisfying lack of visible redundancy.

This solution is a bit of a kludgey hack from a conceptual point of view. 
For example, aside from complicating the compiler with a special case 
hack, it means that the format string must be a constant known at 
compile time for this mechanism to work.

But this hack is an enormous win from a practical point of view, making 
common text formatting tasks markedly more pleasant:

\begin{verbatim}
    printf "%g %s %d\n" 1.2 "foo" 32;
\end{verbatim}

The implemented syntax uses curried arguments and thus allows partial 
application of {\tt printf} statements, which can occasionally be useful.

The limitation of the form to working only with format-strings 
known constant at compiler time is not a major restriction in practice. 
In the rare cases where the format string must be computed at runtime, 
one can always fall back to the underlying syntax: 

\begin{verbatim}
    sfprintf::printf' (compute_formatstring ()) [ sfprintf::FLOAT 1.2, sfprintf::STRING "foo", sfprintf::INT 32 ];
\end{verbatim}

where {\tt compute\_formatstring} is some user-supplied function. 

As always, one may of course dispense with the qualifiers via wholesale importation: 
\begin{verbatim}
    include sfprintf;
    printf' (compute_formatstring ()) [ FLOAT 1.2, STRING "foo", INT 32 ];
\end{verbatim}


The same comments apply, {\it mutatis mutandis,}  to {\tt sprintf} and {\tt fprintf}, all of which are ultimately implemented by the 
\ahrefloc{pkg:sfprintf}{sfprintf} package, with an assist from 
\ahrefloc{src/lib/compiler/front/parser/raw-syntax/printf-format-string-to-raw-syntax.pkg}{src/lib/compiler/front/parser/raw-syntax/printf-format-string-to-raw-syntax.pkg}.

\cutend*

% --------------------------------------------------------------------------------
\subsection{Non-Syntactic Differences}
\cutdef*{subsubsection}
Non-syntactic differences include:

\begin{itemize}

\item Mythryl programs may be invoked script-style via a shebang line:
\begin{verbatim}
#!/usr/bin/mythryl
printf "%s, %s!\n" "Hello" "world";
\end{verbatim}

\item Mythryl code fragments may be executed at the commandline or embedded in scripts:
\begin{verbatim}
shell%  my -x '5!'
120
shell%
\end{verbatim}

\item Mythryl heap images contain shebang lines, allowing them to be executed without 
wrapper scripts.

\item Mythryl uses a conventional makefile hierarchy to drive system compilation.

\item Mythryl installs via a conventional tarball download followed by a conventional 
build process driven by the {\sc GNU} {\tt autoconfig} and {\tt make} tools.

\item Mythryl has a library documentation suite which is largely mechanically generated 
for accuracy and currency, heavily hyperlinked for convenience.  The system codebase 
is hyperlinked into the overall documentation suite for reference.

\item The Mythryl codebase has been heavily edited to make it more accessible to the nonspecialist. 
A uniform code style has been adopted to improve readability. The directory structure has been 
rationalized.

\end{itemize}

\cutend*


% --------------------------------------------------------------------------------
\subsection{Broad Syntactic Differences}
\cutdef*{subsubsection}

{\sc SML} and Mythryl differ most markedly on syntax.  Mythryl's syntax is 
engineered to make the best use possible of C-based intuition. 
Mythryl's syntax fits squarely into Posix tradition.  The entire Mythryl 
codebase has been translated into the new syntax. 

At a very broad level, the major syntactic differences between {\sc SML} and Mythryl are: 
\begin{itemize}
\item Mythryl ends every complete declaration and statement with a semicolon.
\item Mythryl is more sensitive to the presence or absence of whitespace: {\tt f-g} differs from {\tt f -g}. (Subtraction vs negation.)
\item Mythryl frequently uses braces for scoping.
\item Mythryl assigns different semantics to lower\_case, Mixed\_Case and UPPER\_CASE identifiers.
\end{itemize}

The latter is worth expanding upon.  The Mythryl compiler requires that 
\begin{itemize}
\item Value, function and package names be in lower\_case.
\item Type and API (signature) names be in Mixed\_Case.
\item Constructor and exception names be in UPPER\_CASE.
\item Type variables be A B C ... X Y Z or else A\_mumble C\_mumble or such. (Single initial capital letter.)
\end{itemize}

(One point of this convention is to encourage the user to think of 
generics (functors) as functions over packages (structures) with 
apis (signatures) as types.)

One consequence of these conventions is that misspelled constructor names 
in a pattern now draw a compile-time error instead of silently compiling 
incorrect code.

Another consequence of these conventions is that most of {\sc SML}'s 
start of line syntactic noise can be dropped.  Vanilla 
value bindings are now just {\tt x = 12;} and vanilla uniontype 
declarations are now just {\tt Color = RED | GREEN | BLUE;}. 

\cutend*

% --------------------------------------------------------------------------------
\subsection{SML vs Mythryl Fragment Equivalence Table}
\cutdef*{subsubsection}

Here is a table of SML syntax fragments with Mythryl equivalents: 

\begin{tabular}{|l|l|l|} \hline
{\bf SML} & {\bf Mythryl} & {\bf Comment} \\ \hline \hline
{\tt .sig} & {\tt .api} & Default signature file extension has changed. \\ \hline
{\tt .sml} & {\tt .pkg} & Default structure file extension has changed. \\ \hline
{\tt .cm} & {\tt .lib} & ".lib" file extension has better C intuition. \\ \hline
(* A comment. *) & \# A comment. & Mythryl follows scripting comment convention. \\ \hline
(* A comment. *) & /* A comment. */ & Mythryl also supports C-style comments. \\ \hline
{\tt true false} & {\tt TRUE FALSE} & Mythryl constructors are consistently upper case. \\ \hline
{\tt open my\_package;} & {\tt include my\_package;} & Better C intuition, frees {\tt open} for I/O use. \\ \hline
{\tt unit} & {\tt Void} & 'Void' carries better C intuition. \\ \hline
{\tt real} & {\tt Float} & 'Float' carries better C intuition. \\ \hline
{\tt NONE} & {\tt NULL} & 'NULL' carries better C intuition. \\ \hline
{\tt SOME x} & {\tt THE x} & 'THE' avoids sounding like a quantifier. \\ \hline
{\tt int option} & {\tt Null\_Or(Int)} & Latter carries better C intuition. \\ \hline
{\tt string list} & {\tt List(String)} & Mythryl type functions are prefix. \\ \hline
'a list & List(X) & Mythryl type variables are alphabetic. \\ \hline
(none) & x = `ls -l`; & Mythryl supports user-redefinable Perl-flavored backtick operator. \\ \hline
\verb|#\a| & 'a' & Mythryl supports C-flavored character constants. \\ \hline
\verb|~2| & -2 & Mythryl uses dash for unary negation, like most languages. \\ \hline
a :: b & a ! b & Mythryl uses '!' for list construction. \\ \hline
a = (b = c) & a = (b == c) & Mythryl distinguishes equality (==) from binding (=). \\ \hline
!ptr & *ptr & Per C intuition, Mythryl dereferences via prefix asterisk. \\ \hline
abs a & |a| & Mythryl supports circumfix operators. \\ \hline
factorial 5 & 5! & Mythryl supports postfix operators. \\ \hline
not a & !a & Mythryl supports usual C negation convention. \\ \hline
not a & not a & Mythryl also supports this. \\ \hline
a bit\_or b & a | b & Mythryl supports C inclusive-or syntax. \\ \hline
a andalso b & a and b & Mythryl short-circuit ops follow Perl \& kith. \\ \hline
a orelse b & a or b & Ditto. \\ \hline
mystructure.myfunction & mypackage::myfunction & Mythryl follows C++ convention. \\ \hline
\#field record & record.field & Mythryl follows C convention. \\ \hline
\#field record & .field record & Mythryl still supports fieldname-as-function. \\ \hline
(none) & for (x=0; x<12; ++x) \{ ... \} & Mythryl implements C-flavored (but pure-functional) for-loop. \\ \hline
(none) & x where ... end; & Mythryl implements where clauses. \\ \hline
format \verb|"%d\n"| [ INT 12 ] & printf \verb|"%d\n"| 12; & Mythryl implements Perl-flavored printf. \\ \hline
let val x = 12 in x+2 end & \{ x = 12; x+2; \} & Mythryl implements C-flavored blocks. \\ \hline
case ... & case ... esac & Mythryl supplies the missing 'esac' terminator. \\ \hline
if ... & if ... fi & Mythryl supplies the missing 'fi' terminator. \\ \hline
if foo then print \verb|"Hi!\n"| else () & if foo print \verb|"Hi!\n"| fi & Missing else clause defaults to () in Mythryl. \\ \hline
(none) & if ... elif ... else ... fi & Mythryl supports 'elif'. \\ \hline
val x = if y then 2 else 3 & x = y ?? 2 :: 3; & Mythryl supports C-flavored conditional. \\ \hline
handle & except & ``except'' clarifies the tie to exception handling. \\ \hline
structure & package &  ``struct'' means ``record'' to C intuition so we avoid the word. \\ \hline
signature & api &  ``api'' carries better C intuition. \\ \hline
functor & generic package &  ``generic package'' carries better C intuition. \\ \hline
signature Foo = sig ... end & api Foo \{ ... \}; & This syntax is more compact and more C-intuitive. \\ \hline
structure foo = struct ... end & package foo \{ ... \}; & Ditto. \\ \hline
sig ... end & api \_ \{ ... \}; & We avoid spending a reserved word for anonymous case. \\ \hline
struct ... end & package \_ \{ ... \}; & Ditto. \\ \hline
my\_struct :> my\_sig & my\_package: my\_api & Mythryl gives strong sealing the compact syntax. \\ \hline
my\_struct : my\_sig & my\_package: (weak) my\_api & Mythryl weak sealing syntax is clear and extensible. \\ \hline
op + & (+) & Concise Haskell syntax for quoting infix ops. ("op" is not a reserved word in Mythryl.) \\ \hline
infix +++ ; & infix my +++ ; & "infix" is not a reserved word in Mythryl. (Nor, e.g., "type", "in", "do" or "let".) \\ \hline
\end{tabular}
\cutend*

% --------------------------------------------------------------------------------
\subsection{SML vs Mythryl Extended Example}
\cutdef*{subsubsection}
At this point, a pair of matching code examples, one in SML, one in Mythryl, should 
give good intuition.  First the SML version:

\begin{verbatim}
signature My_Api = sig
    uniontype Color = RED | GREEN | BLUE
    uniontype Point = TWO_D of (real * real) | THREE_D of (real * real * realt)
    val say_hello: unit -> unit
    val dist: ((real * real) * (real * real)) -> real
    val sum:  int list -> int
end

structure my_package :> My_Api = struct
    uniontype Color = RED | GREEN | BLUE
    uniontype Point = TWO_D of (real * real) | THREE_D of (real * real * real)
    fun say_hello () = print "Hello!\n"
    fun dist ((x0,y0), (x1,y1))
        =
        let val delta_x = x1 - x0
            val delta_y = y1 - y0
        in
            delta_x * delta_x
            +
            delta_y * delta_y
        end

    fun sum ints
        =
        let fun sum' ([],      result) => result
              | sum' (i :: is, result) => sum' (is, i + result)
        in
            sum' (ints, 0)
        end
end
\end{verbatim}


Now the Mythryl version:

\begin{verbatim}
api My_Api {
    Color = RED | GREEN | BLUE;
    Point = TWO_D (Float, Float) | THREE_D (Float, Float, Float);
    say_hello: Void -> Void;
    mult: (Int, Int) -> Int;
    sum:  ((Float,Float), (Float,Float)) -> Float;
};

package my_package: My_Api {
    Color = RED | GREEN | BLUE;
    Point = TWO_D (Float, Float) | THREE_D (Float, Float, Float);
    fun say_hello () = print "Hello!\n";
    fun dist ((x0,y0), (x1,y1))
        =
        {   delta_x = x1 - x0;
            delta_y = y1 - y0;

            delta_x * delta_x
            +
            delta_y * delta_y;
        };
    fun sum ints
        =
        sum' (ints, 0)
        where
            fun sum' ([],     result) => result;
                sum' (i ! is, result) => sum' (is, i + result);
            end;
        end;
};

\end{verbatim}
\cutend*


% --------------------------------------------------------------------------------
\subsection{Mythryl Invocation}
\cutdef*{subsubsection}

Mythryl code can be run six basic ways:
\begin{enumerate}
\item Mono-file programs can be run script-style by putting a {\tt #!/usr/bin/mythryl} shebang line at the top and chmod-ing them to be executable.
\item Multi-file programs may be compiled and run as usual via the compile manager, renamed {\tt makelib}.
\item Applications dumped as binary heap images via {\tt spawn\_to\_disk} contain {\tt #!/usr/bin/mythryl} shebang lines allowing direct execution without script wrappers.
\item One-line expressions may be interactive executed at the Mythryl prompt by invoking {\tt my} without arguments.
\item Short expressions may be evaluated at the linux prompt or backquoted from bash scripts etc: {\tt my -e $'6!'$}
\item Mythryl programs may compile and execute Mythryl expressions on the fly via {\tt eval}.
\end{enumerate}

Of the six, the first, script-style invocation, is the most generally useful.  The 
second is indispensable for development of large projects, typically in conjunction 
with the third.

\cutend*

% --------------------------------------------------------------------------------
\subsection{Mythryl Constants}
\cutdef*{subsubsection}

\begin{itemize}
\item Mythryl character constants follow the C model: {\tt \verb|'a' '\n' '\000'|}
\item Mythryl decimal integer constants are as expected: {\tt 12}
\item Mythryl negative constants use dash instead of tilde: -{\tt 12}
\item Mythryl hexadecimal integer constants follow the C model: {\tt 0x1AF}
\item Mythryl octal integer constants also follow the C model: {\tt 0377}
\item Boolean constants are uppercase like all Mythryl constructors: {\tt TRUE FALSE}
\item In Mythryl {\tt option} becomes {\tt Null\_Or}. {\tt NONE, SOME x} become {\tt NULL, THE x}.
\item In Mythryl {\tt unit} becomes {\tt Void}. The value syntax is unchanged:  {\tt ()}
\end{itemize}


\cutend*

% --------------------------------------------------------------------------------
\subsection{Mythryl Pattern-Matching}
\cutdef*{subsubsection}

The general form of a Mythryl pattern match statement is

\begin{quote}
    my {\it pattern} = {\it expression};
\end{quote}

The possibilities here are essentially unchanged from SML:

\begin{tabular}{|l|l|} \hline
{\bf Mythryl Code} & {\bf Comment} \\ \hline \hline
my x = 12; & Bind a variable to value. \\ \hline
x = 12; & ``my'' may be dropped when pattern is a lone identifier. \\ \hline
my (x, y) = (12, 13); & Pattern-matching against a tuple. \\ \hline
my (x, \_) = (12, 13); & Partial matching of a tuple. \\ \hline
my (\_, x, \_) = (12, 13, 14); & Fancier version of same. \\ \hline
my \{ x => x, y => y \} = \{x => 12, y => 13\}; & Pattern-matching against a record. \\ \hline
my \{ x, y \} = \{x => 12, y => 13\}; & Convenient abbreviation for previous case. \\ \hline
my \{ x, y \} = \{x, y\}; & Same abbreviation may be used when constructing record. \\ \hline
my \{ x, ... \} = \{x => 12, y => 13\}; & Partial pattern-matching against a record. \\ \hline
my r as \{ x, ... \} = \{x => 12, y => 13\}; & As above, but {\it r} matches complete record. \\ \hline
my (x ! xs) = [ 12, 13 ]; & Match against a list. \\ \hline
\end{tabular}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Mythryl Code Blocks}
\cutdef*{subsubsection}

The original C block syntax required all declarations to precede all statements:
\begin{verbatim}
    { int i = 12;
      float f = 1.0;
      printf("%d %f\n", i, f);
    }
\end{verbatim}

This proved very unpopular in practice, and first {\tt C++} and then {\tt C99} relaxed 
the syntax to allow arbitrary interleaving of declarations and statements within a code 
block.

\begin{verbatim}
    { int i = 12;     printf("%d\n", i);
      float f = 1.0;  printf("%f\n", f);
    }
\end{verbatim}

A somewhat similar progression may be observed in SML.  Officially, {\tt let} syntax 
supports only declarations followed by statements:

\begin{verbatim}
    let val i = 12
        val f = 1.0
    in
        format "%d %f\n" [ INT i, REAL f ]
    end
\end{verbatim}

What one sees in practice, however, is syntax like 

\begin{verbatim}
    let val i = 12      val _ = format "%d\n" [ INT i ]
        val f = 1.0 in          format "%f\n" [ REAL f ]
    end
\end{verbatim}

where it is perfectly clear that the intent of the programmer is 
to interleave declarations and statements freely via the {\tt val \_ = ...} 
hack, whatever the clear intent of the language designers.

Mythryl code blocks are patterned syntactically after C code blocks, but 
are derived forms which internally expand into standard ML {\tt let} statements via 
the above {\tt val \_ = ...} hack.  To some extent, this gives Mythryl 
the best of both worlds;  the application programmer gets the freedom of 
interleaving declarations and statements in natural order, while the Mythryl 
theoretician still gets the analytical perspicuity of the {\tt let} form 
(since theoreticians dismiss derived forms from consideration).

Thus, the Mythryl equivalent of the above is

\begin{verbatim}
    { i = 12;     printf "%d\n" i;
      f = 1.0;    printf "%f\n" f;
    }
\end{verbatim}


\cutend*


% --------------------------------------------------------------------------------
\subsection{Mythryl Functions}
\cutdef*{subsubsection}

Code blocks aside, the core differences between basic SML and Mythryl function 
syntax are that

\begin{itemize}

\item Mythryl consistently uses {\tt =>} to flag multiway {\tt case} 
style constructs and {\tt =} to flag monocase bindings.

\item Mythryl uses a terminal {\tt end} in the multiway cases.

\item Mythryl delimits cases with terminal semicolons rather than initial bars, 
freeing up the latter identifier for application programmer use.

\item Mythryl links mutually recursive functions with {\tt also} rather than 
{\tt and}, reserving the latter identifier for short-circuit conditionals.
\end{itemize}

\begin{verbatim}
    fun f x = x;                      # Monocase form.

    fun f [] => printf "Empty\n";     # Multicase form.
        f x  => printf "Nonempty;
    end;

    fun f x = g x                     # Muturally recursive case.
    also                              # Note lack of semicolon before 'also':
    fun g x = f x;                    # semicolon always marks a complete construct.

    fn x = x;                         # Monocase form of anonymous function.

    fn [] => printf "Empty\n";        # Multicase form of anonymous function.
       x  => printf "Nonempty\n";
    end;

    .{ printf "Foo\n"; }              # Equivalent to   fn () = printf "Foo\n";

    .{ #x == #y; }                    # Equivalent to   fn (x, y) = (x == y);
\end{verbatim}

The latter two forms are intended to facilitate application-programmer 
creation of functions which can be used like traditional iterative 
constructs.  For example given the definition

\begin{verbatim}
    fun foreach []         thunk =>  ();
        foreach (a ! rest) thunk =>  { thunk(a);   foreach rest thunk; };
    end;
\end{verbatim}

(which is in fact part of the Mythryl standard library) one can then write 
code like

\begin{verbatim}
    foreach [ "red", "green", "blue" ] .{
        printf "Color %s encountered\n" #color;
    };
\end{verbatim}

thus obtaining most of the convenience of hardwired {\tt foreach} loops 
in languages like {\tt Python} without having to hammer each such construct 
explicitly into the compiler proper.

A more typical use of this construct would be to list all the files in 
the current directory:

\begin{verbatim}
    foreach (dir::entry_names ".") .{ printf "%s\n" #filename; };
\end{verbatim}


Since the standard library infix function invocation {\tt 1 .. 10} generates 
a list {\tt [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]} one can also write loops like 

\begin{verbatim}
    foreach (1 .. 10) .{
        printf "Loop %d\n" #i;
    };
\end{verbatim}

although the explicitly constructed list makes this inefficient for large 
iteration counts.

\cutend*

% --------------------------------------------------------------------------------
\subsection{Mythryl Conditionals}
\cutdef*{subsubsection}

The Mythryl {\tt case} statement is essentially identical to that of SML 
except for the addition of the long longed-for {\tt esac} terminator:

\begin{verbatim}
    case (foo)
    1 => printf "I\n";
    2 => printf "II\n";
    3 => printf "III\n";
    _ => printf "Many!\n";
    esac;
\end{verbatim}

The Mythryl {\tt if} statement differs more from that of SML. 
The {\it then} and {\it else} clauses comprise implicit code 
blocks, which in many cases considerably reduces code verbosity. 
Also, the Mythryl version supplies a terminal {\tt fi} in honor 
of the late Dijkstra:

\begin{verbatim}
    if  good                           # Conditional parens not needed around lone identifier.
        printf "Very good.\n";
        printf "Yes, very good indeed!\n";
    else
        printf "Not good.\n";
        printf "Doubleplus ungood!\n";
    fi;
\end{verbatim}

Also, unlike SML, Mythryl allows the {\it else} clause to be 
dropped, in which case its value defaults to {\tt Void}:

\begin{verbatim}
    if  good
        printf "Very good.\n";
        printf "Yes, very good indeed!\n";
    fi;
\end{verbatim}

In additional to vanilla {\tt if}, Mythryl also supports 
a C-flavored trinary conditional expression {\tt ... ?? ... :: ...}:

\begin{verbatim}
    sprintf "%d cow%s" cows (cows > 1 ?? "s" :: "");
\end{verbatim}

Finally, the {\tt and} and {\tt or} boolean operators are implemented using 
short-circuit evaluation, making them implicit conditionals:

\begin{verbatim}
    if (f != 0.0
        and
        (1.0 / f) > 2.0      # Cannot throw divide-by-zero exception.
       )
       printf "I feel silly!\n";
    fi;
\end{verbatim}

\cutend*


% --------------------------------------------------------------------------------
\subsection{Mythryl Type Syntax}
\cutdef*{subsubsection}

Mythryl requires all type names to be in {\tt Mixed\_Case} and all constructors 
to be in {\tt UPPER\_CASE} (with the sole exception of the list constructor '!'). 
Combined with the requirement that all statements 
end with a semicolon, this allows concise type declarations. 

Mythryl declares tuples using parentheses-and-commas syntax parallel to 
normal tuple construction syntax.  This loses the tie to mathematical 
set product notation, but carries better C intuition and is more consistent 
with the way records types are declared in both {\sc SML} and Mythryl: 

\begin{verbatim}
    My_Tuple = (Int, Float, String);
\end{verbatim}

A simple uniontype declaration is now simply

\begin{verbatim}
    Color = RED | GREEN | BLUE;
\end{verbatim}

Declaring the same type opaque in an API (signature) is even more concise:

\begin{verbatim}
    Color;
\end{verbatim}

Mythryl does not use the {\sc SML} {\tt of} particle in uniontype declarations. 
(Mythryl returns {\tt of} to the general identifier pool, reducing the reserved 
word count by one.)

\begin{verbatim}
    Point = TWO_D (Float, Float) | THREE_D (Float, Float, Float);
\end{verbatim}

Mythryl uses prefix type functions (``type constructors''), in contrast to 
{\sc SML}'s postfix type syntax.  A list of strings type is now:

\begin{verbatim}
    List_Of_Strings = List(String);
\end{verbatim}

Record and function type declarations are otherwise unchanged: 

\begin{verbatim}
    My_Record_Type = { name: String, age: Int };
    My_Arrow_Type  = List(Int) -> Int;
\end{verbatim}

Mythryl type variables are typically single uppercase letters, canonically 
{\tt X Y Z}:

\begin{verbatim}
    Typeagnostic_Tuple(X, Y) = (List(X), Y, X -> Y);
\end{verbatim}

Relative to {\sc SML} type variable syntax \verb|'a|, the Mythryl 
syntax carries better intuition to C programmers, and incidentally 
frees up leading apostrophe to implement normal C-style character 
constant syntax.

When more semantic content is needed, longer type variable names incorporating a 
single leading capital may be used:

\begin{verbatim}
    Typeagnostic_Tuple(A_boojum, A_snark) = (List(A_boojum), A_snark, A_boojum -> A_snark);
\end{verbatim}


\cutend*

% --------------------------------------------------------------------------------
\subsection{Mythryl API Syntax}
\cutdef*{subsubsection}

Signatures are called APIs in Mythryl, for conciseness and improved C intuition. 

Pursuing the theme that generics (``functors'') are compile-time functions with 
package (``structure'') values taking API (``signature'') types, Mythryl APIs take 
{\tt Mixed\_Case} names just like Mythryl types.

Named APIs are declared using a conventional, compact, Posix-flavored syntax:

\begin{verbatim}
    api My_Api {
        Color;                                   # Opaque type declaration.
        Point = TWO_D (Float, Float)             # Transparent type declaration.
              | THREE_D (Float, Float, Float);   
        
        my_function: List(Int) -> Int;           # Function declaration.
    };                                           # All statements end with a semicolon!
\end{verbatim}

To avoid spending an extra reserved word (as does {\sc SML} with {\tt signature} and {\tt sig}) 
Mythryl uses a simple variant of the above syntax to declare anonymous APIs, merely replacing 
the API name with the standard underbar wildcard:

\begin{verbatim}
    api {
        Color;                                   # Opaque type declaration.
        Point = TWO_D (Float, Float)             # Transparent type declaration.
              | THREE_D (Float, Float, Float);   
        
        my_function: List(Int) -> Int;           # Function declaration.
    };                                           # All statements end with a semicolon!
\end{verbatim}

A Mythryl file declaring an API customarily uses the {\tt .api} file extension.

Note that despite the use of vertical bar ({\tt | }) in the above syntax, it is 
not a reserved word in Mythryl, and may be freely defined by the application 
programmer.  The default Mythryl library definition is integer inclusive-or, 
in line with C intuition.

\cutend*

% --------------------------------------------------------------------------------
\subsection{Mythryl Package Syntax}
\cutdef*{subsubsection}

C calls a record a {\it struct}, so to avoid misleading C intuition,  
where {\sc SML} uses the keyword {\tt structure}, Mythryl uses the keyword {\tt package}.

Named packages are declared using a conventional, compact, Posix-flavored syntax 
parallel to the API syntax.  Here is a package definition matching the preceding 
API declaration:

\begin{verbatim}
    package my_package: My_Api {
        Color = RED | GREEN | BLUE;
        Point = TWO_D (Float, Float)
              | THREE_D (Float, Float, Float);   
        
        fun my_function ints
            =
            sum (ints, 0)
            where
                fun sum ([],       result) => result;
                    sum ((i ! is), result) => sum (is, i + result);
                end;
            end;
    };
\end{verbatim}

Unlike {\sc SML}, which uses plain colon for weak package sealing for 
historical reasons, Mythryl uses plain colon above to represent strong 
sealing, in order to encourage good programming practices by giving the 
shortest, most convenient form to the preferred construct.

The Mythryl syntax for weak sealing in the same case is

\begin{verbatim}
    package my_package: (weak) My_Api {
        Color = RED | GREEN | BLUE;
        Point = TWO_D (Float, Float)
              | THREE_D (Float, Float, Float);   
        
        fun my_function ints
            =
            sum (ints, 0)
            where
                fun sum ([],       result) => result;
                    sum ((i ! is), result) => sum (is, i + result);
                end;
            end;
    }
\end{verbatim}

(The above {\tt weak} is not a reserved identifier, by the way.)

This syntax has better C intuition than {\sc SML}'s {\tt :> } operator.  Also, 
recent research has revealed forms of module sealing other than conventional    
strong and weak sealing;  the above {\tt (weak)} syntax will extend naturally to accommodate    
other forms of sealing should the need arise.

As with Mythryl API syntax, anonymous package declarations (often useful as 
arguments to generics) are written by replacing the package name with an underbar 
wildcard in the above syntax:

\begin{verbatim}
    package my_package
        =
        some_g (
            package {
                Color = RED | GREEN | BLUE;
                Point = TWO_D (Float, Float)
                      | THREE_D (Float, Float, Float);   

                fun my_function ints
                    =
                    sum (ints, 0)
                    where
                        fun sum ([],       result) => result;
                            sum ((i ! is), result) => sum (is, i + result);
                        end;
                    end;
            }
        );
\end{verbatim}

Anonymous package syntax is also used when a package is sealed with an 
API trailing {\tt where} modifiers.  This form parallels normal {\sc SML} 
syntax in such cases:

\begin{verbatim}
    package my_package
        :
        My_Api
        where
            Int == Integer
        =
        package {
            Color = RED | GREEN | BLUE;
            Point = TWO_D (Float, Float)
                  | THREE_D (Float, Float, Float);   

            fun my_function ints
                =
                sum (ints, 0)
                where
                    fun sum ([],       result) => result;
                        sum ((i ! is), result) => sum (is, i + result);
                    end;
                end;
        }
\end{verbatim}

A Mythryl file defining a package customarily uses the {\tt .pkg} file extension.

\cutend*

% --------------------------------------------------------------------------------
\subsection{Mythryl Generic Syntax}
\cutdef*{subsubsection}

The term ``functor'' is utterly alien to the programming mainstream, where 
``generic'' is the usual term, so  
Mythryl replaces the {\tt functor} keyword with {\tt generic package} 
to maximize effectiveness of C-trained intuition.

By convention, Mythryl names generics with identifiers ending in 
{\tt \_g}, but this convention is not compiler-enforced:

\begin{verbatim}
    generic package red_black_map_g (k:  Key):  Map where key == k
        {
            ...
        };
\end{verbatim}

(For complete source to the above example see 
\ahrefloc{src/lib/src/red-black-map-g.pkg}{src/lib/src/red-black-map-g.pkg}.)

\cutend*

% --------------------------------------------------------------------------------
\subsection{Mythryl for Loop}
\cutdef*{subsubsection}

{\sc SML} suffers from a paucity of iterative constructs.  Only {\tt while} is 
standard, and it is almost never used.

Mythryl implements a C-flavored {\tt for} loop construct:

\begin{verbatim}
    for (i = 0; i < 10; ++i) {
        printf "Loop %d\n" i;
    }
\end{verbatim}

That looks disturbingly imperative at first blush, but is in fact 
a derived form which expands into a recursive function as pure as 
the driven snow.  The general form is

\begin{quotation}
~~~~for ( {i = $expression_i$}, j = $expression_j$ ...; {\it conditional};  {\it loop\_increments};  {\it result\_expression}) \{ \newline
~~~~~~~~{\it loop body} \newline
~~~~\}; \newline
\end{quotation}

which the compiler expands internally into code like
\begin{quotation}
~~~~let fun loop (i, j, ...) = \{ \newline
~~~~~~~~~~~~if ({\it conditional}) \newline
~~~~~~~~~~~~~~~~{\it loop body}; \newline
~~~~~~~~~~~~~~~~{\it loop\_increments}; \newline
~~~~~~~~~~~~~~~~loop( i, j, ...); \newline
~~~~~~~~~~~~\}; \newline
~~~~~~~~else \newline
~~~~~~~~~~~~{\it result\_expression}; \newline
~~~~~~~~fi; \newline
~~~~in \newline
~~~~~~~~loop ($expression_i$, $expression_j$, ...); \newline
~~~~end; \newline    
\end{quotation}

You will note that the former version is one-quarter the length 
of the latter:  Using the {\tt for} construct can make iterative 
code considerably shorter and clearer!

Incidentally, the {\tt ++i} and {\tt --j} syntax expand into harmless 
pure {\tt i = i + 1; } and {\tt j = j - 1;} statements.



So there you are, the best of both worlds:  clean loop syntax without guilt!

By the way, the old {\tt while} loop is still available as 

\begin{quotation}
~~~~for ({\it expression}) \{ \newline
~~~~~~~~{\it loop body} \newline
~~~~\}; \newline
\end{quotation}

The point of the keyword substitution is to return {\tt while} to 
the general identifier pool:  The fewer reserved words, the better.

\cutend*


% --------------------------------------------------------------------------------
\subsection{Mythryl Prefix, Infix, Postfix and Circumfix Operators}
\cutdef*{subsubsection}

Contemporary programming is (perhaps unfortunately) based upon seven-bit 
{\sc ASCII}, leading to a distict paucity of available operator symbols, 
particularly compared with the rich variety used in mathematics.

This paucity is accentuated in {\sc SML} by the design inability to 
distinguish between prefix and infix uses of an operator symbol such 
as {\tt -}.  This forces {\sc SML} to use tilde for unary negation 
and {\tt !} for dereferencing, in jarring discord with contemporary 
practice.

C avoids this problem by adopting the rule that every pair of alphabetic 
identifiers must be separated by a binary symbolic operator; this allows 
any following symbolic operators to be unambiguously identified as prefix. 
This is why C can use {\tt *} for both binary multiplication and unary 
dereferencing.  This design approach is unworkable in the functional 
programming context due to the pervasive use of {\tt f x} functional 
application syntax.

Mythryl, participating in a recent trend, uses the presence or absence 
of whitespace to distinguish infix from prefix operator application:

\begin{verbatim}
    f-g             # Infix --- subtraction.
    f -g            # f(-g).
    f - g           # Infix --- subtraction.
    f- g            # Postfix. (No default Mythryl library semantics.)
\end{verbatim}

This effectively doubles or triples the size of the available operator 
namespace and allows Mythryl to use default operator definitions which 
are much more in tune with contemporary C-influenced intuition.

This also allows Mythryl to support some mathematical notations not 
(yet?) commonly used in the programming community, such as this 
definition of the factorial function, taken from the Mythryl standard 
library \ahrefloc{src/lib/std/src/multiword-int-guts.pkg}{src/lib/std/src/multiword-int-guts.pkg} 
package:

\begin{verbatim}
    fun 0! =>  1;
        n! =>  n * (n - 1)! ;
    end;
\end{verbatim}

Mythryl similarly supports a limited set of circumfix operators:

\begin{verbatim}
    fun |i| = (i > 0) ?? i :: -i;
\end{verbatim}

This allows certain common mathematical notations to be used in 
the Mythryl programming context for brevity and readability.

To resolve correctly, such expressions must be surrounded by whitespace 
and there must be no whitespace between the circumfix operator 
symbols and the enclosed expression.

The set of such operators currently supported is:

\begin{itemize}
\item |x|
\item <x>
\item /x/
\item \{i\}
\end{itemize}

(Although in a nod to quantum mechanics, Mythryl does also support mismatched bracket 
constructs like like \verb/<f|/ and \verb|/|g>/.  The standard library defines 
no meanings for these.)

The compiler resolves these operators to equivalent but more conventional 
names early in the front end, renaming them {\tt (|x|) (<x>) (/x/) (\{x\})} 
respectively.  These names may be used in contexts where the functions 
involved need to be named independent of immediate application ot a value.

A closely related Mythryl frontend tweak internally resolves {\tt a[i]} 
to {\tt (\_[]} early.  Defining this as a synonym for the usual vector 
{\tt get} operation via code like

\begin{verbatim}
    my (_[]): (Vector(X), Int) -> X = inline_t::poly_vector::check_sub;
\end{verbatim}

(taken from \ahrefloc{src/lib/std/src/vector.pkg}{src/lib/std/src/vector.pkg})

allowing more natural reference to vector elements:

\begin{verbatim}
    linux> my

    eval:  v = #[1, 2, 3];

    #[1, 2, 3]

    eval:  v[1];

    2
\end{verbatim}

A matching frontend tweak resolves {\tt a[i] = v;} 
to {\tt (\_[]:=)(a,i,v);}  Defining {\tt (\_[]:=)} as a synonym 
for the usual vector {\tt set} operation via code like

\begin{verbatim}
    (_[]:=) = set;
\end{verbatim}

(again from \ahrefloc{src/lib/std/src/vector.pkg}{src/lib/std/src/vector.pkg}) 
allows use of traditional notation for setting a vector entry:

\begin{verbatim}
    linux> my

    eval:  v = #[1, 2, 3];

    #[1, 2, 3]

    eval:  v[1] := 222;

    #[1, 222, 3]

\end{verbatim}

\cutend*


% --------------------------------------------------------------------------------
\subsection{Mythryl Backticks Operators}
\cutdef*{subsubsection}

Bash, Perl and a number of other modern scripting-influenced languages 
supply a backticks operator returning the output from an executed 
shell expression:

\begin{verbatim}
    #!/usr/bin/perl -w
    use strict;
    my $text = `ls -l`;
\end{verbatim}

Mythryl implements a similar backquote operator, with the difference 
that early in compilation the Mythryl compiler expands this operator 
into a call to the {\tt back\_\_ticks} function.

This means that just by redefining the {\tt back\_\_ticks} function, the 
application programmer can redefine the meaning of the backticks 
construct.  This can be useful, say, in a file defining many TCP/IP 
dotted-quad addresses, allowing syntax like 

\begin{verbatim}
    open_socket( `192.168.0.1` );
\end{verbatim}

to be substituted for perhaps

\begin{verbatim}
    open_socket( IP_ADDRESS (192, 168, 0, 1) );
\end{verbatim}

If the construct is being used only once or twice, this is not a 
significant win, but if a long file configuring (say) a 
mail transport agent contains hundreds of such constructs, the 
difference in readability may be substantial.

A similar {\tt dot\_\_backticks} operator is also implemented by 
the Mythryl front end, expanding from syntax like

\begin{verbatim}
    open_socket( .`192.168.0.1` );
\end{verbatim}

The Mythryl standard library assigns no default definition to 
the {\tt dot\_\_backticks} function.

In a similar vein, {\tt ."a b c d"} expands early in the Mythryl front  
end into {\tt dot\_\_qquotes "a b c d"}. 
The  \ahrefloc{pkg:scripting\_globals}{scripting\_globals} 
package sets {\tt dot\_\_qquotes} to {\tt words} which in turn is defined as

\begin{quotation}
~~~~~~~~words  = \ahrefloc{pkg:string}{string}::tokens \ahrefloc{pkg:string}{char}::is\_space;
\end{quotation}

Consequently, by default this construct provides a convenient way 
to specify lists of short words.  It is somewhat like Perl's 
{\tt qw/.../} construct:

\begin{verbatim}
    linux> my

    eval:  ."a b c d e f";

    ["a", "b", "c", "d", "e", "f"]
\end{verbatim}

This can substantially improve readability in certain sorts of programming.

By redefining {\tt dot\_\_qquotes} the application programmer may repurpose 
this facility for other needs.

In similar fashion {\tt .<foo>} expands into a call to {\tt dot\_\_brokets},
{\tt .|foo|} expands into a call to {\tt dot\_\_barets}, {\tt .#foo#} expands 
into a call to {\tt dot\_\_hashets} and {\tt ./foo/} expands into a call to 
{\tt dot\_\_slashets}.  All of these functions default to the identity function. 
Also, the only escape sequence recognized within any of these quotation constructs 
is doubling of the terminator to include it in the string; for example {\tt .#foo##bar#} 
is equivalent to {\tt "foo#bar}.  This makes them useful for avoiding the need to 
double all backslashes in regular expressions.


\cutend*


% --------------------------------------------------------------------------------
\subsection{Mythryl eval Operators}
\cutdef*{subsubsection}

Scripting languages such as Perl frequently implement an {\tt eval} operator 
allowing execution of source code strings dynamically created by the running 
script.  This has a variety of handy uses ranging from implementing systems 
which interactively execute user-entered code to system which dynamically 
compile special-case code at need.

The {\sc SML/NJ} codebase has been implemented from the start upon an 
incremental compiler design which makes implementation of such an operator 
straightforward, but unfortunately there has never been a supported 
interface to this functionality.  Thus, for example, Moonflare's 
\ahref{\mlud}{MLud} 
server written in SML/NJ had to use an undocumented API to access this 
functionality, which API was broken by subsequent releases.  Perhaps 
uncoincidentally, development of this software ceased shortly thereafter.

Mythryl implements a supported {\tt eval} operator for accessing incremental 
compilation functionality:

\begin{verbatim}
    linux> my

    eval:  evali "2 + 2";

    4
\end{verbatim}

Perl and bash, being dynamically typed, are not bothered by the fact 
that the type of {\tt eval} depends entirely upon the contents of its 
string argument.

In a language like {\sc SML} or Mythryl, this ill-typedness is more 
problematic.  This is not an unsurmountable problem.  If it were, 
{\sc SML}'s interactive mode would not be able to print out the 
value and type of interactively entered expressions.  But the solution 
is not something you would want to examine immediately before a meal. 
This problem may relate to the lack of a supported {\sc SML/NJ} {\sc API} 
for accessing incremental compilation functionality.

Eventually, {\tt eval} should be tweaked to have type {\tt String -> X} 
where X can change from invocation to invocation.  (Implementing this 
might be a nice undergrad compiler course project.  Email me a patch 
and I'll merge it in!)

For the moment, at least, Mythryl's solution is just to supply in the 
library a half dozen odd statically typed {\tt eval} variants covering 
common cases:

\begin{verbatim}

    eval:   String -> Void;

    evali:  String -> Int;
    evalf:  String -> Float;
    evals:  String -> String;

    evalli: String -> List( Int    );
    evallf: String -> List( Float  );
    evalls: String -> List( String );

\end{verbatim}

Additional variants may be implemented as needed by 
cloning and tweaking the existing routines.

This isn't a great solution, but it is much better than nothing!

\cutend*

% --------------------------------------------------------------------------------
\subsection{Further Reading}
\cutdef*{subsubsection}

For further reading, you might try the 
\ahrefloc{section:tut:recipes}{recipes} section, 
skim the \ahrefloc{section:ref:api:preface}{available APIs}, 
or browse the \ahrefloc{chapter:code:preface}{codebase} to see 
Mythryl at work on an industrial scale.

\cutend*
