<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mythryl Packages: Strong vs Weak</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mythryl_Types__Phantom_Types.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Package_and_API_Subclassing.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc105">5.4.20</A>  Mythryl Packages: Strong vs Weak</H3><P>We have 
<A HREF="my-Multi-file_Projects__Libraries_and_API_Definitions.html#section:tut:delving-deeper:libraries-and-apis">previously discussed</A> <I>casting</I> a package to an API so as to achieve implementation hiding by 
removing from view all package elements not declared in the API.</P><P>That kind of package casting is usually called <I>strong sealing</I> in the 
functional programming literature.</P><P>Recent research has established there to be a spectrum of plausible and in 
fact useful forms of package casting. At present Mythryl implements two: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Strong</B> package casting. (The normal case.)
</LI><LI CLASS="li-itemize"><B>Weak</B> package casting.
</LI></UL><P>Strong package casting verifies that the package declaration is consistent 
with the api declaration &#X2014; for example that all required functions are present 
and of the right type &#X2014; and then hides from external view all remaining package elements.
Also, types declared as opaque in the api</P><PRE CLASS="verbatim">    My_Type;
</PRE><P>become opaque to the outside world under strong casting. Under Mythryl typing 
rules, this also makes them new types, different from all previously declared types.</P><P>Strong package casting may be included in your original package definition:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    api My_Api {
        My_Type;
        print_it: My_Type -&gt; Void;
    };

    package my_root_package: My_Api {

        My_Type = String;

        fun private_print_fn  string  =  printf "My_Type value == '%s'\n"  string;
        fun print_it          string  =  private_print_fn  string;
    };
</PRE><P>Here we have cast <TT>my_package</TT> to <TT>My_Api</TT> in order to hide 
both the structure of <TT>My_Type</TT> and also the helper function 
<TT>private_print_fn</TT>. The external world sees only an 
opaque type <TT>My_Type</TT> and a function <TT>print_it</TT> which operates 
upon that type. This means that changes in the definition of <TT>My_Type</TT> 
cannot possibly break external code &#X2014; which is what makes such package casting 
so useful in the design and implementation of large software systems.</P><P>We can also cast a package after the fact with an API as a separate operation from 
package definition:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    api My_Api {
        My_Type;
        print_it: My_Type -&gt; Void;
    };

    package my_root_package {

        My_Type = String;

        fun private_print_fn  string  =  printf "My_Type value == '%s'\n"  string;
        fun print_it          string  =  private_print_fn  string;
    };


    package my_cast_package
        =
        my_root_package: My_Api;
</PRE><P>This may seem uselessly obtuse at first blush: Why not just do the 
package casting up front and be done with it? But consider this example:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    api My_First_Api {
        My_Type;
        print_it:   My_Type -&gt; Void;
    };

    api My_Second_Api {
        My_Type;
        print_fn:   My_Type -&gt; Void;
    };

    package my_root_package {

        My_Type = THIS( String )
                | THAT( Int )
                ; 

        fun private_print_fn  string  =  printf "My_Type value == '%s'\n"  string;
        fun print_it          string  =  private_print_fn  string;
        fun print_fn          string  =  private_print_fn  string;
    };


    package my_first_package  =   my_root_package:  My_First_Api;
    package my_second_package =   my_root_package:  My_Second_Api;
</PRE><P>Here we have generated two different externally visible packages from 
a single root package definition by casting it to two different api 
definitions. In a small tutorial example this looks silly, but this 
can become a real asset in the context of a large software development 
project where apis are defined and implemented by multiple groups and 
a given module may need to implement multiple externally provided 
apis.</P><P>Now we can begin to understand why the modern <I>package casting</I> approach is 
more powerful than the older technique of scattering <TT>public</TT> and 
<TT>private</TT> keywords all through the package definition: Aside from 
achieving better separation of concerns by divorcing package definition 
from API definition, the <I>package casting</I> approach defines a <I>package 
algebra</I> in which package definitions provide the seed values and 
API definitions provide the functions which produce new values from old.</P><P>Package casting literally gives us an entirely new language for programming 
in the large.</P><P><B>Weak</B> package casting is an older form of package casting which allows 
as much as possible of the original type equality information to 
propagate through to the resulting package interface. This form was 
developed first and is at this point present for primarily historical reasons.</P><P>We designate weak package casting by adding a <TT>(weak)</TT> qualifier after the 
casting colon:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    api My_Api {
        My_Type;
        print_it: My_Type -&gt; Void;
    };

    package my_package: (weak)  My_Api {

        My_Type = String;

        fun private_print_fn  string  =  printf "My_Type value == '%s'\n"  string;
        fun print_it          string  =  private_print_fn  string;
    };
</PRE><P>This version leaves visible the maximal possible amount of equality 
information about <TT>My_Type</TT>, allowing it to still be externally 
equal to type <TT>String</TT>, while still protecting the internal <TT>private_print_fn</TT> function frome external access.</P><P>Sometimes this additional propagation of type equality information 
is just what you need. Strong package casting is the default and 
normal case, but having both strong and weak package casting 
available makes Mythryl more expressive for programming in the large.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mythryl_Types__Phantom_Types.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Package_and_API_Subclassing.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
