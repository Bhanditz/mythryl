<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Side Effects</TITLE>
</HEAD>
<BODY >
<A HREF="my-Exceptions.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Balanced_Binary_Trees.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc75">5.3.10</A>  Side Effects</H3><P>It is time to broach the vexed subject of <I>side-effects</I>.</P><P>By <I>side-effects</I> in this context we mean essentially changing 
some value in memory in such a way that if code which had previously 
examined its value were to re-examine it, it would find that value 
changed.</P><P>Side-effects were not a major issue when the C programming 
language was designed. Computers were slow, memories were small 
(often less then 64K of RAM), and consequently programs were small 
and simple.</P><P>Today it is common for commodity desktop computers to have 
gigabytes of memory and multiple cores executing instructions 
in parallel out of that memory. Hundreds of millions of lines 
of code may be executing in-memory at the same time. On high-end 
number-crunching computers there may be tens of thousands of cores.</P><P>In this regime side-effects <I>are</I> a major issue.</P><P>From a hardware design point of view, every side-effect is now in fact 
a broadcast operation: The results of that memory write may need to be 
made visible to anything from four to eight cores on a small machine 
to tens of thousands of cores on a supercomputer. That is an 
inherently slow and expensive operation. The more side-effects the 
program creates, the harder it will be to attain good execution speed.</P><P>From a software design point of view, in such a context every 
side-effect is a bug waiting to happen. Side-effects are fertile 
breeding grounds for a wide variety of bugs ranging from race 
conditions to stale local copies.</P><P>In the contemporary context, thus, there are major advantages to 
software development approaches which avoid needless use of 
side-effects.</P><P>Some languages make pervasive use of side-effects. In a C program 
often every other line of code will update a pre-existing 
record in memory and thus cause a side-effect. Such languages are 
often called <I>imperative</I>.</P><P>Other languages, such as Haskell, completely ban side-effects. 
<A HREF="http://en.wikipedia.org/wiki/Simon_Peyton_Jones">Simon Peyton-Jones</A> calls this <I>&#X201C;wearing the hair shirt&#X201D;</I>. Writing code completely without side-effects involves a number of severe 
difficulties &#X2014; and brings with it a number of great advantages. 
Such languages are often called <I>pure-functional</I>.</P><P>Mythryl belongs to the middle ground of <I>mostly-functional</I> 
languages. Mythryl does allow side-effects, but typical Mythryl 
programs use them sparingly. The Mythryl compiler is 
tuned with the expectation that side-effects will be rare. </P><P>Mythryl programs avoid side-effects by doing a lot of copying. 
Where a C program would update a record field in memory, a 
Mythryl program will typically just make a new, updated, copy of the 
record, leaving the original copy untouched. Mythryl 
makes this very efficient; Mythryl can create records 
in a fraction of the time needed by C. (Is C faster than Mythryl? 
It depends what you measure!)</P><P>None of the Mythryl programs presented so far in these tutorials 
use side effects.</P><P>In fact, we have not yet presented any 
Mythryl language constructs which permit the creation of side 
effects.</P><P>Mythryl permits side-effects, but it places strong safeguards 
upon their use.</P><P>For example, all C record fields are read-write, permanently 
eligible to be modified in place. (This creates hair-raising 
problems for C compiler writers attempting to optimize code.) 
But Mythryl record fields are read-only, permanently 
protected from modification, accidental or deliberate.</P><P>In Mythryl, in essence, only <TT>reference cells</TT> may be 
modified. All other values are read-only once created. 
(With the sole exception of mutable vectors.)</P><P>This enormously simplifies the compiler writer&#X2019;s job when 
implementing optimizations.</P><P>More importantly, it makes Mythryl code easier to understand. There 
is never any question as to whether some function ten million lines 
away in another thread running on another core is about to update some 
value being used; with the exception of reference cells (and mutable 
vectors), such updates are forbidden. This makes large Mythryl 
programs enormously easier to read and maintain than large C programs.</P><P>Mythryl reference cells are used much like C pointers, from 
a practical point of view:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    pointer = REF 0;

    printf "%d\n" *pointer;

    pointer := 1;

    printf "%d\n" *pointer;

    pointer := 2;

    printf "%d\n" *pointer;
</PRE><P>Here one thinks of the <TT>REF</TT> reference-creating operator much the way one 
thinks of the C <TT>&amp;</TT> unary address-taking operator, 
and of the <TT>*pointer</TT> dereferencing operator almost exactly the 
way one thinks of the corresponding C operator.</P><P>When run the above code produces</P><PRE CLASS="verbatim">    0
    1
    2
</PRE><P>At first blush that may look a lot like this code:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    variable = 0;

    printf "%d\n" variable;

    variable = 1;

    printf "%d\n" variable;

    variable = 2;

    printf "%d\n" variable;
</PRE><P>When run, the latter produces exactly the same output as the 
former.</P><P>The critical difference is that in the latter 
cases the <TT>=</TT> &#X201C;assignments&#X201D; are only assigning convenient 
names to values. It happens that the same name is being used 
several times, but nothing is actually being overwritten in 
any interesting sense. No code running in another thread can 
ever observe <TT>variable</TT> changing, and thus no timing 
bugs are possible as a result of the latter code executing.</P><P>In the former case, however, the <TT>REF</TT> 
constructor allocates an actual shared cell in memory, and the 
<TT>:=</TT> operator actually overwrites the contents of this 
cell. We can store pointers to this cell in tuples and 
records and pass it around to other functions, which can 
then observe the changed value:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    cell = REF 0;

    r0 = { name =&gt; "0", cell };
    r1 = { name =&gt; "1", cell };

    printf "*r0.cell == %d\n" *r0.cell;
    printf "*r1.cell == %d\n" *r1.cell;

    r0.cell := 1;

    printf "*r0.cell == %d\n" *r0.cell;
    printf "*r1.cell == %d\n" *r1.cell;

    r1.cell := 2;

    printf "*r0.cell == %d\n" *r0.cell;
    printf "*r1.cell == %d\n" *r1.cell;
</PRE><P>Running this produces:</P><PRE CLASS="verbatim">    linux$ ./my-script
    *r0.cell == 0
    *r1.cell == 0
    *r0.cell == 1
    *r1.cell == 1
    *r0.cell == 2
    *r1.cell == 2
    linux$
</PRE><P>Notice that we are reading and writing the same cell through 
both the <TT>r0</TT> and <TT>r1</TT> records. This sort of thing 
can <I>only</I> be done using <TT>REF</TT> and <TT>:=</TT>.</P><P>In general <TT>REF</TT> and <TT>:=</TT> should be viewed like <TT>goto</TT> 
in C &#X2014; fundamentally regrettable and vaguely malevolent, but 
very occasionally exactly the right solution.</P><P>For example, <TT>REF</TT> and <TT>:=</TT> are indispensable when cyclic 
structures must be created. In our pico-mud example in the 
previous section, it would be natural to have the <TT>Door</TT> 
records point to both of the <TT>Room</TT> objects they connect 
as well as having <TT>Room</TT> objects point to all the <TT>Door</TT>s 
entering and leaving them, but we were unable to do that because 
we had no way of forming cycles in a datastructure.</P><P>Here is an updated version which does use cyclic datastructures:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    Room = ROOM { name: String, description: String, doors: Ref(List(Door)) }
    also
    Door = DOOR { name: String, description: String, from: Room, to: Room };

    fun print_room( self as ROOM { name, description, doors } ) = {
        printf "%s room: You see %s\n" name description;
        foreach *doors {.
            my door as DOOR { from, ... } = #d;
            if (from == self)  print_door door;  fi;            # Avoid going into an infinite loop!
        };
    }
    also
    fun print_door( DOOR { name, description, to, ... } ) = {
        printf "%s door: You see %s\n" name description;
        print_room to;
    };

    entryway = ROOM { name =&gt; "entryway", description =&gt; "a big entryway.", doors =&gt; REF [] };
    kitchen  = ROOM { name =&gt; "kitchen",  description =&gt; "a tidy kitchen.", doors =&gt; REF [] };

    door = DOOR { name =&gt; "kitchen", description =&gt; "a white door.", from =&gt; entryway, to =&gt; kitchen };

    my ROOM { doors =&gt; entryway_doors, ... } = entryway;   entryway_doors := [ door ];
    my ROOM { doors =&gt; kitchen_doors,  ... } = kitchen;    kitchen_doors  := [ door ];

    print_room  entryway;
</PRE><P>Here we have changed the <TT>doors</TT> field to hold a reference to a list of doors &#X2014; 
which reference we can thus update. This allows us to create both rooms first (with empty door lists), 
then create the door, with pointers to both rooms, and finally update the room door lists to 
include the door.</P><P>The above example also introduces the <TT>as</TT> pattern-match syntax</P><PRE CLASS="verbatim">    self as ROOM { name, description, doors }
</PRE><P>which allows us to assign a name <TT>self</TT> to the 
entire room record even as we also assign names to its <TT>name</TT>, <TT>description</TT> 
and <TT>doors</TT> individual fields.</P><P>When run, the above prints out</P><PRE CLASS="verbatim">    linux$ ./my-script
    entryway room: You see a big entryway.
    kitchen door: You see a white door.
    kitchen room: You see a tidy kitchen.
    linux$
</PRE>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Exceptions.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Balanced_Binary_Trees.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
