<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Oop Support</TITLE>
</HEAD>
<BODY >
<A HREF="my-Improvements_to_the_core_Mythryl_codebase.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Preface-8.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H2 CLASS="section"><A NAME="htoc224">9.6</A>  Oop Support</H2><P>At the moment the most significant project in progress is implementing 
support for object-oriented programming in Mythryl per Bernard Berthomeiu&#X2019;s 
March 2000 paper <A HREF="http://www.laas.fr/~bernard/oo/ooml.html"><I>OO Programming Styles in ML</I></A>.</P><P>I believe having a reasonable OOP story is essential if Mythryl is to gain traction with contemporary mainstream programmers, partly because 
they will not take a language seriously that does not have OOP support, 
partly because they will not be able to efficiently transfer their 
existing skills to a language without OOP support &#X2014; they have no other 
skills for programming in the large.</P><P>There have been a variety of attempts over the years to support object 
oriented programming in ML, ranging from Ocaml to Moby to the ML2000 
proposals.</P><P>There is at this point no consensus that OOP even makes 
sense in the ML context. For example, John Reppy thinks the topic 
worth pursuing, Robert Harper does not.</P><P>Among those who think OOP is a sensible fit to ML programming, there 
is no consensus as to how it should be done. Xavier Leroy&#X2019;s approach 
in Ocaml requires major changes in the typechecking system which 
significantly increase its complexity. Much the same maybe said 
of John Reppy&#X2019;s approach in Moby.</P><P>My impression is that while mainstream programmers need some flavor 
of OOP to feel comfortable in a programming language, that OOP does 
not need to be particularly sophisticated nor of any particular 
flavor. A wide variety of OOP approaches may be found among successful 
contemporary mainstream languages, ranging from the simple 
(Perl) to the complex (C++) with mainstream programmers by and large 
seeming largely oblivious to the differences.</P><P>It is not clear that experienced Mythryl programmers will use 
OOP heavily once through the transition stage of learning the 
language. The Ocaml experience is that even when OOP support is 
provided, only about 15% of programs use it. In general ML 
module system support satisfies most programming in the large 
requirements; OOP is mainly needed when late binding is 
required on a large scale.</P><P>Consequently, I feel Bernard Berthomeiu&#X2019;s OOP approach is a good fit 
to Mythryl. It provides basic OOP support, in principle without 
requiring any change to the compiler except syntactic sugar.</P><P>I have an initial implementation perhaps half to three quarters complete: </P><UL CLASS="itemize"><LI CLASS="li-itemize">The Mythryl parser has been modified to support syntax for 
declaration of methods and fields. This involves changes to the 
grammar in <A HREF="my-src_lib_compiler_front_parser_yacc_mythryl_grammar.html#src/lib/compiler/front/parser/yacc/mythryl.grammar">src/lib/compiler/front/parser/yacc/mythryl.grammar</A> and to the raw syntax tree representation defined in 
<A HREF="my-src_lib_compiler_front_parser_raw-syntax_raw-syntax_api.html#src/lib/compiler/front/parser/raw-syntax/raw-syntax.api">src/lib/compiler/front/parser/raw-syntax/raw-syntax.api</A>.</LI><LI CLASS="li-itemize">Code has been (half) written to expand the resulting field and method syntax into vanilla raw syntax, treating the OOP 
constructs as derived forms which essentially macro-expand into 
non-OOP code, minimizing added complexity in the rest of the compiler. 
This code lives in 
<A HREF="my-src_lib_compiler_front_typer_main_expand-oop-syntax_api.html#src/lib/compiler/front/typer/main/expand-oop-syntax.api">src/lib/compiler/front/typer/main/expand-oop-syntax.api</A> and <A HREF="my-src_lib_compiler_front_typer_main_expand-oop-syntax_pkg.html#src/lib/compiler/front/typer/main/expand-oop-syntax.pkg">src/lib/compiler/front/typer/main/expand-oop-syntax.pkg</A> with support code in 
<A HREF="my-src_lib_compiler_front_typer_main_expand-oop-syntax-junk_pkg.html#src/lib/compiler/front/typer/main/expand-oop-syntax-junk.pkg">src/lib/compiler/front/typer/main/expand-oop-syntax-junk.pkg</A> and also <A HREF="my-src_lib_compiler_front_parser_raw-syntax_map-raw-syntax_api.html#src/lib/compiler/front/parser/raw-syntax/map-raw-syntax.api">src/lib/compiler/front/parser/raw-syntax/map-raw-syntax.api</A> and <A HREF="my-src_lib_compiler_front_parser_raw-syntax_map-raw-syntax_pkg.html#src/lib/compiler/front/parser/raw-syntax/map-raw-syntax.pkg">src/lib/compiler/front/parser/raw-syntax/map-raw-syntax.pkg</A>.Invocation is directly from the grammar rule for <TT>a_package</TT>.</LI></UL><P>Pushing this project through to completion proved to require more 
changes to the compiler than I had originally hoped. There are 
two major problems.</P><P>The first is that Berthomeiu&#X2019;s approach requires that classes 
be made abstract, which in ML requires <I>strong sealing</I>, which 
in turn requires synthesizing a complete <SPAN STYLE="font-variant:small-caps">API</SPAN> signature 
for the package defining the class. This is not reasonable 
when OOP is being implemented as a derived form early in the 
compiler, before type deduction has been performed.</P><P>To deal with this problem I implemented a new style of package 
sealing <I>partial sealing</I> which is like strong sealing 
except that API elements not mentioned are left visible and 
unchanged instead of being hidden. This required changes in:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="my-src_lib_compiler_front_parser_lex_mythryl_lex.html#src/lib/compiler/front/parser/lex/mythryl.lex">src/lib/compiler/front/parser/lex/mythryl.lex</A> to recognize the new ": (partial)" token.</LI><LI CLASS="li-itemize"><A HREF="my-src_lib_compiler_front_parser_yacc_mythryl_grammar.html#src/lib/compiler/front/parser/yacc/mythryl.grammar">src/lib/compiler/front/parser/yacc/mythryl.grammar</A> to allow the new partial package cast syntax.</LI><LI CLASS="li-itemize"><A HREF="my-src_lib_compiler_front_parser_raw-syntax_raw-syntax_api.html#src/lib/compiler/front/parser/raw-syntax/raw-syntax.api">src/lib/compiler/front/parser/raw-syntax/raw-syntax.api</A> to represent the new syntax in raw syntax trees.</LI><LI CLASS="li-itemize"><A HREF="my-src_app_makelib_compilable_raw-syntax-to-module-dependencies-summary_pkg.html#src/app/makelib/compilable/raw-syntax-to-module-dependencies-summary.pkg">src/app/makelib/compilable/raw-syntax-to-module-dependencies-summary.pkg</A> to preserve existing functionality. (Hope I got that right!)</LI><LI CLASS="li-itemize"><A HREF="my-src_lib_compiler_front_typer_main_type-package-language-g_pkg.html#src/lib/compiler/front/typer/main/type-package-language-g.pkg">src/lib/compiler/front/typer/main/type-package-language-g.pkg</A> to actually implement the new semantics. </LI></UL><P>A more serious problem is that if the methods of a class are 
to be able to create instances of that class (a frequent 
requirement if, say, combining two objects to produce a third 
in the pure-functional spirit), then the <TT>new</TT> method 
for the class must be mutually recursive with the methods 
for that class.</P><P>This is a problem primarily because Berthomeiu&#X2019;s OOP approach 
also requires the methods to be typeagnostic, which requires 
that they be generalized. <SPAN STYLE="font-variant:small-caps">SML/NJ</SPAN>, at least, does not 
generalize mutually recursive functions.</P><P>Berthomeiu&#X2019;s paper passes over this point in silence.</P><P>Here is a minimal stimulus exhibiting the problem. 
This program compiles fine:</P><PRE CLASS="verbatim">package test: api { f: X -&gt; Void; } {

    fun f (x: X) = ();
    fun g () = f 0;
};
</PRE><P>but when made mutually recursive it fails to compile:</P><PRE CLASS="verbatim">package test: api { f: X -&gt; Void; } {

    fun f (x: X) = ()
    also
    fun g () = f 0;
};
</PRE><P>(See <A HREF="my-src_app_tut_oop-crib-temp_oop-crib-temp_pkg.html#src/app/tut/oop-crib-temp/oop-crib-temp.pkg">src/app/tut/oop-crib-temp/oop-crib-temp.pkg</A>.)</P><P>Removing this restriction results in changes starting to propagate deeper into the compiler. I do not yet 
understand those parts of the compiler well enough to 
make this work:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
I added the <TT>generalize_mutually_recursive_functions</TT> tweak to 
<A HREF="my-src_lib_compiler_front_typer_types_type-core-language-declaration-g_pkg.html#src/lib/compiler/front/typer/types/type-core-language-declaration-g.pkg">src/lib/compiler/front/typer/types/type-core-language-declaration-g.pkg</A> to get mutually recursive functions to generalize early enough, but this resulted in 
<TT>translate_pattern_expression</TT> in 
<A HREF="my-src_lib_compiler_back_top_translate_translate-deep-syntax-to-lambdacode_pkg.html#src/lib/compiler/back/top/translate/translate-deep-syntax-to-lambdacode.pkg">src/lib/compiler/back/top/translate/translate-deep-syntax-to-lambdacode.pkg</A> complaining about variables being pre-<SPAN STYLE="font-variant:small-caps">TYPE_VARIABLE_MARK</SPAN>-ed. 
</LI><LI CLASS="li-itemize">After a good deal of code reading I decided that it is probably safe to 
simply comment out that error trap, but this simply resulted in 
<TT>LtyDef: </TT><TT><SPAN STYLE="font-variant:small-caps">FNTYPE_TYPEAGNOSTIC</SPAN></TT><TT> unsupported in ltd_tyc</TT> from 
<A HREF="my-src_lib_compiler_back_top_highcode_highcode-type_pkg.html#src/lib/compiler/back/top/highcode/highcode-type.pkg">src/lib/compiler/back/top/highcode/highcode-type.pkg</A>.</LI></UL><P>I do not understand that part of the codebase, so I have suspended this 
line of development until I have time to study it properly.</P><P>(2011-06-07 CrT: Robert Harper informs me that most-general-type inference 
on mutually recursive functions is mathematically undecidable.)
</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Improvements_to_the_core_Mythryl_codebase.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Preface-8.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
