<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Vector Slices</TITLE>
</HEAD>
<BODY >
<A HREF="my-Typelocked_Vectors.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Types__Hindley-Milner_Type_Inference.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc97">5.4.12</A>  Vector Slices</H3><P>
<A NAME="section:tut:full-monte:vector-slices"></A></P><P>C has a very relaxed approach to typing, allowing one to synthesize a 
pointer to anywhere in memory and call it anything one likes via code 
like</P><PRE CLASS="verbatim">    float* fp = (float*) 0x1245;
</PRE><P>This is often used to advantage in such situations as in writing 
memory allocators and garbage collectors, where typed values are 
appearing, moving and disappearing.</P><P>A typesafe language like Mythryl cannot be quite that relaxed about pointers. 
That is one reason the Mythryl garbage collector is written in C, not Mythryl.</P><P>C code also often uses pointer arithmetic to refer to a substring of a given string:</P><PRE CLASS="verbatim">    char* long_string = "abcdefghijklmnopqrstuvwxyz";
    char* last_half   = long_string + 13;
</PRE><P>In Mythryl we can and do provide a functionally similar way to create 
and use references to substrings and subvectors. Mythryl calls these 
references <I>slices</I>.</P><P>Apis supporting vector slicing include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="my-Vector_Slice.html#api:Vector_Slice">Vector_Slice</A></LI><LI CLASS="li-itemize"><A HREF="my-Rw_Vector_Slice.html#api:Rw_Vector_Slice">Rw_Vector_Slice</A></LI><LI CLASS="li-itemize"><A HREF="my-Typelocked_Vector_Slice.html#api:Typelocked_Vector_Slice">Typelocked_Vector_Slice</A></LI><LI CLASS="li-itemize"><A HREF="my-Typelocked_Rw_Vector_Slice.html#api:Typelocked_Rw_Vector_Slice">Typelocked_Rw_Vector_Slice</A></LI></UL><P>
The <A HREF="my-Substring.html#api:Substring">Substring</A> api is closely related.</P><P>Packages implementing vector slices include:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="my-char_vector_slice.html#pkg:vector_slice_of_chars">vector_slice_of_chars</A></LI><LI CLASS="li-itemize"><A HREF="my-vector_slice_of_eight_byte_floats.html#pkg:vector_slice_of_eight_byte_floats">vector_slice_of_eight_byte_floats</A></LI><LI CLASS="li-itemize"><A HREF="my-rw_vector_slice.html#pkg:rw_vector_slice">_</A>of_charsrw_vector_slice_of_chars</LI><LI CLASS="li-itemize"><A HREF="my-rw_ector_slice_of_eight_byte_floats.html#pkg:rw_vector_slice_of_eight_byte_floats">rw_vector_slice_of_eight_byte_floats</A></LI><LI CLASS="li-itemize"><A HREF="my-rw_vector_slice_of_one_byte_unts.html#pkg:rw_vector_slice_of_one_byte_unts">rw_vector_slice_of_one_byte_unts</A></LI><LI CLASS="li-itemize"><A HREF="my-unt8_vector_slice.html#pkg:vector_slice_of_one_byte_unts">vector_slice_of_one_byte_unts</A></LI></UL><P>The <A HREF="my-substring.html#pkg:substring">substring</A> package is closely related.</P><P>Slices optimize time/space performance at the cost of increased code complexity. Like all such optimizations, they should be used <I>only 
if you have working code which clearly has a substantial performance problem.</I> 
Absent that, it is better to just create new vectors as needed.</P><P>In general slices behave just like the underlying vectors once created:</P><PRE CLASS="verbatim">    linux$ my

    eval:  vector = vector::from_list (0..9);
    #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    eval:  package vs = vector_slice;                     # Short synonym.
    eval:  slice = vs::make_slice (vector, 5, THE 4);     # Offset 5, length 4.

    eval:  for (i = 0; i &lt; vs::length slice; ++i)   printf "%d: %d\n" i (vs::get (slice, i));
    0: 5
    1: 6
    2: 7
    3: 8

    eval:  vs::to_vector slice;                           # Create new vector holding copy of slice contents.
    #[5, 6, 7, 8]
</PRE><P>For variety, here is the same example done with a slice of a <TT>float64_vector</TT>:</P><PRE CLASS="verbatim">    linux$ my

    eval:  vector = vector_of_eight_byte_floats::from_list (map float64::from_int (0..9));
    #[0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]

    eval:  package vs = vector_slice_of_eight_byte_floats;
    eval:  slice = vs::make_slice (vector, 5, THE 4);    # Create a slice pointing into above vector.

    eval:  for (i = 0; i &lt; vs::length slice; ++i)  printf "%d: %f\n" i (vs::get (slice, i));
    0: 5.000000
    1: 6.000000
    2: 7.000000
    3: 8.000000

    eval:  vs::to_vector slice;                           # Create new vector holding copy of slice contents.
    #[5.0, 6.0, 7.0, 8.0]
</PRE>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Typelocked_Vectors.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Types__Hindley-Milner_Type_Inference.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
