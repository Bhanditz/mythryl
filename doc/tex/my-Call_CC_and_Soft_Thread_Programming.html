<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Call/CC and Soft Thread Programming</TITLE>
</HEAD>
<BODY >
<A HREF="my-Package_and_API_Subclassing.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Library_Freezing.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc107">5.4.22</A>  Call/CC and Soft Thread Programming</H3><P>
<A NAME="section:tut:full-monte:callcc"></A></P><P>The fundamental concurrent programming primitive in modern praxis 
is <TT>callcc</TT>, "call with current fate", which may be 
thought of as saving the current call stack.</P><P>(Mythryl actually uses a stackless implementation, so in a literal 
sense there is no call stack to save or restore. This makes the 
Mythryl <TT>callcc</TT> implementation perhaps a hundred times faster 
than the typical competing implementation; in Mythryl <TT>callcc</TT> 
takes essentially the same time as any other function call, and 
works much the same way.)</P><P>Mythryl&#X2019;s version of this facility pairs it with 
<TT>throw</TT>, which may be thought of as resuming a saved call stack.</P><P>The <TT>callcc</TT> interface represents low-level functionality 
reaching deep into system internals; the application level 
interface to it is defined in <A HREF="my-src_lib_std_src_nj_fate_api.html#src/lib/std/src/nj/fate.api">src/lib/std/src/nj/fate.api</A> and <A HREF="my-src_lib_std_src_nj_fate_pkg.html#src/lib/std/src/nj/fate.pkg">src/lib/std/src/nj/fate.pkg</A>.</P><P>The core of the API is</P><PRE CLASS="verbatim">    Fate(X);
    callcc:  (Fate(X) -&gt; X) -&gt; X;
    throw:    Fate(X) -&gt; X -&gt; Y;
</PRE><P>where</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Fate(X)</TT> is the type of fates taking arguments of type X.
</LI><LI CLASS="li-itemize"><TT>callcc user_function</TT> passes the current fate <TT>k</TT> to <TT>userfunction</TT>.
Later doing <TT>throw cc x</TT> effectively results in the original 
<TT>callcc user_function</TT> returning <TT>x</TT>.
</LI><LI CLASS="li-itemize"><TT>throw k x</TT> resumes fate <TT>k</TT> (obtained from <TT>callcc</TT>) with argument <TT>x</TT>.
</LI></UL><P>The <TT>callcc</TT> facility is really only useful in applications large enough 
to need multiple logical threads of control; consequently, simple examples 
tend to look fairly silly. Here is a minimal example of using <TT>callcc</TT> and <TT>throw</TT>:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    callcc = fate::callcc;
    throw  = fate::throw;

    fun test_callcc string
        =
        callcc( \\ current_fate =  throw  current_fate  string );

    printf "Test result is '%s'.\n"  (test_callcc "foo");
</PRE><P>As you probably suspect, when run this yields:</P><PRE CLASS="verbatim">    linux$ ./my-script
    Test result is 'foo'.
</PRE><P>Here we first use <TT>callcc</TT> to get access to the <TT>current_fate</TT> 
and then immediately use <TT>throw</TT> to resume that fate.</P><P>In a more realistic example we would be doing something like maintaining 
a priority queue of fates, entering <TT>current_fate</TT> into 
that priority queue, extracting the next fate to run from that 
priority queue, and then using <TT>throw</TT> to transfer control to that 
next fate, thus effecting a "cooperative multitasking" style 
time-slice context switch; instead of <TT>test_callcc</TT> our function 
might be called something like <TT>yield</TT>.</P><P>A production example of such coding may be found in 
<A HREF="my-src_app_makelib_concurrency_makelib-thread-boss_pkg.html#src/app/makelib/concurrency/makelib-thread-boss.pkg">src/app/makelib/concurrency/makelib-thread-boss.pkg</A>.</P><P>Serious concurrent programming requires an infrastructure of appropriate priority queues, locks, message channels and so forth. The <I>de facto</I> 
standard concurrent programming solution for the SML world is John H Reppy&#X2019;s 
<TT>CML</TT>, documented in his book <I>Concurrent Programming in ML</I>. This 
package has been partially ported to Mythryl; the source code compiles and is in the 
tree rooted at <TT>src/lib/thread-kit</TT>. A suitable entrypoint for reading 
purposes is <A HREF="my-src_lib_src_lib_thread-kit_src_core-thread-kit_threadkit_api.html#src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.api">src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.api</A>.</P><P>The <TT>thread-kit</TT> code is not currently operational or supported; the change of syntax from SML to Mythryl has introduced some superficial breakage which I have 
not yet had time to pin down and fix.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Package_and_API_Subclassing.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Library_Freezing.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
