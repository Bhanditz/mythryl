\index[api]{Tuplebasex}
\label{api:Tuplebasex}
\input{top-api-Tuplebasex.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    Tuplebase X;
    Atom X;
    Duple X = (Atom(X ) , Atom(X ));
    Triple X = (Atom(X ) , Atom(X ) , Atom(X ));
        package ds
          : api {   package key
                      : api {
                            Key X;
                            compare : (Key(X ) , Key(X )) -> Order;};;
                Item X = key::Key(X );
                Set X;
                empty : Set(X );
                singleton : Item(X ) -> Set(X );
                add : (Set(X ) , Item(X )) -> Set(X );
                add' : (Item(X ) , Set(X )) -> Set(X );
                add_list : (Set(X ) , List(Item(X ) )) -> Set(X );
                drop : (Set(X ) , Item(X )) -> Set(X );
                member : (Set(X ) , Item(X )) -> Bool;
                is_empty : Set(X ) -> Bool;
                equal : (Set(X ) , Set(X )) -> Bool;
                compare : (Set(X ) , Set(X )) -> Order;
                is_subset : (Set(X ) , Set(X )) -> Bool;
                vals_count : Set(X ) -> Int;
                vals_list : Set(X ) -> List(Item(X ) );
                union : (Set(X ) , Set(X )) -> Set(X );
                intersection : (Set(X ) , Set(X )) -> Set(X );
                difference : (Set(X ) , Set(X )) -> Set(X );
                map : (Item(X ) -> Item(X )) -> Set(X ) -> Set(X );
                apply : (Item(X ) -> Void) -> Set(X ) -> Void;
                fold_forward : ((Item(X ) , Y) -> Y) -> Y -> Set(X ) -> Y;
                fold_backward : ((Item(X ) , Y) -> Y) -> Y -> Set(X ) -> Y;
                partition : (Item(X ) -> Bool) -> Set(X ) -> (Set(X ) , Set(X ));
                filter : (Item(X ) -> Bool) -> Set(X ) -> Set(X );
                exists : (Item(X ) -> Bool) -> Set(X ) -> Bool;
                find : (Item(X ) -> Bool) -> Set(X ) -> Null_Or(Item(X ) );
                all_invariants_hold : Set(X ) -> Bool;};;
        package ts
          : api {   package key
                      : api {
                            Key X;
                            compare : (Key(X ) , Key(X )) -> Order;};;
                Item X = key::Key(X );
                Set X;
                empty : Set(X );
                singleton : Item(X ) -> Set(X );
                add : (Set(X ) , Item(X )) -> Set(X );
                add' : (Item(X ) , Set(X )) -> Set(X );
                add_list : (Set(X ) , List(Item(X ) )) -> Set(X );
                drop : (Set(X ) , Item(X )) -> Set(X );
                member : (Set(X ) , Item(X )) -> Bool;
                is_empty : Set(X ) -> Bool;
                equal : (Set(X ) , Set(X )) -> Bool;
                compare : (Set(X ) , Set(X )) -> Order;
                is_subset : (Set(X ) , Set(X )) -> Bool;
                vals_count : Set(X ) -> Int;
                vals_list : Set(X ) -> List(Item(X ) );
                union : (Set(X ) , Set(X )) -> Set(X );
                intersection : (Set(X ) , Set(X )) -> Set(X );
                difference : (Set(X ) , Set(X )) -> Set(X );
                map : (Item(X ) -> Item(X )) -> Set(X ) -> Set(X );
                apply : (Item(X ) -> Void) -> Set(X ) -> Void;
                fold_forward : ((Item(X ) , Y) -> Y) -> Y -> Set(X ) -> Y;
                fold_backward : ((Item(X ) , Y) -> Y) -> Y -> Set(X ) -> Y;
                partition : (Item(X ) -> Bool) -> Set(X ) -> (Set(X ) , Set(X ));
                filter : (Item(X ) -> Bool) -> Set(X ) -> Set(X );
                exists : (Item(X ) -> Bool) -> Set(X ) -> Bool;
                find : (Item(X ) -> Bool) -> Set(X ) -> Null_Or(Item(X ) );
                all_invariants_hold : Set(X ) -> Bool;};;
    make_atom : Void -> Atom(X );
    make_string_atom : String -> Atom(X );
    make_float_atom : Float -> Atom(X );
    make_other_atom : X -> Atom(X );
    string_of : Atom(X ) -> Null_Or(String );
    float_of : Atom(X ) -> Null_Or(Float );
    other_of : Atom(X ) -> Null_Or(X );
    empty_tuplebase : Tuplebase(X );
    put_duple : (Tuplebase(X ) , Duple(X )) -> Tuplebase(X );
    put_triple : (Tuplebase(X ) , Triple(X )) -> Tuplebase(X );
    drop_duple : (Tuplebase(X ) , Duple(X )) -> Tuplebase(X );
    drop_triple : (Tuplebase(X ) , Triple(X )) -> Tuplebase(X );
    get_duples : Tuplebase(X ) -> ds::Set(X );
    get_duples1 : (Tuplebase(X ) , Atom(X )) -> Null_Or(ds::Set(X ) );
    get_duples2 : (Tuplebase(X ) , Atom(X )) -> Null_Or(ds::Set(X ) );
    has_duple : (Tuplebase(X ) , Duple(X )) -> Bool;
    get_triples : Tuplebase(X ) -> ts::Set(X );
    get_triples1 : (Tuplebase(X ) , Atom(X )) -> Null_Or(ts::Set(X ) );
    get_triples2 : (Tuplebase(X ) , Atom(X )) -> Null_Or(ts::Set(X ) );
    get_triples3 : (Tuplebase(X ) , Atom(X )) -> Null_Or(ts::Set(X ) );
    get_triples12 : (Tuplebase(X ) , Atom(X ) , Atom(X )) -> Null_Or(ts::Set(X ) );
    get_triples13 : (Tuplebase(X ) , Atom(X ) , Atom(X )) -> Null_Or(ts::Set(X ) );
    get_triples23 : (Tuplebase(X ) , Atom(X ) , Atom(X )) -> Null_Or(ts::Set(X ) );
    has_triple : (Tuplebase(X ) , Triple(X )) -> Bool;
    atoms_apply : Tuplebase(X ) -> (Atom(X ) -> Void) -> Void;};
\end{verbatim}\index[fun]{atoms\_apply}
\index[fun]{has\_triple}
\index[fun]{get\_triples23}
\index[fun]{get\_triples13}
\index[fun]{get\_triples12}
\index[fun]{get\_triples3}
\index[fun]{get\_triples2}
\index[fun]{get\_triples1}
\index[fun]{get\_triples}
\index[fun]{has\_duple}
\index[fun]{get\_duples2}
\index[fun]{get\_duples1}
\index[fun]{get\_duples}
\index[fun]{drop\_triple}
\index[fun]{drop\_duple}
\index[fun]{put\_triple}
\index[fun]{put\_duple}
\index[fun]{empty\_tuplebase}
\index[fun]{other\_of}
\index[fun]{float\_of}
\index[fun]{string\_of}
\index[fun]{make\_other\_atom}
\index[fun]{make\_float\_atom}
\index[fun]{make\_string\_atom}
\index[fun]{make\_atom}
\index[fun]{all\_invariants\_hold}
\index[fun]{find}
\index[fun]{exists}
\index[fun]{filter}
\index[fun]{partition}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{apply}
\index[fun]{map}
\index[fun]{difference}
\index[fun]{intersection}
\index[fun]{union}
\index[fun]{vals\_list}
\index[fun]{vals\_count}
\index[fun]{is\_subset}
\index[fun]{compare}
\index[fun]{equal}
\index[fun]{is\_empty}
\index[fun]{member}
\index[fun]{drop}
\index[fun]{add\_list}
\index[fun]{add\_\_prime\_\_}
\index[fun]{add}
\index[fun]{singleton}
\index[fun]{empty}
\index[fun]{compare}
\index[fun]{all\_invariants\_hold}
\index[fun]{find}
\index[fun]{exists}
\index[fun]{filter}
\index[fun]{partition}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{apply}
\index[fun]{map}
\index[fun]{difference}
\index[fun]{intersection}
\index[fun]{union}
\index[fun]{vals\_list}
\index[fun]{vals\_count}
\index[fun]{is\_subset}
\index[fun]{compare}
\index[fun]{equal}
\index[fun]{is\_empty}
\index[fun]{member}
\index[fun]{drop}
\index[fun]{add\_list}
\index[fun]{add\_\_prime\_\_}
\index[fun]{add}
\index[fun]{singleton}
\index[fun]{empty}
\index[fun]{compare}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
