\index[api]{Tuplebase}
\label{api:Tuplebase}
\input{top-api-Tuplebase.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    Other  = Exception;
    Tuplebase;
    Atom;
    Duple  = (Atom , Atom);
    Triple  = (Atom , Atom , Atom);
        package ds
          : api {   package key
                      : api {
                            Key;
                            compare : (Key , Key) -> Order;};;
                Item  = key::Key;
                Set;
                empty : Set;
                singleton : Item -> Set;
                from_list : List(Item ) -> Set;
                add : (Set , Item) -> Set;
                add' : (Item , Set) -> Set;
                add_list : (Set , List(Item )) -> Set;
                drop : (Set , Item) -> Set;
                member : (Set , Item) -> Bool;
                preceding_member : (Set , Item) -> Null_Or(Item );
                following_member : (Set , Item) -> Null_Or(Item );
                is_empty : Set -> Bool;
                equal : (Set , Set) -> Bool;
                compare : (Set , Set) -> Order;
                is_subset : (Set , Set) -> Bool;
                vals_count : Set -> Int;
                vals_list : Set -> List(Item );
                union : (Set , Set) -> Set;
                intersection : (Set , Set) -> Set;
                difference : (Set , Set) -> Set;
                map : (Item -> Item) -> Set -> Set;
                apply : (Item -> Void) -> Set -> Void;
                fold_forward : ((Item , X) -> X) -> X -> Set -> X;
                fold_backward : ((Item , X) -> X) -> X -> Set -> X;
                partition : (Item -> Bool) -> Set -> (Set , Set);
                filter : (Item -> Bool) -> Set -> Set;
                exists : (Item -> Bool) -> Set -> Bool;
                find : (Item -> Bool) -> Set -> Null_Or(Item );
                all_invariants_hold : Set -> Bool;};;
        package ts
          : api {   package key
                      : api {
                            Key;
                            compare : (Key , Key) -> Order;};;
                Item  = key::Key;
                Set;
                empty : Set;
                singleton : Item -> Set;
                from_list : List(Item ) -> Set;
                add : (Set , Item) -> Set;
                add' : (Item , Set) -> Set;
                add_list : (Set , List(Item )) -> Set;
                drop : (Set , Item) -> Set;
                member : (Set , Item) -> Bool;
                preceding_member : (Set , Item) -> Null_Or(Item );
                following_member : (Set , Item) -> Null_Or(Item );
                is_empty : Set -> Bool;
                equal : (Set , Set) -> Bool;
                compare : (Set , Set) -> Order;
                is_subset : (Set , Set) -> Bool;
                vals_count : Set -> Int;
                vals_list : Set -> List(Item );
                union : (Set , Set) -> Set;
                intersection : (Set , Set) -> Set;
                difference : (Set , Set) -> Set;
                map : (Item -> Item) -> Set -> Set;
                apply : (Item -> Void) -> Set -> Void;
                fold_forward : ((Item , X) -> X) -> X -> Set -> X;
                fold_backward : ((Item , X) -> X) -> X -> Set -> X;
                partition : (Item -> Bool) -> Set -> (Set , Set);
                filter : (Item -> Bool) -> Set -> Set;
                exists : (Item -> Bool) -> Set -> Bool;
                find : (Item -> Bool) -> Set -> Null_Or(Item );
                all_invariants_hold : Set -> Bool;};;
    make_atom : Void -> Atom;
    make_string_atom : String -> Atom;
    make_float_atom : Float -> Atom;
    make_tuplebase_atom : Tuplebase -> Atom;
    make_other_atom : Other -> Atom;
    string_of : Atom -> Null_Or(String );
    float_of : Atom -> Null_Or(Float );
    tuplebase_of : Atom -> Null_Or(Tuplebase );
    other_of : Atom -> Null_Or(Other );
    empty_tuplebase : Tuplebase;
    put_duple : (Tuplebase , Duple) -> Tuplebase;
    put_triple : (Tuplebase , Triple) -> Tuplebase;
    drop_duple : (Tuplebase , Duple) -> Tuplebase;
    drop_triple : (Tuplebase , Triple) -> Tuplebase;
    get_duples : Tuplebase -> ds::Set;
    get_duples1 : (Tuplebase , Atom) -> Null_Or(ds::Set );
    get_duples2 : (Tuplebase , Atom) -> Null_Or(ds::Set );
    has_duple : (Tuplebase , Duple) -> Bool;
    get_triples : Tuplebase -> ts::Set;
    get_triples1 : (Tuplebase , Atom) -> Null_Or(ts::Set );
    get_triples2 : (Tuplebase , Atom) -> Null_Or(ts::Set );
    get_triples3 : (Tuplebase , Atom) -> Null_Or(ts::Set );
    get_triples12 : (Tuplebase , Atom , Atom) -> Null_Or(ts::Set );
    get_triples13 : (Tuplebase , Atom , Atom) -> Null_Or(ts::Set );
    get_triples23 : (Tuplebase , Atom , Atom) -> Null_Or(ts::Set );
    has_triple : (Tuplebase , Triple) -> Bool;
    atoms_apply : Tuplebase -> (Atom -> Void) -> Void;};
\end{verbatim}\index[fun]{atoms\_apply}
\index[fun]{has\_triple}
\index[fun]{get\_triples23}
\index[fun]{get\_triples13}
\index[fun]{get\_triples12}
\index[fun]{get\_triples3}
\index[fun]{get\_triples2}
\index[fun]{get\_triples1}
\index[fun]{get\_triples}
\index[fun]{has\_duple}
\index[fun]{get\_duples2}
\index[fun]{get\_duples1}
\index[fun]{get\_duples}
\index[fun]{drop\_triple}
\index[fun]{drop\_duple}
\index[fun]{put\_triple}
\index[fun]{put\_duple}
\index[fun]{empty\_tuplebase}
\index[fun]{other\_of}
\index[fun]{tuplebase\_of}
\index[fun]{float\_of}
\index[fun]{string\_of}
\index[fun]{make\_other\_atom}
\index[fun]{make\_tuplebase\_atom}
\index[fun]{make\_float\_atom}
\index[fun]{make\_string\_atom}
\index[fun]{make\_atom}
\index[fun]{all\_invariants\_hold}
\index[fun]{find}
\index[fun]{exists}
\index[fun]{filter}
\index[fun]{partition}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{apply}
\index[fun]{map}
\index[fun]{difference}
\index[fun]{intersection}
\index[fun]{union}
\index[fun]{vals\_list}
\index[fun]{vals\_count}
\index[fun]{is\_subset}
\index[fun]{compare}
\index[fun]{equal}
\index[fun]{is\_empty}
\index[fun]{following\_member}
\index[fun]{preceding\_member}
\index[fun]{member}
\index[fun]{drop}
\index[fun]{add\_list}
\index[fun]{add\_\_prime\_\_}
\index[fun]{add}
\index[fun]{from\_list}
\index[fun]{singleton}
\index[fun]{empty}
\index[fun]{compare}
\index[fun]{all\_invariants\_hold}
\index[fun]{find}
\index[fun]{exists}
\index[fun]{filter}
\index[fun]{partition}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{apply}
\index[fun]{map}
\index[fun]{difference}
\index[fun]{intersection}
\index[fun]{union}
\index[fun]{vals\_list}
\index[fun]{vals\_count}
\index[fun]{is\_subset}
\index[fun]{compare}
\index[fun]{equal}
\index[fun]{is\_empty}
\index[fun]{following\_member}
\index[fun]{preceding\_member}
\index[fun]{member}
\index[fun]{drop}
\index[fun]{add\_list}
\index[fun]{add\_\_prime\_\_}
\index[fun]{add}
\index[fun]{from\_list}
\index[fun]{singleton}
\index[fun]{empty}
\index[fun]{compare}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
