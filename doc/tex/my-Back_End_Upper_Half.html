<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Back End Upper Half</TITLE>
</HEAD>
<BODY >
<A HREF="my-Front_End.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Compiler_Internals.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Back_End_Lower_Half.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc3591">16.1.4</A>  Back End Upper Half</H3><P>
<A NAME="section:compiler:backend-tophalf"></A></P><P>The back end upper half originated in the Yale <SPAN STYLE="font-variant:small-caps">FLINT</SPAN> project[12].</P><P>When the front end is done typechecking the code, it 
is handed over successively to the back end upper and 
lower halves</P><PRE CLASS="verbatim">    src/lib/compiler/back/top/
    src/lib/compiler/back/low/
</PRE><P>where the first does machine-independent stuff 
and the second does machine-dependent stuff.</P><P>From a control-flow point of view, the core 
back end upper half module is</P><BLOCKQUOTE CLASS="quote">
<A HREF="my-src_lib_compiler_back_top_main_backend-tophalf-g_pkg.html#src/lib/compiler/back/top/main/backend-tophalf-g.pkg">src/lib/compiler/back/top/main/backend-tophalf-g.pkg</A></BLOCKQUOTE><P>which schedules the various compiler passes in 
highly customizable form.</P><P>The front end gives us the code in the form of a 
deep syntax tree, defined in</P><BLOCKQUOTE CLASS="quote">
<A HREF="my-src_lib_compiler_front_typer-stuff_deep-syntax_deep-syntax_api.html#src/lib/compiler/front/typer-stuff/deep-syntax/deep-syntax.api">src/lib/compiler/front/typer-stuff/deep-syntax/deep-syntax.api</A></BLOCKQUOTE><P>The upper half module translates the deep syntax tree 
into three successive forms, each lower-level than 
the previous:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Lambdacode: A polymorphic typed lambda calculus intermediate representation.
</LI><LI CLASS="li-itemize">A-Normal: A typed form in which the function call hierarchary remains explicit.
</LI><LI CLASS="li-itemize">FPS: "Fate passing style", an untyped blocks-linked-by-gotos representation.
</LI></UL><P>The lambdacode format is defined in</P><BLOCKQUOTE CLASS="quote">
<A HREF="my-src_lib_compiler_back_top_lambdacode_lambdacode-form_api.html#src/lib/compiler/back/top/lambdacode/lambdacode-form.api">src/lib/compiler/back/top/lambdacode/lambdacode-form.api</A></BLOCKQUOTE><P>It is an essentially language-neutral high-level representation, 
so translation into it from deep syntax requires removing all 
vestiges of Mythryl-specific source syntax. This translation 
is done by</P><BLOCKQUOTE CLASS="quote">
<A HREF="my-src_lib_compiler_back_top_translate_translate-deep-syntax-to-lambdacode_pkg.html#src/lib/compiler/back/top/translate/translate-deep-syntax-to-lambdacode.pkg">src/lib/compiler/back/top/translate/translate-deep-syntax-to-lambdacode.pkg</A></BLOCKQUOTE><P>In particular, this translation requires expanding all pattern-matching 
constructs into elementary function applications, a subtask handled by</P><BLOCKQUOTE CLASS="quote">
<A HREF="my-src_lib_compiler_back_top_translate_translate-deep-syntax-pattern-to-lambdacode_pkg.html#src/lib/compiler/back/top/translate/translate-deep-syntax-pattern-to-lambdacode.pkg">src/lib/compiler/back/top/translate/translate-deep-syntax-pattern-to-lambdacode.pkg</A></BLOCKQUOTE><P>The lambdacode representation is purely transitional; 
One constructed, it is immediately converted into A-Normal form.</P><P>A-Normal format is well documented in the literature.[2] It is a 
high-level, typed, optimization-oriented format in which the call 
hierarchy remains explicit. These characteristics make some sorts 
of optimizations easy (and others correspondingly hard). Our version 
is defined in</P><BLOCKQUOTE CLASS="quote">
<A HREF="my-src_lib_compiler_back_top_anormcode_anormcode-form_api.html#src/lib/compiler/back/top/anormcode/anormcode-form.api">src/lib/compiler/back/top/anormcode/anormcode-form.api</A></BLOCKQUOTE><P>(See the comments in that file for a list of the major transforms 
performed on A-Normal Form code, and the files implementing them.)</P><P>The translation from lambdacode to anormcode form is handled by</P><BLOCKQUOTE CLASS="quote">
<A HREF="my-src_lib_compiler_back_top_lambdacode_translate-lambdacode-to-anormcode_pkg.html#src/lib/compiler/back/top/lambdacode/translate-lambdacode-to-anormcode.pkg">src/lib/compiler/back/top/lambdacode/translate-lambdacode-to-anormcode.pkg</A></BLOCKQUOTE><P>While in A-Normal form, a number of optimizations are performed 
(or can be, per configuration options handed to backend-tophalf-g.pkg).
Stefan Monnier&#X2019;s 2003 PhD Thesis "Principled Compilation and Scavenging" 
provides a good overview. [3]</P><P>When we&#X2019;ve done what we reasonably can in A-Normal form, we convert 
the code to FPS, "Fate-Passing Style". This is an untyped 
format in which code is represented essentially as a series of basic 
blocks linked by GOTOs, albeit in abstract, machine-independent form. 
In particular, the explicit function-call hierarchy is discarded, as 
is the implicit stack, replaced by fates passed as explicit 
arguments, hence the name.</P><P>Our definition of FPS is somewhat diffuse, and split into an 
externally visible API on the one hand, whose definition 
centers on</P><BLOCKQUOTE CLASS="quote">
<A HREF="my-src_lib_compiler_back_top_highcode_highcode-form_api.html#src/lib/compiler/back/top/highcode/highcode-form.api">src/lib/compiler/back/top/highcode/highcode-form.api</A><BR><A HREF="my-src_lib_compiler_back_top_highcode_highcode-form_pkg.html#src/lib/compiler/back/top/highcode/highcode-form.pkg">src/lib/compiler/back/top/highcode/highcode-form.pkg</A></BLOCKQUOTE><P>and a more complex internal package, whose definition 
centers on</P><BLOCKQUOTE CLASS="quote">
<A HREF="my-src_lib_compiler_back_top_highcode_highcode-uniq-types_api.html#src/lib/compiler/back/top/highcode/highcode-uniq-types.api">src/lib/compiler/back/top/highcode/highcode-uniq-types.api</A><BR><A HREF="my-src_lib_compiler_back_top_highcode_highcode-uniq-types_pkg.html#src/lib/compiler/back/top/highcode/highcode-uniq-types.pkg">src/lib/compiler/back/top/highcode/highcode-uniq-types.pkg</A></BLOCKQUOTE><P>Translation from A-Normal to FPS form is handled by</P><BLOCKQUOTE CLASS="quote">
<A HREF="my-src_lib_compiler_back_top_nextcode_translate-anormcode-to-nextcode-g_pkg.html#src/lib/compiler/back/top/nextcode/translate-anormcode-to-nextcode-g.pkg">src/lib/compiler/back/top/nextcode/translate-anormcode-to-nextcode-g.pkg</A></BLOCKQUOTE><P>Once in FPS form, a different set of optimizations become 
easy, and are applied. (The relative dis/advantages of 
A-Normal and FPS form are discussed in Stefan Monnier&#X2019;s 
above-mentioned PhD thesis.)</P><P>See [14] and the comments in</P><BLOCKQUOTE CLASS="quote">
<A HREF="my-src_lib_compiler_back_top_highcode_highcode-form_api.html#src/lib/compiler/back/top/highcode/highcode-form.api">src/lib/compiler/back/top/highcode/highcode-form.api</A></BLOCKQUOTE><P>for discussion of the various FPS compiler passes.
</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Front_End.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Compiler_Internals.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Back_End_Lower_Half.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
