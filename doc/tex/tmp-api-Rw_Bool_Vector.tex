\index[api]{Rw\_Bool\_Vector}
\label{api:Rw\_Bool\_Vector}
\input{top-api-Rw_Bool_Vector.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    eqtype Rw_Vector;
    Element  = Bool;
    Vector;
    maximum_vector_length : Int;
    make_rw_vector : (Int , Element) -> Rw_Vector;
    from_list : List(Element ) -> Rw_Vector;
    from_fn : (Int , (Int -> Element)) -> Rw_Vector;
    length : Rw_Vector -> Int;
    get : (Rw_Vector , Int) -> Element;
    _[] : (Rw_Vector , Int) -> Element;
    set : (Rw_Vector , Int , Element) -> Void;
    _[]:= : (Rw_Vector , Int , Element) -> Void;
    to_vector : Rw_Vector -> Vector;
    copy : {at:Int, from:Rw_Vector, into:Rw_Vector} -> Void;
    copy_vector : {at:Int, from:Vector, into:Rw_Vector} -> Void;
    keyed_apply : ((Int , Element) -> Void) -> Rw_Vector -> Void;
    apply : (Element -> Void) -> Rw_Vector -> Void;
    keyed_map_in_place : ((Int , Element) -> Element) -> Rw_Vector -> Void;
    map_in_place : (Element -> Element) -> Rw_Vector -> Void;
    keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
    keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
    fold_forward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
    fold_backward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
    keyed_find : ((Int , Element) -> Bool) -> Rw_Vector -> Null_Or(((Int , Element)) );
    find : (Element -> Bool) -> Rw_Vector -> Null_Or(Element );
    exists : (Element -> Bool) -> Rw_Vector -> Bool;
    all : (Element -> Bool) -> Rw_Vector -> Bool;
    compare_sequences : ((Element , Element) -> Order) -> (Rw_Vector , Rw_Vector) -> Order;
    from_string : String -> Rw_Vector;
    bits : (Int , List(Int )) -> Rw_Vector;
    get_bits : Rw_Vector -> List(Int );
    to_string : Rw_Vector -> String;
    is_zero : Rw_Vector -> Bool;
    extend0 : (Rw_Vector , Int) -> Rw_Vector;
    extend1 : (Rw_Vector , Int) -> Rw_Vector;
    eq_bits : (Rw_Vector , Rw_Vector) -> Bool;
    equal : (Rw_Vector , Rw_Vector) -> Bool;
    bitwise_and : (Rw_Vector , Rw_Vector , Int) -> Rw_Vector;
    bitwise_or : (Rw_Vector , Rw_Vector , Int) -> Rw_Vector;
    bitwise_xor : (Rw_Vector , Rw_Vector , Int) -> Rw_Vector;
    bitwise_not : Rw_Vector -> Rw_Vector;
    lshift : (Rw_Vector , Int) -> Rw_Vector;
    rshift : (Rw_Vector , Int) -> Rw_Vector;
    set_bit : (Rw_Vector , Int) -> Void;
    clr_bit : (Rw_Vector , Int) -> Void;
    union : Rw_Vector -> Rw_Vector -> Void;
    intersection : Rw_Vector -> Rw_Vector -> Void;
    complement : Rw_Vector -> Void;};
\end{verbatim}\index[fun]{complement}
\index[fun]{intersection}
\index[fun]{union}
\index[fun]{clr\_bit}
\index[fun]{set\_bit}
\index[fun]{rshift}
\index[fun]{lshift}
\index[fun]{bitwise\_not}
\index[fun]{bitwise\_xor}
\index[fun]{bitwise\_or}
\index[fun]{bitwise\_and}
\index[fun]{equal}
\index[fun]{eq\_bits}
\index[fun]{extend1}
\index[fun]{extend0}
\index[fun]{is\_zero}
\index[fun]{to\_string}
\index[fun]{get\_bits}
\index[fun]{bits}
\index[fun]{from\_string}
\index[fun]{compare\_sequences}
\index[fun]{all}
\index[fun]{exists}
\index[fun]{find}
\index[fun]{keyed\_find}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{keyed\_fold\_backward}
\index[fun]{keyed\_fold\_forward}
\index[fun]{map\_in\_place}
\index[fun]{keyed\_map\_in\_place}
\index[fun]{apply}
\index[fun]{keyed\_apply}
\index[fun]{copy\_vector}
\index[fun]{copy}
\index[fun]{to\_vector}
\index[fun]{\_[]:=}
\index[fun]{set}
\index[fun]{\_[]}
\index[fun]{get}
\index[fun]{length}
\index[fun]{from\_fn}
\index[fun]{from\_list}
\index[fun]{make\_rw\_vector}
\index[fun]{maximum\_vector\_length}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
