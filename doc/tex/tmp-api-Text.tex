\index[api]{Text}
\label{api:Text}
\input{top-api-Text.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {   package char
          : api {
                eqtype Char;
                eqtype String;
                from_int : Int -> Char;
                to_int : Char -> Int;
                min_char : Char;
                max_char : Char;
                max_ord : Int;
                prior : Char -> Char;
                next : Char -> Char;
                < : (Char , Char) -> Bool;
                <= : (Char , Char) -> Bool;
                > : (Char , Char) -> Bool;
                >= : (Char , Char) -> Bool;
                compare : (Char , Char) -> Order;
                scan : number_string::Reader((Char, X)) -> number_string::Reader((Char, X));
                from_string : ?.string::String -> Null_Or(Char );
                to_string : Char -> ?.string::String;
                from_cstring : ?.string::String -> Null_Or(Char );
                to_cstring : Char -> ?.string::String;
                contains : String -> Char -> Bool;
                not_contains : String -> Char -> Bool;
                is_lower : Char -> Bool;
                is_upper : Char -> Bool;
                is_digit : Char -> Bool;
                is_alpha : Char -> Bool;
                is_hex_digit : Char -> Bool;
                is_alphanumeric : Char -> Bool;
                is_print : Char -> Bool;
                is_space : Char -> Bool;
                is_punct : Char -> Bool;
                is_graph : Char -> Bool;
                is_cntrl : Char -> Bool;
                is_ascii : Char -> Bool;
                to_upper : Char -> Char;
                to_lower : Char -> Char;
                nul : Char;
                ctrl_a : Char;
                ctrl_b : Char;
                ctrl_c : Char;
                ctrl_d : Char;
                ctrl_e : Char;
                ctrl_f : Char;
                ctrl_g : Char;
                ctrl_h : Char;
                ctrl_i : Char;
                ctrl_j : Char;
                newline : Char;
                ctrl_k : Char;
                ctrl_l : Char;
                ctrl_m : Char;
                return : Char;
                ctrl_n : Char;
                ctrl_o : Char;
                ctrl_p : Char;
                ctrl_q : Char;
                ctrl_r : Char;
                ctrl_s : Char;
                ctrl_t : Char;
                ctrl_u : Char;
                ctrl_v : Char;
                ctrl_w : Char;
                ctrl_x : Char;
                ctrl_y : Char;
                ctrl_z : Char;
                del : Char;};;
        package string
          : api {
                eqtype Char;
                eqtype String;
                maximum_vector_length : Int;
                length_in_bytes : String -> Int;
                length_in_chars : String -> Int;
                prefix_length_in_bytes : (String , Int) -> Int;
                get_byte : (String , Int) -> Int;
                get_byte_as_char : (String , Int) -> Char;
                get_char_as_int : (String , Int) -> (Int , Int);
                get_char_bytecount : (String , Int) -> Int;
                extract : (String , Int , Null_Or(Int )) -> String;
                substring : (String , Int , Int) -> String;
                + : (String , String) -> String;
                cat : List(String ) -> String;
                join : String -> List(String ) -> String;
                join' : String -> String -> String -> List(String ) -> String;
                from_char : Char -> String;
                implode : List(Char ) -> String;
                explode : String -> List(Char );
                chomp : String -> String;
                map : (Char -> Char) -> String -> String;
                repeat : (String , Int) -> String;
                translate : (Char -> String) -> String -> String;
                tokens : (Char -> Bool) -> String -> List(String );
                fields : (Char -> Bool) -> String -> List(String );
                lines : String -> List(String );
                longest_common_prefix : (String , String) -> String;
                drop_leading_whitespace : String -> String;
                drop_trailing_whitespace : String -> String;
                is_prefix : String -> String -> Bool;
                is_substring : String -> String -> Bool;
                is_suffix : String -> String -> Bool;
                find_substring : String -> String -> Null_Or(Int );
                find_substring' : String -> (String , Int) -> Null_Or(Int );
                find_substring_backward : String -> String -> Null_Or(Int );
                find_substring_backward' : String -> (String , Int) -> Null_Or(Int );
                compare : (String , String) -> Order;
                compare_sequences : ((Char , Char) -> Order) -> (String , String) -> Order;
                to_lower : String -> String;
                to_upper : String -> String;
                to_mixed : String -> String;
                has_alpha : String -> Bool;
                has_lower : String -> Bool;
                has_upper : String -> Bool;
                is_alpha : String -> Bool;
                is_upper : String -> Bool;
                is_lower : String -> Bool;
                is_mixed : String -> Bool;
                is_ascii : String -> Bool;
                < : (String , String) -> Bool;
                <= : (String , String) -> Bool;
                > : (String , String) -> Bool;
                >= : (String , String) -> Bool;
                from_string : String -> Null_Or(String );
                to_string : String -> String;
                from_cstring : String -> Null_Or(String );
                to_cstring : String -> String;
                byte_offset_of_ith_char : (String , Int) -> Null_Or(Int );
                utf8_to_ucs2 : String -> String;
                    expand_tabs_and_control_chars :
                        {screencol1:Int, screencol2:Int, startcol:Int, utf8byte:Int, utf8text:String}
                        ->  {screencol1_byteoffset_in_screentext:Int, screencol1_byteoffset_in_utf8text:Int,
                            screencol1_bytescount_in_screentext:Int, screencol1_bytescount_in_utf8text:Int,
                            screencol1_colcount_on_screen:Int, screencol1_firstcol_on_screen:Int,
                            screencol2_byteoffset_in_screentext:Int, screencol2_byteoffset_in_utf8text:Int,
                            screencol2_bytescount_in_screentext:Int, screencol2_bytescount_in_utf8text:Int,
                            screencol2_colcount_on_screen:Int, screencol2_firstcol_on_screen:Int, screentext:String,
                            screentext_length_in_screencols:Int, startcol:Int, utf8byte_colcount_on_screen:Int,
                            utf8byte_firstcol_on_screen:Int};};;
        package substring
          : api {
                eqtype Char;
                eqtype String;
                Substring;
                get : (Substring , Int) -> Char;
                size : Substring -> Int;
                burst_substring : Substring -> (String , Int , Int);
                extract : (String , Int , Null_Or(Int )) -> Substring;
                make_substring : (String , Int , Int) -> Substring;
                from_string : String -> Substring;
                to_string : Substring -> String;
                is_empty : Substring -> Bool;
                getc : Substring -> Null_Or(((Char , Substring)) );
                first : Substring -> Null_Or(Char );
                drop_first : Int -> Substring -> Substring;
                drop_last : Int -> Substring -> Substring;
                make_slice : (Substring , Int , Null_Or(Int )) -> Substring;
                cat : List(Substring ) -> String;
                join : String -> List(Substring ) -> String;
                join' : String -> String -> String -> List(Substring ) -> String;
                explode : Substring -> List(Char );
                is_prefix : String -> Substring -> Bool;
                is_substring : String -> Substring -> Bool;
                is_suffix : String -> Substring -> Bool;
                compare : (Substring , Substring) -> Order;
                compare_sequences : ((Char , Char) -> Order) -> (Substring , Substring) -> Order;
                get_prefix : (Char -> Bool) -> Substring -> Substring;
                get_suffix : (Char -> Bool) -> Substring -> Substring;
                drop_prefix : (Char -> Bool) -> Substring -> Substring;
                drop_suffix : (Char -> Bool) -> Substring -> Substring;
                split_off_prefix : (Char -> Bool) -> Substring -> (Substring , Substring);
                split_off_suffix : (Char -> Bool) -> Substring -> (Substring , Substring);
                split_at : (Substring , Int) -> (Substring , Substring);
                position : String -> Substring -> (Substring , Substring);
                span : (Substring , Substring) -> Substring;
                translate : (Char -> String) -> Substring -> String;
                tokens : (Char -> Bool) -> Substring -> List(Substring );
                fields : (Char -> Bool) -> Substring -> List(Substring );
                apply : (Char -> Void) -> Substring -> Void;
                fold_forward : ((Char , X) -> X) -> X -> Substring -> X;
                fold_backward : ((Char , X) -> X) -> X -> Substring -> X;};;
        package vector_of_chars
          : api {
                Vector;
                Element;
                maximum_vector_length : Int;
                from_list : List(Element ) -> Vector;
                from_fn : (Int , (Int -> Element)) -> Vector;
                length : Vector -> Int;
                cat : List(Vector ) -> Vector;
                get : (Vector , Int) -> Element;
                _[] : (Vector , Int) -> Element;
                set : (Vector , Int , Element) -> Vector;
                _[]:= : (Vector , Int , Element) -> Vector;
                keyed_apply : ((Int , Element) -> Void) -> Vector -> Void;
                apply : (Element -> Void) -> Vector -> Void;
                keyed_map : ((Int , Element) -> Element) -> Vector -> Vector;
                map : (Element -> Element) -> Vector -> Vector;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Vector -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Vector -> X;
                fold_forward : ((Element , X) -> X) -> X -> Vector -> X;
                fold_backward : ((Element , X) -> X) -> X -> Vector -> X;
                keyed_find : ((Int , Element) -> Bool) -> Vector -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Vector -> Null_Or(Element );
                exists : (Element -> Bool) -> Vector -> Bool;
                all : (Element -> Bool) -> Vector -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Vector , Vector) -> Order;};;
        package rw_vector_of_chars
          : api {
                eqtype Rw_Vector;
                Element;
                Vector;
                maximum_vector_length : Int;
                make_rw_vector : (Int , Element) -> Rw_Vector;
                from_list : List(Element ) -> Rw_Vector;
                from_fn : (Int , (Int -> Element)) -> Rw_Vector;
                length : Rw_Vector -> Int;
                get : (Rw_Vector , Int) -> Element;
                _[] : (Rw_Vector , Int) -> Element;
                set : (Rw_Vector , Int , Element) -> Void;
                _[]:= : (Rw_Vector , Int , Element) -> Void;
                to_vector : Rw_Vector -> Vector;
                copy : {at:Int, from:Rw_Vector, into:Rw_Vector} -> Void;
                copy_vector : {at:Int, from:Vector, into:Rw_Vector} -> Void;
                keyed_apply : ((Int , Element) -> Void) -> Rw_Vector -> Void;
                apply : (Element -> Void) -> Rw_Vector -> Void;
                keyed_map_in_place : ((Int , Element) -> Element) -> Rw_Vector -> Void;
                map_in_place : (Element -> Element) -> Rw_Vector -> Void;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
                fold_forward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
                fold_backward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
                keyed_find : ((Int , Element) -> Bool) -> Rw_Vector -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Rw_Vector -> Null_Or(Element );
                exists : (Element -> Bool) -> Rw_Vector -> Bool;
                all : (Element -> Bool) -> Rw_Vector -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Rw_Vector , Rw_Vector) -> Order;};;
        package vector_slice_of_chars
          : api {
                Element;
                Vector;
                Slice;
                length : Slice -> Int;
                get : (Slice , Int) -> Element;
                make_full_slice : Vector -> Slice;
                make_slice : (Vector , Int , Null_Or(Int )) -> Slice;
                make_subslice : (Slice , Int , Null_Or(Int )) -> Slice;
                burst_slice : Slice -> (Vector , Int , Int);
                to_vector : Slice -> Vector;
                cat : List(Slice ) -> Vector;
                is_empty : Slice -> Bool;
                get_item : Slice -> Null_Or(((Element , Slice)) );
                keyed_apply : ((Int , Element) -> Void) -> Slice -> Void;
                apply : (Element -> Void) -> Slice -> Void;
                keyed_map : ((Int , Element) -> Element) -> Slice -> Vector;
                map : (Element -> Element) -> Slice -> Vector;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                fold_forward : ((Element , X) -> X) -> X -> Slice -> X;
                fold_backward : ((Element , X) -> X) -> X -> Slice -> X;
                keyed_find : ((Int , Element) -> Bool) -> Slice -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Slice -> Null_Or(Element );
                exists : (Element -> Bool) -> Slice -> Bool;
                all : (Element -> Bool) -> Slice -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Slice , Slice) -> Order;};;
        package rw_vector_slice_of_chars
          : api {
                Element;
                Vector;
                Rw_Vector;
                Slice;
                Vector_Slice;
                length : Slice -> Int;
                get : (Slice , Int) -> Element;
                set : (Slice , Int , Element) -> Void;
                _[] : (Slice , Int) -> Element;
                _[]:= : (Slice , Int , Element) -> Void;
                make_full_slice : Rw_Vector -> Slice;
                make_slice : (Rw_Vector , Int , Null_Or(Int )) -> Slice;
                make_subslice : (Slice , Int , Null_Or(Int )) -> Slice;
                burst_slice : Slice -> (Rw_Vector , Int , Int);
                to_vector : Slice -> Vector;
                copy : {at:Int, from:Slice, into:Rw_Vector} -> Void;
                copy_vector : {at:Int, from:Vector_Slice, into:Rw_Vector} -> Void;
                is_empty : Slice -> Bool;
                get_item : Slice -> Null_Or(((Element , Slice)) );
                keyed_apply : ((Int , Element) -> Void) -> Slice -> Void;
                apply : (Element -> Void) -> Slice -> Void;
                map_in_place : (Element -> Element) -> Slice -> Void;
                keyed_map_in_place : ((Int , Element) -> Element) -> Slice -> Void;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                fold_forward : ((Element , X) -> X) -> X -> Slice -> X;
                fold_backward : ((Element , X) -> X) -> X -> Slice -> X;
                keyed_find : ((Int , Element) -> Bool) -> Slice -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Slice -> Null_Or(Element );
                exists : (Element -> Bool) -> Slice -> Bool;
                all : (Element -> Bool) -> Slice -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Slice , Slice) -> Order;};;
    sharing vector_slice_of_chars::Slice = rw_vector_slice_of_chars::Vector_Slice
    sharing rw_vector_slice_of_chars::Rw_Vector = rw_vector_of_chars::Rw_Vector
      sharing
        rw_vector_slice_of_chars::Vector = vector_slice_of_chars::Vector = rw_vector_of_chars::Vector =
        vector_of_chars::Vector = substring::String = string::String = char::String
      sharing
        rw_vector_slice_of_chars::Element = vector_slice_of_chars::Element = rw_vector_of_chars::Element =
        vector_of_chars::Element = substring::Char = string::Char = char::Char};
\end{verbatim}\index[fun]{compare\_sequences}
\index[fun]{all}
\index[fun]{exists}
\index[fun]{find}
\index[fun]{keyed\_find}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{keyed\_fold\_backward}
\index[fun]{keyed\_fold\_forward}
\index[fun]{keyed\_map\_in\_place}
\index[fun]{map\_in\_place}
\index[fun]{apply}
\index[fun]{keyed\_apply}
\index[fun]{get\_item}
\index[fun]{is\_empty}
\index[fun]{copy\_vector}
\index[fun]{copy}
\index[fun]{to\_vector}
\index[fun]{burst\_slice}
\index[fun]{make\_subslice}
\index[fun]{make\_slice}
\index[fun]{make\_full\_slice}
\index[fun]{\_[]:=}
\index[fun]{\_[]}
\index[fun]{set}
\index[fun]{get}
\index[fun]{length}
\index[fun]{compare\_sequences}
\index[fun]{all}
\index[fun]{exists}
\index[fun]{find}
\index[fun]{keyed\_find}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{keyed\_fold\_backward}
\index[fun]{keyed\_fold\_forward}
\index[fun]{map}
\index[fun]{keyed\_map}
\index[fun]{apply}
\index[fun]{keyed\_apply}
\index[fun]{get\_item}
\index[fun]{is\_empty}
\index[fun]{cat}
\index[fun]{to\_vector}
\index[fun]{burst\_slice}
\index[fun]{make\_subslice}
\index[fun]{make\_slice}
\index[fun]{make\_full\_slice}
\index[fun]{get}
\index[fun]{length}
\index[fun]{compare\_sequences}
\index[fun]{all}
\index[fun]{exists}
\index[fun]{find}
\index[fun]{keyed\_find}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{keyed\_fold\_backward}
\index[fun]{keyed\_fold\_forward}
\index[fun]{map\_in\_place}
\index[fun]{keyed\_map\_in\_place}
\index[fun]{apply}
\index[fun]{keyed\_apply}
\index[fun]{copy\_vector}
\index[fun]{copy}
\index[fun]{to\_vector}
\index[fun]{\_[]:=}
\index[fun]{set}
\index[fun]{\_[]}
\index[fun]{get}
\index[fun]{length}
\index[fun]{from\_fn}
\index[fun]{from\_list}
\index[fun]{make\_rw\_vector}
\index[fun]{maximum\_vector\_length}
\index[fun]{compare\_sequences}
\index[fun]{all}
\index[fun]{exists}
\index[fun]{find}
\index[fun]{keyed\_find}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{keyed\_fold\_backward}
\index[fun]{keyed\_fold\_forward}
\index[fun]{map}
\index[fun]{keyed\_map}
\index[fun]{apply}
\index[fun]{keyed\_apply}
\index[fun]{\_[]:=}
\index[fun]{set}
\index[fun]{\_[]}
\index[fun]{get}
\index[fun]{cat}
\index[fun]{length}
\index[fun]{from\_fn}
\index[fun]{from\_list}
\index[fun]{maximum\_vector\_length}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{apply}
\index[fun]{fields}
\index[fun]{tokens}
\index[fun]{translate}
\index[fun]{span}
\index[fun]{position}
\index[fun]{split\_at}
\index[fun]{split\_off\_suffix}
\index[fun]{split\_off\_prefix}
\index[fun]{drop\_suffix}
\index[fun]{drop\_prefix}
\index[fun]{get\_suffix}
\index[fun]{get\_prefix}
\index[fun]{compare\_sequences}
\index[fun]{compare}
\index[fun]{is\_suffix}
\index[fun]{is\_substring}
\index[fun]{is\_prefix}
\index[fun]{explode}
\index[fun]{join\_\_prime\_\_}
\index[fun]{join}
\index[fun]{cat}
\index[fun]{make\_slice}
\index[fun]{drop\_last}
\index[fun]{drop\_first}
\index[fun]{first}
\index[fun]{getc}
\index[fun]{is\_empty}
\index[fun]{to\_string}
\index[fun]{from\_string}
\index[fun]{make\_substring}
\index[fun]{extract}
\index[fun]{burst\_substring}
\index[fun]{size}
\index[fun]{get}
\index[fun]{expand\_tabs\_and\_control\_chars}
\index[fun]{utf8\_to\_ucs2}
\index[fun]{byte\_offset\_of\_ith\_char}
\index[fun]{to\_cstring}
\index[fun]{from\_cstring}
\index[fun]{to\_string}
\index[fun]{from\_string}
\index[fun]{>=}
\index[fun]{>}
\index[fun]{<=}
\index[fun]{<}
\index[fun]{is\_ascii}
\index[fun]{is\_mixed}
\index[fun]{is\_lower}
\index[fun]{is\_upper}
\index[fun]{is\_alpha}
\index[fun]{has\_upper}
\index[fun]{has\_lower}
\index[fun]{has\_alpha}
\index[fun]{to\_mixed}
\index[fun]{to\_upper}
\index[fun]{to\_lower}
\index[fun]{compare\_sequences}
\index[fun]{compare}
\index[fun]{find\_substring\_backward\_\_prime\_\_}
\index[fun]{find\_substring\_backward}
\index[fun]{find\_substring\_\_prime\_\_}
\index[fun]{find\_substring}
\index[fun]{is\_suffix}
\index[fun]{is\_substring}
\index[fun]{is\_prefix}
\index[fun]{drop\_trailing\_whitespace}
\index[fun]{drop\_leading\_whitespace}
\index[fun]{longest\_common\_prefix}
\index[fun]{lines}
\index[fun]{fields}
\index[fun]{tokens}
\index[fun]{translate}
\index[fun]{repeat}
\index[fun]{map}
\index[fun]{chomp}
\index[fun]{explode}
\index[fun]{implode}
\index[fun]{from\_char}
\index[fun]{join\_\_prime\_\_}
\index[fun]{join}
\index[fun]{cat}
\index[fun]{+}
\index[fun]{substring}
\index[fun]{extract}
\index[fun]{get\_char\_bytecount}
\index[fun]{get\_char\_as\_int}
\index[fun]{get\_byte\_as\_char}
\index[fun]{get\_byte}
\index[fun]{prefix\_length\_in\_bytes}
\index[fun]{length\_in\_chars}
\index[fun]{length\_in\_bytes}
\index[fun]{maximum\_vector\_length}
\index[fun]{del}
\index[fun]{ctrl\_z}
\index[fun]{ctrl\_y}
\index[fun]{ctrl\_x}
\index[fun]{ctrl\_w}
\index[fun]{ctrl\_v}
\index[fun]{ctrl\_u}
\index[fun]{ctrl\_t}
\index[fun]{ctrl\_s}
\index[fun]{ctrl\_r}
\index[fun]{ctrl\_q}
\index[fun]{ctrl\_p}
\index[fun]{ctrl\_o}
\index[fun]{ctrl\_n}
\index[fun]{return}
\index[fun]{ctrl\_m}
\index[fun]{ctrl\_l}
\index[fun]{ctrl\_k}
\index[fun]{newline}
\index[fun]{ctrl\_j}
\index[fun]{ctrl\_i}
\index[fun]{ctrl\_h}
\index[fun]{ctrl\_g}
\index[fun]{ctrl\_f}
\index[fun]{ctrl\_e}
\index[fun]{ctrl\_d}
\index[fun]{ctrl\_c}
\index[fun]{ctrl\_b}
\index[fun]{ctrl\_a}
\index[fun]{nul}
\index[fun]{to\_lower}
\index[fun]{to\_upper}
\index[fun]{is\_ascii}
\index[fun]{is\_cntrl}
\index[fun]{is\_graph}
\index[fun]{is\_punct}
\index[fun]{is\_space}
\index[fun]{is\_print}
\index[fun]{is\_alphanumeric}
\index[fun]{is\_hex\_digit}
\index[fun]{is\_alpha}
\index[fun]{is\_digit}
\index[fun]{is\_upper}
\index[fun]{is\_lower}
\index[fun]{not\_contains}
\index[fun]{contains}
\index[fun]{to\_cstring}
\index[fun]{from\_cstring}
\index[fun]{to\_string}
\index[fun]{from\_string}
\index[fun]{scan}
\index[fun]{compare}
\index[fun]{>=}
\index[fun]{>}
\index[fun]{<=}
\index[fun]{<}
\index[fun]{next}
\index[fun]{prior}
\index[fun]{max\_ord}
\index[fun]{max\_char}
\index[fun]{min\_char}
\index[fun]{to\_int}
\index[fun]{from\_int}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
