<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Pattern Matching</TITLE>
</HEAD>
<BODY >
<A HREF="my-Vectors.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mutually_Recursive_Functions_and_Datastructures.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc70">5.3.5</A>  Pattern Matching</H3><P>In many languages, exchanging the values of two variables is an 
ugly if simple chore requiring resort to a temporary variable. In 
C, for example, we might have something like</P><PRE CLASS="verbatim">    {   int i = 12;
        int j = 13;
        ...
        /* Need to swap i with j now: */
        {   int temp = i;
            i = j;
            j = temp;
        }
        ...
    }
</PRE><P>A few languages have a special hack which lets you do something like that in 
one line. Mythryl has something which looks like one of those hacks:</P><PRE CLASS="verbatim">    linux$ my

    eval:  i = 12;
    eval:  j = 13;

    eval:  my (j,i) = (i,j);

    eval:  i;
    13

    eval:  j;
    12
</PRE><P>But in Mythryl, this is not a special-case hack, but rather a specific application 
of a pervasive facility known as <I>pattern matching</I>.</P><P>Consider the typical Perl subroutine prologue, which looks something like this: </P><PRE CLASS="verbatim">    sub mumble {
        local( $arg1, $arg2, $arg3 ) = @_;
        ...
    }
</PRE><P>The <TT>local</TT> statement above is unpacking the anonymous vector <CODE><TT>@_</TT></CODE> into 
three local variables <TT>$arg1</TT>, <TT>$arg2</TT>, <TT>$arg3</TT>. It is doing 
three assignments in one line. This notation is admirably economical!</P><P>Mythryl allows similar parallel assignments in a very general and flexible way.</P><P>Here is an example of unpacking a three-slot tuple into three variables:</P><PRE CLASS="verbatim">    linux$ my
    eval:  x = (1,2,3);

    eval:  my (a,b,c) = x;

    eval:  a;
    1

    eval:  b;
    2

    eval:  c;
    3
</PRE><P>Here is a matching example of unpacking a three-field record into three variables:</P><PRE CLASS="verbatim">    eval:  x = { name =&gt; "John Doe", height =&gt; 2.0, weight =&gt; 100.0 };

    eval:  my { name =&gt; a, height =&gt; b, weight =&gt; c } = x;

    eval:  a;
    "John Doe"

    eval:  b;
    2.0

    eval:  c;
    100.0
</PRE><P>In practice, one frequently unpacks the record into variables with the 
same names as the record fields:</P><PRE CLASS="verbatim">    eval:  x = { name =&gt; "John Doe", height =&gt; 2.0, weight =&gt; 100.0 };

    eval:  my { name =&gt; name, height =&gt; height, weight =&gt; weight } = x;

    eval:  name;
    "John Doe"

    eval:  height;
    2.0

    eval:  weight;
    100.0
</PRE><P>In cases like this, the redundancy of an expression like</P><PRE CLASS="verbatim">    my { name =&gt; name, height =&gt; height, weight =&gt; weight } = x;
</PRE><P>can quickly become annoying, so Mythryl allows one to simply 
drop the variable name in such cases; if it is not given, Mythryl 
assumes it is the same as the field name:</P><PRE CLASS="verbatim">    eval:  x = { name =&gt; "John Doe", height =&gt; 2.0, weight =&gt; 100.0 };

    eval:  my { name, height, weight } = x;

    eval:  name;
    "John Doe"

    eval:  height;
    2.0

    eval:  weight;
    100.0
</PRE><P>This code idiom is used pervasively in Mythryl code.</P><P>Similar comments apply in the reverse direction, when 
constructing records. It is very common to accumulate values one by 
one in local variables and then construct a record when all values 
are in hand:</P><PRE CLASS="verbatim">    eval:  a = "John Doe";
    eval:  b = 2.0;
    eval:  c = 100.0;

    eval:  x = { name =&gt; a, height =&gt; b, weight =&gt; c };

    { height=2.0, name="John Doe", weight=100.0 }
</PRE><P>Once again, it is very common to accumulate the values in variables 
with the same names as the field-names in the record:</P><PRE CLASS="verbatim">    eval:  name = "John Doe";
    eval:  height = 2.0;
    eval:  weight = 100.0;

    eval:  x = { name =&gt; name, height =&gt; height, weight =&gt; weight };
    { height=2.0, name="John Doe", weight=100.0 }
</PRE><P>Once again, repeating every identifier twice during construction of the 
record quickly becomes tedious, so Mythryl allows dropping the variable 
name in such cases:</P><PRE CLASS="verbatim">    eval:  name = "John Doe";
    eval:  height = 2.0;
    eval:  weight = 100.0;

    eval:  x = { name, height, weight };
    { height=2.0, name="John Doe", weight=100.0 }
</PRE><P>This is another idiom used pervasively in Mythryl code.</P><P>Let us return to the topic of pattern matching.</P><P>One frequently wishes to extract only a subset of the values in a 
tuple. In this case one uses underbar wildcards in the slots which 
are not of interest:</P><PRE CLASS="verbatim">    eval:  x = (1,2,3,4,5,6);
    eval:  my (a,_,c,_,d,_) = x;

    eval:  a;
    1

    eval:  c;
    3

    eval:  d;
    5
</PRE><P>This is yet another pervasive idiom.</P><P>To make things more interesting, Mythryl also allows tuples and records to 
be nested arbitrarily in patterns:</P><PRE CLASS="verbatim">    eval:  x = ( 1, (2,3), { name=&gt;"John Doe", height =&gt; 2.0, weight =&gt; 100.0 } );

    eval:  my (_, (_, a), { name,  ... } ) = x;

    eval:  a;
    3

    eval:  name;
    "John Doe"
</PRE><P>Here we have a tuple containing another tuple plus a record; we 
have extracted one value each from the nested tuple and record, 
using a <TT>... </TT> elipsis to represent the record fields in which 
we have no interest and underbar wildcards to represent the tuple 
slots in which we have no interest.</P><P>Pattern matching pops up in Mythryl in all sorts of spots in which 
you might not at first expect it. For example, the rules in 
<TT>case</TT> statements allow pattern-matching:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    x = (1, (2,3));

    case x
    (1, (b, c)) =&gt; printf "one-tuple carrying %d %d\n" b c;
    (a, (b, c)) =&gt; printf "%d-tuple carrying %d %d\n" a b c;
    esac;
</PRE><P>When run, this produces</P><PRE CLASS="verbatim">    linux$ ./my-script
    one-tuple carrying 2 3
    linux$ 
</PRE><P>When interpreting such case statements it is important to remember 
that they are logically evaluated by the compiler top to bottom, 
selecting the first one which matches. (In practice, the compiler 
uses sophisticated optimization techniques to speed execution.) </P><P>As the patterns used in such rules become more complex, it becomes 
ever more reassuring that the compiler issues diagnostics for rules 
which are redundant (can never match) and rulesets which are 
incomplete (some possible inputs would match no rule).</P><P>The <TT>case</TT> statement pattern matching facility can be used in 
some interesting and initially non-obvious ways. Suppose for 
example that one has two Boolean variables and needs to execute 
different code for all four possible combinations of their values. 
One could nest multiple <TT>if</TT> statements, but this is cleaner:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    a = TRUE;
    b = FALSE;

    case (a,b)
    (TRUE, TRUE ) =&gt; print "TRUE / TRUE  case\n";
    (TRUE, FALSE) =&gt; print "TRUE / FALSE case\n";
    (FALSE,TRUE ) =&gt; print "FALSE/ TRUE  case\n";
    (FALSE,FALSE) =&gt; print "FALSE/ FALSE case\n";
    esac;
</PRE><PRE CLASS="verbatim">    linux$ ./my-script
    TRUE / FALSE case
    linux$ 
</PRE><P>In this particular case the benefit is small, but as the 
number of states to be enumerated grows larger, so does 
the improvement in code readability and maintainability 
relative to using a rats-nest of <TT>if</TT> statements.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Vectors.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mutually_Recursive_Functions_and_Datastructures.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
