<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Raw_Syntax</TITLE>
</HEAD>
<BODY >
<A HREF="my-Property_List.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Compiler_APIs.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Source_Code_Source.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc925">14.5.34</A>  Raw_Syntax</H3><P>				<A NAME="@api257"></A>
<A NAME="api:Raw_Syntax"></A>

The compiler <TT>Raw_Syntax</TT> api defines access to the Mythryl compiler data structure 
used to represent raw syntax trees of code under compilation.</P><P>Like many compilers, the Mythryl compiler starts by translating the 
source code first into a raw syntax tree closely reflecting the 
surface structure of the code, and then into a more abstract deep 
syntax tree less reflective of the surface syntax which more 
perspicuously exposes the underlying semantic structure of the code.</P><P>In the case of the Mythryl compiler, the code is then translated into 
<A HREF="my-Anormcode_Form.html#api:Anormcode_Form">Anormcode_Form</A> and after that transformed to <B>fate passing style</B>, the workhorse representation of the 
Mythryl compiler back end upper half.</P><P>The <TT>Raw_Syntax</TT> api is implemented by the <A HREF="my-raw_syntax.html#pkg:raw_syntax">raw_syntax</A> package.</P><P>The <TT>Rww_Syntax</TT> api source code is in <A HREF="my-src_lib_compiler_front_parser_raw-syntax_raw-syntax_api.html#src/lib/compiler/front/parser/raw-syntax/raw-syntax.api">src/lib/compiler/front/parser/raw-syntax/raw-syntax.api</A>.</P><P>See also: <A HREF="my-Deep_Syntax.html#api:Deep_Syntax">Deep_Syntax</A> API.</P><P>See also: <A HREF="my-Anormcode_Form.html#api:Anormcode_Form">Anormcode_Form</A> API.</P><P><FONT SIZE=1><I>The above information is manually maintained and may contain errors.</I></FONT>
</P><PRE CLASS="verbatim">api {
    Fixity;
    Symbol;
    infixleft : Int -&gt; Fixity;
    infixright : Int -&gt; Fixity;
    Literal  = multiword_int::Int;
    Source_Code_Position  = Int;
    Source_Code_Region  = (Source_Code_Position , Source_Code_Position);
    Path  = List(Symbol );
    Fixity_Item X = {fixity:Null_Or(Symbol ), item:X, source_code_region:Source_Code_Region};
        Package_Cast
        X = NO_PACKAGE_CAST | PARTIAL_PACKAGE_CAST X | STRONG_PACKAGE_CAST X | WEAK_PACKAGE_CAST X;
    Fun_Kind  = MESSAGE_FUN | METHOD_FUN | PLAIN_FUN;
    Package_Kind  = CLASS2_PACKAGE | CLASS_PACKAGE | PLAIN_PACKAGE;
        Raw_Expression
        = AND_EXPRESSION
        (Raw_Expression , Raw_Expression)
        |
        APPLY_EXPRESSION
        {argument:Raw_Expression, function:Raw_Expression}
        |
        CASE_EXPRESSION
        {expression:Raw_Expression, rules:List(Case_Rule )}
        |
        CHAR_CONSTANT_IN_EXPRESSION
        String
        |
        EXCEPT_EXPRESSION
        {expression:Raw_Expression, rules:List(Case_Rule )}
        |
        FLOAT_CONSTANT_IN_EXPRESSION
        String
        |
        FN_EXPRESSION
        List(Case_Rule )
        |
        IF_EXPRESSION
        {else_case:Raw_Expression, test_case:Raw_Expression, then_case:Raw_Expression}
        |
        IMPLICIT_THUNK_PARAMETER
        Path
        |
        INT_CONSTANT_IN_EXPRESSION
        Literal
        |
        LET_EXPRESSION
        {declaration:Declaration, expression:Raw_Expression}
        |
        LIST_EXPRESSION
        List(Raw_Expression )
        |
        OBJECT_FIELD_EXPRESSION
        {field:Symbol, object:Raw_Expression}
        |
        OR_EXPRESSION
        (Raw_Expression , Raw_Expression)
        |
        PRE_FIXITY_EXPRESSION
        List(Fixity_Item(Raw_Expression ) )
        |
        RAISE_EXPRESSION
        Raw_Expression
        |
        RECORD_IN_EXPRESSION
        List(((Symbol , Raw_Expression)) )
        |
        RECORD_SELECTOR_EXPRESSION
        Symbol
        |
        SEQUENCE_EXPRESSION
        List(Raw_Expression )
        |
        SOURCE_CODE_REGION_FOR_EXPRESSION
        (Raw_Expression , Source_Code_Region)
        |
        STRING_CONSTANT_IN_EXPRESSION
        String
        |
        TUPLE_EXPRESSION
        List(Raw_Expression )
        |
        TYPE_CONSTRAINT_EXPRESSION
        {constraint:Any_Type, expression:Raw_Expression}
        |
        UNT_CONSTANT_IN_EXPRESSION
        Literal
        |
        VARIABLE_IN_EXPRESSION
        Path
        |
        VECTOR_IN_EXPRESSION
        List(Raw_Expression )
        |
        WHILE_EXPRESSION
        {expression:Raw_Expression, test:Raw_Expression};
    Case_Rule  = CASE_RULE {expression:Raw_Expression, pattern:Case_Pattern};
        Case_Pattern
        = APPLY_PATTERN
        {argument:Case_Pattern, constructor:Case_Pattern}
        |
        AS_PATTERN
        {expression_pattern:Case_Pattern, variable_pattern:Case_Pattern}
        |
        CHAR_CONSTANT_IN_PATTERN
        String
        |
        INT_CONSTANT_IN_PATTERN
        Literal
        |
        LIST_PATTERN
        List(Case_Pattern )
        |
        OR_PATTERN
        List(Case_Pattern )
        |
        PRE_FIXITY_PATTERN
        List(Fixity_Item(Case_Pattern ) )
        |
        RECORD_PATTERN
        {definition:List(((Symbol , Case_Pattern)) ), is_incomplete:Bool}
        |
        SOURCE_CODE_REGION_FOR_PATTERN
        (Case_Pattern , Source_Code_Region)
        |
        STRING_CONSTANT_IN_PATTERN
        String
        |
        TUPLE_PATTERN
        List(Case_Pattern )
        |
        TYPE_CONSTRAINT_PATTERN
        {pattern:Case_Pattern, type_constraint:Any_Type}
        |
        UNT_CONSTANT_IN_PATTERN
        Literal
        |
        VARIABLE_IN_PATTERN
        Path
        |
        VECTOR_PATTERN
        List(Case_Pattern )
        |
        WILDCARD_PATTERN;
        Package_Expression
        = CALL_OF_GENERIC
        (Path , List(((Package_Expression , Bool)) ))
        |
        INTERNAL_CALL_OF_GENERIC
        (Path , List(((Package_Expression , Bool)) ))
        |
        LET_IN_PACKAGE
        (Declaration , Package_Expression)
        |
        PACKAGE_BY_NAME
        Path
        |
        PACKAGE_CAST
        (Package_Expression , Package_Cast(Api_Expression ))
        |
        PACKAGE_DEFINITION
        Declaration
        |
        SOURCE_CODE_REGION_FOR_PACKAGE
        (Package_Expression , Source_Code_Region);
        Generic_Expression
        = CONSTRAINED_CALL_OF_GENERIC
        (Path , List(((Package_Expression , Bool)) ) , Package_Cast(Generic_Api_Expression ))
        |
        GENERIC_BY_NAME
        (Path , Package_Cast(Generic_Api_Expression ))
        |
        GENERIC_DEFINITION
                {body:Package_Expression, constraint:Package_Cast(Api_Expression ),
                parameters:List(((Null_Or(Symbol ) , Api_Expression)) )}
        |
        LET_IN_GENERIC
        (Declaration , Generic_Expression)
        |
        SOURCE_CODE_REGION_FOR_GENERIC
        (Generic_Expression , Source_Code_Region);
        Api_Expression
        = API_BY_NAME
        Symbol
        |
        API_DEFINITION
        List(Api_Element )
        |
        API_WITH_WHERE_SPECS
        (Api_Expression , List(Where_Spec ))
        |
        SOURCE_CODE_REGION_FOR_API
        (Api_Expression , Source_Code_Region);
        Where_Spec
        = WHERE_PACKAGE
        (List(Symbol ) , List(Symbol ))
        |
        WHERE_TYPE
        (List(Symbol ) , List(Typevar ) , Any_Type);
        Generic_Api_Expression
        = GENERIC_API_BY_NAME
        Symbol
        |
        GENERIC_API_DEFINITION
        {parameter:List(((Null_Or(Symbol ) , Api_Expression)) ), result:Api_Expression}
        |
        SOURCE_CODE_REGION_FOR_GENERIC_API
        (Generic_Api_Expression , Source_Code_Region);
        Api_Element
        = EXCEPTIONS_IN_API
        List(((Symbol , Null_Or(Any_Type ))) )
        |
        GENERICS_IN_API
        List(((Symbol , Generic_Api_Expression)) )
        |
        IMPORT_IN_API
        Api_Expression
        |
        PACKAGES_IN_API
        List(((Symbol , Api_Expression , Null_Or(Path ))) )
        |
        PACKAGE_SHARING_IN_API
        List(Path )
        |
        SOURCE_CODE_REGION_FOR_API_ELEMENT
        (Api_Element , Source_Code_Region)
        |
        TYPES_IN_API
        (List(((Symbol , List(Typevar ) , Null_Or(Any_Type ))) ) , Bool)
        |
        TYPE_SHARING_IN_API
        List(Path )
        |
        VALCONS_IN_API
        {sumtypes:List(Sumtype ), with_types:List(Named_Type )}
        |
        VALUES_IN_API
        List(((Symbol , Any_Type)) );
        Declaration
        = API_DECLARATIONS
        List(Named_Api )
        |
        EXCEPTION_DECLARATIONS
        List(Named_Exception )
        |
        FIELD_DECLARATIONS
        (List(Named_Field ) , List(Typevar ))
        |
        FIXITY_DECLARATIONS
        {fixity:Fixity, ops:List(Symbol )}
        |
        FUNCTION_DECLARATIONS
        (List(Named_Function ) , List(Typevar ))
        |
        GENERIC_API_DECLARATIONS
        List(Named_Generic_Api )
        |
        GENERIC_DECLARATIONS
        List(Named_Generic )
        |
        INCLUDE_DECLARATIONS
        List(Path )
        |
        LOCAL_DECLARATIONS
        (Declaration , Declaration)
        |
        NADA_FUNCTION_DECLARATIONS
        (List(Nada_Named_Function ) , List(Typevar ))
        |
        OVERLOADED_VARIABLE_DECLARATION
        (Symbol , Any_Type , List(Raw_Expression ) , Bool)
        |
        PACKAGE_DECLARATIONS
        List(Named_Package )
        |
        PRE_COMPILE_CODE
        String
        |
        RECURSIVE_VALUE_DECLARATIONS
        (List(Named_Recursive_Value ) , List(Typevar ))
        |
        SEQUENTIAL_DECLARATIONS
        List(Declaration )
        |
        SOURCE_CODE_REGION_FOR_DECLARATION
        (Declaration , Source_Code_Region)
        |
        SUMTYPE_DECLARATIONS
        {sumtypes:List(Sumtype ), with_types:List(Named_Type )}
        |
        TYPE_DECLARATIONS
        List(Named_Type )
        |
        VALUE_DECLARATIONS
        (List(Named_Value ) , List(Typevar ));
        Named_Field
        = NAMED_FIELD
        {init:Null_Or(Raw_Expression ), name:Symbol, type:Any_Type}
        |
        SOURCE_CODE_REGION_FOR_NAMED_FIELD
        (Named_Field , Source_Code_Region);
        Named_Value
        = NAMED_VALUE
        {expression:Raw_Expression, is_lazy:Bool, pattern:Case_Pattern}
        |
        SOURCE_CODE_REGION_FOR_NAMED_VALUE
        (Named_Value , Source_Code_Region);
        Named_Recursive_Value
        = NAMED_RECURSIVE_VALUE
                {expression:Raw_Expression, fixity:Null_Or(((Symbol , Source_Code_Region)) ), is_lazy:Bool,
                null_or_type:Null_Or(Any_Type ), variable_symbol:Symbol}
        |
        SOURCE_CODE_REGION_FOR_RECURSIVELY_NAMED_VALUE
        (Named_Recursive_Value , Source_Code_Region);
        Named_Function
        = NAMED_FUNCTION
                {is_lazy:Bool, kind:Fun_Kind, null_or_type:Null_Or(Any_Type ),
                pattern_clauses:List(Pattern_Clause )}
        |
        SOURCE_CODE_REGION_FOR_NAMED_FUNCTION
        (Named_Function , Source_Code_Region);
        Pattern_Clause
        = PATTERN_CLAUSE        {expression:Raw_Expression, patterns:List(Fixity_Item(Case_Pattern ) ),
                                result_type:Null_Or(Any_Type )};
        Nada_Named_Function
        = NADA_NAMED_FUNCTION
        (List(Nada_Pattern_Clause ) , Bool)
        |
        SOURCE_CODE_REGION_FOR_NADA_NAMED_FUNCTION
        (Nada_Named_Function , Source_Code_Region);
        Nada_Pattern_Clause
        = NADA_PATTERN_CLAUSE
        {expression:Raw_Expression, pattern:Case_Pattern, result_type:Null_Or(Any_Type )};
        Named_Type
        = NAMED_TYPE
        {definition:Any_Type, name_symbol:Symbol, typevars:List(Typevar )}
        |
        SOURCE_CODE_REGION_FOR_NAMED_TYPE
        (Named_Type , Source_Code_Region);
        Sumtype
        = SOURCE_CODE_REGION_FOR_UNION_TYPE
        (Sumtype , Source_Code_Region)
        |
        SUM_TYPE
        {is_lazy:Bool, name_symbol:Symbol, right_hand_side:Sumtype_Right_Hand_Side, typevars:List(Typevar )};
    Sumtype_Right_Hand_Side  = REPLICAS List(Symbol ) | VALCONS List(((Symbol , Null_Or(Any_Type ))) );
        Named_Exception
        = DUPLICATE_NAMED_EXCEPTION
        {equal_to:Path, exception_symbol:Symbol}
        |
        NAMED_EXCEPTION
        {exception_symbol:Symbol, exception_type:Null_Or(Any_Type )}
        |
        SOURCE_CODE_REGION_FOR_NAMED_EXCEPTION
        (Named_Exception , Source_Code_Region);
        Named_Package
        = NAMED_PACKAGE
                {constraint:Package_Cast(Api_Expression ), definition:Package_Expression, kind:Package_Kind,
                name_symbol:Symbol}
        |
        SOURCE_CODE_REGION_FOR_NAMED_PACKAGE
        (Named_Package , Source_Code_Region);
        Named_Generic
        = NAMED_GENERIC
        {definition:Generic_Expression, name_symbol:Symbol}
        |
        SOURCE_CODE_REGION_FOR_NAMED_GENERIC
        (Named_Generic , Source_Code_Region);
        Named_Api
        = NAMED_API
        {definition:Api_Expression, name_symbol:Symbol}
        |
        SOURCE_CODE_REGION_FOR_NAMED_API
        (Named_Api , Source_Code_Region);
        Named_Generic_Api
        = NAMED_GENERIC_API
        {definition:Generic_Api_Expression, name_symbol:Symbol}
        |
        SOURCE_REGION_FOR_NAMED_GENERIC_API
        (Named_Generic_Api , Source_Code_Region);
    Typevar  = SOURCE_CODE_REGION_FOR_TYPEVAR (Typevar , Source_Code_Region) | TYPEVAR Symbol;
        Any_Type
        = RECORD_TYPE
        List(((Symbol , Any_Type)) )
        |
        SOURCE_CODE_REGION_FOR_TYPE
        (Any_Type , Source_Code_Region)
        |
        TUPLE_TYPE
        List(Any_Type )
        |
        TYPEVAR_TYPE
        Typevar
        |
        TYPE_TYPE
        (List(Symbol ) , List(Any_Type ));};
</PRE><P><A NAME="@fun6280"></A>
<A NAME="@fun6281"></A>

</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Property_List.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Compiler_APIs.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Source_Code_Source.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
