\index[api]{Map\_With\_Implicit\_Keys}
\label{api:Map\_With\_Implicit\_Keys}
\input{top-api-Map_With_Implicit_Keys.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {   package key
          : api {
                Key;
                compare : (Key , Key) -> Order;};;
    Map X;
    empty : (X -> key::Key) -> Map(X );
    is_empty : Map(X ) -> Bool;
    singleton : (X , (X -> key::Key)) -> Map(X );
    set : (Map(X ) , X) -> Map(X );
    set' : (X , Map(X )) -> Map(X );
    $ : (Map(X ) , X) -> Map(X );
    get : (Map(X ) , key::Key) -> Null_Or(X );
    get_or_raise_exception_not_found : (Map(X ) , key::Key) -> X;
    contains_key : (Map(X ) , key::Key) -> Bool;
    get_and_drop : (Map(X ) , key::Key) -> (Map(X ) , Null_Or(X ));
    drop : (Map(X ) , key::Key) -> Map(X );
    first_val_else_null : Map(X ) -> Null_Or(X );
    first_keyval_else_null : Map(X ) -> Null_Or(((key::Key , X)) );
    last_val_else_null : Map(X ) -> Null_Or(X );
    last_keyval_else_null : Map(X ) -> Null_Or(((key::Key , X)) );
    vals_count : Map(X ) -> Int;
    vals_list : Map(X ) -> List(X );
    keyvals_list : Map(X ) -> List(((key::Key , X)) );
    keys_list : Map(X ) -> List(key::Key );
    compare_sequences : ((X , X) -> Order) -> (Map(X ) , Map(X )) -> Order;
    union_with : ((X , X) -> X) -> (Map(X ) , Map(X )) -> Map(X );
    keyed_union_with : ((key::Key , X , X) -> X) -> (Map(X ) , Map(X )) -> Map(X );
    intersect_with : ((Y , X) -> Y) -> (Map(Y ) , Map(X )) -> Map(Y );
    keyed_intersect_with : ((key::Key , Y , X) -> Y) -> (Map(Y ) , Map(X )) -> Map(Y );
    merge_with : ((Null_Or(Y ) , Null_Or(X )) -> Null_Or(Y )) -> (Map(Y ) , Map(X )) -> Map(Y );
        keyed_merge_with :
        ((key::Key , Null_Or(Y ) , Null_Or(X )) -> Null_Or(Y )) -> (Map(Y ) , Map(X )) -> Map(Y );
    apply : (X -> Void) -> Map(X ) -> Void;
    keyed_apply : ((key::Key , X) -> Void) -> Map(X ) -> Void;
    fold_forward : ((X , Y) -> Y) -> Y -> Map(X ) -> Y;
    keyed_fold_forward : ((key::Key , X , Y) -> Y) -> Y -> Map(X ) -> Y;
    fold_backward : ((X , Y) -> Y) -> Y -> Map(X ) -> Y;
    keyed_fold_backward : ((key::Key , X , Y) -> Y) -> Y -> Map(X ) -> Y;
    filter : (X -> Bool) -> Map(X ) -> Map(X );
    keyed_filter : ((key::Key , X) -> Bool) -> Map(X ) -> Map(X );
    all_invariants_hold : Map(X ) -> Bool;
    debug_print : (Map(X ) , (key::Key -> Void) , (X -> Void)) -> Int;};
\end{verbatim}\index[fun]{debug\_print}
\index[fun]{all\_invariants\_hold}
\index[fun]{keyed\_filter}
\index[fun]{filter}
\index[fun]{keyed\_fold\_backward}
\index[fun]{fold\_backward}
\index[fun]{keyed\_fold\_forward}
\index[fun]{fold\_forward}
\index[fun]{keyed\_apply}
\index[fun]{apply}
\index[fun]{keyed\_merge\_with}
\index[fun]{merge\_with}
\index[fun]{keyed\_intersect\_with}
\index[fun]{intersect\_with}
\index[fun]{keyed\_union\_with}
\index[fun]{union\_with}
\index[fun]{compare\_sequences}
\index[fun]{keys\_list}
\index[fun]{keyvals\_list}
\index[fun]{vals\_list}
\index[fun]{vals\_count}
\index[fun]{last\_keyval\_else\_null}
\index[fun]{last\_val\_else\_null}
\index[fun]{first\_keyval\_else\_null}
\index[fun]{first\_val\_else\_null}
\index[fun]{drop}
\index[fun]{get\_and\_drop}
\index[fun]{contains\_key}
\index[fun]{get\_or\_raise\_exception\_not\_found}
\index[fun]{get}
\index[fun]{\$}
\index[fun]{set\_\_prime\_\_}
\index[fun]{set}
\index[fun]{singleton}
\index[fun]{is\_empty}
\index[fun]{empty}
\index[fun]{compare}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
