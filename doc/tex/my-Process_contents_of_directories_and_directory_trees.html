<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Process contents of directories and directory trees</TITLE>
</HEAD>
<BODY >
<A HREF="my-Get_current_directory.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Recipes.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Run_a_long-lived_Linux_subprocess.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc171">5.5.56</A>  Process contents of directories and directory trees</H3><P>Alphabetically list all vanilla names 
(names not starting with a dot) in 
current directory:
</P><PRE CLASS="verbatim">    eval:  foreach (dir::entry_names ".") {. printf "%s\n" #filename; };
    bar
    foo
    zot
</PRE><P>Alphabetically list all names in current directory, except for &#X201C;.&#X201D; and &#X201C;..&#X201D;:
</P><PRE CLASS="verbatim">    eval:  foreach (dir::entry_names' ".") {. printf "%s\n" #filename; };
    .bashrc
    .emacs
    bar
    foo
    src
    zot
</PRE><P>Alphabetically list all filenames in current directory, including &#X201C;.&#X201D; and &#X201C;..&#X201D;:
</P><PRE CLASS="verbatim">    eval:  foreach (dir::entry_names'' ".") {. printf "%s\n" #filename; };
    .
    ..
    .bashrc
    .emacs
    bar
    foo
    src
    zot
</PRE><P>Alphabetically list names of all vanilla files in current directory, 
ignoring directories, pipes etc:
</P><PRE CLASS="verbatim">    eval:  foreach (dir::file_names ".") {. printf "%s\n" #filename; };
    .bashrc
    .emacs
    bar
    foo
    zot
</PRE><P>Count number of entries in current directory:
</P><PRE CLASS="verbatim">    eval:  length (dir::entry_names'' ".");
    7
</PRE><P>Alphabetically list paths of all vanilla names in current directory:
</P><PRE CLASS="verbatim">    eval:  foreach (dir::entries ".") {. printf "%s\n" #filename; };
    /home/jcb/bar
    /home/jcb/foo
    /home/jcb/src
    /home/jcb/zot
</PRE><P>Alphabetically list paths of all names in current directory except for &#X201C;.&#X201D; and &#X201C;..&#X201D;:
</P><PRE CLASS="verbatim">    eval:  foreach (dir::entries' ".") {. printf "%s\n" #filename; };
    /home/jcb/.bashrc
    /home/jcb/.emacs
    /home/jcb/bar
    /home/jcb/foo
    /home/jcb/src
    /home/jcb/zot
</PRE><P>Alphabetically list paths of all names in current directory, including &#X201C;.&#X201D; and &#X201C;..&#X201D;:
</P><PRE CLASS="verbatim">    eval:  foreach (dir::entries'' ".") {. printf "%s\n" #filename; };
    /home/jcb/.
    /home/jcb/..
    /home/jcb/.bashrc
    /home/jcb/.emacs
    /home/jcb/bar
    /home/jcb/foo
    /home/jcb/src
    /home/jcb/zot
</PRE><P>Alphabetically list paths of all vanilla files in current directory, 
ignoring directories, pipes etc:
</P><PRE CLASS="verbatim">    eval:  foreach (dir::files ".") {. printf "%s\n" #filename; };
    /home/jcb/.bashrc
    /home/jcb/.emacs
    /home/jcb/bar
    /home/jcb/foo
    /home/jcb/zot
</PRE><P>Print the sizes and names of all vanilla files in current directory:
</P><PRE CLASS="verbatim">    eval:  foreach (dir::file_names ".") {. printf "%8d %s\n" (stat #filename).size #filename; };
         328 .bashrc
      240553 .emacs
       29559 bar
       24963 foo
      124518 zot
</PRE><P>Build a list of (filename, filesize) pairs for current directory:
</P><PRE CLASS="verbatim">    eval:  pair_list = map {. (#name, (stat #name).size); } (dir::file_names ".");
    [(".bashrc", 328), 
     ("bar", 29559), ("foot", 24963), 
     ("zot", 126542)]
</PRE><P>Build a list of (filename, filesize) pairs for current directory II:
</P><PRE CLASS="verbatim">    eval:  [ (filename, (stat filename).size) for filename in dir::file_names "." ];
    [(".bashrc", 328), 
     ("bar", 29559), ("foot", 24963), 
     ("zot", 126542)]
</PRE><P>Sort the above list by size:
</P><PRE CLASS="verbatim">    eval:  sorted_list = sort {. #2 #a &lt; #2 #b; } pair_list;
    [(".emacs", 240547), ("zot", 126542),
     ("bar", 29559), (".bashrc", 328)]
</PRE><P>Print above size-sorted list:
</P><PRE CLASS="verbatim">    eval:  apply  {. printf "%8d %s\n" (#2 #a) (#1 #a); }  sorted_list;
      240547 .emacs
      126542 zot
       29559 bar
         328 .bashrc
</PRE><P>Print names of the immediate subdirectories of the current directory:
</P><PRE CLASS="verbatim">    eval:  foreach (dir::entry_names ".") {. if (-D #name) printf "%s\n" #name; fi; };
    src
</PRE><P>Print names of all files matching a given regular expression:
</P><PRE CLASS="verbatim">    eval:  foreach (dir::file_names ".") {. if (#name =~ ./o/) printf "%s\n" #name; fi; };
    foo
    zot
</PRE><P>Build a map from file names to file sizes, then print it out:
</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    include package   string_map;

    # Build a string-map (balanced binary tree)
    # where the keys are the file names and the
    # values are the file sizes:
    #
    name_to_size
        =
        for (result = empty,  input = dir::file_names ".";
             length input &gt; 0; input = tail input;
             result
            )
            {  name    = head input;
               result $= (name, (stat name).size);
            };

    # Iterate over all keys in the map, fetching
    # corresponding sizes and printing the two out:
    #
    foreach (keys_list name_to_size) {.
        size = the (get (name_to_size, #name));
        printf "%8d %s\n" size #name;
    };

    exit 0;
</PRE><P>List all plain files in or below current directory:
</P><PRE CLASS="verbatim">    eval:  foreach (dir_tree::files ".") {. printf "%s\n" #file; };
    /home/jcb/.bashrc
    /home/jcb/.emacs
    /home/jcb/bar
    /home/jcb/foo
    /home/jcb/src/test.c
    /home/jcb/zot
</PRE><P>List sizes of all plain files in or below current directory:
</P><PRE CLASS="verbatim">    eval:  foreach (dir_tree::files ".") {. printf "%8d %s\n" (stat #file).size #file; };
         328 /home/jcb/.bashrc
      240553 /home/jcb/.emacs
       29559 /home/jcb/bar
       24963 /home/jcb/foo
        1978 /home/jcb/src/test.c
      124518 /home/jcb/zot
</PRE><P>Count number of plain files in or below current directory:
</P><PRE CLASS="verbatim">    eval:  length (dir_tree::files ".");
    6
</PRE><P>Print all .c files in or below current directory:
</P><PRE CLASS="verbatim">    eval:  foreach (dir_tree::files ".") {. if (#file =~ ./\\.c$/) printf "%s\n" #file; fi; };
    /home/jcb/src/test.c
</PRE><P>Print all .c files in or below current directory, another way:
</P><PRE CLASS="verbatim">    eval:  foreach (filter {. #file =~ ./\\.c$/; } (dir_tree::files ".")) {. printf "%s\n" #file; };
    /home/jcb/src/test.c
</PRE><P>Count number of .c files in or below current directory:
</P><PRE CLASS="verbatim">    eval:  length (filter {. #file =~ ./\\.c$/; } (dir_tree::files "."));
    1
</PRE><P>Two equivalent ways to count the number of 
directories in or below a directory:
</P><PRE CLASS="verbatim">    eval:  length (filter {. isdir #file; } (dir_tree::entries' "."));
    1
    eval:  length (filter {. -D #file; } (dir_tree::entries' "."));
</PRE><P>To count other things, you can replace <TT>isdir</TT> above by one of 
<TT>ispipe</TT>, 
<TT>issymlink</TT>, 
<TT>issocket</TT>, 
<TT>ischardev</TT> or 
<TT>isblockdev</TT>, or equivalently replace <TT>-D</TT> by one of 
<TT>-P</TT>, 
<TT>-L</TT>, 
<TT>-S</TT>, 
<TT>-C</TT> or 
<TT>-B</TT>.</P><P>To follow symlinks to directories, change <TT>dir_tree</TT> to 
<TT>link_tree</TT> in the above examples. (To avoid symlink 
loops, <TT>link_tree</TT> remembers which directories it has 
already visited, by dev-inode number, and visits each one at 
most once.)</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Get_current_directory.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Recipes.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Run_a_long-lived_Linux_subprocess.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
