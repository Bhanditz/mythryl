!*: Ref(Bool ) -> Bool;
!=: (''a , ''a) -> Bool;
!_: Bool -> Bool;
%:
(X , X) -> X
as  ti::mod: (Int , Int) -> Int;
    i1w::mod: (?.Int1 , ?.Int1) -> ?.Int1;
    i2w::mod: (?.Int2 , ?.Int2) -> ?.Int2;
    mwi::mod:
        (?.core_multiword_int::Multiword_Int , ?.core_multiword_int::Multiword_Int)
        ->
        ?.core_multiword_int::Multiword_Int;
    u1b::mod: (?.word8 , ?.word8) -> ?.word8;
    tu::mod: (?.word , ?.word) -> ?.word;
    u1w::mod: (?.one_word_unt , ?.one_word_unt) -> ?.one_word_unt;
    u2w::mod: (?.word64 , ?.word64) -> ?.word64;;
&:
(X , X) -> X
as  ti::bitwise_and: (Int , Int) -> Int;
    i1w::bitwise_and: (?.Int1 , ?.Int1) -> ?.Int1;
    tu::bitwise_and: (?.word , ?.word) -> ?.word;
    u1w::bitwise_and: (?.one_word_unt , ?.one_word_unt) -> ?.one_word_unt;
    u1b::bitwise_and: (?.word8 , ?.word8) -> ?.word8;;
*:
(X , Y) -> Z
as  ti::*: (Int , Int) -> Int;
    i1w::*: (?.Int1 , ?.Int1) -> ?.Int1;
    i2w::*: (?.Int2 , ?.Int2) -> ?.Int2;
    mwi::*:
        (?.core_multiword_int::Multiword_Int , ?.core_multiword_int::Multiword_Int)
        ->
        ?.core_multiword_int::Multiword_Int;
    tu::*: (?.word , ?.word) -> ?.word;
    u1w::*: (?.one_word_unt , ?.one_word_unt) -> ?.one_word_unt;
    u2w::*: (?.word64 , ?.word64) -> ?.word64;
    f8b::*: (Float , Float) -> Float;
    unt08times: (?.word8 , ?.word8) -> ?.word8;
    mat43_times_mat43:
        (Mat43 , Mat43)
        ->  {m00:Float, m01:Float, m02:Float, m10:Float, m11:Float, m12:Float, m20:Float, m21:Float, m22:Float,
            m30:Float, m31:Float, m32:Float};
    xyz_times_mat43: (Xyz , Mat43) -> {x:Float, y:Float, z:Float};
    xyz_times_xyz: (Xyz , Xyz) -> Float;
    float_times_xyz: (Float , Xyz) -> {x:Float, y:Float, z:Float};
    int_times_float: (Int , Float) -> Float;
    float_times_int: (Float , Int) -> Float;
    int1_times_int: (?.Int1 , Int) -> ?.Int1;
    int_times_int1: (Int , ?.Int1) -> ?.Int1;
    cpx_times_cpx: (Complex , Complex) -> Complex;
    qtn_times_qtn: (Quaternion , Quaternion) -> Quaternion;;
**: (Float , Float) -> Float;
*_: Ref(X ) -> X;
+:
(X , X) -> X
as  ti::+: (Int , Int) -> Int;
    i1w::+: (?.Int1 , ?.Int1) -> ?.Int1;
    i2w::+: (?.Int2 , ?.Int2) -> ?.Int2;
    mwi::+:
        (?.core_multiword_int::Multiword_Int , ?.core_multiword_int::Multiword_Int)
        ->
        ?.core_multiword_int::Multiword_Int;
    tu::+: (?.word , ?.word) -> ?.word;
    strcat: (String , String) -> String;
    u1w::+: (?.one_word_unt , ?.one_word_unt) -> ?.one_word_unt;
    u2w::+: (?.word64 , ?.word64) -> ?.word64;
    f8b::+: (Float , Float) -> Float;
    unt08plus: (?.word8 , ?.word8) -> ?.word8;
    rowcol_plus_rowcol: (Rowcol , Rowcol) -> {col:Int, row:Int};
    xyz_plus_xyz: (Xyz , Xyz) -> {x:Float, y:Float, z:Float};
    cpx_plus_cpx: (Complex , Complex) -> {i:Float, r:Float};
    qtn_plus_qtn: (Quaternion , Quaternion) -> {i:Float, j:Float, k:Float, r:Float};;
-:
(X , X) -> X
as  ti::-: (Int , Int) -> Int;
    i1w::-: (?.Int1 , ?.Int1) -> ?.Int1;
    i2w::-: (?.Int2 , ?.Int2) -> ?.Int2;
    mwi::-:
        (?.core_multiword_int::Multiword_Int , ?.core_multiword_int::Multiword_Int)
        ->
        ?.core_multiword_int::Multiword_Int;
    tu::-: (?.word , ?.word) -> ?.word;
    u1w::-: (?.one_word_unt , ?.one_word_unt) -> ?.one_word_unt;
    u2w::-: (?.word64 , ?.word64) -> ?.word64;
    f8b::-: (Float , Float) -> Float;
    unt08minus: (?.word8 , ?.word8) -> ?.word8;
    rowcol_sub_rowcol: (Rowcol , Rowcol) -> {col:Int, row:Int};
    xyz_sub_xyz: (Xyz , Xyz) -> {x:Float, y:Float, z:Float};
    cpx_sub_cpx: (Complex , Complex) -> {i:Float, r:Float};
    qtn_sub_qtn: (Quaternion , Quaternion) -> {i:Float, j:Float, k:Float, r:Float};;
-_:
X -> X
as  ti::neg: Int -> Int;
    i1w::neg: ?.Int1 -> ?.Int1;
    i2w::neg: ?.Int2 -> ?.Int2;
    mwi::neg: ?.core_multiword_int::Multiword_Int -> ?.core_multiword_int::Multiword_Int;
    tu::neg: ?.word -> ?.word;
    u1w::neg: ?.one_word_unt -> ?.one_word_unt;
    u2w::neg: ?.word64 -> ?.word64;
    f8b::neg: Float -> Float;
    unt08neg: ?.word8 -> ?.word8;;
..: (Int , Int) -> List(Int );
/:
(X , X) -> X
as  ti::div: (Int , Int) -> Int;
    i1w::div: (?.Int1 , ?.Int1) -> ?.Int1;
    i2w::div: (?.Int2 , ?.Int2) -> ?.Int2;
    mwi::div:
        (?.core_multiword_int::Multiword_Int , ?.core_multiword_int::Multiword_Int)
        ->
        ?.core_multiword_int::Multiword_Int;
    u1b::div: (?.word8 , ?.word8) -> ?.word8;
    tu::div: (?.word , ?.word) -> ?.word;
    u1w::div: (?.one_word_unt , ?.one_word_unt) -> ?.one_word_unt;
    u2w::div: (?.word64 , ?.word64) -> ?.word64;
    f8b::/: (Float , Float) -> Float;;
:=: (Ref(X ) , X) -> Void;
<:
(X , X) -> Bool
as  ti::<: (Int , Int) -> Bool;
    i1w::<: (?.Int1 , ?.Int1) -> Bool;
    i2w::<: (?.Int2 , ?.Int2) -> Bool;
    mwi::<: (?.core_multiword_int::Multiword_Int , ?.core_multiword_int::Multiword_Int) -> Bool;
    u1b::<: (?.word8 , ?.word8) -> Bool;
    tu::<: (?.word , ?.word) -> Bool;
    u1w::<: (?.one_word_unt , ?.one_word_unt) -> Bool;
    u2w::<: (?.word64 , ?.word64) -> Bool;
    f8b::<: (Float , Float) -> Bool;
    it::char::<: (Char , Char) -> Bool;
    stringlt: (String , String) -> Bool;;
<<:
(Y , X) -> Y
as  ti::lshift: (Int , Int) -> Int;
    i1w::lshift: (?.Int1 , ?.Int1) -> ?.Int1;
    tu::lshift: (?.word , ?.word) -> ?.word;
    u1w::lshift: (?.one_word_unt , ?.word) -> ?.one_word_unt;
    unt08lshift: (?.word8 , ?.word) -> ?.word8;;
<=:
(X , X) -> Bool
as  ti::<=: (Int , Int) -> Bool;
    i1w::<=: (?.Int1 , ?.Int1) -> Bool;
    i2w::<=: (?.Int2 , ?.Int2) -> Bool;
    mwi::<=: (?.core_multiword_int::Multiword_Int , ?.core_multiword_int::Multiword_Int) -> Bool;
    u1b::<=: (?.word8 , ?.word8) -> Bool;
    tu::<=: (?.word , ?.word) -> Bool;
    u1w::<=: (?.one_word_unt , ?.one_word_unt) -> Bool;
    u2w::<=: (?.word64 , ?.word64) -> Bool;
    f8b::<=: (Float , Float) -> Bool;
    it::char::<=: (Char , Char) -> Bool;
    stringle: (String , String) -> Bool;;
==: (''a , ''a) -> Bool;
==>: (Mailop(X ) , (X -> Y)) -> Mailop(Y );
=~: (String , String) -> Bool;
>:
(X , X) -> Bool
as  ti::>: (Int , Int) -> Bool;
    i1w::>: (?.Int1 , ?.Int1) -> Bool;
    i2w::>: (?.Int2 , ?.Int2) -> Bool;
    mwi::>: (?.core_multiword_int::Multiword_Int , ?.core_multiword_int::Multiword_Int) -> Bool;
    u1b::>: (?.word8 , ?.word8) -> Bool;
    tu::>: (?.word , ?.word) -> Bool;
    u1w::>: (?.one_word_unt , ?.one_word_unt) -> Bool;
    u2w::>: (?.word64 , ?.word64) -> Bool;
    f8b::>: (Float , Float) -> Bool;
    it::char::>: (Char , Char) -> Bool;
    stringgt: (String , String) -> Bool;;
><: (X , X) -> X as xyz_x_xyz: (Xyz , Xyz) -> {x:Float, y:Float, z:Float};;
>=:
(X , X) -> Bool
as  ti::>=: (Int , Int) -> Bool;
    i1w::>=: (?.Int1 , ?.Int1) -> Bool;
    i2w::>=: (?.Int2 , ?.Int2) -> Bool;
    mwi::>=: (?.core_multiword_int::Multiword_Int , ?.core_multiword_int::Multiword_Int) -> Bool;
    u1b::>=: (?.word8 , ?.word8) -> Bool;
    tu::>=: (?.word , ?.word) -> Bool;
    u1w::>=: (?.one_word_unt , ?.one_word_unt) -> Bool;
    u2w::>=: (?.word64 , ?.word64) -> Bool;
    f8b::>=: (Float , Float) -> Bool;
    it::char::>=: (Char , Char) -> Bool;
    stringge: (String , String) -> Bool;;
>>:
(Y , X) -> Y
as  ti::rshift: (Int , Int) -> Int;
    i1w::rshift: (?.Int1 , ?.Int1) -> ?.Int1;
    tu::rshift: (?.word , ?.word) -> ?.word;
    u1w::rshift: (?.one_word_unt , ?.word) -> ?.one_word_unt;
    unt08rshift: (?.word8 , ?.word) -> ?.word8;;
>>>:
(Y , X) -> Y
as  tu::rshiftl: (?.word , ?.word) -> ?.word;
    u1w::rshiftl: (?.one_word_unt , ?.word) -> ?.one_word_unt;
    unt08rshiftl: (?.word8 , ?.word) -> ?.word8;;
@: (List(X ) , List(X )) -> List(X );
^:
(X , X) -> X
as  ti::bitwise_xor: (Int , Int) -> Int;
    i1w::bitwise_xor: (?.Int1 , ?.Int1) -> ?.Int1;
    tu::bitwise_xor: (?.word , ?.word) -> ?.word;
    u1w::bitwise_xor: (?.one_word_unt , ?.one_word_unt) -> ?.one_word_unt;
    unt08bitwise_xor: (?.word8 , ?.word8) -> ?.word8;;
_!: multiword_int::Int -> multiword_int::Int;
_[]:
(X , Y) -> Z
as  it::rw_vector_of_chars::get: (rw_vector_of_chars::Rw_Vector , Int) -> Char;
    it::vector_of_one_byte_unts::get: (vector_of_one_byte_unts::Vector , Int) -> ?.word8;
    it::rw_vector_of_one_byte_unts::get: (rw_vector_of_one_byte_unts::Rw_Vector , Int) -> ?.word8;
    it::rw_vector_of_eight_byte_floats::get: (runtime::asm::Float64_Rw_Vector , Int) -> Float;
    it::poly_rw_vector::get: (Rw_Vector(X ) , Int) -> X;
    it::poly_vector::get: (?.Vector(X ) , Int) -> X;
    it::vector_of_chars::get_byte_as_char: (String , Int) -> Char;
    it::poly_rw_matrix::get: (?.inline_t::poly_rw_matrix::Rw_Matrix(X ) , ((Int , Int))) -> X;
    it::rw_matrix_of_eight_byte_floats::get:
    (rw_matrix_of_eight_byte_floats::Rw_Matrix , ((Int , Int))) -> Float;
    it::rw_matrix_of_one_byte_unts::get:
    (rw_matrix_of_one_byte_unts::Rw_Matrix , ((Int , Int))) -> ?.word8;;
_[]:=:
(X , Y , Z) -> A
as  it::rw_vector_of_one_byte_unts::set:
    (rw_vector_of_one_byte_unts::Rw_Vector , Int , ?.word8) -> Void;
    it::rw_vector_of_eight_byte_floats::set: (runtime::asm::Float64_Rw_Vector , Int , Float) -> Void;
    it::poly_rw_vector::set: (Rw_Vector(X ) , Int , X) -> Void;
    it::rw_vector_of_chars::set: (rw_vector_of_chars::Rw_Vector , Int , Char) -> Void;
    it::poly_rw_matrix::set: (?.inline_t::poly_rw_matrix::Rw_Matrix(X ) , ((Int , Int)) , X) -> Void;
    it::rw_matrix_of_eight_byte_floats::set:
    (rw_matrix_of_eight_byte_floats::Rw_Matrix , ((Int , Int)) , Float) -> Void;
    it::rw_matrix_of_one_byte_unts::set:
    (rw_matrix_of_one_byte_unts::Rw_Matrix , ((Int , Int)) , ?.word8) -> Void;;
_[]:=: (Rw_Vector(X ) , Int , X) -> Void;
abs:
X -> X
as  ti::abs: Int -> Int;
    i1w::abs: ?.Int1 -> ?.Int1;
    i2w::abs: ?.Int2 -> ?.Int2;
    mwi::abs: ?.core_multiword_int::Multiword_Int -> ?.core_multiword_int::Multiword_Int;
    f8b::abs: Float -> Float;;
acos: Float -> Float;
all_logging: Logtree_Node;
always': X -> Mailop(X );
am_logging: Logtree_Node -> Bool;
ancestors_of_logtree_node: Logtree_Node -> List(String );
apply: (X -> Void) -> List(X ) -> Void;
apply': List(X ) -> (X -> Void) -> Void;
arg0: Void -> String;
argv: Void -> List(String );
as_lines: String -> List(String );
asin: Float -> Float;
atan: Float -> Float;
atan2: (Float , Float) -> Float;
atod: String -> Float;
atoi: String -> Int;
backticks__op: X -> Y;
backticks__op: String -> List(String );
basename: String -> String;
bin_sh: String -> String;
bin_sh': String -> Int;
block_until_mailop_fires: Mailop(X ) -> X;
build_executable_heap_image:
    ?.freeze_policy::Freeze_Policy
    ->
    {heap_filename:String, libfile_to_run:String, setup:Null_Or(String ), wrapper_libfile:String}
    ->
    Null_Or(List(String ) );
cat: List(String ) -> String;
cat_mailops: List(Mailop(X ) ) -> Mailop(X );
ceil: Float -> Int;
chdir: String -> Void;
chomp: String -> String;
clone_readqueue: Readqueue(X ) -> Readqueue(X );
close_input: Input_Stream -> Void;
close_output: Output_Stream -> Void;
compare_task: (Apptask , Apptask) -> Order;
compare_thread: (Microthread , Microthread) -> Order;
compile: String -> Bool;
compile_raw_declaration_to_package_closure:
        {compiler_state_stack:(compiler_state::Compiler_State , List(compiler_state::Compiler_State )),
        declaration:raw_syntax::Declaration, options:List(compiler_state::Compile_And_Eval_String_Option ),
        pp:?.standard_prettyprinter::pp::Prettyprinter, sourcecode_info:sourcecode_info::Sourcecode_Info}
    ->Null_Or(
        {code_and_data_segments:code_segment::Code_And_Data_Segments,
        compiler_state_stack:(compiler_state::Compiler_State , List(compiler_state::Compiler_State )),
        compiler_verbosity:per_compile_stuff::Compiler_Verbosity,
        deep_syntax_declaration:deep_syntax::Declaration,
        export_picklehash:Null_Or(picklehash::Picklehash ),
        exported_highcode_variables:List(highcode_codetemp::Codetemp ),
        get_current_compiler_mapstack_set:Void -> compiler_state::Compiler_Mapstack_Set,
        import_trees:List(import_tree::Import_Tree ), inline_expression:Null_Or(anormcode_form::Function ),
        linking_mapstack:linking_mapstack::Picklehash_To_Heapchunk_Mapstack,
        new_symbolmapstack:symbolmapstack::Symbolmapstack, package_closure:code_segment::Package_Closure,
        top_level_pkg_etc_defs_jar:compiler_state::Compiler_Mapstack_Set_Jar}
       );
compiler_logging: Logtree_Node;
cos: Float -> Float;
cosh: Float -> Float;
current_thread_info__hook: Ref(Null_Or((Void -> (Int , String , Int)) ) );
default_microthread: Microthread;
deref: Ref(X ) -> X;
die: String -> Void;
die_x: String -> X;
dirname: String -> String;
disable: Logtree_Node -> Void;
do_one_mailop: List(Mailop(X ) ) -> X;
do_one_mailop': Replyqueue -> List(Mailop(Void ) ) -> Void;
do_while: (Void -> Bool) -> Void;
do_while_not: (Void -> Bool) -> Void;
dotbackticks__op: X -> X;
dotbarets__op: X -> X;
dotbrokets__op: X -> X;
dothashets__op: X -> X;
dotqquotes__op: X -> Y;
dotqquotes__op: String -> List(String );
dotquotes__op: X -> X;
dotslashets__op: X -> X;
drop_mailqueue_tap: (Mailqueue(X ) , Ref(Void )) -> Void;
dynamic_mailop: (Void -> Mailop(X )) -> Mailop(X );
dynamic_mailop_with_nack: (Mailop(Void ) -> Mailop(X )) -> Mailop(X );
e: Float;
enable: Logtree_Node -> Void;
enable_node: Logtree_Node -> Void;
end_of_stream: Input_Stream -> Bool;
environ: Void -> List(String );
eval: String -> Void;
eval_kludge_ref_float: Ref(Float );
eval_kludge_ref_int: Ref(Int );
eval_kludge_ref_list_float: Ref(List(Float ) );
eval_kludge_ref_list_int: Ref(List(Int ) );
eval_kludge_ref_list_string: Ref(List(String ) );
eval_kludge_ref_string: Ref(String );
evalf: String -> Float;
evali: String -> Int;
evallf: String -> List(Float );
evalli: String -> List(Int );
evalls: String -> List(String );
evals: String -> String;
exception_message: Exception -> String;
exception_name: Exception -> String;
exists: String -> Bool;
exit: Int -> Void;
exit_x: Int -> X;
exp: Float -> Float;
explode: String -> List(Char );
explode: String -> List(Char );
factors: Int -> List(Int );
fatal: String -> X;
fields: (Char -> Bool) -> String -> List(String );
filter: (X -> Bool) -> List(X ) -> List(X );
find_logtree_node_by_name: String -> Logtree_Node;
float: Int -> Float;
floor: Float -> Int;
flush: Output_Stream -> Void;
fold_backward: ((X , Y) -> Y) -> Y -> List(X ) -> Y;
fold_forward: ((X , Y) -> Y) -> Y -> List(X ) -> Y;
foreach: List(X ) -> (X -> Y) -> Void;
forget_all_mailslots_mailqueues_and_imps: Void -> Void;
forget_imp: String -> Void;
forget_mailqueue: String -> Void;
forget_mailslot: String -> Void;
forget_startup_or_shutdown_action: String -> Null_Or(((List(When ) , (When -> Void))) );
freeze: String -> Bool;
freeze': {recursively:Bool} -> String -> Bool;
from_int: Int -> Char;
from_lines: String -> List(String ) -> Void;
fscanf: Input_Stream -> String -> Null_Or(List(printf_field::Printf_Arg ) );
get_current_microthread: Void -> Microthread;
get_current_microthread's_id: Void -> Int;
get_current_microthread's_name: Void -> String;
get_exception_that_killed_task: Apptask -> Null_Or(Exception );
get_exception_that_killed_thread: Microthread -> Null_Or(Exception );
get_from_maildrop: Maildrop(X ) -> X;
get_from_maildrop': Maildrop(X ) -> Mailop(X );
get_from_oneshot: Oneshot_Maildrop(X ) -> X;
get_from_oneshot': Oneshot_Maildrop(X ) -> Mailop(X );
get_instream: Input_Stream -> ?.winix_text_file_for_posix__premicrothread::Input_Stream;
get_mailqueue_id: Mailqueue(X ) -> Int;
get_mailqueue_length: Mailqueue(X ) -> Int;
get_mailqueue_putcount: Mailqueue(X ) -> Int;
get_mailqueue_reader: Mailqueue(X ) -> Microthread;
get_makelib_preprocessor_symbol_value: String -> Controller(Null_Or(Int ) );
get_or_make_current_cleanup_task: Void -> Apptask;
get_output_position: Output_Stream -> ?.winix_text_file_for_posix__premicrothread::Out_Position;
get_outstream: Output_Stream -> ?.winix_text_file_for_posix__premicrothread::Output_Stream;
get_task's_alive_threads_count: Apptask -> Int;
get_task's_id: Apptask -> Int;
get_task's_name: Apptask -> String;
get_task's_state: Apptask -> state::State;
get_thread's_id: Microthread -> Int;
get_thread's_id_as_string: Microthread -> String;
get_thread's_name: Microthread -> String;
get_thread's_state: Microthread -> state::State;
get_thread's_task: Microthread -> Apptask;
getcwd: Void -> String;
getegid: Void -> Int;
getenv: String -> Null_Or(String );
geteuid: Void -> Int;
getgid: Void -> Int;
getgroups: Void -> List(Int );
getlogin: Void -> String;
getpgrp: Void -> Int;
getpid: Void -> Int;
getppid: Void -> Int;
getuid: Void -> Int;
hash_thread: Microthread -> Unt;
head: List(X ) -> X;
help: Void -> Void;
id_to_int: Id -> Int;
id_zero: Id;
identity: X -> X;
if_then': (Mailop(X ) , (X -> Y)) -> Mailop(Y );
ignore: X -> Void;
implode: List(Char ) -> String;
implode: List(Char ) -> String;
in: (''a , List(''a )) -> Bool;
isblockdev: String -> Bool;
ischardev: String -> Bool;
isdir: String -> Bool;
iseven: Int -> Bool;
isfile: String -> Bool;
isodd: Int -> Bool;
ispipe: String -> Bool;
isprime: Int -> Bool;
issocket: String -> Bool;
issue_unique_id: Void -> Id;
issymlink: String -> Bool;
it: Void;
it: Void;
join: String -> List(String ) -> String;
join': String -> String -> String -> List(String ) -> String;
kill_task: {success:Bool, task:Apptask} -> Void;
kill_thread: {success:Bool, thread:Microthread} -> Void;
length: List(X ) -> Int;
link_and_run_package_closure:
    {pp:?.standard_prettyprinter::pp::Prettyprinter, sourcecode_info:sourcecode_info::Sourcecode_Info}
    ->  {code_and_data_segments:code_segment::Code_And_Data_Segments,
        compiler_state_stack:(compiler_state::Compiler_State , List(compiler_state::Compiler_State )),
        compiler_verbosity:per_compile_stuff::Compiler_Verbosity,
        deep_syntax_declaration:deep_syntax::Declaration,
        export_picklehash:Null_Or(picklehash::Picklehash ),
        exported_highcode_variables:List(highcode_codetemp::Codetemp ),
        get_current_compiler_mapstack_set:Void -> compiler_state::Compiler_Mapstack_Set,
        import_trees:List(import_tree::Import_Tree ), inline_expression:Null_Or(anormcode_form::Function ),
        linking_mapstack:linking_mapstack::Picklehash_To_Heapchunk_Mapstack,
        new_symbolmapstack:symbolmapstack::Symbolmapstack, package_closure:code_segment::Package_Closure,
        top_level_pkg_etc_defs_jar:compiler_state::Compiler_Mapstack_Set_Jar}
    ->
    (compiler_state::Compiler_State , List(compiler_state::Compiler_State ));
ln: Float -> Float;
load: String -> Bool;
load_plugin: String -> Bool;
log10: Float -> Float;
log_if: Logtree_Node -> Int -> (Void -> String) -> Void;
logger_cleanup: Ref((Void -> Void) );
logger_is_set_to: Void -> Log_To;
logprint: String -> Void;
lstat: String -> ?.posix_file::stat::Stat;
maildrop_swap: (Maildrop(X ) , X) -> X;
maildrop_swap': (Maildrop(X ) , X) -> Mailop(X );
maildrop_to_string: (Maildrop(X ) , String) -> String;
mailqueue_to_string: (Mailqueue(X ) , String) -> String;
make: String -> Bool;
make_boolean_per_thread_property: Void -> {get:Void -> Bool, set:Bool -> Void};
make_empty_maildrop: Void -> Maildrop(X );
make_end_gun: Void -> {end_gun':End_Gun, fire_end_gun:Void -> Void};
make_exception_handling_mailop: (Mailop(X ) , (Exception -> X)) -> Mailop(X );
make_full_maildrop: X -> Maildrop(X );
make_instream: ?.winix_text_file_for_posix__premicrothread::Input_Stream -> Input_Stream;
make_logtree_leaf: {default:Bool, name:String, parent:Logtree_Node} -> Logtree_Node;
make_mailcaster: Void -> Mailcaster(X );
make_mailqueue: Microthread -> Mailqueue(X );
make_mailslot: Void -> Mailslot(X );
make_oneshot_maildrop: Void -> Oneshot_Maildrop(X );
make_outstream: ?.winix_text_file_for_posix__premicrothread::Output_Stream -> Output_Stream;
make_per_thread_property:
(Void -> X) -> {clear:Void -> Void, get:Void -> X, peek:Void -> Null_Or(X ), set:X -> Void};
make_readqueue: Mailcaster(X ) -> Readqueue(X );
make_replyqueue: Void -> Replyqueue;
make_run_gun: Void -> {fire_run_gun:Void -> Void, run_gun':Run_Gun};
make_task: String -> List(((String , (Void -> Void))) ) -> Apptask;
make_thread: String -> (Void -> Void) -> Microthread;
make_thread': List(Make_Thread_Args ) -> (X -> Void) -> X -> Microthread;
map: (X -> Y) -> List(X ) -> List(Y );
map': List(X ) -> (X -> Y) -> List(Y );
max:
(X , X) -> X
as  ti::max: (Int , Int) -> Int;
    i1w::max: (?.Int1 , ?.Int1) -> ?.Int1;
    f8b::max: (Float , Float) -> Float;;
mayexecute: String -> Bool;
mayread: String -> Bool;
maywrite: String -> Bool;
min:
(X , X) -> X
as  ti::min: (Int , Int) -> Int;
    i1w::min: (?.Int1 , ?.Int1) -> ?.Int1;
    f8b::min: (Float , Float) -> Float;;
mkdir: String -> Void;
name_of_logtree_node: Logtree_Node -> String;
never': Mailop(X );
nonblocking_get_from_maildrop: Maildrop(X ) -> Null_Or(X );
nonblocking_get_from_oneshot: Oneshot_Maildrop(X ) -> Null_Or(X );
nonblocking_put_in_mailslot: (Mailslot(X ) , X) -> Bool;
nonblocking_take_from_maildrop: Maildrop(X ) -> Null_Or(X );
nonblocking_take_from_mailslot: Mailslot(X ) -> Null_Or(X );
not: Bool -> Bool;
not_null: Null_Or(X ) -> Bool;
note: (Void -> String) -> Void;
note_imp: {at_shutdown:Void -> Void, at_startup:Void -> Void, name:String} -> Void;
note_in_ramlog: (Void -> String) -> Void;
note_mailqueue: (String , Mailqueue(X )) -> Void;
note_mailqueue_tap: (Mailqueue(X ) , (X -> Void)) -> Ref(Void );
note_mailslot: (String , Mailslot(X )) -> Void;
note_startup_or_shutdown_action:
(String , List(When ) , (When -> Void)) -> Null_Or(((List(When ) , (When -> Void))) );
note_task_cleanup_action: (Void -> Void) -> Void;
note_thread_cleanup_action: (Void -> Void) -> Void;
now: Void -> Float;
null: List(X ) -> Bool;
o: ((X -> Y) , (Z -> X)) -> Z -> Y;
open_for_append: String -> Output_Stream;
open_for_read: String -> Input_Stream;
open_for_write: String -> Output_Stream;
open_string: String -> Input_Stream;
parent_of_logtree_node: Logtree_Node -> Null_Or(Logtree_Node );
parse_string_to_raw_declarations:
    {pp:?.standard_prettyprinter::pp::Prettyprinter, sourcecode_info:sourcecode_info::Sourcecode_Info}
    ->
    List(raw_syntax::Declaration );
peek: Input_Stream -> Null_Or(Element );
pi: Float;
pow: (Float , Float) -> Float;
print: String -> Void;
print: String -> Void;
print_logtree: Void -> Void;
product: List(Int ) -> Int;
put_in_maildrop: (Maildrop(X ) , X) -> Void;
put_in_mailqueue: (Mailqueue(X ) , X) -> Void;
put_in_mailslot: (Mailslot(X ) , X) -> Void;
put_in_mailslot': (Mailslot(X ) , X) -> Mailop(Void );
put_in_oneshot: (Oneshot_Maildrop(X ) , X) -> Void;
put_in_replyqueue: (Replyqueue , Mailop(Void )) -> Void;
read: Input_Stream -> Vector;
read_all: Input_Stream -> Vector;
read_line: Input_Stream -> Null_Or(String );
read_lines: Input_Stream -> List(String );
read_n: (Input_Stream , Int) -> Vector;
read_one: Input_Stream -> Null_Or(Element );
receive: Readqueue(X ) -> X;
receive': Readqueue(X ) -> Mailop(X );
redump_heap: String -> Void;
rename: {from:String, to:String} -> Void;
replyqueue_to_string: (Replyqueue , String) -> String;
reverse: List(X ) -> List(X );
rmdir: String -> Void;
round: Float -> Int;
round: Float -> Int;
run: String -> Void;
run_thread__xu: Microthread -> (X -> Void) -> X -> Void;
run_under_thread_scheduler: (Void -> X) -> Void;
same_id: (Id , Id) -> Bool;
same_maildrop: (Maildrop(X ) , Maildrop(X )) -> Bool;
same_mailqueue: (Mailqueue(X ) , Mailqueue(X )) -> Bool;
same_mailslot: (Mailslot(X ) , Mailslot(X )) -> Bool;
same_oneshot_maildrop: (Oneshot_Maildrop(X ) , Oneshot_Maildrop(X )) -> Bool;
same_task: (Apptask , Apptask) -> Bool;
same_thread: (Microthread , Microthread) -> Bool;
say: (Void -> String) -> Void;
scan_stream:
        (
        number_string::Reader((Element, ?.winix_text_file_for_posix__premicrothread::Input_Stream))
        ->
        number_string::Reader((X, ?.winix_text_file_for_posix__premicrothread::Input_Stream))
        )
    ->
    Input_Stream -> Null_Or(X );
scanf: String -> Null_Or(List(printf_field::Printf_Arg ) );
search_lib_load_path_for_file: String -> Null_Or(String );
set_control: String -> String -> Void;
set_instream: (Input_Stream , ?.winix_text_file_for_posix__premicrothread::Input_Stream) -> Void;
set_logger_to: Log_To -> Void;
set_output_position:
(Output_Stream , ?.winix_text_file_for_posix__premicrothread::Out_Position) -> Void;
set_outstream: (Output_Stream , ?.winix_text_file_for_posix__premicrothread::Output_Stream) -> Void;
setgid: Int -> Void;
setpgid: (Int , Int) -> Void;
setsid: Void -> Int;
setuid: Int -> Void;
show_all: Void -> Void;
show_api: String -> Void;
show_apis: Void -> Void;
show_control: String -> Void;
show_controls: Void -> Void;
show_generics: Void -> Void;
show_pkg: String -> Void;
show_pkgs: Void -> Void;
show_types: Void -> Void;
show_vals: Void -> Void;
shuffle: List(X ) -> List(X );
shuffle': random::Random_Number_Generator -> List(X ) -> List(X );
shut_down_thread_scheduler: Int -> X;
sin: Float -> Float;
sinh: Float -> Float;
size: String -> Int;
sleep: Float -> Void;
sleep_for: Float -> Void;
sleep_until: time::Time -> Void;
sort: ((X , X) -> Bool) -> List(X ) -> List(X );
sorted: ((X , X) -> Bool) -> List(X ) -> Bool;
sources:
    Null_Or({architecture:String, os:String} )
    ->
    String -> Null_Or(List({derived:Bool, file:String, ilk:String} ) );
spawn_to_disk: (String , ((String , List(String )) -> Int) , Null_Or(time::Time )) -> Void;
sqrt: Float -> Float;
sscanf: String -> String -> Null_Or(List(printf_field::Printf_Arg ) );
standardlib_logging: Logtree_Node;
start_up_thread_scheduler: (Void -> Void) -> Int;
start_up_thread_scheduler': time::Time -> (Void -> Void) -> Int;
stat: String -> ?.posix_file::stat::Stat;
state_to_string: state::State -> String;
stderr: Output_Stream;
stdin: Input_Stream;
stdout: Output_Stream;
str: Char -> String;
strcat: List(String ) -> String;
strlen: String -> Int;
strsort: List(String ) -> List(String );
struniqsort: List(String ) -> List(String );
substring: (String , Int , Int) -> String;
subtree_nodes_and_log_flags: Logtree_Node -> List(((Logtree_Node , Bool)) );
sum: List(Int ) -> Int;
symlink: {new:String, old:String} -> Void;
tail: List(X ) -> List(X );
take_all_from_mailqueue: Mailqueue(X ) -> List(X );
take_all_from_mailqueue': Mailqueue(X ) -> Mailop(List(X ) );
take_from_maildrop: Maildrop(X ) -> X;
take_from_maildrop': Maildrop(X ) -> Mailop(X );
take_from_mailqueue: Mailqueue(X ) -> X;
take_from_mailqueue': Mailqueue(X ) -> Mailop(X );
take_from_mailslot: Mailslot(X ) -> X;
take_from_mailslot': Mailslot(X ) -> Mailop(X );
tan: Float -> Float;
tanh: Float -> Float;
task_done__mailop: Apptask -> Mailop(Void );
the: Null_Or(X ) -> X;
the_else: (Null_Or(X ) , X) -> X;
then: (X , Void) -> X;
thread_done__mailop: Microthread -> Mailop(Void );
thread_exit: {success:Bool} -> X;
time: Void -> one_word_int::Int;
timeout_at': time::Time -> Mailop(Void );
timeout_in': Float -> Mailop(Void );
to_int: Char -> Int;
tokens: (Char -> Bool) -> String -> List(String );
tolower: String -> String;
toupper: String -> String;
transmit: (Mailcaster(X ) , X) -> Void;
trim: String -> String;
trunc: Float -> Int;
uniquesort: ((X , X) -> Order) -> List(X ) -> List(X );
unlink: String -> Void;
use: String -> Bool;
vector: List(X ) -> ?.Vector(X );
warn: (Void -> String) -> Void;
when_to_string: When -> String;
words: String -> List(String );
write: (Output_Stream , Vector) -> Void;
write_one: (Output_Stream , Element) -> Void;
write_substring: (Output_Stream , Substring) -> Void;
yield: Void -> Void;
|:
(X , X) -> X
as  ti::bitwise_or: (Int , Int) -> Int;
    i1w::bitwise_or: (?.Int1 , ?.Int1) -> ?.Int1;
    tu::bitwise_or: (?.word , ?.word) -> ?.word;
    u1w::bitwise_or: (?.one_word_unt , ?.one_word_unt) -> ?.one_word_unt;
    unt08bitwise_or: (?.word8 , ?.word8) -> ?.word8;;
~_:
X -> X
as  ti::bitwise_not: Int -> Int;
    tu::bitwise_not: ?.word -> ?.word;
    u1w::bitwise_not: ?.one_word_unt -> ?.one_word_unt;
    u1b::bitwise_not: ?.word8 -> ?.word8;;
! : (X , List(X )) -> List(X );
APP_SHUTDOWN : When;
APP_STARTUP : When;
BAD_CHAR : Exception;
BIND : Exception;
COMPILER_STARTUP : When;
DIE : String -> Exception;
DIVIDE_BY_ZERO : Exception;
DOMAIN : Exception;
EMPTY : Exception;
EQUAL : Order;
FAIL : String -> Fail_Or(X );
FALSE : Bool;
GREATER : Order;
IMPOSSIBLE : Exception;
INDEX_OUT_OF_BOUNDS : Exception;
LESS : Order;
    LOGTREE_NODE
    :   {children:Ref(List(Logtree_Node ) ), logging:Ref(Bool ), name:String, parent:Null_Or(Logtree_Node )}
        ->
        Logtree_Node
;
LOG_TO_FILE : String -> Log_To;
LOG_TO_NULL : Log_To;
LOG_TO_STDERR : Log_To;
LOG_TO_STDOUT : Log_To;
LOG_TO_STREAM : Output_Stream -> Log_To;
MATCH : Exception;
MAY_NOT_FILL_ALREADY_FULL_MAILDROP : Exception;
MAY_NOT_FILL_ALREADY_FULL_ONESHOT_MAILDROP : Exception;
NIL : List(X );
NOT_FOUND : Exception;
NO_SUCH_ACTION : Exception;
NO_SUCH_LOGTREE_NODE : Exception;
NULL : Null_Or(X );
NULL_OR : Exception;
OVERFLOW : Exception;
REF : X -> Ref(X );
SIZE : Exception;
SPAN : Exception;
THE : X -> Null_Or(X );
THREADKIT_SHUTDOWN : When;
THREAD_NAME : String -> Make_Thread_Args;
THREAD_SCHEDULER_NOT_RUNNING : Exception;
THREAD_TASK : Apptask -> Make_Thread_Args;
TRUE : Bool;
WORK : X -> Fail_Or(X );
Apptask;
Array;
Bool;
Char;
Complex;
Controller;
Crypt;
Element;
End_Gun;
Exception;
Fail_Or;
Float;
Float;
Id;
Input_Stream;
Int;
List;
Log_To;
Logtree_Node;
Mailcaster;
Maildrop;
Mailop;
Mailqueue;
Mailslot;
Make_Thread_Args;
Mat43;
Microthread;
Null_Or;
Oneshot_Maildrop;
Order;
Output_Stream;
Quaternion;
Readqueue;
Ref;
Replyqueue;
Rowcol;
Run_Gun;
Rw_Vector;
String;
Substring;
Unt;
?.Vector;
Vector;
Void;
When;
Xyz;
generic binary_map_g
:
a_generic_api:
(k:
api {
    Key;
    compare : (Key , Key) -> Order;};
)
:
api {   package key
          : api {
                Key;
                compare : (Key , Key) -> Order;};;
    Map X;
    empty : Map(X );
    is_empty : Map(X ) -> Bool;
    singleton : (key::Key , X) -> Map(X );
    from_list : List(((key::Key , X)) ) -> Map(X );
    set : (Map(X ) , key::Key , X) -> Map(X );
    set' : (((key::Key , X)) , Map(X )) -> Map(X );
    $ : (Map(X ) , ((key::Key , X))) -> Map(X );
    get : (Map(X ) , key::Key) -> Null_Or(X );
    get_or_raise_exception_not_found : (Map(X ) , key::Key) -> X;
    contains_key : (Map(X ) , key::Key) -> Bool;
    preceding_key : (Map(X ) , key::Key) -> Null_Or(key::Key );
    following_key : (Map(X ) , key::Key) -> Null_Or(key::Key );
    get_and_drop : (Map(X ) , key::Key) -> (Map(X ) , Null_Or(X ));
    drop : (Map(X ) , key::Key) -> Map(X );
    first_val_else_null : Map(X ) -> Null_Or(X );
    first_keyval_else_null : Map(X ) -> Null_Or(((key::Key , X)) );
    last_val_else_null : Map(X ) -> Null_Or(X );
    last_keyval_else_null : Map(X ) -> Null_Or(((key::Key , X)) );
    vals_count : Map(X ) -> Int;
    vals_list : Map(X ) -> List(X );
    keyvals_list : Map(X ) -> List(((key::Key , X)) );
    keys_list : Map(X ) -> List(key::Key );
    compare_sequences : ((X , X) -> Order) -> (Map(X ) , Map(X )) -> Order;
    difference_with : (Map(X ) , Map(X )) -> Map(X );
    union_with : ((X , X) -> X) -> (Map(X ) , Map(X )) -> Map(X );
    keyed_union_with : ((key::Key , X , X) -> X) -> (Map(X ) , Map(X )) -> Map(X );
    intersect_with : ((X , Y) -> Z) -> (Map(X ) , Map(Y )) -> Map(Z );
    keyed_intersect_with : ((key::Key , X , Y) -> Z) -> (Map(X ) , Map(Y )) -> Map(Z );
    merge_with : ((Null_Or(X ) , Null_Or(Y )) -> Null_Or(Z )) -> (Map(X ) , Map(Y )) -> Map(Z );
        keyed_merge_with :
        ((key::Key , Null_Or(X ) , Null_Or(Y )) -> Null_Or(Z )) -> (Map(X ) , Map(Y )) -> Map(Z );
    apply : (X -> Void) -> Map(X ) -> Void;
    keyed_apply : ((key::Key , X) -> Void) -> Map(X ) -> Void;
    map : (X -> Y) -> Map(X ) -> Map(Y );
    keyed_map : ((key::Key , X) -> Y) -> Map(X ) -> Map(Y );
    fold_forward : ((X , Y) -> Y) -> Y -> Map(X ) -> Y;
    keyed_fold_forward : ((key::Key , X , Y) -> Y) -> Y -> Map(X ) -> Y;
    fold_backward : ((X , Y) -> Y) -> Y -> Map(X ) -> Y;
    keyed_fold_backward : ((key::Key , X , Y) -> Y) -> Y -> Map(X ) -> Y;
    filter : (X -> Bool) -> Map(X ) -> Map(X );
    keyed_filter : ((key::Key , X) -> Bool) -> Map(X ) -> Map(X );
    map' : (X -> Null_Or(Y )) -> Map(X ) -> Map(Y );
    keyed_map' : ((key::Key , X) -> Null_Or(Y )) -> Map(X ) -> Map(Y );
    all_invariants_hold : Map(X ) -> Bool;
    debug_print : (Map(X ) , (key::Key -> Void) , (X -> Void)) -> Int;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(E80.3)
generic_closure:
CL:
parameter: #GLOBAL(E80.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(E80.2)
            syx::COERCED_PACKAGE:
                #GLOBAL(E80.4)
                 src:syx::PACKAGE:
                        ed::S: #GLOBAL(E80.5) syx::VARIABLE_PACKAGE: [#GLOBAL(E80.0)] key
                        ed::T: #GLOBAL(E80.6) te::FM: ?.Map
                tgt:syx::PACKAGE:
                    ed::S: #GLOBAL(577.1)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(E80.4), #GLOBAL(E80.0)]
                     key
                    ed::T: #GLOBAL(577.2)
                     te::V:
                     [#GLOBAL(E80.4), #GLOBAL(E80.6)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic binary_search_g
:
a_generic_api:
(a:
api {
    eqtype Rw_Vector;
    Element;
    Vector;
    maximum_vector_length : Int;
    make_rw_vector : (Int , Element) -> Rw_Vector;
    from_list : List(Element ) -> Rw_Vector;
    from_fn : (Int , (Int -> Element)) -> Rw_Vector;
    length : Rw_Vector -> Int;
    get : (Rw_Vector , Int) -> Element;
    _[] : (Rw_Vector , Int) -> Element;
    set : (Rw_Vector , Int , Element) -> Void;
    _[]:= : (Rw_Vector , Int , Element) -> Void;
    to_vector : Rw_Vector -> Vector;
    copy : {at:Int, from:Rw_Vector, into:Rw_Vector} -> Void;
    copy_vector : {at:Int, from:Vector, into:Rw_Vector} -> Void;
    keyed_apply : ((Int , Element) -> Void) -> Rw_Vector -> Void;
    apply : (Element -> Void) -> Rw_Vector -> Void;
    keyed_map_in_place : ((Int , Element) -> Element) -> Rw_Vector -> Void;
    map_in_place : (Element -> Element) -> Rw_Vector -> Void;
    keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
    keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
    fold_forward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
    fold_backward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
    keyed_find : ((Int , Element) -> Bool) -> Rw_Vector -> Null_Or(((Int , Element)) );
    find : (Element -> Bool) -> Rw_Vector -> Null_Or(Element );
    exists : (Element -> Bool) -> Rw_Vector -> Bool;
    all : (Element -> Bool) -> Rw_Vector -> Bool;
    compare_sequences : ((Element , Element) -> Order) -> (Rw_Vector , Rw_Vector) -> Order;};
)
:
api {   package a
          : api {
                eqtype Rw_Vector;
                Element;
                Vector;
                maximum_vector_length : Int;
                make_rw_vector : (Int , Element) -> Rw_Vector;
                from_list : List(Element ) -> Rw_Vector;
                from_fn : (Int , (Int -> Element)) -> Rw_Vector;
                length : Rw_Vector -> Int;
                get : (Rw_Vector , Int) -> Element;
                _[] : (Rw_Vector , Int) -> Element;
                set : (Rw_Vector , Int , Element) -> Void;
                _[]:= : (Rw_Vector , Int , Element) -> Void;
                to_vector : Rw_Vector -> Vector;
                copy : {at:Int, from:Rw_Vector, into:Rw_Vector} -> Void;
                copy_vector : {at:Int, from:Vector, into:Rw_Vector} -> Void;
                keyed_apply : ((Int , Element) -> Void) -> Rw_Vector -> Void;
                apply : (Element -> Void) -> Rw_Vector -> Void;
                keyed_map_in_place : ((Int , Element) -> Element) -> Rw_Vector -> Void;
                map_in_place : (Element -> Element) -> Rw_Vector -> Void;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
                fold_forward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
                fold_backward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
                keyed_find : ((Int , Element) -> Bool) -> Rw_Vector -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Rw_Vector -> Null_Or(Element );
                exists : (Element -> Bool) -> Rw_Vector -> Bool;
                all : (Element -> Bool) -> Rw_Vector -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Rw_Vector , Rw_Vector) -> Order;};;
    bsearch : ((X , a::Element) -> Order) -> (X , a::Rw_Vector) -> Null_Or(((Int , a::Element)) );};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(1DB.5)
generic_closure:
CL:
parameter: #GLOBAL(1DB.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(1DB.2)
            syx::COERCED_PACKAGE:
                #GLOBAL(1DB.6)
                 src:syx::PACKAGE:
                 ed::S: #GLOBAL(1DB.7) syx::VARIABLE_PACKAGE: [#GLOBAL(1DB.0)] a
                tgt:syx::PACKAGE:
                 ed::S: #GLOBAL(1DB.4) syx::VARIABLE_PACKAGE: [#GLOBAL(1DB.6), #GLOBAL(1DB.0)] a
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic binary_set_g
:
a_generic_api:
(k:
api {
    Key;
    compare : (Key , Key) -> Order;};
)
:
api {   package key
          : api {
                Key;
                compare : (Key , Key) -> Order;};;
    Item  = key::Key;
    Set;
    empty : Set;
    singleton : Item -> Set;
    from_list : List(Item ) -> Set;
    add : (Set , Item) -> Set;
    add' : (Item , Set) -> Set;
    add_list : (Set , List(Item )) -> Set;
    drop : (Set , Item) -> Set;
    member : (Set , Item) -> Bool;
    preceding_member : (Set , Item) -> Null_Or(Item );
    following_member : (Set , Item) -> Null_Or(Item );
    is_empty : Set -> Bool;
    equal : (Set , Set) -> Bool;
    compare : (Set , Set) -> Order;
    is_subset : (Set , Set) -> Bool;
    vals_count : Set -> Int;
    vals_list : Set -> List(Item );
    union : (Set , Set) -> Set;
    intersection : (Set , Set) -> Set;
    difference : (Set , Set) -> Set;
    map : (Item -> Item) -> Set -> Set;
    apply : (Item -> Void) -> Set -> Void;
    fold_forward : ((Item , X) -> X) -> X -> Set -> X;
    fold_backward : ((Item , X) -> X) -> X -> Set -> X;
    partition : (Item -> Bool) -> Set -> (Set , Set);
    filter : (Item -> Bool) -> Set -> Set;
    exists : (Item -> Bool) -> Set -> Bool;
    find : (Item -> Bool) -> Set -> Null_Or(Item );
    all_invariants_hold : Set -> Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(AAE.3)
generic_closure:
CL:
parameter: #GLOBAL(AAE.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(AAE.2)
            syx::COERCED_PACKAGE:
                #GLOBAL(AAE.4)
                 src:syx::PACKAGE:
                        ed::S: #GLOBAL(AAE.5) syx::VARIABLE_PACKAGE: [#GLOBAL(AAE.0)] key
                        ed::T: #GLOBAL(AAE.6) te::FM: ?.Item
                        ed::T: #GLOBAL(AAE.7) te::FM: ?.Set
                tgt:syx::PACKAGE:
                    ed::S: #GLOBAL(691.1)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(AAE.4), #GLOBAL(AAE.0)]
                     key
                    ed::T: #GLOBAL(691.2)
                     te::V:
                     [#GLOBAL(AAE.4), #GLOBAL(AAE.6)]
                    ed::T: #GLOBAL(691.3)
                     te::V:
                     [#GLOBAL(AAE.4), #GLOBAL(AAE.7)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic digraph_strongly_connected_components_g
:
a_generic_api:
(nd:
api {
    Key;
    compare : (Key , Key) -> Order;};
)
:
api {   package nd
          : api {
                Key;
                compare : (Key , Key) -> Order;};;
    Node  = nd::Key;
    Component  = RECURSIVE List(Node ) | SIMPLE Node;
    topological_order' : {follow:Node -> List(Node ), roots:List(Node )} -> List(Component );
    topological_order : {follow:Node -> List(Node ), root:Node} -> List(Component );};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(148.4)
generic_closure:
CL:
parameter: #GLOBAL(148.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(148.2)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(148.5)
                         src:syx::PACKAGE:
                                ed::S: #GLOBAL(148.6) syx::VARIABLE_PACKAGE: [#GLOBAL(148.0)] nd
                                ed::T: #GLOBAL(148.7) te::FM: ?.Node
                                    ed::S: #GLOBAL(148.8)
                                        syx::PACKAGE_LET:
                                            stipulate:  ed::S: #GLOBAL(148.9)
                                                            syx::APPLY:
                                                                fct:fe::CONSTANT_GENERIC:<>
                                                                arg:syx::COERCED_PACKAGE:
                                                                        #GLOBAL(148.10)
                                                                         src:syx::VARIABLE_PACKAGE:
                                                                         [#GLOBAL(148.0)]
                                                                        tgt:syx::VARIABLE_PACKAGE:
                                                                         [#GLOBAL(148.10)]
                                                         <return_package>
                                            herein:syx::VARIABLE_PACKAGE:
                                             [#GLOBAL(148.9), #GLOBAL(ECE.2)]
                                     map
                                ed::T: #GLOBAL(148.11) te::FM: ?.Component
                            ed::S: #GLOBAL(148.12)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(148.9), #GLOBAL(ECE.2)]
                             map
                        tgt:syx::PACKAGE:
                            ed::S: #GLOBAL(1C1.1)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(148.5), #GLOBAL(148.0)]
                             nd
                            ed::T: #GLOBAL(1C1.2)
                             te::V:
                             [#GLOBAL(148.5), #GLOBAL(148.7)]
                            ed::T: #GLOBAL(1C1.3)
                             te::V:
                             [#GLOBAL(148.5), #GLOBAL(148.11)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic expanding_rw_vector_g
:
a_generic_api:
(rwv:
api {
    eqtype Rw_Vector;
    Element;
    Vector;
    maximum_vector_length : Int;
    make_rw_vector : (Int , Element) -> Rw_Vector;
    from_list : List(Element ) -> Rw_Vector;
    from_fn : (Int , (Int -> Element)) -> Rw_Vector;
    length : Rw_Vector -> Int;
    get : (Rw_Vector , Int) -> Element;
    _[] : (Rw_Vector , Int) -> Element;
    set : (Rw_Vector , Int , Element) -> Void;
    _[]:= : (Rw_Vector , Int , Element) -> Void;
    to_vector : Rw_Vector -> Vector;
    copy : {at:Int, from:Rw_Vector, into:Rw_Vector} -> Void;
    copy_vector : {at:Int, from:Vector, into:Rw_Vector} -> Void;
    keyed_apply : ((Int , Element) -> Void) -> Rw_Vector -> Void;
    apply : (Element -> Void) -> Rw_Vector -> Void;
    keyed_map_in_place : ((Int , Element) -> Element) -> Rw_Vector -> Void;
    map_in_place : (Element -> Element) -> Rw_Vector -> Void;
    keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
    keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
    fold_forward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
    fold_backward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
    keyed_find : ((Int , Element) -> Bool) -> Rw_Vector -> Null_Or(((Int , Element)) );
    find : (Element -> Bool) -> Rw_Vector -> Null_Or(Element );
    exists : (Element -> Bool) -> Rw_Vector -> Bool;
    all : (Element -> Bool) -> Rw_Vector -> Bool;
    compare_sequences : ((Element , Element) -> Order) -> (Rw_Vector , Rw_Vector) -> Order;};
)
:
api {
    Element;
    Rw_Vector;
    rw_vector : (Int , Element) -> Rw_Vector;
    copy_rw_subvector : (Rw_Vector , Int , Int) -> Rw_Vector;
    from_list : (List(Element ) , Element) -> Rw_Vector;
    from_fn : (Int , (Int -> Element) , Element) -> Rw_Vector;
    default : Rw_Vector -> Element;
    get : (Rw_Vector , Int) -> Element;
    set : (Rw_Vector , Int , Element) -> Void;
    bound : Rw_Vector -> Int;
    truncate : (Rw_Vector , Int) -> Void;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(668.3)
generic_closure:
CL:
parameter: #GLOBAL(668.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(668.2)
            syx::COERCED_PACKAGE:
                #GLOBAL(668.4)
                 src:syx::PACKAGE:
                        ed::T: #GLOBAL(668.5) te::FM: ?.Element
                        ed::T: #GLOBAL(668.6) te::FM: ?.Rw_Vector
                tgt:syx::PACKAGE:
                    ed::T: #GLOBAL(EC0.1)
                     te::V:
                     [#GLOBAL(668.4), #GLOBAL(668.5)]
                    ed::T: #GLOBAL(EC0.2)
                     te::V:
                     [#GLOBAL(668.4), #GLOBAL(668.6)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic finalize_g
:
a_generic_api:
(chunk:
api {
    Chunk;
    Chunk_Info;
    finalize : Chunk_Info -> Void;};
)
:
api {   package chunk
          : api {
                Chunk;
                Chunk_Info;
                finalize : Chunk_Info -> Void;};;
    register_chunk : (chunk::Chunk , chunk::Chunk_Info) -> Void;
    get_dead : Void -> List(chunk::Chunk_Info );
    finalize : Void -> Void;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(A4F.3)
generic_closure:
CL:
parameter: #GLOBAL(A4F.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(A4F.2)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(A4F.4)
                         src:syx::PACKAGE:
                         ed::S: #GLOBAL(A4F.5) syx::VARIABLE_PACKAGE: [#GLOBAL(A4F.0)] chunk
                        tgt:syx::PACKAGE:
                         ed::S: #GLOBAL(167.1) syx::VARIABLE_PACKAGE: [#GLOBAL(A4F.4), #GLOBAL(A4F.0)] chunk
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic graphtree_g
:
a_generic_api:
(<parameter>:
api {
    Graph_Info;
    Edge_Info;
    Node_Info;};
)
:
api {
    Graph;
    Edge;
    Node;
    Graph_Info;
    Edge_Info;
    Node_Info;
    exception GRAPHTREE_ERROR String;
    make_graph : Graph_Info -> Graph;
    make_subgraph : (Graph , Graph_Info) -> Graph;
    node_count : Graph -> Int;
    edge_count : Graph -> Int;
    make_node : (Graph , Node_Info) -> Node;
    put_node : (Graph , Node) -> Void;
    drop_node : (Graph , Node) -> Void;
    nodes : Graph -> List(Node );
    nodes_apply : (Node -> Void) -> Graph -> Void;
    nodes_fold : ((Node , X) -> X) -> Graph -> X -> X;
    make_edge : {graph:Graph, head:Node, info:Edge_Info, tail:Node} -> Edge;
    drop_edge : (Graph , Edge) -> Void;
    edges : Graph -> List(Edge );
    in_edges : (Graph , Node) -> List(Edge );
    out_edges : (Graph , Node) -> List(Edge );
    in_edges_apply : (Edge -> Void) -> (Graph , Node) -> Void;
    out_edges_apply : (Edge -> Void) -> (Graph , Node) -> Void;
    head : Edge -> Node;
    tail : Edge -> Node;
    nodes_of : Edge -> {head:Node, tail:Node};
    is_root : Graph -> Bool;
    root_of_node : Node -> Graph;
    root_of_edge : Edge -> Graph;
    root_of_graph : Graph -> Graph;
    has_node : (Graph , Node) -> Bool;
    has_edge : (Graph , Edge) -> Bool;
    eq_graph : (Graph , Graph) -> Bool;
    eq_node : (Node , Node) -> Bool;
    eq_edge : (Edge , Edge) -> Bool;
    edge_info_of : Edge -> Edge_Info;
    graph_info_of : Graph -> Graph_Info;
    node_info_of : Node -> Node_Info;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(7F9.10)
generic_closure:
CL:
parameter: #GLOBAL(7F9.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(7F9.9)
            syx::COERCED_PACKAGE:
                #GLOBAL(7F9.11)
                 src:syx::PACKAGE:
                        ed::T: #GLOBAL(7F9.12) te::FM: ?.Graph_Info
                        ed::T: #GLOBAL(7F9.13) te::FM: ?.Edge_Info
                        ed::T: #GLOBAL(7F9.14) te::FM: ?.Node_Info
                        ed::S: #GLOBAL(7F9.15) syx::PACKAGE: ed::T: #GLOBAL(7F9.16) te::FM: ?.Key int_key
                            ed::S: #GLOBAL(7F9.17)
                                syx::PACKAGE_LET:
                                    stipulate:  ed::S: #GLOBAL(7F9.18)
                                                    syx::APPLY:
                                                        fct:fe::CONSTANT_GENERIC:<>
                                                        arg:syx::COERCED_PACKAGE:
                                                                #GLOBAL(7F9.19)
                                                                 src:syx::VARIABLE_PACKAGE:
                                                                 [#GLOBAL(7F9.15)]
                                                                tgt:syx::PACKAGE:
                                                                 ed::T: #GLOBAL(802.1) te::V: [#GLOBAL(7F9.19), #GLOBAL(7F9.16)]
                                                 <return_package>
                                    herein:syx::VARIABLE_PACKAGE:
                                     [#GLOBAL(7F9.18), #GLOBAL(ECE.2)]
                             im
                        ed::T: #GLOBAL(7F9.20) te::FM: ?.Next_Id_Counters
                            ed::T: #GLOBAL(7F9.21)
                             te::FM:
                             ?.Graph
                            ed::T: #GLOBAL(7F9.22)
                             te::FM:
                             ?.Edge
                            ed::T: #GLOBAL(7F9.23)
                             te::FM:
                             ?.Node
                    ed::S: #GLOBAL(7F9.24)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(7F9.18), #GLOBAL(ECE.2)]
                     im
                tgt:syx::PACKAGE:
                    ed::T: #GLOBAL(176.1)
                     te::V:
                     [#GLOBAL(7F9.11), #GLOBAL(7F9.21)]
                    ed::T: #GLOBAL(176.2)
                     te::V:
                     [#GLOBAL(7F9.11), #GLOBAL(7F9.22)]
                    ed::T: #GLOBAL(176.3)
                     te::V:
                     [#GLOBAL(7F9.11), #GLOBAL(7F9.23)]
                    ed::T: #GLOBAL(176.4)
                     te::V:
                     [#GLOBAL(7F9.11), #GLOBAL(7F9.12)]
                    ed::T: #GLOBAL(176.5)
                     te::V:
                     [#GLOBAL(7F9.11), #GLOBAL(7F9.13)]
                    ed::T: #GLOBAL(176.6)
                     te::V:
                     [#GLOBAL(7F9.11), #GLOBAL(7F9.14)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic interval_set_g
:
a_generic_api:
(d:
api {
    Point;
    compare : (Point , Point) -> Order;
    next : Point -> Point;
    prior : Point -> Point;
    is_succ : (Point , Point) -> Bool;
    min_pt : Point;
    max_pt : Point;};
)
:
api {   package d
          : api {
                Point;
                compare : (Point , Point) -> Order;
                next : Point -> Point;
                prior : Point -> Point;
                is_succ : (Point , Point) -> Bool;
                min_pt : Point;
                max_pt : Point;};;
    Item  = d::Point;
    Interval  = (Item , Item);
    Set;
    empty : Set;
    universe : Set;
    singleton : Item -> Set;
    interval : (Item , Item) -> Set;
    is_empty : Set -> Bool;
    is_universe : Set -> Bool;
    member : (Set , Item) -> Bool;
    items : Set -> List(Item );
    intervals : Set -> List(Interval );
    add : (Set , Item) -> Set;
    add' : (Item , Set) -> Set;
    add_int : (Set , Interval) -> Set;
    add_int' : (Interval , Set) -> Set;
    complement : Set -> Set;
    union : (Set , Set) -> Set;
    intersect : (Set , Set) -> Set;
    difference : (Set , Set) -> Set;
    apply : (Item -> Void) -> Set -> Void;
    fold_forward : ((Item , X) -> X) -> X -> Set -> X;
    fold_backward : ((Item , X) -> X) -> X -> Set -> X;
    filter : (Item -> Bool) -> Set -> Set;
    all : (Item -> Bool) -> Set -> Bool;
    exists : (Item -> Bool) -> Set -> Bool;
    apply_int : (Interval -> Void) -> Set -> Void;
    foldl_int : ((Interval , X) -> X) -> X -> Set -> X;
    foldr_int : ((Interval , X) -> X) -> X -> Set -> X;
    filter_int : (Interval -> Bool) -> Set -> Set;
    all_int : (Interval -> Bool) -> Set -> Bool;
    exists_int : (Interval -> Bool) -> Set -> Bool;
    compare : (Set , Set) -> Order;
    is_subset : (Set , Set) -> Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(9A7.3)
generic_closure:
CL:
parameter: #GLOBAL(9A7.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(9A7.2)
            syx::COERCED_PACKAGE:
                #GLOBAL(9A7.4)
                 src:syx::PACKAGE:
                        ed::S: #GLOBAL(9A7.5) syx::VARIABLE_PACKAGE: [#GLOBAL(9A7.0)] d
                        ed::T: #GLOBAL(9A7.6) te::FM: ?.Item
                        ed::T: #GLOBAL(9A7.7) te::FM: ?.Interval
                        ed::T: #GLOBAL(9A7.8) te::FM: ?.Set
                tgt:syx::PACKAGE:
                    ed::S: #GLOBAL(3D7.1)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(9A7.4), #GLOBAL(9A7.0)]
                     d
                    ed::T: #GLOBAL(3D7.2)
                     te::V:
                     [#GLOBAL(9A7.4), #GLOBAL(9A7.6)]
                    ed::T: #GLOBAL(3D7.3)
                     te::V:
                     [#GLOBAL(9A7.4), #GLOBAL(9A7.7)]
                    ed::T: #GLOBAL(3D7.4)
                     te::V:
                     [#GLOBAL(9A7.4), #GLOBAL(9A7.8)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic issue_unique_id_g
:
a_generic_api:
(<parameter>:
api {};
)
:
api {
    Id;
    issue_unique_id : Void -> Id;
    id_to_int : Id -> Int;
    id_zero : Id;
    same_id : (Id , Id) -> Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(306.4)
generic_closure:
CL:
parameter: #GLOBAL(306.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(306.3)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(306.5)
                         src:syx::PACKAGE:
                         ed::T: #GLOBAL(306.6) te::FM: ?.Id
                        tgt:syx::PACKAGE:
                         ed::T: #GLOBAL(95F.1) te::V: [#GLOBAL(306.5), #GLOBAL(306.6)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic issue_unique_id_wrapper_g
:
a_generic_api:
(<parameter>:
api {};
)
:
api {
    Id;
    issue_unique_id : Void -> Id;
    id_to_int : Id -> Int;
    id_zero : Id;
    same_id : (Id , Id) -> Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(B1B.4)
generic_closure:
CL:
parameter: #GLOBAL(B1B.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(B1B.3)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(B1B.5)
                         src:syx::PACKAGE:
                         ed::T: #GLOBAL(B1B.6) te::FM: ?.Id
                        tgt:syx::PACKAGE:
                         ed::T: #GLOBAL(95F.1) te::V: [#GLOBAL(B1B.5), #GLOBAL(B1B.6)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic keyword_g
:
a_generic_api:
(kw:
api {
    Token;
    Source_Position;
    ident : (quickstring__premicrothread::Quickstring , Source_Position , Source_Position) -> Token;
    keywords : List(((String , ((Source_Position , Source_Position) -> Token))) );};
)
:
api {
    Token;
    Source_Position;
    keyword : (String , Source_Position , Source_Position) -> Token;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(71F.13)
generic_closure:
CL:
parameter: #GLOBAL(71F.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(71F.7)
            syx::COERCED_PACKAGE:
                #GLOBAL(71F.14)
                 src:syx::PACKAGE:
                        ed::S: #GLOBAL(71F.15) syx::CONSTANT_PACKAGE: <quickstring__premicrothread> qs
                        ed::S: #GLOBAL(71F.16) syx::CONSTANT_PACKAGE: <> qht
                        ed::T: #GLOBAL(71F.17) te::FM: ?.Token
                        ed::T: #GLOBAL(71F.18) te::FM: ?.Source_Position
                tgt:syx::PACKAGE:
                    ed::T: #GLOBAL(71F.9)
                     te::V:
                     [#GLOBAL(71F.14), #GLOBAL(71F.17)]
                    ed::T: #GLOBAL(71F.10)
                     te::V:
                     [#GLOBAL(71F.14), #GLOBAL(71F.18)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic leftist_heap_priority_queue_g
:
a_generic_api:
(p:
api {
    Priority;
    Item;
    compare : (Priority , Priority) -> Order;
    priority : Item -> Priority;};
)
:
api {
    Item;
    Queue;
    empty : Queue;
    singleton : Item -> Queue;
    from_list : List(Item ) -> Queue;
    set : (Item , Queue) -> Queue;
    remove : Queue -> (Item , Queue);
    next : Queue -> Null_Or(((Item , Queue)) );
    merge : (Queue , Queue) -> Queue;
    vals_count : Queue -> Int;
    is_empty : Queue -> Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(6E5.3)
generic_closure:
CL:
parameter: #GLOBAL(6E5.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(6E5.2)
            syx::COERCED_PACKAGE:
                #GLOBAL(6E5.4)
                 src:syx::PACKAGE:
                        ed::T: #GLOBAL(6E5.5) te::FM: ?.Item
                            ed::T: #GLOBAL(6E5.6) te::FM: ?.Queue
                            ed::T: #GLOBAL(6E5.7) te::FM: ?.Heap
                tgt:syx::PACKAGE:
                    ed::T: #GLOBAL(8C9.1)
                     te::V:
                     [#GLOBAL(6E5.4), #GLOBAL(6E5.5)]
                    ed::T: #GLOBAL(8C9.2)
                     te::V:
                     [#GLOBAL(6E5.4), #GLOBAL(6E5.6)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic list_map_g
:
a_generic_api:
(k:
api {
    Key;
    compare : (Key , Key) -> Order;};
)
:
api {   package key
          : api {
                Key  = k::Key;
                compare : (Key , Key) -> Order;};;
    Map X;
    empty : Map(X );
    is_empty : Map(X ) -> Bool;
    singleton : (key::Key , X) -> Map(X );
    from_list : List(((key::Key , X)) ) -> Map(X );
    set : (Map(X ) , key::Key , X) -> Map(X );
    set' : (((key::Key , X)) , Map(X )) -> Map(X );
    $ : (Map(X ) , ((key::Key , X))) -> Map(X );
    get : (Map(X ) , key::Key) -> Null_Or(X );
    get_or_raise_exception_not_found : (Map(X ) , key::Key) -> X;
    contains_key : (Map(X ) , key::Key) -> Bool;
    preceding_key : (Map(X ) , key::Key) -> Null_Or(key::Key );
    following_key : (Map(X ) , key::Key) -> Null_Or(key::Key );
    get_and_drop : (Map(X ) , key::Key) -> (Map(X ) , Null_Or(X ));
    drop : (Map(X ) , key::Key) -> Map(X );
    first_val_else_null : Map(X ) -> Null_Or(X );
    first_keyval_else_null : Map(X ) -> Null_Or(((key::Key , X)) );
    last_val_else_null : Map(X ) -> Null_Or(X );
    last_keyval_else_null : Map(X ) -> Null_Or(((key::Key , X)) );
    vals_count : Map(X ) -> Int;
    vals_list : Map(X ) -> List(X );
    keyvals_list : Map(X ) -> List(((key::Key , X)) );
    keys_list : Map(X ) -> List(key::Key );
    compare_sequences : ((X , X) -> Order) -> (Map(X ) , Map(X )) -> Order;
    difference_with : (Map(X ) , Map(X )) -> Map(X );
    union_with : ((X , X) -> X) -> (Map(X ) , Map(X )) -> Map(X );
    keyed_union_with : ((key::Key , X , X) -> X) -> (Map(X ) , Map(X )) -> Map(X );
    intersect_with : ((X , Y) -> Z) -> (Map(X ) , Map(Y )) -> Map(Z );
    keyed_intersect_with : ((key::Key , X , Y) -> Z) -> (Map(X ) , Map(Y )) -> Map(Z );
    merge_with : ((Null_Or(X ) , Null_Or(Y )) -> Null_Or(Z )) -> (Map(X ) , Map(Y )) -> Map(Z );
        keyed_merge_with :
        ((key::Key , Null_Or(X ) , Null_Or(Y )) -> Null_Or(Z )) -> (Map(X ) , Map(Y )) -> Map(Z );
    apply : (X -> Void) -> Map(X ) -> Void;
    keyed_apply : ((key::Key , X) -> Void) -> Map(X ) -> Void;
    map : (X -> Y) -> Map(X ) -> Map(Y );
    keyed_map : ((key::Key , X) -> Y) -> Map(X ) -> Map(Y );
    fold_forward : ((X , Y) -> Y) -> Y -> Map(X ) -> Y;
    keyed_fold_forward : ((key::Key , X , Y) -> Y) -> Y -> Map(X ) -> Y;
    fold_backward : ((X , Y) -> Y) -> Y -> Map(X ) -> Y;
    keyed_fold_backward : ((key::Key , X , Y) -> Y) -> Y -> Map(X ) -> Y;
    filter : (X -> Bool) -> Map(X ) -> Map(X );
    keyed_filter : ((key::Key , X) -> Bool) -> Map(X ) -> Map(X );
    map' : (X -> Null_Or(Y )) -> Map(X ) -> Map(Y );
    keyed_map' : ((key::Key , X) -> Null_Or(Y )) -> Map(X ) -> Map(Y );
    all_invariants_hold : Map(X ) -> Bool;
    debug_print : (Map(X ) , (key::Key -> Void) , (X -> Void)) -> Int;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(8FA.6)
generic_closure:
CL:
parameter: #GLOBAL(8FA.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(8FA.2)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(8FA.7)
                         src:syx::PACKAGE:
                                ed::S: #GLOBAL(8FA.8) syx::VARIABLE_PACKAGE: [#GLOBAL(8FA.0)] key
                                ed::T: #GLOBAL(8FA.9) te::FM: ?.Map
                        tgt:syx::PACKAGE:
                            ed::S: #GLOBAL(577.1)
                             syx::PACKAGE:
                             ed::T: #GLOBAL(802.1) te::V: [#GLOBAL(8FA.7), #GLOBAL(8FA.0), #GLOBAL(802.1)]
                             key
                            ed::T: #GLOBAL(577.2)
                             te::V:
                             [#GLOBAL(8FA.7), #GLOBAL(8FA.9)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic list_set_g
:
a_generic_api:
(k:
api {
    Key;
    compare : (Key , Key) -> Order;};
)
:
api {   package key
          : api {
                Key  = k::Key;
                compare : (Key , Key) -> Order;};;
    Item  = key::Key;
    Set;
    empty : Set;
    singleton : Item -> Set;
    from_list : List(Item ) -> Set;
    add : (Set , Item) -> Set;
    add' : (Item , Set) -> Set;
    add_list : (Set , List(Item )) -> Set;
    drop : (Set , Item) -> Set;
    member : (Set , Item) -> Bool;
    preceding_member : (Set , Item) -> Null_Or(Item );
    following_member : (Set , Item) -> Null_Or(Item );
    is_empty : Set -> Bool;
    equal : (Set , Set) -> Bool;
    compare : (Set , Set) -> Order;
    is_subset : (Set , Set) -> Bool;
    vals_count : Set -> Int;
    vals_list : Set -> List(Item );
    union : (Set , Set) -> Set;
    intersection : (Set , Set) -> Set;
    difference : (Set , Set) -> Set;
    map : (Item -> Item) -> Set -> Set;
    apply : (Item -> Void) -> Set -> Void;
    fold_forward : ((Item , X) -> X) -> X -> Set -> X;
    fold_backward : ((Item , X) -> X) -> X -> Set -> X;
    partition : (Item -> Bool) -> Set -> (Set , Set);
    filter : (Item -> Bool) -> Set -> Set;
    exists : (Item -> Bool) -> Set -> Bool;
    find : (Item -> Bool) -> Set -> Null_Or(Item );
    all_invariants_hold : Set -> Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(C5F.6)
generic_closure:
CL:
parameter: #GLOBAL(C5F.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(C5F.2)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(C5F.7)
                         src:syx::PACKAGE:
                                ed::S: #GLOBAL(C5F.8) syx::VARIABLE_PACKAGE: [#GLOBAL(C5F.0)] key
                                ed::T: #GLOBAL(C5F.9) te::FM: ?.Item
                                ed::T: #GLOBAL(C5F.10) te::FM: ?.Set
                        tgt:syx::PACKAGE:
                            ed::S: #GLOBAL(691.1)
                             syx::PACKAGE:
                             ed::T: #GLOBAL(802.1) te::V: [#GLOBAL(C5F.7), #GLOBAL(C5F.0), #GLOBAL(802.1)]
                             key
                            ed::T: #GLOBAL(691.2)
                             te::V:
                             [#GLOBAL(C5F.7), #GLOBAL(C5F.9)]
                            ed::T: #GLOBAL(691.3)
                             te::V:
                             [#GLOBAL(C5F.7), #GLOBAL(C5F.10)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic make_complete_yacc_parser_g
:
a_generic_api:
(<parameter>:
api {   package lex
          : api {   package user_declarations
                      : api {
                            Token (X, Y);
                            Source_Position;
                            Semantic_Value;};;
                    make_lexer :
                        (Int -> String)
                        ->
                        Void
                        ->
                        user_declarations::Token((user_declarations::Semantic_Value, user_declarations::Source_Position));};;
        package parser_data
          : api {
                Source_Position;
                Semantic_Value;
                Arg;
                Result;
                    package lr_table
                      : api {
                            Pairlist (X, Y) = EMPTY | PAIR (X , Y , Pairlist((X, Y)));
                            State  = STATE Int;
                            Terminal  = TERM Int;
                            Nonterminal  = NONTERM Int;
                            Action  = ACCEPT | ERROR | REDUCE Int | SHIFT State;
                            Table;
                            state_count : Table -> Int;
                            rule_count : Table -> Int;
                            describe_goto : Table -> State -> Pairlist((Nonterminal, State));
                            action : Table -> (State , Terminal) -> Action;
                            goto : Table -> (State , Nonterminal) -> State;
                            initial_state : Table -> State;
                            describe_actions : Table -> State -> (Pairlist((Terminal, Action)) , Action);
                            exception GOTO (State , Nonterminal);
                                make_lr_table :
                                        {actions:Rw_Vector(((Pairlist((Terminal, Action)) , Action)) ),
                                        gotos:Rw_Vector(Pairlist((Nonterminal, State)) ), initial_state:State, rule_count:Int,
                                        state_count:Int}
                                    ->
                                    Table;};;
                    package token
                      : api {   package lr_table
                                  : api {
                                        Pairlist (X, Y) = EMPTY | PAIR (X , Y , Pairlist((X, Y)));
                                        State  = STATE Int;
                                        Terminal  = TERM Int;
                                        Nonterminal  = NONTERM Int;
                                        Action  = ACCEPT | ERROR | REDUCE Int | SHIFT State;
                                        Table;
                                        state_count : Table -> Int;
                                        rule_count : Table -> Int;
                                        describe_goto : Table -> State -> Pairlist((Nonterminal, State));
                                        action : Table -> (State , Terminal) -> Action;
                                        goto : Table -> (State , Nonterminal) -> State;
                                        initial_state : Table -> State;
                                        describe_actions : Table -> State -> (Pairlist((Terminal, Action)) , Action);
                                        exception GOTO (State , Nonterminal);
                                            make_lr_table :
                                                    {actions:Rw_Vector(((Pairlist((Terminal, Action)) , Action)) ),
                                                    gotos:Rw_Vector(Pairlist((Nonterminal, State)) ), initial_state:State, rule_count:Int,
                                                    state_count:Int}
                                                ->
                                                Table;};;
                            Token (X, Y) = TOKEN (lr_table::Terminal , ((X , Y , Y)));
                            same_token : (Token((X, Y)) , Token((X, Y))) -> Bool;};;
                    package actions
                      : api {   actions :
                                    (   Int , Source_Position ,
                                        List(((lr_table::State , ((Semantic_Value , Source_Position , Source_Position)))) ) , Arg
                                    )
                                    ->
                                    (   lr_table::Nonterminal , ((Semantic_Value , Source_Position , Source_Position)) ,
                                        List(((lr_table::State , ((Semantic_Value , Source_Position , Source_Position)))) )
                                    );
                            void : Semantic_Value;
                            extract : Semantic_Value -> Result;};;
                    package error_recovery
                      : api {
                            is_keyword : lr_table::Terminal -> Bool;
                            no_shift : lr_table::Terminal -> Bool;
                            errtermvalue : lr_table::Terminal -> Semantic_Value;
                            show_terminal : lr_table::Terminal -> String;
                            terms : List(lr_table::Terminal );
                            preferred_change : List(((List(lr_table::Terminal ) , List(lr_table::Terminal ))) );};;
                table : lr_table::Table;
            sharing lr_table = token::lr_table};;
        package lr_parser
          : api {   package stream
                      : api {
                            Stream X;
                            streamify : (Void -> X) -> Stream(X );
                            cons : (X , Stream(X )) -> Stream(X );
                            get : Stream(X ) -> (X , Stream(X ));};;
                    package lr_table
                      : api {
                            Pairlist (X, Y) = EMPTY | PAIR (X , Y , Pairlist((X, Y)));
                            State  = STATE Int;
                            Terminal  = TERM Int;
                            Nonterminal  = NONTERM Int;
                            Action  = ACCEPT | ERROR | REDUCE Int | SHIFT State;
                            Table;
                            state_count : Table -> Int;
                            rule_count : Table -> Int;
                            describe_goto : Table -> State -> Pairlist((Nonterminal, State));
                            action : Table -> (State , Terminal) -> Action;
                            goto : Table -> (State , Nonterminal) -> State;
                            initial_state : Table -> State;
                            describe_actions : Table -> State -> (Pairlist((Terminal, Action)) , Action);
                            exception GOTO (State , Nonterminal);
                                make_lr_table :
                                        {actions:Rw_Vector(((Pairlist((Terminal, Action)) , Action)) ),
                                        gotos:Rw_Vector(Pairlist((Nonterminal, State)) ), initial_state:State, rule_count:Int,
                                        state_count:Int}
                                    ->
                                    Table;};;
                    package token
                      : api {   package lr_table
                                  : api {
                                        Pairlist (X, Y) = EMPTY | PAIR (X , Y , Pairlist((X, Y)));
                                        State  = STATE Int;
                                        Terminal  = TERM Int;
                                        Nonterminal  = NONTERM Int;
                                        Action  = ACCEPT | ERROR | REDUCE Int | SHIFT State;
                                        Table;
                                        state_count : Table -> Int;
                                        rule_count : Table -> Int;
                                        describe_goto : Table -> State -> Pairlist((Nonterminal, State));
                                        action : Table -> (State , Terminal) -> Action;
                                        goto : Table -> (State , Nonterminal) -> State;
                                        initial_state : Table -> State;
                                        describe_actions : Table -> State -> (Pairlist((Terminal, Action)) , Action);
                                        exception GOTO (State , Nonterminal);
                                            make_lr_table :
                                                    {actions:Rw_Vector(((Pairlist((Terminal, Action)) , Action)) ),
                                                    gotos:Rw_Vector(Pairlist((Nonterminal, State)) ), initial_state:State, rule_count:Int,
                                                    state_count:Int}
                                                ->
                                                Table;};;
                            Token (X, Y) = TOKEN (lr_table::Terminal , ((X , Y , Y)));
                            same_token : (Token((X, Y)) , Token((X, Y))) -> Bool;};;
                exception PARSE_ERROR;
                    parse : {arg:X,
                            error_recovery:
                                {error:(String , Z , Z) -> Void, errtermvalue:lr_table::Terminal -> Y,
                                is_keyword:lr_table::Terminal -> Bool, no_shift:lr_table::Terminal -> Bool,
                                preferred_change:List(((List(lr_table::Terminal ) , List(lr_table::Terminal ))) ),
                                show_terminal:lr_table::Terminal -> String, terms:List(lr_table::Terminal )}
                            , lexer:stream::Stream(token::Token((Y, Z)) ), lookahead:Int,
                            saction:
                            (Int , Z , List(((lr_table::State , ((Y , Z , Z)))) ) , X)
                            ->
                            (lr_table::Nonterminal , ((Y , Z , Z)) , List(((lr_table::State , ((Y , Z , Z)))) ))
                            , table:lr_table::Table, void:Y}
                        ->
                        (Y , stream::Stream(token::Token((Y, Z)) ));
            sharing token::lr_table = lr_table};;
    sharing lr_parser::token = parser_data::token
    sharing lr_parser::lr_table = parser_data::lr_table
    sharing parser_data::token::Token = lex::user_declarations::Token
    sharing parser_data::Source_Position = lex::user_declarations::Source_Position
    sharing parser_data::Semantic_Value = lex::user_declarations::Semantic_Value};
)
:
api {   package token
          : api {   package lr_table
                      : api {
                            Pairlist (X, Y) = EMPTY | PAIR (X , Y , Pairlist((X, Y)));
                            State  = STATE Int;
                            Terminal  = TERM Int;
                            Nonterminal  = NONTERM Int;
                            Action  = ACCEPT | ERROR | REDUCE Int | SHIFT State;
                            Table;
                            state_count : Table -> Int;
                            rule_count : Table -> Int;
                            describe_goto : Table -> State -> Pairlist((Nonterminal, State));
                            action : Table -> (State , Terminal) -> Action;
                            goto : Table -> (State , Nonterminal) -> State;
                            initial_state : Table -> State;
                            describe_actions : Table -> State -> (Pairlist((Terminal, Action)) , Action);
                            exception GOTO (State , Nonterminal);
                                make_lr_table :
                                        {actions:Rw_Vector(((Pairlist((Terminal, Action)) , Action)) ),
                                        gotos:Rw_Vector(Pairlist((Nonterminal, State)) ), initial_state:State, rule_count:Int,
                                        state_count:Int}
                                    ->
                                    Table;};;
                Token (X, Y) = TOKEN (lr_table::Terminal , ((X , Y , Y)));
                same_token : (Token((X, Y)) , Token((X, Y))) -> Bool;};;
        package stream
          : api {
                Stream X;
                streamify : (Void -> X) -> Stream(X );
                cons : (X , Stream(X )) -> Stream(X );
                get : Stream(X ) -> (X , Stream(X ));};;
    exception PARSE_ERROR;
    Source_Position;
    Result;
    Arg;
    Semantic_Value;
    make_lexer : (Int -> String) -> stream::Stream(token::Token((Semantic_Value, Source_Position)) );
        parse :
            (   Int , stream::Stream(token::Token((Semantic_Value, Source_Position)) ) ,
                ((String , Source_Position , Source_Position) -> Void) , Arg
            )
            ->
            (Result , stream::Stream(token::Token((Semantic_Value, Source_Position)) ));
        same_token :
            (token::Token((Semantic_Value, Source_Position)) , token::Token((Semantic_Value, Source_Position)))
            ->
            Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(CB5.7)
generic_closure:
CL:
parameter: #GLOBAL(CB5.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(CB5.6)
            syx::COERCED_PACKAGE:
                #GLOBAL(CB5.8)
                 src:syx::PACKAGE:
                        ed::S: #GLOBAL(CB5.9) syx::VARIABLE_PACKAGE: [#GLOBAL(CB5.0), #GLOBAL(CB5.3), #GLOBAL(0B9.74)] token
                        ed::S: #GLOBAL(CB5.10) syx::VARIABLE_PACKAGE: [#GLOBAL(CB5.0), #GLOBAL(CB5.4), #GLOBAL(0B9.54)] stream
                        ed::T: #GLOBAL(CB5.11) te::FM: ?.Arg
                        ed::T: #GLOBAL(CB5.12) te::FM: ?.Source_Position
                        ed::T: #GLOBAL(CB5.13) te::FM: ?.Result
                        ed::T: #GLOBAL(CB5.14) te::FM: ?.Semantic_Value
                    ed::S: #GLOBAL(CB5.15)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(CB5.0), #GLOBAL(CB5.4), #GLOBAL(0B9.54)]
                     stream
                    ed::S: #GLOBAL(CB5.16)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(CB5.0), #GLOBAL(CB5.3), #GLOBAL(0B9.74)]
                     token
                tgt:syx::PACKAGE:
                    ed::S: #GLOBAL(0B9.58)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(CB5.8), #GLOBAL(CB5.16)]
                     token
                    ed::S: #GLOBAL(0B9.59)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(CB5.8), #GLOBAL(CB5.15)]
                     stream
                    ed::T: #GLOBAL(0B9.60)
                     te::V:
                     [#GLOBAL(CB5.8), #GLOBAL(CB5.12)]
                    ed::T: #GLOBAL(0B9.61)
                     te::V:
                     [#GLOBAL(CB5.8), #GLOBAL(CB5.13)]
                    ed::T: #GLOBAL(0B9.62)
                     te::V:
                     [#GLOBAL(CB5.8), #GLOBAL(CB5.11)]
                    ed::T: #GLOBAL(0B9.63)
                     te::V:
                     [#GLOBAL(CB5.8), #GLOBAL(CB5.14)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic make_complete_yacc_parser_with_custom_argument_g
:
a_generic_api:
(<parameter>:
api {   package lex
          : api {   package user_declarations
                      : api {
                            Token (X, Y);
                            Source_Position;
                            Semantic_Value;
                            Arg;};;
                    make_lexer :
                        (Int -> String)
                        ->
                        user_declarations::Arg
                        ->
                        Void
                        ->
                        user_declarations::Token((user_declarations::Semantic_Value, user_declarations::Source_Position));};;
        package parser_data
          : api {
                Source_Position;
                Semantic_Value;
                Arg;
                Result;
                    package lr_table
                      : api {
                            Pairlist (X, Y) = EMPTY | PAIR (X , Y , Pairlist((X, Y)));
                            State  = STATE Int;
                            Terminal  = TERM Int;
                            Nonterminal  = NONTERM Int;
                            Action  = ACCEPT | ERROR | REDUCE Int | SHIFT State;
                            Table;
                            state_count : Table -> Int;
                            rule_count : Table -> Int;
                            describe_goto : Table -> State -> Pairlist((Nonterminal, State));
                            action : Table -> (State , Terminal) -> Action;
                            goto : Table -> (State , Nonterminal) -> State;
                            initial_state : Table -> State;
                            describe_actions : Table -> State -> (Pairlist((Terminal, Action)) , Action);
                            exception GOTO (State , Nonterminal);
                                make_lr_table :
                                        {actions:Rw_Vector(((Pairlist((Terminal, Action)) , Action)) ),
                                        gotos:Rw_Vector(Pairlist((Nonterminal, State)) ), initial_state:State, rule_count:Int,
                                        state_count:Int}
                                    ->
                                    Table;};;
                    package token
                      : api {   package lr_table
                                  : api {
                                        Pairlist (X, Y) = EMPTY | PAIR (X , Y , Pairlist((X, Y)));
                                        State  = STATE Int;
                                        Terminal  = TERM Int;
                                        Nonterminal  = NONTERM Int;
                                        Action  = ACCEPT | ERROR | REDUCE Int | SHIFT State;
                                        Table;
                                        state_count : Table -> Int;
                                        rule_count : Table -> Int;
                                        describe_goto : Table -> State -> Pairlist((Nonterminal, State));
                                        action : Table -> (State , Terminal) -> Action;
                                        goto : Table -> (State , Nonterminal) -> State;
                                        initial_state : Table -> State;
                                        describe_actions : Table -> State -> (Pairlist((Terminal, Action)) , Action);
                                        exception GOTO (State , Nonterminal);
                                            make_lr_table :
                                                    {actions:Rw_Vector(((Pairlist((Terminal, Action)) , Action)) ),
                                                    gotos:Rw_Vector(Pairlist((Nonterminal, State)) ), initial_state:State, rule_count:Int,
                                                    state_count:Int}
                                                ->
                                                Table;};;
                            Token (X, Y) = TOKEN (lr_table::Terminal , ((X , Y , Y)));
                            same_token : (Token((X, Y)) , Token((X, Y))) -> Bool;};;
                    package actions
                      : api {   actions :
                                    (   Int , Source_Position ,
                                        List(((lr_table::State , ((Semantic_Value , Source_Position , Source_Position)))) ) , Arg
                                    )
                                    ->
                                    (   lr_table::Nonterminal , ((Semantic_Value , Source_Position , Source_Position)) ,
                                        List(((lr_table::State , ((Semantic_Value , Source_Position , Source_Position)))) )
                                    );
                            void : Semantic_Value;
                            extract : Semantic_Value -> Result;};;
                    package error_recovery
                      : api {
                            is_keyword : lr_table::Terminal -> Bool;
                            no_shift : lr_table::Terminal -> Bool;
                            errtermvalue : lr_table::Terminal -> Semantic_Value;
                            show_terminal : lr_table::Terminal -> String;
                            terms : List(lr_table::Terminal );
                            preferred_change : List(((List(lr_table::Terminal ) , List(lr_table::Terminal ))) );};;
                table : lr_table::Table;
            sharing lr_table = token::lr_table};;
        package lr_parser
          : api {   package stream
                      : api {
                            Stream X;
                            streamify : (Void -> X) -> Stream(X );
                            cons : (X , Stream(X )) -> Stream(X );
                            get : Stream(X ) -> (X , Stream(X ));};;
                    package lr_table
                      : api {
                            Pairlist (X, Y) = EMPTY | PAIR (X , Y , Pairlist((X, Y)));
                            State  = STATE Int;
                            Terminal  = TERM Int;
                            Nonterminal  = NONTERM Int;
                            Action  = ACCEPT | ERROR | REDUCE Int | SHIFT State;
                            Table;
                            state_count : Table -> Int;
                            rule_count : Table -> Int;
                            describe_goto : Table -> State -> Pairlist((Nonterminal, State));
                            action : Table -> (State , Terminal) -> Action;
                            goto : Table -> (State , Nonterminal) -> State;
                            initial_state : Table -> State;
                            describe_actions : Table -> State -> (Pairlist((Terminal, Action)) , Action);
                            exception GOTO (State , Nonterminal);
                                make_lr_table :
                                        {actions:Rw_Vector(((Pairlist((Terminal, Action)) , Action)) ),
                                        gotos:Rw_Vector(Pairlist((Nonterminal, State)) ), initial_state:State, rule_count:Int,
                                        state_count:Int}
                                    ->
                                    Table;};;
                    package token
                      : api {   package lr_table
                                  : api {
                                        Pairlist (X, Y) = EMPTY | PAIR (X , Y , Pairlist((X, Y)));
                                        State  = STATE Int;
                                        Terminal  = TERM Int;
                                        Nonterminal  = NONTERM Int;
                                        Action  = ACCEPT | ERROR | REDUCE Int | SHIFT State;
                                        Table;
                                        state_count : Table -> Int;
                                        rule_count : Table -> Int;
                                        describe_goto : Table -> State -> Pairlist((Nonterminal, State));
                                        action : Table -> (State , Terminal) -> Action;
                                        goto : Table -> (State , Nonterminal) -> State;
                                        initial_state : Table -> State;
                                        describe_actions : Table -> State -> (Pairlist((Terminal, Action)) , Action);
                                        exception GOTO (State , Nonterminal);
                                            make_lr_table :
                                                    {actions:Rw_Vector(((Pairlist((Terminal, Action)) , Action)) ),
                                                    gotos:Rw_Vector(Pairlist((Nonterminal, State)) ), initial_state:State, rule_count:Int,
                                                    state_count:Int}
                                                ->
                                                Table;};;
                            Token (X, Y) = TOKEN (lr_table::Terminal , ((X , Y , Y)));
                            same_token : (Token((X, Y)) , Token((X, Y))) -> Bool;};;
                exception PARSE_ERROR;
                    parse : {arg:X,
                            error_recovery:
                                {error:(String , Z , Z) -> Void, errtermvalue:lr_table::Terminal -> Y,
                                is_keyword:lr_table::Terminal -> Bool, no_shift:lr_table::Terminal -> Bool,
                                preferred_change:List(((List(lr_table::Terminal ) , List(lr_table::Terminal ))) ),
                                show_terminal:lr_table::Terminal -> String, terms:List(lr_table::Terminal )}
                            , lexer:stream::Stream(token::Token((Y, Z)) ), lookahead:Int,
                            saction:
                            (Int , Z , List(((lr_table::State , ((Y , Z , Z)))) ) , X)
                            ->
                            (lr_table::Nonterminal , ((Y , Z , Z)) , List(((lr_table::State , ((Y , Z , Z)))) ))
                            , table:lr_table::Table, void:Y}
                        ->
                        (Y , stream::Stream(token::Token((Y, Z)) ));
            sharing token::lr_table = lr_table};;
    sharing lr_parser::token = parser_data::token
    sharing lr_parser::lr_table = parser_data::lr_table
    sharing parser_data::token::Token = lex::user_declarations::Token
    sharing parser_data::Source_Position = lex::user_declarations::Source_Position
    sharing parser_data::Semantic_Value = lex::user_declarations::Semantic_Value};
)
:
api {   package token
          : api {   package lr_table
                      : api {
                            Pairlist (X, Y) = EMPTY | PAIR (X , Y , Pairlist((X, Y)));
                            State  = STATE Int;
                            Terminal  = TERM Int;
                            Nonterminal  = NONTERM Int;
                            Action  = ACCEPT | ERROR | REDUCE Int | SHIFT State;
                            Table;
                            state_count : Table -> Int;
                            rule_count : Table -> Int;
                            describe_goto : Table -> State -> Pairlist((Nonterminal, State));
                            action : Table -> (State , Terminal) -> Action;
                            goto : Table -> (State , Nonterminal) -> State;
                            initial_state : Table -> State;
                            describe_actions : Table -> State -> (Pairlist((Terminal, Action)) , Action);
                            exception GOTO (State , Nonterminal);
                                make_lr_table :
                                        {actions:Rw_Vector(((Pairlist((Terminal, Action)) , Action)) ),
                                        gotos:Rw_Vector(Pairlist((Nonterminal, State)) ), initial_state:State, rule_count:Int,
                                        state_count:Int}
                                    ->
                                    Table;};;
                Token (X, Y) = TOKEN (lr_table::Terminal , ((X , Y , Y)));
                same_token : (Token((X, Y)) , Token((X, Y))) -> Bool;};;
        package stream
          : api {
                Stream X;
                streamify : (Void -> X) -> Stream(X );
                cons : (X , Stream(X )) -> Stream(X );
                get : Stream(X ) -> (X , Stream(X ));};;
    exception PARSE_ERROR;
    Arg;
    Lex_Arg;
    Source_Position;
    Result;
    Semantic_Value;
        make_lexer :
        (Int -> String) -> Lex_Arg -> stream::Stream(token::Token((Semantic_Value, Source_Position)) );
        parse :
            (   Int , stream::Stream(token::Token((Semantic_Value, Source_Position)) ) ,
                ((String , Source_Position , Source_Position) -> Void) , Arg
            )
            ->
            (Result , stream::Stream(token::Token((Semantic_Value, Source_Position)) ));
        same_token :
            (token::Token((Semantic_Value, Source_Position)) , token::Token((Semantic_Value, Source_Position)))
            ->
            Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(AB0.7)
generic_closure:
CL:
parameter: #GLOBAL(AB0.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(AB0.6)
            syx::COERCED_PACKAGE:
                #GLOBAL(AB0.8)
                 src:syx::PACKAGE:
                        ed::S: #GLOBAL(AB0.9) syx::VARIABLE_PACKAGE: [#GLOBAL(AB0.0), #GLOBAL(AB0.3), #GLOBAL(0B9.74)] token
                        ed::S: #GLOBAL(AB0.10) syx::VARIABLE_PACKAGE: [#GLOBAL(AB0.0), #GLOBAL(AB0.4), #GLOBAL(0B9.54)] stream
                        ed::T: #GLOBAL(AB0.11) te::FM: ?.Lex_Arg
                        ed::T: #GLOBAL(AB0.12) te::FM: ?.Arg
                        ed::T: #GLOBAL(AB0.13) te::FM: ?.Source_Position
                        ed::T: #GLOBAL(AB0.14) te::FM: ?.Result
                        ed::T: #GLOBAL(AB0.15) te::FM: ?.Semantic_Value
                    ed::S: #GLOBAL(AB0.16)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(AB0.0), #GLOBAL(AB0.4), #GLOBAL(0B9.54)]
                     stream
                    ed::S: #GLOBAL(AB0.17)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(AB0.0), #GLOBAL(AB0.3), #GLOBAL(0B9.74)]
                     token
                tgt:syx::PACKAGE:
                    ed::S: #GLOBAL(0B9.12)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(AB0.8), #GLOBAL(AB0.17)]
                     token
                    ed::S: #GLOBAL(0B9.13)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(AB0.8), #GLOBAL(AB0.16)]
                     stream
                    ed::T: #GLOBAL(0B9.14)
                     te::V:
                     [#GLOBAL(AB0.8), #GLOBAL(AB0.12)]
                    ed::T: #GLOBAL(0B9.15)
                     te::V:
                     [#GLOBAL(AB0.8), #GLOBAL(AB0.11)]
                    ed::T: #GLOBAL(0B9.16)
                     te::V:
                     [#GLOBAL(AB0.8), #GLOBAL(AB0.13)]
                    ed::T: #GLOBAL(0B9.17)
                     te::V:
                     [#GLOBAL(AB0.8), #GLOBAL(AB0.14)]
                    ed::T: #GLOBAL(0B9.18)
                     te::V:
                     [#GLOBAL(AB0.8), #GLOBAL(AB0.15)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic red_black_map_g
:
a_generic_api:
(k:
api {
    Key;
    compare : (Key , Key) -> Order;};
)
:
api {   package key
          : api {
                Key;
                compare : (Key , Key) -> Order;};;
    Map X;
    empty : Map(X );
    is_empty : Map(X ) -> Bool;
    singleton : (key::Key , X) -> Map(X );
    from_list : List(((key::Key , X)) ) -> Map(X );
    set : (Map(X ) , key::Key , X) -> Map(X );
    set' : (((key::Key , X)) , Map(X )) -> Map(X );
    $ : (Map(X ) , ((key::Key , X))) -> Map(X );
    get : (Map(X ) , key::Key) -> Null_Or(X );
    get_or_raise_exception_not_found : (Map(X ) , key::Key) -> X;
    contains_key : (Map(X ) , key::Key) -> Bool;
    preceding_key : (Map(X ) , key::Key) -> Null_Or(key::Key );
    following_key : (Map(X ) , key::Key) -> Null_Or(key::Key );
    get_and_drop : (Map(X ) , key::Key) -> (Map(X ) , Null_Or(X ));
    drop : (Map(X ) , key::Key) -> Map(X );
    first_val_else_null : Map(X ) -> Null_Or(X );
    first_keyval_else_null : Map(X ) -> Null_Or(((key::Key , X)) );
    last_val_else_null : Map(X ) -> Null_Or(X );
    last_keyval_else_null : Map(X ) -> Null_Or(((key::Key , X)) );
    vals_count : Map(X ) -> Int;
    vals_list : Map(X ) -> List(X );
    keyvals_list : Map(X ) -> List(((key::Key , X)) );
    keys_list : Map(X ) -> List(key::Key );
    compare_sequences : ((X , X) -> Order) -> (Map(X ) , Map(X )) -> Order;
    difference_with : (Map(X ) , Map(X )) -> Map(X );
    union_with : ((X , X) -> X) -> (Map(X ) , Map(X )) -> Map(X );
    keyed_union_with : ((key::Key , X , X) -> X) -> (Map(X ) , Map(X )) -> Map(X );
    intersect_with : ((X , Y) -> Z) -> (Map(X ) , Map(Y )) -> Map(Z );
    keyed_intersect_with : ((key::Key , X , Y) -> Z) -> (Map(X ) , Map(Y )) -> Map(Z );
    merge_with : ((Null_Or(X ) , Null_Or(Y )) -> Null_Or(Z )) -> (Map(X ) , Map(Y )) -> Map(Z );
        keyed_merge_with :
        ((key::Key , Null_Or(X ) , Null_Or(Y )) -> Null_Or(Z )) -> (Map(X ) , Map(Y )) -> Map(Z );
    apply : (X -> Void) -> Map(X ) -> Void;
    keyed_apply : ((key::Key , X) -> Void) -> Map(X ) -> Void;
    map : (X -> Y) -> Map(X ) -> Map(Y );
    keyed_map : ((key::Key , X) -> Y) -> Map(X ) -> Map(Y );
    fold_forward : ((X , Y) -> Y) -> Y -> Map(X ) -> Y;
    keyed_fold_forward : ((key::Key , X , Y) -> Y) -> Y -> Map(X ) -> Y;
    fold_backward : ((X , Y) -> Y) -> Y -> Map(X ) -> Y;
    keyed_fold_backward : ((key::Key , X , Y) -> Y) -> Y -> Map(X ) -> Y;
    filter : (X -> Bool) -> Map(X ) -> Map(X );
    keyed_filter : ((key::Key , X) -> Bool) -> Map(X ) -> Map(X );
    map' : (X -> Null_Or(Y )) -> Map(X ) -> Map(Y );
    keyed_map' : ((key::Key , X) -> Null_Or(Y )) -> Map(X ) -> Map(Y );
    all_invariants_hold : Map(X ) -> Bool;
    debug_print : (Map(X ) , (key::Key -> Void) , (X -> Void)) -> Int;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(ECE.4)
generic_closure:
CL:
parameter: #GLOBAL(ECE.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(ECE.2)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(ECE.5)
                         src:syx::PACKAGE:
                                ed::S: #GLOBAL(ECE.6) syx::VARIABLE_PACKAGE: [#GLOBAL(ECE.0)] key
                                ed::T: #GLOBAL(ECE.7) te::FM: ?.Color
                                ed::T: #GLOBAL(ECE.8) te::FM: ?.Tree
                                ed::T: #GLOBAL(ECE.9) te::FM: ?.Map
                                ed::T: #GLOBAL(ECE.10) te::FM: ?.Descent_Path
                                ed::T: #GLOBAL(ECE.11) te::FM: ?.Digit
                        tgt:syx::PACKAGE:
                            ed::S: #GLOBAL(577.1)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(ECE.5), #GLOBAL(ECE.0)]
                             key
                            ed::T: #GLOBAL(577.2)
                             te::V:
                             [#GLOBAL(ECE.5), #GLOBAL(ECE.9)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic red_black_map_with_implicit_keys_g
:
a_generic_api:
(k:
api {
    Key;
    compare : (Key , Key) -> Order;};
)
:
api {   package key
          : api {
                Key;
                compare : (Key , Key) -> Order;};;
    Map X;
    empty : (X -> key::Key) -> Map(X );
    is_empty : Map(X ) -> Bool;
    singleton : (X , (X -> key::Key)) -> Map(X );
    set : (Map(X ) , X) -> Map(X );
    set' : (X , Map(X )) -> Map(X );
    $ : (Map(X ) , X) -> Map(X );
    get : (Map(X ) , key::Key) -> Null_Or(X );
    get_or_raise_exception_not_found : (Map(X ) , key::Key) -> X;
    contains_key : (Map(X ) , key::Key) -> Bool;
    get_and_drop : (Map(X ) , key::Key) -> (Map(X ) , Null_Or(X ));
    drop : (Map(X ) , key::Key) -> Map(X );
    first_val_else_null : Map(X ) -> Null_Or(X );
    first_keyval_else_null : Map(X ) -> Null_Or(((key::Key , X)) );
    last_val_else_null : Map(X ) -> Null_Or(X );
    last_keyval_else_null : Map(X ) -> Null_Or(((key::Key , X)) );
    vals_count : Map(X ) -> Int;
    vals_list : Map(X ) -> List(X );
    keyvals_list : Map(X ) -> List(((key::Key , X)) );
    keys_list : Map(X ) -> List(key::Key );
    compare_sequences : ((X , X) -> Order) -> (Map(X ) , Map(X )) -> Order;
    union_with : ((X , X) -> X) -> (Map(X ) , Map(X )) -> Map(X );
    keyed_union_with : ((key::Key , X , X) -> X) -> (Map(X ) , Map(X )) -> Map(X );
    intersect_with : ((Y , X) -> Y) -> (Map(Y ) , Map(X )) -> Map(Y );
    keyed_intersect_with : ((key::Key , Y , X) -> Y) -> (Map(Y ) , Map(X )) -> Map(Y );
    merge_with : ((Null_Or(Y ) , Null_Or(X )) -> Null_Or(Y )) -> (Map(Y ) , Map(X )) -> Map(Y );
        keyed_merge_with :
        ((key::Key , Null_Or(Y ) , Null_Or(X )) -> Null_Or(Y )) -> (Map(Y ) , Map(X )) -> Map(Y );
    apply : (X -> Void) -> Map(X ) -> Void;
    keyed_apply : ((key::Key , X) -> Void) -> Map(X ) -> Void;
    fold_forward : ((X , Y) -> Y) -> Y -> Map(X ) -> Y;
    keyed_fold_forward : ((key::Key , X , Y) -> Y) -> Y -> Map(X ) -> Y;
    fold_backward : ((X , Y) -> Y) -> Y -> Map(X ) -> Y;
    keyed_fold_backward : ((key::Key , X , Y) -> Y) -> Y -> Map(X ) -> Y;
    filter : (X -> Bool) -> Map(X ) -> Map(X );
    keyed_filter : ((key::Key , X) -> Bool) -> Map(X ) -> Map(X );
    all_invariants_hold : Map(X ) -> Bool;
    debug_print : (Map(X ) , (key::Key -> Void) , (X -> Void)) -> Int;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(DDE.4)
generic_closure:
CL:
parameter: #GLOBAL(DDE.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(DDE.2)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(DDE.5)
                         src:syx::PACKAGE:
                                ed::S: #GLOBAL(DDE.6) syx::VARIABLE_PACKAGE: [#GLOBAL(DDE.0)] key
                                ed::T: #GLOBAL(DDE.7) te::FM: ?.Color
                                ed::T: #GLOBAL(DDE.8) te::FM: ?.Tree
                                ed::T: #GLOBAL(DDE.9) te::FM: ?.Map
                                ed::T: #GLOBAL(DDE.10) te::FM: ?.Descent_Path
                                ed::T: #GLOBAL(DDE.11) te::FM: ?.Digit
                        tgt:syx::PACKAGE:
                            ed::S: #GLOBAL(1B2.1)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(DDE.5), #GLOBAL(DDE.0)]
                             key
                            ed::T: #GLOBAL(1B2.2)
                             te::V:
                             [#GLOBAL(DDE.5), #GLOBAL(DDE.9)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic red_black_numbered_set_g
:
a_generic_api:
(k:
api {
    Key;
    compare : (Key , Key) -> Order;};
)
:
api {   package key
          : api {
                Key;
                compare : (Key , Key) -> Order;};;
    Numbered_Set;
    empty : Numbered_Set;
    is_empty : Numbered_Set -> Bool;
    from_list : List(key::Key ) -> Numbered_Set;
    singleton : key::Key -> Numbered_Set;
    set : (Numbered_Set , key::Key) -> Numbered_Set;
    set' : (key::Key , Numbered_Set) -> Numbered_Set;
    $ : (Numbered_Set , key::Key) -> Numbered_Set;
    find : (Numbered_Set , key::Key) -> Null_Or(Int );
    contains_key : (Numbered_Set , key::Key) -> Bool;
    remove : (Numbered_Set , key::Key) -> (Numbered_Set , Int);
    first_key_else_null : Numbered_Set -> Null_Or(key::Key );
    vals_count : Numbered_Set -> Int;
    keys_list : Numbered_Set -> List(key::Key );
    union_with : ((X , X) -> X) -> (Numbered_Set , Numbered_Set) -> Numbered_Set;
    keyed_union_with : ((key::Key , X , X) -> X) -> (Numbered_Set , Numbered_Set) -> Numbered_Set;
    intersect_with : ((X , Y) -> Z) -> (Numbered_Set , Numbered_Set) -> Numbered_Set;
    keyed_intersect_with : ((key::Key , X , Y) -> Z) -> (Numbered_Set , Numbered_Set) -> Numbered_Set;
    apply : (key::Key -> Void) -> Numbered_Set -> Void;
    keyed_apply : ((key::Key , Int) -> Void) -> Numbered_Set -> Void;
    fold_forward : ((key::Key , X) -> X) -> X -> Numbered_Set -> X;
    keyed_fold_forward : ((key::Key , Int , X) -> X) -> X -> Numbered_Set -> X;
    fold_backward : ((key::Key , X) -> X) -> X -> Numbered_Set -> X;
    keyed_fold_backward : ((key::Key , Int , X) -> X) -> X -> Numbered_Set -> X;
    filter : (key::Key -> Bool) -> Numbered_Set -> Numbered_Set;
    keyed_filter : ((key::Key , Int) -> Bool) -> Numbered_Set -> Numbered_Set;
    all_invariants_hold : Numbered_Set -> Bool;
    debug_print : (Numbered_Set , (key::Key -> Void)) -> Int;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(318.4)
generic_closure:
CL:
parameter: #GLOBAL(318.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(318.2)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(318.5)
                         src:syx::PACKAGE:
                                ed::S: #GLOBAL(318.6) syx::VARIABLE_PACKAGE: [#GLOBAL(318.0)] key
                                ed::T: #GLOBAL(318.7) te::FM: ?.Color
                                ed::T: #GLOBAL(318.8) te::FM: ?.Tree
                                ed::T: #GLOBAL(318.9) te::FM: ?.Numbered_Set
                                ed::T: #GLOBAL(318.10) te::FM: ?.Descent_Path
                                ed::T: #GLOBAL(318.11) te::FM: ?.Digit
                        tgt:syx::PACKAGE:
                            ed::S: #GLOBAL(6E1.1)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(318.5), #GLOBAL(318.0)]
                             key
                            ed::T: #GLOBAL(6E1.2)
                             te::V:
                             [#GLOBAL(318.5), #GLOBAL(318.9)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic red_black_set_g
:
a_generic_api:
(k:
api {
    Key;
    compare : (Key , Key) -> Order;};
)
:
api {   package key
          : api {
                Key;
                compare : (Key , Key) -> Order;};;
    Item  = key::Key;
    Set;
    empty : Set;
    singleton : Item -> Set;
    from_list : List(Item ) -> Set;
    add : (Set , Item) -> Set;
    add' : (Item , Set) -> Set;
    add_list : (Set , List(Item )) -> Set;
    drop : (Set , Item) -> Set;
    member : (Set , Item) -> Bool;
    preceding_member : (Set , Item) -> Null_Or(Item );
    following_member : (Set , Item) -> Null_Or(Item );
    is_empty : Set -> Bool;
    equal : (Set , Set) -> Bool;
    compare : (Set , Set) -> Order;
    is_subset : (Set , Set) -> Bool;
    vals_count : Set -> Int;
    vals_list : Set -> List(Item );
    union : (Set , Set) -> Set;
    intersection : (Set , Set) -> Set;
    difference : (Set , Set) -> Set;
    map : (Item -> Item) -> Set -> Set;
    apply : (Item -> Void) -> Set -> Void;
    fold_forward : ((Item , X) -> X) -> X -> Set -> X;
    fold_backward : ((Item , X) -> X) -> X -> Set -> X;
    partition : (Item -> Bool) -> Set -> (Set , Set);
    filter : (Item -> Bool) -> Set -> Set;
    exists : (Item -> Bool) -> Set -> Bool;
    find : (Item -> Bool) -> Set -> Null_Or(Item );
    all_invariants_hold : Set -> Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(875.4)
generic_closure:
CL:
parameter: #GLOBAL(875.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(875.2)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(875.5)
                         src:syx::PACKAGE:
                                ed::S: #GLOBAL(875.6) syx::VARIABLE_PACKAGE: [#GLOBAL(875.0)] key
                                ed::T: #GLOBAL(875.7) te::FM: ?.Item
                                ed::T: #GLOBAL(875.8) te::FM: ?.Color
                                ed::T: #GLOBAL(875.9) te::FM: ?.Tree
                                ed::T: #GLOBAL(875.10) te::FM: ?.Set
                                ed::T: #GLOBAL(875.11) te::FM: ?.Descent_Path
                                ed::T: #GLOBAL(875.12) te::FM: ?.Digit
                        tgt:syx::PACKAGE:
                            ed::S: #GLOBAL(691.1)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(875.5), #GLOBAL(875.0)]
                             key
                            ed::T: #GLOBAL(691.2)
                             te::V:
                             [#GLOBAL(875.5), #GLOBAL(875.7)]
                            ed::T: #GLOBAL(691.3)
                             te::V:
                             [#GLOBAL(875.5), #GLOBAL(875.10)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic red_black_setx_g
:
a_generic_api:
(k:
api {
    Key X;
    compare : (Key(X ) , Key(X )) -> Order;};
)
:
api {   package key
          : api {
                Key X;
                compare : (Key(X ) , Key(X )) -> Order;};;
    Item X = key::Key(X );
    Set X;
    empty : Set(X );
    singleton : Item(X ) -> Set(X );
    add : (Set(X ) , Item(X )) -> Set(X );
    add' : (Item(X ) , Set(X )) -> Set(X );
    add_list : (Set(X ) , List(Item(X ) )) -> Set(X );
    drop : (Set(X ) , Item(X )) -> Set(X );
    member : (Set(X ) , Item(X )) -> Bool;
    is_empty : Set(X ) -> Bool;
    equal : (Set(X ) , Set(X )) -> Bool;
    compare : (Set(X ) , Set(X )) -> Order;
    is_subset : (Set(X ) , Set(X )) -> Bool;
    vals_count : Set(X ) -> Int;
    vals_list : Set(X ) -> List(Item(X ) );
    union : (Set(X ) , Set(X )) -> Set(X );
    intersection : (Set(X ) , Set(X )) -> Set(X );
    difference : (Set(X ) , Set(X )) -> Set(X );
    map : (Item(X ) -> Item(X )) -> Set(X ) -> Set(X );
    apply : (Item(X ) -> Void) -> Set(X ) -> Void;
    fold_forward : ((Item(X ) , Y) -> Y) -> Y -> Set(X ) -> Y;
    fold_backward : ((Item(X ) , Y) -> Y) -> Y -> Set(X ) -> Y;
    partition : (Item(X ) -> Bool) -> Set(X ) -> (Set(X ) , Set(X ));
    filter : (Item(X ) -> Bool) -> Set(X ) -> Set(X );
    exists : (Item(X ) -> Bool) -> Set(X ) -> Bool;
    find : (Item(X ) -> Bool) -> Set(X ) -> Null_Or(Item(X ) );
    all_invariants_hold : Set(X ) -> Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(532.4)
generic_closure:
CL:
parameter: #GLOBAL(532.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(532.2)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(532.5)
                         src:syx::PACKAGE:
                                ed::S: #GLOBAL(532.6) syx::VARIABLE_PACKAGE: [#GLOBAL(532.0)] key
                                ed::T: #GLOBAL(532.7) te::FM: ?.Item
                                ed::T: #GLOBAL(532.8) te::FM: ?.Color
                                ed::T: #GLOBAL(532.9) te::FM: ?.Tree
                                ed::T: #GLOBAL(532.10) te::FM: ?.Set
                                ed::T: #GLOBAL(532.11) te::FM: ?.Descent_Path
                                ed::T: #GLOBAL(532.12) te::FM: ?.Digit
                        tgt:syx::PACKAGE:
                            ed::S: #GLOBAL(F54.1)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(532.5), #GLOBAL(532.0)]
                             key
                            ed::T: #GLOBAL(F54.2)
                             te::V:
                             [#GLOBAL(532.5), #GLOBAL(532.7)]
                            ed::T: #GLOBAL(F54.3)
                             te::V:
                             [#GLOBAL(532.5), #GLOBAL(532.10)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic red_black_setxy_g
:
a_generic_api:
(k:
api {
    Key (X, Y);
    compare : (Key((X, Y)) , Key((X, Y))) -> Order;};
)
:
api {   package key
          : api {
                Key (X, Y);
                compare : (Key((X, Y)) , Key((X, Y))) -> Order;};;
    Item (X, Y) = key::Key((X, Y));
    Set (X, Y);
    empty : Set((X, Y));
    singleton : Item((X, Y)) -> Set((X, Y));
    add : (Set((X, Y)) , Item((X, Y))) -> Set((X, Y));
    add' : (Item((X, Y)) , Set((X, Y))) -> Set((X, Y));
    add_list : (Set((X, Y)) , List(Item((X, Y)) )) -> Set((X, Y));
    drop : (Set((X, Y)) , Item((X, Y))) -> Set((X, Y));
    member : (Set((X, Y)) , Item((X, Y))) -> Bool;
    is_empty : Set((X, Y)) -> Bool;
    equal : (Set((X, Y)) , Set((X, Y))) -> Bool;
    compare : (Set((X, Y)) , Set((X, Y))) -> Order;
    is_subset : (Set((X, Y)) , Set((X, Y))) -> Bool;
    vals_count : Set((X, Y)) -> Int;
    vals_list : Set((X, Y)) -> List(Item((X, Y)) );
    union : (Set((X, Y)) , Set((X, Y))) -> Set((X, Y));
    intersection : (Set((X, Y)) , Set((X, Y))) -> Set((X, Y));
    difference : (Set((X, Y)) , Set((X, Y))) -> Set((X, Y));
    map : (Item((X, Y)) -> Item((X, Y))) -> Set((X, Y)) -> Set((X, Y));
    apply : (Item((X, Y)) -> Void) -> Set((X, Y)) -> Void;
    fold_forward : ((Item((X, Y)) , Y) -> Y) -> Y -> Set((X, Y)) -> Y;
    fold_backward : ((Item((X, Y)) , Y) -> Y) -> Y -> Set((X, Y)) -> Y;
    partition : (Item((X, Y)) -> Bool) -> Set((X, Y)) -> (Set((X, Y)) , Set((X, Y)));
    filter : (Item((X, Y)) -> Bool) -> Set((X, Y)) -> Set((X, Y));
    exists : (Item((X, Y)) -> Bool) -> Set((X, Y)) -> Bool;
    find : (Item((X, Y)) -> Bool) -> Set((X, Y)) -> Null_Or(Item((X, Y)) );
    all_invariants_hold : Set((X, Y)) -> Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(1C5.4)
generic_closure:
CL:
parameter: #GLOBAL(1C5.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(1C5.2)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(1C5.5)
                         src:syx::PACKAGE:
                                ed::S: #GLOBAL(1C5.6) syx::VARIABLE_PACKAGE: [#GLOBAL(1C5.0)] key
                                ed::T: #GLOBAL(1C5.7) te::FM: ?.Item
                                ed::T: #GLOBAL(1C5.8) te::FM: ?.Color
                                ed::T: #GLOBAL(1C5.9) te::FM: ?.Tree
                                ed::T: #GLOBAL(1C5.10) te::FM: ?.Set
                                ed::T: #GLOBAL(1C5.11) te::FM: ?.Descent_Path
                                ed::T: #GLOBAL(1C5.12) te::FM: ?.Digit
                        tgt:syx::PACKAGE:
                            ed::S: #GLOBAL(8D7.1)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(1C5.5), #GLOBAL(1C5.0)]
                             key
                            ed::T: #GLOBAL(8D7.2)
                             te::V:
                             [#GLOBAL(1C5.5), #GLOBAL(1C5.7)]
                            ed::T: #GLOBAL(8D7.3)
                             te::V:
                             [#GLOBAL(1C5.5), #GLOBAL(1C5.10)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic regular_expression_matcher_g
:
a_generic_api:
(<parameter>:
api {   package p
          : api {   package r
                      : api {
                            exception CANNOT_PARSE;
                            exception CANNOT_COMPILE;
                                package char
                                  : api {
                                        eqtype Char;
                                        eqtype String;
                                        from_int : Int -> Char;
                                        to_int : Char -> Int;
                                        min_char : Char;
                                        max_char : Char;
                                        max_ord : Int;
                                        prior : Char -> Char;
                                        next : Char -> Char;
                                        < : (Char , Char) -> Bool;
                                        <= : (Char , Char) -> Bool;
                                        > : (Char , Char) -> Bool;
                                        >= : (Char , Char) -> Bool;
                                        compare : (Char , Char) -> Order;
                                        scan : number_string::Reader((Char, X)) -> number_string::Reader((Char, X));
                                        from_string : string::String -> Null_Or(Char );
                                        to_string : Char -> string::String;
                                        from_cstring : string::String -> Null_Or(Char );
                                        to_cstring : Char -> string::String;
                                        contains : String -> Char -> Bool;
                                        not_contains : String -> Char -> Bool;
                                        is_lower : Char -> Bool;
                                        is_upper : Char -> Bool;
                                        is_digit : Char -> Bool;
                                        is_alpha : Char -> Bool;
                                        is_hex_digit : Char -> Bool;
                                        is_alphanumeric : Char -> Bool;
                                        is_print : Char -> Bool;
                                        is_space : Char -> Bool;
                                        is_punct : Char -> Bool;
                                        is_graph : Char -> Bool;
                                        is_cntrl : Char -> Bool;
                                        is_ascii : Char -> Bool;
                                        to_upper : Char -> Char;
                                        to_lower : Char -> Char;
                                        nul : Char;
                                        ctrl_a : Char;
                                        ctrl_b : Char;
                                        ctrl_c : Char;
                                        ctrl_d : Char;
                                        ctrl_e : Char;
                                        ctrl_f : Char;
                                        ctrl_g : Char;
                                        ctrl_h : Char;
                                        ctrl_i : Char;
                                        ctrl_j : Char;
                                        newline : Char;
                                        ctrl_k : Char;
                                        ctrl_l : Char;
                                        ctrl_m : Char;
                                        return : Char;
                                        ctrl_n : Char;
                                        ctrl_o : Char;
                                        ctrl_p : Char;
                                        ctrl_q : Char;
                                        ctrl_r : Char;
                                        ctrl_s : Char;
                                        ctrl_t : Char;
                                        ctrl_u : Char;
                                        ctrl_v : Char;
                                        ctrl_w : Char;
                                        ctrl_x : Char;
                                        ctrl_y : Char;
                                        ctrl_z : Char;
                                        del : Char;};;
                                package char_set
                                  : api {   package key
                                              : api {
                                                    Key  = char::Char;
                                                    compare : (Key , Key) -> Order;};;
                                        Item  = key::Key;
                                        Set;
                                        empty : Set;
                                        singleton : Item -> Set;
                                        from_list : List(Item ) -> Set;
                                        add : (Set , Item) -> Set;
                                        add' : (Item , Set) -> Set;
                                        add_list : (Set , List(Item )) -> Set;
                                        drop : (Set , Item) -> Set;
                                        member : (Set , Item) -> Bool;
                                        preceding_member : (Set , Item) -> Null_Or(Item );
                                        following_member : (Set , Item) -> Null_Or(Item );
                                        is_empty : Set -> Bool;
                                        equal : (Set , Set) -> Bool;
                                        compare : (Set , Set) -> Order;
                                        is_subset : (Set , Set) -> Bool;
                                        vals_count : Set -> Int;
                                        vals_list : Set -> List(Item );
                                        union : (Set , Set) -> Set;
                                        intersection : (Set , Set) -> Set;
                                        difference : (Set , Set) -> Set;
                                        map : (Item -> Item) -> Set -> Set;
                                        apply : (Item -> Void) -> Set -> Void;
                                        fold_forward : ((Item , X) -> X) -> X -> Set -> X;
                                        fold_backward : ((Item , X) -> X) -> X -> Set -> X;
                                        partition : (Item -> Bool) -> Set -> (Set , Set);
                                        filter : (Item -> Bool) -> Set -> Set;
                                        exists : (Item -> Bool) -> Set -> Bool;
                                        find : (Item -> Bool) -> Set -> Null_Or(Item );
                                        all_invariants_hold : Set -> Bool;};;
                                Abstract_Regular_Expression
                                = ALT
                                List(Abstract_Regular_Expression )
                                |
                                ASSIGN
                                (Int , (String -> String) , Abstract_Regular_Expression)
                                |
                                BACK_REF
                                ((String -> String) , Int)
                                |
                                BEGIN
                                |
                                BOUNDARY
                                {next:Null_Or(char::Char ), prev:Null_Or(char::Char ), this:Null_Or(char::Char )} -> Bool
                                |
                                CHAR
                                char::Char
                                |
                                CONCAT
                                List(Abstract_Regular_Expression )
                                |
                                END
                                |
                                GROUP
                                Abstract_Regular_Expression
                                |
                                GUARD
                                ((String -> Bool) , Abstract_Regular_Expression)
                                |
                                INTERVAL
                                (Abstract_Regular_Expression , Int , Null_Or(Int ))
                                |
                                MATCH_SET
                                char_set::Set
                                |
                                NONMATCH_SET
                                char_set::Set
                                |
                                OPTION
                                Abstract_Regular_Expression
                                |
                                PLUS
                                Abstract_Regular_Expression
                                |
                                STAR
                                Abstract_Regular_Expression;
                            add_range : (char_set::Set , char::Char , char::Char) -> char_set::Set;
                            all_chars : char_set::Set;};;
                    scan :
                    number_string::Reader((Char, X)) -> number_string::Reader((r::Abstract_Regular_Expression, X));};;
        package e
          : api {   package r
                      : api {
                            exception CANNOT_PARSE;
                            exception CANNOT_COMPILE;
                                package char
                                  : api {
                                        eqtype Char;
                                        eqtype String;
                                        from_int : Int -> Char;
                                        to_int : Char -> Int;
                                        min_char : Char;
                                        max_char : Char;
                                        max_ord : Int;
                                        prior : Char -> Char;
                                        next : Char -> Char;
                                        < : (Char , Char) -> Bool;
                                        <= : (Char , Char) -> Bool;
                                        > : (Char , Char) -> Bool;
                                        >= : (Char , Char) -> Bool;
                                        compare : (Char , Char) -> Order;
                                        scan : number_string::Reader((Char, X)) -> number_string::Reader((Char, X));
                                        from_string : string::String -> Null_Or(Char );
                                        to_string : Char -> string::String;
                                        from_cstring : string::String -> Null_Or(Char );
                                        to_cstring : Char -> string::String;
                                        contains : String -> Char -> Bool;
                                        not_contains : String -> Char -> Bool;
                                        is_lower : Char -> Bool;
                                        is_upper : Char -> Bool;
                                        is_digit : Char -> Bool;
                                        is_alpha : Char -> Bool;
                                        is_hex_digit : Char -> Bool;
                                        is_alphanumeric : Char -> Bool;
                                        is_print : Char -> Bool;
                                        is_space : Char -> Bool;
                                        is_punct : Char -> Bool;
                                        is_graph : Char -> Bool;
                                        is_cntrl : Char -> Bool;
                                        is_ascii : Char -> Bool;
                                        to_upper : Char -> Char;
                                        to_lower : Char -> Char;
                                        nul : Char;
                                        ctrl_a : Char;
                                        ctrl_b : Char;
                                        ctrl_c : Char;
                                        ctrl_d : Char;
                                        ctrl_e : Char;
                                        ctrl_f : Char;
                                        ctrl_g : Char;
                                        ctrl_h : Char;
                                        ctrl_i : Char;
                                        ctrl_j : Char;
                                        newline : Char;
                                        ctrl_k : Char;
                                        ctrl_l : Char;
                                        ctrl_m : Char;
                                        return : Char;
                                        ctrl_n : Char;
                                        ctrl_o : Char;
                                        ctrl_p : Char;
                                        ctrl_q : Char;
                                        ctrl_r : Char;
                                        ctrl_s : Char;
                                        ctrl_t : Char;
                                        ctrl_u : Char;
                                        ctrl_v : Char;
                                        ctrl_w : Char;
                                        ctrl_x : Char;
                                        ctrl_y : Char;
                                        ctrl_z : Char;
                                        del : Char;};;
                                package char_set
                                  : api {   package key
                                              : api {
                                                    Key  = char::Char;
                                                    compare : (Key , Key) -> Order;};;
                                        Item  = key::Key;
                                        Set;
                                        empty : Set;
                                        singleton : Item -> Set;
                                        from_list : List(Item ) -> Set;
                                        add : (Set , Item) -> Set;
                                        add' : (Item , Set) -> Set;
                                        add_list : (Set , List(Item )) -> Set;
                                        drop : (Set , Item) -> Set;
                                        member : (Set , Item) -> Bool;
                                        preceding_member : (Set , Item) -> Null_Or(Item );
                                        following_member : (Set , Item) -> Null_Or(Item );
                                        is_empty : Set -> Bool;
                                        equal : (Set , Set) -> Bool;
                                        compare : (Set , Set) -> Order;
                                        is_subset : (Set , Set) -> Bool;
                                        vals_count : Set -> Int;
                                        vals_list : Set -> List(Item );
                                        union : (Set , Set) -> Set;
                                        intersection : (Set , Set) -> Set;
                                        difference : (Set , Set) -> Set;
                                        map : (Item -> Item) -> Set -> Set;
                                        apply : (Item -> Void) -> Set -> Void;
                                        fold_forward : ((Item , X) -> X) -> X -> Set -> X;
                                        fold_backward : ((Item , X) -> X) -> X -> Set -> X;
                                        partition : (Item -> Bool) -> Set -> (Set , Set);
                                        filter : (Item -> Bool) -> Set -> Set;
                                        exists : (Item -> Bool) -> Set -> Bool;
                                        find : (Item -> Bool) -> Set -> Null_Or(Item );
                                        all_invariants_hold : Set -> Bool;};;
                                Abstract_Regular_Expression
                                = ALT
                                List(Abstract_Regular_Expression )
                                |
                                ASSIGN
                                (Int , (String -> String) , Abstract_Regular_Expression)
                                |
                                BACK_REF
                                ((String -> String) , Int)
                                |
                                BEGIN
                                |
                                BOUNDARY
                                {next:Null_Or(char::Char ), prev:Null_Or(char::Char ), this:Null_Or(char::Char )} -> Bool
                                |
                                CHAR
                                char::Char
                                |
                                CONCAT
                                List(Abstract_Regular_Expression )
                                |
                                END
                                |
                                GROUP
                                Abstract_Regular_Expression
                                |
                                GUARD
                                ((String -> Bool) , Abstract_Regular_Expression)
                                |
                                INTERVAL
                                (Abstract_Regular_Expression , Int , Null_Or(Int ))
                                |
                                MATCH_SET
                                char_set::Set
                                |
                                NONMATCH_SET
                                char_set::Set
                                |
                                OPTION
                                Abstract_Regular_Expression
                                |
                                PLUS
                                Abstract_Regular_Expression
                                |
                                STAR
                                Abstract_Regular_Expression;
                            add_range : (char_set::Set , char::Char , char::Char) -> char_set::Set;
                            all_chars : char_set::Set;};;
                Compiled_Regular_Expression;
                compile : r::Abstract_Regular_Expression -> Compiled_Regular_Expression;
                    find :
                        Compiled_Regular_Expression
                        ->
                        number_string::Reader((Char, X))
                        ->number_string::Reader(
                          (?.regex_match_result::Regex_Match_Result(Null_Or({match_length:Int, match_position:X} ) ), X));
                    prefix :
                        Compiled_Regular_Expression
                        ->
                        number_string::Reader((Char, X))
                        ->number_string::Reader(
                          (?.regex_match_result::Regex_Match_Result(Null_Or({match_length:Int, match_position:X} ) ), X));
                    match :
                          List(
                          ((    r::Abstract_Regular_Expression ,
                                (?.regex_match_result::Regex_Match_Result(Null_Or({match_length:Int, match_position:Y} ) ) -> X)
                          ))
                           )
                        ->
                        number_string::Reader((Char, Y)) -> number_string::Reader((X, Y));};;};
)
:
api {
    =~ : (String , String) -> Bool;
    find_first_match_to_ith_group : Int -> String -> String -> Null_Or(String );
    find_first_match_to_regex : String -> String -> Null_Or(String );
    find_first_match_to_regex_and_return_all_groups : String -> String -> Null_Or(List(String ) );
    find_all_matches_to_regex_and_return_values_of_ith_group : Int -> String -> String -> List(String );
        find_all_matches_to_regex_and_return_all_values_of_all_groups :
        String -> String -> List(List(String ) );
    find_all_matches_to_regex : String -> String -> List(String );
    matches : String -> String -> Bool;
    replace_first_via_fn : String -> (List(String ) -> String) -> String -> String;
    replace_all_via_fn : String -> (List(String ) -> String) -> String -> String;
    replace_first : String -> String -> String -> String;
    replace_all : String -> String -> String -> String;
    regex_case : String -> {cases:List(((String , (List(String ) -> X))) ), default:Void -> X} -> X;
    Compiled_Regular_Expression  = Compiled_Regular_Expression;
        compile :
        number_string::Reader((Char, X)) -> number_string::Reader((Compiled_Regular_Expression, X));
    compile_string : String -> Compiled_Regular_Expression;
        find :
            Compiled_Regular_Expression
            ->
            number_string::Reader((Char, X))
            ->number_string::Reader(
              (?.regex_match_result::Regex_Match_Result(Null_Or({match_length:Int, match_position:X} ) ), X));
        prefix :
            Compiled_Regular_Expression
            ->
            number_string::Reader((Char, X))
            ->number_string::Reader(
              (?.regex_match_result::Regex_Match_Result(Null_Or({match_length:Int, match_position:X} ) ), X));
        stream_match :
              List(
              ((    String ,
                    (?.regex_match_result::Regex_Match_Result(Null_Or({match_length:Int, match_position:Y} ) ) -> X)
              ))
               )
            ->
            number_string::Reader((Char, Y)) -> number_string::Reader((X, Y));};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(E95.8)
generic_closure:
CL:
parameter: #GLOBAL(E95.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(E95.5)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(E95.9)
                         src:syx::PACKAGE:
                                ed::S: #GLOBAL(E95.10) syx::CONSTANT_PACKAGE: <regex_match_result> m
                                ed::S: #GLOBAL(E95.11) syx::VARIABLE_PACKAGE: [#GLOBAL(E95.0), #GLOBAL(E95.2), #GLOBAL(843.1)] r
                                ed::T: #GLOBAL(E95.12) te::FM: ?.Compiled_Regular_Expression
                                    ed::S: #GLOBAL(E95.13)
                                        syx::PACKAGE_LET:
                                            stipulate:  ed::S: #GLOBAL(E95.14)
                                                            syx::APPLY:
                                                                fct:fe::CONSTANT_GENERIC:<>
                                                                arg:syx::COERCED_PACKAGE:
                                                                        #GLOBAL(E95.15)
                                                                         src:syx::PACKAGE:
                                                                         ed::T: #GLOBAL(E95.16) te::FM: ?.Hash_Key
                                                                        tgt:syx::PACKAGE:
                                                                         ed::T: #GLOBAL(838.1) te::V: [#GLOBAL(E95.15), #GLOBAL(E95.16)]
                                                         <return_package>
                                            herein:syx::VARIABLE_PACKAGE:
                                             [#GLOBAL(E95.14), #GLOBAL(F13.2)]
                                     sht
                            ed::S: #GLOBAL(E95.17)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(E95.0), #GLOBAL(E95.2), #GLOBAL(843.1)]
                             r
                            ed::S: #GLOBAL(E95.18)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(E95.14), #GLOBAL(F13.2)]
                             sht
                        tgt:syx::PACKAGE:
                         ed::T: #GLOBAL(DA4.1) te::V: [#GLOBAL(E95.9), #GLOBAL(E95.12)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic rw_vector_quicksort_g
:
a_generic_api:
(a:
api {
    eqtype Rw_Vector;
    Element;
    Vector;
    maximum_vector_length : Int;
    make_rw_vector : (Int , Element) -> Rw_Vector;
    from_list : List(Element ) -> Rw_Vector;
    from_fn : (Int , (Int -> Element)) -> Rw_Vector;
    length : Rw_Vector -> Int;
    get : (Rw_Vector , Int) -> Element;
    _[] : (Rw_Vector , Int) -> Element;
    set : (Rw_Vector , Int , Element) -> Void;
    _[]:= : (Rw_Vector , Int , Element) -> Void;
    to_vector : Rw_Vector -> Vector;
    copy : {at:Int, from:Rw_Vector, into:Rw_Vector} -> Void;
    copy_vector : {at:Int, from:Vector, into:Rw_Vector} -> Void;
    keyed_apply : ((Int , Element) -> Void) -> Rw_Vector -> Void;
    apply : (Element -> Void) -> Rw_Vector -> Void;
    keyed_map_in_place : ((Int , Element) -> Element) -> Rw_Vector -> Void;
    map_in_place : (Element -> Element) -> Rw_Vector -> Void;
    keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
    keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
    fold_forward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
    fold_backward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
    keyed_find : ((Int , Element) -> Bool) -> Rw_Vector -> Null_Or(((Int , Element)) );
    find : (Element -> Bool) -> Rw_Vector -> Null_Or(Element );
    exists : (Element -> Bool) -> Rw_Vector -> Bool;
    all : (Element -> Bool) -> Rw_Vector -> Bool;
    compare_sequences : ((Element , Element) -> Order) -> (Rw_Vector , Rw_Vector) -> Order;};
)
:
api {   package a
          : api {
                eqtype Rw_Vector;
                Element;
                Vector;
                maximum_vector_length : Int;
                make_rw_vector : (Int , Element) -> Rw_Vector;
                from_list : List(Element ) -> Rw_Vector;
                from_fn : (Int , (Int -> Element)) -> Rw_Vector;
                length : Rw_Vector -> Int;
                get : (Rw_Vector , Int) -> Element;
                _[] : (Rw_Vector , Int) -> Element;
                set : (Rw_Vector , Int , Element) -> Void;
                _[]:= : (Rw_Vector , Int , Element) -> Void;
                to_vector : Rw_Vector -> Vector;
                copy : {at:Int, from:Rw_Vector, into:Rw_Vector} -> Void;
                copy_vector : {at:Int, from:Vector, into:Rw_Vector} -> Void;
                keyed_apply : ((Int , Element) -> Void) -> Rw_Vector -> Void;
                apply : (Element -> Void) -> Rw_Vector -> Void;
                keyed_map_in_place : ((Int , Element) -> Element) -> Rw_Vector -> Void;
                map_in_place : (Element -> Element) -> Rw_Vector -> Void;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
                fold_forward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
                fold_backward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
                keyed_find : ((Int , Element) -> Bool) -> Rw_Vector -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Rw_Vector -> Null_Or(Element );
                exists : (Element -> Bool) -> Rw_Vector -> Bool;
                all : (Element -> Bool) -> Rw_Vector -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Rw_Vector , Rw_Vector) -> Order;};;
    sort : ((a::Element , a::Element) -> Order) -> a::Rw_Vector -> Void;
    sorted : ((a::Element , a::Element) -> Order) -> a::Rw_Vector -> Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(82B.3)
generic_closure:
CL:
parameter: #GLOBAL(82B.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(82B.2)
            syx::COERCED_PACKAGE:
                #GLOBAL(82B.4)
                 src:syx::PACKAGE:
                 ed::S: #GLOBAL(82B.5) syx::VARIABLE_PACKAGE: [#GLOBAL(82B.0)] a
                tgt:syx::PACKAGE:
                 ed::S: #GLOBAL(1A2.1) syx::VARIABLE_PACKAGE: [#GLOBAL(82B.4), #GLOBAL(82B.0)] a
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic thread_scheduler_control_g
:
a_generic_api:
(drv:
api {
    start_threadkit_driver : Void -> Void;
    wake_sleeping_threads_and_schedule_fd_io_and_harvest_dead_subprocesses__iu : Void -> Void;
    block_until_some_thread_becomes_runnable : Void -> Bool;
    stop_threadkit_driver : Void -> Void;};
)
:
api {
    start_up_thread_scheduler : (Void -> Void) -> Int;
    start_up_thread_scheduler' : time::Time -> (Void -> Void) -> Int;
    run_under_thread_scheduler : (Void -> X) -> Void;
    shut_down_thread_scheduler : Int -> X;
    spawn_to_disk : (String , ((String , List(String )) -> Int) , Null_Or(time::Time )) -> Void;
    When  = APP_SHUTDOWN | APP_STARTUP | COMPILER_STARTUP | THREADKIT_SHUTDOWN;
    when_to_string : When -> String;
        note_startup_or_shutdown_action :
        (String , List(When ) , (When -> Void)) -> Null_Or(((List(When ) , (When -> Void))) );
    forget_startup_or_shutdown_action : String -> Null_Or(((List(When ) , (When -> Void))) );
    exception NO_SUCH_ACTION;
    note_mailqueue : (String , Mailqueue(X )) -> Void;
    forget_mailqueue : String -> Void;
    note_mailslot : (String , Mailslot(X )) -> Void;
    forget_mailslot : String -> Void;
    note_imp : {at_shutdown:Void -> Void, at_startup:Void -> Void, name:String} -> Void;
    forget_imp : String -> Void;
    forget_all_mailslots_mailqueues_and_imps : Void -> Void;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(884.3)
generic_closure:
CL:
parameter: #GLOBAL(884.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(884.2)
            syx::COERCED_PACKAGE:
                #GLOBAL(884.4)
                 src:syx::PACKAGE:
                        ed::T: #GLOBAL(884.5)
                         te::C:
                         ?.run_at::When
                                ed::S: #GLOBAL(884.6) syx::CONSTANT_PACKAGE: <initialize_run_at> iss
                                    ed::S: #GLOBAL(884.7)
                                        syx::PACKAGE_LET:
                                            stipulate:  ed::S: #GLOBAL(884.8)
                                                            syx::APPLY:
                                                                fct:fe::CONSTANT_GENERIC:<>
                                                                arg:syx::COERCED_PACKAGE:
                                                                        #GLOBAL(884.9)
                                                                         src:syx::VARIABLE_PACKAGE:
                                                                         [#GLOBAL(884.0)]
                                                                        tgt:syx::VARIABLE_PACKAGE:
                                                                         [#GLOBAL(884.9)]
                                                         <return_package>
                                            herein:syx::VARIABLE_PACKAGE:
                                             [#GLOBAL(884.8), #GLOBAL(217.2)]
                                     bas
                            ed::T: #GLOBAL(884.10) te::FM: ?.Cmdt
                tgt:syx::PACKAGE:
                 ed::T: #GLOBAL(0C8.1) te::V: [#GLOBAL(884.4), #GLOBAL(884.5)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic threadkit_base_for_os_g
:
a_generic_api:
(drv:
api {
    start_threadkit_driver : Void -> Void;
    wake_sleeping_threads_and_schedule_fd_io_and_harvest_dead_subprocesses__iu : Void -> Void;
    block_until_some_thread_becomes_runnable : Void -> Bool;
    stop_threadkit_driver : Void -> Void;};
)
:
api {   wake_sleeping_threads_and_schedule_fd_io_and_harvest_dead_subprocesses__xu__fate :
        fate::Fate(Void );
    no_runnable_threads_left__fate : fate::Fate(Void );
    Pair (X, Y) = PAIR (X , Y);
        wrap_for_export :
        (((String , List(String )) -> Int) , Null_Or(time::Time )) -> Pair((String, List(String ))) -> Int;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(217.6)
generic_closure:
CL:
parameter: #GLOBAL(217.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(217.2)
            syx::COERCED_PACKAGE:
                #GLOBAL(217.7)
                 src:syx::PACKAGE:
                        ed::T: #GLOBAL(217.8) te::FM: ?.Pair
                        ed::T: #GLOBAL(217.9) te::FM: ?.Cmdt
                tgt:syx::PACKAGE:
                 ed::T: #GLOBAL(217.4) te::V: [#GLOBAL(217.7), #GLOBAL(217.8)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic traitful_graphtree_g
:
a_generic_api:
(<parameter>:
api {
    Graph_Info;
    Edge_Info;
    Node_Info;};
)
:
api {
    Traitful_Graph;
    Node;
    Edge;
    Graph_Info;
    Node_Info;
    Edge_Info;
    exception GRAPHTREE_ERROR String;
        Graph_Part
        = EDGE_PART
        Edge
        |
        GRAPH_PART
        Traitful_Graph
        |
        NODE_PART
        Node
        |
        PROTOEDGE_PART
        Traitful_Graph
        |
        PROTONODE_PART
        Traitful_Graph;
        make_graph :
                {info:Null_Or(Graph_Info ), make_default_edge_info:Void -> Edge_Info,
                make_default_graph_info:Void -> Graph_Info, make_default_node_info:Void -> Node_Info, name:String}
            ->
            Traitful_Graph;
    graph_name : Traitful_Graph -> String;
    node_name : Node -> String;
    node_count : Traitful_Graph -> Int;
    edge_count : Traitful_Graph -> Int;
    has_node : (Traitful_Graph , Node) -> Bool;
    has_edge : (Traitful_Graph , Edge) -> Bool;
    drop_node : (Traitful_Graph , Node) -> Void;
    drop_edge : (Traitful_Graph , Edge) -> Void;
    make_node : (Traitful_Graph , String , Null_Or(Node_Info )) -> Node;
    get_or_make_node : (Traitful_Graph , String , Null_Or(Node_Info )) -> Node;
    find_node : (Traitful_Graph , String) -> Null_Or(Node );
    nodes : Traitful_Graph -> List(Node );
    nodes_apply : (Node -> Void) -> Traitful_Graph -> Void;
    nodes_fold : ((Node , X) -> X) -> Traitful_Graph -> X -> X;
    make_edge : {graph:Traitful_Graph, head:Node, info:Null_Or(Edge_Info ), tail:Node} -> Edge;
    edges : Traitful_Graph -> List(Edge );
    in_edges : (Traitful_Graph , Node) -> List(Edge );
    out_edges : (Traitful_Graph , Node) -> List(Edge );
    in_edges_apply : (Edge -> Void) -> (Traitful_Graph , Node) -> Void;
    out_edges_apply : (Edge -> Void) -> (Traitful_Graph , Node) -> Void;
    head : Edge -> Node;
    tail : Edge -> Node;
    nodes_of : Edge -> {head:Node, tail:Node};
    make_subgraph : (Traitful_Graph , String , Null_Or(Graph_Info )) -> Traitful_Graph;
    find_subgraph : (Traitful_Graph , String) -> Null_Or(Traitful_Graph );
    get_trait : Graph_Part -> String -> Null_Or(String );
    set_trait : Graph_Part -> (String , String) -> Void;
    drop_trait : Graph_Part -> String -> Void;
    trait_apply : Graph_Part -> ((String , String) -> Void) -> Void;
    count_trait : Graph_Part -> Int;
    graph_info_of : Traitful_Graph -> Graph_Info;
    edge_info_of : Edge -> Edge_Info;
    node_info_of : Node -> Node_Info;
    eq_graph : (Traitful_Graph , Traitful_Graph) -> Bool;
    eq_node : (Node , Node) -> Bool;
    eq_edge : (Edge , Edge) -> Bool;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(601.10)
generic_closure:
CL:
parameter: #GLOBAL(601.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(601.9)
            syx::COERCED_PACKAGE:
                #GLOBAL(601.11)
                 src:syx::PACKAGE:
                        ed::T: #GLOBAL(601.12) te::FM: ?.Mapref
                        ed::T: #GLOBAL(601.13) te::FM: ?.User_Node_Info
                        ed::T: #GLOBAL(601.14) te::FM: ?.User_Edge_Info
                        ed::T: #GLOBAL(601.15) te::FM: ?.User_Graph_Info
                        ed::T: #GLOBAL(601.16) te::FM: ?.Node_Info
                        ed::T: #GLOBAL(601.17) te::FM: ?.Edge_Info
                        ed::T: #GLOBAL(601.18) te::FM: ?.Graph_Info
                            ed::S: #GLOBAL(601.19)
                                syx::PACKAGE_LET:
                                    stipulate:  ed::S: #GLOBAL(601.20)
                                                    syx::APPLY:
                                                        fct:fe::CONSTANT_GENERIC:<>
                                                        arg:syx::COERCED_PACKAGE:
                                                                #GLOBAL(601.21)
                                                                 src:syx::PACKAGE:
                                                                        ed::T: #GLOBAL(601.22) te::FM: ?.Edge_Info
                                                                        ed::T: #GLOBAL(601.23) te::FM: ?.Node_Info
                                                                        ed::T: #GLOBAL(601.24) te::FM: ?.Graph_Info
                                                                tgt:syx::PACKAGE:
                                                                    ed::T: #GLOBAL(7F9.2)
                                                                     te::V:
                                                                     [#GLOBAL(601.21), #GLOBAL(601.24)]
                                                                    ed::T: #GLOBAL(7F9.3)
                                                                     te::V:
                                                                     [#GLOBAL(601.21), #GLOBAL(601.22)]
                                                                    ed::T: #GLOBAL(7F9.4)
                                                                     te::V:
                                                                     [#GLOBAL(601.21), #GLOBAL(601.23)]
                                                 <return_package>
                                    herein:syx::VARIABLE_PACKAGE:
                                     [#GLOBAL(601.20), #GLOBAL(7F9.9)]
                             g
                        ed::T: #GLOBAL(601.25) te::FM: ?.Node
                        ed::T: #GLOBAL(601.26) te::FM: ?.Edge
                            ed::T: #GLOBAL(601.27) te::FM: ?.Traitful_Graph
                            ed::T: #GLOBAL(601.28) te::FM: ?.Graphtree
                        ed::T: #GLOBAL(601.29) te::FM: ?.Graph_Part
                        ed::T: #GLOBAL(601.30) te::FM: ?.Node_Info
                        ed::T: #GLOBAL(601.31) te::FM: ?.Edge_Info
                        ed::T: #GLOBAL(601.32) te::FM: ?.Graph_Info
                    ed::T: #GLOBAL(601.33)
                     te::V:
                     [#GLOBAL(601.20), #GLOBAL(7F9.11), #GLOBAL(7F9.21)]
                    ed::S: #GLOBAL(601.34)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(601.20), #GLOBAL(7F9.9)]
                     g
                tgt:syx::PACKAGE:
                    ed::T: #GLOBAL(C16.1)
                     te::V:
                     [#GLOBAL(601.11), #GLOBAL(601.27)]
                    ed::T: #GLOBAL(C16.2)
                     te::V:
                     [#GLOBAL(601.11), #GLOBAL(601.25)]
                    ed::T: #GLOBAL(C16.3)
                     te::V:
                     [#GLOBAL(601.11), #GLOBAL(601.26)]
                    ed::T: #GLOBAL(C16.4)
                     te::V:
                     [#GLOBAL(601.11), #GLOBAL(601.32)]
                    ed::T: #GLOBAL(C16.5)
                     te::V:
                     [#GLOBAL(601.11), #GLOBAL(601.30)]
                    ed::T: #GLOBAL(C16.6)
                     te::V:
                     [#GLOBAL(601.11), #GLOBAL(601.31)]
                    ed::T: #GLOBAL(C16.7)
                     te::V:
                     [#GLOBAL(601.11), #GLOBAL(601.29)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic typelocked_double_keyed_typelocked_hashtable_g
:
a_generic_api:
(<parameter>:
api {   package key1
          : api {
                Hash_Key;
                hash_value : Hash_Key -> Unt;
                same_key : (Hash_Key , Hash_Key) -> Bool;};;
        package key2
          : api {
                Hash_Key;
                hash_value : Hash_Key -> Unt;
                same_key : (Hash_Key , Hash_Key) -> Bool;};;};
)
:
api {   package key1
          : api {
                Hash_Key;
                hash_value : Hash_Key -> Unt;
                same_key : (Hash_Key , Hash_Key) -> Bool;};;
        package key2
          : api {
                Hash_Key;
                hash_value : Hash_Key -> Unt;
                same_key : (Hash_Key , Hash_Key) -> Bool;};;
    Hashtable X;
    make_hashtable : (Int , Exception) -> Hashtable(X );
    clear : Hashtable(X ) -> Void;
    set : Hashtable(X ) -> (key1::Hash_Key , key2::Hash_Key , X) -> Void;
    in_domain1 : Hashtable(X ) -> key1::Hash_Key -> Bool;
    in_domain2 : Hashtable(X ) -> key2::Hash_Key -> Bool;
    get1 : Hashtable(X ) -> key1::Hash_Key -> X;
    get2 : Hashtable(X ) -> key2::Hash_Key -> X;
    find1 : Hashtable(X ) -> key1::Hash_Key -> Null_Or(X );
    find2 : Hashtable(X ) -> key2::Hash_Key -> Null_Or(X );
    remove1 : Hashtable(X ) -> key1::Hash_Key -> X;
    remove2 : Hashtable(X ) -> key2::Hash_Key -> X;
    vals_count : Hashtable(X ) -> Int;
    vals_list : Hashtable(X ) -> List(X );
    keyvals_list : Hashtable(X ) -> List(((key1::Hash_Key , key2::Hash_Key , X)) );
    apply : (X -> Void) -> Hashtable(X ) -> Void;
    keyed_apply : ((key1::Hash_Key , key2::Hash_Key , X) -> Void) -> Hashtable(X ) -> Void;
    map : (X -> Y) -> Hashtable(X ) -> Hashtable(Y );
    keyed_map : ((key1::Hash_Key , key2::Hash_Key , X) -> Y) -> Hashtable(X ) -> Hashtable(Y );
    fold : ((X , Y) -> Y) -> Y -> Hashtable(X ) -> Y;
    foldi : ((key1::Hash_Key , key2::Hash_Key , X , Y) -> Y) -> Y -> Hashtable(X ) -> Y;
    filter : (X -> Bool) -> Hashtable(X ) -> Void;
    keyed_filter : ((key1::Hash_Key , key2::Hash_Key , X) -> Bool) -> Hashtable(X ) -> Void;
    copy : Hashtable(X ) -> Hashtable(X );
    bucket_sizes : Hashtable(X ) -> (List(Int ) , List(Int ));};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(0CC.6)
generic_closure:
CL:
parameter: #GLOBAL(0CC.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(0CC.5)
            syx::COERCED_PACKAGE:
                #GLOBAL(0CC.7)
                 src:syx::PACKAGE:
                        ed::S: #GLOBAL(0CC.8) syx::VARIABLE_PACKAGE: [#GLOBAL(0CC.0), #GLOBAL(0CC.2)] key1
                        ed::S: #GLOBAL(0CC.9) syx::VARIABLE_PACKAGE: [#GLOBAL(0CC.0), #GLOBAL(0CC.3)] key2
                        ed::S: #GLOBAL(0CC.10) syx::CONSTANT_PACKAGE: <hashtable_representation> htrep
                        ed::T: #GLOBAL(0CC.11) te::FM: ?.Hashtable
                    ed::S: #GLOBAL(0CC.12)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(0CC.0), #GLOBAL(0CC.2)]
                     key1
                    ed::S: #GLOBAL(0CC.13)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(0CC.0), #GLOBAL(0CC.3)]
                     key2
                tgt:syx::PACKAGE:
                    ed::S: #GLOBAL(79D.1)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(0CC.7), #GLOBAL(0CC.12)]
                     key1
                    ed::S: #GLOBAL(79D.2)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(0CC.7), #GLOBAL(0CC.13)]
                     key2
                    ed::T: #GLOBAL(79D.3)
                     te::V:
                     [#GLOBAL(0CC.7), #GLOBAL(0CC.11)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic typelocked_hashtable_g
:
a_generic_api:
(key:
api {
    Hash_Key;
    hash_value : Hash_Key -> Unt;
    same_key : (Hash_Key , Hash_Key) -> Bool;};
)
:
api {   package key
          : api {
                Hash_Key;
                hash_value : Hash_Key -> Unt;
                same_key : (Hash_Key , Hash_Key) -> Bool;};;
    Hashtable X;
    make_hashtable : {not_found_exception:Exception, size_hint:Int} -> Hashtable(X );
    clear : Hashtable(X ) -> Void;
    set : Hashtable(X ) -> (key::Hash_Key , X) -> Void;
    contains_key : Hashtable(X ) -> key::Hash_Key -> Bool;
    get : Hashtable(X ) -> key::Hash_Key -> X;
    find : Hashtable(X ) -> key::Hash_Key -> Null_Or(X );
    drop : Hashtable(X ) -> key::Hash_Key -> Void;
    get_and_drop : Hashtable(X ) -> key::Hash_Key -> Null_Or(X );
    vals_count : Hashtable(X ) -> Int;
    vals_list : Hashtable(X ) -> List(X );
    keyvals_list : Hashtable(X ) -> List(((key::Hash_Key , X)) );
    apply : (X -> Void) -> Hashtable(X ) -> Void;
    keyed_apply : ((key::Hash_Key , X) -> Void) -> Hashtable(X ) -> Void;
    map : (X -> Y) -> Hashtable(X ) -> Hashtable(Y );
    keyed_map : ((key::Hash_Key , X) -> Y) -> Hashtable(X ) -> Hashtable(Y );
    fold : ((X , Y) -> Y) -> Y -> Hashtable(X ) -> Y;
    foldi : ((key::Hash_Key , X , Y) -> Y) -> Y -> Hashtable(X ) -> Y;
    map_in_place : (X -> X) -> Hashtable(X ) -> Void;
    keyed_map_in_place : ((key::Hash_Key , X) -> X) -> Hashtable(X ) -> Void;
    filter : (X -> Bool) -> Hashtable(X ) -> Void;
    keyed_filter : ((key::Hash_Key , X) -> Bool) -> Hashtable(X ) -> Void;
    copy : Hashtable(X ) -> Hashtable(X );
    bucket_sizes : Hashtable(X ) -> List(Int );};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(F13.3)
generic_closure:
CL:
parameter: #GLOBAL(F13.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(F13.2)
            syx::COERCED_PACKAGE:
                #GLOBAL(F13.4)
                 src:syx::PACKAGE:
                        ed::S: #GLOBAL(F13.5) syx::VARIABLE_PACKAGE: [#GLOBAL(F13.0)] key
                        ed::T: #GLOBAL(F13.6) te::FM: ?.Hashtable
                    ed::T: #GLOBAL(F13.7)
                     te::V:
                     [#GLOBAL(F13.0), #GLOBAL(838.1)]
                tgt:syx::PACKAGE:
                    ed::S: #GLOBAL(255.1)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(F13.4), #GLOBAL(F13.0)]
                     key
                    ed::T: #GLOBAL(255.2)
                     te::V:
                     [#GLOBAL(F13.4), #GLOBAL(F13.6)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic typelocked_rw_vector_g
:
a_generic_api:
(<parameter>:
api {
    Element;};
)
:
api {
    eqtype Rw_Vector;
    Element  = Element;
    Vector;
    maximum_vector_length : Int;
    make_rw_vector : (Int , Element) -> Rw_Vector;
    from_list : List(Element ) -> Rw_Vector;
    from_fn : (Int , (Int -> Element)) -> Rw_Vector;
    length : Rw_Vector -> Int;
    get : (Rw_Vector , Int) -> Element;
    _[] : (Rw_Vector , Int) -> Element;
    set : (Rw_Vector , Int , Element) -> Void;
    _[]:= : (Rw_Vector , Int , Element) -> Void;
    to_vector : Rw_Vector -> Vector;
    copy : {at:Int, from:Rw_Vector, into:Rw_Vector} -> Void;
    copy_vector : {at:Int, from:Vector, into:Rw_Vector} -> Void;
    keyed_apply : ((Int , Element) -> Void) -> Rw_Vector -> Void;
    apply : (Element -> Void) -> Rw_Vector -> Void;
    keyed_map_in_place : ((Int , Element) -> Element) -> Rw_Vector -> Void;
    map_in_place : (Element -> Element) -> Rw_Vector -> Void;
    keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
    keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
    fold_forward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
    fold_backward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
    keyed_find : ((Int , Element) -> Bool) -> Rw_Vector -> Null_Or(((Int , Element)) );
    find : (Element -> Bool) -> Rw_Vector -> Null_Or(Element );
    exists : (Element -> Bool) -> Rw_Vector -> Bool;
    all : (Element -> Bool) -> Rw_Vector -> Bool;
    compare_sequences : ((Element , Element) -> Order) -> (Rw_Vector , Rw_Vector) -> Order;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(35A.8)
generic_closure:
CL:
parameter: #GLOBAL(35A.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(35A.5)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(35A.9)
                         src:syx::PACKAGE:
                                ed::T: #GLOBAL(35A.10) te::FM: ?.Element
                                ed::T: #GLOBAL(35A.11) te::FM: ?.Rw_Vector
                                ed::T: #GLOBAL(35A.12) te::FM: ?.Vector
                        tgt:syx::PACKAGE:
                            ed::T: #GLOBAL(FDA.1)
                             te::V:
                             [#GLOBAL(35A.9), #GLOBAL(35A.11)]
                            ed::T: #GLOBAL(FDA.2)
                             te::V:
                             [#GLOBAL(35A.9), #GLOBAL(35A.10)]
                            ed::T: #GLOBAL(FDA.3)
                             te::V:
                             [#GLOBAL(35A.9), #GLOBAL(35A.12)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic winix_base_file_io_driver_for_posix_g
:
a_generic_api:
(<parameter>:
api {   package rv
          : api {
                Vector;
                Element;
                maximum_vector_length : Int;
                from_list : List(Element ) -> Vector;
                from_fn : (Int , (Int -> Element)) -> Vector;
                length : Vector -> Int;
                cat : List(Vector ) -> Vector;
                get : (Vector , Int) -> Element;
                _[] : (Vector , Int) -> Element;
                set : (Vector , Int , Element) -> Vector;
                _[]:= : (Vector , Int , Element) -> Vector;
                keyed_apply : ((Int , Element) -> Void) -> Vector -> Void;
                apply : (Element -> Void) -> Vector -> Void;
                keyed_map : ((Int , Element) -> Element) -> Vector -> Vector;
                map : (Element -> Element) -> Vector -> Vector;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Vector -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Vector -> X;
                fold_forward : ((Element , X) -> X) -> X -> Vector -> X;
                fold_backward : ((Element , X) -> X) -> X -> Vector -> X;
                keyed_find : ((Int , Element) -> Bool) -> Vector -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Vector -> Null_Or(Element );
                exists : (Element -> Bool) -> Vector -> Bool;
                all : (Element -> Bool) -> Vector -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Vector , Vector) -> Order;};;
        package wv
          : api {
                eqtype Rw_Vector;
                Element;
                Vector;
                maximum_vector_length : Int;
                make_rw_vector : (Int , Element) -> Rw_Vector;
                from_list : List(Element ) -> Rw_Vector;
                from_fn : (Int , (Int -> Element)) -> Rw_Vector;
                length : Rw_Vector -> Int;
                get : (Rw_Vector , Int) -> Element;
                _[] : (Rw_Vector , Int) -> Element;
                set : (Rw_Vector , Int , Element) -> Void;
                _[]:= : (Rw_Vector , Int , Element) -> Void;
                to_vector : Rw_Vector -> Vector;
                copy : {at:Int, from:Rw_Vector, into:Rw_Vector} -> Void;
                copy_vector : {at:Int, from:Vector, into:Rw_Vector} -> Void;
                keyed_apply : ((Int , Element) -> Void) -> Rw_Vector -> Void;
                apply : (Element -> Void) -> Rw_Vector -> Void;
                keyed_map_in_place : ((Int , Element) -> Element) -> Rw_Vector -> Void;
                map_in_place : (Element -> Element) -> Rw_Vector -> Void;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
                fold_forward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
                fold_backward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
                keyed_find : ((Int , Element) -> Bool) -> Rw_Vector -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Rw_Vector -> Null_Or(Element );
                exists : (Element -> Bool) -> Rw_Vector -> Bool;
                all : (Element -> Bool) -> Rw_Vector -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Rw_Vector , Rw_Vector) -> Order;};;
        package rvs
          : api {
                Element;
                Vector;
                Slice;
                length : Slice -> Int;
                get : (Slice , Int) -> Element;
                make_full_slice : Vector -> Slice;
                make_slice : (Vector , Int , Null_Or(Int )) -> Slice;
                make_subslice : (Slice , Int , Null_Or(Int )) -> Slice;
                burst_slice : Slice -> (Vector , Int , Int);
                to_vector : Slice -> Vector;
                cat : List(Slice ) -> Vector;
                is_empty : Slice -> Bool;
                get_item : Slice -> Null_Or(((Element , Slice)) );
                keyed_apply : ((Int , Element) -> Void) -> Slice -> Void;
                apply : (Element -> Void) -> Slice -> Void;
                keyed_map : ((Int , Element) -> Element) -> Slice -> Vector;
                map : (Element -> Element) -> Slice -> Vector;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                fold_forward : ((Element , X) -> X) -> X -> Slice -> X;
                fold_backward : ((Element , X) -> X) -> X -> Slice -> X;
                keyed_find : ((Int , Element) -> Bool) -> Slice -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Slice -> Null_Or(Element );
                exists : (Element -> Bool) -> Slice -> Bool;
                all : (Element -> Bool) -> Slice -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Slice , Slice) -> Order;};;
        package wvs
          : api {
                Element;
                Vector;
                Rw_Vector;
                Slice;
                Vector_Slice;
                length : Slice -> Int;
                get : (Slice , Int) -> Element;
                set : (Slice , Int , Element) -> Void;
                _[] : (Slice , Int) -> Element;
                _[]:= : (Slice , Int , Element) -> Void;
                make_full_slice : Rw_Vector -> Slice;
                make_slice : (Rw_Vector , Int , Null_Or(Int )) -> Slice;
                make_subslice : (Slice , Int , Null_Or(Int )) -> Slice;
                burst_slice : Slice -> (Rw_Vector , Int , Int);
                to_vector : Slice -> Vector;
                copy : {at:Int, from:Slice, into:Rw_Vector} -> Void;
                copy_vector : {at:Int, from:Vector_Slice, into:Rw_Vector} -> Void;
                is_empty : Slice -> Bool;
                get_item : Slice -> Null_Or(((Element , Slice)) );
                keyed_apply : ((Int , Element) -> Void) -> Slice -> Void;
                apply : (Element -> Void) -> Slice -> Void;
                map_in_place : (Element -> Element) -> Slice -> Void;
                keyed_map_in_place : ((Int , Element) -> Element) -> Slice -> Void;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                fold_forward : ((Element , X) -> X) -> X -> Slice -> X;
                fold_backward : ((Element , X) -> X) -> X -> Slice -> X;
                keyed_find : ((Int , Element) -> Bool) -> Slice -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Slice -> Null_Or(Element );
                exists : (Element -> Bool) -> Slice -> Bool;
                all : (Element -> Bool) -> Slice -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Slice , Slice) -> Order;};;
    some_element : rv::Element;
    eqtype File_Position;
    compare : (File_Position , File_Position) -> Order;
    sharing rvs::Slice = wvs::Vector_Slice
    sharing wvs::Element = rvs::Element = wv::Element = rv::Element
    sharing wvs::Vector = rvs::Vector = wv::Vector = rv::Vector};
)
:
api {
    Mailop X = Mailop(X );
    Rw_Vector;
    Vector;
    Element;
    Vector_Slice;
    Rw_Vector_Slice;
    eqtype File_Position;
    compare : (File_Position , File_Position) -> Order;
        Filereader
        = FILEREADER        {avail:Void -> Null_Or(Int ), best_io_quantum:Int, close:Void -> Void,
                            end_file_position:Null_Or((Void -> File_Position) ), filename:String,
                            get_file_position:Null_Or((Void -> File_Position) ), io_descriptor:Null_Or(Int ),
                            read_vector:Int -> Vector, read_vector_mailop:Int -> Mailop(Vector ),
                            set_file_position:Null_Or((File_Position -> Void) ),
                            verify_file_position:Null_Or((Void -> File_Position) )};
        Filewriter
        = FILEWRITER
                {best_io_quantum:Int, close:Void -> Void, end_file_position:Null_Or((Void -> File_Position) ),
                filename:String, get_file_position:Null_Or((Void -> File_Position) ), io_descriptor:Null_Or(Int ),
                set_file_position:Null_Or((File_Position -> Void) ),
                verify_file_position:Null_Or((Void -> File_Position) ), write_rw_vector:Rw_Vector_Slice -> Int,
                write_rw_vector_mailop:Rw_Vector_Slice -> Mailop(Int ), write_vector:Vector_Slice -> Int,
                write_vector_mailop:Vector_Slice -> Mailop(Int )};};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(510.10)
generic_closure:
CL:
parameter: #GLOBAL(510.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(510.9)
            syx::COERCED_PACKAGE:
                #GLOBAL(510.11)
                 src:syx::PACKAGE:
                        ed::T: #GLOBAL(510.12) te::FM: ?.Mailop
                        ed::T: #GLOBAL(510.13) te::FM: ?.Element
                        ed::T: #GLOBAL(510.14) te::FM: ?.Vector
                        ed::T: #GLOBAL(510.15) te::FM: ?.Rw_Vector
                        ed::T: #GLOBAL(510.16) te::FM: ?.Rw_Vector_Slice
                        ed::T: #GLOBAL(510.17) te::FM: ?.Vector_Slice
                        ed::T: #GLOBAL(510.18) te::FM: ?.File_Position
                        ed::T: #GLOBAL(510.19) te::FM: ?.Filereader
                        ed::T: #GLOBAL(510.20) te::FM: ?.Filewriter
                tgt:syx::PACKAGE:
                    ed::T: #GLOBAL(069.1)
                     te::V:
                     [#GLOBAL(510.11), #GLOBAL(510.12)]
                    ed::T: #GLOBAL(069.2)
                     te::V:
                     [#GLOBAL(510.11), #GLOBAL(510.15)]
                    ed::T: #GLOBAL(069.3)
                     te::V:
                     [#GLOBAL(510.11), #GLOBAL(510.14)]
                    ed::T: #GLOBAL(069.4)
                     te::V:
                     [#GLOBAL(510.11), #GLOBAL(510.13)]
                    ed::T: #GLOBAL(069.5)
                     te::V:
                     [#GLOBAL(510.11), #GLOBAL(510.17)]
                    ed::T: #GLOBAL(069.6)
                     te::V:
                     [#GLOBAL(510.11), #GLOBAL(510.16)]
                    ed::T: #GLOBAL(069.7)
                     te::V:
                     [#GLOBAL(510.11), #GLOBAL(510.18)]
                    ed::T: #GLOBAL(069.8)
                     te::V:
                     [#GLOBAL(510.11), #GLOBAL(510.19)]
                    ed::T: #GLOBAL(069.9)
                     te::V:
                     [#GLOBAL(510.11), #GLOBAL(510.20)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic winix_base_file_io_driver_for_posix_g__premicrothread
:
a_generic_api:
(<parameter>:
api {   package vector
          : api {
                Vector;
                Element;
                maximum_vector_length : Int;
                from_list : List(Element ) -> Vector;
                from_fn : (Int , (Int -> Element)) -> Vector;
                length : Vector -> Int;
                cat : List(Vector ) -> Vector;
                get : (Vector , Int) -> Element;
                _[] : (Vector , Int) -> Element;
                set : (Vector , Int , Element) -> Vector;
                _[]:= : (Vector , Int , Element) -> Vector;
                keyed_apply : ((Int , Element) -> Void) -> Vector -> Void;
                apply : (Element -> Void) -> Vector -> Void;
                keyed_map : ((Int , Element) -> Element) -> Vector -> Vector;
                map : (Element -> Element) -> Vector -> Vector;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Vector -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Vector -> X;
                fold_forward : ((Element , X) -> X) -> X -> Vector -> X;
                fold_backward : ((Element , X) -> X) -> X -> Vector -> X;
                keyed_find : ((Int , Element) -> Bool) -> Vector -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Vector -> Null_Or(Element );
                exists : (Element -> Bool) -> Vector -> Bool;
                all : (Element -> Bool) -> Vector -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Vector , Vector) -> Order;};;
        package vector_slice
          : api {
                Element;
                Vector;
                Slice;
                length : Slice -> Int;
                get : (Slice , Int) -> Element;
                make_full_slice : Vector -> Slice;
                make_slice : (Vector , Int , Null_Or(Int )) -> Slice;
                make_subslice : (Slice , Int , Null_Or(Int )) -> Slice;
                burst_slice : Slice -> (Vector , Int , Int);
                to_vector : Slice -> Vector;
                cat : List(Slice ) -> Vector;
                is_empty : Slice -> Bool;
                get_item : Slice -> Null_Or(((Element , Slice)) );
                keyed_apply : ((Int , Element) -> Void) -> Slice -> Void;
                apply : (Element -> Void) -> Slice -> Void;
                keyed_map : ((Int , Element) -> Element) -> Slice -> Vector;
                map : (Element -> Element) -> Slice -> Vector;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                fold_forward : ((Element , X) -> X) -> X -> Slice -> X;
                fold_backward : ((Element , X) -> X) -> X -> Slice -> X;
                keyed_find : ((Int , Element) -> Bool) -> Slice -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Slice -> Null_Or(Element );
                exists : (Element -> Bool) -> Slice -> Bool;
                all : (Element -> Bool) -> Slice -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Slice , Slice) -> Order;};;
        package rw_vector
          : api {
                eqtype Rw_Vector;
                Element;
                Vector;
                maximum_vector_length : Int;
                make_rw_vector : (Int , Element) -> Rw_Vector;
                from_list : List(Element ) -> Rw_Vector;
                from_fn : (Int , (Int -> Element)) -> Rw_Vector;
                length : Rw_Vector -> Int;
                get : (Rw_Vector , Int) -> Element;
                _[] : (Rw_Vector , Int) -> Element;
                set : (Rw_Vector , Int , Element) -> Void;
                _[]:= : (Rw_Vector , Int , Element) -> Void;
                to_vector : Rw_Vector -> Vector;
                copy : {at:Int, from:Rw_Vector, into:Rw_Vector} -> Void;
                copy_vector : {at:Int, from:Vector, into:Rw_Vector} -> Void;
                keyed_apply : ((Int , Element) -> Void) -> Rw_Vector -> Void;
                apply : (Element -> Void) -> Rw_Vector -> Void;
                keyed_map_in_place : ((Int , Element) -> Element) -> Rw_Vector -> Void;
                map_in_place : (Element -> Element) -> Rw_Vector -> Void;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
                fold_forward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
                fold_backward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
                keyed_find : ((Int , Element) -> Bool) -> Rw_Vector -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Rw_Vector -> Null_Or(Element );
                exists : (Element -> Bool) -> Rw_Vector -> Bool;
                all : (Element -> Bool) -> Rw_Vector -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Rw_Vector , Rw_Vector) -> Order;};;
        package rw_vector_slice
          : api {
                Element;
                Vector;
                Rw_Vector;
                Slice;
                Vector_Slice;
                length : Slice -> Int;
                get : (Slice , Int) -> Element;
                set : (Slice , Int , Element) -> Void;
                _[] : (Slice , Int) -> Element;
                _[]:= : (Slice , Int , Element) -> Void;
                make_full_slice : Rw_Vector -> Slice;
                make_slice : (Rw_Vector , Int , Null_Or(Int )) -> Slice;
                make_subslice : (Slice , Int , Null_Or(Int )) -> Slice;
                burst_slice : Slice -> (Rw_Vector , Int , Int);
                to_vector : Slice -> Vector;
                copy : {at:Int, from:Slice, into:Rw_Vector} -> Void;
                copy_vector : {at:Int, from:Vector_Slice, into:Rw_Vector} -> Void;
                is_empty : Slice -> Bool;
                get_item : Slice -> Null_Or(((Element , Slice)) );
                keyed_apply : ((Int , Element) -> Void) -> Slice -> Void;
                apply : (Element -> Void) -> Slice -> Void;
                map_in_place : (Element -> Element) -> Slice -> Void;
                keyed_map_in_place : ((Int , Element) -> Element) -> Slice -> Void;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                fold_forward : ((Element , X) -> X) -> X -> Slice -> X;
                fold_backward : ((Element , X) -> X) -> X -> Slice -> X;
                keyed_find : ((Int , Element) -> Bool) -> Slice -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Slice -> Null_Or(Element );
                exists : (Element -> Bool) -> Slice -> Bool;
                all : (Element -> Bool) -> Slice -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Slice , Slice) -> Order;};;
    eqtype File_Position;
    some_element : vector::Element;
    compare : (File_Position , File_Position) -> Order;
    sharing rw_vector_slice::Rw_Vector = rw_vector::Rw_Vector
    sharing rw_vector_slice::Vector_Slice = vector_slice::Slice
    sharing rw_vector_slice::Vector = rw_vector::Vector = vector_slice::Vector = vector::Vector
    sharing rw_vector_slice::Element = rw_vector::Element = vector_slice::Element = vector::Element};
)
:
api {
    Element  = Element;
    Vector  = Vector;
    Vector_Slice  = Vector_Slice;
    Rw_Vector  = Rw_Vector;
    Rw_Vector_Slice  = Slice;
    File_Position  = File_Position;
    compare : (File_Position , File_Position) -> Order;
        Filereader
        = FILEREADER        {avail:Void -> Null_Or(Int ), best_io_quantum:Int, blockx:Null_Or((Void -> Void) ),
                            can_readx:Null_Or((Void -> Bool) ), close:Void -> Void,
                            end_file_position:Null_Or((Void -> File_Position) ), filename:String,
                            get_file_position:Null_Or((Void -> File_Position) ), io_descriptor:Null_Or(Int ),
                            read_vector:Int -> Vector, set_file_position:Null_Or((File_Position -> Void) ),
                            verify_file_position:Null_Or((Void -> File_Position) )};
        Filewriter
        = FILEWRITER
                {best_io_quantum:Int, blockx:Null_Or((Void -> Void) ), can_output:Null_Or((Void -> Bool) ),
                close:Void -> Void, end_file_position:Null_Or((Void -> File_Position) ), filename:String,
                get_file_position:Null_Or((Void -> File_Position) ), io_descriptor:Null_Or(Int ),
                set_file_position:Null_Or((File_Position -> Void) ),
                verify_file_position:Null_Or((Void -> File_Position) ),
                write_rw_vector:Null_Or((Rw_Vector_Slice -> Int) ), write_vector:Null_Or((Vector_Slice -> Int) )};
    open_vector : Vector -> Filereader;
    null_reader : Void -> Filereader;
    null_writer : Void -> Filewriter;
    augment_reader : Filereader -> Filereader;
    augment_writer : Filewriter -> Filewriter;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(4B0.17)
generic_closure:
CL:
parameter: #GLOBAL(4B0.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(4B0.9)
            syx::ABSTRACT_PACKAGE:
                an_api: <omitted>
                sexp:
                    syx::COERCED_PACKAGE:
                        #GLOBAL(4B0.18)
                         src:syx::PACKAGE:
                                ed::S: #GLOBAL(4B0.19) syx::VARIABLE_PACKAGE: [#GLOBAL(4B0.0), #GLOBAL(4B0.4)] wv
                                ed::S: #GLOBAL(4B0.20) syx::VARIABLE_PACKAGE: [#GLOBAL(4B0.0), #GLOBAL(4B0.5)] wvs
                                ed::S: #GLOBAL(4B0.21) syx::VARIABLE_PACKAGE: [#GLOBAL(4B0.0), #GLOBAL(4B0.2)] rv
                                ed::S: #GLOBAL(4B0.22) syx::VARIABLE_PACKAGE: [#GLOBAL(4B0.0), #GLOBAL(4B0.3)] rvs
                                ed::T: #GLOBAL(4B0.23) te::FM: ?.Element
                                ed::T: #GLOBAL(4B0.24) te::FM: ?.Vector
                                ed::T: #GLOBAL(4B0.25) te::FM: ?.Vector_Slice
                                ed::T: #GLOBAL(4B0.26) te::FM: ?.Rw_Vector
                                ed::T: #GLOBAL(4B0.27) te::FM: ?.Rw_Vector_Slice
                                ed::T: #GLOBAL(4B0.28) te::FM: ?.File_Position
                                ed::T: #GLOBAL(4B0.29) te::FM: ?.Filereader
                                ed::T: #GLOBAL(4B0.30) te::FM: ?.Filewriter
                            ed::S: #GLOBAL(4B0.31)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(4B0.0), #GLOBAL(4B0.2)]
                             rv
                            ed::S: #GLOBAL(4B0.32)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(4B0.0), #GLOBAL(4B0.3)]
                             rvs
                            ed::S: #GLOBAL(4B0.33)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(4B0.0), #GLOBAL(4B0.4)]
                             wv
                            ed::S: #GLOBAL(4B0.34)
                             syx::VARIABLE_PACKAGE:
                             [#GLOBAL(4B0.0), #GLOBAL(4B0.5)]
                             wvs
                        tgt:syx::PACKAGE:
                            ed::T: #GLOBAL(07B.1)
                             te::V:
                             [#GLOBAL(4B0.18), #GLOBAL(4B0.23)]
                            ed::T: #GLOBAL(07B.2)
                             te::V:
                             [#GLOBAL(4B0.18), #GLOBAL(4B0.24)]
                            ed::T: #GLOBAL(07B.3)
                             te::V:
                             [#GLOBAL(4B0.18), #GLOBAL(4B0.25)]
                            ed::T: #GLOBAL(07B.4)
                             te::V:
                             [#GLOBAL(4B0.18), #GLOBAL(4B0.26)]
                            ed::T: #GLOBAL(07B.5)
                             te::V:
                             [#GLOBAL(4B0.18), #GLOBAL(4B0.27)]
                            ed::T: #GLOBAL(07B.6)
                             te::V:
                             [#GLOBAL(4B0.18), #GLOBAL(4B0.28)]
                            ed::T: #GLOBAL(07B.7)
                             te::V:
                             [#GLOBAL(4B0.18), #GLOBAL(4B0.29)]
                            ed::T: #GLOBAL(07B.8)
                             te::V:
                             [#GLOBAL(4B0.18), #GLOBAL(4B0.30)]
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic winix_data_file_for_os_g
:
a_generic_api:
(<parameter>:
api {   package wxd
          : api {   package drv
                      : api {
                            Mailop X = Mailop(X );
                            Rw_Vector  = Rw_Vector;
                            Vector  = Vector;
                            Element  = Element;
                            Vector_Slice  = Vector_Slice;
                            Rw_Vector_Slice  = Rw_Vector_Slice;
                            File_Position  = File_Position;
                            compare : (File_Position , File_Position) -> Order;
                            Filereader = Filereader;
                            Filewriter = Filewriter;};;
                File_Descriptor;
                open_for_read : String -> drv::Filereader;
                open_for_write : String -> drv::Filewriter;
                open_for_append : String -> drv::Filewriter;
                make_filereader : {fd:File_Descriptor, filename:String} -> drv::Filereader;
                    make_filewriter :
                    {append_mode:Bool, best_io_quantum:Int, fd:File_Descriptor, filename:String} -> drv::Filewriter;};;};
)
:
api {
    Vector;
    Element;
    Input_Stream;
    Output_Stream;
    read : Input_Stream -> Vector;
    read_one : Input_Stream -> Null_Or(Element );
    read_n : (Input_Stream , Int) -> Vector;
    read_all : Input_Stream -> Vector;
    peek : Input_Stream -> Null_Or(Element );
    close_input : Input_Stream -> Void;
    end_of_stream : Input_Stream -> Bool;
    write : (Output_Stream , Vector) -> Void;
    write_one : (Output_Stream , Element) -> Void;
    flush : Output_Stream -> Void;
    close_output : Output_Stream -> Void;
        package pur
          : api {
                Vector  = Vector;
                Element  = one_byte_unt::Unt;
                Filereader  = Filereader;
                Filewriter  = Filewriter;
                Input_Stream;
                Output_Stream;
                File_Position  = File_Position;
                Out_Position;
                make_instream : (Filereader , Vector) -> Input_Stream;
                read : Input_Stream -> (Vector , Input_Stream);
                read_one : Input_Stream -> Null_Or(((Element , Input_Stream)) );
                read_n : (Input_Stream , Int) -> (Vector , Input_Stream);
                read_all : Input_Stream -> (Vector , Input_Stream);
                close_input : Input_Stream -> Void;
                end_of_stream : Input_Stream -> Bool;
                get_reader : Input_Stream -> (Filereader , Vector);
                file_position_in : Input_Stream -> File_Position;
                make_outstream : (Filewriter , io_exceptions::Buffering_Mode) -> Output_Stream;
                write : (Output_Stream , Vector) -> Void;
                write_one : (Output_Stream , Element) -> Void;
                flush : Output_Stream -> Void;
                close_output : Output_Stream -> Void;
                set_buffering_mode : (Output_Stream , io_exceptions::Buffering_Mode) -> Void;
                get_buffering_mode : Output_Stream -> io_exceptions::Buffering_Mode;
                get_writer : Output_Stream -> (Filewriter , io_exceptions::Buffering_Mode);
                file_pos_out : Out_Position -> File_Position;
                get_output_position : Output_Stream -> Out_Position;
                set_output_position : Out_Position -> Void;
                input1evt : Input_Stream -> Mailop(Null_Or(((Element , Input_Stream)) ) );
                input_nevt : (Input_Stream , Int) -> Mailop(((Vector , Input_Stream)) );
                input_mailop : Input_Stream -> Mailop(((Vector , Input_Stream)) );
                input_all_mailop : Input_Stream -> Mailop(((Vector , Input_Stream)) );};;
    make_instream : pur::Input_Stream -> Input_Stream;
    get_instream : Input_Stream -> pur::Input_Stream;
    set_instream : (Input_Stream , pur::Input_Stream) -> Void;
    get_output_position : Output_Stream -> pur::Out_Position;
    set_output_position : (Output_Stream , pur::Out_Position) -> Void;
    make_outstream : pur::Output_Stream -> Output_Stream;
    get_outstream : Output_Stream -> pur::Output_Stream;
    set_outstream : (Output_Stream , pur::Output_Stream) -> Void;
    input1evt : Input_Stream -> Mailop(Null_Or(Element ) );
    input_nevt : (Input_Stream , Int) -> Mailop(Vector );
    input_mailop : Input_Stream -> Mailop(Vector );
    input_all_mailop : Input_Stream -> Mailop(Vector );
    open_for_read : String -> Input_Stream;
    open_for_write : String -> Output_Stream;
    open_for_append : String -> Output_Stream;
    sharing pur::Element = Element
    sharing pur::Vector = Vector};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(4D1.15)
generic_closure:
CL:
parameter: #GLOBAL(4D1.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(4D1.14)
            syx::COERCED_PACKAGE:
                #GLOBAL(4D1.16)
                 src:syx::PACKAGE:
                        ed::S: #GLOBAL(4D1.17) syx::VARIABLE_PACKAGE: [#GLOBAL(4D1.0), #GLOBAL(4D1.2), #GLOBAL(50E.1)] drv
                            ed::S: #GLOBAL(4D1.18)
                             syx::PACKAGE:
                                    ed::T: #GLOBAL(4D1.19) te::FM: ?.Vector
                                    ed::T: #GLOBAL(4D1.20) te::FM: ?.Element
                                    ed::T: #GLOBAL(4D1.21) te::FM: ?.Filereader
                                    ed::T: #GLOBAL(4D1.22) te::FM: ?.Filewriter
                                    ed::T: #GLOBAL(4D1.23) te::FM: ?.File_Position
                                        ed::T: #GLOBAL(4D1.24)
                                         te::FM:
                                         ?.Input_Stream
                                        ed::T: #GLOBAL(4D1.25)
                                         te::FM:
                                         ?.Input_Buffer
                                        ed::T: #GLOBAL(4D1.26)
                                         te::FM:
                                         ?.Next
                                        ed::T: #GLOBAL(4D1.27)
                                         te::FM:
                                         ?.Global_File_Stuff
                                    ed::T: #GLOBAL(4D1.28) te::FM: ?.Next_Data
                                    ed::T: #GLOBAL(4D1.29) te::FM: ?.Result
                                    ed::T: #GLOBAL(4D1.30) te::FM: ?.Output_Stream_Info
                                    ed::T: #GLOBAL(4D1.31) te::FM: ?.Output_Stream
                                    ed::T: #GLOBAL(4D1.32) te::FM: ?.Out_Position
                             pur
                        ed::T: #GLOBAL(4D1.33) te::FM: ?.Vector
                        ed::T: #GLOBAL(4D1.34) te::FM: ?.Element
                        ed::T: #GLOBAL(4D1.35) te::FM: ?.Input_Stream
                        ed::T: #GLOBAL(4D1.36) te::FM: ?.Output_Stream
                    ed::T: #GLOBAL(4D1.37)
                     te::C:
                     ?.internal_threadkit_types::Apptask
                    ed::T: #GLOBAL(4D1.38)
                     te::C:
                     ?.mailop::End_Gun
                    ed::T: #GLOBAL(4D1.39)
                     te::C:
                     ?.mailcaster::Mailcaster
                    ed::T: #GLOBAL(4D1.40)
                     te::C:
                     ?.maildrop::Maildrop
                    ed::T: #GLOBAL(4D1.41)
                     te::C:
                     ?.internal_threadkit_types::Mailop
                    ed::T: #GLOBAL(4D1.42)
                     te::C:
                     ?.mailqueue::Mailqueue
                    ed::T: #GLOBAL(4D1.43)
                     te::C:
                     ?.mailslot::Mailslot
                    ed::T: #GLOBAL(4D1.44)
                     te::C:
                     ?.microthread::Make_Thread_Args
                    ed::T: #GLOBAL(4D1.45)
                     te::C:
                     ?.internal_threadkit_types::Microthread
                    ed::T: #GLOBAL(4D1.46)
                     te::C:
                     ?.oneshot_maildrop::Oneshot_Maildrop
                    ed::T: #GLOBAL(4D1.47)
                     te::C:
                     ?.mailcaster::Readqueue
                    ed::T: #GLOBAL(4D1.48)
                     te::C:
                     ?.mailop::Replyqueue
                    ed::T: #GLOBAL(4D1.49)
                     te::C:
                     ?.mailop::Run_Gun
                    ed::T: #GLOBAL(4D1.50)
                     te::C:
                     ?.run_at::When
                    ed::S: #GLOBAL(4D1.51)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(4D1.0), #GLOBAL(4D1.2), #GLOBAL(50E.1)]
                     drv
                    ed::S: #GLOBAL(4D1.52)
                     syx::CONSTANT_PACKAGE:
                     <threadkit::state>
                     state
                tgt:syx::PACKAGE:
                    ed::T: #GLOBAL(6C4.1)
                     te::V:
                     [#GLOBAL(4D1.16), #GLOBAL(4D1.33)]
                    ed::T: #GLOBAL(6C4.2)
                     te::V:
                     [#GLOBAL(4D1.16), #GLOBAL(4D1.34)]
                    ed::T: #GLOBAL(6C4.3)
                     te::V:
                     [#GLOBAL(4D1.16), #GLOBAL(4D1.35)]
                    ed::T: #GLOBAL(6C4.4)
                     te::V:
                     [#GLOBAL(4D1.16), #GLOBAL(4D1.36)]
                    ed::S: #GLOBAL(6C4.5)
                     syx::PACKAGE:
                        ed::T: #GLOBAL(520.1)
                         te::V:
                         [#GLOBAL(4D1.16), #GLOBAL(4D1.18), #GLOBAL(4D1.19)]
                        ed::T: #GLOBAL(520.2)
                         te::V:
                         [#GLOBAL(4D1.16), #GLOBAL(4D1.18), #GLOBAL(4D1.20)]
                        ed::T: #GLOBAL(520.3)
                         te::V:
                         [#GLOBAL(4D1.16), #GLOBAL(4D1.18), #GLOBAL(4D1.21)]
                        ed::T: #GLOBAL(520.4)
                         te::V:
                         [#GLOBAL(4D1.16), #GLOBAL(4D1.18), #GLOBAL(4D1.22)]
                        ed::T: #GLOBAL(520.5)
                         te::V:
                         [#GLOBAL(4D1.16), #GLOBAL(4D1.18), #GLOBAL(4D1.24)]
                        ed::T: #GLOBAL(520.6)
                         te::V:
                         [#GLOBAL(4D1.16), #GLOBAL(4D1.18), #GLOBAL(4D1.31)]
                        ed::T: #GLOBAL(520.7)
                         te::V:
                         [#GLOBAL(4D1.16), #GLOBAL(4D1.18), #GLOBAL(4D1.23)]
                        ed::T: #GLOBAL(520.8)
                         te::V:
                         [#GLOBAL(4D1.16), #GLOBAL(4D1.18), #GLOBAL(4D1.32)]
                     pur
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic winix_mailslot_io_g
:
a_generic_api:
(<parameter>:
api {   package drv
          : api {
                Mailop X = Mailop(X );
                Rw_Vector;
                Vector;
                Element;
                Vector_Slice;
                Rw_Vector_Slice;
                eqtype File_Position;
                compare : (File_Position , File_Position) -> Order;
                    Filereader
                    = FILEREADER        {avail:Void -> Null_Or(Int ), best_io_quantum:Int, close:Void -> Void,
                                        end_file_position:Null_Or((Void -> File_Position) ), filename:String,
                                        get_file_position:Null_Or((Void -> File_Position) ), io_descriptor:Null_Or(Int ),
                                        read_vector:Int -> Vector, read_vector_mailop:Int -> Mailop(Vector ),
                                        set_file_position:Null_Or((File_Position -> Void) ),
                                        verify_file_position:Null_Or((Void -> File_Position) )};
                    Filewriter
                    = FILEWRITER
                            {best_io_quantum:Int, close:Void -> Void, end_file_position:Null_Or((Void -> File_Position) ),
                            filename:String, get_file_position:Null_Or((Void -> File_Position) ), io_descriptor:Null_Or(Int ),
                            set_file_position:Null_Or((File_Position -> Void) ),
                            verify_file_position:Null_Or((Void -> File_Position) ), write_rw_vector:Rw_Vector_Slice -> Int,
                            write_rw_vector_mailop:Rw_Vector_Slice -> Mailop(Int ), write_vector:Vector_Slice -> Int,
                            write_vector_mailop:Vector_Slice -> Mailop(Int )};};;
        package rv
          : api {
                Vector;
                Element;
                maximum_vector_length : Int;
                from_list : List(Element ) -> Vector;
                from_fn : (Int , (Int -> Element)) -> Vector;
                length : Vector -> Int;
                cat : List(Vector ) -> Vector;
                get : (Vector , Int) -> Element;
                _[] : (Vector , Int) -> Element;
                set : (Vector , Int , Element) -> Vector;
                _[]:= : (Vector , Int , Element) -> Vector;
                keyed_apply : ((Int , Element) -> Void) -> Vector -> Void;
                apply : (Element -> Void) -> Vector -> Void;
                keyed_map : ((Int , Element) -> Element) -> Vector -> Vector;
                map : (Element -> Element) -> Vector -> Vector;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Vector -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Vector -> X;
                fold_forward : ((Element , X) -> X) -> X -> Vector -> X;
                fold_backward : ((Element , X) -> X) -> X -> Vector -> X;
                keyed_find : ((Int , Element) -> Bool) -> Vector -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Vector -> Null_Or(Element );
                exists : (Element -> Bool) -> Vector -> Bool;
                all : (Element -> Bool) -> Vector -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Vector , Vector) -> Order;};;
        package rvs
          : api {
                Element;
                Vector;
                Slice;
                length : Slice -> Int;
                get : (Slice , Int) -> Element;
                make_full_slice : Vector -> Slice;
                make_slice : (Vector , Int , Null_Or(Int )) -> Slice;
                make_subslice : (Slice , Int , Null_Or(Int )) -> Slice;
                burst_slice : Slice -> (Vector , Int , Int);
                to_vector : Slice -> Vector;
                cat : List(Slice ) -> Vector;
                is_empty : Slice -> Bool;
                get_item : Slice -> Null_Or(((Element , Slice)) );
                keyed_apply : ((Int , Element) -> Void) -> Slice -> Void;
                apply : (Element -> Void) -> Slice -> Void;
                keyed_map : ((Int , Element) -> Element) -> Slice -> Vector;
                map : (Element -> Element) -> Slice -> Vector;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                fold_forward : ((Element , X) -> X) -> X -> Slice -> X;
                fold_backward : ((Element , X) -> X) -> X -> Slice -> X;
                keyed_find : ((Int , Element) -> Bool) -> Slice -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Slice -> Null_Or(Element );
                exists : (Element -> Bool) -> Slice -> Bool;
                all : (Element -> Bool) -> Slice -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Slice , Slice) -> Order;};;
        package wv
          : api {
                eqtype Rw_Vector;
                Element;
                Vector;
                maximum_vector_length : Int;
                make_rw_vector : (Int , Element) -> Rw_Vector;
                from_list : List(Element ) -> Rw_Vector;
                from_fn : (Int , (Int -> Element)) -> Rw_Vector;
                length : Rw_Vector -> Int;
                get : (Rw_Vector , Int) -> Element;
                _[] : (Rw_Vector , Int) -> Element;
                set : (Rw_Vector , Int , Element) -> Void;
                _[]:= : (Rw_Vector , Int , Element) -> Void;
                to_vector : Rw_Vector -> Vector;
                copy : {at:Int, from:Rw_Vector, into:Rw_Vector} -> Void;
                copy_vector : {at:Int, from:Vector, into:Rw_Vector} -> Void;
                keyed_apply : ((Int , Element) -> Void) -> Rw_Vector -> Void;
                apply : (Element -> Void) -> Rw_Vector -> Void;
                keyed_map_in_place : ((Int , Element) -> Element) -> Rw_Vector -> Void;
                map_in_place : (Element -> Element) -> Rw_Vector -> Void;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Rw_Vector -> X;
                fold_forward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
                fold_backward : ((Element , X) -> X) -> X -> Rw_Vector -> X;
                keyed_find : ((Int , Element) -> Bool) -> Rw_Vector -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Rw_Vector -> Null_Or(Element );
                exists : (Element -> Bool) -> Rw_Vector -> Bool;
                all : (Element -> Bool) -> Rw_Vector -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Rw_Vector , Rw_Vector) -> Order;};;
        package wvs
          : api {
                Element;
                Vector;
                Rw_Vector;
                Slice;
                Vector_Slice;
                length : Slice -> Int;
                get : (Slice , Int) -> Element;
                set : (Slice , Int , Element) -> Void;
                _[] : (Slice , Int) -> Element;
                _[]:= : (Slice , Int , Element) -> Void;
                make_full_slice : Rw_Vector -> Slice;
                make_slice : (Rw_Vector , Int , Null_Or(Int )) -> Slice;
                make_subslice : (Slice , Int , Null_Or(Int )) -> Slice;
                burst_slice : Slice -> (Rw_Vector , Int , Int);
                to_vector : Slice -> Vector;
                copy : {at:Int, from:Slice, into:Rw_Vector} -> Void;
                copy_vector : {at:Int, from:Vector_Slice, into:Rw_Vector} -> Void;
                is_empty : Slice -> Bool;
                get_item : Slice -> Null_Or(((Element , Slice)) );
                keyed_apply : ((Int , Element) -> Void) -> Slice -> Void;
                apply : (Element -> Void) -> Slice -> Void;
                map_in_place : (Element -> Element) -> Slice -> Void;
                keyed_map_in_place : ((Int , Element) -> Element) -> Slice -> Void;
                keyed_fold_forward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                keyed_fold_backward : ((Int , Element , X) -> X) -> X -> Slice -> X;
                fold_forward : ((Element , X) -> X) -> X -> Slice -> X;
                fold_backward : ((Element , X) -> X) -> X -> Slice -> X;
                keyed_find : ((Int , Element) -> Bool) -> Slice -> Null_Or(((Int , Element)) );
                find : (Element -> Bool) -> Slice -> Null_Or(Element );
                exists : (Element -> Bool) -> Slice -> Bool;
                all : (Element -> Bool) -> Slice -> Bool;
                compare_sequences : ((Element , Element) -> Order) -> (Slice , Slice) -> Order;};;
    sharing drv::Rw_Vector_Slice = wvs::Slice
    sharing drv::Vector_Slice = wvs::Vector_Slice = rvs::Slice
    sharing drv::Vector = rvs::Vector = wvs::Vector = rv::Vector = wv::Vector
    sharing drv::Rw_Vector = wvs::Rw_Vector = wv::Rw_Vector};
)
:
api {   package drv
          : api {
                Mailop X = Mailop(X );
                Rw_Vector;
                Vector;
                Element;
                Vector_Slice;
                Rw_Vector_Slice;
                eqtype File_Position;
                compare : (File_Position , File_Position) -> Order;
                    Filereader
                    = FILEREADER        {avail:Void -> Null_Or(Int ), best_io_quantum:Int, close:Void -> Void,
                                        end_file_position:Null_Or((Void -> File_Position) ), filename:String,
                                        get_file_position:Null_Or((Void -> File_Position) ), io_descriptor:Null_Or(Int ),
                                        read_vector:Int -> Vector, read_vector_mailop:Int -> Mailop(Vector ),
                                        set_file_position:Null_Or((File_Position -> Void) ),
                                        verify_file_position:Null_Or((Void -> File_Position) )};
                    Filewriter
                    = FILEWRITER
                            {best_io_quantum:Int, close:Void -> Void, end_file_position:Null_Or((Void -> File_Position) ),
                            filename:String, get_file_position:Null_Or((Void -> File_Position) ), io_descriptor:Null_Or(Int ),
                            set_file_position:Null_Or((File_Position -> Void) ),
                            verify_file_position:Null_Or((Void -> File_Position) ), write_rw_vector:Rw_Vector_Slice -> Int,
                            write_rw_vector_mailop:Rw_Vector_Slice -> Mailop(Int ), write_vector:Vector_Slice -> Int,
                            write_vector_mailop:Vector_Slice -> Mailop(Int )};};;
    make_filereader : Mailslot(drv::Vector ) -> drv::Filereader;
    make_filewriter : Mailslot(drv::Vector ) -> drv::Filewriter;};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(E87.11)
generic_closure:
CL:
parameter: #GLOBAL(E87.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(E87.8)
            syx::COERCED_PACKAGE:
                #GLOBAL(E87.12)
                 src:syx::PACKAGE:
                    ed::S: #GLOBAL(E87.13) syx::VARIABLE_PACKAGE: [#GLOBAL(E87.0), #GLOBAL(E87.2)] drv
                    ed::T: #GLOBAL(E87.14)
                     te::C:
                     ?.internal_threadkit_types::Apptask
                    ed::T: #GLOBAL(E87.15)
                     te::C:
                     ?.mailop::End_Gun
                    ed::T: #GLOBAL(E87.16)
                     te::C:
                     ?.mailcaster::Mailcaster
                    ed::T: #GLOBAL(E87.17)
                     te::C:
                     ?.maildrop::Maildrop
                    ed::T: #GLOBAL(E87.18)
                     te::C:
                     ?.internal_threadkit_types::Mailop
                    ed::T: #GLOBAL(E87.19)
                     te::C:
                     ?.mailqueue::Mailqueue
                    ed::T: #GLOBAL(E87.20)
                     te::C:
                     ?.mailslot::Mailslot
                    ed::T: #GLOBAL(E87.21)
                     te::C:
                     ?.microthread::Make_Thread_Args
                    ed::T: #GLOBAL(E87.22)
                     te::C:
                     ?.internal_threadkit_types::Microthread
                    ed::T: #GLOBAL(E87.23)
                     te::C:
                     ?.oneshot_maildrop::Oneshot_Maildrop
                    ed::T: #GLOBAL(E87.24)
                     te::C:
                     ?.mailcaster::Readqueue
                    ed::T: #GLOBAL(E87.25)
                     te::C:
                     ?.mailop::Replyqueue
                    ed::T: #GLOBAL(E87.26)
                     te::C:
                     ?.mailop::Run_Gun
                    ed::T: #GLOBAL(E87.27)
                     te::C:
                     ?.run_at::When
                    ed::S: #GLOBAL(E87.28)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(E87.0), #GLOBAL(E87.2)]
                     drv
                    ed::S: #GLOBAL(E87.29)
                     syx::CONSTANT_PACKAGE:
                     <threadkit::state>
                     state
                tgt:syx::PACKAGE:
                 ed::S: #GLOBAL(E87.10) syx::VARIABLE_PACKAGE: [#GLOBAL(E87.12), #GLOBAL(E87.28)] drv
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
generic winix_text_file_for_os_g
:
a_generic_api:
(<parameter>:
api {   package wxd
          : api {   package drv
                      : api {
                            Mailop X = Mailop(X );
                            Rw_Vector  = Rw_Vector;
                            Vector  = Vector;
                            Element  = Element;
                            Vector_Slice  = Vector_Slice;
                            Rw_Vector_Slice  = Rw_Vector_Slice;
                            File_Position  = File_Position;
                            compare : (File_Position , File_Position) -> Order;
                            Filereader = Filereader;
                            Filewriter = Filewriter;};;
                File_Descriptor;
                open_for_read : String -> drv::Filereader;
                open_for_write : String -> drv::Filewriter;
                open_for_append : String -> drv::Filewriter;
                make_filereader : {fd:File_Descriptor, filename:String} -> drv::Filereader;
                    make_filewriter :
                    {append_mode:Bool, best_io_quantum:Int, fd:File_Descriptor, filename:String} -> drv::Filewriter;
                stdin : Void -> drv::Filereader;
                stdout : Void -> drv::Filewriter;
                stderr : Void -> drv::Filewriter;
                string_reader : String -> drv::Filereader;};;};
)
:
api {
    Vector  = String;
    Element  = Char;
    Input_Stream;
    Output_Stream;
    read : Input_Stream -> Vector;
    read_one : Input_Stream -> Null_Or(Element );
    read_n : (Input_Stream , Int) -> Vector;
    read_all : Input_Stream -> Vector;
    peek : Input_Stream -> Null_Or(Element );
    close_input : Input_Stream -> Void;
    end_of_stream : Input_Stream -> Bool;
    write : (Output_Stream , Vector) -> Void;
    write_one : (Output_Stream , Element) -> Void;
    flush : Output_Stream -> Void;
    close_output : Output_Stream -> Void;
        package pur
          : api {
                Vector  = String;
                Element  = Char;
                Filereader  = Filereader;
                Filewriter  = Filewriter;
                Input_Stream;
                Output_Stream;
                File_Position  = File_Position;
                Out_Position;
                make_instream : (Filereader , Vector) -> Input_Stream;
                read : Input_Stream -> (Vector , Input_Stream);
                read_one : Input_Stream -> Null_Or(((Element , Input_Stream)) );
                read_n : (Input_Stream , Int) -> (Vector , Input_Stream);
                read_all : Input_Stream -> (Vector , Input_Stream);
                close_input : Input_Stream -> Void;
                end_of_stream : Input_Stream -> Bool;
                get_reader : Input_Stream -> (Filereader , Vector);
                file_position_in : Input_Stream -> File_Position;
                make_outstream : (Filewriter , io_exceptions::Buffering_Mode) -> Output_Stream;
                write : (Output_Stream , Vector) -> Void;
                write_one : (Output_Stream , Element) -> Void;
                flush : Output_Stream -> Void;
                close_output : Output_Stream -> Void;
                set_buffering_mode : (Output_Stream , io_exceptions::Buffering_Mode) -> Void;
                get_buffering_mode : Output_Stream -> io_exceptions::Buffering_Mode;
                get_writer : Output_Stream -> (Filewriter , io_exceptions::Buffering_Mode);
                file_pos_out : Out_Position -> File_Position;
                get_output_position : Output_Stream -> Out_Position;
                set_output_position : Out_Position -> Void;
                read_line : Input_Stream -> Null_Or(((String , Input_Stream)) );
                write_substring : (Output_Stream , Substring) -> Void;
                input1evt : Input_Stream -> Mailop(Null_Or(((Element , Input_Stream)) ) );
                input_nevt : (Input_Stream , Int) -> Mailop(((Vector , Input_Stream)) );
                input_mailop : Input_Stream -> Mailop(((Vector , Input_Stream)) );
                input_all_mailop : Input_Stream -> Mailop(((Vector , Input_Stream)) );
                input_line_mailop : Input_Stream -> Mailop(Null_Or(((Vector , Input_Stream)) ) );};;
    make_instream : pur::Input_Stream -> Input_Stream;
    get_instream : Input_Stream -> pur::Input_Stream;
    set_instream : (Input_Stream , pur::Input_Stream) -> Void;
    get_output_position : Output_Stream -> pur::Out_Position;
    set_output_position : (Output_Stream , pur::Out_Position) -> Void;
    make_outstream : pur::Output_Stream -> Output_Stream;
    get_outstream : Output_Stream -> pur::Output_Stream;
    set_outstream : (Output_Stream , pur::Output_Stream) -> Void;
    read_line : Input_Stream -> Null_Or(String );
    read_lines : Input_Stream -> List(String );
    as_lines : String -> List(String );
    write_substring : (Output_Stream , Substring) -> Void;
    from_lines : String -> List(String ) -> Void;
    open_for_read : String -> Input_Stream;
    open_string : String -> Input_Stream;
    open_for_write : String -> Output_Stream;
    open_for_append : String -> Output_Stream;
    stdin : Input_Stream;
    stdout : Output_Stream;
    stderr : Output_Stream;
    input1evt : Input_Stream -> Mailop(Null_Or(Element ) );
    input_nevt : (Input_Stream , Int) -> Mailop(Vector );
    input_mailop : Input_Stream -> Mailop(Vector );
    input_all_mailop : Input_Stream -> Mailop(Vector );
    open_slot_in : Mailslot(String ) -> Input_Stream;
    open_slot_out : Mailslot(String ) -> Output_Stream;
    print : String -> Void;
    exists : String -> Bool;
        scan_stream :
            (number_string::Reader((Element, pur::Input_Stream)) -> number_string::Reader((X, pur::Input_Stream)))
            ->
            Input_Stream -> Null_Or(X );};
typechecked_generic:
Typechecked_Generic:
inverse_path: <>
stamp: #GLOBAL(E87.15)
generic_closure:
CL:
parameter: #GLOBAL(E87.0)
body: syx::PACKAGE:
        ed::S: #GLOBAL(E87.14)
            syx::COERCED_PACKAGE:
                #GLOBAL(E87.16)
                 src:syx::PACKAGE:
                            ed::S: #GLOBAL(E87.17) syx::VARIABLE_PACKAGE: [#GLOBAL(E87.0), #GLOBAL(E87.2), #GLOBAL(50E.1)] drv
                                    ed::S: #GLOBAL(E87.18)
                                     syx::PACKAGE:
                                            ed::T: #GLOBAL(E87.19) te::FM: ?.Vector
                                            ed::T: #GLOBAL(E87.20) te::FM: ?.Element
                                            ed::T: #GLOBAL(E87.21) te::FM: ?.Filereader
                                            ed::T: #GLOBAL(E87.22) te::FM: ?.Filewriter
                                            ed::T: #GLOBAL(E87.23) te::FM: ?.File_Position
                                                ed::T: #GLOBAL(E87.24)
                                                 te::FM:
                                                 ?.Input_Stream
                                                ed::T: #GLOBAL(E87.25)
                                                 te::FM:
                                                 ?.Input_Buffer
                                                ed::T: #GLOBAL(E87.26)
                                                 te::FM:
                                                 ?.Next
                                                ed::T: #GLOBAL(E87.27)
                                                 te::FM:
                                                 ?.Global_File_Stuff
                                            ed::T: #GLOBAL(E87.28) te::FM: ?.Next_Data
                                            ed::T: #GLOBAL(E87.29) te::FM: ?.Result
                                            ed::T: #GLOBAL(E87.30) te::FM: ?.Output_Stream_Info
                                            ed::T: #GLOBAL(E87.31) te::FM: ?.Output_Stream
                                            ed::T: #GLOBAL(E87.32) te::FM: ?.Out_Position
                                     pur
                                ed::T: #GLOBAL(E87.33) te::FM: ?.Vector
                                ed::T: #GLOBAL(E87.34) te::FM: ?.Element
                                ed::T: #GLOBAL(E87.35) te::FM: ?.Input_Stream
                                ed::T: #GLOBAL(E87.36) te::FM: ?.Output_Stream
                                ed::T: #GLOBAL(E87.37) te::FM: ?.Result
                                    ed::S: #GLOBAL(E87.38)
                                        syx::PACKAGE_LET:
                                            stipulate:  ed::S: #GLOBAL(E87.39)
                                                            syx::APPLY:
                                                                fct:fe::CONSTANT_GENERIC:<>
                                                                arg:syx::COERCED_PACKAGE:
                                                                        #GLOBAL(E87.40)
                                                                         src:syx::PACKAGE:
                                                                                ed::S: #GLOBAL(E87.41) syx::VARIABLE_PACKAGE: [#GLOBAL(E87.0), #GLOBAL(E87.2), #GLOBAL(50E.1)] drv
                                                                                ed::S: #GLOBAL(E87.42) syx::CONSTANT_PACKAGE: <vector_of_chars> rv
                                                                                ed::S: #GLOBAL(E87.43) syx::CONSTANT_PACKAGE: <rw_vector_of_chars> wv
                                                                                ed::S: #GLOBAL(E87.44) syx::CONSTANT_PACKAGE: <vector_slice_of_chars> rvs
                                                                                ed::S: #GLOBAL(E87.45) syx::CONSTANT_PACKAGE: <rw_vector_slice_of_chars> wvs
                                                                            ed::S: #GLOBAL(E87.46)
                                                                             syx::VARIABLE_PACKAGE:
                                                                             [#GLOBAL(E87.0), #GLOBAL(E87.2), #GLOBAL(50E.1)]
                                                                             drv
                                                                        tgt:syx::PACKAGE:
                                                                            ed::S: #GLOBAL(E87.2)
                                                                             syx::PACKAGE:
                                                                                ed::T: #GLOBAL(069.1)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.46), #GLOBAL(069.1)]
                                                                                ed::T: #GLOBAL(069.2)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.46), #GLOBAL(069.2)]
                                                                                ed::T: #GLOBAL(069.3)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.46), #GLOBAL(069.3)]
                                                                                ed::T: #GLOBAL(069.4)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.46), #GLOBAL(069.4)]
                                                                                ed::T: #GLOBAL(069.5)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.46), #GLOBAL(069.5)]
                                                                                ed::T: #GLOBAL(069.6)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.46), #GLOBAL(069.6)]
                                                                                ed::T: #GLOBAL(069.7)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.46), #GLOBAL(069.7)]
                                                                                ed::T: #GLOBAL(069.8)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.46), #GLOBAL(069.8)]
                                                                                ed::T: #GLOBAL(069.9)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.46), #GLOBAL(069.9)]
                                                                             drv
                                                                            ed::S: #GLOBAL(E87.3)
                                                                             syx::VARIABLE_PACKAGE:
                                                                             [#GLOBAL(E87.40), #GLOBAL(E87.42)]
                                                                             rv
                                                                            ed::S: #GLOBAL(E87.4)
                                                                             syx::PACKAGE:
                                                                                ed::T: #GLOBAL(FE8.1)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.44), #GLOBAL(FE8.1)]
                                                                                ed::T: #GLOBAL(FE8.2)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.44), #GLOBAL(FE8.2)]
                                                                                ed::T: #GLOBAL(FE8.3)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.44), #GLOBAL(FE8.3)]
                                                                             rvs
                                                                            ed::S: #GLOBAL(E87.5)
                                                                             syx::VARIABLE_PACKAGE:
                                                                             [#GLOBAL(E87.40), #GLOBAL(E87.43)]
                                                                             wv
                                                                            ed::S: #GLOBAL(E87.6)
                                                                             syx::PACKAGE:
                                                                                ed::T: #GLOBAL(663.1)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.45), #GLOBAL(663.1)]
                                                                                ed::T: #GLOBAL(663.2)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.45), #GLOBAL(663.2)]
                                                                                ed::T: #GLOBAL(663.3)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.45), #GLOBAL(663.3)]
                                                                                ed::T: #GLOBAL(663.4)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.45), #GLOBAL(663.4)]
                                                                                ed::T: #GLOBAL(663.5)
                                                                                 te::V:
                                                                                 [#GLOBAL(E87.40), #GLOBAL(E87.45), #GLOBAL(663.5)]
                                                                             wvs
                                                         <return_package>
                                            herein:syx::VARIABLE_PACKAGE:
                                             [#GLOBAL(E87.39), #GLOBAL(E87.8)]
                                     mailslot_io
                    ed::T: #GLOBAL(E87.47)
                     te::C:
                     ?.internal_threadkit_types::Apptask
                    ed::T: #GLOBAL(E87.48)
                     te::C:
                     ?.mailop::End_Gun
                    ed::T: #GLOBAL(E87.49)
                     te::C:
                     ?.mailcaster::Mailcaster
                    ed::T: #GLOBAL(E87.50)
                     te::C:
                     ?.maildrop::Maildrop
                    ed::T: #GLOBAL(E87.51)
                     te::C:
                     ?.internal_threadkit_types::Mailop
                    ed::T: #GLOBAL(E87.52)
                     te::C:
                     ?.mailqueue::Mailqueue
                    ed::T: #GLOBAL(E87.53)
                     te::C:
                     ?.mailslot::Mailslot
                    ed::T: #GLOBAL(E87.54)
                     te::C:
                     ?.microthread::Make_Thread_Args
                    ed::T: #GLOBAL(E87.55)
                     te::C:
                     ?.internal_threadkit_types::Microthread
                    ed::T: #GLOBAL(E87.56)
                     te::C:
                     ?.oneshot_maildrop::Oneshot_Maildrop
                    ed::T: #GLOBAL(E87.57)
                     te::C:
                     ?.mailcaster::Readqueue
                    ed::T: #GLOBAL(E87.58)
                     te::C:
                     ?.mailop::Replyqueue
                    ed::T: #GLOBAL(E87.59)
                     te::C:
                     ?.mailop::Run_Gun
                    ed::T: #GLOBAL(E87.60)
                     te::C:
                     ?.run_at::When
                    ed::S: #GLOBAL(E87.61)
                     syx::VARIABLE_PACKAGE:
                     [#GLOBAL(E87.39), #GLOBAL(E87.8)]
                     mailslot_io
                    ed::S: #GLOBAL(E87.62)
                     syx::CONSTANT_PACKAGE:
                     <threadkit::state>
                     state
                tgt:syx::PACKAGE:
                    ed::T: #GLOBAL(601.1)
                     te::V:
                     [#GLOBAL(E87.16), #GLOBAL(E87.33)]
                    ed::T: #GLOBAL(601.2)
                     te::V:
                     [#GLOBAL(E87.16), #GLOBAL(E87.34)]
                    ed::T: #GLOBAL(601.3)
                     te::V:
                     [#GLOBAL(E87.16), #GLOBAL(E87.35)]
                    ed::T: #GLOBAL(601.4)
                     te::V:
                     [#GLOBAL(E87.16), #GLOBAL(E87.36)]
                    ed::S: #GLOBAL(601.5)
                     syx::PACKAGE:
                        ed::T: #GLOBAL(520.1)
                         te::V:
                         [#GLOBAL(E87.16), #GLOBAL(E87.18), #GLOBAL(E87.19)]
                        ed::T: #GLOBAL(520.2)
                         te::V:
                         [#GLOBAL(E87.16), #GLOBAL(E87.18), #GLOBAL(E87.20)]
                        ed::T: #GLOBAL(520.3)
                         te::V:
                         [#GLOBAL(E87.16), #GLOBAL(E87.18), #GLOBAL(E87.21)]
                        ed::T: #GLOBAL(520.4)
                         te::V:
                         [#GLOBAL(E87.16), #GLOBAL(E87.18), #GLOBAL(E87.22)]
                        ed::T: #GLOBAL(520.5)
                         te::V:
                         [#GLOBAL(E87.16), #GLOBAL(E87.18), #GLOBAL(E87.24)]
                        ed::T: #GLOBAL(520.6)
                         te::V:
                         [#GLOBAL(E87.16), #GLOBAL(E87.18), #GLOBAL(E87.31)]
                        ed::T: #GLOBAL(520.7)
                         te::V:
                         [#GLOBAL(E87.16), #GLOBAL(E87.18), #GLOBAL(E87.23)]
                        ed::T: #GLOBAL(520.8)
                         te::V:
                         [#GLOBAL(E87.16), #GLOBAL(E87.18), #GLOBAL(E87.32)]
                     pur
         <result_package>
dictionary:
lambdaty:
  <lambdaty>typepath:--printing of Typepath not implemented yet--
fixity  . :
fixity !:
fixity !=:
fixity $:
fixity %:
fixity &:
fixity *:
fixity **:
fixity +:
fixity -:
fixity ..:
fixity /:
fixity :=:
fixity <:
fixity <<:
fixity <=:
fixity ==:
fixity ==>:
fixity =~:
fixity >:
fixity ><:
fixity >=:
fixity >>:
fixity >>>:
fixity ?:
fixity @:
fixity \:
fixity ^:
fixity div:
fixity in:
fixity o:
fixity then:
fixity |:
fixity ~:
% This file generated by latex_print_compiler_state_to_file  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-compiler-state.pkg
