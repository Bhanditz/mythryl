\index[api]{Digraphxy}
\label{api:Digraphxy}
\input{top-api-Digraphxy.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    Graph (X, Y);
    Node X;
    Tag X;
    Node_Datum X = NFLOAT Float | NID Id | NINT Int | NNONE | NOTHER X | NSTRING String;
    Tag_Datum X = TFLOAT Float | TID Id | TINT Int | TNONE | TOTHER X | TSTRING String;
    Tagless_Edge X = (Node(X ) , Node(X ));
    Edge (X, Y) = (Node(X ) , Tag(Y ) , Node(X ));
        package ts
          : api {   package key
                      : api {
                            Key X;
                            compare : (Key(X ) , Key(X )) -> Order;};;
                Item X = key::Key(X );
                Set X;
                empty : Set(X );
                singleton : Item(X ) -> Set(X );
                add : (Set(X ) , Item(X )) -> Set(X );
                add' : (Item(X ) , Set(X )) -> Set(X );
                add_list : (Set(X ) , List(Item(X ) )) -> Set(X );
                drop : (Set(X ) , Item(X )) -> Set(X );
                member : (Set(X ) , Item(X )) -> Bool;
                is_empty : Set(X ) -> Bool;
                equal : (Set(X ) , Set(X )) -> Bool;
                compare : (Set(X ) , Set(X )) -> Order;
                is_subset : (Set(X ) , Set(X )) -> Bool;
                vals_count : Set(X ) -> Int;
                vals_list : Set(X ) -> List(Item(X ) );
                union : (Set(X ) , Set(X )) -> Set(X );
                intersection : (Set(X ) , Set(X )) -> Set(X );
                difference : (Set(X ) , Set(X )) -> Set(X );
                map : (Item(X ) -> Item(X )) -> Set(X ) -> Set(X );
                apply : (Item(X ) -> Void) -> Set(X ) -> Void;
                fold_forward : ((Item(X ) , Y) -> Y) -> Y -> Set(X ) -> Y;
                fold_backward : ((Item(X ) , Y) -> Y) -> Y -> Set(X ) -> Y;
                partition : (Item(X ) -> Bool) -> Set(X ) -> (Set(X ) , Set(X ));
                filter : (Item(X ) -> Bool) -> Set(X ) -> Set(X );
                exists : (Item(X ) -> Bool) -> Set(X ) -> Bool;
                find : (Item(X ) -> Bool) -> Set(X ) -> Null_Or(Item(X ) );
                all_invariants_hold : Set(X ) -> Bool;};;
        package es
          : api {   package key
                      : api {
                            Key (X, Y);
                            compare : (Key((X, Y)) , Key((X, Y))) -> Order;};;
                Item (X, Y) = key::Key((X, Y));
                Set (X, Y);
                empty : Set((X, Y));
                singleton : Item((X, Y)) -> Set((X, Y));
                add : (Set((X, Y)) , Item((X, Y))) -> Set((X, Y));
                add' : (Item((X, Y)) , Set((X, Y))) -> Set((X, Y));
                add_list : (Set((X, Y)) , List(Item((X, Y)) )) -> Set((X, Y));
                drop : (Set((X, Y)) , Item((X, Y))) -> Set((X, Y));
                member : (Set((X, Y)) , Item((X, Y))) -> Bool;
                is_empty : Set((X, Y)) -> Bool;
                equal : (Set((X, Y)) , Set((X, Y))) -> Bool;
                compare : (Set((X, Y)) , Set((X, Y))) -> Order;
                is_subset : (Set((X, Y)) , Set((X, Y))) -> Bool;
                vals_count : Set((X, Y)) -> Int;
                vals_list : Set((X, Y)) -> List(Item((X, Y)) );
                union : (Set((X, Y)) , Set((X, Y))) -> Set((X, Y));
                intersection : (Set((X, Y)) , Set((X, Y))) -> Set((X, Y));
                difference : (Set((X, Y)) , Set((X, Y))) -> Set((X, Y));
                map : (Item((X, Y)) -> Item((X, Y))) -> Set((X, Y)) -> Set((X, Y));
                apply : (Item((X, Y)) -> Void) -> Set((X, Y)) -> Void;
                fold_forward : ((Item((X, Y)) , Y) -> Y) -> Y -> Set((X, Y)) -> Y;
                fold_backward : ((Item((X, Y)) , Y) -> Y) -> Y -> Set((X, Y)) -> Y;
                partition : (Item((X, Y)) -> Bool) -> Set((X, Y)) -> (Set((X, Y)) , Set((X, Y)));
                filter : (Item((X, Y)) -> Bool) -> Set((X, Y)) -> Set((X, Y));
                exists : (Item((X, Y)) -> Bool) -> Set((X, Y)) -> Bool;
                find : (Item((X, Y)) -> Bool) -> Set((X, Y)) -> Null_Or(Item((X, Y)) );
                all_invariants_hold : Set((X, Y)) -> Bool;};;
    make_node : Void -> Node(X );
    make_int_node : Int -> Node(X );
    make_id_node : Id -> Node(X );
    make_string_node : String -> Node(X );
    make_float_node : Float -> Node(X );
    make_other_node : X -> Node(X );
    node_datum : Node(X ) -> Node_Datum(X );
    node_int : Node(X ) -> Null_Or(Int );
    node_id : Node(X ) -> Null_Or(Id );
    node_string : Node(X ) -> Null_Or(String );
    node_float : Node(X ) -> Null_Or(Float );
    node_other : Node(X ) -> Null_Or(X );
    make_tag : Void -> Tag(X );
    make_int_tag : Int -> Tag(X );
    make_id_tag : Id -> Tag(X );
    make_string_tag : String -> Tag(X );
    make_float_tag : Float -> Tag(X );
    make_other_tag : X -> Tag(X );
    tag_datum : Tag(X ) -> Tag_Datum(X );
    tag_int : Tag(X ) -> Null_Or(Int );
    tag_id : Tag(X ) -> Null_Or(Id );
    tag_string : Tag(X ) -> Null_Or(String );
    tag_float : Tag(X ) -> Null_Or(Float );
    tag_other : Tag(X ) -> Null_Or(X );
    empty_graph : Graph((X, Y));
    put_tagless_edge : (Graph((X, Y)) , Tagless_Edge(X )) -> Graph((X, Y));
    put_edge : (Graph((X, Y)) , Edge((X, Y))) -> Graph((X, Y));
    drop_tagless_edge : (Graph((X, Y)) , Tagless_Edge(X )) -> Graph((X, Y));
    drop_edge : (Graph((X, Y)) , Edge((X, Y))) -> Graph((X, Y));
    get_tagless_edges : Graph((Y, X)) -> ts::Set(Y );
    get_tagless_edges1 : (Graph((Y, X)) , Node(Y )) -> Null_Or(ts::Set(Y ) );
    get_tagless_edges2 : (Graph((Y, X)) , Node(Y )) -> Null_Or(ts::Set(Y ) );
    has_tagless_edge : (Graph((Y, X)) , Tagless_Edge(Y )) -> Bool;
    has_edge : (Graph((X, Y)) , Edge((X, Y))) -> Bool;
    get_edges : Graph((X, Y)) -> es::Set((X, Y));
    get_edges1 : (Graph((X, Y)) , Node(X )) -> Null_Or(es::Set((X, Y)) );
    get_edges2 : (Graph((X, Y)) , Tag(Y )) -> Null_Or(es::Set((X, Y)) );
    get_edges3 : (Graph((X, Y)) , Node(X )) -> Null_Or(es::Set((X, Y)) );
    get_edges12 : (Graph((X, Y)) , Node(X ) , Tag(Y )) -> Null_Or(es::Set((X, Y)) );
    get_edges13 : (Graph((X, Y)) , Node(X ) , Node(X )) -> Null_Or(es::Set((X, Y)) );
    get_edges23 : (Graph((X, Y)) , Tag(Y ) , Node(X )) -> Null_Or(es::Set((X, Y)) );
    nodes_apply : Graph((Y, X)) -> (Node(Y ) -> Void) -> Void;
    tags_apply : Graph((X, Y)) -> (Tag(Y ) -> Void) -> Void;};
\end{verbatim}\index[fun]{tags\_apply}
\index[fun]{nodes\_apply}
\index[fun]{get\_edges23}
\index[fun]{get\_edges13}
\index[fun]{get\_edges12}
\index[fun]{get\_edges3}
\index[fun]{get\_edges2}
\index[fun]{get\_edges1}
\index[fun]{get\_edges}
\index[fun]{has\_edge}
\index[fun]{has\_tagless\_edge}
\index[fun]{get\_tagless\_edges2}
\index[fun]{get\_tagless\_edges1}
\index[fun]{get\_tagless\_edges}
\index[fun]{drop\_edge}
\index[fun]{drop\_tagless\_edge}
\index[fun]{put\_edge}
\index[fun]{put\_tagless\_edge}
\index[fun]{empty\_graph}
\index[fun]{tag\_other}
\index[fun]{tag\_float}
\index[fun]{tag\_string}
\index[fun]{tag\_id}
\index[fun]{tag\_int}
\index[fun]{tag\_datum}
\index[fun]{make\_other\_tag}
\index[fun]{make\_float\_tag}
\index[fun]{make\_string\_tag}
\index[fun]{make\_id\_tag}
\index[fun]{make\_int\_tag}
\index[fun]{make\_tag}
\index[fun]{node\_other}
\index[fun]{node\_float}
\index[fun]{node\_string}
\index[fun]{node\_id}
\index[fun]{node\_int}
\index[fun]{node\_datum}
\index[fun]{make\_other\_node}
\index[fun]{make\_float\_node}
\index[fun]{make\_string\_node}
\index[fun]{make\_id\_node}
\index[fun]{make\_int\_node}
\index[fun]{make\_node}
\index[fun]{all\_invariants\_hold}
\index[fun]{find}
\index[fun]{exists}
\index[fun]{filter}
\index[fun]{partition}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{apply}
\index[fun]{map}
\index[fun]{difference}
\index[fun]{intersection}
\index[fun]{union}
\index[fun]{vals\_list}
\index[fun]{vals\_count}
\index[fun]{is\_subset}
\index[fun]{compare}
\index[fun]{equal}
\index[fun]{is\_empty}
\index[fun]{member}
\index[fun]{drop}
\index[fun]{add\_list}
\index[fun]{add\_\_prime\_\_}
\index[fun]{add}
\index[fun]{singleton}
\index[fun]{empty}
\index[fun]{compare}
\index[fun]{all\_invariants\_hold}
\index[fun]{find}
\index[fun]{exists}
\index[fun]{filter}
\index[fun]{partition}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{apply}
\index[fun]{map}
\index[fun]{difference}
\index[fun]{intersection}
\index[fun]{union}
\index[fun]{vals\_list}
\index[fun]{vals\_count}
\index[fun]{is\_subset}
\index[fun]{compare}
\index[fun]{equal}
\index[fun]{is\_empty}
\index[fun]{member}
\index[fun]{drop}
\index[fun]{add\_list}
\index[fun]{add\_\_prime\_\_}
\index[fun]{add}
\index[fun]{singleton}
\index[fun]{empty}
\index[fun]{compare}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
