<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Package and API Subclassing</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mythryl_Packages__Strong_vs_Weak.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Call_CC_and_Soft_Thread_Programming.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc106">5.4.21</A>  Package and API Subclassing</H3><P>We have <A HREF="my-Packages.html#section:tut:bare-essentials:packages">seen</A> that the Mythryl <TT>include</TT> statement may be used to dump package 
definitions into the current namespace in order to save us the 
effort of writing explicit package qualifiers:</P><PRE CLASS="verbatim">    linux$ my

    eval:  v = vector::from_list [ 1, 2, 3 ];
    #[1, 2, 3]

    eval:  include package   vector;

    including vector
      Vector  X = Vector(X);
          max_len : Int;
          from_list : List(X) -&gt; Vector(X);
          tabulate : (Int, (Int -&gt; X)) -&gt; Vector(X);
          length : Vector(X) -&gt; Int;
          get : (Vector(X), Int) -&gt; X;
          _[] : (Vector(X), Int) -&gt; X;
          set : (Vector(X), Int, X) -&gt; Vector(X);
          cat : List(Vector(X)) -&gt; Vector(X);
          keyed_apply : ((Int, X) -&gt; Void) -&gt; Vector(X) -&gt; Void;
          apply : (X -&gt; Void) -&gt; Vector(X) -&gt; Void;
          keyed_map : ((Int, X) -&gt; Y) -&gt; Vector(X) -&gt; Vector(Y);
          map : (X -&gt; Y) -&gt; Vector(X) -&gt; Vector(Y);
          keyed_fold_forward : ((Int, X, Y) -&gt; Y) -&gt; Y -&gt; Vector(X) -&gt; Y;
          keyed_fold_backward : ((Int, X, Y) -&gt; Y) -&gt; Y -&gt; Vector(X) -&gt; Y;
          fold_forward : ((X, Y) -&gt; Y) -&gt; Y -&gt; Vector(X) -&gt; Y;
          fold_backward : ((X, Y) -&gt; Y) -&gt; Y -&gt; Vector(X) -&gt; Y;
          keyed_find : ((Int, X) -&gt; Bool)
                  -&gt; Vector(X) -&gt; Null_Or(((Int, X)));
          find : (X -&gt; Bool) -&gt; Vector(X) -&gt; Null_Or(X);
          exists : (X -&gt; Bool) -&gt; Vector(X) -&gt; Bool;
          all : (X -&gt; Bool) -&gt; Vector(X) -&gt; Bool;
          compare_sequences : ((X, X) -&gt; Order) -&gt; (Vector(X), Vector(X)) -&gt; Order;

    eval:  v = from_list [ 3, 4, 5 ];
    #[3, 4, 5]
</PRE><P>The <TT>include</TT> statement is also often used to dump the contents of 
one package definition into another, with the idea of defining the second 
package just by overriding a few definitions:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    api Chitchat {
        say_hello:    String -&gt; Void;
        say_goodbye:  String -&gt; Void;
    };

    package p1: Chitchat {

        fun say_hello   string =  printf "Hi %s!\n"      string;
        fun say_goodbye string =  printf "Goodbye %s!\n" string;
    };

    package p2: Chitchat {

        include package   p1;

        fun say_hello   string =  printf "Well hello there, %s."  string;
    };
</PRE><P>Here we have dumped both function definitions from package <TT>p1</TT> 
into <TT>p2</TT> and then overriden just the definition of interest.</P><P>This can be a very economical mode of programming in a production setting 
where package <TT>p1</TT> may be very large and the changes to be made very 
small.</P><P>The same technique may be used to define a new API in terms of additions 
or changes to an existing one. Here we define an extended api and then 
a matching extended package:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    api Chitchat {
        say_hello:    String -&gt; Void;
        say_goodbye:  String -&gt; Void;
    };

    api Chitchattier {

        include api Chitchat;

        say_little:   String -&gt; Void;
    };

    package p1: Chitchat {

        fun say_hello   string =  printf "Hi %s!\n"      string;
        fun say_goodbye string =  printf "Goodbye %s!\n" string;
    };

    package p2: Chitchattier {

        include package   p1;

        fun say_little  string =  printf "Hot enough for you, %s?"  string;
    };
</PRE><P>This can be a very useful technique on large software projects.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mythryl_Packages__Strong_vs_Weak.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Call_CC_and_Soft_Thread_Programming.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
