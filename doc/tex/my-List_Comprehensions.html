<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>List Comprehensions</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mutually_Recursive_Functions_and_Datastructures.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Code_Reading_Interlude.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc72">5.3.7</A>  List Comprehensions</H3><P>
<A NAME="section:tut:delving-deeper:list-comprehensions"></A></P><P>You may be familiar from mathematics with notations such as 
{ <I>i</I><SUP>2</SUP> | 0 &lt; <I>i</I> &lt; 100, <I>i</I> &#X454; <I>Primes</I> } for the set 
containing the squares of all primes less than one hundred. 
This notation is technically termed a <I>set comprehension</I>. </P><P>A similar notation inspired by set comprehensions has recently 
become popular in programming languages ranging from Python to 
Ocaml. They define ordered lists rather than unordered sets, 
and are consequently termed <I>list comprehensions</I>.</P><P>Here is the Mythryl list comprehension corresponding to the 
above set comprehension:</P><PRE CLASS="verbatim">    linux$ my

    eval:  [ i*i for i in (1..99) where isprime i ];

    [1, 4, 9, 25, 49, 121, 169, 289, 361, 529, 841, 961, 1369, 
     1681, 1849, 2209, 2809, 3481, 3721, 4489, 5041, 5329, 6241, 
     6889, 7921, 9409]

</PRE><P>List comprehensions provide a compact, convenient way of generating 
lists of interesting values. Without list comprehensions, we would 
instead have had to write something like</P><PRE CLASS="verbatim">    loop (1..99, [])
    where
        fun loop ([], results)
                =&gt;
                reverse results;

            loop (i ! rest, results)
                =&gt;
                loop
                  ( rest,

                    isprime i   ??   i*i ! results
                                ::         results
                  );
        end;                
    end;                
</PRE><P>The underlying list comprehension syntax used above is</P><BLOCKQUOTE CLASS="quotation">
    [ <I>result-expression</I> <B>for</B> <I>pattern</I> <B>in</B> <I>list-expression</I> <B>where</B> <I>condition</I> ];
</BLOCKQUOTE><P>where
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>list-expression</I> is any Mythryl expression yielding a list;
</LI><LI CLASS="li-itemize"><I>pattern</I> is any Mythryl pattern which will match the members of that list;
</LI><LI CLASS="li-itemize"><I>condition</I> is any Mythryl Boolean expression selecting list elements;
</LI><LI CLASS="li-itemize"><I>result-expression</I> is any Mythryl expression over the values in <I>pattern</I>.
</LI></UL><P>In general there may be multiple <TT>for</TT> clauses, and the <TT>where</TT> clause 
is optional:</P><PRE CLASS="verbatim">    linux$ my

    eval:  [ (i,j)  for i in (0..4)  for j in (5..9) ];

    [ (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (1, 5), 
      (1, 6), (1, 7), (1, 8), (1, 9), (2, 5), (2, 6), 
      (2, 7), (2, 8), (2, 9), (3, 5), (3, 6), (3, 7), 
      (3, 8), (3, 9), (4, 5), (4, 6), (4, 7), (4, 8), 
      (4, 9) ]

</PRE><P>Here is an example of finding Pythagorean triples &#X2014; sets 
of three integers which could be the lengths of the sides of a 
right triangle:</P><PRE CLASS="verbatim">    linux$ my

    eval:  [ (x,y,z) for x in 1..20 for y in x..20 for z in y..20 where x*x + y*y == z*z ];

    [ (3, 4, 5), (5, 12, 13), (6, 8, 10), (8, 15, 17), (9, 12, 15), (12, 16, 20)]
</PRE><P>To show that list comprehensions are useful for 
more than just playing with numbers, here is an example 
more relevant to system administration. 
This one creates a list of <TT>(filename, filesize)</TT> pairs 
for all <TT>.pkg</TT> files under the current directory:</P><PRE CLASS="verbatim">    linux$ my

    eval:  [ (filename, (stat filename).size) for filename in dir_tree::files "." where filename =~ ./\\.pkg$/ ];

    [ ("/pub/home/cynbe/a/foo.pkg", 451), 
      ("/pub/home/cynbe/a/bar.pkg", 910) ]
</PRE><P>(For the curious, Mythryl list comprehensions are implemented primarily by 
<A HREF="my-src_lib_compiler_front_parser_raw-syntax_expand-list-comprehension-syntax_pkg.html#src/lib/compiler/front/parser/raw-syntax/expand-list-comprehension-syntax.pkg">src/lib/compiler/front/parser/raw-syntax/expand-list-comprehension-syntax.pkg</A>.)</P>
<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mutually_Recursive_Functions_and_Datastructures.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Code_Reading_Interlude.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
