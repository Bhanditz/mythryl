<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Thunk Syntax</TITLE>
</HEAD>
<BODY >
<A HREF="my-Anonymous_Functions.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Functions.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Curried_Functions.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc268">10.9.4</A>  Thunk Syntax</H3><P>
<A NAME="section:ref:functions:thunk-syntax"></A></P><P>A function which takes only <TT>Void</TT> as an argument 
is often called a <I>thunk</I>. (Legend has it that 
the name comes from Algol 68, in which they were 
used to implement call-by-name, the explanation 
being that that the called routine didn&#X2019;t have to 
think about the expression because the compiler had 
already "thunk" about it.)</P><P>Such functions are 
often used to encapsulate suspended computations which 
may be passed around or stored in datastructures and 
then later continued by invoking them with a void 
argument.</P><P>Thunks may be written easily enough using vanilla 
Mythryl anonymous function syntax:</P><PRE CLASS="verbatim">    linux$ cat my-script
    #!/usr/bin/mythryl

    thunk =   \\ () = print "Done!\n";

    thunk ();

    linux$ ./my-script
    Done!
</PRE><P>There are however times when even the above syntax can be 
annoying verbose; the <TT>fun () =</TT> prefix is visually 
distracting from the actual computation to be performed.</P><P>For such times Mythryl provides a special <I>thunk notation</I>, 
which looks just like a code block with a leading dot:</P><PRE CLASS="verbatim">    linux$ cat my-script
    #!/usr/bin/mythryl

    thunk =   {. print "Done!\n"; };

    thunk ();

    linux$ ./my-script
    Done!
</PRE><P>This syntax is entirely equivalent to the preceding 
anonymous function syntax, but is more compact and 
less distracting.</P><P>Mythryl thunk syntax does also support arguments.</P><P>Suppose for example that you wish to drop all nines 
from a list of integers. Package <TT>list</TT> provides 
a function <TT>list::filter</TT> which accepts a predicate 
function and a list and drops all list elements not 
satisfying the predicate function, which will do the 
job nicely:</P><PRE CLASS="verbatim">    linux$ my

    eval: filter  (\\ a = a != 9)  [ 1, 9, 2, 4, 9, 9 ];

    [1, 2, 4]
</PRE><P>The anonymous function syntax is however visually distracting 
here. Thunk syntax lets us do better:</P><PRE CLASS="verbatim">    linux$ my

    eval:  filter  {. #a != 9; }  [ 1, 9, 2, 4, 9, 9 ];

    [1, 2, 4]
</PRE><P>Here the # symbol marks the argument. This syntax is 
distinctly more readable than the vanilla anonymous function 
syntax.</P><P>Thunk syntax also supports multiple arguments, although in 
general if you need multiple arguments you should probably 
be writing a regular anonymous or named function. One 
nice application however is comparison function arguments 
to sort functions. For example the <TT>list_mergesort::sort</TT> 
function sorts a list according to a supplied comparison 
function. Suppose we wish to sort a list of strings by length:</P><PRE CLASS="verbatim">    linux$ my

    eval:  list_mergesort::sort  (\\ (a, b) = strlen(a) &gt; strlen(b))  [ "a", "def", "ab" ]; 

    ["a", "ab", "def"]
</PRE><P>This works fine, but again the anonymous-function syntax is 
somewhat distracting. Thunk syntax is more concise and readable:</P><PRE CLASS="verbatim">    linux$ my

    eval:  list_mergesort::sort  {. strlen(#a) &gt; strlen(#b); }  [ "a", "def", "ab" ]; 

    ["a", "ab", "def"]
</PRE><P>Thunk syntax is particularly useful when writing functions which 
are intended to mimic the functionality of compiler-implemented 
control structures:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    foreach [ "abc", "def", "ghi" ] {.
        printf "%s\n" #word;
    };

    linux$ ./my-script
    abc
    def
    ghi
</PRE><P>Here <TT>foreach</TT> is just a library function accepting two 
arguments:</P><PRE CLASS="verbatim">    fun foreach []         thunk =&gt;  ();
        foreach (a ! rest) thunk =&gt;  { thunk(a);   foreach rest thunk; };
    end;
</PRE><P>By using thunk syntax for the second argument we gain much of the compactness 
and convenience of a control construct built into the compiler.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Anonymous_Functions.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Functions.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Curried_Functions.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
