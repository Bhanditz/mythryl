<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Multi-file Projects: Libraries and API Definitions</TITLE>
</HEAD>
<BODY >
<A HREF="my-Prefix__Postfix_and_Circumfix_Operators.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Multi-file_Projects__Compiling_a_Stand-Alone_Executable.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc80">5.3.15</A>  Multi-file Projects: Libraries and API Definitions</H3><P>
<A NAME="section:tut:delving-deeper:libraries-and-apis"></A></P><P>One-file scripts are great for little system administration tasks 
and the like, but eventually you will want to write a serious 
application in Mythryl, and at that point you need to be able to 
divide the source code up logically between multiple files with 
cleanly defined interfaces between them. It is time we examined 
how to do that in Mythryl.</P><P>First we need to talk a little bit about API definition. Critical 
to the construction of any large software project is the concept 
of <I>implementation hiding</I>, of dividing the code up into modules 
which each expose to the external world only a simple, clean, 
well-defined interface. Code within each module can then be 
freely modified as long as the interface remains unchanged. 
This makes maintenance and evolution of large software systems 
enormously easier.</P><P>In Mythryl we define such module interfaces using the <TT>api</TT> 
construct.</P><P>Suppose for example that we want to create a library of functions to do useful 
things with Mythryl lists. We will call the library <TT>list_lib</TT> 
and in it we will define a function <TT>list_length</TT> which accepts 
a list of strings and returns the length of that list as an integer. 
This library will have various internal functions, but the only 
function it will export to the external world will be <TT>list_length</TT>.</P><P>We will implement this by writing an API which we will call 
<TT>List_Lib</TT>, which will define the external interface to our 
library:</P><PRE CLASS="verbatim">    api List_Lib {
        list_length:  List(String) -&gt; Int;
    };
</PRE><P>This says that the <TT>List_Lib</TT> api makes available to the external 
world a single function named <TT>list_length</TT> which accepts a 
list of strings and returns an integer.</P><P>Now we implement our library package proper:</P><PRE CLASS="verbatim">    package list_lib: List_Lib {

        # Private helper function for computing
        # list length.  Its second argument
        # counts the number of list elements
        # seen so far.  This is a common MythryL idiom:
        #
        fun length_helper (rest_of_list, nodes_seen)
            =
            if (rest_of_list == [])    nodes_seen;                                              # Done, return count. 
            else                       length_helper( tail(rest_of_list), nodes_seen + 1 );     # Count rest of list recursively.
            fi;

        fun list_length a_list
            =
            length_helper (a_list, 0);
    };
</PRE><P>The <TT>package list_lib: List_Lib</TT> looks like a package <SPAN STYLE="font-variant:small-caps">API</SPAN> declaration, 
but in fact it is a <I>package cast</I> which forces the external view of the 
<TT>list_lib</TT> package to be exactly that specified by the <TT>List_Lib</TT> <SPAN STYLE="font-variant:small-caps">API</SPAN> definition.</P><P>Here the <TT>length_helper</TT> helper function does all the real work, but 
it is not externally visible because we did not list it in our <TT>List_Lib</TT> 
api definition. This is a simple example of implementation hiding.</P><P>The <TT>list_length</TT> function is really just a wrapper around <TT>length_helper</TT>, 
but it is the only externally visible part of the package.</P><P>We can test our package and api using a little script:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    api List_Lib {
        list_length:  List(String) -&gt; Int;
    };

    package list_lib: List_Lib {

        # Private helper function for computing
        # list length.  Its second argument
        # counts the number of list elements
        # seen so far.  This is a common MythryL idiom:
        #
        fun length_helper (rest_of_list, nodes_seen)
            =
            if (rest_of_list == [])    nodes_seen;                                              # Done, return count. 
            else                       length_helper( tail(rest_of_list), nodes_seen + 1 );     # Count rest of list recursively.
            fi;

        fun list_length a_list
            =
            length_helper (a_list, 0);
    };

    printf "list length is %d\n"  (list_lib::list_length( ["abc", "def", "ghi"] ));
</PRE><P>When run, this yields</P><PRE CLASS="verbatim">    linux$ ./my-script
    list length is 3
    linux$ 
</PRE><P>But declaring an api and package within a script file was not the point; 
the point was to compile multi-file applications. To do that, save 
the package definition in a file named <TT>list-lib.pkg</TT>, the api 
declaration in a file named <TT>list-lib.api</TT> and create a file 
named <TT>list-lib.lib</TT> to control their compilation with contents 
as shown below, and compile the complete fileset interactively as shown:</P><PRE CLASS="verbatim">    linux$ cat list-lib.api

    api List_Lib {
        list_length:  List(String) -&gt; Int;
    };

    linux$ cat list-lib.pkg

    package list_lib: List_Lib {

        # Private helper function for computing
        # list length.  Its second argument
        # counts the number of list elements
        # seen so far.  This is a common MythryL idiom:
        #
        fun length_helper (rest_of_list, nodes_seen)
            =
            if (rest_of_list == [])    nodes_seen;                                              # Done, return count. 
            else                       length_helper( tail(rest_of_list), nodes_seen + 1 );     # Count rest of list recursively.
            fi;

        fun list_length a_list
            =
            length_helper (a_list, 0);
    };

    linux$ cat list-lib.lib

    LIBRARY_EXPORTS

            api List_Lib
            pkg list_lib

    LIBRARY_COMPONENTS

            $ROOT/src/lib/std/standard.lib

            list-lib.api
            list-lib.pkg


    linux$ my

    eval:  make "list-lib.lib";
        src/app/makelib/main/makelib-g.pkg:   Running   .lib file    list-lib.lib
          parse/libfile-parser-g.pkg:   Reading   make   file   list-lib.lib                                          on behalf of &lt;toplevel&gt;
    .../compile/compile-in-dependency-order-g.pkg:   Loading                 list-lib.api
    .../compile/compile-in-dependency-order-g.pkg:   Loading                 list-lib.pkg
        src/app/makelib/main/makelib-g.pkg:   New names added.

    TRUE

    eval:  makelib::show_all();

    Top-level definitions:
    [...]
    api List_Lib
    pkg list_lib
    val it

    ()

    eval:  list_lib::list_length( ["abc", "def", "ghi"] );

    3
</PRE><P>Here we used <TT>make "list-lib.lib";</TT> to compile and load our library, 
then we used <TT>makelib::show_all();</TT> to list all loaded packages and apis, 
verifying that <TT>List_Lib</TT> and <TT>list_lib</TT> were now present, and then 
invoked our library by evaluating <TT>list_lib::list_length( ["abc", "def", "ghi"] );</TT>, 
verifying that it returned the expected value of three.</P><P>The <TT>list-lib.lib</TT> file contents should be reasonably self-explanatory.</P><P>The <SPAN STYLE="font-variant:small-caps">LIBRARY_COMPONENTS</SPAN> section lists all source files which should be 
compiled to form the library, together with all the sub-libraries needed by 
those source files. You will probably always want to list the standard 
Mythryl libraries <CODE><TT>$ROOT/src/lib/std/standard.lib</TT></CODE> in this section; if 
you have additional sub-libraries of your own needed by the source files 
in this library, you will need to list them as well.</P><P>The <SPAN STYLE="font-variant:small-caps">LIBRARY_EXPORTS</SPAN> section lists all of the apis and packages which 
should be made externally visible to users of your package. Just as a 
package may have internal functions which are not made externally visible, 
so a complex library may have entire packages which are for internal use 
only and not made externally visible.</P><P>We shall have more to say about Mythryl libraries 
<A HREF="my-Library_Freezing.html#section:tut:full-monte:library-freezing">later</A> but right now it is time to learn how to compile stand-alone executables.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Prefix__Postfix_and_Circumfix_Operators.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Multi-file_Projects__Compiling_a_Stand-Alone_Executable.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
