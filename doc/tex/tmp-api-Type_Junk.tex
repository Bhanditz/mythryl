\index[api]{Type\_Junk}
\label{api:Type\_Junk}
\input{top-api-Type_Junk.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    equality_property_to_string : type_declaration_types::e::Is_Eqtype -> String;
        make_incomplete_record_typevar :
            (List(((symbol::Symbol , type_declaration_types::Typoid)) ) , Int)
            ->
            type_declaration_types::Typevar;
    make_user_typevar : symbol::Symbol -> type_declaration_types::Typevar;
        make_overloaded_literal_typevar :
            (type_declaration_types::Literal_Kind , line_number_db::Source_Code_Region , List(String ))
            ->
            type_declaration_types::Typoid;
    make_overloaded_typevar_and_type : List(String ) -> type_declaration_types::Typoid;
    make_meta_typevar_and_type : (Int , List(String )) -> type_declaration_types::Typoid;
    name_of_type : type_declaration_types::Type -> symbol::Symbol;
    stamp_of_type : type_declaration_types::Type -> stamp::Stamp;
    namepath_of_type : type_declaration_types::Type -> ?.inverse_path::Inverse_Path;
    stamppath_of_type : type_declaration_types::Type -> ?.stamppath::Stamppath;
    arity_of_type : type_declaration_types::Type -> Int;
        set_typepath :
        (type_declaration_types::Type , ?.inverse_path::Inverse_Path) -> type_declaration_types::Type;
    types_are_equal : (type_declaration_types::Type , type_declaration_types::Type) -> Bool;
        make_constructor_typoid :
            (type_declaration_types::Type , List(type_declaration_types::Typoid ))
            ->
            type_declaration_types::Typoid;
    drop_resolved_typevars : type_declaration_types::Typoid -> type_declaration_types::Typoid;
        same_typevar_ref :
        (type_declaration_types::Typevar_Ref , type_declaration_types::Typevar_Ref) -> Bool;
    resolve_typevars_to_typescheme_slots : List(type_declaration_types::Typevar_Ref ) -> Void;
        resolve_typevars_to_typescheme_slots_1 :
        List(type_declaration_types::Typevar_Ref ) -> type_declaration_types::Typescheme_Eqflags;
    exception BAD_TYPE_REDUCTION;
        map_constructor_typoid_dot_type :
            (type_declaration_types::Type -> type_declaration_types::Type)
            ->
            type_declaration_types::Typoid -> type_declaration_types::Typoid;
        apply_typescheme :
            (type_declaration_types::Typescheme , List(type_declaration_types::Typoid ))
            ->
            type_declaration_types::Typoid;
    reduce_typoid : type_declaration_types::Typoid -> type_declaration_types::Typoid;
    head_reduce_typoid : type_declaration_types::Typoid -> type_declaration_types::Typoid;
    typoids_are_equal : (type_declaration_types::Typoid , type_declaration_types::Typoid) -> Bool;
    type_equality : (type_declaration_types::Type , type_declaration_types::Type) -> Bool;
    make_typeagnostic_api : Int -> type_declaration_types::Typescheme_Eqflags;
    sumtype_to_type : type_declaration_types::Valcon -> type_declaration_types::Type;
        sumtype_to_typoid :
            (type_declaration_types::Type , Null_Or(type_declaration_types::Typoid ))
            ->
            type_declaration_types::Typoid;
        match_typescheme :
            (type_declaration_types::Typescheme , type_declaration_types::Typoid)
            ->
            type_declaration_types::Typoid;
    drop_macro_expanded_indirections_from_type : type_declaration_types::Typoid -> Void;
        instantiate_if_typescheme :
            (type_declaration_types::Typoid , symbolmapstack::Symbolmapstack , List(String ))
            ->
            (type_declaration_types::Typoid , List(type_declaration_types::Typoid ));
        pkg_typoid_matches_api_typoid :
        {type_per_api:type_declaration_types::Typoid, type_per_pkg:type_declaration_types::Typoid} -> Bool;
    typevar_of_typoid : type_declaration_types::Typoid -> type_declaration_types::Typevar_Ref;
    get_recursive_typevar_map : (Int , type_declaration_types::Typoid) -> Int -> Bool;
    label_is_greater_than : (symbol::Symbol , symbol::Symbol) -> Bool;
        is_value :
            {inlining_data_says_it_is_pure:inlining_data::Inlining_Data -> Bool}
            ->
            deep_syntax::Deep_Expression -> Bool;
    is_variable_typoid : type_declaration_types::Typoid -> Bool;
        sort_fields :
        List(((deep_syntax::Numbered_Label , X)) ) -> List(((deep_syntax::Numbered_Label , X)) );
    map_unzip : (X -> (Y , Z)) -> List(X ) -> (List(Y ) , List(Z ));
    Typeset;
    make_typeset : Void -> Typeset;
    insert_type_into_typeset : (type_declaration_types::Type , Typeset) -> Typeset;
    filter_typeset : (type_declaration_types::Typoid , Typeset) -> List(type_declaration_types::Type );
    sumtype_sibling : (Int , type_declaration_types::Type) -> type_declaration_types::Type;
    extract_sumtype : type_declaration_types::Type -> List(type_declaration_types::Valcon );
    wrap_definition : (type_declaration_types::Type , stamp::Stamp) -> type_declaration_types::Type;
    unwrap_definition_1 : type_declaration_types::Type -> Null_Or(type_declaration_types::Type );
    unwrap_definition_star : type_declaration_types::Type -> type_declaration_types::Type;};
\end{verbatim}\index[fun]{unwrap\_definition\_star}
\index[fun]{unwrap\_definition\_1}
\index[fun]{wrap\_definition}
\index[fun]{extract\_sumtype}
\index[fun]{sumtype\_sibling}
\index[fun]{filter\_typeset}
\index[fun]{insert\_type\_into\_typeset}
\index[fun]{make\_typeset}
\index[fun]{map\_unzip}
\index[fun]{sort\_fields}
\index[fun]{is\_variable\_typoid}
\index[fun]{is\_value}
\index[fun]{label\_is\_greater\_than}
\index[fun]{get\_recursive\_typevar\_map}
\index[fun]{typevar\_of\_typoid}
\index[fun]{pkg\_typoid\_matches\_api\_typoid}
\index[fun]{instantiate\_if\_typescheme}
\index[fun]{drop\_macro\_expanded\_indirections\_from\_type}
\index[fun]{match\_typescheme}
\index[fun]{sumtype\_to\_typoid}
\index[fun]{sumtype\_to\_type}
\index[fun]{make\_typeagnostic\_api}
\index[fun]{type\_equality}
\index[fun]{typoids\_are\_equal}
\index[fun]{head\_reduce\_typoid}
\index[fun]{reduce\_typoid}
\index[fun]{apply\_typescheme}
\index[fun]{map\_constructor\_typoid\_dot\_type}
\index[fun]{resolve\_typevars\_to\_typescheme\_slots\_1}
\index[fun]{resolve\_typevars\_to\_typescheme\_slots}
\index[fun]{same\_typevar\_ref}
\index[fun]{drop\_resolved\_typevars}
\index[fun]{make\_constructor\_typoid}
\index[fun]{types\_are\_equal}
\index[fun]{set\_typepath}
\index[fun]{arity\_of\_type}
\index[fun]{stamppath\_of\_type}
\index[fun]{namepath\_of\_type}
\index[fun]{stamp\_of\_type}
\index[fun]{name\_of\_type}
\index[fun]{make\_meta\_typevar\_and\_type}
\index[fun]{make\_overloaded\_typevar\_and\_type}
\index[fun]{make\_overloaded\_literal\_typevar}
\index[fun]{make\_user\_typevar}
\index[fun]{make\_incomplete\_record\_typevar}
\index[fun]{equality\_property\_to\_string}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
