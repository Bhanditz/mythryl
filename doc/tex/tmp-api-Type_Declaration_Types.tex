\index[api]{Type\_Declaration\_Types}
\label{api:Type\_Declaration\_Types}
\input{top-api-Type_Declaration_Types.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    Label;
    Typescheme_Eqflags;
        package e
          : api {
                Is_Eqtype  = CHUNK | DATA | INDETERMINATE | NO | UNDEF | YES;};;
    Literal_Kind  = CHAR | FLOAT | INT | STRING | UNT;
        Typevar
        = INCOMPLETE_RECORD_TYPEVAR
        {eq:Bool, fn_nesting:Int, known_fields:List(((Label , Typoid)) )}
        |
        LITERAL_TYPEVAR
        {kind:Literal_Kind, source_code_region:line_number_db::Source_Code_Region}
        |
        META_TYPEVAR
        {eq:Bool, fn_nesting:Int}
        |
        OVERLOADED_TYPEVAR
        Bool
        |
        RESOLVED_TYPEVAR
        Typoid
        |
        TYPEVAR_MARK
        Int
        |
        USER_TYPEVAR
        {eq:Bool, fn_nesting:Int, name:symbol::Symbol};
        Typepath
        = TYPEPATH_APPLY
        (Typepath , List(Typepath ))
        |
        TYPEPATH_GENERIC
        (List(Typepath ) , List(Typepath ))
        |
        TYPEPATH_SELECT
        (Typepath , Int)
        |
        TYPEPATH_TYPE
        Type
        |
        TYPEPATH_VARIABLE
        Exception;
        Typekind
        = ABSTRACT
        Type
        |
        BASE
        Int
        |
        FLEXIBLE_TYPE
        Typepath
        |
        FORMAL
        |
        SUMTYPE {family:Sumtype_Family, free_types:List(Type ), index:Int, root:Null_Or(stamp::Stamp ),
                stamps:?.Vector(stamp::Stamp )}
        |
        TEMP;
        Type
        = ERRONEOUS_TYPE
        |
        FREE_TYPE
        Int
        |
        NAMED_TYPE
                {namepath:?.inverse_path::Inverse_Path, stamp:stamp::Stamp, strict:List(Bool ),
                typescheme:Typescheme}
        |
        RECORD_TYPE
        List(Label )
        |
        RECURSIVE_TYPE
        Int
        |
        SUM_TYPE
        Sumtype_Record
        |
        TYPE_BY_STAMPPATH
        {arity:Int, namepath:?.inverse_path::Inverse_Path, stamppath:?.stamppath::Stamppath};
        Typoid
        = TYPCON_TYPOID
        (Type , List(Typoid ))
        |
        TYPESCHEME_ARG
        Int
        |
        TYPESCHEME_TYPOID
        {typescheme:Typescheme, typescheme_eqflags:Typescheme_Eqflags}
        |
        TYPEVAR_REF
        Typevar_Ref
        |
        UNDEFINED_TYPOID
        |
        WILDCARD_TYPOID;
    Typescheme  = TYPESCHEME {arity:Int, body:Typoid};
    Valcon_Info  = {domain:Null_Or(Typoid ), form:varhome::Valcon_Form, name:symbol::Symbol};
          Sumtype_Member  =
                {an_api:varhome::Valcon_Signature, arity:Int, is_eqtype:Ref(e::Is_Eqtype ), is_lazy:Bool,
                name_symbol:symbol::Symbol, valcons:List(Valcon_Info )};
          Sumtype_Family  =
          {members:?.Vector(Sumtype_Member ), mkey:stamp::Stamp, property_list:property_list::Property_List};
    Stub_Info  = {is_lib:Bool, owner:picklehash::Picklehash};
          Sumtype_Record  =
                {arity:Int, is_eqtype:Ref(e::Is_Eqtype ), kind:Typekind, namepath:?.inverse_path::Inverse_Path,
                stamp:stamp::Stamp, stub:Null_Or(Stub_Info )};
    Typevar_Ref  = {id:Int, ref_typevar:Ref(Typevar )};
    infinity : Int;
    copy_typevar_ref : Typevar_Ref -> Typevar_Ref;
    make_typevar_ref : (Typevar , List(String )) -> Typevar_Ref;
    make_typevar_ref' : (Ref(Typevar ) , List(String )) -> Typevar_Ref;
        Valcon
        = VALCON        {form:varhome::Valcon_Form, is_constant:Bool, is_lazy:Bool, name:symbol::Symbol,
                        signature:varhome::Valcon_Signature, typoid:Typoid};};
\end{verbatim}\index[fun]{make\_typevar\_ref\_\_prime\_\_}
\index[fun]{make\_typevar\_ref}
\index[fun]{copy\_typevar\_ref}
\index[fun]{infinity}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
