<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Script Structure</TITLE>
</HEAD>
<BODY >
<A HREF="my-Printf_Sprintf_Fprintf.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Coding_Conventions.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H2 CLASS="section"><A NAME="htoc307">12.1</A>  Script Structure</H2><P>The recommended script structure is to start the script 
with any statements which modify the global environment, 
followed by the body of the script enclosed in braces: </P><PRE CLASS="verbatim">            #!/usr/bin/mythryl 

            global_environment_changing_statement (); 

            { 
                main_body_of_script (); 
            }; 
</PRE><P>The idea behind this structure is: </P><UL CLASS="itemize"><LI CLASS="li-itemize">
Wrapping the main body of the script in braces makes it compile as a unit. 
This allows implicit type information to propagate freely through the script 
body, minimizing the number of obscure compiler type errors due to insufficient 
type information. 
</LI><LI CLASS="li-itemize">But any calls which change the global environment must be above the script 
body block, because they must compile and execute independently of the script 
body if the environment changes are to be visible within the script body. 
</LI></UL><P>The only call most programmers are likely to use often 
which changes the global environment is the <TT>load</TT> command 
to load a library and make it available to the script, so in 
practice the above structure will usually reduce to something like </P><PRE CLASS="verbatim">            #!/usr/bin/mythryl 
            #
            load "foo.lib";
            load "bar.lib";
            load "zot.lib";
            ...                                 # Meta-notation for more load commands.
            #
            { 
                ...                             # Meta-notation for unshown code.
                foo::something();
                ...                             # Meta-notation for unshown code.
                zot::mumble();
                ...                             # Meta-notation for unshown code.
                bar::whatever();
                ...                             # Meta-notation for unshown code.
            }; 
</PRE><P>Many scripts will of course need only <TT>standard.lib</TT>, which is loaded by 
default, and consequently will not need any <TT>load</TT> commands at all, reducing 
the above structure to just</P><PRE CLASS="verbatim">            #!/usr/bin/mythryl 
            #
            { 
                ...                             # Meta-notation for unshown code.
            }; 
</PRE><P>For a working example of defining a custom library and then 
using it from a script see <TT>src/app/tut/factor/use-lib-from-script-demo</TT> in 
the Mythryl source code distribution.</P><P>For a tutorial on defining libraries in Mythryl see 
<A HREF="my-Multi-file_Projects__Libraries_and_API_Definitions.html#section:tut:delving-deeper:libraries-and-apis">Multi-file Projects: Libraries and API Definitions</A>.</P>
<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Printf_Sprintf_Fprintf.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Coding_Conventions.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
