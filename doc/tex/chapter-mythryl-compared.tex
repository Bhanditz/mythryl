\chapter{Mythryl Compared}

% ================================================================================
% This chapter is referenced in:
%
%     doc/tex/book.tex
%

% ================================================================================
\section{Contents}

How does Mythryl compare to other programming languages?

Programming languages may be ranked along many dimensions.  Here we 
describe its position and neighbors along some of the more interesting 
dimensions.

% ================================================================================

\section{Place on the Purity Spectrum.}

The {\it functional programming} community is centrally concerned with 
side effects, and in particular avoiding side effects, because expressions 
without side effects obey the fundamental rule that ``equals may be substituted 
for equals'' upon which much algebraic reasoning is based.  Languages or 
portions of a program which obey this rule should be that much easier 
to understand, reason about and modify.  Code which uses no side effects 
is termed {\it pure};  other code is termed {\it impure}.

The impure end of the programming language spectrum is anchored by 
older languages like Pascal, C and Lisp which side-effects in almost 
every statement.  In general every field of every C record is writable 
and likely to actually get written from time to time.  Such languages are 
often termed {\tt imperative};  minimizing use of side-effects was not a 
goal in their design.  (In part because they were designed in an era of 
small machines and small programs;  taming the complexity of million-line 
programs was not an issue back then.)

The pure end of the programming language spectrum is anchored by pure-functional 
languages such as Haskell which completely forbid the use of side-effects, or 
at any rate side-effects as we know them.  This complete freedom from side-effects 
yields some benefits such as the ability to write fully lazy code.  However, having 
to completely avoid use of algorithms which depend upon side-effects is a major 
constraint upon the programmer;  for many problems the best known algorithms require 
the use of side effects.  Simon Peyton-Jones refers to programming under this strict 
constraint as {\it "wearing the hair shirt"}.

Mythryl sits at neither end of the purity spectrum, but instead within it, 
closest to the pure end.  Mythryl does allow the use of side effects, but 
typical Mythryl programs use only about one percent as many side-effects 
as a typical C program.  This means that, assuming equal programmer skill, 
Mythryl programs should experience only about one percent as many side-effect 
related bugs (such as race conditions) as an equivalent C++ or Java program.

% ================================================================================

\section{Language Relatives.}

The Mythryl codebase is a rewritten fork of the {\sc SML/NJ} codebase so {\sc SML} 
in general and {\sc SML/NJ} in particular are Mythryl's closest relatives.

The {\sc SML} language is the largest member of the {\sc ML} family which includes 
many research languages, of which the most-used is far and away Ocaml, which has 
a large and active userbase and has seen significant commercial application.  The 
remaining members of the family are by and large the kind of language created as 
part of a doctoral project, with userbase largely limited to a few academics 
working on similar problems.

Pure-functional languages, of which by far the best-known and most-used is 
Haskell, form a separate language family closely related to the {\sc ML} 
language family.  Most researchers work primarily within one family or the 
other, but follow papers published about both families, as many tools, 
techniques and research problems are common to the two families.  In particular, 
the type systems are broadly similar, have been a very active research area for 
several decades, and seem likely to continue to be so for decades to come.

Functional languages in general are derived from the typed lambda 
calculus which Alonzo Church developed in the 1930s.  The Lisp 
family of languages is based upon his earlier untyped lambda calculus, 
developed in the 1920s.  There two calculi are closely related, and 
consequently there are strong affinities between the Lisp language 
family and the functional programming language family.  (Pure lisp 
is in fact arguably the first pure-functional programming language, 
although in practice most Lisp is written in the imperative style.)

This affinity is strongest between the Scheme end of the the Lisp 
family and the mostly-functional end of the functional programming 
language family;  for example researchers working on Scheme and SML 
will often reference each other's papers.

In the applied world programming languages are increasingly adopting 
ideas and techniques taken from the ML family.  For example in the Perl world 
Perl6 is scheduled to use ML-style Hindley-Milner typechecking and to support various 
other ML-flavored constructs.  The Java world offers languages like Scala;  the 
{\sc .NET} world languages like F\#.

Among the most distant of Mythryl's functional kindred are J and the 
rest of the APL language family.  The APL programming style in general 
is in fact pure-functional in spirit, centering on computation via 
side-effect free expressions, and J in particular has taken on additional 
functional programming flavoring during its evolution.

Beyond this, Mythryl's relatives blend indistinguishably into the 
broader world of programming languages.  Many languages not normally 
thought of as functional have in fact a fairly strong functional 
element in their constitution.  For example Perl (unlike C!) treats 
strings in an entirely pure fashion, always constructing new 
strings rather than modifying old strings.

Almost any language can be used in a mostly-functional style if one 
chooses, sometimes with significant gains in code maintainability and 
debuggability, just as the object-oriented approach to programming, 
once mastered, may be put to work in almost any language, independent 
of whether that language is officially "object oriented".




