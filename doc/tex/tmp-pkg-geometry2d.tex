\index[pkg]{geometry2d}
\label{pkg:geometry2d}
\input{top-pkg-geometry2d.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    bounding_box : List({col:Int, row:Int} ) -> {col:Int, high:Int, row:Int, wide:Int};
    convex_hull : List(Point ) -> List(Point );
    point_in_polygon : (Point , List(Point )) -> Bool;
    site_to_box : Window_Site -> {col:Int, high:Int, row:Int, wide:Int};
    valid_arc : {angle1:Int, angle2:Int, col:Int, high:Int, row:Int, wide:Int} -> Bool;
    valid_box : {col:Int, high:Int, row:Int, wide:Int} -> Bool;
    valid_line : Line -> Bool;
    valid_point : {col:Int, row:Int} -> Bool;
    valid_site : Window_Site -> Bool;
    valid_size : {high:Int, wide:Int} -> Bool;
    Arc  = {col:Int, fill_angle:Float, high:Int, row:Int, start_angle:Float, wide:Int};
    Arc64  = {angle1:Int, angle2:Int, col:Int, high:Int, row:Int, wide:Int};
    Box  = {col:Int, high:Int, row:Int, wide:Int};
    Line  = (Point , Point);
    Point  = {col:Int, row:Int};
    Size  = {high:Int, wide:Int};
    Window_Site  = {border_thickness:Int, size:Size, upperleft:Point};
        package box
          : api {
                area : Box -> Int;
                bisect_box_horizontally : (Box , Point , Point) -> List({col:Int, high:Int, row:Int, wide:Int} );
                bisect_box_vertically : (Box , Point , Point) -> List({col:Int, high:Int, row:Int, wide:Int} );
                    bisect_boxes_horizontally :
                    (List(Box ) , Point , Point) -> List({col:Int, high:Int, row:Int, wide:Int} );
                    bisect_boxes_vertically :
                    (List(Box ) , Point , Point) -> List({col:Int, high:Int, row:Int, wide:Int} );
                    box_a_in_box_b :
                    {a:{col:Int, high:Int, row:Int, wide:Int}, b:{col:Int, high:Int, row:Int, wide:Int}} -> Bool;
                    box_corners :
                        Box
                        ->  {lower_left:{col:Int, row:Int}, lower_right:{col:Int, row:Int}, upper_left:{col:Int, row:Int},
                            upper_right:{col:Int, row:Int}};
                clip_point : ({col:Int, high:Int, row:Int, wide:Int} , {col:Int, row:Int}) -> {col:Int, row:Int};
                clone_box_at : (Box , Point) -> {col:Int, high:Int, row:Int, wide:Int};
                eq : ({col:''a, high:''b, row:''c, wide:''d} , {col:''a, high:''b, row:''c, wide:''d}) -> Bool;
                horizontal_lineseg_intersects_box : (Box , Point , Point) -> Bool;
                    intersect :
                    ({col:Int, high:Int, row:Int, wide:Int} , {col:Int, high:Int, row:Int, wide:Int}) -> Bool;
                intersect_box_with_boxes : (Box , List(Box )) -> List(Box );
                intersect_boxes_with_boxes : (List(Box ) , List(Box )) -> List(Box );
                    intersection :
                        ({col:Int, high:Int, row:Int, wide:Int} , {col:Int, high:Int, row:Int, wide:Int})
                        ->
                        Null_Or({col:Int, high:Int, row:Int, wide:Int} );
                lowerright : Box -> {col:Int, row:Int};
                lowerright1 : {col:Int, high:Int, row:Int, wide:Int} -> {col:Int, row:Int};
                make : ({col:X, row:Y} , {high:Z, wide:A}) -> {col:X, high:Z, row:Y, wide:A};
                make_nested_box : (Box , Int) -> Box;
                midpoint : {col:Int, high:Int, row:Int, wide:Int} -> {col:Int, row:Int};
                ne : ({col:''a, high:''b, row:''c, wide:''d} , {col:''a, high:''b, row:''c, wide:''d}) -> Bool;
                point_in_box : ({col:Int, row:Int} , {col:Int, high:Int, row:Int, wide:Int}) -> Bool;
                point_on_box_perimeter : ({col:Int, row:Int} , {col:Int, high:Int, row:Int, wide:Int}) -> Bool;
                quadsect_box : (Box , Point) -> List(Box );
                quadsect_boxes : (List(Box ) , Point) -> List(Box );
                    rtranslate :
                    ({col:Int, high:X, row:Int, wide:Y} , {col:Int, row:Int}) -> {col:Int, high:X, row:Int, wide:Y};
                size : Box -> {high:Int, wide:Int};
                subtract_box_b_from_box_a : {a:Box, b:Box} -> List({col:Int, high:Int, row:Int, wide:Int} );
                subtract_boxes_b_from_boxes_a : {a:List(Box ), b:List(Box )} -> List(Box );
                to_points : Box -> List({col:Int, row:Int} );
                    translate :
                    ({col:Int, high:X, row:Int, wide:Y} , {col:Int, row:Int}) -> {col:Int, high:X, row:Int, wide:Y};
                    union :
                        ({col:Int, high:Int, row:Int, wide:Int} , {col:Int, high:Int, row:Int, wide:Int})
                        ->
                        {col:Int, high:Int, row:Int, wide:Int};
                upperleft : Box -> {col:Int, row:Int};
                upperleft_and_size : {col:X, high:Y, row:Z, wide:A} -> ({col:X, row:Z} , {high:Y, wide:A});
                vertical_lineseg_intersects_box : (Box , Point , Point) -> Bool;
                    xor :
                        ({col:Int, high:Int, row:Int, wide:Int} , {col:Int, high:Int, row:Int, wide:Int})
                        ->
                        List({col:Int, high:Int, row:Int, wide:Int} );
                zero : {col:Int, high:Int, row:Int, wide:Int};};;
        package line
          : api {   intersection :
                        ((({col:Int, row:Int} , {col:Int, row:Int})) , (({col:Int, row:Int} , {col:Int, row:Int})))
                        ->
                        Null_Or({col:Int, row:Int} );
                    rotate_90_degrees_counterclockwise :
                    ({col:Int, row:Int} , {col:Int, row:Int}) -> ({col:Int, row:Int} , {col:Int, row:Int});};;
        package point
          : api {
                add : ({col:Int, row:Int} , {col:Int, row:Int}) -> {col:Int, row:Int};
                add_size : ({col:Int, row:Int} , {high:Int, wide:Int}) -> {col:Int, row:Int};
                clip : ({col:Int, row:Int} , {high:Int, wide:Int}) -> {col:Int, row:Int};
                col : Point -> Int;
                compare_xy : (Point , Point) -> Order;
                eq : ({col:''a, row:''b} , {col:''a, row:''b}) -> Bool;
                ge : ({col:Int, row:Int} , {col:Int, row:Int}) -> Bool;
                gt : ({col:Int, row:Int} , {col:Int, row:Int}) -> Bool;
                in_box : ({col:Int, row:Int} , {col:Int, high:Int, row:Int, wide:Int}) -> Bool;
                le : ({col:Int, row:Int} , {col:Int, row:Int}) -> Bool;
                lt : ({col:Int, row:Int} , {col:Int, row:Int}) -> Bool;
                mean : List(Point ) -> {col:Int, row:Int};
                ne : ({col:''a, row:''b} , {col:''a, row:''b}) -> Bool;
                row : Point -> Int;
                scale : ({col:Int, row:Int} , Int) -> {col:Int, row:Int};
                subtract : ({col:Int, row:Int} , {col:Int, row:Int}) -> {col:Int, row:Int};
                zero : {col:Int, row:Int};};;
        package size
          : api {
                add : ({high:Int, wide:Int} , {high:Int, wide:Int}) -> {high:Int, wide:Int};
                eq : ({high:''a, wide:''b} , {high:''a, wide:''b}) -> Bool;
                scale : ({high:Int, wide:Int} , Int) -> {high:Int, wide:Int};
                subtract : ({high:Int, wide:Int} , {high:Int, wide:Int}) -> {high:Int, wide:Int};};;};
\end{verbatim}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
