\index[api]{Raw\_Syntax}
\label{api:Raw\_Syntax}
\input{top-api-Raw_Syntax.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    Fixity;
    Symbol;
    infixleft : Int -> Fixity;
    infixright : Int -> Fixity;
    Literal  = multiword_int::Int;
    Source_Code_Position  = Int;
    Source_Code_Region  = (Source_Code_Position , Source_Code_Position);
    Path  = List(Symbol );
    Fixity_Item X = {fixity:Null_Or(Symbol ), item:X, source_code_region:Source_Code_Region};
        Package_Cast
        X = NO_PACKAGE_CAST | PARTIAL_PACKAGE_CAST X | STRONG_PACKAGE_CAST X | WEAK_PACKAGE_CAST X;
    Fun_Kind  = MESSAGE_FUN | METHOD_FUN | PLAIN_FUN;
    Package_Kind  = CLASS2_PACKAGE | CLASS_PACKAGE | PLAIN_PACKAGE;
        Raw_Expression
        = AND_EXPRESSION
        (Raw_Expression , Raw_Expression)
        |
        APPLY_EXPRESSION
        {argument:Raw_Expression, function:Raw_Expression}
        |
        CASE_EXPRESSION
        {expression:Raw_Expression, rules:List(Case_Rule )}
        |
        CHAR_CONSTANT_IN_EXPRESSION
        String
        |
        EXCEPT_EXPRESSION
        {expression:Raw_Expression, rules:List(Case_Rule )}
        |
        FLOAT_CONSTANT_IN_EXPRESSION
        String
        |
        FN_EXPRESSION
        List(Case_Rule )
        |
        IF_EXPRESSION
        {else_case:Raw_Expression, test_case:Raw_Expression, then_case:Raw_Expression}
        |
        IMPLICIT_THUNK_PARAMETER
        Path
        |
        INT_CONSTANT_IN_EXPRESSION
        Literal
        |
        LET_EXPRESSION
        {declaration:Declaration, expression:Raw_Expression}
        |
        LIST_EXPRESSION
        List(Raw_Expression )
        |
        OBJECT_FIELD_EXPRESSION
        {field:Symbol, object:Raw_Expression}
        |
        OR_EXPRESSION
        (Raw_Expression , Raw_Expression)
        |
        PRE_FIXITY_EXPRESSION
        List(Fixity_Item(Raw_Expression ) )
        |
        RAISE_EXPRESSION
        Raw_Expression
        |
        RECORD_IN_EXPRESSION
        List(((Symbol , Raw_Expression)) )
        |
        RECORD_SELECTOR_EXPRESSION
        Symbol
        |
        SEQUENCE_EXPRESSION
        List(Raw_Expression )
        |
        SOURCE_CODE_REGION_FOR_EXPRESSION
        (Raw_Expression , Source_Code_Region)
        |
        STRING_CONSTANT_IN_EXPRESSION
        String
        |
        TUPLE_EXPRESSION
        List(Raw_Expression )
        |
        TYPE_CONSTRAINT_EXPRESSION
        {constraint:Any_Type, expression:Raw_Expression}
        |
        UNT_CONSTANT_IN_EXPRESSION
        Literal
        |
        VARIABLE_IN_EXPRESSION
        Path
        |
        VECTOR_IN_EXPRESSION
        List(Raw_Expression )
        |
        WHILE_EXPRESSION
        {expression:Raw_Expression, test:Raw_Expression};
    Case_Rule  = CASE_RULE {expression:Raw_Expression, pattern:Case_Pattern};
        Case_Pattern
        = APPLY_PATTERN
        {argument:Case_Pattern, constructor:Case_Pattern}
        |
        AS_PATTERN
        {expression_pattern:Case_Pattern, variable_pattern:Case_Pattern}
        |
        CHAR_CONSTANT_IN_PATTERN
        String
        |
        INT_CONSTANT_IN_PATTERN
        Literal
        |
        LIST_PATTERN
        List(Case_Pattern )
        |
        OR_PATTERN
        List(Case_Pattern )
        |
        PRE_FIXITY_PATTERN
        List(Fixity_Item(Case_Pattern ) )
        |
        RECORD_PATTERN
        {definition:List(((Symbol , Case_Pattern)) ), is_incomplete:Bool}
        |
        SOURCE_CODE_REGION_FOR_PATTERN
        (Case_Pattern , Source_Code_Region)
        |
        STRING_CONSTANT_IN_PATTERN
        String
        |
        TUPLE_PATTERN
        List(Case_Pattern )
        |
        TYPE_CONSTRAINT_PATTERN
        {pattern:Case_Pattern, type_constraint:Any_Type}
        |
        UNT_CONSTANT_IN_PATTERN
        Literal
        |
        VARIABLE_IN_PATTERN
        Path
        |
        VECTOR_PATTERN
        List(Case_Pattern )
        |
        WILDCARD_PATTERN;
        Package_Expression
        = CALL_OF_GENERIC
        (Path , List(((Package_Expression , Bool)) ))
        |
        INTERNAL_CALL_OF_GENERIC
        (Path , List(((Package_Expression , Bool)) ))
        |
        LET_IN_PACKAGE
        (Declaration , Package_Expression)
        |
        PACKAGE_BY_NAME
        Path
        |
        PACKAGE_CAST
        (Package_Expression , Package_Cast(Api_Expression ))
        |
        PACKAGE_DEFINITION
        Declaration
        |
        SOURCE_CODE_REGION_FOR_PACKAGE
        (Package_Expression , Source_Code_Region);
        Generic_Expression
        = CONSTRAINED_CALL_OF_GENERIC
        (Path , List(((Package_Expression , Bool)) ) , Package_Cast(Generic_Api_Expression ))
        |
        GENERIC_BY_NAME
        (Path , Package_Cast(Generic_Api_Expression ))
        |
        GENERIC_DEFINITION
                {body:Package_Expression, constraint:Package_Cast(Api_Expression ),
                parameters:List(((Null_Or(Symbol ) , Api_Expression)) )}
        |
        LET_IN_GENERIC
        (Declaration , Generic_Expression)
        |
        SOURCE_CODE_REGION_FOR_GENERIC
        (Generic_Expression , Source_Code_Region);
        Api_Expression
        = API_BY_NAME
        Symbol
        |
        API_DEFINITION
        List(Api_Element )
        |
        API_WITH_WHERE_SPECS
        (Api_Expression , List(Where_Spec ))
        |
        SOURCE_CODE_REGION_FOR_API
        (Api_Expression , Source_Code_Region);
        Where_Spec
        = WHERE_PACKAGE
        (List(Symbol ) , List(Symbol ))
        |
        WHERE_TYPE
        (List(Symbol ) , List(Typevar ) , Any_Type);
        Generic_Api_Expression
        = GENERIC_API_BY_NAME
        Symbol
        |
        GENERIC_API_DEFINITION
        {parameter:List(((Null_Or(Symbol ) , Api_Expression)) ), result:Api_Expression}
        |
        SOURCE_CODE_REGION_FOR_GENERIC_API
        (Generic_Api_Expression , Source_Code_Region);
        Api_Element
        = EXCEPTIONS_IN_API
        List(((Symbol , Null_Or(Any_Type ))) )
        |
        GENERICS_IN_API
        List(((Symbol , Generic_Api_Expression)) )
        |
        IMPORT_IN_API
        Api_Expression
        |
        PACKAGES_IN_API
        List(((Symbol , Api_Expression , Null_Or(Path ))) )
        |
        PACKAGE_SHARING_IN_API
        List(Path )
        |
        SOURCE_CODE_REGION_FOR_API_ELEMENT
        (Api_Element , Source_Code_Region)
        |
        TYPES_IN_API
        (List(((Symbol , List(Typevar ) , Null_Or(Any_Type ))) ) , Bool)
        |
        TYPE_SHARING_IN_API
        List(Path )
        |
        VALCONS_IN_API
        {sumtypes:List(Sumtype ), with_types:List(Named_Type )}
        |
        VALUES_IN_API
        List(((Symbol , Any_Type)) );
        Declaration
        = API_DECLARATIONS
        List(Named_Api )
        |
        EXCEPTION_DECLARATIONS
        List(Named_Exception )
        |
        FIELD_DECLARATIONS
        (List(Named_Field ) , List(Typevar ))
        |
        FIXITY_DECLARATIONS
        {fixity:Fixity, ops:List(Symbol )}
        |
        FUNCTION_DECLARATIONS
        (List(Named_Function ) , List(Typevar ))
        |
        GENERIC_API_DECLARATIONS
        List(Named_Generic_Api )
        |
        GENERIC_DECLARATIONS
        List(Named_Generic )
        |
        INCLUDE_DECLARATIONS
        List(Path )
        |
        LOCAL_DECLARATIONS
        (Declaration , Declaration)
        |
        NADA_FUNCTION_DECLARATIONS
        (List(Nada_Named_Function ) , List(Typevar ))
        |
        OVERLOADED_VARIABLE_DECLARATION
        (Symbol , Any_Type , List(Raw_Expression ) , Bool)
        |
        PACKAGE_DECLARATIONS
        List(Named_Package )
        |
        PRE_COMPILE_CODE
        String
        |
        RECURSIVE_VALUE_DECLARATIONS
        (List(Named_Recursive_Value ) , List(Typevar ))
        |
        SEQUENTIAL_DECLARATIONS
        List(Declaration )
        |
        SOURCE_CODE_REGION_FOR_DECLARATION
        (Declaration , Source_Code_Region)
        |
        SUMTYPE_DECLARATIONS
        {sumtypes:List(Sumtype ), with_types:List(Named_Type )}
        |
        TYPE_DECLARATIONS
        List(Named_Type )
        |
        VALUE_DECLARATIONS
        (List(Named_Value ) , List(Typevar ));
        Named_Field
        = NAMED_FIELD
        {init:Null_Or(Raw_Expression ), name:Symbol, type:Any_Type}
        |
        SOURCE_CODE_REGION_FOR_NAMED_FIELD
        (Named_Field , Source_Code_Region);
        Named_Value
        = NAMED_VALUE
        {expression:Raw_Expression, is_lazy:Bool, pattern:Case_Pattern}
        |
        SOURCE_CODE_REGION_FOR_NAMED_VALUE
        (Named_Value , Source_Code_Region);
        Named_Recursive_Value
        = NAMED_RECURSIVE_VALUE
                {expression:Raw_Expression, fixity:Null_Or(((Symbol , Source_Code_Region)) ), is_lazy:Bool,
                null_or_type:Null_Or(Any_Type ), variable_symbol:Symbol}
        |
        SOURCE_CODE_REGION_FOR_RECURSIVELY_NAMED_VALUE
        (Named_Recursive_Value , Source_Code_Region);
        Named_Function
        = NAMED_FUNCTION
                {is_lazy:Bool, kind:Fun_Kind, null_or_type:Null_Or(Any_Type ),
                pattern_clauses:List(Pattern_Clause )}
        |
        SOURCE_CODE_REGION_FOR_NAMED_FUNCTION
        (Named_Function , Source_Code_Region);
        Pattern_Clause
        = PATTERN_CLAUSE        {expression:Raw_Expression, patterns:List(Fixity_Item(Case_Pattern ) ),
                                result_type:Null_Or(Any_Type )};
        Nada_Named_Function
        = NADA_NAMED_FUNCTION
        (List(Nada_Pattern_Clause ) , Bool)
        |
        SOURCE_CODE_REGION_FOR_NADA_NAMED_FUNCTION
        (Nada_Named_Function , Source_Code_Region);
        Nada_Pattern_Clause
        = NADA_PATTERN_CLAUSE
        {expression:Raw_Expression, pattern:Case_Pattern, result_type:Null_Or(Any_Type )};
        Named_Type
        = NAMED_TYPE
        {definition:Any_Type, name_symbol:Symbol, typevars:List(Typevar )}
        |
        SOURCE_CODE_REGION_FOR_NAMED_TYPE
        (Named_Type , Source_Code_Region);
        Sumtype
        = SOURCE_CODE_REGION_FOR_UNION_TYPE
        (Sumtype , Source_Code_Region)
        |
        SUM_TYPE
        {is_lazy:Bool, name_symbol:Symbol, right_hand_side:Sumtype_Right_Hand_Side, typevars:List(Typevar )};
    Sumtype_Right_Hand_Side  = REPLICAS List(Symbol ) | VALCONS List(((Symbol , Null_Or(Any_Type ))) );
        Named_Exception
        = DUPLICATE_NAMED_EXCEPTION
        {equal_to:Path, exception_symbol:Symbol}
        |
        NAMED_EXCEPTION
        {exception_symbol:Symbol, exception_type:Null_Or(Any_Type )}
        |
        SOURCE_CODE_REGION_FOR_NAMED_EXCEPTION
        (Named_Exception , Source_Code_Region);
        Named_Package
        = NAMED_PACKAGE
                {constraint:Package_Cast(Api_Expression ), definition:Package_Expression, kind:Package_Kind,
                name_symbol:Symbol}
        |
        SOURCE_CODE_REGION_FOR_NAMED_PACKAGE
        (Named_Package , Source_Code_Region);
        Named_Generic
        = NAMED_GENERIC
        {definition:Generic_Expression, name_symbol:Symbol}
        |
        SOURCE_CODE_REGION_FOR_NAMED_GENERIC
        (Named_Generic , Source_Code_Region);
        Named_Api
        = NAMED_API
        {definition:Api_Expression, name_symbol:Symbol}
        |
        SOURCE_CODE_REGION_FOR_NAMED_API
        (Named_Api , Source_Code_Region);
        Named_Generic_Api
        = NAMED_GENERIC_API
        {definition:Generic_Api_Expression, name_symbol:Symbol}
        |
        SOURCE_REGION_FOR_NAMED_GENERIC_API
        (Named_Generic_Api , Source_Code_Region);
    Typevar  = SOURCE_CODE_REGION_FOR_TYPEVAR (Typevar , Source_Code_Region) | TYPEVAR Symbol;
        Any_Type
        = RECORD_TYPE
        List(((Symbol , Any_Type)) )
        |
        SOURCE_CODE_REGION_FOR_TYPE
        (Any_Type , Source_Code_Region)
        |
        TUPLE_TYPE
        List(Any_Type )
        |
        TYPEVAR_TYPE
        Typevar
        |
        TYPE_TYPE
        (List(Symbol ) , List(Any_Type ));};
\end{verbatim}\index[fun]{infixright}
\index[fun]{infixleft}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
