<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mythryl Types: Hindley-Milner Type Inference</TITLE>
</HEAD>
<BODY >
<A HREF="my-Vector_Slices.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Types__Elementary_Types_and_Type_Constructors.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc98">5.4.13</A>  Mythryl Types: Hindley-Milner Type Inference</H3><P>The lack of explicit type declarations makes a Mythryl function definition like </P><PRE CLASS="verbatim">    fun next(arg) = arg+1;
</PRE><P>look a lot more like a similar declaration in an untyped scripting 
language like Python or Ruby than it does like the equivalent declaration 
in C, festooned with type declarations:</P><PRE CLASS="verbatim">    int next (int arg) { return a+1; } 
</PRE><P>But Mythryl is in fact a strongly typed language &#X2014; more so than C, 
in fact &#X2014; and Mythryl syntax lets us, if we wish, festoon our function 
declarations with as many types as any C program. The result even 
looks something like the above C case when we do so:</P><PRE CLASS="verbatim">    fun sum (arg: Int): Int = { a+1; };
</PRE><P>Appearances to the contrary, from a typing point of view Mythryl code 
is in fact much more like C than like untyped scripting languages.</P><P>Like the C compiler, the Mythryl compiler statically computes a 
precise type for every variable, value, function and expression.</P><P>Like the C compiler, the Mythryl compiler takes advantage of type 
information for such things as deciding when to generate 
floating-point arithmetic instructions and when to generate integer 
arithmetic instructions.</P><P>The critical difference is that C has a very simple, <I>ad hoc</I> 
type system design dating from the 1960s, whereas Mythryl uses a 
sophisticated modern type system designed around <A HREF="http://en.wikipedia.org/wiki/Type_inference"><I>Hindley-Milner</I></A> type inference.</P><P>Hindley-Milner type inference (also known as <I>Damas-Milner</I> type inference) is based upon the 
<A HREF="http://en.wikipedia.org/wiki/Unification"><I>unification</I></A> operation popularized by Prolog. Consequently writing type declarations in Mythryl is a bit 
like writing Prolog code; as we shall see subsequently, it is possible 
to write pages of useful Mythryl code entirely as type definitions.</P><P>The more immediately interesting aspect of Mythryl type inference is that 
the compiler freely propagates type inferences outward through the source 
code from every source of information.</P><P>The easiest way to explore Mythryl typing is to use its interactive mode 
with result type display turned on:</P><PRE CLASS="verbatim">    linux$ my
    eval:  set_control  "mythryl_parser::show_interactive_result_types" "TRUE";

    eval:  2+2;

    4 : Int

    eval:  fun sum(a,b) = a+b;

    \\ : (Int, Int) -&gt; Int

    eval:  fun swap(a,b) = (b,a);

    \\ : (X, Y) -&gt; (Y, X)

</PRE><P>The remainder of this section presumes that you have turned on 
result type display as shown above.</P><P>Suppose for example that you enter</P><PRE CLASS="verbatim">    eval:  fun next (arg) = arg + 1.0;

    \\ : Float -&gt; Float
</PRE><P>The Mythryl declaration of the overloaded addition operator in 
<A HREF="my-src_lib_core_init_pervasive_pkg.html#src/lib/core/init/pervasive.pkg">src/lib/core/init/pervasive.pkg</A> declares that it combines two values of the same type to produce another 
value of the same type:</P><PRE CLASS="verbatim">    overloaded my + :   ((X, X) -&gt; X)
</PRE><P>The Mythryl compiler knows that constant <TT>1.0</TT> is of type <TT>Float</TT>, 
hence it can deduce that <TT>arg</TT> must also be a <TT>Float</TT>, and so 
must the result of the addition and consequently of the function, so 
that function <TT>next</TT> must necessarily take a <TT>Float</TT> argument 
and return a <TT>Float</TT> result, giving it a type of <TT>Float -&gt; Float</TT>. </P><P>If we instead enter</P><PRE CLASS="verbatim">    eval:  fun next(arg) = arg + "1";

    \\ : String -&gt; String
</PRE><P>exactly the same chain of reasoning leads the compiler to deduce a type 
of <TT>String -&gt; String</TT> for our function.</P><P>It is due to the power of this style of type inference that Mythryl code can 
be written largely without explicit types. The major exception is api 
definitions. Api definitions represent interfaces to unknown external code 
so one needs to explicitly specify all types in an <TT>.api</TT> file. 
(It is in any event good documentation to do so.) </P><P>Another place where type inference often fails is when setting a variable to 
an empty list:</P><PRE CLASS="verbatim">    result_list = [];
</PRE><P>In such cases, the Mythryl compiler often has no idea whether you intend <TT>result_list</TT> 
to be a list of integers, floats, strings, or maybe something exotic like complete 
symbol tables. Consequently, you will often see Mythryl code giving the type 
explicitly in such cases:</P><PRE CLASS="verbatim">    result_list = ([]: List(String));
</PRE><P>As a general rule, if the Mythryl compiler cannot deduce the type of a variable, 
the human reader of the code probably cannot either, so such type declarations 
are in any case welcome documention.</P><P>The Mythryl compiler constructs a global dependency tree of all api declarations 
and package definitions and then compiles rootward from the leafs. Consequently, 
when it compiles a package, it has in hand full type information about all other 
modules referenced by that package. (Also as a consequence, the Mythryl compiler 
gets very upset if you have cyclic dependencies between packages: It then 
has no idea how to get started compiling. This is the &#X201C;recursive modules&#X201D; 
problem, which has received a great deal of attention from researchers.)</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Vector_Slices.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Types__Elementary_Types_and_Type_Constructors.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
