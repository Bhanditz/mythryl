<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mythryl Types: Extensible Types</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mythryl_Generic_Packages.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Types__Phantom_Types.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc103">5.4.18</A>  Mythryl Types: Extensible Types</H3><P>The predefined Mythryl sumtype <TT>Exception</TT> is unique in that it may 
be incrementally extended by defining new constructors for it using 
<TT>exception</TT> declarations.</P><P>Vanilla Mythryl sumtype declarations require that all constructors belonging 
to the type be declared up front at the point of sumtype definition; no later 
extension of the sumtype is allowed. Normally this is good; it means that 
when you read a sumtype definition in the code you can be sure that what 
you see is the complete story.</P><P>But situations can occasionally arise in industrial-scale Mythryl programming in 
which it is desirable to incrementally extend a sumtype.</P><P>Programmers can and do simply use the <TT>Exception</TT> sumtype directly in 
such cases, defining new constructors as needed via <TT>exception</TT> 
declarations.</P><P>Sometimes, however, it is better to be a little more typesafe by 
keeping such constructors type-distinct from vanilla <TT>Exception</TT> 
constructors.</P><P>Here is a hack to define your own extensible sumtypes separate from 
the standard Mythryl <TT>Exception</TT> sumtype:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    # Each application of api "Extensible" to
    # package "extensible" generates a new
    # package exporting a new type "Extensible":

    api Extensible {
        Extensible;
        make_new_constructor_deconstructor_pair:
            Null_Or(X)
            -&gt;
            (  (X -&gt; Extensible),
               (Extensible -&gt; Null_Or(X))
            );
    };

    package extensible {

        Extensible = Exception;

        fun make_new_constructor_deconstructor_pair _
            =
            {   exception CONSTRUCTOR(X);

                fun deconstructor (CONSTRUCTOR(y)) =&gt; THE y;
                    deconstructor _                =&gt; NULL;
                end;

                (CONSTRUCTOR, deconstructor);
            };
    };



    # Define two new extensible types,
    # Extensible1 and Extensible2:
    #
    package extensible1 = extensible: Extensible;
    Extensible1 = extensible1::Extensible;                  # First new extensible type.
    #
    package extensible2 = extensible: Extensible;
    Extensible2 = extensible2::Extensible;                  # Second new extensible type.


    # Define two new constructor/deconstructor pairs
    # for each of our new extensible types:
    #
    my (constructor1a, deconstructor1a) = extensible1::make_new_constructor_deconstructor_pair( NULL: Null_Or(Int)    ); 
    my (constructor1b, deconstructor1b) = extensible1::make_new_constructor_deconstructor_pair( NULL: Null_Or(String) ); 
    #
    my (constructor2a, deconstructor2a) = extensible2::make_new_constructor_deconstructor_pair( NULL: Null_Or(Int)    ); 
    my (constructor2b, deconstructor2b) = extensible2::make_new_constructor_deconstructor_pair( NULL: Null_Or(String) ); 



    # Apply all four of our new constructors:
    #
    wrapped1a = constructor1a(  1112  );
    wrapped1b = constructor1b( "food" );
    #
    wrapped2a = constructor2a(  2111  );
    wrapped2b = constructor2b( "foof" );



    # Apply all four of our new destructors,
    # recovering the wrapped values:
    #
    unwrapped1a = the (deconstructor1a wrapped1a);
    unwrapped1b = the (deconstructor1b wrapped1b);

    unwrapped2a = the (deconstructor2a wrapped2a);
    unwrapped2b = the (deconstructor2b wrapped2b);



    # Display our recovered results
    # to the cheering crowd:
    #
    printf "unwrapped1a == %d\n" unwrapped1a; 
    printf "unwrapped1b == %s\n" unwrapped1b; 
    #
    printf "unwrapped2a == %d\n" unwrapped2a; 
    printf "unwrapped2b == %s\n" unwrapped2b; 
</PRE><P>Running this produces:</P><PRE CLASS="verbatim">    linux$ ./my-script
    unwrapped1a == 1112
    unwrapped1b == food
    unwrapped2a == 2111
    unwrapped2b == foof
</PRE><P>This is somewhat clumsy. Whether that is a bug or a feature depends 
on whether you believe the use of extensible types should be encouraged 
or discouraged.</P><P>The above construction also has some technical limitations.</P><P>As presented, it does not allow creation of 0-ary constructors. This 
can be circumvented by (say) adding an extra <TT>make_new_0ary_constructor</TT> call.</P><P>More importantly, it does not allow creating parameterized extensible 
types.</P><P><B>Credit:</B> The above construction is adapted from Bernard Berthomieu&#X2019;s 
March 2000 
<A HREF="http://www.laas.fr/~bernard/oo/ooml.html"><I>OO Programming Styles in ML</I></A> paper. The core technique has been in general circulation for some time.</P><P>For a production example of this technique in action see 
<A HREF="my-src_lib_src_property-list_pkg.html#src/lib/src/property-list.pkg">src/lib/src/property-list.pkg</A>.</P>
<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mythryl_Generic_Packages.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Types__Phantom_Types.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
