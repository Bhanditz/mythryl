<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Type_Junk</TITLE>
</HEAD>
<BODY >
<A HREF="my-Token.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Compiler_APIs.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Type_Package_Language.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc937">14.5.46</A>  Type_Junk</H3><P>					<A NAME="@api269"></A>
<A NAME="api:Type_Junk"></A>

The compiler <TT>Type_Junk</TT> api defines access to functionality in 
support of compiler handling of type information.</P><P>The <TT>Type_Junk</TT> api is implemented by the <A HREF="my-type_junk.html#pkg:type_junk">type_junk</A> package.</P><P>The <TT>Type_Junk</TT> api source code is in <A HREF="my-src_lib_compiler_front_typer-stuff_types_type-junk_api.html#src/lib/compiler/front/typer-stuff/types/type-junk.api">src/lib/compiler/front/typer-stuff/types/type-junk.api</A>.</P><P><FONT SIZE=1><I>The above information is manually maintained and may contain errors.</I></FONT>
</P><PRE CLASS="verbatim">api {
    equality_property_to_string : type_declaration_types::e::Is_Eqtype -&gt; String;
        make_incomplete_record_typevar :
            (List(((symbol::Symbol , type_declaration_types::Typoid)) ) , Int)
            -&gt;
            type_declaration_types::Typevar;
    make_user_typevar : symbol::Symbol -&gt; type_declaration_types::Typevar;
        make_overloaded_literal_typevar :
            (type_declaration_types::Literal_Kind , line_number_db::Source_Code_Region , List(String ))
            -&gt;
            type_declaration_types::Typoid;
    make_overloaded_typevar_and_type : List(String ) -&gt; type_declaration_types::Typoid;
    make_meta_typevar_and_type : (Int , List(String )) -&gt; type_declaration_types::Typoid;
    name_of_type : type_declaration_types::Type -&gt; symbol::Symbol;
    stamp_of_type : type_declaration_types::Type -&gt; stamp::Stamp;
    namepath_of_type : type_declaration_types::Type -&gt; ?.inverse_path::Inverse_Path;
    stamppath_of_type : type_declaration_types::Type -&gt; ?.stamppath::Stamppath;
    arity_of_type : type_declaration_types::Type -&gt; Int;
        set_typepath :
        (type_declaration_types::Type , ?.inverse_path::Inverse_Path) -&gt; type_declaration_types::Type;
    types_are_equal : (type_declaration_types::Type , type_declaration_types::Type) -&gt; Bool;
        make_constructor_typoid :
            (type_declaration_types::Type , List(type_declaration_types::Typoid ))
            -&gt;
            type_declaration_types::Typoid;
    drop_resolved_typevars : type_declaration_types::Typoid -&gt; type_declaration_types::Typoid;
        same_typevar_ref :
        (type_declaration_types::Typevar_Ref , type_declaration_types::Typevar_Ref) -&gt; Bool;
    resolve_typevars_to_typescheme_slots : List(type_declaration_types::Typevar_Ref ) -&gt; Void;
        resolve_typevars_to_typescheme_slots_1 :
        List(type_declaration_types::Typevar_Ref ) -&gt; type_declaration_types::Typescheme_Eqflags;
    exception BAD_TYPE_REDUCTION;
        map_constructor_typoid_dot_type :
            (type_declaration_types::Type -&gt; type_declaration_types::Type)
            -&gt;
            type_declaration_types::Typoid -&gt; type_declaration_types::Typoid;
        apply_typescheme :
            (type_declaration_types::Typescheme , List(type_declaration_types::Typoid ))
            -&gt;
            type_declaration_types::Typoid;
    reduce_typoid : type_declaration_types::Typoid -&gt; type_declaration_types::Typoid;
    head_reduce_typoid : type_declaration_types::Typoid -&gt; type_declaration_types::Typoid;
    typoids_are_equal : (type_declaration_types::Typoid , type_declaration_types::Typoid) -&gt; Bool;
    type_equality : (type_declaration_types::Type , type_declaration_types::Type) -&gt; Bool;
    make_typeagnostic_api : Int -&gt; type_declaration_types::Typescheme_Eqflags;
    sumtype_to_type : type_declaration_types::Valcon -&gt; type_declaration_types::Type;
        sumtype_to_typoid :
            (type_declaration_types::Type , Null_Or(type_declaration_types::Typoid ))
            -&gt;
            type_declaration_types::Typoid;
        match_typescheme :
            (type_declaration_types::Typescheme , type_declaration_types::Typoid)
            -&gt;
            type_declaration_types::Typoid;
    drop_macro_expanded_indirections_from_type : type_declaration_types::Typoid -&gt; Void;
        instantiate_if_typescheme :
            (type_declaration_types::Typoid , symbolmapstack::Symbolmapstack , List(String ))
            -&gt;
            (type_declaration_types::Typoid , List(type_declaration_types::Typoid ));
        pkg_typoid_matches_api_typoid :
        {type_per_api:type_declaration_types::Typoid, type_per_pkg:type_declaration_types::Typoid} -&gt; Bool;
    typevar_of_typoid : type_declaration_types::Typoid -&gt; type_declaration_types::Typevar_Ref;
    get_recursive_typevar_map : (Int , type_declaration_types::Typoid) -&gt; Int -&gt; Bool;
    label_is_greater_than : (symbol::Symbol , symbol::Symbol) -&gt; Bool;
        is_value :
            {inlining_data_says_it_is_pure:inlining_data::Inlining_Data -&gt; Bool}
            -&gt;
            deep_syntax::Deep_Expression -&gt; Bool;
    is_variable_typoid : type_declaration_types::Typoid -&gt; Bool;
        sort_fields :
        List(((deep_syntax::Numbered_Label , X)) ) -&gt; List(((deep_syntax::Numbered_Label , X)) );
    map_unzip : (X -&gt; (Y , Z)) -&gt; List(X ) -&gt; (List(Y ) , List(Z ));
    Typeset;
    make_typeset : Void -&gt; Typeset;
    insert_type_into_typeset : (type_declaration_types::Type , Typeset) -&gt; Typeset;
    filter_typeset : (type_declaration_types::Typoid , Typeset) -&gt; List(type_declaration_types::Type );
    sumtype_sibling : (Int , type_declaration_types::Type) -&gt; type_declaration_types::Type;
    extract_sumtype : type_declaration_types::Type -&gt; List(type_declaration_types::Valcon );
    wrap_definition : (type_declaration_types::Type , stamp::Stamp) -&gt; type_declaration_types::Type;
    unwrap_definition_1 : type_declaration_types::Type -&gt; Null_Or(type_declaration_types::Type );
    unwrap_definition_star : type_declaration_types::Type -&gt; type_declaration_types::Type;};
</PRE><P><A NAME="@fun6393"></A>
<A NAME="@fun6394"></A>
<A NAME="@fun6395"></A>
<A NAME="@fun6396"></A>
<A NAME="@fun6397"></A>
<A NAME="@fun6398"></A>
<A NAME="@fun6399"></A>
<A NAME="@fun6400"></A>
<A NAME="@fun6401"></A>
<A NAME="@fun6402"></A>
<A NAME="@fun6403"></A>
<A NAME="@fun6404"></A>
<A NAME="@fun6405"></A>
<A NAME="@fun6406"></A>
<A NAME="@fun6407"></A>
<A NAME="@fun6408"></A>
<A NAME="@fun6409"></A>
<A NAME="@fun6410"></A>
<A NAME="@fun6411"></A>
<A NAME="@fun6412"></A>
<A NAME="@fun6413"></A>
<A NAME="@fun6414"></A>
<A NAME="@fun6415"></A>
<A NAME="@fun6416"></A>
<A NAME="@fun6417"></A>
<A NAME="@fun6418"></A>
<A NAME="@fun6419"></A>
<A NAME="@fun6420"></A>
<A NAME="@fun6421"></A>
<A NAME="@fun6422"></A>
<A NAME="@fun6423"></A>
<A NAME="@fun6424"></A>
<A NAME="@fun6425"></A>
<A NAME="@fun6426"></A>
<A NAME="@fun6427"></A>
<A NAME="@fun6428"></A>
<A NAME="@fun6429"></A>
<A NAME="@fun6430"></A>
<A NAME="@fun6431"></A>
<A NAME="@fun6432"></A>
<A NAME="@fun6433"></A>
<A NAME="@fun6434"></A>
<A NAME="@fun6435"></A>
<A NAME="@fun6436"></A>
<A NAME="@fun6437"></A>
<A NAME="@fun6438"></A>

</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Token.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Compiler_APIs.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Type_Package_Language.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
