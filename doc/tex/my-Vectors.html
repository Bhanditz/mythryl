<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Vectors</TITLE>
</HEAD>
<BODY >
<A HREF="my-Tuples_and_Records.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Pattern_Matching.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc69">5.3.4</A>  Vectors</H3><P>
<A NAME="section:tut:delving-deeper:vectors"></A></P><P>Vectors and arrays are the heart and soul of languages like Fortran. Open up 
any Fortran source file at random, and you will probably be looking at a 
<TT>do</TT> loop over a vector or array. Fortran compiler writers sweat blood 
trying to squeeze one percent more performance out of such loops.</P><P>Mythryl is not like that. The heart and soul of Mythryl is recursive processing 
of recursive datastructures like lists. Mythryl compiler writers sweat blood 
trying to squeeze a little more performance out of such recursive functions. </P><P>But Mythryl does have vectors, and occasionally they are just the right tool 
for the job.</P><P>The fundamentally interesting properties of vectors are:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
They are cheap.
</LI><LI CLASS="li-itemize">They allow constant-time access to any element by postion.
</LI></UL><P>Accessing the one-hundredth element in a list requires one hundred operations, 
stepping down the list, but accessing the one-hundredth element in a vector takes 
no longer than accessing the first element.</P><P>Vectors are like tuples in that they efficiently store a sequence of elements 
which may be accessed by slot number. The crucial difference is that tuple 
elements may be of different types, and tuple slots may be accessed using 
only constant slot numbers, whereas vector elements must all be of the same 
type, and may be fetched using slot index variables as well as slot index 
constants.</P><P>The fundamental operations of interest on vectors are 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Create.
</LI><LI CLASS="li-itemize">Get <I>i</I>&#X2013;th element.
</LI><LI CLASS="li-itemize">Get length.
</LI></UL><P>Here is a transcript of creating a three-element vector, accessing 
each of its elements, and then getting its length:</P><PRE CLASS="verbatim">    linux$ my

    eval:  v = #[ 11, 22, 33 ];
    #[11, 22, 33]

    eval:  v[ 0 ];
    11

    eval:  v[ 1 ];
    22

    eval:  v[ 2 ];
    33

    eval:  vector::length v;
    3
</PRE><P>Mythryl vectors are type-agnostic (&#X201C;<I>polymorphic</I>&#X201D; &#X2014; literally, &#X201C;many shaped&#X201D;): They may 
contain elements of any type, so long as all the elements of a given vector 
are the same type. Here is the above example repeated with a vector of Strings: </P><PRE CLASS="verbatim">    linux$ my

    eval:  v = #[ "one", "two", "three" ];
    #["one", "two", "three"]

    eval:  v[ 0 ];
    "one"

    eval:  v[ 1 ];
    "two"

    eval:  v[ 2 ];
    "three"

    eval:  vector::length v;
    3
</PRE><P>You will often wish to construct a vector from elements computed on 
the fly at runtime. Most frequently you will have accumulated these 
in a list while computing them. The <TT>vector::from_list</TT> function 
does what you need in this case:</P><PRE CLASS="verbatim">    linux$ my

    eval:  v = vector::from_list (reverse( [ "one", "two", "three" ] ) );
    #["three", "two", "one"]
</PRE><P>Another frequent operation is to apply some function to all the elements 
of a vector and return a vector containing the results &#X2014; the vector 
equivalent of the list <TT>map</TT> function. Here is an example where we 
add one to each element of a vector:</P><PRE CLASS="verbatim">    linux$ my

    eval:  v = vector::from_list (1..10);
    #[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    eval:  w = vector::map  (\\ i = i + 1)  v;
    #[2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
</PRE><P>The <TT>vector::apply</TT> function is just like the <TT>vector::map</TT> function 
except that no result value is constructed. It is useful when we are applying 
a function to the vector elements purely for its side effects:</P><PRE CLASS="verbatim">    linux$ my

    eval:  v = #[ "q", "w", "e", "r", "t", "y" ];
    #["q", "w", "e", "r", "t", "y"]

    eval:  vector::apply print v;
    qwerty
</PRE><P>If you are in a C-flavored frame of mind, you can do the same 
thing with an explicit <TT>for</TT> loop:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    v = #[ "q", "w", "e", "r", "t", "y" ];

    for (i = 0;  i &lt; vector::length v;  ++i) {
        print v[i];
    };

    print "\n";
</PRE><P>Running the above yields:</P><PRE CLASS="verbatim">    linux$ ./my-script
    qwerty
    linux$
</PRE><P>The <TT>v[i]</TT> notation for accessing the <I>i</I>-th element of a vector 
is readable for general use, but a nuisance if you want to pass the 
vector-get function around as an argument, say to use it in conjunction with 
functions like <TT>map</TT>. For cases like this, the vector-get operation 
is also available as <TT>vector::get</TT>:</P><PRE CLASS="verbatim">    linux$ my

    eval:  v = vector::from_list (shuffle (1..10));
    #[10, 9, 8, 3, 4, 5, 6, 7, 2, 1]

    eval:  vector::get (v, 0);
    10
</PRE><P>A final useful function is <TT>vector::set</TT>. This constructs a new 
vector which differs from a pre-existing vector in one specified slot:</P><PRE CLASS="verbatim">    linux$ my

    eval:  v = #[ 3, 1, 4, 1, 6 ];             # Make a vector.
    #[3, 1, 4, 1, 6]

    eval:  w = vector::set( v, 1, 222 );       # Make a new vector differing in one slot.
    #[3, 222, 4, 1, 6]

    eval:  v;                                  # The original vector is unchanged.
    #[3, 1, 4, 1, 6]
</PRE><P>A number of other convenience operations are predefined on vectors, 
which we will cover in a later tutorial (peek at <A HREF="my-Vector.html#api:Vector">Vector</A> if impatient), but 
the above is enough to get started with vanilla Vectors.</P><P>The other major vector flavor is Rw_Vector.</P><P>Vanilla vectors are <I>immutable</I>. Once created, they cannot be changed. 
Some people call such values <I>pure</I>. Values which can be changed after 
creation via side-effects are termed <I>mutable</I> or <I>impure</I>.</P><P>Mythryl programmers work with pure values when they can and impure values 
when they must.</P><P>Pure values result in code which is much easier to understand, since 
you never have to worry about pure values changing in unexpected ways 
at inconvenient moments, due perhaps to other threads running on other 
cores.</P><P>But sometimes you really do need to to modify the an existing value, 
perhaps because the algorithm requires it (<I>e.g.</I> many matrix algorithms), 
perhaps because you are precisely interested in broadcasting information 
to other threads in a multithread program.</P><P>For such cases Mythryl provides Rw_Vectors, which as the name suggests are 
writable as well as readable.</P><P>The <A HREF="my-Rw_Vector.html#api:Rw_Vector">Rw_Vector api</A> is almost identical to the <A HREF="my-Vector.html#api:Vector">Vector api</A>; the significant difference is just that the <TT>rw_vector::set</TT> operation modifies its argument vector in place:</P><PRE CLASS="verbatim">    linux$ my

    eval:  v = rw_vector::from_list [ 3, 1, 4, 1, 6 ];
    [|3, 1, 4, 1, 6|]

    eval:  rw_vector::set( v, 1, 222 );
    ()

    eval:  v;
    [|3, 222, 4, 1, 6|]
</PRE><P>We will have more to say about vectors <A HREF="my-Typelocked_Vectors.html#section:tut:full-monte:typelocked-vectors">later</A>, but first it is time to discuss <I>pattern matching</I>.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Tuples_and_Records.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Pattern_Matching.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
