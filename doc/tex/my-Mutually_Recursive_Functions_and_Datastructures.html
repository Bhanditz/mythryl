<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mutually Recursive Functions and Datastructures</TITLE>
</HEAD>
<BODY >
<A HREF="my-Pattern_Matching.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-List_Comprehensions.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc71">5.3.6</A>  Mutually Recursive Functions and Datastructures</H3><P>A C <TT>enum</TT> declaration allows definition of a data type consisting 
of a finite list of alternatives:</P><PRE CLASS="verbatim">    enum Color { RED, GREEN, BLUE };
</PRE><P>The <TT>enum</TT> declaration is not particularly near and dear to the 
C programmer&#X2019;s heart. In fact, the <TT>enum</TT> declaration was not 
even mentioned in <I>The C Programming Language</I>.</P><P>Mythryl has a similar construct:</P><PRE CLASS="verbatim">    Color = RED | GREEN | BLUE;
</PRE><P>This construct is however very near and dear indeed to the heart of 
the Mythryl programmer; it is the rock upon which mutually recursive 
datastructures are built, which are in turn the backbone of 
sophisticated programs such as the Mythryl compiler itself.</P><P>Simple declarations such as the above one are frequently used to define 
a data type which can then be used in records:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    Color  = BLUE | GREEN | RED;

    fun print_color( color ) = {
        case color
            RED   =&gt; print "Red\n";
            GREEN =&gt; print "Green\n";
            BLUE  =&gt; print "Blue\n";
        esac;
    };

    a = { x =&gt; 1.0, y =&gt; 1.0, diameter =&gt; 0.5, color =&gt; RED  };
    b = { x =&gt; 1.0, y =&gt; 2.0, diameter =&gt; 0.7, color =&gt; BLUE };

    print_color(a.color);
    print_color(b.color);
</PRE><P>The <TT>a</TT> and <TT>b</TT> records above might represent circles to be 
drawn upon the screen in a graphics application, say.</P><P>One nice aspect of code such as the above is that if <TT>Color</TT> is 
redefined to include one more (or less) color, the compiler will 
automatically flag all <TT>case</TT> statements on <TT>Color</TT> which have not 
been modified appropriately to reflect the new definition. This 
can be an enormous help when maintaining large complex programs. 
(Relative to doing the same thing in C, say.)</P><P>However, the real power of such declarations only begins to become 
apparent when the named constants are decorated with data values:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    Tree = LEAF(Int)
         | NODE { key: Int, left_kid: Tree, right_kid: Tree };

    fun print_tree( t ) = {

        case t

            LEAF i =&gt; printf "leaf: %d\n" i;

            NODE { key, left_kid, right_kid }
                =&gt;
                {   print_tree(left_kid);
                    printf "key: %d\n" key;
                    print_tree(right_kid);
                };

        esac;
    };

    my_tree = NODE { key =&gt; 2, left_kid =&gt; LEAF 1, right_kid =&gt; LEAF 3 };

    print_tree(my_tree);
</PRE><P>Running the above will produce:</P><PRE CLASS="verbatim">    linux$ ./my-script
    leaf: 1
    key: 2
    leaf: 3
</PRE><P>Now, there&#X2019;s a lot going on there! If you translated the above into 
C or Java, you would probably have several pages of code. Let&#X2019;s break 
it down:</P><PRE CLASS="verbatim">    Tree = LEAF(Int)
         | NODE { key: Int, left_kid: Tree, right_kid: Tree };
</PRE><P>This two-liner defines a complete binary tree data type. </P><P>The first line says that leaf nodes carry a single integer value. </P><P>The second line says that internal nodes carry a record containing an integer 
key and pointers to two subtrees. (Mythryl does not distinguish between 
record values and pointers to records the way C does. Think of it as 
always implementing the pointer case.)</P><P>Since the definition of the <TT>Tree</TT> type refers to itself (the 
record fields <TT>left_kid</TT> and <TT>right_kid</TT> are both of type 
<TT>Tree</TT>), it defines a recursive datastructure, instances of which may be 
arbitrarily large.</P><P>Now consider the function definition:</P><PRE CLASS="verbatim">    fun print_tree( t ) = {

        case t

            LEAF i =&gt; printf "leaf: %d\n" i;

            NODE { key, left_kid, right_kid }
                =&gt;
                {   print_tree(left_kid);
                    printf "key: %d\n" key;
                    print_tree(right_kid);
                };
        esac;
    };
</PRE><P>The <TT>case</TT> expressions 
<TT>LEAF i</TT> and <TT>NODE { key, left_kid, right_kid }</TT> 
are again examples of pattern-matching assignments.</P><P>This recursive routine takes a single argument.</P><P>If that argument is a <TT>LEAF</TT>, it simply prints out the integer 
value associated with the leaf, pattern-matched out of the 
left hand side of the rule.</P><P>If that argument is an internal binary tree <TT>NODE</TT>, it does 
an in-order traversal, recursively printing out its left 
subtree, then printing out its key, then again 
recursively printing out its right subtree.</P><P>Finally, consider the statement</P><PRE CLASS="verbatim">    my_tree = NODE { key =&gt; 2, left_kid =&gt; LEAF 1, right_kid =&gt; LEAF 3 };
</PRE><P>This statement constructs a complete (little) binary tree consisting of 
two leaf nodes and one internal node. (Don&#X2019;t try doing this in one 
line in C!)</P><P>In this context the constants <TT>NODE</TT> and <TT>LEAF</TT> are called 
<I>constructors</I>, for the simple and sufficient reason that when 
they are applied as functions they construct values 
of the indicated type.</P><P>Having these constructors implicitly generated by the Mythryl compiler 
in response to the <TT>Tree</TT> type declaration is one of the things 
that makes Mythryl code so economical.</P><P>As the final major twist to this story, Mythryl allows us to define 
mutually recursive datastructures. Suppose, for example, we are 
building a <I>mud</I> &#X2014; an online interactive text game in which players 
wander through rooms connected by doors. Each room may have 
multiple doors, and each door connects the current room to 
another room:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    Room = ROOM { name: String, description: String, doors: List(Door) }
    also
    Door = DOOR { name: String, description: String, to: Room };

    fun print_room( ROOM { name, description, doors } ) = {
        printf "%s room: You see %s\n" name description;
        apply print_door doors; 
    }
    also
    fun print_door( DOOR { name, description, to } ) = {
        printf "%s door: You see %s\n" name description;
        print_room to;
    };

    level = ROOM { name =&gt; "main",
                   description =&gt; "a big entryroom.", 
                   doors =&gt; [  DOOR { name =&gt; "kitchen.",
                                      description =&gt; "a white door.",
                                      to =&gt; ROOM { name =&gt; "kitchen", 
                                                   description =&gt; "a tidy kitchen.",
                                                   doors =&gt; []
                                                 }
                                    }
                            ] 
                   };

    print_room level;
</PRE><P>The <TT>Room</TT> and <TT>Door</TT> types are mutually recursive. Naturally, 
this means that to process the resulting data structure we need 
mutually recursive functions, in this case <TT>print_room</TT> and <TT>print_door</TT>.</P><P>In both cases we use the <TT>also</TT> 
reserved word to notify the compiler 
of the mutual recursion.</P><P>Notice in each case the absence of a semicolon 
preceding the <TT>also</TT>. Mythryl ends complete statements 
with a semicolon, and only complete statements.</P><P>Here we also see for the first time that function call parameter lists 
do pattern-matching. We use this facility in both the <TT>print_door</TT> 
and <TT>print_room</TT> functions to efficiently unpack the values we 
need from the relevant record structures.</P><P>When run, the above script produces</P><PRE CLASS="verbatim">    linux$ ./my-script
    main room: You see a big entryroom.
    kitchen door: You see a white door.
    kitchen room: You see a tidy kitchen.
</PRE><P>That&#X2019;s not much as muds go, but that&#X2019;s a lot accomplished in half a 
page of code! If you coded up the same thing in C you might have 
five or ten pages of code before you were done.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Pattern_Matching.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-List_Comprehensions.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
