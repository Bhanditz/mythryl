<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>More Regular Expressions</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mythryl_Functions__Defaultable_Keyword_Parameters.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Typelocked_Vectors.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc95">5.4.10</A>  More Regular Expressions</H3><P>
<A NAME="section:tut:full-monte:regex"></A></P><P>Picking up where we <A HREF="my-Regular_Expressions.html#section:tut:bare-essentials:regex">left off</A>, we have seen how to do <TT><I>string</I></TT><TT> </TT><CODE><TT>=~</TT></CODE><TT> </TT><TT><I>regex</I></TT> matching and 
<TT>regex::replace_all</TT> substitutions; it is time to explore some other 
functions exported by package <A HREF="my-regex.html#pkg:regex">regex</A> per the <A HREF="my-Regular_Expression_Matcher.html#api:Regular_Expression_Matcher">Regular_Expression_Matcher</A> api.</P><P>The <TT>regex::find_first_match_to_regex</TT> function returns <SPAN STYLE="font-variant:small-caps">THE</SPAN> first substring matching a regular expression, returning <SPAN STYLE="font-variant:small-caps">NULL</SPAN> if no match is found:</P><PRE CLASS="verbatim">    linux$ my
    eval:  regex::find_first_match_to_regex ./f.t/ "the fat father futzed";
    THE "fat"
</PRE><P>The <TT>regex::find_all_matches_to_regex</TT> function returns all substrings matching a regular expression:</P><PRE CLASS="verbatim">    linux$ my
    eval:  regex::find_all_matches_to_regex ./f.t/ "the fat father futzed";
    ["fat", "fat", "fut"]
</PRE><P>Thus, recalling that in Perl regular expressions <CODE><TT>\w</TT></CODE> matches word constituents 
and <CODE><TT>\b</TT></CODE> matches at word boundaries, one way to break out the words in a string is:</P><PRE CLASS="verbatim">    linux$ my
    eval:  regex::find_all_matches_to_regex ./\b\w+\b/ "the fat father futzed";
    ["the", "fat", "father", "futzed"]
</PRE><P>Regular expressions use parentheses both for grouping expressions and also for 
designating substring matches of interest. A number of <TT>regex</TT> functions 
center on processing of such parenthesis-marked groupings. </P><P>For example <TT>regex::find_first_groups_all</TT> matches a regular expression once against a 
string, raising exception <SPAN STYLE="font-variant:small-caps">NOT_FOUND</SPAN> if there is no match, otherwise returning the list 
of all substrings matching groups (parenthesized subexpressions):</P><PRE CLASS="verbatim">    linux$ my

    eval:  regex::find_first_match_to_regex_and_return_all_groups ./f.q/ "the fat father futzed";
    NULL

    eval:  regex::find_first_match_to_regex_and_return_all_groups ./f.t/ "the fat father futzed";
    THE []

    eval:  regex::find_first_match_to_regex_and_return_all_groups ./(f)(.)(t)/ "the fat father futzed";
    THE ["f", "a", "t"]

    eval:  regex::find_first_match_to_regex_and_return_all_groups ./((f(.))t)/ "the fat father futzed";
    THE ["fat", "fa", "a"]
</PRE><P>Here:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
In the first example there was no match, so the call raised exception <SPAN STYLE="font-variant:small-caps">NOT_FOUND</SPAN>.</LI><LI CLASS="li-itemize">In the second example there was a match, but the regular expression contained 
no parenthesis-marked groupings, so the return list was empty.</LI><LI CLASS="li-itemize">In the third example the first match was against <TT>fat</TT> and the regular 
expression had three sets of parentheses, so the returned list contained 
three strings, each corresponding to the substring matched by one 
regular expression parenthesis-pair.</LI><LI CLASS="li-itemize">The fourth example is just like the third except that the parentheses placements 
are different, and thus also the corresponding returned strings.
</LI></UL><P>The <TT>regex::find_first_group </TT><TT><I>i</I></TT> function does the same as above, except that 
it returns only a single selected parenthesis group match, raising exception <SPAN STYLE="font-variant:small-caps">NOT_FOUND</SPAN> 
if the regex fails to match the string. </P><P>By convention, group 0 is the complete matched string, hence <TT>regex::find_first_match_to_ith_group 0 </TT><TT><I>regex</I></TT> 
is the same as <TT>regex::find_first_match_to_regex </TT><TT><I>regex</I></TT>:</P><PRE CLASS="verbatim">    linux$ my

    eval:  regex::find_first_match_to_regex       ./(f)(.)(t)/ "the fat father futzed";
    THE "fat"

    eval:  regex::find_first_match_to_ith_group 0 ./(f)(.)(t)/ "the fat father futzed";
    THE "fat"

    eval:  regex::find_first_match_to_ith_group 1 ./(f)(.)(t)/ "the fat father futzed";
    THE "f"

    eval:  regex::find_first_match_to_ith_group 2 ./(f)(.)(t)/ "the fat father futzed";
    THE "a"

    eval:  regex::find_first_match_to_ith_group 3 ./(f)(.)(t)/ "the fat father futzed";
    THE "t"
</PRE><P>Hint: There is no <TT>regex</TT> call which explicitly returns the location 
of a match within a string, but it is easy to extract the leading string and 
compute its length. For example, to find the location of the first "foo" in 
a string:</P><PRE CLASS="verbatim">    eval:  strlen (regex::find_first_match_to_ith_group 1 ./^(.*)foo/ "the fool on the hill");
    THE 4
</PRE><P>The <TT>regex::find_all_matches_to_regex_and_return_values_of_ith_group </TT><TT><I>i</I></TT> function is the same as above, except that it 
returns the <I>i</I>-th parenthesis group match for all successful matches 
of the regular expression against the target string:</P><PRE CLASS="verbatim">    eval:  regex::find_all_matches_to_regex_and_return_values_of_ith_group 2 ./(f)(.)(t)/ "the fat father futzed";
    ["a", "a", "u"]
</PRE><P>Finally, the <TT>regex::find_all_matches_to_regex_and_return_all_values_of_all_groups</TT> does the obvious:
</P><PRE CLASS="verbatim">    eval:  regex::find_all_matches_to_regex_and_return_all_values_of_all_groups ./(f)(.)(t)/ "the fat father futzed";
    [["f", "a", "t"], ["f", "a", "t"], ["f", "u", "t"]]
</PRE><P>We&#X2019;ve already seen that <TT>regex::replace_all</TT> may be used to substitute 
a string for every regular expression match in a string:</P><PRE CLASS="verbatim">    linux$ my

    eval:  regex::replace_all ./f.t/ "FAT" "the fat father futzed";
    "the FAT FATher FATzed"
</PRE><P>There is a matching call which replaces only the first match:</P><PRE CLASS="verbatim">    linux$ my

    eval:  regex::replace_first ./f.t/ "FAT" "the fat father futzed";
    "the FAT father futzed"
</PRE><P>There is also a matching pair of functions which allow arbitrary substitutions 
at each regular expression matchpoint in the string by calling a 
user-supplied function to compute the replacement string.</P><P>The <TT>regex::replace_first_via_fn</TT> will return the template string if there is 
no match, otherwise it calls the user-supplied function with 
a list of strings corresponding to the parenthesis group matchings:</P><PRE CLASS="verbatim">    linux$ my

    eval: regex::replace_first_via_fn  ./(f.t)/  {. toupper (strcat #stringlist); }  "the fat father futzed";
    "the FAT father futzed"
</PRE><P>As you might expect <TT>regex::replace_all_via_fn</TT> is identical except that it splices 
in replacements for all substrings matched by the regular expression:</P><PRE CLASS="verbatim">    linux$ my

    eval: regex::replace_all_via_fn ./(f.t)/ {. toupper (strcat #stringlist); }  "the fat father futzed";
    "the FAT FATher FUTzed"
</PRE><P>For the ultimate in flexibility, the 
<TT>regex::regex_case</TT> function provides a &#X2019;case&#X2019; 
type statement driven by regular expression 
pattern-matching.</P><P>The arguments consist of a text to be matched 
followed by a list of (<I>regex, action-fn</I>) pairs 
and a default action function.</P><P>Execution consists of matching each regex 
in order against the target text until one matches, 
at which point the corresponding action 
is invoked (with the substrings obtained 
from the match) and the result returned.</P><P>If no regex matches, the default action 
is executed and the result returned.</P><P>In any event, exactly one action function 
invoked exactly once:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    fun diagnose  target_text
        =
        regex::regex_case
            target_text
            {  cases =&gt;    [ (./utilize/,                       \\ _       = printf "This guy is verbose!\n"                      ),
                             (./weaponize/,                     \\ _       = printf "This guy is from the Pentagon!\n"            ),
                             (./(\b[bcdfghjklmnpqrstvwxz]+\b)/, \\ strings = printf "What is this '%s' word?!\n" (strcat strings) )
                           ],

               default =&gt;  \\ _ = printf "I can deduce nothing.\n"
            };

    diagnose  "We must utilize our utmost efforts.";
    diagnose  "We must weaponize the chalkboards.";
    diagnose  "The crwth is revolting!";
    diagnose  "We are the people!";
</PRE><P>When run, the above script produces:</P><PRE CLASS="verbatim">    linux$ ./my-script
    This guy is verbose!
    This guy is from the Pentagon!
    What is this 'crwth' word?!
    I can deduce nothing.
    linux$
</PRE><P>See also: <A HREF="my-Perl5_Regular_Expression_Overview.html#section:libref:perl5-regular-expressions:overview">Perl5 Regular Expressions Library Reference</A>.<BR>See also: <A HREF="my-Regular_expressions.html#section:tut:recipe:regular-expressions">regular expression recipes</A>.</P>
<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mythryl_Functions__Defaultable_Keyword_Parameters.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Typelocked_Vectors.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
