<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Typelocked Vectors</TITLE>
</HEAD>
<BODY >
<A HREF="my-More_Regular_Expressions.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Vector_Slices.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc96">5.4.11</A>  Typelocked Vectors</H3><P>
<A NAME="section:tut:full-monte:typelocked-vectors"></A></P><P>Picking up where we <A HREF="my-Vectors.html#section:tut:delving-deeper:vectors">left off</A>, the vanilla <A HREF="my-Vector.html#api:Vector">Vector</A> and <A HREF="my-Rw_Vector.html#api:Rw_Vector">Rw_Vector</A> apis support very flexible vector functionality, but this flexibility comes at 
a price.</P><P>In order to be able to hold values of any type, a <A HREF="my-vector.html#pkg:vector">vector</A> is implemented as a vector of pointers to the actual values. This way the vector 
elements can be anything from 8-bit unsigned values to 64-bit floats to perhaps 
entire binary trees, images, symbol tables or relational database tables.</P><P>Consequently, every vector <A HREF="my-vector.html#pkg:vector">vector</A> or <A HREF="my-rw_vector.html#pkg:rw_vector">rw_vector</A> element stored has the space overhead of the in-vector pointer plus any per-element space 
overhead due to the memory allocation subsystem implementation and memory alignment restrictions. 
In the case of a vector holding 64-bit floats, this may easily triple the amount of memory 
required; in the case of a vector holding 8-bit unsigned values this may result in memory 
consumption an order of magnitude higher than optimum.</P><P>Constantly indirecting through these vector pointers also increases the CPU time overhead 
required for vector computations.</P><P>Most of the time these space and time overhead costs are of negligible practical importance, 
a more than justifiable price to pay for code simplicity and cleanliness.</P><P>But sometimes these costs are significant enough that is worth some increase in code 
complexity in order to reduce them.</P><P>For such times Mythryl provides a variety of <I>typelocked</I> vector implementations 
where by &#X201C;typelocked&#X201D; we mean specialized to a particular type of element. 
The <A HREF="my-Typelocked_Vector.html#api:Typelocked_Vector">Typelocked_Vector</A> and <A HREF="my-Typelocked_Rw_Vector.html#api:Typelocked_Rw_Vector">Typelocked_Rw_Vector</A> apis define the interfaces for these implementations, which include 
<A HREF="my-char_vector.html#pkg:vector_of_chars">vector_of_chars</A>,<A HREF="my-unt8_vector.html#pkg:vector_of_one_byte_unts">vector_of_one_byte_unts</A>,<A HREF="my-vector_of_eight_byte_floats.html#pkg:vector_of_eight_byte_floats">vector_of_eight_byte_floats</A>,<A HREF="my-rw_vector_of_chars.html#pkg:rw_vector_of_chars">rw_vector_of_chars</A>,<A HREF="my-rw_vector_of_one_byte_unts.html#pkg:rw_vector_of_one_byte_unts">rw_vector_of_one_byte_unts</A> and <A HREF="my-rw_vector_of_eight_byte_floats.html#pkg:rw_vector_of_eight_byte_floats">rw_vector_of_eight_byte_floats</A> packages.</P><P>The typelocked vector apis are very similar to the vanilla vector apis; often you will simply be able to substitute the appropriate typelocked vector package 
for the vanilla one and soldier on with increased space and time efficiency:</P><PRE CLASS="verbatim">    linux$ my

    eval:  v = vector_of_one_byte_unts::from_list (map one_byte_unt::from_int [ 1, 2, 3, 4 ]);

    eval:  vector_of_one_byte_unts::get (v, 0);
    0wx1

    eval:  vector_of_one_byte_unts::get (v, 1);
    0wx2

    eval:  vector_of_one_byte_unts::get (v, 2);
    0wx3


    eval:  v = rw_vector_of_one_byte_unts::make_rw_vector( 4, 0wx0 );

    eval:  for (i = 0; i &lt; 4; ++i)  printf "%d\n" (one_byte_unt::to_int (rw_vector_of_one_byte_unts::get(v,i)));
    0
    0
    0
    0

    eval:  rw_vector_of_one_byte_unts::set( v, 0, 0wx12 );
    eval:  rw_vector_of_one_byte_unts::set( v, 1, 0wx45 );

    eval:  for (i = 0; i &lt; 4; ++i)  printf "%d\n" (one_byte_unt::to_int (rw_vector_of_one_byte_unts::get(v,i)));
    18
    69
    0
    0


    eval:  package fv = rw_vector_of_eight_byte_floats;

    eval:  v = fv::make_rw_vector( 4, 0.0 );

    eval:  for (i = 0; i &lt; 4; ++i)  printf "%f\n" (rw_vector_of_eight_byte_floats::get(v,i));
    0.000000
    0.000000
    0.000000
    0.000000

    eval:  fv::set( v, 0, 3.141592 );
    eval:  fv::set( v, 1, 2.718281 );

    eval:  for (i = 0; i &lt; 4; ++i)  printf "%f\n" (rw_vector_of_eight_byte_floats::get(v,i));
    3.141592
    2.718282
    0.000000
    0.000000
</PRE>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-More_Regular_Expressions.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Vector_Slices.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
