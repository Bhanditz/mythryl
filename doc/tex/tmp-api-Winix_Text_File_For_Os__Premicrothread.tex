\index[api]{Winix\_Text\_File\_For\_Os\_\_Premicrothread}
\label{api:Winix\_Text\_File\_For\_Os\_\_Premicrothread}
\input{top-api-Winix_Text_File_For_Os__Premicrothread.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    Vector  = String;
    Element  = Char;
    Input_Stream;
    Output_Stream;
    read : Input_Stream -> Vector;
    read_one : Input_Stream -> Null_Or(Element );
    read_n : (Input_Stream , Int) -> Vector;
    read_all : Input_Stream -> Vector;
    peek : Input_Stream -> Null_Or(Element );
    close_input : Input_Stream -> Void;
    end_of_stream : Input_Stream -> Bool;
    write : (Output_Stream , Vector) -> Void;
    write_one : (Output_Stream , Element) -> Void;
    flush : Output_Stream -> Void;
    close_output : Output_Stream -> Void;
        package pur
          : api {
                Vector  = String;
                Element  = Char;
                Filereader;
                Filewriter;
                Input_Stream;
                Output_Stream;
                File_Position;
                Out_Position;
                make_instream : (Filereader , Vector) -> Input_Stream;
                read : Input_Stream -> (Vector , Input_Stream);
                read_one : Input_Stream -> Null_Or(((Element , Input_Stream)) );
                read_n : (Input_Stream , Int) -> (Vector , Input_Stream);
                read_all : Input_Stream -> (Vector , Input_Stream);
                close_input : Input_Stream -> Void;
                end_of_stream : Input_Stream -> Bool;
                get_reader : Input_Stream -> (Filereader , Vector);
                file_position_in : Input_Stream -> File_Position;
                make_outstream : (Filewriter , io_exceptions::Buffering_Mode) -> Output_Stream;
                write : (Output_Stream , Vector) -> Void;
                write_one : (Output_Stream , Element) -> Void;
                flush : Output_Stream -> Void;
                close_output : Output_Stream -> Void;
                set_buffering_mode : (Output_Stream , io_exceptions::Buffering_Mode) -> Void;
                get_buffering_mode : Output_Stream -> io_exceptions::Buffering_Mode;
                get_writer : Output_Stream -> (Filewriter , io_exceptions::Buffering_Mode);
                file_pos_out : Out_Position -> File_Position;
                get_output_position : Output_Stream -> Out_Position;
                set_output_position : Out_Position -> Void;
                read_line : Input_Stream -> Null_Or(((String , Input_Stream)) );
                write_substring : (Output_Stream , Substring) -> Void;};;
    make_instream : pur::Input_Stream -> Input_Stream;
    get_instream : Input_Stream -> pur::Input_Stream;
    set_instream : (Input_Stream , pur::Input_Stream) -> Void;
    get_output_position : Output_Stream -> pur::Out_Position;
    set_output_position : (Output_Stream , pur::Out_Position) -> Void;
    make_outstream : pur::Output_Stream -> Output_Stream;
    get_outstream : Output_Stream -> pur::Output_Stream;
    set_outstream : (Output_Stream , pur::Output_Stream) -> Void;
    read_line : Input_Stream -> Null_Or(String );
    read_lines : Input_Stream -> List(String );
    as_lines : String -> List(String );
    write_substring : (Output_Stream , Substring) -> Void;
    from_lines : String -> List(String ) -> Void;
    exists : String -> Bool;
    open_for_read : String -> Input_Stream;
    open_string : String -> Input_Stream;
    open_for_write : String -> Output_Stream;
    open_for_append : String -> Output_Stream;
    stdin : Input_Stream;
    stdout : Output_Stream;
    stderr : Output_Stream;
    print : String -> Void;
        scan_stream :
            (number_string::Reader((Element, pur::Input_Stream)) -> number_string::Reader((X, pur::Input_Stream)))
            ->
            Input_Stream -> Null_Or(X );
    say : (Void -> String) -> Void;
    note : (Void -> String) -> Void;
    warn : (Void -> String) -> Void;
    fatal : String -> X;
    note_in_ramlog : (Void -> String) -> Void;
    exception NO_SUCH_LOGTREE_NODE;
        Logtree_Node
        = LOGTREE_NODE
        {children:Ref(List(Logtree_Node ) ), logging:Ref(Bool ), name:String, parent:Null_Or(Logtree_Node )};
        Log_To
          = LOG_TO_FILE String | LOG_TO_NULL | LOG_TO_STDERR | LOG_TO_STDOUT | LOG_TO_STREAM Output_Stream;
    logger_cleanup : Ref((Void -> Void) );
    set_logger_to : Log_To -> Void;
    logger_is_set_to : Void -> Log_To;
    all_logging : Logtree_Node;
    standardlib_logging : Logtree_Node;
    compiler_logging : Logtree_Node;
    make_logtree_leaf : {default:Bool, name:String, parent:Logtree_Node} -> Logtree_Node;
    name_of_logtree_node : Logtree_Node -> String;
    parent_of_logtree_node : Logtree_Node -> Null_Or(Logtree_Node );
    enable : Logtree_Node -> Void;
    disable : Logtree_Node -> Void;
    enable_node : Logtree_Node -> Void;
    am_logging : Logtree_Node -> Bool;
    subtree_nodes_and_log_flags : Logtree_Node -> List(((Logtree_Node , Bool)) );
    ancestors_of_logtree_node : Logtree_Node -> List(String );
    find_logtree_node_by_name : String -> Logtree_Node;
    print_logtree : Void -> Void;
    logprint : String -> Void;
    log_if : Logtree_Node -> Int -> (Void -> String) -> Void;
    current_thread_info__hook : Ref(Null_Or((Void -> (Int , String , Int)) ) );};
\end{verbatim}\index[fun]{current\_thread\_info\_\_hook}
\index[fun]{log\_if}
\index[fun]{logprint}
\index[fun]{print\_logtree}
\index[fun]{find\_logtree\_node\_by\_name}
\index[fun]{ancestors\_of\_logtree\_node}
\index[fun]{subtree\_nodes\_and\_log\_flags}
\index[fun]{am\_logging}
\index[fun]{enable\_node}
\index[fun]{disable}
\index[fun]{enable}
\index[fun]{parent\_of\_logtree\_node}
\index[fun]{name\_of\_logtree\_node}
\index[fun]{make\_logtree\_leaf}
\index[fun]{compiler\_logging}
\index[fun]{standardlib\_logging}
\index[fun]{all\_logging}
\index[fun]{logger\_is\_set\_to}
\index[fun]{set\_logger\_to}
\index[fun]{logger\_cleanup}
\index[fun]{note\_in\_ramlog}
\index[fun]{fatal}
\index[fun]{warn}
\index[fun]{note}
\index[fun]{say}
\index[fun]{scan\_stream}
\index[fun]{print}
\index[fun]{stderr}
\index[fun]{stdout}
\index[fun]{stdin}
\index[fun]{open\_for\_append}
\index[fun]{open\_for\_write}
\index[fun]{open\_string}
\index[fun]{open\_for\_read}
\index[fun]{exists}
\index[fun]{from\_lines}
\index[fun]{write\_substring}
\index[fun]{as\_lines}
\index[fun]{read\_lines}
\index[fun]{read\_line}
\index[fun]{set\_outstream}
\index[fun]{get\_outstream}
\index[fun]{make\_outstream}
\index[fun]{set\_output\_position}
\index[fun]{get\_output\_position}
\index[fun]{set\_instream}
\index[fun]{get\_instream}
\index[fun]{make\_instream}
\index[fun]{write\_substring}
\index[fun]{read\_line}
\index[fun]{set\_output\_position}
\index[fun]{get\_output\_position}
\index[fun]{file\_pos\_out}
\index[fun]{get\_writer}
\index[fun]{get\_buffering\_mode}
\index[fun]{set\_buffering\_mode}
\index[fun]{close\_output}
\index[fun]{flush}
\index[fun]{write\_one}
\index[fun]{write}
\index[fun]{make\_outstream}
\index[fun]{file\_position\_in}
\index[fun]{get\_reader}
\index[fun]{end\_of\_stream}
\index[fun]{close\_input}
\index[fun]{read\_all}
\index[fun]{read\_n}
\index[fun]{read\_one}
\index[fun]{read}
\index[fun]{make\_instream}
\index[fun]{close\_output}
\index[fun]{flush}
\index[fun]{write\_one}
\index[fun]{write}
\index[fun]{end\_of\_stream}
\index[fun]{close\_input}
\index[fun]{peek}
\index[fun]{read\_all}
\index[fun]{read\_n}
\index[fun]{read\_one}
\index[fun]{read}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
