<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Coding Conventions</TITLE>
</HEAD>
<BODY >
<A HREF="my-Script_Structure.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Preface-10.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H2 CLASS="section"><A NAME="htoc308">12.2</A>  Coding Conventions</H2><H3 CLASS="subsection"><A NAME="htoc309">12.2.1</A>  Preface</H3><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;The limits of my language are the limits of my world.&#X201D;<BR>
                                                &#X2014;</FONT><FONT SIZE=1><EM>Ludwig Wittgenstein</EM></FONT><FONT SIZE=1>
</FONT></BLOCKQUOTE><P>Shared conventions make communication possible.</P><P>Language is a set of conventions important due not to any intrinsic 
property, but due to the extrinsic property that they are shared by 
others: <EM>knight</EM> is a better spelling than <EM>nait</EM> not because 
the former is more phonetic (which it no longer is, thanks to phonetic 
drift) but because it will be immediately understood by billions of 
other people, which the latter will not.</P><P>Early scribes spent centuries learning to put vowels in words 
and blanks between them. Editors draw on thousands of years of experience 
to make books more readable. </P><P>The world is moving faster today; we don&#X2019;t have thousands of years of 
programming experience to draw on, nor can we spend centuries learning 
to put vowels in our identifiers. We have to work harder, faster and 
smarter to make our code readable. We have to be better. </P><H3 CLASS="subsection"><A NAME="htoc310">12.2.2</A>  The Prime Directives</H3><P>Readability is everything.</P><P>Use common sense.</P><P>Don&#X2019;t break rules capriciously, but do break rules when necessary.</P><H3 CLASS="subsection"><A NAME="htoc311">12.2.3</A>  External identifiers</H3><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;Short words are best and the old words when short are best of all.&#X201D;<BR>
</FONT><P><FONT SIZE=1>                                                &#X2014;</FONT><FONT SIZE=1><EM>Winston Churchill</EM></FONT><FONT SIZE=1>
</FONT></P></BLOCKQUOTE><P>When defining exported symbols, clarity trumps brevity: The client 
programmer can always define abbreviations as desired.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Construct exported identifiers from complete words separated by underbars. 
Do not use word fragments; do not drop vowels; do not run words together. 
Use acronyms only when universal, such as <SPAN STYLE="font-variant:small-caps">ASCII</SPAN>. 
</LI><LI CLASS="li-itemize">A verb followed by a noun makes a good function name.
</LI><LI CLASS="li-itemize">An adjective followed by a noun makes a good type or constant name.
</LI><LI CLASS="li-itemize">Eschew obfustication. Prefer short, plain words whenever practical. Do not utilize <EM>utilize</EM>; use <EM>use</EM>.
</LI></UL><P>Be specific &#X2014; call a rock a &#X201C;rock&#X201D;, not a &#X201C;thing&#X201D;. 
Do not be coy; do not keep secrets from the reader. Programs 
are not murder mystery novels.</P><P>When you pick an external identifier, your target audience 
should be someone who has never heard of your package, someone 
who is diving into an unfamiliar ten-million-line program with 
thirty minutes to fix an obscure bug before people start dying. 
This person does have time to puzzle out cryptic identifiers; 
they need to be blindingly obvious. </P><P>Save a life: Make your external identifiers exactly as long 
as they need to be, neither more nor less. Sweat blood to make 
them clear. </P><H3 CLASS="subsection"><A NAME="htoc312">12.2.4</A>  Internal identifiers</H3><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;The difference between the right word<BR>
  and the almost right word is the difference<BR>
  between lightning and a lightning bug.&#X201D;<BR>
</FONT><P><FONT SIZE=1>                                                &#X2014;</FONT><FONT SIZE=1><EM>Mark Twain</EM></FONT><FONT SIZE=1>
</FONT></P></BLOCKQUOTE><P>Identifier length should be proportional to scope 
and inversely proportional to frequency of use.</P><P>Favor short old words over long neologisms.</P><P>Favor complete words over word fragments 
and abbreviations; use the latter only 
when they unquestionably improve readability.</P><P>Use verbs to name functions 
and nouns to name other values. </P><P>Comment abbreviations 
when introduced if not absolutely obvious.</P><H3 CLASS="subsection"><A NAME="htoc313">12.2.5</A>  Expressions</H3><P>When adjacent identifiers contain underbars or double-colons, 
separate them by a double or triple blank:
</P><PRE CLASS="verbatim">    foo bar zot        # Single blanks fine here.
    foo_bar  zot       # Double blanks needed here..
</PRE><H3 CLASS="subsection"><A NAME="htoc314">12.2.6</A>  Package names</H3><P>Use nouns or noun phrases. </P><P>Exception: If the package encapsulates only an algorithm, use a verb or verb phrase.</P><P>Favor the singular over the plural: <TT>snark.pkg</TT> not <TT>snarks.pkg</TT>. 
(But do use the latter when implementing sets of snarks.)</P><H3 CLASS="subsection"><A NAME="htoc315">12.2.7</A>  Layout</H3><P>Layout is the art of using syntax to elucidate semantics. </P><P>We use whitespace, indentation, alignment and bridge comments 
to make the code&#X2019;s logical structure leap off the page for 
the reader.</P><H3 CLASS="subsection"><A NAME="htoc316">12.2.8</A>  Indentation</H3><P>Indent four blanks per nested scope.</P><H3 CLASS="subsection"><A NAME="htoc317">12.2.9</A>  Alignment</H3><P>Neatness counts! </P><P>Where practical, line stuff up to take advantage 
of early stages in the visual processing pipeline.</P><P>For example, reformatting
</P><PRE CLASS="verbatim">            my (f, e) = if (f &lt; 1.0) scale_up (f, e);
                     elif (f &gt;= 10.0) scale_dn (f, e);
                       else (f, e); fi;
</PRE><P>as
</P><PRE CLASS="verbatim">            my (f, e)
                =
                if    (f &lt;   1.0)   scale_up (f, e);
                elif  (f &gt;= 10.0)   scale_dn (f, e);
                                             (f, e);
                fi;
</PRE><P>makes the code easier to read.</P><P>Similarly, it is much harder to spot the misspelling in
</P><PRE CLASS="verbatim">fun is_const (VARIABLE_IN_EXPRESSION _) =&gt; FALSE;
  is_const ( VALCON_IN_EXPRESSION _)=&gt; TRUE;
 is_const ( INT_CONSTANT_IN_EXPRESSION  _)=&gt;  TRUE;
   is_const ( UNT_CONSTANT_IN_EXPRESION _) =&gt;TRUE;
  is_const (FLOAT_CONSTANT_IN_EXPRESSION  _) =&gt; TRUE;
   is_const (STRING_CONSTANT_IN_EXPRESSION  _)=&gt;  TRUE;
  is_const ( CHAR_CONSTANT_IN_EXPRESSION _) =&gt; TRUE;
  is_const ( FN_EXPRESSION _) =&gt;  TRUE;
 end;
</PRE><P>than in
</P><PRE CLASS="verbatim">fun is_const (       VARIABLE_IN_EXPRESSION     _) =&gt;  FALSE;
    is_const (         VALCON_IN_EXPRESSION     _) =&gt;  TRUE;
    is_const (   INT_CONSTANT_IN_EXPRESSION     _) =&gt;  TRUE;
    is_const (   UNT_CONSTANT_IN_EXPRESION      _) =&gt;  TRUE;
    is_const ( FLOAT_CONSTANT_IN_EXPRESSION     _) =&gt;  TRUE;
    is_const (STRING_CONSTANT_IN_EXPRESSION     _) =&gt;  TRUE;
    is_const (  CHAR_CONSTANT_IN_EXPRESSION     _) =&gt;  TRUE;
    is_const (                FN_EXPRESSION     _) =&gt;  TRUE;
end;
</PRE><P>Be nice to your precortical visual pathway and it will be nice to you.</P><H3 CLASS="subsection"><A NAME="htoc318">12.2.10</A>  Whitespace</H3><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;Consistently separating words<BR>
  by spaces became a general custom<BR>
  about the tenth century A.D.,<BR>
  and lasted until about 1957,<BR>
  when FORTRAN abandoned the practice.&#X201D;<BR>
</FONT><P><FONT SIZE=1>                                                &#X2014;</FONT><FONT SIZE=1><EM>Sun FORTRAN Reference Manual</EM></FONT><FONT SIZE=1>
</FONT></P></BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;The right word may be effective,<BR>
  but no word was ever as effective<BR>
  as a rightly timed pause."<BR>
</FONT><P><FONT SIZE=1>                                                &#X2014;</FONT><FONT SIZE=1><EM>Mark Twain&#X2019;s Speeches</EM></FONT><FONT SIZE=1>
</FONT></P></BLOCKQUOTE><P>Whitespace is Your Friend. Use it liberally to enhance readability. 
Open up your code; give it room to breathe.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Put whitespace after a comma or semicolon.
</LI><LI CLASS="li-itemize">Break code blocks into paragraphs with blank lines.
</LI><LI CLASS="li-itemize">Put three blank lines between functions of significant length.
</LI></UL><H3 CLASS="subsection"><A NAME="htoc319">12.2.11</A>  Bridge comments</H3><P>Use bridge comments to visually connect the dots. </P><P>For example, often the proximity of the first two lines 
of a close-packed case statement confuses the 
eye</P><PRE CLASS="verbatim">    case (mimble mamble mumble)
        TIMBLE =&gt; tamble tumble;
        FIMBLE =&gt; famble fumble;
    esac;
</PRE><P>but adding a blank line makes the case 
statement visually fall to pieces: </P><PRE CLASS="verbatim">    case (mimble mamble mumble)

        TIMBLE =&gt; tamble tumble;
        FIMBLE =&gt; famble fumble;
    esac;
</PRE><P>A bridge comment gives the code room 
to breathe while still tying it together into 
a visual whole: </P><PRE CLASS="verbatim">    case (mimble mamble mumble)
        #
        TIMBLE =&gt; tamble tumble;
        FIMBLE =&gt; famble fumble;
    esac;
</PRE><H3 CLASS="subsection"><A NAME="htoc320">12.2.12</A>  Case expressions</H3><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;Writing it is easy, understanding it is hard.&#X201D;<BR>
                                                &#X2014;</FONT><FONT SIZE=1><EM>Anonymous</EM></FONT><FONT SIZE=1>
</FONT></BLOCKQUOTE><P>Thou shalt not wrap useless parentheses around entire case expressions.</P><P>Thou shalt not wrap useless parentheses around entire rule patterns.</P><P>The canonical layouts are</P><PRE CLASS="verbatim">    case expression
        #
        pattern =&gt; expression;
        pattern =&gt; expression;
        pattern =&gt; expression;
        ...
    esac;

    case expression
        #
        pattern
            =&gt;
            {   statement;
                statement;
                statement;
                ...
            }; 

        pattern
            =&gt;
            {   statement;
                statement;
                statement;
                ...
            }; 

        pattern
            =&gt;
            {   statement;
                statement;
                statement;
                ...
            }; 


         ...
    esac;
</PRE><P>Avoid mixing the two models. If you must 
have both mono-line and multi-line alternatives 
within the same <TT>case</TT>, group the mono-line 
alternatives together at the top if possible.</P><H3 CLASS="subsection"><A NAME="htoc321">12.2.13</A>  Record expressions</H3><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;Real Programmers don&#X2019;t comment their code.<BR>
  It was hard to write; it should be hard to read.&#X201D;<BR>
                                                &#X2014;</FONT><FONT SIZE=1><EM>Anonymous</EM></FONT><FONT SIZE=1>
</FONT></BLOCKQUOTE><P>Lay out records like <TT>case</TT> statements, 
but with two-blank initial indents:</P><PRE CLASS="verbatim">    { key   =&gt; value,
      key   =&gt; value,
      key   =&gt; value
    };

    { long_key
          =&gt;
          big_epression,

      long_key
          =&gt;
          big_epression,

      long_key
          =&gt;
          big_epression
    };
</PRE><P>As always, try to put the shortest alternatives first.</P><H3 CLASS="subsection"><A NAME="htoc322">12.2.14</A>  Except statements</H3><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;Easy writing makes damned hard reading.&#X201D;<BR>
                                        &#X2014;</FONT><FONT SIZE=1><EM>Richard Brinsley Sheridan </EM></FONT><FONT SIZE=1>
</FONT></BLOCKQUOTE><P>Multi-key <TT>except</TT> statements are implicit <TT>case</TT> statements.
Lay them out accordingly.</P><P>The canonical layouts are</P><PRE CLASS="verbatim">    expression
    except
        key = expression;

    expression
    except
        long_key
            =
            {   statement;
                statement;
                statement;
                ...
            };

    expression
    except
        key =&gt; expression;
        key =&gt; expression;
        key =&gt; expression;
        ...
    end;


    expression
    except
        long_key
            =&gt;
            {   statement;
                statement;
                statement;
                ...
            };

        long_key
            =&gt;
            {   statement;
                statement;
                statement;
                ...
            };

        long_key
            =&gt;
            {   statement;
                statement;
                statement;
                ...
            };
    end;

</PRE><H3 CLASS="subsection"><A NAME="htoc323">12.2.15</A>  Function definitions</H3><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;I notice that you use plain, simple language,<BR>
  short words and brief sentences. That is the<BR>
  way to write English &#X2014; it is the modern way<BR>
  and the best way. Stick to it; don&#X2019;t let fluff<BR>
  and flowers and verbosity creep in.<BR><BR>
&#X201C;When you catch an adjective, kill it.<BR>
  No, I don&#X2019;t mean utterly, but kill most<BR>
  of them &#X2014; then the rest will be valuable.<BR>
  They weaken when they are close together.<BR>
  They give strength when they are wide apart.<BR><BR>
&#X201C;An adjective habit, or a wordy, diffuse,<BR>
  flowery habit, once fastened upon a person,<BR>
  is as hard to get rid of as any other vice.&#X201D;<BR><BR>
                                                &#X2014;</FONT><FONT SIZE=1><EM>Mark Twain</EM></FONT><FONT SIZE=1>
</FONT></BLOCKQUOTE><P>Default format is:</P><PRE CLASS="verbatim">    fun foo arguments
        =
        body;
</PRE><P>In the typical case where the body contains more than one statement, this becomes</P><PRE CLASS="verbatim">    fun foo arguments
        =
        {   statement;
            statement;
        }
</PRE><P>With a long argument list this becomes one of</P><PRE CLASS="verbatim">    fun foo
            argument
            argument
            argument
            ...
        =
        {   statement;
            statement;
        }

    fun bar
        (
            argument
            argument
            argument
            ...
        )
        =
        {   statement;
            statement;
        }
</PRE><P>Use a <TT>where</TT> clause to improve readability 
when the function body consists of some definitions 
combined in the result:</P><PRE CLASS="verbatim">    fun foo arguments
        =
        bar zot
        where
            bar = expression;
            zot = expression;
        end;
</PRE><P>Use one-line function definitions only to expose parallelism:</P><PRE CLASS="verbatim">    fun foo = tum diddle dum;
    fun bar = tum diddle dee;
</PRE><P>Pattern-matching function definitions are implicit <TT>case</TT> 
statements. Lay them out accordingly:</P><PRE CLASS="verbatim">    fun foo arguments =&gt; expression;
        foo arguments =&gt; expression;
        foo arguments =&gt; expression;
        ...
    end;

    fun foo arguments
            =&gt;
            {    statement;
                 statement;
                 statement;
                 ...
            };

        foo arguments
            =&gt;
            {    statement;
                 statement;
                 statement;
                 ...
            };

        foo arguments
            =&gt;
            {    statement;
                 statement;
                 statement;
                 ...
            };
    end;

</PRE><H3 CLASS="subsection"><A NAME="htoc324">12.2.16</A>  If statements</H3><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;Strunk felt that the reader was in serious<BR>
  trouble most of the time, a man floundering<BR>
  in a swamp, and that it was the duty of anyone<BR>
  attempting to write English to drain the swamp<BR>
  quickly and get his man up on dry ground, or<BR>
  at least throw him a rope.&#X201D;<BR><BR>
                                                &#X2014;</FONT><FONT SIZE=1><EM>EB White</EM></FONT><FONT SIZE=1>
</FONT></BLOCKQUOTE><P>Thou shalt not wrap useless parentheses around entire <TT>if</TT> conditions.</P><P>The canonical <TT>if</TT> statement layouts are</P><PRE CLASS="verbatim">
    if condition     action;   fi;

    if condition     action;
    else             action;
    fi;


    if condition
        #
        big expression;
    else
        big expression;
    fi;

    if condition
        #
        statement;
        statement;
        ...
    fi;

    if condition
        #
        statement;
        statement;
        ...
    else
        statement;
        statement;
        ...
    fi;

</PRE><P>Use the most readable alternative.</P><P>Fine points:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Put the shortest alternative first, negating the condition as necessary.
</LI><LI CLASS="li-itemize">Try to keep all indentations a multiple of four blanks.
</LI></UL><H3 CLASS="subsection"><A NAME="htoc325">12.2.17</A>  ?? ::</H3><P>The canonical layouts are</P><PRE CLASS="verbatim">    condition   ??   expression   ::   expression;

    condition   ??   expression 
                ::   expression;

</PRE><P>If neither of those work, use an <TT>if</TT>.</P><H3 CLASS="subsection"><A NAME="htoc326">12.2.18</A>  Commenting</H3><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;Do not say a little in many words,<BR>
  but a great deal in a few.&#X201D;<BR>
                                                &#X2014;</FONT><FONT SIZE=1><EM>Pythagoras (582-497 BCE)</EM></FONT><FONT SIZE=1>
</FONT></BLOCKQUOTE><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;Omit needless words! Omit needless words! Omit needless words!&#X201D;<BR>
                                                &#X2014;</FONT><FONT SIZE=1><EM>Will Strunk</EM></FONT><FONT SIZE=1>
</FONT></BLOCKQUOTE><P>Commenting is a form of expository writing, and as such 
the rules of expository writing apply: </P><UL CLASS="itemize"><LI CLASS="li-itemize">
Use complete words. 
</LI><LI CLASS="li-itemize">Use complete sentences. 
</LI><LI CLASS="li-itemize">Punctuate. 
</LI><LI CLASS="li-itemize">Prefer active voice to passive voice. 
</LI></UL><P>Briefer is better &#X2014; but clarity beats brevity. </P><P>If you don&#X2019;t already have a copy, buy and read 
Strunk and White&#X2019;s <I>Elements of Style</I>. 
It is the best book on commenting available. 
Get the classic version they wrote, not the 
recent version mangled after their deaths 
without their permission nor taste. </P><P>Break comment lines at 40-50 characters &#X2014; 72 maximum.</P><P>Write high-level comments motivating the package 
as well as low-level ones elucidating details.</P><P>Put a motivating comment before each major function. 
Use short imperative sentences: 
</P><PRE CLASS="verbatim">    # Boojum the snarks thrice each
    # to re-establish the softly and
    # silently vanishing invariants:
    #
    fun boojum_snarks  snark_list
        =
        {
            ...
        };
</PRE><P>Do not use comments as a crutch. If you find yourself writing </P><PRE CLASS="verbatim">    bpl = [];   # Breakpoint list.
</PRE><P>it means you should rename <TT>bpl</TT> to <TT>breakpoint_list</TT>. (When 
cleaning up other people&#X2019;s code I find that more often than not the 
comment where an identifier is declared contains the proper name of 
that identifier.)</P><P>Don&#X2019;t be stupid. Comments like
</P><PRE CLASS="verbatim">    close file;         # Close file.
</PRE><P>do not help anyone. Make every word count.</P><P>Do not needlessly break a sentence or clause across lines. 
For example, do not write 
</P><PRE CLASS="verbatim">    # Oh frabjous day, we have a boojum.  Softly
    # and silently steal it away.
</PRE><P>but rather
</P><PRE CLASS="verbatim">    # Oh frabjous day, we have a boojum.
    # Softly and silently steal it away.
</PRE><H3 CLASS="subsection"><A NAME="htoc327">12.2.19</A>  Favor Subpackages Over Prefixes</H3><P>In general it is better to use subpackages rather than identifier prefixes 
for sumtype namespace management. For example</P><PRE CLASS="verbatim">    package wa {
        Window_Attribute
          = BACKGROUND_NONE
          | BACKGROUND_PARENT_RELATIVE
          | BACKGROUND_RW_PIXMAP          dt::Rw_Pixmap
          | BACKGROUND_RO_PIXMAP          dt::Ro_Pixmap
          | BACKGROUND_COLOR              rgb::Rgb
          #
          | BORDER_COPY_FROM_PARENT
          | BORDER_RW_PIXMAP              dt::Rw_Pixmap
          | BORDER_RO_PIXMAP              dt::Ro_Pixmap
          | BORDER_COLOR                  rgb::Rgb
          #
          | BIT_GRAVITY                   xt::Gravity
          | WINDOW_GRAVITY                xt::Gravity
          #
          | CURSOR_NONE
          | CURSOR                        cs::Xcursor
          ;
    };
</PRE><P>is better than</P><PRE CLASS="verbatim">    Window_Attribute
      = WA_BACKGROUND_NONE
      | WA_BACKGROUND_PARENT_RELATIVE
      | WA_BACKGROUND_RW_PIXMAP          dt::Rw_Pixmap
      | WA_BACKGROUND_RO_PIXMAP          dt::Ro_Pixmap
      | WA_BACKGROUND_COLOR              rgb::Rgb
      #
      | WA_BORDER_COPY_FROM_PARENT
      | WA_BORDER_RW_PIXMAP              dt::Rw_Pixmap
      | WA_BORDER_RO_PIXMAP              dt::Ro_Pixmap
      | WA_BORDER_COLOR                  rgb::Rgb
      #
      | WA_BIT_GRAVITY                   xt::Gravity
      | WA_WINDOW_GRAVITY                xt::Gravity
      #
      | WA_CURSOR_NONE
      | WA_CURSOR                        cs::Xcursor
      ;
</PRE><P>The crucial difference is that the subpackage formulation gives 
the application programmer the option of abbreviating</P><PRE CLASS="verbatim">    case attribute
        #
        wa::BACKGROUND_NONE            =&gt; ... ;
        wa::BACKGROUND_PARENT_RELATIVE =&gt; ... ;
        wa::BACKGROUND_RW_PIXMAP _     =&gt; ... ;
        wa::BACKGROUND_RO_PIXMAP _     =&gt; ... ;
        wa::BACKGROUND_COLOR     _     =&gt; ... ;
        wa::BORDER_COPY_FROM_PARENT    =&gt; ... ;
        wa::BORDER_RW_PIXMAP     _     =&gt; ... ;
        wa::BORDER_RO_PIXMAP     _     =&gt; ... ;
        wa::BORDER_COLOR         _     =&gt; ... ;
        wa::BIT_GRAVITY          _     =&gt; ... ; 
        wa::WINDOW_GRAVITY       _     =&gt; ... ;
        wa::CURSOR_NONE          _     =&gt; ... ;
        wa::CURSOR               _     =&gt; ... ;
    esac;
</PRE><P>as</P><PRE CLASS="verbatim">    {   include package   wa;

        case attribute
            #
            BACKGROUND_NONE            =&gt; ... ;
            BACKGROUND_PARENT_RELATIVE =&gt; ... ;
            BACKGROUND_RW_PIXMAP _     =&gt; ... ;
            BACKGROUND_RO_PIXMAP _     =&gt; ... ;
            BACKGROUND_COLOR     _     =&gt; ... ;
            BORDER_COPY_FROM_PARENT    =&gt; ... ;
            BORDER_RW_PIXMAP     _     =&gt; ... ;
            BORDER_RO_PIXMAP     _     =&gt; ... ;
            BORDER_COLOR         _     =&gt; ... ;
            BIT_GRAVITY          _     =&gt; ... ; 
            WINDOW_GRAVITY       _     =&gt; ... ;
            CURSOR_NONE          _     =&gt; ... ;
            CURSOR               _     =&gt; ... ;
        esac;
    };
</PRE><P>but the prefix formulation allows no such convenient de-uglification trick.</P><P>This rule is a special case of: <I>Favor explicit representations over implicit ones</I>.</P><H3 CLASS="subsection"><A NAME="htoc328">12.2.20</A>  <TT>.api</TT> files</H3><P>Any <TT>.pkg</TT> file longer than a screenful should have an explicitly 
defined API, usually in an <TT>.api</TT> file, occasionally at the top 
of the <TT>.pkg</TT> file.</P><P>Favor strong sealing when in doubt. (But some packages will need 
to use weak sealing in order to export sufficient type information 
to allow equality comparisons to do what you want.) </P><P>Reading your <SPAN STYLE="font-variant:small-caps">API</SPAN> definition (and any dependent documentation) should 
be sufficient for use; client programmers should not have to read 
the <TT>pkg</TT> definition proper in order to use it.</P><P>"A human being should be able to change a diaper, plan an invasion,
butcher a hog, conn a ship, design a building, write a sonnet, balance 
accounts, build a wall, set a bone, comfort the dying, take orders,
give orders, cooperate, act alone, solve equations, analyze a new 
problem, pitch manure, program a computer, cook a tasty meal, fight 
efficiently, die gallantly. Specialization is for insects."</P><P>&#X2014; Robert A Heinlein </P><P>Particularly programmers. In an age of narrow specialists, 
the programmer is the last great specializing generalist. A programmer 
may be called upon to write code to time diaper changes, coordinate 
an invasion, schedule a slaughterhouse, control a ship, construct and 
verify a building design, edit music, do accounting, control robotic 
surgery, generate and mail casualty notices, compile code, generate 
code, interact with other humans or computers, operate autonomously, 
manage meal recipes, control war drones, shut itself down cleanly. </P><H3 CLASS="subsection"><A NAME="htoc329">12.2.21</A>  Raytracing</H3><P>A nice possible turn of phrase:</P><P>Raytracing is by nature embarassingly parallel and embarassingly slow.</P><P>"Embarassingly parallel" is a technical term.</P><P>"Embarassingly slow" is not &#X2014; it means just what you think. </P><H3 CLASS="subsection"><A NAME="htoc330">12.2.22</A>  Parallel Programming</H3><P>Here be monsters!</P><P>Caveat artifex! </P><P>Parallel coding in Mythryl is currently a tricky hack and will remain so 
until the system is converted from assymetric multitasking ("AMT") to 
symmetric multitasking ("SMT"). You do not need to be an M-theory Master 
to write Mythryl parallel code, but you do need to learn the relevant 
constraints and observe them obsessively. If you do not, you will be 
entering a world of pain &#X2014; or at least a world of obscure misbehavior 
virtually impossible to diagnose and fix. </P><P>You want to know how something like Linux happens? </P><P>I&#X2019;ll tell you how something like Linux happens. </P><P>At any given time there are about a hundred people 
who could do a project like that. </P><P>And up on the Hacker&#X2019;s Astral Plane they&#X2019;re sitting 
around the pool drinking. And one of them says, 
"Look you know this has to be done. One of us is 
going to have to do it." </P><P>And they all look at each other and nod. </P><P>And there&#X2019;s a long silence. </P><P>And finally someone like Linus Torvalds says, 
"Ok, I&#X2019;ll do it. I&#X2019;ll write the damn thing. 
But you guys owe me. You guys owe me BIG TIME." </P><P>And he goes off and writes Linux while the rest 
party and write Facebook. </P><P>So now you know. </P><H3 CLASS="subsection"><A NAME="htoc331">12.2.23</A>  Whitespace in Mythryl</H3><P>I wrote a big post to the list on this, which should be turned 
into a section in the docs at some point. </P><P>(There is at least one other big post that should be turned into 
a doc section, but I don&#X2019;t remember the topic. &#X2014; 2012-04-30 CrT) </P><PRE CLASS="verbatim">   http://web.archiveorange.com/archive/v/omFiN7t9On3Z8tca3mLz 
 
    Helge Horch Fri Jan 27 2012 
    Hi all, 
 
    a friend of mine intends to use one of my favourite quotes for a paper: 
 
    "Programming with objects is like working with trained animals, 
     instead of pushing around data with a broom." 
 
    Since I was the one who mentioned it to him, my friend now demands a clear 
    attribution. 8-) 
 
    I *think* it was Alan Kay, and I *had* thought it was somewhere in either 
    the 1981 BYTE, the Dynabook papers, Green Book, ThingLab paper, etc. I have 
    now leaved through many pages - I can't find it. 
 
    So: Is the quote accurate? Alan's? Dan's? (Too bad you're all at OOPSLA 
    now...) Where might I have read it? 
 
    Desperately yours, 
    Helge 
 
    P.S. This is for a Forth paper. Curiously, while not being a new concept 
    for the Forth community, OOP (OOF) is constantly rediscovered. 
 
    ---------- 
 
    Alan Kay  Fri Jan 27 2012 
    Helge -- 
 
    I'm pretty sure that I didn't say this -- but it does sound like something 
    that Dan Ingalls wrote ... Have you looked at his POPL 78 article about 
    Smalltalk 76 ? 
 
    Cheers, 
 
    Alan 
 
    ---------- 
 
 
    Dan Ingalls  Fri Jan 27 2012 20:55:47 GMT-0800 (PST) 
    Helge - 
 
        "Beyond this I must add that programming in Smalltalk is fun.  On the one hand, 
         the act of assembling expressions into statements and then into methods is not 
         very different from conventional programming.  On the other hand, the experience 
         is totally different, for the objects which populate and traverse the code are 
         active entities, and writing expressions feels like organizing trained animals 
         rather than pushing boxes around." 
 
    The Smalltalk-76 Programming System 
    Design and Implementation 
    Daniel H. H. Ingalls 
    Proceedings of ACM conf on Principles of Programming Languages 
    Tucson, AZ, 1978 
 
    I like your version a lot.  The broom is good. 
 
      - Dan 
 

% ================================================================================
\subsection{Mythryl Pragmatics}
It is one thing to knowing the parts and quite another to know how to
use it without cutting your foot off.

   "Clarify globally, abbreviate locally."

 "Good libraries never die" -- libraries should raise exceptions, not call die().
 
 
</PRE>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Script_Structure.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Preface-10.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
