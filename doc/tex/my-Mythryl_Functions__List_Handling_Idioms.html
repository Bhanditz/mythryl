<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mythryl Functions: List Handling Idioms</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mythryl_Functions__Implicit_Case_Statements.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Functions__Value_Capture.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc89">5.4.4</A>  Mythryl Functions: List Handling Idioms</H3><P>Let us return to the topic of functions which manipulate lists, and see 
how to write them in idiomatically correct Mythryl.</P><P>We have presented such functions previously in these tutorials, but 
they were written in a &#X201C;C written in Mythryl syntax&#X201D; style which 
would make any experienced Mythryl programmer wince.</P><P>Recall that the fundamental operator for constructing lists is the 
Mythryl &#X2019;!&#X2019; operator &#X2014; what Lisp calls <TT>cons</TT>. By repeatedly 
using &#X2019;!&#X2019; to prepend values to the empty list, we can build up any 
valid Mythryl list:</P><PRE CLASS="verbatim">    linux$ my

    eval:  "abc" ! [];
    ["abc"]

    eval:  "abc" ! ("def" ! []);
    ["abc", "def"]

    eval:  "abc" ! ("def" ! ("ghi" ! []));
    ["abc", "def", "ghi"]
</PRE><P>Recall also that Mythryl functions allow pattern matching against 
arguments.</P><P>In fact, we now know that all the &#X201C;argument lists&#X201D; 
we have been using in our functions in the tutorials have really 
been extracting values from argument tuples via pattern 
matching. (I warned you that pattern matching keeps popping up in 
Mythryl where you least expect it!)</P><P>Put those two facts together with our new knowledge that 
Mythryl functions may accept arguments of any type &#X2014; in particular, 
lists &#X2014; and that Mythryl function syntax can encode implicit 
<TT>case</TT> statements, and we are now able to understand one of 
the list idioms dear to the Mythryl programmer&#X2019;s heart:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    fun sum_list  list_of_integers
        =
        sum_it (list_of_integers, 0)
        where
            fun sum_it (    [], sum)  =&gt; sum;
                sum_it (i ! is, sum)  =&gt; sum_it( is, sum + i);
            end;
        end;

    printf "%d\n" (sum_list [1,2,3,4] );
</PRE><P>Running the above will give you:</P><PRE CLASS="verbatim">    linux$ ./my-script
    10
</PRE><P>The above is a list-processing idiom that you will see over and over again, 
and if you write any significant amount of real Mythryl code, you will 
write it over and over again.</P><P>Three points to note:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">The <TT>where</TT> syntax.<P>We could have written the above as 
the entirely equivalent 
</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    fun sum_list  list_of_integers
        =
        {   fun sum_it (    [], sum)  =&gt; sum;
                sum_it (i ! is, sum)  =&gt; sum_it( is, sum + i);
            end;

            sum_it (list_of_integers, 0);
        };

    printf "%d\n" (sum_list [1,2,3,4] );
</PRE><P>but the preceding version is clearer because it motivates the 
<TT>sum_it</TT> function before it defines it, which makes it easier for the 
reader to understand why the function is being defined and thus how to interpret it.</P></LI><LI CLASS="li-itemize">The helper function idiom.<P>Lists are recursive datastructures, and recursive datastructure processing 
calls for recursive functions, but typically the recursive function doing 
the work needs extra result-so-far state arguments beyond those supplied 
by the original caller.</P><P>These leads to a bog-standard idiom in which the 
externally visible function is just a wrapper for the recursive function 
which does the work.</P><P>In the above example, the external caller supplied only the list 
argument, but to compute the sum we needed an extra argument 
containing the sum of the list values seen so far.</P></LI><LI CLASS="li-itemize">The <TT>[] / (i ! is)</TT> list processing idiom.<P>Look again at the initial parameter patterns in the <TT>sum_it</TT> 
function:</P><PRE CLASS="verbatim">            fun sum_it (    [], sum)  =&gt; sum;
                sum_it (i ! is, sum)  =&gt; sum_it( is, sum + i);
            end;
</PRE><P>The <TT>[]</TT> case detects end-of-iteration and returns the final result.</P><P>The <TT>i ! is</TT> case (read as &#X201C;<CODE><I>'i'</I></CODE> and more <CODE><I>'i'</I></CODE>s&#X201D;) pries one element 
off the start of the list; we process it, combine what we learn from 
it with one or more of our result-so-far state parameters, and then 
finish up by calling ourself recursively on the rest of the input list.
</P></LI></UL><P>You will see this general pattern over and over again, until you can 
recognize it at a glance.</P><P>A frequent variation of it accumulates the result-so-far in a list. 
In this case, by the time we reach the terminating <TT>[]</TT> case on 
input, our result-so-far list is in the reverse order of of the 
original input list. We have been taking values from the 
front of the input list and adding them to the front of the 
result list, so in the end the first value processed, derived from 
the first element of the input list, is now at the end of the 
result list.</P><P>Consequently, the <TT>[]</TT> case will almost always <TT>reverse</TT> the 
result list before returning it:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    fun list_to_upper  list_of_strings
        =
        f (list_of_strings, [])
        where
            fun f (    [], results_so_far)  =&gt; reverse results_so_far;
                f (s ! ss, results_so_far)  =&gt; f( ss, (string::to_upper s) ! results_so_far);
            end;
        end;

    map  (printf "%s\n") (list_to_upper [ "abc", "def", "ghi" ] );
</PRE><P>When run, the above produces</P><PRE CLASS="verbatim">    linux$ ./my-script
    ABC
    DEF
    GHI
    linux$
</PRE><P>Note how the <TT>reverse</TT> in the <TT>[]</TT> clause makes the results come out 
in the expected order. </P><P>Note also how the helper function is this time simply called <TT>f</TT>. 
I do not particularly approve of this idiom, but it is one you will 
see quite a bit in production Mythryl code, so it is good to get 
used to it. It certainly has the virtue of brevity.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mythryl_Functions__Implicit_Case_Statements.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Functions__Value_Capture.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
