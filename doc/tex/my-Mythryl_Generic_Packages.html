<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mythryl Generic Packages</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mythryl_Types__Type_Variables.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Types__Extensible_Types.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc102">5.4.17</A>  Mythryl Generic Packages</H3><P>Mythryl generics derive from David MacQueen&#X2019;s 1990 design for an SML <I>module system</I>. 
This sparked off a research effort which continues to this day. There is still 
much that we do not understand about such module systems.</P><P>One thing that is reasonably clear is that as a result of this 
research, we now for the first time have a solid engineering basis 
for programming in the large. In some ways these module systems are 
what &#X201C;object oriented&#X201D; programming should ideally have been but in 
practice could not be because we simply did not know enough back 
in 1967 when OOP originated.</P><P>The Mythryl generic package system is best understood as a compile-time 
language in which the types are <SPAN STYLE="font-variant:small-caps">API</SPAN>s, the values are 
packages, and the functions are <I>generics</I> &#X2014; entities which 
take a package as an argument and produce another package as 
result.</P><P>The process of applying a generic package to a package to produce another package 
is a lot like macro expansion &#X2014; but well-typed macro expansion with 
exquisitely carefully worked out semantics. (SML is the only programming 
language with a fully defined semantics as well as syntax. The benchmark 
definition is <I>The Definition of Standard ML (Revised)</I> by Milner, 
Tofte, Harper and MacQueen. Mythryl, which is essentially SML with a 
Posix face, inherits that semantic clarity and precision.)</P><P>Enough verbiage, let&#X2019;s look at a concrete example. We will define a 
generic binary tree which can deal with any type of key so long as 
it is sortable and of course with any type of value.</P><P>First we need to define concretely the notion of a sortable key. 
For our purpose, it consists of some type together with 
a function which can compare two values of that type and announce whether 
the first is greater, equal or less than the second.</P><P>The Mythryl standard library already defines a type <TT>Order</TT> 
which will do nicely. (Re-use is better than re-invention!)</P><P>It is defined in <A HREF="my-src_lib_core_init_order_pkg.html#src/lib/core/init/order.pkg">src/lib/core/init/order.pkg</A> as:</P><PRE CLASS="verbatim">    Order =  LESS | EQUAL | GREATER;</PRE><P>With that in hand, we can define the key concept so:</P><PRE CLASS="verbatim">    api Key {

        Key;

        compare:  (Key, Key) -&gt; Order;
    };
</PRE><P>This demands some type <TT>Key</TT> and a function <TT>compare</TT> which, 
given two <TT>Key</TT>s, returns one of <TT>LESS</TT>, <TT>EQUAL</TT> or 
<TT>GREATER</TT>. (Actually, I cheated; Key is also part of the 
Mythryl standard library, as api <A HREF="my-Key.html#api:Key">Key</A>. Never replicate what you can simply steal!)</P><P>Now we can define the API for our binary tree implementation:</P><PRE CLASS="verbatim">    api Binary_Tree {

        exception NOT_FOUND;

        package key: Key;

        Tree(X);              # Tree holding any type of value.

        make_tree:            Void -&gt; Tree(X);

        set_key_value_pair:   (Tree(X), key::Key, X) -&gt; Tree(X);

        get_key_value:        (Tree(X), key::Key) -&gt; X;
    };    
</PRE><P>Here:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>key</TT> defines the type of keys used by this particular binary tree;
</LI><LI CLASS="li-itemize">X represents the type of values held in a particular tree. (A don&#X2019;t-care wildcard type variable.)
</LI><LI CLASS="li-itemize"><TT>set_key_value_pair</TT> is a function which accepts a tree, a key and a value and returns the resulting new tree.
</LI><LI CLASS="li-itemize"><TT>get_key_value</TT> is a function which accepts a tree and a key and returns the matching value.
</LI></UL><P>To keep things simple, this is very much a toy api definition. (For an industrial-strength 
example of such an api see the <A HREF="my-Map.html#api:Map">Map</A> api in the Mythryl standard library.)</P><P>Now for the fun part. Here is a Mythryl generic package to generate implementations of our <TT>Binary_Tree</TT> api:</P><PRE CLASS="verbatim">    generic package binary_tree_g (k:  Key):  Binary_Tree where key == k
    {
        package key = k;

        exception NOT_FOUND;

        Tree X
            = EMPTY
            | TREE_NODE { key:       key::Key,
                          value:     X,
                          left_kid:  Tree(X),
                          right_kid: Tree(X)
                        };

        fun make_tree ()
            =
            EMPTY;


        fun set_key_value_pair (EMPTY, key, value)
                =&gt;
                TREE_NODE { key, value, EMPTY, EMPTY };

            set_key_value_pair (TREE_NODE { key=&gt;k, value=&gt;v, left_kid, right_kid }, key, value)
                =&gt;
                case (key::compare(key, k))

                EQUAL   =&gt; TREE_NODE { key, value, left_kid, right_kid };

                LESS    =&gt; case left_kid
                           EMPTY =&gt; TREE_NODE { key=&gt;k, value=&gt;v, left_kid=&gt; TREE_NODE { key, value, EMPTY, EMPTY },       right_kid };
                           _     =&gt; TREE_NODE { key=&gt;k, value=&gt;v, left_kid=&gt; set_key_value_pair( left_kid, key, value ), right_kid };
                           esac; 

                GREATER =&gt; case right_kid
                           EMPTY =&gt; TREE_NODE { key=&gt;k, value=&gt;v, left_kid, right_kid=&gt; TREE_NODE { key, value, EMPTY, EMPTY }      };
                           _     =&gt; TREE_NODE { key=&gt;k, value=&gt;v, left_kid, right_kid=&gt; set_key_value_pair( right_kid, key, value ) };
                           esac; 
                esac;
        end;


        fun get_key_value (EMPTY, key)
                =&gt;
                raise exception NOT_FOUND;

            get_key_value (TREE_NODE { key=&gt;k, value, left_kid, right_kid }, key)
                =&gt;
                case (key::compare(key, k))
                EQUAL   =&gt; value;
                LESS    =&gt; get_key_value(  left_kid, key );
                GREATER =&gt; get_key_value( right_kid, key );
                esac;
        end;
    };
</PRE><P>Since this tutorial is not about 
<A HREF="http://en.wikipedia.org/wiki/Binary_tree">binary trees</A> per se, we will not discuss the binary tree construction and lookup algorithms, which are anyhow very vanilla.</P><P>The main thing to note is that the above generic package looks just like a 
vanilla <TT>package</TT> declaration except that it takes a <TT>k: Key</TT> 
package argument on the first line.</P><P>(The alert reader will also have noted the <TT>where key == k</TT> modifier 
on the <TT>Binary_Tree</TT> api reference. This is necessary to specialized 
the generic package <TT>Binary_Tree</TT> api definition to the particular key type 
in use.)</P><P>Now we may generate specific binary tree implementations by invoking the 
generic package with appropriate key package arguments:</P><PRE CLASS="verbatim">    package int_key {
        Key = int::Int;
        compare = int::compare;
    };

    package binary_tree_with_int_keys
        =
        binary_tree_g( int_key );
</PRE><P>Usually there is no point in actually assigning a name to the 
argument package, so instead we pass an anonymous package 
defined on the spot:</P><PRE CLASS="verbatim">    package binary_tree_with_int_keys
        =
        binary_tree_g (
            package {
                Key = int::Int;
                compare = int::compare;
            }
        );
</PRE><P>Put it all together in a test script and it looks like this:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    api Binary_Tree {

        exception NOT_FOUND;

        package key: Key;

        Tree(X);      # Tree holding any type of value.

        make_tree:            Void -&gt; Tree(X);

        set_key_value_pair:  (Tree(X), key::Key, X) -&gt; Tree(X);

        get_key_value:        (Tree(X), key::Key) -&gt; X;
    };    

    generic package binary_tree_g (k:  Key):  Binary_Tree where key == k
    {
        package key = k;

        exception NOT_FOUND;

        Tree X
            = EMPTY |
              TREE_NODE {    key:       key::Key,
                             value:       X,
                             left_kid:  Tree(X),
                             right_kid: Tree(X)
                        };

        fun make_tree () =  EMPTY;

        fun set_key_value_pair (EMPTY, key, value)
                =&gt;
                TREE_NODE { key, value, left_kid =&gt; EMPTY, right_kid =&gt; EMPTY };

            set_key_value_pair (TREE_NODE { key=&gt;k, value=&gt;v, left_kid, right_kid }, key, value)
                =&gt;
                case (key::compare(key, k))

                EQUAL   =&gt; TREE_NODE { key, value, left_kid, right_kid };

                LESS    =&gt; case left_kid
                           EMPTY =&gt; TREE_NODE { key=&gt;k, value=&gt;v, left_kid=&gt; TREE_NODE { key, value, left_kid =&gt; EMPTY, right_kid =&gt; EMPTY }, right_kid };
                           _     =&gt; TREE_NODE { key=&gt;k, value=&gt;v, left_kid=&gt; set_key_value_pair( left_kid, key, value ),                     right_kid };
                           esac; 

                GREATER =&gt; case right_kid
                           EMPTY =&gt; TREE_NODE { key=&gt;k, value=&gt;v, left_kid, right_kid=&gt; TREE_NODE { key, value, left_kid =&gt; EMPTY, right_kid =&gt; EMPTY } };
                           _     =&gt; TREE_NODE { key=&gt;k, value=&gt;v, left_kid, right_kid=&gt; set_key_value_pair( right_kid, key, value )                    };
                           esac; 
                esac;
        end;

        fun get_key_value (EMPTY, key)
                =&gt;
                raise exception NOT_FOUND;

            get_key_value (TREE_NODE { key=&gt;k, value, left_kid, right_kid }, key)
                =&gt;
                case (key::compare(key, k))
                EQUAL   =&gt; value;
                LESS    =&gt; get_key_value(  left_kid, key );
                GREATER =&gt; get_key_value( right_kid, key );
                esac;
        end;
    };


    # Generate a package implementing
    # binary trees with Int keys:
    #
    package binary_tree_with_int_keys
        =
        binary_tree_g (
            package {
                Key     = int::Int;
                compare = int::compare;
            }
        );

    # Define a shorter synonym for the package name:
    #
    package ti = binary_tree_with_int_keys;



    # Create and exercise a binary tree with
    # Int keys and String vals:

    t = (ti::make_tree ()): ti::Tree(String);

    t = ti::set_key_value_pair( t, 1, "one"   );
    t = ti::set_key_value_pair( t, 2, "two"   );
    t = ti::set_key_value_pair( t, 3, "three" );

    printf "%d -&gt; %s\n" 1 (ti::get_key_value( t, 1 ));
    printf "%d -&gt; %s\n" 2 (ti::get_key_value( t, 2 ));
    printf "%d -&gt; %s\n" 3 (ti::get_key_value( t, 3 ));


    # Create and exercise a binary tree with
    # Int keys and Float vals:


    t = (ti::make_tree ()): ti::Tree(Float);

    t = ti::set_key_value_pair( t, 1, 1.0   );
    t = ti::set_key_value_pair( t, 2, 2.0   );
    t = ti::set_key_value_pair( t, 3, 3.0   );

    printf "%d -&gt; %f\n" 1 (ti::get_key_value( t, 1 ));
    printf "%d -&gt; %f\n" 2 (ti::get_key_value( t, 2 ));
    printf "%d -&gt; %f\n" 3 (ti::get_key_value( t, 3 ));



    # Generate a package implementing
    # binary trees with Int keys:
    #
    package binary_tree_with_string_keys
        =
        binary_tree_g (
            package {
                Key     = string::String;
                compare = string::compare;
            }
        );

    # Define a shorter synonym for the package name:
    #
    package ts = binary_tree_with_string_keys;






    # Create and exercise a binary tree with
    # String keys and Int vals:

    t = (ts::make_tree ()): ts::Tree(Int);

    t = ts::set_key_value_pair( t, "one",   1 );
    t = ts::set_key_value_pair( t, "two",   2 );
    t = ts::set_key_value_pair( t, "three", 3 );

    printf "%s -&gt; %d\n" "one"   (ts::get_key_value( t, "one"   ));
    printf "%s -&gt; %d\n" "two"   (ts::get_key_value( t, "two"   ));
    printf "%s -&gt; %d\n" "three" (ts::get_key_value( t, "three" ));



    # Create and exercise a binary tree with
    # String keys and Float vals:

    t = (ts::make_tree ()): ts::Tree(Float);

    t = ts::set_key_value_pair( t, "one",   1.0 );
    t = ts::set_key_value_pair( t, "two",   2.0 );
    t = ts::set_key_value_pair( t, "three", 3.0 );

    printf "%s -&gt; %f\n" "one"   (ts::get_key_value( t, "one"   ));
    printf "%s -&gt; %f\n" "two"   (ts::get_key_value( t, "two"   ));
    printf "%s -&gt; %f\n" "three" (ts::get_key_value( t, "three" ));
</PRE><P>Here is a demo run of the script:</P><PRE CLASS="verbatim">    linux$ ./my-script
    1 -&gt; one
    2 -&gt; two
    3 -&gt; three
    1 -&gt; 1.000000
    2 -&gt; 2.000000
    3 -&gt; 3.000000
    one -&gt; 1
    two -&gt; 2
    three -&gt; 3
    one -&gt; 1.000000
    two -&gt; 2.000000
    three -&gt; 3.000000
    linux$ ./my-script
</PRE><P>So there you have it &#X2014; four different tree varieties 
from a single code specification. (And, obviously, we 
could have generated dozens more with negligible 
additional effort.)</P><P>Bottom line: Mythryl generics provide a powerful programming tool for increasing 
code reusability.</P><P>For an industrial-strength version of the above example 
see <A HREF="my-src_lib_src_red-black-map-g_pkg.html#src/lib/src/red-black-map-g.pkg">src/lib/src/red-black-map-g.pkg</A>.</P>
<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mythryl_Types__Type_Variables.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Types__Extensible_Types.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
