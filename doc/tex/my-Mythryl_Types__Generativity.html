<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mythryl Types: Generativity</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mythryl_Types__Elementary_Types_and_Type_Constructors.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Types__Type_Variables.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc100">5.4.15</A>  Mythryl Types: Generativity</H3><P>When are two types equal? Consider these two declarations:</P><PRE CLASS="verbatim">    Student     = { name: String, address: Int };
    Code_Module = { name: String, address: Int };
</PRE><P>Should these be considered two different types, or two names for 
the same type?</P><P>Should the compiler let us store values of one type in variables 
declared with the other type?</P><P>There are two schools of thought on this subject. Neither is 
right or wrong; each has advantages and disadvantages, and 
each has been used successfully in both theory and 
practice.</P><P>One school of thought focusses on structure. If two types have 
the same basic structure, if mathematically there can be no problem 
in using them interchangably, then they are equivalent.</P><P>According to this school of thought, the above two types are both 
records, they both have fields of the same name, and those fields 
have the same elementary types. Substituting a value of one type 
for a value of another type cannot possibly make any mathematical 
difference in the course of the computation. Therefore, the two 
types are the same, just different names for the same thing.</P><P>The other school of thought focusses on names. The clear intent 
of the coder is that <TT>Student</TT> records represent humans, giving their 
name and room number (or some such), whereas <TT>Code_Module</TT> 
records represent bits of executable code, giving their declared 
name and their current location in memory. Treating a room number 
as a memory address cannot possibly give rational results, nor is 
adding the name of a code module to a class enrollment list likely 
to accomplish anything useful.</P><P>According to this school of thought, the above two declarations 
were written for entirely different purposes, and the compiler 
should definitely do its best to prevent inadvertent mixing of 
the two types of values.</P><P>As a matter of practice, the name-oriented approach to typing has 
tended to dominate in programming languages developed by 
working programmers for industrial use &#X2014; languages like C. It 
is very simple to implement and understand.</P><P>The structure-oriented approach, by contrast, has tended to dominate 
in programming languages developed by computer science theoreticians 
for research purposes. It has very clean mathematical semantics.</P><P>The Mythryl type system belongs to the structure-oriented school. 
If it were not, almost none of the machinery we have covered in 
these tutorials would be workable. For example, almost every call to 
a function implicitly defines an anonymous tuple type. Lacking 
names, a name-oriented compiler would be unable to decide whether 
that function call made sense from a type point of view. The 
structure-oriented approach, by contrast, has no problem doing 
type analysis of such masses of anonymous tuple types.</P><P>One major exception is that every sumtype declaration creates a 
new type:</P><PRE CLASS="verbatim">    package a {  Color = RED | GREEN | BLUE; };
    package b {  Color = RED | GREEN | BLUE; };
</PRE><P>The two types <TT>a::Color</TT> and <TT>b::Color</TT> are different even 
though their definitions are identical. If you want them to be 
equal, you should have one package borrow its definition from the other:</P><PRE CLASS="verbatim">    package a {  Color = RED | GREEN | BLUE; };
    package b {  Color = a::Color; };
</PRE><P>Still, that far from exhausts the discussion.</P><P>What does one do if one definitely wants to create a new type distinct 
from all others? What happens when a type is exported but its 
definition is not? Are two such types exported from different modules 
equivalent or not?</P><P>Theoreticians can and do spend entire careers exploring such questions 
and the consequences of different policy choices. Grab a copy of 
Pierce&#X2019;s <I>Types and Programming Languages</I> if you&#X2019;re interested. 
Here we are just going to summarize the basics of what Mythryl does 
and how to take advantage of it in practical programming.</P><P>First a bit of nomenclature. A type is <I>opaque</I> if it is exported 
from a package without exposing its underlying structure. It is 
<I>transparent</I> otherwise. For example:</P><PRE CLASS="verbatim">    api Silly {
        My_Opaque_Color;
        My_Transparent_Color = RED | GREEN | BLUE;
    };

    package silly: Silly {
        My_Opaque_Color      = RED | GREEN | BLUE;
        My_Transparent_Color = RED | GREEN | BLUE;
    };
</PRE><P>Here the colors <TT>My_Opaque_Color</TT> and <TT>My_Transparent_Color</TT> are 
exactly identical within package <TT>silly</TT>. But due to package <TT>silly</TT> 
being cast to api <TT>Silly</TT> which hides the definition of <TT>My_Opaque_Color</TT>, 
the external world knows exactly what the definition is of <TT>My_Transparent_Color</TT>, 
but has absolutely no clue about the definition of <TT>My_Opaque_Color</TT>.</P><P>The critical Mythryl typing rules are thus three:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Every sumtype definition introduces a new type.
</LI><LI CLASS="li-itemize">Every opaque type is different from every other opaque type.
</LI><LI CLASS="li-itemize">Transparent types are equivalent if their definitions are structurally equivalent.
</LI></UL><P>One practical consequence of this is that if, as a programmer, you wish 
to create a type which is distinct from all other types in the system, 
the way to do so is to export it as an opaque type from a package.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mythryl_Types__Elementary_Types_and_Type_Constructors.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Types__Type_Variables.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
