\index[api]{Digraph}
\label{api:Digraph}
\input{top-api-Digraph.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    Other  = Exception;
    Graph;
    Node;
    Tag;
    Datum  = FLOAT Float | ID Id | INT Int | NONE | OTHER Other | STRING String | TBASE Exception;
    Tagless_Edge  = (Node , Node);
    Edge  = (Node , Tag , Node);
        package ts
          : api {   package key
                      : api {
                            Key;
                            compare : (Key , Key) -> Order;};;
                Item  = key::Key;
                Set;
                empty : Set;
                singleton : Item -> Set;
                from_list : List(Item ) -> Set;
                add : (Set , Item) -> Set;
                add' : (Item , Set) -> Set;
                add_list : (Set , List(Item )) -> Set;
                drop : (Set , Item) -> Set;
                member : (Set , Item) -> Bool;
                preceding_member : (Set , Item) -> Null_Or(Item );
                following_member : (Set , Item) -> Null_Or(Item );
                is_empty : Set -> Bool;
                equal : (Set , Set) -> Bool;
                compare : (Set , Set) -> Order;
                is_subset : (Set , Set) -> Bool;
                vals_count : Set -> Int;
                vals_list : Set -> List(Item );
                union : (Set , Set) -> Set;
                intersection : (Set , Set) -> Set;
                difference : (Set , Set) -> Set;
                map : (Item -> Item) -> Set -> Set;
                apply : (Item -> Void) -> Set -> Void;
                fold_forward : ((Item , X) -> X) -> X -> Set -> X;
                fold_backward : ((Item , X) -> X) -> X -> Set -> X;
                partition : (Item -> Bool) -> Set -> (Set , Set);
                filter : (Item -> Bool) -> Set -> Set;
                exists : (Item -> Bool) -> Set -> Bool;
                find : (Item -> Bool) -> Set -> Null_Or(Item );
                all_invariants_hold : Set -> Bool;};;
        package es
          : api {   package key
                      : api {
                            Key;
                            compare : (Key , Key) -> Order;};;
                Item  = key::Key;
                Set;
                empty : Set;
                singleton : Item -> Set;
                from_list : List(Item ) -> Set;
                add : (Set , Item) -> Set;
                add' : (Item , Set) -> Set;
                add_list : (Set , List(Item )) -> Set;
                drop : (Set , Item) -> Set;
                member : (Set , Item) -> Bool;
                preceding_member : (Set , Item) -> Null_Or(Item );
                following_member : (Set , Item) -> Null_Or(Item );
                is_empty : Set -> Bool;
                equal : (Set , Set) -> Bool;
                compare : (Set , Set) -> Order;
                is_subset : (Set , Set) -> Bool;
                vals_count : Set -> Int;
                vals_list : Set -> List(Item );
                union : (Set , Set) -> Set;
                intersection : (Set , Set) -> Set;
                difference : (Set , Set) -> Set;
                map : (Item -> Item) -> Set -> Set;
                apply : (Item -> Void) -> Set -> Void;
                fold_forward : ((Item , X) -> X) -> X -> Set -> X;
                fold_backward : ((Item , X) -> X) -> X -> Set -> X;
                partition : (Item -> Bool) -> Set -> (Set , Set);
                filter : (Item -> Bool) -> Set -> Set;
                exists : (Item -> Bool) -> Set -> Bool;
                find : (Item -> Bool) -> Set -> Null_Or(Item );
                all_invariants_hold : Set -> Bool;};;
    make_node : Void -> Node;
    make_int_node : Int -> Node;
    make_id_node : Id -> Node;
    make_string_node : String -> Node;
    make_float_node : Float -> Node;
    make_graph_node : Graph -> Node;
    make_other_node : Other -> Node;
    node_datum : Node -> Datum;
    node_int : Node -> Null_Or(Int );
    node_id : Node -> Null_Or(Id );
    node_string : Node -> Null_Or(String );
    node_float : Node -> Null_Or(Float );
    node_graph : Node -> Null_Or(Graph );
    node_other : Node -> Null_Or(Other );
    make_tag : Void -> Tag;
    make_int_tag : Int -> Tag;
    make_id_tag : Id -> Tag;
    make_string_tag : String -> Tag;
    make_float_tag : Float -> Tag;
    make_graph_tag : Graph -> Tag;
    make_other_tag : Other -> Tag;
    tag_datum : Tag -> Datum;
    tag_int : Tag -> Null_Or(Int );
    tag_id : Tag -> Null_Or(Id );
    tag_string : Tag -> Null_Or(String );
    tag_float : Tag -> Null_Or(Float );
    tag_graph : Tag -> Null_Or(Graph );
    tag_other : Tag -> Null_Or(Other );
    empty_graph : Graph;
    put_tagless_edge : (Graph , Tagless_Edge) -> Graph;
    put_edge : (Graph , Edge) -> Graph;
    drop_tagless_edge : (Graph , Tagless_Edge) -> Graph;
    drop_edge : (Graph , Edge) -> Graph;
    get_tagless_edges : Graph -> ts::Set;
    get_tagless_edges1 : (Graph , Node) -> Null_Or(ts::Set );
    get_tagless_edges2 : (Graph , Node) -> Null_Or(ts::Set );
    has_tagless_edge : (Graph , Tagless_Edge) -> Bool;
    has_edge : (Graph , Edge) -> Bool;
    get_edges : Graph -> es::Set;
    get_edges1 : (Graph , Node) -> Null_Or(es::Set );
    get_edges2 : (Graph , Tag) -> Null_Or(es::Set );
    get_edges3 : (Graph , Node) -> Null_Or(es::Set );
    get_edges12 : (Graph , Node , Tag) -> Null_Or(es::Set );
    get_edges13 : (Graph , Node , Node) -> Null_Or(es::Set );
    get_edges23 : (Graph , Tag , Node) -> Null_Or(es::Set );
    nodes_apply : Graph -> (Node -> Void) -> Void;
    tags_apply : Graph -> (Tag -> Void) -> Void;};
\end{verbatim}\index[fun]{tags\_apply}
\index[fun]{nodes\_apply}
\index[fun]{get\_edges23}
\index[fun]{get\_edges13}
\index[fun]{get\_edges12}
\index[fun]{get\_edges3}
\index[fun]{get\_edges2}
\index[fun]{get\_edges1}
\index[fun]{get\_edges}
\index[fun]{has\_edge}
\index[fun]{has\_tagless\_edge}
\index[fun]{get\_tagless\_edges2}
\index[fun]{get\_tagless\_edges1}
\index[fun]{get\_tagless\_edges}
\index[fun]{drop\_edge}
\index[fun]{drop\_tagless\_edge}
\index[fun]{put\_edge}
\index[fun]{put\_tagless\_edge}
\index[fun]{empty\_graph}
\index[fun]{tag\_other}
\index[fun]{tag\_graph}
\index[fun]{tag\_float}
\index[fun]{tag\_string}
\index[fun]{tag\_id}
\index[fun]{tag\_int}
\index[fun]{tag\_datum}
\index[fun]{make\_other\_tag}
\index[fun]{make\_graph\_tag}
\index[fun]{make\_float\_tag}
\index[fun]{make\_string\_tag}
\index[fun]{make\_id\_tag}
\index[fun]{make\_int\_tag}
\index[fun]{make\_tag}
\index[fun]{node\_other}
\index[fun]{node\_graph}
\index[fun]{node\_float}
\index[fun]{node\_string}
\index[fun]{node\_id}
\index[fun]{node\_int}
\index[fun]{node\_datum}
\index[fun]{make\_other\_node}
\index[fun]{make\_graph\_node}
\index[fun]{make\_float\_node}
\index[fun]{make\_string\_node}
\index[fun]{make\_id\_node}
\index[fun]{make\_int\_node}
\index[fun]{make\_node}
\index[fun]{all\_invariants\_hold}
\index[fun]{find}
\index[fun]{exists}
\index[fun]{filter}
\index[fun]{partition}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{apply}
\index[fun]{map}
\index[fun]{difference}
\index[fun]{intersection}
\index[fun]{union}
\index[fun]{vals\_list}
\index[fun]{vals\_count}
\index[fun]{is\_subset}
\index[fun]{compare}
\index[fun]{equal}
\index[fun]{is\_empty}
\index[fun]{following\_member}
\index[fun]{preceding\_member}
\index[fun]{member}
\index[fun]{drop}
\index[fun]{add\_list}
\index[fun]{add\_\_prime\_\_}
\index[fun]{add}
\index[fun]{from\_list}
\index[fun]{singleton}
\index[fun]{empty}
\index[fun]{compare}
\index[fun]{all\_invariants\_hold}
\index[fun]{find}
\index[fun]{exists}
\index[fun]{filter}
\index[fun]{partition}
\index[fun]{fold\_backward}
\index[fun]{fold\_forward}
\index[fun]{apply}
\index[fun]{map}
\index[fun]{difference}
\index[fun]{intersection}
\index[fun]{union}
\index[fun]{vals\_list}
\index[fun]{vals\_count}
\index[fun]{is\_subset}
\index[fun]{compare}
\index[fun]{equal}
\index[fun]{is\_empty}
\index[fun]{following\_member}
\index[fun]{preceding\_member}
\index[fun]{member}
\index[fun]{drop}
\index[fun]{add\_list}
\index[fun]{add\_\_prime\_\_}
\index[fun]{add}
\index[fun]{from\_list}
\index[fun]{singleton}
\index[fun]{empty}
\index[fun]{compare}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
