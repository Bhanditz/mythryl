\index[pkg]{scripting\_globals}
\label{pkg:scripting\_globals}
\input{top-pkg-scripting_globals.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    _! : multiword_int::Int -> multiword_int::Int;
    _[]:= : (Rw_Vector(X ) , Int , X) -> Void;
    =~ : (String , String) -> Bool;
    atod : String -> Float;
    atoi : String -> Int;
    backticks__op : String -> List(String );
    basename : String -> String;
    bin_sh : String -> String;
    bin_sh' : String -> Int;
    chdir : String -> Void;
    chomp : String -> String;
    die : String -> Void;
    die_x : String -> X;
    dirname : String -> String;
    environ : Void -> List(String );
    eval : String -> Void;
    evali : String -> Int;
    evalf : String -> Float;
    evals : String -> String;
    evalli : String -> List(Int );
    evallf : String -> List(Float );
    evalls : String -> List(String );
    exit : Int -> Void;
    exit_x : Int -> X;
    explode : String -> List(Char );
    factors : Int -> List(Int );
    fields : (Char -> Bool) -> String -> List(String );
    filter : (X -> Bool) -> List(X ) -> List(X );
    fscanf : Input_Stream -> String -> Null_Or(List(printf_field::Printf_Arg ) );
    getcwd : Void -> String;
    getenv : String -> Null_Or(String );
    getpid : Void -> Int;
    getuid : Void -> Int;
    geteuid : Void -> Int;
    getppid : Void -> Int;
    getgid : Void -> Int;
    getegid : Void -> Int;
    getgroups : Void -> List(Int );
    getlogin : Void -> String;
    getpgrp : Void -> Int;
    mkdir : String -> Void;
    setgid : Int -> Void;
    setpgid : (Int , Int) -> Void;
    setsid : Void -> Int;
    setuid : Int -> Void;
    implode : List(Char ) -> String;
    in : (''a , List(''a )) -> Bool;
    iseven : Int -> Bool;
    isodd : Int -> Bool;
    isprime : Int -> Bool;
    join' : String -> String -> String -> List(String ) -> String;
    join : String -> List(String ) -> String;
    lstat : String -> ?.posix_file::stat::Stat;
    now : Void -> Float;
    product : List(Int ) -> Int;
    rename : {from:String, to:String} -> Void;
    rmdir : String -> Void;
    round : Float -> Int;
    shuffle' : random::Random_Number_Generator -> List(X ) -> List(X );
    shuffle : List(X ) -> List(X );
    sleep : Float -> Void;
    sort : ((X , X) -> Bool) -> List(X ) -> List(X );
    sorted : ((X , X) -> Bool) -> List(X ) -> Bool;
    scanf : String -> Null_Or(List(printf_field::Printf_Arg ) );
    sscanf : String -> String -> Null_Or(List(printf_field::Printf_Arg ) );
    stat : String -> ?.posix_file::stat::Stat;
    strcat : List(String ) -> String;
    strlen : String -> Int;
    strsort : List(String ) -> List(String );
    struniqsort : List(String ) -> List(String );
    sum : List(Int ) -> Int;
    symlink : {new:String, old:String} -> Void;
    time : Void -> one_word_int::Int;
    tolower : String -> String;
    toupper : String -> String;
    tokens : (Char -> Bool) -> String -> List(String );
    trim : String -> String;
    uniquesort : ((X , X) -> Order) -> List(X ) -> List(X );
    unlink : String -> Void;
    words : String -> List(String );
    dotqquotes__op : String -> List(String );
    arg0 : Void -> String;
    argv : Void -> List(String );
    isfile : String -> Bool;
    isdir : String -> Bool;
    ispipe : String -> Bool;
    issymlink : String -> Bool;
    issocket : String -> Bool;
    ischardev : String -> Bool;
    isblockdev : String -> Bool;
    mayread : String -> Bool;
    maywrite : String -> Bool;
    mayexecute : String -> Bool;
    eval_kludge_ref_int : Ref(Int );
    eval_kludge_ref_float : Ref(Float );
    eval_kludge_ref_string : Ref(String );
    eval_kludge_ref_list_int : Ref(List(Int ) );
    eval_kludge_ref_list_float : Ref(List(Float ) );
    eval_kludge_ref_list_string : Ref(List(String ) );
    exception THREAD_SCHEDULER_NOT_RUNNING;
        package state
          : api {
                State  = ALIVE | FAILURE | FAILURE_DUE_TO_UNCAUGHT_EXCEPTION | SUCCESS;};;
    Apptask  = ...;
    Microthread  = ...;
    default_microthread : Microthread;
    get_current_microthread : Void -> Microthread;
    get_current_microthread's_name : Void -> String;
    get_current_microthread's_id : Void -> Int;
    get_task's_id : Apptask -> Int;
    get_task's_name : Apptask -> String;
    get_task's_state : Apptask -> state::State;
    get_task's_alive_threads_count : Apptask -> Int;
    same_task : (Apptask , Apptask) -> Bool;
    compare_task : (Apptask , Apptask) -> Order;
    same_thread : (Microthread , Microthread) -> Bool;
    compare_thread : (Microthread , Microthread) -> Order;
    hash_thread : Microthread -> Unt;
    kill_thread : {success:Bool, thread:Microthread} -> Void;
    kill_task : {success:Bool, task:Apptask} -> Void;
    get_thread's_id : Microthread -> Int;
    get_thread's_id_as_string : Microthread -> String;
    get_thread's_name : Microthread -> String;
    get_thread's_state : Microthread -> state::State;
    get_thread's_task : Microthread -> Apptask;
    get_exception_that_killed_thread : Microthread -> Null_Or(Exception );
    get_exception_that_killed_task : Apptask -> Null_Or(Exception );
    Make_Thread_Args  = THREAD_NAME String | THREAD_TASK Apptask;
    make_thread' : List(Make_Thread_Args ) -> (X -> Void) -> X -> Microthread;
    make_thread : String -> (Void -> Void) -> Microthread;
    make_task : String -> List(((String , (Void -> Void))) ) -> Apptask;
    thread_exit : {success:Bool} -> X;
    thread_done__mailop : Microthread -> Mailop(Void );
    task_done__mailop : Apptask -> Mailop(Void );
    yield : Void -> Void;
    run_thread__xu : Microthread -> (X -> Void) -> X -> Void;
        make_per_thread_property :
        (Void -> X) -> {clear:Void -> Void, get:Void -> X, peek:Void -> Null_Or(X ), set:X -> Void};
    make_boolean_per_thread_property : Void -> {get:Void -> Bool, set:Bool -> Void};
    Mailslot X = ...;
    make_mailslot : Void -> Mailslot(X );
    same_mailslot : (Mailslot(X ) , Mailslot(X )) -> Bool;
    put_in_mailslot : (Mailslot(X ) , X) -> Void;
    take_from_mailslot : Mailslot(X ) -> X;
    put_in_mailslot' : (Mailslot(X ) , X) -> Mailop(Void );
    take_from_mailslot' : Mailslot(X ) -> Mailop(X );
    nonblocking_put_in_mailslot : (Mailslot(X ) , X) -> Bool;
    nonblocking_take_from_mailslot : Mailslot(X ) -> Null_Or(X );
    Maildrop X;
    exception MAY_NOT_FILL_ALREADY_FULL_MAILDROP;
    make_empty_maildrop : Void -> Maildrop(X );
    make_full_maildrop : X -> Maildrop(X );
    put_in_maildrop : (Maildrop(X ) , X) -> Void;
    take_from_maildrop : Maildrop(X ) -> X;
    take_from_maildrop' : Maildrop(X ) -> Mailop(X );
    nonblocking_take_from_maildrop : Maildrop(X ) -> Null_Or(X );
    get_from_maildrop : Maildrop(X ) -> X;
    get_from_maildrop' : Maildrop(X ) -> Mailop(X );
    nonblocking_get_from_maildrop : Maildrop(X ) -> Null_Or(X );
    maildrop_swap : (Maildrop(X ) , X) -> X;
    maildrop_swap' : (Maildrop(X ) , X) -> Mailop(X );
    same_maildrop : (Maildrop(X ) , Maildrop(X )) -> Bool;
    make_run_gun : Void -> {fire_run_gun:Void -> Void, run_gun':Run_Gun};
    make_end_gun : Void -> {end_gun':End_Gun, fire_end_gun:Void -> Void};
    maildrop_to_string : (Maildrop(X ) , String) -> String;
    Oneshot_Maildrop X;
    exception MAY_NOT_FILL_ALREADY_FULL_ONESHOT_MAILDROP;
    make_oneshot_maildrop : Void -> Oneshot_Maildrop(X );
    put_in_oneshot : (Oneshot_Maildrop(X ) , X) -> Void;
    get_from_oneshot : Oneshot_Maildrop(X ) -> X;
    get_from_oneshot' : Oneshot_Maildrop(X ) -> Mailop(X );
    nonblocking_get_from_oneshot : Oneshot_Maildrop(X ) -> Null_Or(X );
    same_oneshot_maildrop : (Oneshot_Maildrop(X ) , Oneshot_Maildrop(X )) -> Bool;
    Mailqueue X = ...;
    make_mailqueue : Microthread -> Mailqueue(X );
    same_mailqueue : (Mailqueue(X ) , Mailqueue(X )) -> Bool;
    put_in_mailqueue : (Mailqueue(X ) , X) -> Void;
    take_from_mailqueue : Mailqueue(X ) -> X;
    take_from_mailqueue' : Mailqueue(X ) -> Mailop(X );
    take_all_from_mailqueue : Mailqueue(X ) -> List(X );
    take_all_from_mailqueue' : Mailqueue(X ) -> Mailop(List(X ) );
    mailqueue_to_string : (Mailqueue(X ) , String) -> String;
    get_mailqueue_reader : Mailqueue(X ) -> Microthread;
    get_mailqueue_id : Mailqueue(X ) -> Int;
    get_mailqueue_length : Mailqueue(X ) -> Int;
    get_mailqueue_putcount : Mailqueue(X ) -> Int;
    drop_mailqueue_tap : (Mailqueue(X ) , Ref(Void )) -> Void;
    note_mailqueue_tap : (Mailqueue(X ) , (X -> Void)) -> Ref(Void );
    Mailcaster X = ...;
    Readqueue X = ...;
    make_mailcaster : Void -> Mailcaster(X );
    make_readqueue : Mailcaster(X ) -> Readqueue(X );
    clone_readqueue : Readqueue(X ) -> Readqueue(X );
    receive : Readqueue(X ) -> X;
    receive' : Readqueue(X ) -> Mailop(X );
    transmit : (Mailcaster(X ) , X) -> Void;
    Mailop X = ...;
    Run_Gun  = Mailop(Void );
    End_Gun  = Mailop(Void );
    do_one_mailop : List(Mailop(X ) ) -> X;
    ==> : (Mailop(X ) , (X -> Y)) -> Mailop(Y );
    Replyqueue  = {next_id:Ref(Int ), queue:Ref(List(?.mailop::Replyqueue_Entry ) )};
    make_replyqueue : Void -> Replyqueue;
    put_in_replyqueue : (Replyqueue , Mailop(Void )) -> Void;
    do_one_mailop' : Replyqueue -> List(Mailop(Void ) ) -> Void;
    replyqueue_to_string : (Replyqueue , String) -> String;
    dynamic_mailop : (Void -> Mailop(X )) -> Mailop(X );
    dynamic_mailop_with_nack : (Mailop(Void ) -> Mailop(X )) -> Mailop(X );
    never' : Mailop(X );
    always' : X -> Mailop(X );
    if_then' : (Mailop(X ) , (X -> Y)) -> Mailop(Y );
    make_exception_handling_mailop : (Mailop(X ) , (Exception -> X)) -> Mailop(X );
    cat_mailops : List(Mailop(X ) ) -> Mailop(X );
    block_until_mailop_fires : Mailop(X ) -> X;
    state_to_string : state::State -> String;
    get_or_make_current_cleanup_task : Void -> Apptask;
    note_thread_cleanup_action : (Void -> Void) -> Void;
    note_task_cleanup_action : (Void -> Void) -> Void;
    timeout_in' : Float -> Mailop(Void );
    timeout_at' : time::Time -> Mailop(Void );
    sleep_for : Float -> Void;
    sleep_until : time::Time -> Void;
    start_up_thread_scheduler : (Void -> Void) -> Int;
    start_up_thread_scheduler' : time::Time -> (Void -> Void) -> Int;
    run_under_thread_scheduler : (Void -> X) -> Void;
    shut_down_thread_scheduler : Int -> X;
    spawn_to_disk : (String , ((String , List(String )) -> Int) , Null_Or(time::Time )) -> Void;
    When  = APP_SHUTDOWN | APP_STARTUP | COMPILER_STARTUP | THREADKIT_SHUTDOWN;
    when_to_string : When -> String;
        note_startup_or_shutdown_action :
        (String , List(When ) , (When -> Void)) -> Null_Or(((List(When ) , (When -> Void))) );
    forget_startup_or_shutdown_action : String -> Null_Or(((List(When ) , (When -> Void))) );
    exception NO_SUCH_ACTION;
    note_mailqueue : (String , Mailqueue(X )) -> Void;
    forget_mailqueue : String -> Void;
    note_mailslot : (String , Mailslot(X )) -> Void;
    forget_mailslot : String -> Void;
    note_imp : {at_shutdown:Void -> Void, at_startup:Void -> Void, name:String} -> Void;
    forget_imp : String -> Void;
    forget_all_mailslots_mailqueues_and_imps : Void -> Void;};
\end{verbatim}
{\tiny\it The following information is manually maintained and may contain errors.}
\input{bot-pkg-scripting_globals.tex}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
