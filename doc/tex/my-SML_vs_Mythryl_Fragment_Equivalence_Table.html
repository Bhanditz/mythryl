<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>SML vs Mythryl Fragment Equivalence Table</TITLE>
</HEAD>
<BODY >
<A HREF="my-Broad_Syntactic_Differences.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Mythryl_for_SML_Programmers.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-SML_vs_Mythryl_Extended_Example.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc187">5.7.5</A>  SML vs Mythryl Fragment Equivalence Table</H3><P>Here is a table of SML syntax fragments with Mythryl equivalents: </P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP><B>SML</B></TD><TD ALIGN=left NOWRAP><B>Mythryl</B></TD><TD ALIGN=left NOWRAP><B>Comment</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>.sig</TT></TD><TD ALIGN=left NOWRAP><TT>.api</TT></TD><TD ALIGN=left NOWRAP>Default signature file extension has changed.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>.sml</TT></TD><TD ALIGN=left NOWRAP><TT>.pkg</TT></TD><TD ALIGN=left NOWRAP>Default structure file extension has changed.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>.cm</TT></TD><TD ALIGN=left NOWRAP><TT>.lib</TT></TD><TD ALIGN=left NOWRAP>".lib" file extension has better C intuition.</TD></TR>
<TR><TD ALIGN=left NOWRAP>(* A comment. *)</TD><TD ALIGN=left NOWRAP># A comment.</TD><TD ALIGN=left NOWRAP>Mythryl follows scripting comment convention.</TD></TR>
<TR><TD ALIGN=left NOWRAP>(* A comment. *)</TD><TD ALIGN=left NOWRAP>/* A comment. */</TD><TD ALIGN=left NOWRAP>Mythryl also supports C-style comments.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>true false</TT></TD><TD ALIGN=left NOWRAP><TT>TRUE FALSE</TT></TD><TD ALIGN=left NOWRAP>Mythryl constructors are consistently upper case.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>open my_package;</TT></TD><TD ALIGN=left NOWRAP><TT>include package my_package;</TT></TD><TD ALIGN=left NOWRAP>Better C intuition, frees <TT>open</TT> for I/O use.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>unit</TT></TD><TD ALIGN=left NOWRAP><TT>Void</TT></TD><TD ALIGN=left NOWRAP>&#X2019;Void&#X2019; carries better C intuition.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>real</TT></TD><TD ALIGN=left NOWRAP><TT>Float</TT></TD><TD ALIGN=left NOWRAP>&#X2019;Float&#X2019; carries better C intuition.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>NONE</TT></TD><TD ALIGN=left NOWRAP><TT>NULL</TT></TD><TD ALIGN=left NOWRAP>&#X2019;NULL&#X2019; carries better C intuition.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>SOME x</TT></TD><TD ALIGN=left NOWRAP><TT>THE x</TT></TD><TD ALIGN=left NOWRAP>&#X2019;THE&#X2019; avoids sounding like a quantifier.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>int option</TT></TD><TD ALIGN=left NOWRAP><TT>Null_Or(Int)</TT></TD><TD ALIGN=left NOWRAP>Latter carries better C intuition.</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>string list</TT></TD><TD ALIGN=left NOWRAP><TT>List(String)</TT></TD><TD ALIGN=left NOWRAP>Mythryl type functions are prefix.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&#X2019;a list</TD><TD ALIGN=left NOWRAP>List(X)</TD><TD ALIGN=left NOWRAP>Mythryl type variables are alphabetic.</TD></TR>
<TR><TD ALIGN=left NOWRAP>(none)</TD><TD ALIGN=left NOWRAP>x = &#X2018;ls -l&#X2018;;</TD><TD ALIGN=left NOWRAP>Mythryl supports user-redefinable Perl-flavored backtick operator.</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>#\a</CODE></TD><TD ALIGN=left NOWRAP>&#X2019;a&#X2019;</TD><TD ALIGN=left NOWRAP>Mythryl supports C-flavored character constants.</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>~2</CODE></TD><TD ALIGN=left NOWRAP>-2</TD><TD ALIGN=left NOWRAP>Mythryl uses dash for unary negation, like most languages.</TD></TR>
<TR><TD ALIGN=left NOWRAP>a :: b</TD><TD ALIGN=left NOWRAP>a ! b</TD><TD ALIGN=left NOWRAP>Mythryl uses &#X2019;!&#X2019; for list construction.</TD></TR>
<TR><TD ALIGN=left NOWRAP>a = (b = c)</TD><TD ALIGN=left NOWRAP>a = (b == c)</TD><TD ALIGN=left NOWRAP>Mythryl distinguishes equality (==) from binding (=).</TD></TR>
<TR><TD ALIGN=left NOWRAP>!ptr</TD><TD ALIGN=left NOWRAP>*ptr</TD><TD ALIGN=left NOWRAP>Per C intuition, Mythryl dereferences via prefix asterisk.</TD></TR>
<TR><TD ALIGN=left NOWRAP>abs a</TD><TD ALIGN=left NOWRAP>|a|</TD><TD ALIGN=left NOWRAP>Mythryl supports circumfix operators.</TD></TR>
<TR><TD ALIGN=left NOWRAP>factorial 5</TD><TD ALIGN=left NOWRAP>5!</TD><TD ALIGN=left NOWRAP>Mythryl supports postfix operators.</TD></TR>
<TR><TD ALIGN=left NOWRAP>not a</TD><TD ALIGN=left NOWRAP>!a</TD><TD ALIGN=left NOWRAP>Mythryl supports usual C negation convention.</TD></TR>
<TR><TD ALIGN=left NOWRAP>not a</TD><TD ALIGN=left NOWRAP>not a</TD><TD ALIGN=left NOWRAP>Mythryl also supports this.</TD></TR>
<TR><TD ALIGN=left NOWRAP>a bit_or b</TD><TD ALIGN=left NOWRAP>a | b</TD><TD ALIGN=left NOWRAP>Mythryl supports C inclusive-or syntax.</TD></TR>
<TR><TD ALIGN=left NOWRAP>a andalso b</TD><TD ALIGN=left NOWRAP>a and b</TD><TD ALIGN=left NOWRAP>Mythryl short-circuit ops follow Perl &amp; kith.</TD></TR>
<TR><TD ALIGN=left NOWRAP>a orelse b</TD><TD ALIGN=left NOWRAP>a or b</TD><TD ALIGN=left NOWRAP>Ditto.</TD></TR>
<TR><TD ALIGN=left NOWRAP>mystructure.myfunction</TD><TD ALIGN=left NOWRAP>mypackage::myfunction</TD><TD ALIGN=left NOWRAP>Mythryl follows C++ convention.</TD></TR>
<TR><TD ALIGN=left NOWRAP>#field record</TD><TD ALIGN=left NOWRAP>record.field</TD><TD ALIGN=left NOWRAP>Mythryl follows C convention.</TD></TR>
<TR><TD ALIGN=left NOWRAP>#field record</TD><TD ALIGN=left NOWRAP>.field record</TD><TD ALIGN=left NOWRAP>Mythryl still supports fieldname-as-function.</TD></TR>
<TR><TD ALIGN=left NOWRAP>(none)</TD><TD ALIGN=left NOWRAP>for (x=0; x&lt;12; ++x) { ... }</TD><TD ALIGN=left NOWRAP>Mythryl implements C-flavored (but pure-functional) for-loop.</TD></TR>
<TR><TD ALIGN=left NOWRAP>(none)</TD><TD ALIGN=left NOWRAP>x where ... end;</TD><TD ALIGN=left NOWRAP>Mythryl implements where clauses.</TD></TR>
<TR><TD ALIGN=left NOWRAP>format <CODE>"%d\n"</CODE> [ INT 12 ]</TD><TD ALIGN=left NOWRAP>printf <CODE>"%d\n"</CODE> 12;</TD><TD ALIGN=left NOWRAP>Mythryl implements Perl-flavored printf.</TD></TR>
<TR><TD ALIGN=left NOWRAP>let val x = 12 in x+2 end</TD><TD ALIGN=left NOWRAP>{ x = 12; x+2; }</TD><TD ALIGN=left NOWRAP>Mythryl implements C-flavored blocks.</TD></TR>
<TR><TD ALIGN=left NOWRAP>case ...</TD><TD ALIGN=left NOWRAP>case ... esac</TD><TD ALIGN=left NOWRAP>Mythryl supplies the missing &#X2019;esac&#X2019; terminator.</TD></TR>
<TR><TD ALIGN=left NOWRAP>if ...</TD><TD ALIGN=left NOWRAP>if ... fi</TD><TD ALIGN=left NOWRAP>Mythryl supplies the missing &#X2019;fi&#X2019; terminator.</TD></TR>
<TR><TD ALIGN=left NOWRAP>if foo then print <CODE>"Hi!\n"</CODE> else ()</TD><TD ALIGN=left NOWRAP>if foo print <CODE>"Hi!\n"</CODE> fi</TD><TD ALIGN=left NOWRAP>Missing else clause defaults to () in Mythryl.</TD></TR>
<TR><TD ALIGN=left NOWRAP>(none)</TD><TD ALIGN=left NOWRAP>if ... elif ... else ... fi</TD><TD ALIGN=left NOWRAP>Mythryl supports &#X2019;elif&#X2019;.</TD></TR>
<TR><TD ALIGN=left NOWRAP>val x = if y then 2 else 3</TD><TD ALIGN=left NOWRAP>x = y ?? 2 :: 3;</TD><TD ALIGN=left NOWRAP>Mythryl supports C-flavored conditional.</TD></TR>
<TR><TD ALIGN=left NOWRAP>handle</TD><TD ALIGN=left NOWRAP>except</TD><TD ALIGN=left NOWRAP>&#X201C;except&#X201D; clarifies the tie to exception handling.</TD></TR>
<TR><TD ALIGN=left NOWRAP>structure</TD><TD ALIGN=left NOWRAP>package</TD><TD ALIGN=left NOWRAP>&#X201C;struct&#X201D; means &#X201C;record&#X201D; to C intuition so we avoid the word.</TD></TR>
<TR><TD ALIGN=left NOWRAP>signature</TD><TD ALIGN=left NOWRAP>api</TD><TD ALIGN=left NOWRAP>&#X201C;api&#X201D; carries better C intuition.</TD></TR>
<TR><TD ALIGN=left NOWRAP>functor</TD><TD ALIGN=left NOWRAP>generic package</TD><TD ALIGN=left NOWRAP>&#X201C;generic package&#X201D; carries better C intuition.</TD></TR>
<TR><TD ALIGN=left NOWRAP>signature Foo = sig ... end</TD><TD ALIGN=left NOWRAP>api Foo { ... };</TD><TD ALIGN=left NOWRAP>This syntax is more compact and more C-intuitive.</TD></TR>
<TR><TD ALIGN=left NOWRAP>structure foo = struct ... end</TD><TD ALIGN=left NOWRAP>package foo { ... };</TD><TD ALIGN=left NOWRAP>Ditto.</TD></TR>
<TR><TD ALIGN=left NOWRAP>sig ... end</TD><TD ALIGN=left NOWRAP>api _ { ... };</TD><TD ALIGN=left NOWRAP>We avoid spending a reserved word for anonymous case.</TD></TR>
<TR><TD ALIGN=left NOWRAP>struct ... end</TD><TD ALIGN=left NOWRAP>package _ { ... };</TD><TD ALIGN=left NOWRAP>Ditto.</TD></TR>
<TR><TD ALIGN=left NOWRAP>my_struct :&gt; my_sig</TD><TD ALIGN=left NOWRAP>my_package: my_api</TD><TD ALIGN=left NOWRAP>Mythryl gives strong sealing the compact syntax.</TD></TR>
<TR><TD ALIGN=left NOWRAP>my_struct : my_sig</TD><TD ALIGN=left NOWRAP>my_package: (weak) my_api</TD><TD ALIGN=left NOWRAP>Mythryl weak sealing syntax is clear and extensible.</TD></TR>
<TR><TD ALIGN=left NOWRAP>op +</TD><TD ALIGN=left NOWRAP>(+)</TD><TD ALIGN=left NOWRAP>Concise Haskell syntax for quoting infix ops. ("op" is not a reserved word in Mythryl.)</TD></TR>
<TR><TD ALIGN=left NOWRAP>infix +++ ;</TD><TD ALIGN=left NOWRAP>infix my +++ ;</TD><TD ALIGN=left NOWRAP>"infix" is not a reserved word in Mythryl. (Nor, e.g., "type", "in", "do" or "let".)</TD></TR>
</TABLE>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Broad_Syntactic_Differences.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Mythryl_for_SML_Programmers.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-SML_vs_Mythryl_Extended_Example.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
