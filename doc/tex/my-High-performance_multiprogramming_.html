<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>High-performance multiprogramming.</TITLE>
</HEAD>
<BODY >
<A HREF="my-Great_garbage_collection_.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Engineered_.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H2 CLASS="section"><A NAME="htoc12">1.11</A>  High-performance multiprogramming.</H2><P>Multi-core programming means multiprocessing &#X2014; having more than 
one program counter active at the same instant &#X2014; and multiprocessing 
means multiprogramming &#X2014; having more than one thread conceptually 
active at any given time &#X2014; so the rise of commodity multi-core 
<SPAN STYLE="font-variant:small-caps">CPU</SPAN> chips means that we are all now willy-nilly multiprogramming 
practitioners.</P><P>One of the prettiest design choices made early on by the <SPAN STYLE="font-variant:small-caps">SML/NJ</SPAN> 
design team &#X2014; probably Andrew Appel &#X2014; was to dispense entirely with 
the notion of a call stack and instead allot callframes directly 
upon the heap.</P><P>This idea has a long and mixed history; a number of systems like 
Smalltalk started out doing this for its elegance and simplicity, 
but had to give it up for performance reasons.</P><P>But <SPAN STYLE="font-variant:small-caps">SML/NJ</SPAN> had the advantage of having from the outset a high-performance 
multi-generation copying garbage collector (classic Smalltalk relied 
on simple reference-counting) and consequently wound up in a sweet 
spot where on the one hand the garbage collector allowed simple and 
elegant callframe allocation, while on the other hand the demands of 
on-heap callframe allocation kept the garbage collector implementors 
on their toes, resulting in no-compromise performance levels which 
benefit all the rest of the system.</P><P>From a multiprogramming point of view, the result is that in 
<SPAN STYLE="font-variant:small-caps">SML/NJ</SPAN> &#X2014; and thus ultimately Mythryl &#X2014; the fundamental 
multiprogramming thread-switch <TT>call/cc</TT> primitive is just as 
fast as a vanilla function call because in fact it <EM>is</EM> 
just a function call, while in contemporary systems it involves an 
actual switch of stacks involving hundreds of instructions of 
context save and restore, which consequently takes hundreds of 
times longer.</P><P>The bottom line for today&#X2019;s programmer: As we head into the 
era of serious multiprogramming and multiprocessing, the 
Mythryl programmer enjoys an essentially optimally efficient 
infrastructure on which to build, whereas most other programmers 
are headed for ticklish performance problems.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Great_garbage_collection_.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Engineered_.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
