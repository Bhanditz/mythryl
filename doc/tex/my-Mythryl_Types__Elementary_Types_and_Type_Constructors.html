<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mythryl Types: Elementary Types and Type Constructors</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mythryl_Types__Hindley-Milner_Type_Inference.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Types__Generativity.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc99">5.4.14</A>  Mythryl Types: Elementary Types and Type Constructors</H3><BLOCKQUOTE CLASS="quote"><FONT SIZE=1>
&#X201C;Using &#X201C;Void&#X201D; for a non-empty type is barbaric!&#X201D;<BR>
                            &#X2014;Robert Harper, co-author of </FONT><FONT SIZE=1><I>The Definition of Standard ML</I></FONT><FONT SIZE=1>
</FONT></BLOCKQUOTE><P>Type systems start with a few irreducible elementary types together 
with some operators which generate new types from previously existing 
ones. Mythryl&#X2019;s type system is no exception.</P><P>Mythryl&#X2019;s core elementary types are:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Void</B>: Like C <B>void</B>, this is the value returned by a function which returns 
nothing interesting, and the argument value given to a function which really needs 
no argument. There is exactly one value of this type, which is written <TT>()</TT>. 
(Theoreticians prefer to call this type <B>unit</B>, reserving <B>void</B> for the type 
which has no values at all.)
</LI><LI CLASS="li-itemize"><B>Int</B>: The default integer type. This has 31 bits of precision. (See below.)
</LI><LI CLASS="li-itemize"><B>Float</B>: The default floating point type. This has 64 bits of precision, and 
thus actually corresponds to C <B>double</B>.
</LI><LI CLASS="li-itemize"><B>Char</B>: One seven-bit <SPAN STYLE="font-variant:small-caps">ASCII</SPAN> character.
</LI></UL><P>The following core Mythryl vector types are also treated as elementary:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>String</B>: Logically a vector of Char, but treated as elementary.
</LI><LI CLASS="li-itemize"><B>Vector</B>: Immutable typeagnostic vectors.
</LI><LI CLASS="li-itemize"><B>Rw_Vector</B>: Mutable typeagnostic vectors.
</LI></UL><P>The very special <B>Exception</B> sumtype is also predefined.</P><P>Mythryl&#X2019;s core mechanisms for constructing new types from old are:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The tuple type constructor: <CODE><TT>New_Type = (Old_Type_A, Old_Type_B, ... );</TT></CODE><TT> </TT>
</LI><LI CLASS="li-itemize">The record type constructor: <CODE><TT>New_Type = { fieldname_a =&gt; Old_Type_A, fieldname_b =&gt; Old_Type_B, ... );</TT></CODE><TT> </TT>
</LI><LI CLASS="li-itemize">The arrow type constructor for functions: <CODE><TT>New_Type = Argument_Type -&gt; Result_Type;</TT></CODE><TT> </TT>
</LI><LI CLASS="li-itemize">The <B>Ref</B> type constructor for declaring mutable reference cells: <CODE><TT>New_Type = Ref( Old_Type );</TT></CODE><TT> </TT>
</LI></UL><P>Finally, Mythryl&#X2019;s sumtype definition facility effectively 
introduces new programmer-defined types and type constructors.</P><P>For example the declaration
</P><PRE CLASS="verbatim">    Color = RED | GREEN | BLUE;
</PRE><P>effectively defines a new atomic type <TT>Color</TT> which may be used anywhere an 
existing elementary type like <TT>Int</TT> may be used, and the declaration</P><PRE CLASS="verbatim">    Tree(X) = EMPTY | NODE { key: Int, value: X, left_kid: Tree(x), right_kid: Tree(X) };
</PRE><P>effectively defines a new type constructor <TT>Tree(X)</TT> which accepts an 
existing type and generates a new one.</P><P>Several types which in other languages are elementary, are in Mythryl 
simply standard library declarations, at least in principle.</P><P>For example the the Boolean type, which is elementary in many 
languages, is in Mythryl defined as
</P><PRE CLASS="verbatim">    Bool = TRUE | FALSE;
</PRE><P>in the standard library, at least in principle. (In practice, 
the compiler uses special hardwired knowledge of <TT>Bool</TT> in 
order to produce better code.)</P><P>Similarly, Mythryl lists are in theory simply a type defined 
in the standard library by a statement like
</P><PRE CLASS="verbatim">    List(X) = [] | (X ! List(X));
</PRE><P>(In practice, <TT>[]</TT> and <TT>! </TT> are not legal end-user 
syntax &#X2014; user-defined constructors must be upper-case 
alphabetic &#X2014; and the list construction syntax <TT>[ 12, 13, 14 ]</TT> 
is a completely <I>ad hoc</I> convenience specially hacked into the Mythryl grammar. 
They say that the difference between theory and practice is that in theory 
they are the same but in practice they are different.)</P><P>Complicating the above picture, the messy realities of computer hardware motivate the 
definition of a few additional elementary types. Integers come in 
signed and unsigned and various lengths, and the Mythryl compiler 
needs to know about them all ahead of time to produce good code, 
so we also have the elementary types 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Int1</B>: 32-bit signed integers.
</LI><LI CLASS="li-itemize"><B>Int2</B>: 64-bit signed integers.
</LI><LI CLASS="li-itemize"><B>Unt8</B>: 8-bit unsigned integers.
</LI><LI CLASS="li-itemize"><B>Unt1</B>: 32-bit unsigned integers.
</LI><LI CLASS="li-itemize"><B>Unt2</B>: 64-bit unsigned integers.
</LI></UL><P>Similarly, two additional typelocked vector types are irrelevant 
in principle but in practice essential to achieving good space/time 
efficiency:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Unt8_Rw_Vector</B>: Mutable vectors of 8-bit unsigned integers.
</LI><LI CLASS="li-itemize"><B>Float64_Rw_Vector</B>: Mutable vectors of 64-bit floating point numbers.
</LI></UL><P>For those interested, some of the real-world process of defining these 
early types in the Mythryl compiler source code may be found in 
<A HREF="my-src_lib_compiler_front_semantic_symbolmapstack_base-types-and-ops_pkg.html#src/lib/compiler/front/semantic/symbolmapstack/base-types-and-ops.pkg">src/lib/compiler/front/semantic/symbolmapstack/base-types-and-ops.pkg</A>;</P>
<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mythryl_Types__Hindley-Milner_Type_Inference.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Types__Generativity.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
