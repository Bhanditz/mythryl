<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Exceptions</TITLE>
</HEAD>
<BODY >
<A HREF="my-Code_Reading_Interlude.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Side_Effects.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc74">5.3.9</A>  Exceptions</H3><P>Most modern languages have some sort of mechanism for aborting 
a subcomputation which has gone seriously wrong and picking up 
again at an appropriate recovery point.</P><P>For example C has <TT>setjmp()</TT> and <TT>longjmp()</TT> and Python 
has <TT>try: ... except SomeError: ... </TT>.</P><P>Mythryl has a facility which is quite similar in function and 
application, albeit with some interesting twists.</P><P>The Mythryl exception handling machinery consists of three 
fundamental parts:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
An <I>exception</I> data type and matching <TT>exception</TT> declaration.
</LI><LI CLASS="li-itemize">An <TT>except</TT> statement for trapping exceptions.
</LI><LI CLASS="li-itemize">A <TT>raise exception</TT> statement for raising exceptions.
</LI></UL><P>A typical use might look something like:</P><PRE CLASS="verbatim">    fun foo ()
        =
        {   exception FOUND_IT( Int );
            exception NOT_FOUND;

            fun do_deep_recursive_search ()
                =
                {    ...
                     raise exception NOT_FOUND;       # Oh well.
                     ...
                     raise exception FOUND_IT( n/32 + 6 );
                     ...
                };

            do_deep_recursive_search ()
            except
                NOT_FOUND   =&gt; printf "Could not find answer!\n";
                FOUND_IT(i) =&gt; printf "The answer is %d.\n" i;
            end;
        };
</PRE><P>Mythryl exceptions may carry arbitrary information. They are 
defined via declarations like</P><PRE CLASS="verbatim">    exception DISK_ERROR;
    exception OUT_OF_RAM;
    exception TERMINATED_BY_SIGNAL_FROM_PROCESS( Int   );       # Int value is pid of external process.
    exception VIOLATION_OF_ACCESS_CONTROL_RULE( String );       # String value is text of rule. 
</PRE><P>These declarations behave a lot like a vanilla 
sumtype declaration</P><PRE CLASS="verbatim">    Exception = DISK_ERROR
              | OUT_OF_RAM;
              | TERMINATED_BY_SIGNAL_FROM_PROCESS( Int   );
              | VIOLATION_OF_ACCESS_CONTROL_RULE( String );
</PRE><P>The <TT>exception</TT> declarations differ primarily in that 
constructors declared with <TT>exception</TT> may be used as arguments to <TT>raise exception</TT> and <TT>except</TT>.</P><P>The Mythryl <TT>raise exception</TT> construct is used to change the flow of control 
by activating the exception handling machinery. 
It is logically a lot like <TT>longjmp()</TT> in C.</P><P>One difference is that the C <TT>longjmp()</TT> function is not very 
efficient; the usual implementation has to sequentially search down 
the stack until it finds a registered <TT>setjmp()</TT> handler. 
The Mythryl <TT>raise exception</TT> construct, by contrast, is implemented very 
efficiently. The mechanism used is essentially identical to that 
used to return from a Mythryl function call, and consequently 
executes just as quickly. Mythryl <TT>raise exception</TT> and <TT>except</TT> 
are sometimes used as a simple non-local <TT>goto</TT>, quite independently 
of any consideration of exceptional conditions.</P><P>The Mythryl <TT>except</TT> construct is in essence a specialized 
<TT>case</TT> statement. Like function definitions, it has separate 
syntax for the single-alternative and multi-alternative cases:</P><PRE CLASS="verbatim">    exception SOME_EXCEPTION; 
    exception EXCEPTION_ONE(String); 
    exception EXCEPTION_TWO(Float); 

    # Single-exception syntax:
    #
    some_expression ()
    except
        SOME_EXCEPTION = printf "Encountered SOME_EXCEPTION\n";

    # Multi-exception syntax:
    #
    some_expression ()
    except
        EXCEPTION_ONE(string) =&gt; printf "Encountered EXCEPTION_ONE(%s)\n" string;
        EXCEPTION_TWO(float)  =&gt; printf "Encountered EXCEPTION_TWO(%f)\n" float ;
    end;
</PRE><P>As always, the single-alternative form uses <TT>=</TT> and has no <TT>end</TT> while 
the multi-alternative form uses <TT>=&gt;</TT> and has an <TT>end</TT> trailing the final 
alternative.</P><P>The Mythryl standard library <A HREF="my-safely.html#pkg:safely">safely</A> package provides canned functionality for protecting a computation from exceptions. It is 
often used to, for example, read from a file while guaranteeing that the 
file will be closed properly should any exception be raised, by catching 
the exception, closing the file, and then re-raising the exception.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Code_Reading_Interlude.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Delving_Deeper.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Side_Effects.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
