<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Overview</TITLE>
</HEAD>
<BODY >
<A HREF="my-Balanced_Binary_Trees.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Red-Black_Trees.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H4 CLASS="subsubsection">Overview</H4><P>A common programming operation is constructing a mapping from 
some set of keys to some set of corresponding values. We might 
be mapping file names to file lengths or employee numbers to 
employee records or program variables to their types. Abstractly, 
we are constructing a function which is defined by exhaustive 
enumeration rather than by any concise rule.</P><P>In this situation a Perl programmer would automatically reach for 
a hashtable.</P><P>A Mythryl programmer, however, will usually reach for a balanced 
binary tree.</P><P>Niklaus Wirth pointed out some years back that balanced binary trees 
are rarely the best-performing algorithm by a given measure, but they 
are usually in the top three or so by any given measure. By contrast, 
the algorithm which places first by one measure will often place dead 
last by another.</P><P>For example, hashtables have an average access time of <I>O</I>(1) with a 
very low proportionality constant; they win hands-down by this 
measure. But their worst case is a disastrous <I>O</I>(<I>N</I>)! You would not 
want to use a hashtable in software controlling something like an 
airliner or nuclear reactor; it might appear to work fine for years 
and then out of the blue stop dead due to an improbable series of 
hash bucket collisions.</P><P>For balanced binary trees, by contrast, the worst case <I>O</I>(<I>log</I>(<I>N</I>), 
just the same as the best case. Balanced binary trees are a tad 
slower than hashtables but rock-solid dependable.</P><P>Consequently using balanced binary trees is a very safe 
and sane habit; they will never let you down. Using 
hashtables, by contrast, is the kind of habit that is likely to get 
you killed some fine morning when you least expect it.</P><P>However, the Mythryl programmer&#X2019;s fondness for balanced binary trees 
goes much deeper than just their being a nice safe and sane datastructure.</P><P>A pervasive theme in Mythryl programming is avoiding the needless use 
of side-effects. There is no practical way to update a hashtable 
without side effects: The entire table would have to be copied at 
each update, at prohibitive <I>O</I>(<I>N</I>) cost. It is however perfectly practical 
to update balanced binary trees without side effects: 
By doing <I>path copying</I> when we update a balanced binary tree 
we can leave the original tree intact, simply building a new tree to 
replace it. Sharing common parts between the old and new tree lets 
us do this quite efficiently, taking only <I>O</I>(<I>log</I>(<I>N</I>)) time and space. </P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Balanced_Binary_Trees.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Red-Black_Trees.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
