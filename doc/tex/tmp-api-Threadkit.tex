\index[api]{Threadkit}
\label{api:Threadkit}
\input{top-api-Threadkit.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    exception THREAD_SCHEDULER_NOT_RUNNING;
        package state
          : api {
                State  = ALIVE | FAILURE | FAILURE_DUE_TO_UNCAUGHT_EXCEPTION | SUCCESS;};;
    Apptask;
    Microthread;
    default_microthread : Microthread;
    get_current_microthread : Void -> Microthread;
    get_current_microthread's_name : Void -> String;
    get_current_microthread's_id : Void -> Int;
    get_task's_id : Apptask -> Int;
    get_task's_name : Apptask -> String;
    get_task's_state : Apptask -> state::State;
    get_task's_alive_threads_count : Apptask -> Int;
    same_task : (Apptask , Apptask) -> Bool;
    compare_task : (Apptask , Apptask) -> Order;
    same_thread : (Microthread , Microthread) -> Bool;
    compare_thread : (Microthread , Microthread) -> Order;
    hash_thread : Microthread -> Unt;
    kill_thread : {success:Bool, thread:Microthread} -> Void;
    kill_task : {success:Bool, task:Apptask} -> Void;
    get_thread's_id : Microthread -> Int;
    get_thread's_id_as_string : Microthread -> String;
    get_thread's_name : Microthread -> String;
    get_thread's_state : Microthread -> state::State;
    get_thread's_task : Microthread -> Apptask;
    get_exception_that_killed_thread : Microthread -> Null_Or(Exception );
    get_exception_that_killed_task : Apptask -> Null_Or(Exception );
    Make_Thread_Args  = THREAD_NAME String | THREAD_TASK Apptask;
    make_thread' : List(Make_Thread_Args ) -> (X -> Void) -> X -> Microthread;
    make_thread : String -> (Void -> Void) -> Microthread;
    make_task : String -> List(((String , (Void -> Void))) ) -> Apptask;
    thread_exit : {success:Bool} -> X;
    thread_done__mailop : Microthread -> ?.internal_threadkit_types::Mailop(Void );
    task_done__mailop : Apptask -> ?.internal_threadkit_types::Mailop(Void );
    yield : Void -> Void;
    run_thread__xu : Microthread -> (X -> Void) -> X -> Void;
        make_per_thread_property :
        (Void -> X) -> {clear:Void -> Void, get:Void -> X, peek:Void -> Null_Or(X ), set:X -> Void};
    make_boolean_per_thread_property : Void -> {get:Void -> Bool, set:Bool -> Void};
    Mailslot X;
    make_mailslot : Void -> Mailslot(X );
    same_mailslot : (Mailslot(X ) , Mailslot(X )) -> Bool;
    put_in_mailslot : (Mailslot(X ) , X) -> Void;
    take_from_mailslot : Mailslot(X ) -> X;
    put_in_mailslot' : (Mailslot(X ) , X) -> ?.internal_threadkit_types::Mailop(Void );
    take_from_mailslot' : Mailslot(X ) -> ?.internal_threadkit_types::Mailop(X );
    nonblocking_put_in_mailslot : (Mailslot(X ) , X) -> Bool;
    nonblocking_take_from_mailslot : Mailslot(X ) -> Null_Or(X );
    Maildrop X;
    exception MAY_NOT_FILL_ALREADY_FULL_MAILDROP;
    make_empty_maildrop : Void -> Maildrop(X );
    make_full_maildrop : X -> Maildrop(X );
    put_in_maildrop : (Maildrop(X ) , X) -> Void;
    take_from_maildrop : Maildrop(X ) -> X;
    take_from_maildrop' : Maildrop(X ) -> ?.internal_threadkit_types::Mailop(X );
    nonblocking_take_from_maildrop : Maildrop(X ) -> Null_Or(X );
    get_from_maildrop : Maildrop(X ) -> X;
    get_from_maildrop' : Maildrop(X ) -> ?.internal_threadkit_types::Mailop(X );
    nonblocking_get_from_maildrop : Maildrop(X ) -> Null_Or(X );
    maildrop_swap : (Maildrop(X ) , X) -> X;
    maildrop_swap' : (Maildrop(X ) , X) -> ?.internal_threadkit_types::Mailop(X );
    same_maildrop : (Maildrop(X ) , Maildrop(X )) -> Bool;
    make_run_gun : Void -> {fire_run_gun:Void -> Void, run_gun':mailop::Run_Gun};
    make_end_gun : Void -> {end_gun':mailop::End_Gun, fire_end_gun:Void -> Void};
    maildrop_to_string : (Maildrop(X ) , String) -> String;
    Oneshot_Maildrop X;
    exception MAY_NOT_FILL_ALREADY_FULL_ONESHOT_MAILDROP;
    make_oneshot_maildrop : Void -> Oneshot_Maildrop(X );
    put_in_oneshot : (Oneshot_Maildrop(X ) , X) -> Void;
    get_from_oneshot : Oneshot_Maildrop(X ) -> X;
    get_from_oneshot' : Oneshot_Maildrop(X ) -> ?.internal_threadkit_types::Mailop(X );
    nonblocking_get_from_oneshot : Oneshot_Maildrop(X ) -> Null_Or(X );
    same_oneshot_maildrop : (Oneshot_Maildrop(X ) , Oneshot_Maildrop(X )) -> Bool;
    Mailqueue X;
    make_mailqueue : ?.internal_threadkit_types::Microthread -> Mailqueue(X );
    same_mailqueue : (Mailqueue(X ) , Mailqueue(X )) -> Bool;
    put_in_mailqueue : (Mailqueue(X ) , X) -> Void;
    take_from_mailqueue : Mailqueue(X ) -> X;
    take_from_mailqueue' : Mailqueue(X ) -> ?.internal_threadkit_types::Mailop(X );
    take_all_from_mailqueue : Mailqueue(X ) -> List(X );
    take_all_from_mailqueue' : Mailqueue(X ) -> ?.internal_threadkit_types::Mailop(List(X ) );
    mailqueue_to_string : (Mailqueue(X ) , String) -> String;
    get_mailqueue_reader : Mailqueue(X ) -> ?.internal_threadkit_types::Microthread;
    get_mailqueue_id : Mailqueue(X ) -> Int;
    get_mailqueue_length : Mailqueue(X ) -> Int;
    get_mailqueue_putcount : Mailqueue(X ) -> Int;
    drop_mailqueue_tap : (Mailqueue(X ) , Ref(Void )) -> Void;
    note_mailqueue_tap : (Mailqueue(X ) , (X -> Void)) -> Ref(Void );
    Mailcaster X;
    Readqueue X;
    make_mailcaster : Void -> Mailcaster(X );
    make_readqueue : Mailcaster(X ) -> Readqueue(X );
    clone_readqueue : Readqueue(X ) -> Readqueue(X );
    receive : Readqueue(X ) -> X;
    receive' : Readqueue(X ) -> ?.internal_threadkit_types::Mailop(X );
    transmit : (Mailcaster(X ) , X) -> Void;
    Mailop X;
    Run_Gun  = Mailop(Void );
    End_Gun  = Mailop(Void );
    do_one_mailop : List(Mailop(X ) ) -> X;
    ==> : (Mailop(X ) , (X -> Y)) -> Mailop(Y );
    Replyqueue;
    make_replyqueue : Void -> Replyqueue;
    put_in_replyqueue : (Replyqueue , Mailop(Void )) -> Void;
    do_one_mailop' : Replyqueue -> List(Mailop(Void ) ) -> Void;
    replyqueue_to_string : (Replyqueue , String) -> String;
    dynamic_mailop : (Void -> Mailop(X )) -> Mailop(X );
    dynamic_mailop_with_nack : (Mailop(Void ) -> Mailop(X )) -> Mailop(X );
    never' : Mailop(X );
    always' : X -> Mailop(X );
    if_then' : (Mailop(X ) , (X -> Y)) -> Mailop(Y );
    make_exception_handling_mailop : (Mailop(X ) , (Exception -> X)) -> Mailop(X );
    cat_mailops : List(Mailop(X ) ) -> Mailop(X );
    block_until_mailop_fires : Mailop(X ) -> X;
    state_to_string : microthread::state::State -> String;
    get_or_make_current_cleanup_task : Void -> ?.internal_threadkit_types::Apptask;
    note_thread_cleanup_action : (Void -> Void) -> Void;
    note_task_cleanup_action : (Void -> Void) -> Void;
    timeout_in' : Float -> ?.Mailop(Void );
    timeout_at' : time::Time -> ?.Mailop(Void );
    sleep_for : Float -> Void;
    sleep_until : time::Time -> Void;
    start_up_thread_scheduler : (Void -> Void) -> Int;
    start_up_thread_scheduler' : time::Time -> (Void -> Void) -> Int;
    run_under_thread_scheduler : (Void -> X) -> Void;
    shut_down_thread_scheduler : Int -> X;
    spawn_to_disk : (String , ((String , List(String )) -> Int) , Null_Or(time::Time )) -> Void;
    When  = APP_SHUTDOWN | APP_STARTUP | COMPILER_STARTUP | THREADKIT_SHUTDOWN;
    when_to_string : When -> String;
        note_startup_or_shutdown_action :
        (String , List(When ) , (When -> Void)) -> Null_Or(((List(When ) , (When -> Void))) );
    forget_startup_or_shutdown_action : String -> Null_Or(((List(When ) , (When -> Void))) );
    exception NO_SUCH_ACTION;
    note_mailqueue : (String , mailqueue::Mailqueue(X )) -> Void;
    forget_mailqueue : String -> Void;
    note_mailslot : (String , ?.mailslot::Mailslot(X )) -> Void;
    forget_mailslot : String -> Void;
    note_imp : {at_shutdown:Void -> Void, at_startup:Void -> Void, name:String} -> Void;
    forget_imp : String -> Void;
    forget_all_mailslots_mailqueues_and_imps : Void -> Void;};
\end{verbatim}\index[fun]{forget\_all\_mailslots\_mailqueues\_and\_imps}
\index[fun]{forget\_imp}
\index[fun]{note\_imp}
\index[fun]{forget\_mailslot}
\index[fun]{note\_mailslot}
\index[fun]{forget\_mailqueue}
\index[fun]{note\_mailqueue}
\index[fun]{forget\_startup\_or\_shutdown\_action}
\index[fun]{note\_startup\_or\_shutdown\_action}
\index[fun]{when\_to\_string}
\index[fun]{spawn\_to\_disk}
\index[fun]{shut\_down\_thread\_scheduler}
\index[fun]{run\_under\_thread\_scheduler}
\index[fun]{start\_up\_thread\_scheduler\_\_prime\_\_}
\index[fun]{start\_up\_thread\_scheduler}
\index[fun]{sleep\_until}
\index[fun]{sleep\_for}
\index[fun]{timeout\_at\_\_prime\_\_}
\index[fun]{timeout\_in\_\_prime\_\_}
\index[fun]{note\_task\_cleanup\_action}
\index[fun]{note\_thread\_cleanup\_action}
\index[fun]{get\_or\_make\_current\_cleanup\_task}
\index[fun]{state\_to\_string}
\index[fun]{block\_until\_mailop\_fires}
\index[fun]{cat\_mailops}
\index[fun]{make\_exception\_handling\_mailop}
\index[fun]{if\_then\_\_prime\_\_}
\index[fun]{always\_\_prime\_\_}
\index[fun]{never\_\_prime\_\_}
\index[fun]{dynamic\_mailop\_with\_nack}
\index[fun]{dynamic\_mailop}
\index[fun]{replyqueue\_to\_string}
\index[fun]{do\_one\_mailop\_\_prime\_\_}
\index[fun]{put\_in\_replyqueue}
\index[fun]{make\_replyqueue}
\index[fun]{==>}
\index[fun]{do\_one\_mailop}
\index[fun]{transmit}
\index[fun]{receive\_\_prime\_\_}
\index[fun]{receive}
\index[fun]{clone\_readqueue}
\index[fun]{make\_readqueue}
\index[fun]{make\_mailcaster}
\index[fun]{note\_mailqueue\_tap}
\index[fun]{drop\_mailqueue\_tap}
\index[fun]{get\_mailqueue\_putcount}
\index[fun]{get\_mailqueue\_length}
\index[fun]{get\_mailqueue\_id}
\index[fun]{get\_mailqueue\_reader}
\index[fun]{mailqueue\_to\_string}
\index[fun]{take\_all\_from\_mailqueue\_\_prime\_\_}
\index[fun]{take\_all\_from\_mailqueue}
\index[fun]{take\_from\_mailqueue\_\_prime\_\_}
\index[fun]{take\_from\_mailqueue}
\index[fun]{put\_in\_mailqueue}
\index[fun]{same\_mailqueue}
\index[fun]{make\_mailqueue}
\index[fun]{same\_oneshot\_maildrop}
\index[fun]{nonblocking\_get\_from\_oneshot}
\index[fun]{get\_from\_oneshot\_\_prime\_\_}
\index[fun]{get\_from\_oneshot}
\index[fun]{put\_in\_oneshot}
\index[fun]{make\_oneshot\_maildrop}
\index[fun]{maildrop\_to\_string}
\index[fun]{make\_end\_gun}
\index[fun]{make\_run\_gun}
\index[fun]{same\_maildrop}
\index[fun]{maildrop\_swap\_\_prime\_\_}
\index[fun]{maildrop\_swap}
\index[fun]{nonblocking\_get\_from\_maildrop}
\index[fun]{get\_from\_maildrop\_\_prime\_\_}
\index[fun]{get\_from\_maildrop}
\index[fun]{nonblocking\_take\_from\_maildrop}
\index[fun]{take\_from\_maildrop\_\_prime\_\_}
\index[fun]{take\_from\_maildrop}
\index[fun]{put\_in\_maildrop}
\index[fun]{make\_full\_maildrop}
\index[fun]{make\_empty\_maildrop}
\index[fun]{nonblocking\_take\_from\_mailslot}
\index[fun]{nonblocking\_put\_in\_mailslot}
\index[fun]{take\_from\_mailslot\_\_prime\_\_}
\index[fun]{put\_in\_mailslot\_\_prime\_\_}
\index[fun]{take\_from\_mailslot}
\index[fun]{put\_in\_mailslot}
\index[fun]{same\_mailslot}
\index[fun]{make\_mailslot}
\index[fun]{make\_boolean\_per\_thread\_property}
\index[fun]{make\_per\_thread\_property}
\index[fun]{run\_thread\_\_xu}
\index[fun]{yield}
\index[fun]{task\_done\_\_mailop}
\index[fun]{thread\_done\_\_mailop}
\index[fun]{thread\_exit}
\index[fun]{make\_task}
\index[fun]{make\_thread}
\index[fun]{make\_thread\_\_prime\_\_}
\index[fun]{get\_exception\_that\_killed\_task}
\index[fun]{get\_exception\_that\_killed\_thread}
\index[fun]{get\_thread\_\_prime\_\_s\_task}
\index[fun]{get\_thread\_\_prime\_\_s\_state}
\index[fun]{get\_thread\_\_prime\_\_s\_name}
\index[fun]{get\_thread\_\_prime\_\_s\_id\_as\_string}
\index[fun]{get\_thread\_\_prime\_\_s\_id}
\index[fun]{kill\_task}
\index[fun]{kill\_thread}
\index[fun]{hash\_thread}
\index[fun]{compare\_thread}
\index[fun]{same\_thread}
\index[fun]{compare\_task}
\index[fun]{same\_task}
\index[fun]{get\_task\_\_prime\_\_s\_alive\_threads\_count}
\index[fun]{get\_task\_\_prime\_\_s\_state}
\index[fun]{get\_task\_\_prime\_\_s\_name}
\index[fun]{get\_task\_\_prime\_\_s\_id}
\index[fun]{get\_current\_microthread\_\_prime\_\_s\_id}
\index[fun]{get\_current\_microthread\_\_prime\_\_s\_name}
\index[fun]{get\_current\_microthread}
\index[fun]{default\_microthread}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
