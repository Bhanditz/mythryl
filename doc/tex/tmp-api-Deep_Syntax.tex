\index[api]{Deep\_Syntax}
\label{api:Deep\_Syntax}
\input{top-api-Deep_Syntax.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    Source_Code_Region;
    Numbered_Label  = NUMBERED_LABEL {name:symbol::Symbol, number:Int};
        Deep_Expression
        = ABSTRACTION_PACKING_EXPRESSION
        (Deep_Expression , type_declaration_types::Typoid , List(type_declaration_types::Type ))
        |
        AND_EXPRESSION
        (Deep_Expression , Deep_Expression)
        |
        APPLY_EXPRESSION
        {operand:Deep_Expression, operator:Deep_Expression}
        |
        CASE_EXPRESSION
        (Deep_Expression , List(Case_Rule ) , Bool)
        |
        CHAR_CONSTANT_IN_EXPRESSION
        String
        |
        EXCEPT_EXPRESSION
        (Deep_Expression , Fnrules)
        |
        FLOAT_CONSTANT_IN_EXPRESSION
        String
        |
        FN_EXPRESSION
        Fnrules
        |
        IF_EXPRESSION
        {else_case:Deep_Expression, test_case:Deep_Expression, then_case:Deep_Expression}
        |
        INT_CONSTANT_IN_EXPRESSION
        (multiword_int::Int , type_declaration_types::Typoid)
        |
        LET_EXPRESSION
        (Declaration , Deep_Expression)
        |
        OR_EXPRESSION
        (Deep_Expression , Deep_Expression)
        |
        RAISE_EXPRESSION
        (Deep_Expression , type_declaration_types::Typoid)
        |
        RECORD_IN_EXPRESSION
        List(((Numbered_Label , Deep_Expression)) )
        |
        RECORD_SELECTOR_EXPRESSION
        (Numbered_Label , Deep_Expression)
        |
        SEQUENTIAL_EXPRESSIONS
        List(Deep_Expression )
        |
        SOURCE_CODE_REGION_FOR_EXPRESSION
        (Deep_Expression , Source_Code_Region)
        |
        STRING_CONSTANT_IN_EXPRESSION
        String
        |
        TYPE_CONSTRAINT_EXPRESSION
        (Deep_Expression , type_declaration_types::Typoid)
        |
        UNT_CONSTANT_IN_EXPRESSION
        (multiword_int::Int , type_declaration_types::Typoid)
        |
        VALCON_IN_EXPRESSION
        {typescheme_args:List(type_declaration_types::Typoid ), valcon:type_declaration_types::Valcon}
        |
        VARIABLE_IN_EXPRESSION
                {typescheme_args:List(type_declaration_types::Typoid ),
                var:Ref(variables_and_constructors::Variable )}
        |
        VECTOR_IN_EXPRESSION
        (List(Deep_Expression ) , type_declaration_types::Typoid)
        |
        WHILE_EXPRESSION
        {expression:Deep_Expression, test:Deep_Expression};
    Case_Rule  = CASE_RULE (Case_Pattern , Deep_Expression);
        Case_Pattern
        = APPLY_PATTERN
        (type_declaration_types::Valcon , List(type_declaration_types::Typoid ) , Case_Pattern)
        |
        AS_PATTERN
        (Case_Pattern , Case_Pattern)
        |
        CHAR_CONSTANT_IN_PATTERN
        String
        |
        CONSTRUCTOR_PATTERN
        (type_declaration_types::Valcon , List(type_declaration_types::Typoid ))
        |
        FLOAT_CONSTANT_IN_PATTERN
        String
        |
        INT_CONSTANT_IN_PATTERN
        (multiword_int::Int , type_declaration_types::Typoid)
        |
        NO_PATTERN
        |
        OR_PATTERN
        (Case_Pattern , Case_Pattern)
        |
        RECORD_PATTERN
                {fields:List(((type_declaration_types::Label , Case_Pattern)) ), is_incomplete:Bool,
                type_ref:Ref(type_declaration_types::Typoid )}
        |
        STRING_CONSTANT_IN_PATTERN
        String
        |
        TYPE_CONSTRAINT_PATTERN
        (Case_Pattern , type_declaration_types::Typoid)
        |
        UNT_CONSTANT_IN_PATTERN
        (multiword_int::Int , type_declaration_types::Typoid)
        |
        VARIABLE_IN_PATTERN
        variables_and_constructors::Variable
        |
        VECTOR_PATTERN
        (List(Case_Pattern ) , type_declaration_types::Typoid)
        |
        WILDCARD_PATTERN;
        Declaration
        = API_DECLARATIONS
        List(module_level_declarations::Api )
        |
        EXCEPTION_DECLARATIONS
        List(Named_Exception )
        |
        FIXITY_DECLARATION
        {fixity:?.fixity::Fixity, ops:List(symbol::Symbol )}
        |
        GENERIC_API_DECLARATIONS
        List(module_level_declarations::Generic_Api )
        |
        GENERIC_DECLARATIONS
        List(Named_Generic )
        |
        INCLUDE_DECLARATIONS
        List(((symbol_path::Symbol_Path , module_level_declarations::Package)) )
        |
        LOCAL_DECLARATIONS
        (Declaration , Declaration)
        |
        OVERLOADED_VARIABLE_DECLARATION
        variables_and_constructors::Variable
        |
        PACKAGE_DECLARATIONS
        List(Named_Package )
        |
        RECURSIVE_VALUE_DECLARATIONS
        List(Named_Recursive_Value )
        |
        SEQUENTIAL_DECLARATIONS
        List(Declaration )
        |
        SOURCE_CODE_REGION_FOR_DECLARATION
        (Declaration , Source_Code_Region)
        |
        SUMTYPE_DECLARATIONS
        {sumtypes:List(type_declaration_types::Type ), with_types:List(type_declaration_types::Type )}
        |
        TYPE_DECLARATIONS
        List(type_declaration_types::Type )
        |
        VALUE_DECLARATIONS
        List(Named_Value );
        Package_Expression
        = COMPUTED_PACKAGE
                {a_generic:module_level_declarations::Generic, generic_argument:module_level_declarations::Package,
                parameter_types:List(type_declaration_types::Typepath )}
        |
        PACKAGE_BY_NAME
        module_level_declarations::Package
        |
        PACKAGE_DEFINITION
        List(symbolmapstack_entry::Symbolmapstack_Entry )
        |
        PACKAGE_LET
        {declaration:Declaration, expression:Package_Expression}
        |
        SOURCE_CODE_REGION_FOR_PACKAGE
        (Package_Expression , Source_Code_Region);
        Generic_Expression
        = GENERIC_BY_NAME
        module_level_declarations::Generic
        |
        GENERIC_DEFINITION
                {definition:Package_Expression, parameter:module_level_declarations::Package,
                parameter_types:List(type_declaration_types::Typepath )}
        |
        GENERIC_LET
        (Declaration , Generic_Expression)
        |
        SOURCE_CODE_REGION_FOR_GENERIC
        (Generic_Expression , Source_Code_Region);
        Named_Value
        = VALUE_NAMING
                {expression:Deep_Expression, generalized_typevars:List(type_declaration_types::Typevar_Ref ),
                pattern:Case_Pattern, raw_typevars:Ref(List(type_declaration_types::Typevar_Ref ) )};
        Named_Recursive_Value
        = NAMED_RECURSIVE_VALUE
                {expression:Deep_Expression, generalized_typevars:List(type_declaration_types::Typevar_Ref ),
                null_or_type:Null_Or(type_declaration_types::Typoid ),
                raw_typevars:Ref(List(type_declaration_types::Typevar_Ref ) ),
                variable:variables_and_constructors::Variable};
        Named_Exception
        = DUPLICATE_NAMED_EXCEPTION
        {equal_to:type_declaration_types::Valcon, exception_constructor:type_declaration_types::Valcon}
        |
        NAMED_EXCEPTION
                {exception_constructor:type_declaration_types::Valcon,
                exception_typoid:Null_Or(type_declaration_types::Typoid ), name_string:Deep_Expression};
        Named_Package
        = NAMED_PACKAGE         {a_package:module_level_declarations::Package, definition:Package_Expression,
                                name_symbol:symbol::Symbol};
        Named_Generic
        = NAMED_GENERIC         {a_generic:module_level_declarations::Generic, definition:Generic_Expression,
                                name_symbol:symbol::Symbol};
    Fnrules  = (List(Case_Rule ) , type_declaration_types::Typoid);};
\end{verbatim}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
