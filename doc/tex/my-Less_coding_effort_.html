<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Less coding effort.</TITLE>
</HEAD>
<BODY >
<A HREF="my-Executive_summary_.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Typesafe_.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H2 CLASS="section"><A NAME="htoc3">1.2</A>  Less coding effort.</H2><P>Here is Quicksort in one line in Mythryl:</P><PRE CLASS="verbatim">    fun qsort [] =&gt; [];  qsort (x!xs) =&gt; qsort (filter {. #a &lt; x; } xs) @ [x] @ qsort (filter {. #a &gt;= x; } xs);  end;
</PRE><P>Admittedly, one would usually format it more like:</P><PRE CLASS="verbatim">    fun qsort [] =&gt; [];
        qsort (x ! xs) =&gt; qsort (filter {. #a &lt; x; } xs) @ [x] @ qsort (filter {. #a &gt;= x; } xs);
    end;
</PRE><P>Either way, this is a far cry from the hundred-plus lines of code of a typical C Quicksort implementation.</P><P>Here is a one-liner which finds and prints all C files under the current directory:</P><PRE CLASS="verbatim">    #/usr/bin/mythryl
    foreach (dir_tree::files ".") {. if (#file =~ ./\\.[ch]$/)  printf "%s\n" #file;  fi; };
</PRE><P>Here is another which generates a list of all Pythagorean triples (<I>i</I>,<I>j</I>,<I>k</I>) such that <I>i</I><SUP>2</SUP> + <I>j</I><SUP>2</SUP> = <I>k</I><SUP>2</SUP>, 
all values being twenty or less:</P><PRE CLASS="verbatim">    linux$ my

    eval:   [ (i,j,k) for i in 1..20 for j in i..20 for k in j..20 where i*i + j*j == k*k ];

    [ (3, 4, 5), (5, 12, 13), (6, 8, 10), (8, 15, 17), (9, 12, 15), (12, 16, 20) ]
</PRE><P>Here is a Mythryl recursive descent parser for a fragment of English, written 
directly in vanilla Mythryl:</P><PRE CLASS="verbatim">    verb      =  match [ "eats", "throws", "eat", "throw" ];
    noun      =  match [ "boy", "girl", "apple", "ball"   ];
    article   =  match [ "the", "a"                       ];
    adjective =  match [ "big", "little", "good", "bad"   ];
    adverb    =  match [ "quickly", "slowly"              ];

    qualified_noun =   noun   |   adjective  &amp;  noun;
    qualified_verb =   verb   |   adverb     &amp;  verb;

    noun_phrase    =             qualified_noun
                   | article  &amp;  qualified_noun;

    sentence
        =
        ( noun_phrase  &amp;  qualified_verb  &amp;  noun_phrase     # "The little boy quickly throws the ball"
        |                 qualified_verb  &amp;  noun_phrase     # "Eat the apple"
        | noun_phrase  &amp;  qualified_verb                     # "The girl slowly eats"
        |                 qualified_verb                     # "Eat"
        );
</PRE><P>This example owes its conciseness to deft use of: </P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Type inference</B>: No explicit type declarations needed. This cuts the code in half. 
</LI><LI CLASS="li-itemize"><B>Partially applied curried functions</B>: This cuts the code in half again. 
</LI><LI CLASS="li-itemize"><B>Lists</B>: Mythryl&#X2019;s Lisp-style lists cut many solutions in half.
Where a C or Java programmer has to do the custom linklist dance 
yet again, the Mythryl programmer just reaches for standard lists. 
</LI><LI CLASS="li-itemize"><B>Parametric polymorphism</B>: This is what lets Mythryl lists be used off-the-shelf 
with a wide variety of sumtypes in perfect type safety. 
</LI><LI CLASS="li-itemize"><B>Infix operators</B>: Mythryl makes it trivially easy to redefine operators 
like &#X2019;|&#X2019; and &#X2019;&amp;&#X2019; for the particular task at hand. 
</LI><LI CLASS="li-itemize"><B>Concise syntax</B>: Mythryl keeps reserved word count and use to an 
absolute minimum, making it easy for your own code to shine through. 
The above example does not use a single reserved word; a C++ or Java translation 
might well use a dozen or more. 
</LI></UL><P>(For the complete code and development of the above example 
see <A HREF="my-Mythryl_Functions__Parsing_Combinators_I.html#section:tut:fullmonte:parsing-combinators-i">this tutorial</A>, which also shows how to code it even more concisely.)</P><P>If you&#X2019;ve only used Java and C++, phrases like <I>partially applied curried function</I> 
and <I>parametric polymorphism</I> probably sound like sheer gobbledygook, but once you 
have used them for a week or two you&#X2019;ll wonder how you ever lived without them.</P><P>Collapsing pages of code into a few deft lines means less coding time, 
less debugging time, less maintenance time, and thus more time left to spend 
on the enjoyable aspects of software design and implementation.</P><P>Harder to quantify, but to many people even more important, is that 
deft, concise code is simply more <I>satisfying</I> to write. Verbose 
code is ugly; concise code is beautiful. Nobody enjoys creating 
ugliness; everyone enjoys creating beauty.</P><P><I>Mythryl unleashes your inner code poet.</I></P><P>Thanks to type safety and Hindley-Milner type inference, Mythryl combines the conciseness 
of scripting languages like Python with the efficiency of &#X201C;strongly typed&#X201D; compiled 
languages like C++.</P><P>This yields the best of both worlds from a coding effort point of view. </P><UL CLASS="itemize"><LI CLASS="li-itemize">Like the scripting language programmer, the Mythryl programmer wastes little 
time writing explicit type declarations.</LI><LI CLASS="li-itemize">Unlike the scripting language programmer, 
the Mythryl programmer wastes little time tracking down runtime bugs; most problems are 
caught at compile time.</LI></UL><P>Every C programmer is drearily familiar with the fact that almost any 
significant maintenance change will result in multiple debugging runs, and more 
often than not some digging through coredumps in the debugger. </P><P>C programmers new to Mythryl are often startled to find that the 
typical maintenance change results in a program which runs as 
soon as it compiles.</P><P>At first, it feels like cheating.</P><P>This property is partly due to type safety and partly due to the somewhat 
mysterious fact that rich type systems tend to catch a lot more errors 
than by rights they should; most of the time a serious logic error 
turns out to trigger some sort of type error which results in it getting 
caught at compile time.</P><P>This <EM>does</EM> depend on the programmer working with the type system 
rather than against it. This means exposing as much as possible of 
the semantics of the program to the type system. 
One can, for example, 
treat all the keys to all the hashtables in a program as being of type 
String.
But one can also assign different types to the keys for the 
different hashtables, in which case the typechecker will automatically 
flag as an error any attempt to use look up a key in the wrong hashtable. </P><P>The C programmer, laboring under a low-level type system incapable of 
expressing much of the required semantic subtlety, quickly acquires the 
habit of working around it via casts.</P><P>Learning to program effectively in Mythryl means unlearning this habit, 
learning instead to take creative advantage of the expressiveness of 
the Mythryl type system to describe to the compiler as much as possible 
of what is going on.</P><P>Be nice to your compiler, and it will save you untold hours of debug misery!</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Executive_summary_.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Typesafe_.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
