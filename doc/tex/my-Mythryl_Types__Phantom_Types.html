<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mythryl Types: Phantom Types</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mythryl_Types__Extensible_Types.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Packages__Strong_vs_Weak.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc104">5.4.19</A>  Mythryl Types: Phantom Types</H3><P><I><FONT SIZE=1>Material in this tutorial is adapted from 
</FONT></I><A HREF="http://arxiv.org/pdf/cs.PL/0403034"><I><FONT SIZE=1>Phantom Types and Subtyping</FONT></I></A><I><FONT SIZE=1> by Fluet and Pucalla, 2006</FONT></I></P><P>Studies have documented productivity differences of as much as fifty to one between programmers doing the same work side by side. Great 
programmers achieve these sorts of results not by working harder than 
mediocre programmers, but by working smarter. Why do laboriously by 
hand something which the computer can do more reliably and more quickly?</P><P>Mythryl provides ample scope to work smarter instead of harder, for those 
so inclined. One of the great under-appreciated facilities it offers for 
doing so is its Hindley-Milner typechecker.</P><P>This typechecker is based on the <I>unify</I> operation from logic 
programming made famous by Prolog; it is in essence a poor man&#X2019;s 
theorem prover. Consequently when writing Mythryl type declarations 
you have at your fingertips much of the power of the power of pure 
Prolog.</P><P>By using this power inventively, you can program the Mythryl compiler 
to catch problems automatically at compile time which you might 
otherwise wind up having to track down at run time.</P><P>In real-world terms, this can mean the difference between being 
home sound asleep at three AM, or working late in a caffeine stupor 
against a deadline trying to track down "one last bug". That is 
part of the difference between working smarter and working harder.</P><P>The full power of Hindley-Milner type checking has become apparent 
only slowly over time; we are still discovering new ways of applying 
it to solve real-world programming problems. You might be the first 
to discover yet another!</P><P>Many such techniques are based on <I>phantom types</I>.</P><P>In the C world, types and values correspond in a simple way: Usually 
there is a type every value, and values are created for every type.</P><P>Hindley-Milner typechecking opens up a new world of possibilities.</P><P>For example, it turns out to be possible to implement (emulate) the 
entire C type system via appropriate Mythryl type declarations. The 
Mythryl C library interface autogeneration utility <TT>c-glue / 
c-glue-maker</TT>, which is the Mythryl port of Matthias Blume&#X2019;s <SPAN STYLE="font-variant:small-caps">SML/NJ</SPAN> <SPAN STYLE="font-variant:small-caps">NLFFI</SPAN> package, does this: You may see part of the code 
in 
<A HREF="my-src_lib_c-glue-lib_c_api.html#src/lib/c-glue-lib/c.api">src/lib/c-glue-lib/c.api</A>.</P><P>When doing such advanced Mythryl type hacking, types are often defined with no intent of ever creating any directly corresponding data values. 
Because of the lack of corresponding data values, such types are often 
called <I>phantom types</I>.</P><P>When we define phantom types we are ceasing to think in terms 
of runtime code and instead starting to regard the Mythryl 
type language as a way of programming the Mythryl typechecker to perform 
tasks of interest to us at compile time. We are programming on a different 
plane.</P><P>Suppose we are implementing a weakly typed interpreter vaguely like 
Perl or Python. We have a <TT>Value</TT> type that the interpreter 
manipulates, which supports integer and boolean values, and operations 
like <TT>print</TT>, <TT>increment</TT> and <TT>not</TT> which may be performed upon 
those values.</P><P>Our code might well look something like this:
</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    Value = INT( Int ) | BOOL( Bool) ; 

    fun make_int_value  (i): Value = INT(  i );
    fun make_bool_value (b): Value = BOOL( b );

    fun print (v: Value)
        =
        case v
        INT( i) =&gt; printf "%d" i;
        BOOL(b) =&gt; printf "%B" b;
        esac;
       
    fun increment (v: Value): Value
        =
        case v
        INT( i) =&gt; INT( i + 1 );
        BOOL(b) =&gt; raise exception DIE "Cannot increment a Boolean value";
        esac;

    fun not (v: Value): Value
        =
        case v
        INT( i) =&gt; raise exception DIE "Cannot 'not' an Int value";
        BOOL(b) =&gt; BOOL( bool::not b );
        esac;

    v  = make_int_value( 12 );
    v' = not( v );
</PRE><P>Here we have one function each for creating boolean and integer flavors of 
value, a function which can print both boolean and integer values, a 
function which can increment integer values, and a function which can 
<TT>not</TT> boolean values.</P><P>The above code will compile just fine, but at runtime the final line 
will produce a <TT>"Cannot &#X2019;not&#X2019; an Int value"</TT>; runtime error.</P><P>This is sub-optimal. As a matter of design praxis, we would prefer to 
catch such errors at compile time rather than at run time if at all 
practical. (Suppose the program ran for sixty hours before issuing 
the runtime error and exiting!)</P><P>We do not want to just make our integer and boolean values completely 
different types, because we want functions like <TT>print</TT> above to 
operate indifferently upon either. Yet with them both folded into the 
same type, the typechecker has no way of flagging the above sort of 
coding errors.</P><P>Phantom types offer a solution:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    Value(X) = INT( Int ) | BOOL( Bool) ; 

    fun make_int_value  (i): Value(Int)  = INT(  i );
    fun make_bool_value (b): Value(Bool) = BOOL( b );

    fun print (v: Value(X))
        =
        case v
        INT( i) =&gt; printf "%d" i;
        BOOL(b) =&gt; printf "%B" b;
        esac;
       
    fun increment (v: Value(Int)): Value(Int)
        =
        case v
        INT( i) =&gt; INT( i + 1 );
        BOOL(b) =&gt; raise exception DIE "Cannot increment a Boolean value";
        esac;

    fun not (v: Value(Bool)): Value(Bool)
        =
        case v
        INT( i) =&gt; raise exception DIE "Cannot 'not' an Int value";
        BOOL(b) =&gt; BOOL( bool::not b );
        esac;

    v  = make_int_value( 12 );
    v' = not( v );
</PRE><P>The above code now gives a type error when it compiles.</P><P>The crucial difference is that <TT>Value</TT> now takes a phantom type as argument.</P><P>Mythryl does not support subtypes in a true mathematical sense, 
but the <TT>Value</TT> phantom type parameter lets us effectively define 
sub-types <TT>Value(Int)</TT> and <TT>Value(Bool)</TT> of our base 
type <TT>Value(X)</TT>.</P><P>This lets us distinguish the return types of <TT>make_int_value</TT> 
and <TT>make_bool_value</TT> by declaring them as respectively 
<TT>Value(Int)</TT> and <TT>Value(Bool)</TT>.</P><P>By defining <TT>print</TT> to take a type of <TT>Value(X)</TT>, we allow it 
to be given arguments of types both <TT>Value(Int)</TT> and <TT>Value(Bool)</TT>.</P><P>But by defining <TT>increment</TT> and <TT>not</TT> to accept respectively values of 
type <TT>Value(Int)</TT> and <TT>Value(Bool)</TT>, we prime the type-checker to flag any 
attempt to call either with an inappropriate value.</P><P>Note that there is never any data value component corresponding to the phantom 
type parameter; we added the phantom type without changing the runtime sumtype 
in any way.</P><P>Note also that we could use any two types whatever as the 
phantom types in the above example, so long as they were typechecker distinct 
&#X2014; so long as they did not <I>unify</I>.</P><P>For example, the following program is exactly equivalent, despite the replacement 
of <TT>Int</TT> and <TT>Bool</TT> by <TT>Vector</TT> and <TT>String</TT> as our phantom 
witness types:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    Value(X) = INT( Int ) | BOOL( Bool ); 

    fun make_int_value  (i): Value(Vector) = INT(  i );
    fun make_bool_value (b): Value(String) = BOOL( b );

    fun print (v: Value(X))
        =
        case v
        INT( i) =&gt; printf "%d" i;
        BOOL(b) =&gt; printf "%B" b;
        esac;
       
    fun increment (v: Value(Vector)): Value(Vector)
        =
        case v
        INT( i) =&gt; INT( i + 1 );
        BOOL(b) =&gt; raise exception DIE "Cannot increment a Boolean value";
        esac;

    fun not (v: Value(String)): Value(String)
        =
        case v
        INT( i) =&gt; raise exception DIE "Cannot 'not' an Int value";
        BOOL(b) =&gt; BOOL( bool::not b );
        esac;

    v  = make_int_value( 12 );
    v' = not( v );
</PRE><P>This emphasizes the irrelevance of phantom types to the runtime behavior of 
the program; they are purely compiletime book-keeping.</P><P>To help settle the idea, here is a similar example with another setting, 
this time one involving a TCP/IP network socket library.</P><P>Here we assume a fictional underlying <TT>net</TT> package which does 
all the work irrelevant to our example:</P><PRE CLASS="verbatim">    Socket = UNT( one_word_unt:Unt );

    fun make_udp_socket( address: String ): Socket = {
        net::make_udp_socket address;
    };
    fun make_tcp_socket( address: String ): Socket = {
        net::make_tcp_socket address;
    };

    fun udp_send( socket: Socket,  string: String) = {
        net::udp_send( socket, string );
    }
    fun tcp_send( socket: Socket,  string: String) = {
        net::tcp_send( socket, string );
    }

    fun close_socket( socket: Socket ) = {
        net::close_socket( socket );
    }    
</PRE><P>Once again, the issue here is that we have two types, <TT>upd</TT> and <TT>tcp</TT> 
sockets, which are neither completely distinct nor identical. We can only 
call <TT>udp_send</TT> on <TT>udp</TT> sockets and only call <TT>tcp_send</TT> on 
<TT>tcp</TT> sockets, but we may call <TT>close_socket</TT> on either. Given the 
above implementation, unfortunately, doing a send on the wrong type socket 
will be detected only at runtime, not at compile type.</P><P>Once again, we can solve the problem by adding phantom types to record 
the needed subtyping information. This time we declare some fresh 
sumtypes to use as the phantom types, just to improve readability:</P><PRE CLASS="verbatim">    Udp = UDP;          # Used only as phantom type.
    Tcp = TCP;          # Used only as phantom type.

    Socket(X) = UNT( one_word_unt:Unt );

    fun make_udp_socket( address: String ): Socket(UDP) = {
        net::make_udp_socket address;
    };
    fun make_tcp_socket( address: String ): Socket(TCP) = {
        net::make_tcp_socket address;
    };

    fun udp_send( socket: Socket(UDP),  string: String) = {
        net::udp_send( socket, string );
    }
    fun tcp_send( socket: Socket(TCP),  string: String) = {
        net::tcp_send( socket, string );
    }

    fun close_socket( socket: Socket(X) ) = {
        net::close_socket( socket );
    }    
</PRE><P>Now any attempt to do a send on the wrong type of socket will 
draw a compile error, but we may still call <TT>close_socket</TT> on 
either type of socket.</P><P>Suppose now that we wanted to encode a two-level type hierarchy using 
phantom types: We have a value type which subdivides into floating 
point and integer, where the integer type in turn subdivides into 
32-bit and 64-bit integers. We have a <TT>print_value</TT> operation 
which may be applied to any of them, an <TT>exp</TT> operation which 
applies only to floats, an <TT>increment</TT> operation which applies 
to both integer types, and a <TT>negate</TT> operation which (for 
some reason) applies only to 32-bit integers.</P><P>We can implement this via phantom types by using two phantom type 
type variables in our <TT>Value</TT> definition instead of just one 
as above:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    My_Int     = MY_INT;
    My_Int1   = MY_INT1;
    My_Int2   = MY_INT2;
    My_Float   = MY_FLOAT;

    Value(X,Y) = INT1(one_word_int::Int) 
               | INT2(two_word_int::Int)
               | FLOAT(float::Float)
               ;

    fun make_int1 (i: one_word_int::Int):           Value(My_Int, My_Int1)
        =
        INT1(i);

    fun make_int2 (i: two_word_int::Int):           Value(My_Int, My_Int2)
        =
        INT2(i);

    fun make_float (f: float::Float):         Value(My_Float, Y)
        =
        FLOAT(f);

    fun print_value( v: Value(X,Y) )
        =
        case  v
        INT1(i) =&gt;   print (one_word_int::to_string i);
        INT2(i) =&gt;   print (two_word_int::to_string i);
        FLOAT(f) =&gt;   print (float::to_string f);
        esac;

    fun increment( v: Value(My_Int,Y) ):      Value(My_Int,Y)
        =
        case  v
        INT1(i) =&gt;   INT1( i + 1 );
        INT2(i) =&gt;   INT2( i + 1 );
        _        =&gt;   raise exception DIE "increment: impossible case";
        esac;

    fun negate( v: Value(My_Int,My_Int1) ):   Value(My_Int,My_Int1)
        =
        case  v
        INT1(i) =&gt;   INT1( one_word_int::neg i );
        _        =&gt;   raise exception DIE "negate: impossible case";
        esac;

    fun exp( v: Value(My_Float,Y) ):          Value(My_Float,Y)
        =
        case  v
        FLOAT(f) =&gt;   FLOAT( float::math::exp(f) );
        _        =&gt;   raise exception DIE "exp: impossible case";
        esac;
</PRE><P>Quite general hierarchical subtyping relationships may be encoded and checked 
using phantom types. In general, for each additional level of hierarchy we 
will add one additional phantom type variable. For an in-depth discussion see 
<A HREF="http://arxiv.org/pdf/cs.PL/0403034">Phantom Types and Subtyping</A> by Fluet and Pucalla, 2006, from which much of the material in this tutorial was adapted.</P>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mythryl_Types__Extensible_Types.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Packages__Strong_vs_Weak.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
