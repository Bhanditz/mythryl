<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mythryl Functions: Parsing Combinators I</TITLE>
</HEAD>
<BODY >
<A HREF="my-Mythryl_Functions__Currying_and_Partial_Application.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Functions__Thunk_Syntax.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc92">5.4.7</A>  Mythryl Functions: Parsing Combinators I</H3><P>
<A NAME="section:tut:fullmonte:parsing-combinators-i"></A></P><P>In this section we take a short break from introducing new 
language features in order to show how to use currying, higher 
order functions, partial application, fates and infix 
notation to build a concise recursive-descent backtracking parser. </P><P>Combinator parsing is a pretty technique well worth learning 
in and of itself; it is also an excellent exercise in simplifying 
code by thinking functionally.</P><P>Today parsers generated by tools like <TT>yacc</TT> 
are usually used when generating parsers for programming 
languages. However, recursive descent parsers still have 
advantages in fields like natural language processing, where 
the grammar may be not be LALR(1), or where it may be 
necessary to work with ambiguous grammars, returning all 
possible parses of a sentence and then using semantic 
constraints to select the most probable one.</P><P>Here are the parser rules for a small fragment of English:</P><PRE CLASS="verbatim">    verb      =  match [ "eats", "throws", "eat", "throw" ];
    noun      =  match [ "boy", "girl", "apple", "ball"   ];
    article   =  match [ "the", "a"                       ];
    adjective =  match [ "big", "little", "good", "bad"   ];
    adverb    =  match [ "quickly", "slowly"              ];

    qualified_noun =   noun   |   adjective  &amp;  noun;
    qualified_verb =   verb   |   adverb     &amp;  verb;

    noun_phrase    =             qualified_noun
                   | article  &amp;  qualified_noun;

    sentence
        =
        ( noun_phrase  &amp;  qualified_verb  &amp;  noun_phrase     # "The little boy quickly throws the ball"
        |                 qualified_verb  &amp;  noun_phrase     # "Eat the apple"
        | noun_phrase  &amp;  qualified_verb                     # "The girl slowly eats"
        |                 qualified_verb                     # "Eat"
        );
</PRE><P>That code is straight Mythryl, although it may not seem so 
at first glance. To make those rules work, we must first 
define a few support functions.</P><P>We start by defining a binary-tree datastructure:</P><PRE CLASS="verbatim">    Parsetree = PAIR (Parsetree, Parsetree)
              | TOKEN String
              ;
</PRE><P>This will hold the syntax tree generated by our parser.</P><P>As support we define a simple function to print out our parsetrees:</P><PRE CLASS="verbatim">    fun parsetree_to_string (TOKEN string)
            =&gt;
            string;

        parsetree_to_string (PAIR (parsetree1, parsetree2))
            =&gt;
            sprintf "(%s %s)"
                (parsetree_to_string  parsetree1)
                (parsetree_to_string  parsetree2);
    end;
</PRE><P>The elements of our parser are parse functions, each 
of which attempts to match some pattern such as a verb phrase 
or noun phrase against part of the input string. Our parse 
functions have the type</P><PRE CLASS="verbatim">    Parse_Function
        =
        Success_Fate -&gt; Failure_Fate -&gt; List(String) -&gt; Void;
</PRE><P>We use fate passing to handle backtracking: We 
call the <TT>Success_Fate</TT> function if our parse function 
succeeds in matching its assigned pattern at the current location within 
the input text, otherwise we call the <TT>Failure_Fate</TT>.
The final <TT>List(String)</TT> argument is the list of input 
tokens yet to be parsed.</P><P>The fate function types are:</P><PRE CLASS="verbatim">    Failure_Fate
        =
        Void -&gt; Void;

    Success_Fate
        =
        Parsetree            -&gt;         # Parsetree for substring just matched.
        Failure_Fate -&gt;
        List(String)         -&gt;         # Input tokens not yet matched.
        Void;
</PRE><P>We begin with a parse function which attempts to match the next 
input token against a list of words:</P><PRE CLASS="verbatim">    in = list::in;      # ``word in [ "abc", "def" ]'' is TRUE iff word == "abc" or word == "def".

    fun match  words  success_fate  failure_fate  []   : Void
            =&gt;
            failure_fate  ();                                               # No token to match.

        match  words  success_fate  failure_fate (token ! tokens)
            =&gt;
            if (string::to_lower(token) in words)

                 success_fate  (TOKEN token) failure_fate  tokens;
            else
                 failure_fate  ();                                          # Next token does not match.
            fi;     
    end;
</PRE><P>This function is reasonably straightforward. If the next input token 
matches one of our words we construct a <TT>TOKEN</TT> syntax tree 
node representing our successfully matched one-word syntax subtree 
and pass it to our <TT>success_fate</TT>, otherwise we call our 
<TT>failure_fate</TT>.</P><P>Next we define an "and" function which matches two patterns consecutively 
in the input. This function takes as input two parse functions describing 
the subpatterns, and returns a parse function which will match their 
concatenation.</P><P>Because they build new parse functions by combining existing 
parse functions such 
functions are often called <I>combining forms</I>, or simply <I>combinators</I>.</P><P>The type of our combinator is</P><PRE CLASS="verbatim">    (Parser, Parser) -&gt; Parser 
</PRE><P>To improve the readability of our grammar rules, we 
use the infix operator <TT>&amp;</TT> to name this function:</P><PRE CLASS="verbatim">    fun parse_fn_1 &amp; parse_fn_2
        =
        \\  success_fate
            =
            parse_fn_1
                (\\ parsetree_1
                    =
                    parse_fn_2
                        (\\ parsetree_2
                            =
                            success_fate  (PAIR (parsetree_1, parsetree_2))
                        )
                );
</PRE><P>This function is also quite straightforward. We call 
<TT>parser_1</TT> with a success fate 
which calls <TT>parser_2</TT> 
with a success fate which constructs a syntax tree 
<TT>PAIR</TT> node combining the two syntax subtrees they 
construct for it and then passes that <TT>PAIR</TT> 
node to our own original success fate.</P><P>Note how we use partial application of curried functions 
to simplify the code. Both <TT>parser_1</TT> and <TT>parser_2</TT> 
take more arguments than explicitly shown. We could have 
written the same function as</P><PRE CLASS="verbatim">    fun parse_fn_1 &amp; parse_fn_2
        =
        \\  success_fate
            =
        \\  failure_fate
            =
        \\  tokens
            =
            parse_fn_1  success_fate_1  failure_fate  tokens
            where
                fun success_fate_1  parsetree_1  failure_fate  tokens
                    =
                    parse_fn_2  success_fate_2  failure_fate  tokens
                    where
                        fun success_fate_2  parsetree_2  failure_fate  tokens
                            =
                            success_fate  (PAIR (parsetree_1, parsetree_2))  failure_fate  tokens;
                    end;
            end;
</PRE><P>By using partial application we have cut our code in half.</P><P>Next we define a complementary "or" function which matches in the 
input either one of two given parse functions. Once again, to 
improve readability, we give it a compact infix name instead of 
a conventional prefix alphabetic name:</P><PRE CLASS="verbatim">    fun parse_fn_1 | parse_fn_2
        =
        \\  success_fate
            =
        \\  failure_fate
            =
        \\  tokens
            =
            parse_fn_1  success_fate_1  failure_fate_1  tokens
            where
                fun success_fate_1  parsetree   ignored_failure_fate  tokens
                    =
                    success_fate  parsetree   failure_fate  tokens;

                fun failure_fate_1 ()
                    =
                    parse_fn_2  success_fate  failure_fate  tokens;
            end;
</PRE><P>This function is much like the preceding one, except that here 
we synthesize a failure fate as well as a success fate.</P><P>We now have all the machinery in place for the grammar rule 
functions illustrated at the top of this section:</P><PRE CLASS="verbatim">    verb      =  match [ "eats", "throws", "eat", "throw" ];
    noun      =  match [ "boy", "girl", "apple", "ball"   ];
    article   =  match [ "the", "a"                       ];
    adjective =  match [ "big", "little", "good", "bad"   ];
    adverb    =  match [ "quickly", "slowly"              ];

    qualified_noun =   noun   |   adjective  &amp;  noun;
    qualified_verb =   verb   |   adverb     &amp;  verb;

    noun_phrase    =             qualified_noun
                   | article  &amp;  qualified_noun;

    sentence
        =
        ( noun_phrase  &amp;  qualified_verb  &amp;  noun_phrase     # "The little boy quickly throws the ball"
        |                 qualified_verb  &amp;  noun_phrase     # "Eat the apple"
        | noun_phrase  &amp;  qualified_verb                     # "The girl slowly eats"
        |                 qualified_verb                     # "Eat"
        );
</PRE><P>Note how we once again use partial application of curried functions 
to keep the code concise. For example the first rule above can 
be written</P><PRE CLASS="verbatim">    fun verb  success_fate  failure_fate  tokens
        =
        match [ "eats", "throws" ]  success_fate  failure_fate  tokens;
</PRE><P>but if we do that with all the rules they will be much 
harder to read and maintain.</P><P>Here are the final four functions needed to produce a functioning 
mini-parser for our fragment of English:</P><PRE CLASS="verbatim">    fun parse string
        =
        sentence
            toplevel_success_fate
            toplevel_failure_fate
            (string_to_words  string)

         where

            fun toplevel_success_fate  parsetree  failure_fate  tokens
                =
                printf "Successful parse: %s\n" (parsetree_to_string  parsetree);


            fun toplevel_failure_fate  ()
                =
                print  "No parse found.\n";


            string_to_words =  string::tokens  char::is_space;
        end;
</PRE><P>Putting it all together, here is our complete parser package:</P><PRE CLASS="verbatim">    package parse1 {

        in = list::in;

        Parsetree = PAIR (Parsetree, Parsetree)
                  | TOKEN String
                  ;

        fun parsetree_to_string (TOKEN string)
                =&gt;
                string;

            parsetree_to_string (PAIR (parsetree1, parsetree2))
                =&gt;
                sprintf "(%s %s)"
                    (parsetree_to_string  parsetree1)
                    (parsetree_to_string  parsetree2);
        end;



        # A parse function which matches any word in a given list:
        #
        fun match  words  success_fate  failure_fate  []   : Void
                =&gt;
                failure_fate  ();                                               # No token to match.

            match  words  success_fate  failure_fate (token ! tokens)
                =&gt;
                if (string::to_lower(token) in words)

                     success_fate  (TOKEN token) failure_fate  tokens;
                else
                     failure_fate  ();                                          # Next token does not match.
                fi;         
        end;


        # An 'and' parse combinator which requires that
        # the two given parse functions match successive
        # portions of the 'tokens' input:
        #
        fun parse_fn_1 &amp; parse_fn_2
            =
            \\  success_fate
                =
                parse_fn_1
                    (\\ parsetree_1
                        =
                        parse_fn_2
                            (\\ parsetree_2
                                =
                                success_fate  (PAIR (parsetree_1, parsetree_2))
                            )
                    );


        # An 'or' parse combinator which requires that
        # one of the two given parse functions
        # match a prefix of 'tokens':
        #
        fun parse_fn_1 | parse_fn_2
            =
            \\  success_fate
                =
            \\  failure_fate
                =
            \\  tokens
                =
                parse_fn_1  success_fate_1  failure_fate_1  tokens
                where
                    fun success_fate_1  parsetree   ignored_failure_fate  tokens
                        =
                        success_fate  parsetree   failure_fate  tokens;

                    fun failure_fate_1 ()
                        =
                        parse_fn_2  success_fate  failure_fate  tokens;
                end;


        # Now a simple grammar for a small fragment of English:
        #
        verb      =  match [ "eats", "throws", "eat", "throw" ];
        noun      =  match [ "boy", "girl", "apple", "ball"   ];
        article   =  match [ "the", "a"                       ];
        adjective =  match [ "big", "little", "good", "bad"   ];
        adverb    =  match [ "quickly", "slowly"              ];

        qualified_noun =   noun   |   adjective  &amp;  noun;
        qualified_verb =   verb   |   adverb     &amp;  verb;

        noun_phrase    =             qualified_noun
                       | article  &amp;  qualified_noun;

        sentence
            =
            ( noun_phrase  &amp;  qualified_verb  &amp;  noun_phrase     # "The little boy quickly throws the ball"
            |                 qualified_verb  &amp;  noun_phrase     # "Eat the apple"
            | noun_phrase  &amp;  qualified_verb                     # "The girl slowly eats"
            |                 qualified_verb                     # "Eat"
            );


        # Finally, a toplevel function to drive it all:
        #
        fun parse string
            =
            sentence
                toplevel_success_fate
                toplevel_failure_fate
                (string_to_words  string)

            where

                fun toplevel_success_fate  parsetree  failure_fate  tokens
                    =
                    printf "Successful parse: %s\n" (parsetree_to_string  parsetree);


                fun toplevel_failure_fate  ()
                    =
                    print  "No parse found.\n";


                string_to_words =  string::tokens  char::is_space;
            end;
    };
</PRE><P>This code is in <TT>src/app/tut/combinator-parsing/parse1.pkg</TT> in the 
Mythryl source code distribution. You may try it out by doing</P><PRE CLASS="verbatim">    linux$ cd src/app/tut/combinator-parsing
    linux$ my
    eval:  make "parse1.lib";
    eval:  parse1::parse "The boy quickly throws the little ball";
    Successful parse: (((The boy) (quickly throws)) (the (little ball)))
</PRE><P><B>Further conciseness</B>:</P><P>At the risk of gilding the lily, recall that the Mythryl backticks 
operator is redefinable. For example, we can do:</P><PRE CLASS="verbatim">    linux$ my
    eval:  fun backticks__op string  =  string::tokens  char::is_space  string;
    eval:  `abc def`;

    ["abc", "def"]
</PRE><P>Of course, now that we are comfortable with partially applied 
curried functions, we are more likely to write just:</P><PRE CLASS="verbatim">    linux$ my
    eval:  backticks__op  =  string::tokens  char::is_space;
    eval:  `abc def`;

    ["abc", "def"]
</PRE><P>Either way, this lets us replace</P><PRE CLASS="verbatim">        verb      =  match [ "eats", "throws", "eat", "throw" ];
        noun      =  match [ "boy", "girl", "apple", "ball"   ];
        article   =  match [ "the", "a"                       ];
        adjective =  match [ "big", "little", "good", "bad"   ];
        adverb    =  match [ "quickly", "slowly"              ];
</PRE><P>by simply</P><PRE CLASS="verbatim">        verb      =  match `eats throws eat throw`;
        noun      =  match `boy girl apple ball`;
        article   =  match `the a`;
        adjective =  match `big little good bad`;
        adverb    =  match `quickly slowly`;
</PRE><P>If we wrap <TT>match</TT> into <TT>back__ticks</TT> by</P><PRE CLASS="verbatim">    fun backticks__op string  =  match  (string::tokens char::is_space string);
</PRE><P>we can abbreviate further to just</P><PRE CLASS="verbatim">        verb      =  `eats throws eat throw`;
        noun      =  `boy girl apple ball`;
        article   =  `the a`;
        adjective =  `big little good bad`;
        adverb    =  `quickly slowly`;
</PRE><P>Whether this is splendidly concise or dreadfully obscure 
depends on your taste and situation. Mythryl gives you 
the tools; how to use them is your decision.</P><P><B>Further reading</B>:</P><BLOCKQUOTE CLASS="quotation">
<A HREF="http://www.eecs.usma.edu/webs/people/okasaki/jfp98.ps">Even Higher Order Functions for Parsing</A><BR><A HREF="http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/hutton-parsing.pdf">Higher Order Functions for Parsing</A><BR></BLOCKQUOTE>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Mythryl_Functions__Currying_and_Partial_Application.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Functions__Thunk_Syntax.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
