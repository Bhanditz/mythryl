\chapter{Contributing}

% ================================================================================
% This chapter is referenced in:
%
%     doc/tex/book.tex
%

% ================================================================================
\section{Preface}

\begin{quote}\begin{tiny}
           ``Many hands make light work.''\newline
            ~~~~~~~~~~~~~~~~~~~~~~~~~---{\em Proverb}
\end{tiny}\end{quote}

The Mythryl project can benefit from any of the usual array of 
open source promotion activities ranging from evangelism to 
writing {\em HOW-TO}s to bugfixing to major infrastructure rewrites, 
but as a developer, I can speak effectively only to development issues.

% ================================================================================
\section{Apps}

Software teams scale poorly in general, and open source teams 
scale especially badly, so the most efficient way to contribute 
code to Mythryl development is to expand the software ecology 
by writing or porting to Mythryl whatever application 
lies closest to your heart.  (Motivation is everything!)

Mythryl apps I would personally particularly welcome include 
(in roughly increasing order of difficulty):

\begin{itemize}
\item A graphic biff.  (I'm a fan of \ahref{\xbuffy}{\sc XBuffy}, so I'd probably start by porting it.)
\item A classic mud.  Or a port of Moonflare's  \ahref{\mlud}{\sc MLud}.
\item A {\em TMDA}-style challenge-response spam filter.
\item An HTTP daemon.  (Apache is far too big to port, so I would look for some small security-oriented daemon as a starting point.)
\item A decent email client.  (I would start by porting the \ahref{\pronto}{\sc Pronto} Perl/Gtk client.)
\item A mailing list manager.  (I might start by porting \ahref{\mailman}{\sc MailMan}.)
\item A web browser.  I'm sick of flaky, leaky, unscriptable browsers.  Start by doing a simple Gtk wrapper of the Gecko engine, then start porting parts from C to Mythryl.
\item A raytracer.  Everyone loves doing simple raytracers in functional languages.  For (much!) extra credit: Implement the RenderMan spec.
\item An Arduino compiler, development environment and interface library.  Too much fun!
\item An CNC compiler, development platform, interface and driver. The current open source offerings are pathetic, so my CNC mill is gathering dust.
\item An SMTP daemon.  (I would start implementing the \ahref{\exim}{\sc Exim}. spec, which may well be the best-written spec in the open-source world.)
\item A \ahref{\texmacs}{\sc TeXmacs}-style programming editor.  (For extra credit, make it groupware!) 
\item A nice integrated app/framework for monitoring and managing a lanful of Linux boxes, including firewall configuration, drive health monitoring and programmable intrusion detection. Call it {\tt Argus}. :)
\item A port of CMU's \ahref{\nyquist}{\sc Nyquist} sound-synthesis language.
\item A programmable 3D graphics environment.  (I'm a fan of \ahref{\avs}{\sc AVS} 4 and  \ahref{\geomview}{\sc GeomView}, so I'd probably produce a mix of the two with some  \ahref{\blender}{\sc Blender} thrown in.)
\item A port of the \ahref{\ardour}{\sc Ardour} sound editor. A Mythryl version should be solid enough to use;  the C version may never be.
\item A port of the \ahref{\cinelerra}{\sc Cinelerra} video editor. A Mythryl version should be solid enough to use;  the C version may never be.
\item A peer-to-peer virtual world, sort of a sane acephalous {\em Second Life}.
\end{itemize}

If you do this, please make an effort to use existing Mythryl libraries 
wherever appropriate, and failing that to structure as much as practical 
of your application as libraries and generics re-usable by others.


% ================================================================================
\section{Interfaces to C libraries}

Write solid, well-thought out, well documented glue libraries 
to allow use of major C libraries from native Mythryl code. 
Don't forget docs, examples and tutorials.

Current targets include:

\begin{itemize}
\item Ncurses.
\item Gtk.
\item OpenGL.
\item OpenSSL.
\item OpenSSH.
\item OpenCV.
\item ALSA.
\item Jack.
\item A good linear algebra package.  Extra credit:  an APL/J style pure-functional interface.
\item MySQL. (Try to make it inherently SQL injection proof by at least optionally not going through a text stage.)
\item {\sc IMAP} mailbox access.
\end{itemize}




% ================================================================================
\section{Native Mythryl libraries}

Write solid, well-thought out, well documented Mythryl libraries. 
Again, don't forget docs, examples and tutorials.

Current targets include:

\begin{itemize}
\item Improve the general graph library:  Add algorithms, visualization tools, and conversions to and from major other datastructures.
\item Write/port an OpenGL-based graph visualization library.  \ahref{\graphviz}{\sc GraphViz} is probably the place to start.
\item A simple relational db library that plays nice with the Mythryl type system.
\item Port the {\sc Pacal} symbolic algebra package to Mythryl. Six kilolines of clean code.
\end{itemize}


% ================================================================================
\section{Improvements to the core Mythryl codebase}

\begin{quotation}\begin{tiny}
           ``A day will come when beings,\newline
           ~~now latent in our thoughts\newline
           ~~and hidden in our loins,\newline
           ~~shall stand upon Earth\newline
           ~~as a footstool and laugh,\newline
           ~~and reach out their hands\newline
           ~~amidst the stars.''\newline

            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~---{\em H.G. Wells, 1902}
\end{tiny}\end{quotation}


Closer to home, useful contributions (again in roughly increasing 
order of difficulty) include:

\begin{itemize}
\item Check out the existing libraries like {\tt x-kit}, see what works, fix what does not, document both, write tutorials and examples.
\item Protect existing functionality from bitrot by writing additional unit tests.
\item Expand and improve the {\tt winix} cross-platform OS/filesystem interface to include more functionality common to Windows, MacOS and *nix.
\item Improve the {\sc GNU} autotools based installation logic.
\item Grep the codebase for {\sc FIXME}, pick one, and fix it.
\item Do a proper Debian package for Mythryl.
\item Clean up the C runtime code so it compiles complaint-free under {\tt gcc -Wall}.  (I did this once, and lost it in a laptop disk futzup. {\em sigh}.)
\item Change the C runtime to use {\tt typedef}'d integer types everywhere, as preparation for an AMD-64 port.
\item Revive the currently broken backend architecture-description logic {\tt adl}.
\item Do a port to AMD-64.  (The biggest short-term win from this would be having a decent number of registers, unlike intel32: Probably good for a 15-30% speedup.)
\item Re-activate and maintain the Windows or Mac ports.
\item Reduce the start-up time for Mythryl scripts by pre-forking several ready-to-run mythryld processes.
\item Implement strings-as-types, to reduce the contortions of phantom type programming.
\item Implement a cleaner, more typesafe facility for generating Mythryl source code than just contacatenating strings.
\item Rewrite Makelib to cleanly separate parsing and processing.
\item Implement {\sc OOP} support per Bernard Berthomeiu's paper. (See next section.)
\item Revive Fu's UHawaii 1999 thesis work ``Design and Implementation of an Operating system in Standard ML'' and port to Mythryl. 
(This includes a port of the CMU Fox Project's SML TCP/IP protocol stack.)  Add in the x-kit code to allow standalone Mythryl 
applications to function as X clients.
\item Implement Generalized Abstract Types.  The Peyton Jones/Washburn/Weirich ``Wobbly Types'' paper is a good starting point.
\item Kill the compiler's overflow checking, except when specifically requested.
\item Kill the tagged\_int type.  It screws up the surface semantics for the sake of a few percent gain in space/time efficiency, which is always a bad idea.
\item Kill the sequence headers (SEQHDR) on strings and vectors.  These are inordinately expensive in time and space and intrude runtime typing into a system based on compile-time typing.
\item Design and implement an application-programmer API for accessing the codebase's incremental compilation capabilities.  The {\tt .lib} ``setup'' code has much of the required machinery.
\item Clean up the .lib file syntax.  I suggest making .lib files into vanilla Mythryl code executed at maketime.
\item Make the type-checker an easily replaced generic: There is an enormous amount of good research coming out on improved/alternate typechecking.
\item Re-implement typechecking based on Derek Dreyer and Karl Crary's CMU thesis work: The current stamp-based logic is a hoary kludge whose time has come. This will include phasing out equality types at the surface syntax level.
\item Implement alternate typechecking algorithms, selectable by a pragma or such:  Dependent types and linear types are attractive targets.
\item Re-activate the codebase support for inter-package inlining.  Be alert: It was probably disabled for a good reason.
\item Do a general tune-up of existing backend code optimization. There is probably a lot of low-hanging fruit here. You'll want to make/steal a benchmark suite to meaure progress and prevent regression.
\item Re/activate some or all of the backend optimizations based on (e.g.) SSA (Static Single Assignment).  This will probably break the garbage collector if you're not careful --- so be careful.
\item Do a production-quality reimplemention of Mythryl support for parallel compiles of the compiler on multicore machines.
\item Do a production-quality rewrite of the c-glue facility (nee' Matthias Blume's NLFFI) emphasizing semi-automated interface generation driven by SWIG-like spec files, 
      rather than fully automatic interface generation driven only by {\tt .h} files, which is heroic and a great research project, but not ready for prime time, making 
      the entire facility useless in practice.
\item Integrate the Mythryl {\tt x-kit} (ne\'e {\tt eXene}) libraries, making them the standard.
\item Make the Mythryl codebase more thread-safe by moving the various global variables scattered through it into dynamically allocated records.
\item Write a native Mythryl OpenGL widget kit taking {\tt x-kit} as a model but using the ``Adaptive Functional Programming'' mechanism for event propagation.
\item Re-activate the Mythryl codebase support for multiprocessing, which worked a decade ago on SGI and Sparc machines but has bitrotted since.
\item Write Mythryl debugger.  (I would start by reviewing David Tarditi's SML/NJ debugger paper(s), then fold in Xavier LeRoy's idea of using process forking to implement replay.)
\item Write a real-time garbage collector for Mythryl based on Cheng's 2001 CMU thesis.  Make it {\sc COW}-friendly to maximize shared pages after a fork().
\item Implement software transactional memory.  The Harris/Marlow/Peyton Jones/Herlihy paper ``Composable memory transactions'' is a good starting point.
\end{itemize}

% ================================================================================
\section{Oop Support}

At the moment the most significant project in progress is implementing 
support for object-oriented programming in Mythryl per Bernard Berthomeiu's 
March 2000 paper \ahref{\ooprogrammingstylesinml}{{\it OO Programming Styles in ML}}.

I believe having a reasonable OOP story is essential if Mythryl is to 
gain traction with contemporary mainstream programmers, partly because 
they will not take a language seriously that does not have OOP support, 
partly because they will not be able to efficiently transfer their 
existing skills to a language without OOP support --- they have no other 
skills for programming in the large.

There have been a variety of attempts over the years to support object 
oriented programming in ML, ranging from Ocaml to Moby to the ML2000 
proposals.

There is at this point no consensus that OOP even makes 
sense in the ML context.  For example, John Reppy thinks the topic 
worth pursuing, Robert Harper does not.

Among those who think OOP is a sensible fit to ML programming, there 
is no consensus as to how it should be done.  Xavier Leroy's approach 
in Ocaml requires major changes in the typechecking system which 
significantly increase its complexity.  Much the same maybe  said 
of John Reppy's approach in Moby.

My impression is that while mainstream programmers need some flavor 
of OOP to feel comfortable in a programming language, that OOP does 
not need to be particularly sophisticated nor of any particular 
flavor.  A wide variety of OOP approaches may be found among successful 
contemporary mainstream languages, ranging from the simple 
(Perl) to the complex (C++) with mainstream programmers by and large 
seeming largely oblivious to the differences.

It is not clear that experienced Mythryl programmers will use 
OOP heavily once through the transition stage of learning the 
language.  The Ocaml experience is that even when OOP support is 
provided, only about 15\% of programs use it.  In general ML 
module system support satisfies most programming in the large 
requirements;  OOP is mainly needed when late binding is 
required on a large scale.

Consequently, I feel Bernard Berthomeiu's OOP approach is a good fit 
to Mythryl.  It provides basic OOP support, in principle without 
requiring any change to the compiler except syntactic sugar.

I have an initial implementation perhaps half to three quarters complete: 

\begin{itemize}

\item The Mythryl parser has been modified to support syntax for 
declaration of methods and fields.  This involves changes to the 
grammar in \ahrefloc{src/lib/compiler/front/parser/yacc/mythryl.grammar}{src/lib/compiler/front/parser/yacc/mythryl.grammar} 
and to the raw syntax tree representation defined in 
\ahrefloc{src/lib/compiler/front/parser/raw-syntax/raw-syntax.api}{src/lib/compiler/front/parser/raw-syntax/raw-syntax.api}.

\item Code has been (half) written to expand the resulting field 
and method syntax into vanilla raw syntax, treating the OOP 
constructs as derived forms which essentially macro-expand into 
non-OOP code, minimizing added complexity in the rest of the compiler. 
This code lives in  
\ahrefloc{src/lib/compiler/front/typer/main/expand-oop-syntax.api}{src/lib/compiler/front/typer/main/expand-oop-syntax.api} and 
\ahrefloc{src/lib/compiler/front/typer/main/expand-oop-syntax.pkg}{src/lib/compiler/front/typer/main/expand-oop-syntax.pkg} 
with support code in 
\ahrefloc{src/lib/compiler/front/typer/main/expand-oop-syntax-junk.pkg}{src/lib/compiler/front/typer/main/expand-oop-syntax-junk.pkg} and also 
\ahrefloc{src/lib/compiler/front/parser/raw-syntax/map-raw-syntax.api}{src/lib/compiler/front/parser/raw-syntax/map-raw-syntax.api} and 
\ahrefloc{src/lib/compiler/front/parser/raw-syntax/map-raw-syntax.pkg}{src/lib/compiler/front/parser/raw-syntax/map-raw-syntax.pkg}.
Invocation is directly from the grammar rule for {\tt a\_package}.

\end{itemize}

Pushing this project through to completion proved to require more 
changes to the compiler than I had originally hoped.  There are 
two major problems.

The first is that Berthomeiu's approach requires that classes 
be made abstract, which in ML requires {\it strong sealing}, which 
in turn requires synthesizing a complete {\sc API} signature 
for the package defining the class.  This is not reasonable 
when OOP is being implemented as a derived form early in the 
compiler, before type deduction has been performed.

To deal with this problem I implemented a new style of package 
sealing {\it partial sealing} which is like strong sealing 
except that API elements not mentioned are left visible and 
unchanged instead of being hidden. This required changes in:

\begin{itemize}
\item \ahrefloc{src/lib/compiler/front/parser/lex/mythryl.lex}{src/lib/compiler/front/parser/lex/mythryl.lex} to recognize the new ": (partial)" token.
\item \ahrefloc{src/lib/compiler/front/parser/yacc/mythryl.grammar}{src/lib/compiler/front/parser/yacc/mythryl.grammar} to allow the new partial package cast syntax.
\item \ahrefloc{src/lib/compiler/front/parser/raw-syntax/raw-syntax.api}{src/lib/compiler/front/parser/raw-syntax/raw-syntax.api} to represent the new syntax in raw syntax trees.
\item \ahrefloc{src/app/makelib/compilable/raw-syntax-to-module-dependencies-summary.pkg}{src/app/makelib/compilable/raw-syntax-to-module-dependencies-summary.pkg} to preserve existing functionality. (Hope I got that right!)
\item \ahrefloc{src/lib/compiler/front/typer/main/type-package-language-g.pkg}{src/lib/compiler/front/typer/main/type-package-language-g.pkg} to actually implement the new semantics.  
\end{itemize}

A more serious problem is that if the methods of a class are 
to be able to create instances of that class (a frequent 
requirement if, say, combining two objects to produce a third 
in the pure-functional spirit), then the {\tt new} method 
for the class must be mutually recursive with the methods 
for that class.

This is a problem primarily because Berthomeiu's OOP approach 
also requires the methods to be typeagnostic, which requires 
that they be generalized.  {\sc SML/NJ}, at least, does not 
generalize mutually recursive functions.

Berthomeiu's paper passes over this point in silence.

Here is a minimal stimulus exhibiting the problem. 
This program compiles fine:

\begin{verbatim}
package test: api { f: X -> Void; } {

    fun f (x: X) = ();
    fun g () = f 0;
};
\end{verbatim}

but when made mutually recursive it fails to compile:

\begin{verbatim}
package test: api { f: X -> Void; } {

    fun f (x: X) = ()
    also
    fun g () = f 0;
};
\end{verbatim}

(See \ahrefloc{src/app/tut/oop-crib-temp/oop-crib-temp.pkg}{src/app/tut/oop-crib-temp/oop-crib-temp.pkg}.)

Removing this restriction results in changes starting to 
propagate deeper into the compiler.  I do not yet 
understand those parts of the compiler well enough to 
make this work:

\begin{itemize}
\item I added the {\tt generalize\_mutually\_recursive\_functions} tweak to 
      \ahrefloc{src/lib/compiler/front/typer/types/type-core-language-declaration-g.pkg}{src/lib/compiler/front/typer/types/type-core-language-declaration-g.pkg} 
      to get mutually recursive functions to generalize early enough, but this resulted in 
      {\tt translate\_pattern\_expression} in 
      \ahrefloc{src/lib/compiler/back/top/translate/translate-deep-syntax-to-lambdacode.pkg}{src/lib/compiler/back/top/translate/translate-deep-syntax-to-lambdacode.pkg} 
      complaining about variables being pre-{\sc TYPE\_VARIABLE\_MARK}-ed. 
\item After a good deal of code reading I decided that it is probably safe to 
      simply comment out that error trap, but this simply resulted in  
      {\tt LtyDef: {\sc FNTYPE\_TYPEAGNOSTIC} unsupported in ltd\_tyc} from 
      \ahrefloc{src/lib/compiler/back/top/highcode/highcode-type.pkg}{src/lib/compiler/back/top/highcode/highcode-type.pkg}.
\end{itemize}

I do not understand that part of the codebase, so I have suspended this 
line of development until I have time to study it properly.

(2011-06-07 CrT: Robert Harper informs me that most-general-type inference 
                 on mutually recursive functions is mathematically undecidable.)