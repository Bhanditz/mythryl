\index[api]{Microthread\_Preemptive\_Scheduler}
\label{api:Microthread\_Preemptive\_Scheduler}
\input{top-api-Microthread_Preemptive_Scheduler.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {
    foreground_run_queue : rw_queue::Rw_Queue(((Microthread , fate::Fate(Void ))) );
    background_run_queue : rw_queue::Rw_Queue(((Microthread , fate::Fate(Void ))) );
    set_condvar__iu : ?.internal_threadkit_types::Condition_Variable -> Void;
    get_current_microthread : Void -> Microthread;
    set_current_microthread : Microthread -> Void;
    push_into_run_queue : (Microthread , fate::Fate(Void )) -> Void;
        enqueue_old_thread_plus_old_fate_then_install_new_thread :
        {new_thread:Microthread, old_fate:fate::Fate(Void )} -> Void;
    assert_not_in_uninterruptible_scope : String -> Void;
    enter_uninterruptible_scope : Void -> Void;
    exit_uninterruptible_scope : Void -> Void;
    dispatch_next_thread__xu__noreturn : Void -> X;
    dispatch_next_thread__noreturn : Void -> X;
    switch_to_thread__xu : (Microthread , fate::Fate(X ) , X) -> Void;
    yield_to_next_thread__xu : fate::Fate(Void ) -> X;
    run_next_runnable_thread__xu__hook : Ref(fate::Fate(Void ) );
    no_runnable_threads_left__hook : Ref(fate::Fate(Void ) );
    thread_scheduler_shutdown_hook : Ref(fate::Fate(((Bool , Int)) ) );
    get_approximate_time : Void -> time::Time;
    reset_thread_scheduler : Bool -> Void;
    start_thread_scheduler_timer : time::Time -> Void;
    stop_thread_scheduler_timer : Void -> Void;
    restart_thread_scheduler_timer : Void -> Void;
    block_until_inter_hostthread_request_queue_is_nonempty : Void -> Void;
    Do_Echo  = {reply:String -> Void, what:String};
    echo : Do_Echo -> Void;
    do : (Void -> Void) -> Void;
    run_thunk : (Void -> Void) -> Void;
    run_thunks : List((Void -> Void) ) -> Void;
    run_thunk_soon : (Void -> Void) -> Void;
    run_thunk_immediately__iu : (Void -> Void) -> Void;
    inter_hostthread_request_queue_is_empty : Void -> Bool;
    trace_backpatchfn : Ref(((Void -> String) -> Void) );
    get_uninterruptible_scope_nesting_depth : Void -> Int;
    uninterruptible_scope_mutex : Ref(Int );
    alarm_handler_calls : Ref(Int );
    alarm_handler_calls_with__uninterruptible_scope_mutex__set : Ref(Int );
    alarm_handler_calls_with__microthread_switch_lock__set : Ref(Int );
    wake_scheduler_hostthread_if_paused : Void -> Void;
    kill_count : Ref(Int );
    thread_scheduler_statestring : Void -> String;
    print_thread_scheduler_state : Void -> Void;
    print_int : Int -> Int -> Void;
    mutex : hostthread::Mutex;
    condvar : hostthread::Mutex;
    Request  = DO_ECHO Do_Echo | DO_THUNK Void -> Void;
    request_queue : Ref(List(Request ) );};
\end{verbatim}\index[fun]{request\_queue}
\index[fun]{condvar}
\index[fun]{mutex}
\index[fun]{print\_int}
\index[fun]{print\_thread\_scheduler\_state}
\index[fun]{thread\_scheduler\_statestring}
\index[fun]{kill\_count}
\index[fun]{wake\_scheduler\_hostthread\_if\_paused}
\index[fun]{alarm\_handler\_calls\_with\_\_microthread\_switch\_lock\_\_set}
\index[fun]{alarm\_handler\_calls\_with\_\_uninterruptible\_scope\_mutex\_\_set}
\index[fun]{alarm\_handler\_calls}
\index[fun]{uninterruptible\_scope\_mutex}
\index[fun]{get\_uninterruptible\_scope\_nesting\_depth}
\index[fun]{trace\_backpatchfn}
\index[fun]{inter\_hostthread\_request\_queue\_is\_empty}
\index[fun]{run\_thunk\_immediately\_\_iu}
\index[fun]{run\_thunk\_soon}
\index[fun]{run\_thunks}
\index[fun]{run\_thunk}
\index[fun]{do}
\index[fun]{echo}
\index[fun]{block\_until\_inter\_hostthread\_request\_queue\_is\_nonempty}
\index[fun]{restart\_thread\_scheduler\_timer}
\index[fun]{stop\_thread\_scheduler\_timer}
\index[fun]{start\_thread\_scheduler\_timer}
\index[fun]{reset\_thread\_scheduler}
\index[fun]{get\_approximate\_time}
\index[fun]{thread\_scheduler\_shutdown\_hook}
\index[fun]{no\_runnable\_threads\_left\_\_hook}
\index[fun]{run\_next\_runnable\_thread\_\_xu\_\_hook}
\index[fun]{yield\_to\_next\_thread\_\_xu}
\index[fun]{switch\_to\_thread\_\_xu}
\index[fun]{dispatch\_next\_thread\_\_noreturn}
\index[fun]{dispatch\_next\_thread\_\_xu\_\_noreturn}
\index[fun]{exit\_uninterruptible\_scope}
\index[fun]{enter\_uninterruptible\_scope}
\index[fun]{assert\_not\_in\_uninterruptible\_scope}
\index[fun]{enqueue\_old\_thread\_plus\_old\_fate\_then\_install\_new\_thread}
\index[fun]{push\_into\_run\_queue}
\index[fun]{set\_current\_microthread}
\index[fun]{get\_current\_microthread}
\index[fun]{set\_condvar\_\_iu}
\index[fun]{background\_run\_queue}
\index[fun]{foreground\_run\_queue}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
