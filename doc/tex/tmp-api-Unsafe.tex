\index[api]{Unsafe}
\label{api:Unsafe}
\input{top-api-Unsafe.tex}
{\tiny \it The above information is manually maintained and may contain errors.}
\begin{verbatim}
api {   package mythryl_callable_c_library_interface
          : api {
                exception CFUN_NOT_FOUND String;
                find_c_function : {fun_name:String, lib_name:String} -> X -> Y;
                    find_c_function' :
                        {fun_name:String, lib_name:String}
                        ->
                        (Ref((X -> Y) ) , (({fun_name:String, io_call:X -> Y, lib_name:String} -> X -> Y) -> Void));
                    find_c_function'' :
                        {fun_name:String, lib_name:String}
                        ->
                        ((X -> Y) , Ref((X -> Y) ) , (({fun_name:String, io_call:X -> Y, lib_name:String} -> X -> Y) -> Void));
                    find_c_function''' :
                        {fun_name:String, lib_name:String}
                        ->
                        (   (Y -> X) , Ref((Y -> X) ) , (({fun_name:String, io_call:Y -> X, lib_name:String} -> Y -> X) -> Void)
                            , (Y -> Z) , Ref((Y -> Z) ) ,
                            (({fun_name:String, io_call:Y -> X, lib_name:String} -> Y -> Z) -> Void)
                        );
                restore_redirected_syscalls_to_direct_form : Void -> Void;
                System_Constant  = {id:Int, name:String};
                exception SYSTEM_CONSTANT_NOT_FOUND String;
                find_system_constant : (String , List(System_Constant )) -> Null_Or(System_Constant );
                bind_system_constant : (String , List(System_Constant )) -> System_Constant;};;
        package unsafe_chunk
          : api {
                Chunk;
                    Representation
                    = BYTE_RO_VECTOR
                    |
                    BYTE_RW_VECTOR
                    |
                    FLOAT64
                    |
                    FLOAT64_RW_VECTOR
                    |
                    LAZY_SUSPENSION
                    |
                    PAIR
                    |
                    RECORD
                    |
                    REF
                    |
                    TYPEAGNOSTIC_RO_VECTOR
                    |
                    TYPEAGNOSTIC_RW_VECTOR
                    |
                    UNBOXED
                    |
                    UNT1
                    |
                    WEAK_POINTER;
                to_chunk : X -> Chunk;
                make_tuple : List(Chunk ) -> Chunk;
                boxed : Chunk -> Bool;
                unboxed : Chunk -> Bool;
                rep : Chunk -> Representation;
                length : Chunk -> Int;
                exception REPRESENTATION;
                to_tuple : Chunk -> List(Chunk );
                to_string : Chunk -> String;
                to_ref : Chunk -> Ref(Chunk );
                to_rw_vector : Chunk -> Rw_Vector(Chunk );
                to_float64_rw_vector : Chunk -> runtime::asm::Float64_Rw_Vector;
                to_byte_rw_vector : Chunk -> runtime::asm::Unt8_Rw_Vector;
                to_vector : Chunk -> ?.Vector(Chunk );
                to_byte_vector : Chunk -> ?.vector_of_one_byte_unts::Vector;
                to_exn : Chunk -> Exception;
                to_float : Chunk -> Float;
                to_int : Chunk -> Int;
                to_int1 : Chunk -> one_word_int::Int;
                to_unt : Chunk -> Unt;
                to_unt8 : Chunk -> one_byte_unt::Unt;
                to_unt1 : Chunk -> one_word_unt::Unt;
                nth : (Chunk , Int) -> Chunk;};;
        package software_generated_periodic_events
          : api {
                exception BAD_SOFTWARE_GENERATED_PERIODIC_EVENT_INTERVAL;
                software_generated_periodic_events_switch_refcell__global : Ref(Bool );
                    set_software_generated_periodic_event_handler :
                    Null_Or((fate::Fate(Void ) -> fate::Fate(Void )) ) -> Void;
                    get_software_generated_periodic_event_handler :
                    Void -> Null_Or((fate::Fate(Void ) -> fate::Fate(Void )) );
                set_software_generated_periodic_event_interval : Null_Or(Int ) -> Void;
                get_software_generated_periodic_event_interval : Void -> Null_Or(Int );};;
        package vector
          : api {
                get : (?.Vector(X ) , Int) -> X;
                make : (Int , List(X )) -> ?.Vector(X );};;
        package rw_vector
          : api {
                get : (Rw_Vector(X ) , Int) -> X;
                set : (Rw_Vector(X ) , Int , X) -> Void;
                make : (Int , X) -> Rw_Vector(X );};;
        package vector_of_chars
          : api {
                Vector  = Vector;
                Element  = Element;
                get : (Vector , Int) -> Element;
                set : (Vector , Int , Element) -> Void;
                make : Int -> Vector;};;
        package rw_vector_of_chars
          : api {
                Rw_Vector  = Rw_Vector;
                Element  = Element;
                get : (Rw_Vector , Int) -> Element;
                set : (Rw_Vector , Int , Element) -> Void;
                make : Int -> Rw_Vector;};;
        package vector_of_one_byte_unts
          : api {
                Vector  = Vector;
                Element  = Element;
                get : (Vector , Int) -> Element;
                set : (Vector , Int , Element) -> Void;
                make : Int -> Vector;};;
        package rw_vector_of_one_byte_unts
          : api {
                Rw_Vector  = Rw_Vector;
                Element  = Element;
                get : (Rw_Vector , Int) -> Element;
                set : (Rw_Vector , Int , Element) -> Void;
                make : Int -> Rw_Vector;};;
        package rw_vector_of_eight_byte_floats
          : api {
                Rw_Vector  = Rw_Vector;
                Element  = Element;
                get : (Rw_Vector , Int) -> Element;
                set : (Rw_Vector , Int , Element) -> Void;
                make : Int -> Rw_Vector;};;
    get_handler : Void -> fate::Fate(X );
    set_handler : fate::Fate(X ) -> Void;
    get_current_microthread_register : Void -> X;
    set_current_microthread_register : X -> Void;
    get_pseudo : Int -> X;
    set_pseudo : (X , Int) -> Void;
    unpickle_datastructure : vector_of_one_byte_unts::Vector -> X;
    pickle_datastructure : X -> vector_of_one_byte_unts::Vector;
    boxed : X -> Bool;
    cast : X -> Y;
        package p
          : api {   Pervasive_Package_Pickle_List
                      = CONS (vector_of_one_byte_unts::Vector , unsafe_chunk::Chunk , Pervasive_Package_Pickle_List) | NIL;};;
    pervasive_package_pickle_list__global : Ref(p::Pervasive_Package_Pickle_List );
    sigint_fate : Ref(fate::Fate(Void ) );
        posix_interprocess_signal_handler_refcell__global :
        Ref(((Int , Int , fate::Fate(Void )) -> fate::Fate(Void )) );};
\end{verbatim}\index[fun]{posix\_interprocess\_signal\_handler\_refcell\_\_global}
\index[fun]{sigint\_fate}
\index[fun]{pervasive\_package\_pickle\_list\_\_global}
\index[fun]{cast}
\index[fun]{boxed}
\index[fun]{pickle\_datastructure}
\index[fun]{unpickle\_datastructure}
\index[fun]{set\_pseudo}
\index[fun]{get\_pseudo}
\index[fun]{set\_current\_microthread\_register}
\index[fun]{get\_current\_microthread\_register}
\index[fun]{set\_handler}
\index[fun]{get\_handler}
\index[fun]{make}
\index[fun]{set}
\index[fun]{get}
\index[fun]{make}
\index[fun]{set}
\index[fun]{get}
\index[fun]{make}
\index[fun]{set}
\index[fun]{get}
\index[fun]{make}
\index[fun]{set}
\index[fun]{get}
\index[fun]{make}
\index[fun]{set}
\index[fun]{get}
\index[fun]{make}
\index[fun]{set}
\index[fun]{get}
\index[fun]{make}
\index[fun]{get}
\index[fun]{get\_software\_generated\_periodic\_event\_interval}
\index[fun]{set\_software\_generated\_periodic\_event\_interval}
\index[fun]{get\_software\_generated\_periodic\_event\_handler}
\index[fun]{set\_software\_generated\_periodic\_event\_handler}
\index[fun]{software\_generated\_periodic\_events\_switch\_refcell\_\_global}
\index[fun]{nth}
\index[fun]{to\_unt1}
\index[fun]{to\_unt8}
\index[fun]{to\_unt}
\index[fun]{to\_int1}
\index[fun]{to\_int}
\index[fun]{to\_float}
\index[fun]{to\_exn}
\index[fun]{to\_byte\_vector}
\index[fun]{to\_vector}
\index[fun]{to\_byte\_rw\_vector}
\index[fun]{to\_float64\_rw\_vector}
\index[fun]{to\_rw\_vector}
\index[fun]{to\_ref}
\index[fun]{to\_string}
\index[fun]{to\_tuple}
\index[fun]{length}
\index[fun]{rep}
\index[fun]{unboxed}
\index[fun]{boxed}
\index[fun]{make\_tuple}
\index[fun]{to\_chunk}
\index[fun]{bind\_system\_constant}
\index[fun]{find\_system\_constant}
\index[fun]{restore\_redirected\_syscalls\_to\_direct\_form}
\index[fun]{find\_c\_function\_\_prime\_\_\_\_prime\_\_\_\_prime\_\_}
\index[fun]{find\_c\_function\_\_prime\_\_\_\_prime\_\_}
\index[fun]{find\_c\_function\_\_prime\_\_}
\index[fun]{find\_c\_function}
% This file generated by do_symbol_binding  from
%    src/lib/compiler/front/typer-stuff/symbolmapstack/latex-print-symbolmapstack.pkg
