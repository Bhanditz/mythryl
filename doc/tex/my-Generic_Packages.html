<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Generic Packages</TITLE>
</HEAD>
<BODY >
<A HREF="my-Anonymous_APIs.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Packages_and_APIs.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc293">10.11.8</A>  Generic Packages</H3><P>
<A NAME="section:ref:generic-packages"></A></P><P>Often a package must make an arbitrary choice among 
a number of available sumtypes. For example, a 
binary tree needs to know the type of its keys in 
order to keep the tree sorted, but the logic of the 
binary tree does not otherwise depend particularly upon 
the key type. </P><P>In such a case, rather than coding up separate 
versions of the tree for each key type of interest, 
it is more efficient to define a single generic 
package which can then be expanded at compiletime 
to produce the various specialized tree implementations 
needed.</P><P>A generic package is in essence a typed compiletime 
code macro which accepts a package as argument and 
returns a package as result:</P><PRE CLASS="verbatim">
    api  Key {

        Key;

        compare:  (Key, Key) -&gt; Order;
    };

    generic package binary_tree (k: Key) {

        Binary_Tree
            = LEAF
            | NODE { key:   Key,

                     left_kid:  Binary_Tree,
                     right_kid: Binary_Tree
                   }
            ;

        fun make_tree () = ... ;
        fun insert_tree  (tree: Binary_Tree, key: Key) = ... ;
        fun contains_key (tree: Binary_Tree, key: Key) = ... ;
    };

    package tree_of_ints    = binary_tree (Key = int::Int;       compare = int::compare;);
    package tree_of_floats  = binary_tree (Key = float::Float;   compare = float::compare;);
    package tree_of_strings = binary_tree (Key = string::String; compare = string::compare;);
</PRE><P>Here we have defined a single generic package <TT>binary_tree</TT> which 
accepts as argument a package containing <TT>Key</TT>, the type for the 
trees keys, and <TT>compare</TT>, the function which compares two keys to 
see which is greater (or if they are equal). (For expository brevity, 
we have omitted the bodies of the package functions.)</P><P>We have then generated three concrete specializations of this generic 
package, one each for trees with Int, Float and String keys.</P><P>Here the arguments</P><PRE CLASS="verbatim">    (Key = int::Int;       compare = int::compare;)
    (Key = float::Float;   compare = float::compare;)
    (Key = string::String; compare = string::compare;)
</PRE><P>define anonymous packages as arguments for the generic package.</P><P>(This is not a general syntax for defining anonymous packages; 
it works only in this specific syntactic context. A general 
syntax for anonymous packages is to again change the package 
name to an underbar: <TT>package _ { ... }</TT>.)</P><P>For an industrial-strength example of generic packages in action, see 
<A HREF="my-src_lib_src_red-black-set-g_pkg.html#src/lib/src/red-black-set-g.pkg">src/lib/src/red-black-set-g.pkg</A>, <A HREF="my-src_lib_src_string-set_pkg.html#src/lib/src/string-set.pkg">src/lib/src/string-set.pkg</A> and <A HREF="my-src_lib_src_string-key_pkg.html#src/lib/src/string-key.pkg">src/lib/src/string-key.pkg</A>.</P>
<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Anonymous_APIs.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-Packages_and_APIs.html"><IMG SRC="contents_motif.gif" ALT="Up"></A></BODY>
</HTML>
