<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Mythryl Functions: Beyond Parameter Lists</TITLE>
</HEAD>
<BODY >
<A HREF="my-Preface-4.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Functions__Implicit_Case_Statements.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc87">5.4.2</A>  Mythryl Functions: Beyond Parameter Lists</H3><P>To date we have been fostering the illusion that Mythryl functions are much 
like functions in C or Perl, give or take the occasional syntactic oddity 
or feature.</P><P>In this section we draw aside the veil.</P><P>C functions are hardwired by the compiler to accept a 
comma-delimited sequence of parameters. The C grammar specifies exactly 
what that parameter sequence may contain; the C compiler translates 
directly from ordinal position within the parameter sequence to ordinal 
position within a stackframe. As far as the C compiler is concerned, a 
function parameter list declaration is essentially an abstract specification 
of part of a function call stackframe.</P><P>The Mythryl compiler doesn&#X2019;t see function syntax that way at all.</P><P>To start with, the Mythryl compiler does not think of functions as having 
multiple parameters matching multiple arguments. So far as the Mythryl 
compiler is concerned, every Mythryl function takes exactly one value 
as input and returns exactly one value as result. (This turns out to make 
the compiler much simpler to write!)</P><P>What we have been presenting as a conventional function argument list,
the Mythryl compiler has all along been thinking of as <I>a single tuple 
argument</I>.</P><P>At first blush this may appear to be a purely philosophical distinction about 
as important to today&#X2019;s practicing programmer as is the distinction between 
<A HREF="http://en.wikipedia.org/wiki/Homoiousian">Homoiousian</A> and <A HREF="http://en.wikipedia.org/wiki/Homoousian">Homoousian</A> to today&#X2019;s practicing Christian. (There was a time when confusing the two 
could get you killed!)</P><P>In fact, there is a world of difference between the two ways of thinking 
about the matter, and until you begin thinking about it the Mythryl way, 
you are not writing Mythryl at all, really, but rather writing C 
in Mythryl syntax.</P><P>Let us start with a simple example. The fact that the Mythryl &#X201C;argument lists&#X201D; 
we have been writing are in fact tuple arguments means that we can construct 
such &#X201C;argument lists&#X201D; ahead of time, pass them around, and even store them 
in other datastructures, before finally applying the function to them. Do not 
try any of these examples in C!</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    fun confess (name, condition) = {
        printf "Hello!  My name is %s and I am %s.\n"  name  condition;
    };

    confess( "Linus", "an open source programmer" );

    a = ( "Richard", "a free software author" );

    confess a;

    b = [ ( "Albert", "a physicist" ),
          ( "Karl",   "a mathematician" )
        ];

    map confess b;
</PRE><P>When run this produces</P><PRE CLASS="verbatim">    linux$ ./my-script
    Hello!  My name is Linus and I am an open source programmer.
    Hello!  My name is Richard and I am a free software author.
    Hello!  My name is Albert and I am a physicist.
    Hello!  My name is Karl and I am a mathematician.
    linux$ 
</PRE><P>So already we can begin to see that this fresh way of thinking about functions 
is opening up fresh expressive possibilities for coding.</P><P>Now let us open up the world of possibilities a bit more.</P><P>The Mythryl compiler does not think of functions as accepting a single 
<I>tuple</I> as argument. That is not what we said above. The Mythryl 
compiler thinks of functions as accepting a single <I>value</I> as argument. 
Any type of of value will do.</P><P>In particular, the argument value handed to a function can just as easily 
be a record as a tuple. The Mythryl compiler hardly distinguishes between 
the two anyhow; to it a record is just a tuple with a teeny bit of extra 
icing on top.</P><P>This essentially means that we get functions with keyword arguments 
&#X201C;for free&#X201D; in Mythryl, where some other languages devote just a 
remarkable amount of special-case jiggery-pokery logic in the compiler 
to implementing them:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    fun confess { name, condition } = {
        printf "Hello!  My name is %s and I am %s.\n"  name  condition;
    };

    confess { name =&gt; "Linus", condition =&gt; "an open source programmer" };

    a = { name =&gt; "Richard", condition =&gt; "a free software author" };

    confess a;

    b = [ { name =&gt; "Albert", condition =&gt; "a physicist" },
          { name =&gt;  "Karl", condition =&gt; "a mathematician" }
        ];

    map confess b;
</PRE><P>When run, this produces exactly the same results as the first script, and 
in fact may well compile into exactly the same binary code, but the 
readability impact is significant. In particular, the intent behind 
the list of records is immediately much clearer to the reader than is that 
behind the earlier list of tuples.</P><P>Record arguments are particularly nice when a function has two 
arguments of the same type which might easily be confused.</P><P>For example when copying from one vector to another (say), 
the programming world has no consistent convention as to 
whether the destination should come first or second. It 
is easy to get them backwards, and the result is an error 
which will not be caught at compiletime and which might 
take some time to track down at runtime.</P><P>Using record instead of tuple arguments can make the code 
clearer and reduce the risk of introducing errors during 
code maintenance:</P><PRE CLASS="verbatim">    copy (        this_vector,        that_vector );    # Potentially confusing
    copy { src =&gt; this_vector, dst =&gt; that_vector };    # Much clearer.
</PRE>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Preface-4.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Full_Monte.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Mythryl_Functions__Implicit_Case_Statements.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
