<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<LINK REL=STYLESHEET type="text/css" HREF="local.css">
<LINK rel="stylesheet" type="text/css" href="book.css">
<TITLE>Lists and Strings</TITLE>
</HEAD>
<BODY >
<A HREF="my-Defining_functions.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Bare_Essentials.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Packages.html"><IMG SRC="next_motif.gif" ALT="Next"></A><HR>
<H3 CLASS="subsection"><A NAME="htoc58">5.2.9</A>  Lists and Strings</H3><P>Mythryl strings are a bit like C strings, but a lot more like Perl or 
Python strings.</P><P>Mythryl strings are a first-class type with a 
variety of predefined operations:</P><PRE CLASS="verbatim">    linux$ my

    eval:  "abc" + "def";

    "abcdef"

    eval:  toupper("abc");

    "ABC"

    eval:  tolower("ABC");

    "abc"

    eval:  ^D
    linux$
</PRE><P>Mythryl lists are a teeny bit like those of Perl and a lot more like those of 
Python, Lisp or Ruby. Lists are one of the conveniences which make programming 
in Mythryl much more pleasant that programming in C for many common sorts of 
tasks. Lists are one of the Mythryl programmer&#X2019;s favorite datastructures. 
Any time you have an indeterminate number of similar things which you need 
to keep track of, you usually just throw them in a list. </P><P>Mythryl lists are written with square brackets. You need to put blanks around 
them to keep the Mythryl compiler from confusing them with arrays.</P><P>Useful operations on lists include <TT>@</TT> which concatenates two lists to 
form a single list, <TT>strcat</TT> which concatenates a list of strings to 
produce a single string, and <TT>reverse</TT> which reverses a list:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    a = ["abc", "def", "ghi"];
    b = ["jkl", "mno", "pqr"];

    printf "strcat a     == '%s'\n"  (strcat(a));
    printf "strcat b     == '%s'\n"  (strcat(b));
    printf "strcat a@b   == '%s'\n"  (strcat(a @ b ));
    printf "strcat( reverse(a) ) == '%s'\n"  (strcat(reverse(a)));
    printf "strcat( reverse(a@b) ) == '%s'\n"  (strcat(reverse(a@b)));
</PRE><P>When run the above produces:</P><PRE CLASS="verbatim">    linux$ ./my-script
    strcat a     == 'abcdefghi'
    strcat b     == 'jklmnopqr'
    strcat a@b   == 'abcdefghijklmnopqr'
    strcat( reverse(a) ) == 'ghidefabc'
    strcat( reverse(a@b) ) == 'pqrmnojklghidefabc'
    linux$
</PRE><P>The <TT>map</TT> function applies a given function to all elements of a 
list and returns a list of the results. It is one of the most 
frequently used Mythryl functions:</P><PRE CLASS="verbatim">    linux$ my

    eval:  map toupper ["abc", "def", "ghi"];

    ["ABC", "DEF", "GHI"]

    eval:  ^D
    linux$
</PRE><P>The <TT>apply</TT> function is just like the <TT>map</TT> function except that 
it constructs no return list &#X2014; the supplied function is applied only 
for side-effects:</P><PRE CLASS="verbatim">    #!/usr/bin/mythryl

    apply print ["abc\n", "def\n", "ghi\n"];
</PRE><P>When run the above produces:</P><PRE CLASS="verbatim">    linux$ ./my-script
    abc
    def
    ghi
    linux$
</PRE><P>The Mythryl <TT>head</TT> and <TT>tail</TT> functions return the first 
element of a list and the rest of the list. They correspond to Lisp <TT>car</TT> 
and <TT>cdr</TT>. The Mythryl infix operator &#X2019;!&#X2019; prepends a new element to a 
list, returning a new list. It corresponds to the Lisp <TT>cons</TT> function:</P><PRE CLASS="verbatim">    linux$ my

    eval:  a = [ "abc", "def", "ghi" ];

    ["abc", "def", "ghi"]

    eval:  head(a);

    "abc"

    eval:  tail(a);

    ["def", "ghi"]

    eval:  "abc" ! ["def", "ghi"];

    ["abc", "def", "ghi"]

    eval:  ^D
    linux$ 
</PRE><P>The Mythryl <TT>explode</TT> and <TT>implode</TT> functions convert 
between strings and lists of characters:</P><PRE CLASS="verbatim">    linux$ my

    eval:  explode("abcdef");

    ['a', 'b', 'c', 'd', 'e', 'f']

    eval:  implode( ['a', 'b', 'c', 'd', 'e', 'f'] );

    "abcdef"

    eval:  implode( reverse( explode( "abcdef" ) ) );

    "fedcba"

    eval:  ^D

    linux$
</PRE><P>The <TT>strsort</TT> function sorts a list of strings, and 
<TT>struniqsort</TT> does the same while dropping duplicates. 
The <TT>shuffle</TT> function re-arranges the list elements 
into a pseudo-random order:</P><PRE CLASS="verbatim">    linux$ my

    eval:  strsort( ["def", "abc", "ghi", "def", "abc", "ghi"] );

    ["abc", "abc", "def", "def", "ghi", "ghi"]

    eval:  struniqsort( ["def", "abc", "ghi", "def", "abc", "ghi"] );

    ["abc", "def", "ghi"]

    eval:  shuffle( ["abc", "def", "ghi", "jkl", "mno"] );

    ["ghi", "def", "abc", "jkl", "mno"]

    eval:  ^D
    linux$
</PRE><P>The <TT>length</TT> function counts the number of elements in 
a list; the <TT>strlen</TT> function counts the number of 
characters in a string:</P><PRE CLASS="verbatim">    linux$ my

    eval:  length( ["abc", "def", "ghi"] );

    3

    eval:  strlen( "abcdefghi" );

    9

    eval:  ^D

    linux$
</PRE>

<HR SIZE=2>
<DIV CLASS="center">
<FONT SIZE=1>Comments and suggestions to: </FONT><A HREF="mailto:bugs@mythryl.org"><FONT SIZE=1>bugs@mythryl.org</FONT></A></DIV>
<HR>
<A HREF="my-Defining_functions.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A><A HREF="my-The_Bare_Essentials.html"><IMG SRC="contents_motif.gif" ALT="Up"></A><A HREF="my-Packages.html"><IMG SRC="next_motif.gif" ALT="Next"></A></BODY>
</HTML>
