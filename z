#!/usr/bin/mythryl

foo = REF 0;
bar = REF 0;

mutex = pthread::make_mutex ();
pthread::set_up_mutex (mutex, NULL);

barrier = pthread::make_barrier ();
pthread::set_up_barrier { barrier, threads => 3 };

fun subthread_fn ()
    =
    {
	if (pthread::wait_on_barrier barrier)		# Exactly one pthread waiting on barrier should see a TRUE return value.
	    #
	    pthread::acquire_mutex mutex;
		#
		foo := *foo + 1;
		bar := *bar + 1;
		#
	    pthread::release_mutex mutex;
	else
	    pthread::acquire_mutex mutex;
		#
		foo := *foo + 1;
		#
	    pthread::release_mutex mutex;
	fi; 
	#
	pthread::pthread_exit ();
    };

subthread1 = pthread::spawn_pthread  subthread_fn;
subthread2 = pthread::spawn_pthread  subthread_fn;
subthread3 = pthread::spawn_pthread  subthread_fn;


pthread::join_pthread subthread1;
pthread::join_pthread subthread2;
pthread::join_pthread subthread3;

pthread::clear_barrier   barrier;

printf "*foo d=%d\n" *foo;
printf "*bar d=%d\n" *bar;

pthread::free_mutex mutex;
pthread::free_barrier barrier;






# mutex = pthread::make_mutex ();
# pthread::set_up_mutex (mutex, NULL);
# 
# fun subthread_fn ()
#     =
#     {   if ((pthread::try_mutex mutex) == pthread::ACQUIRED_MUTEX) print "Worked!\n";	pthread::release_mutex mutex;
#         else							   print "Failed!\n";
# 	fi;
# 
# 	#
# 	pthread::pthread_exit ();
#     };
# 
# pthread = pthread::spawn_pthread  subthread_fn;
# 
# 
# pthread::join_pthread pthread;




