// posix-signals.c
//
// Compute the signal table information for UNIX systems.  This is used to
// generate the posix-signal-table--autogenerated.c file and the system-signals--autogenerated.h file.
//
// We also define the pseudo-signals HEAPCLEANING_DONE and THREAD_SCHEDULER_TIMESLICE
// which Mythryl-level code can register handlers for just like real signals.
//
// For the actual C-level signal handler and related Mythryl/C signal support code see
//
//     src/c/machine-dependent/posix-signal.c 

#include "../mythryl-config.h"

#include "system-dependent-unix-stuff.h"
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include "header-file-autogeneration-stuff.h"
#include "generate-system-signals.h-for-posix-systems.h"


#define UNSUPPORTED_SIGNAL 0

#ifndef SIGALRM
#define SIGALRM   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGABRT									// We favor "SIGABRT" over "SIGIOT" because the former has 10X more Google hits.
#ifdef  SIGIOT
#define SIGABRT   SIGIOT
#else
#define SIGABRT   UNSUPPORTED_SIGNAL
#endif
#endif

#ifndef SIGBUS
#define SIGBUS    UNSUPPORTED_SIGNAL
#endif

#ifndef SIGCHLD
#ifdef  SIGCLD
#define SIGCHLD   SIGCLD
#else
#define SIGCHLD   UNSUPPORTED_SIGNAL
#endif
#endif

#ifndef SIGCONT
#define SIGCONT   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGHUP
#define SIGHUP    UNSUPPORTED_SIGNAL
#endif

#ifndef SIGILL
#define SIGILL    UNSUPPORTED_SIGNAL
#endif

#ifndef SIGINT
#define SIGINT    UNSUPPORTED_SIGNAL
#endif

#ifndef SIGIO								// "SIGIO" has 10X more Google hits than "SIGPOLL".
#ifdef  SIGPOLL
#define SIGIO     SIGPOLL
#else
#define SIGIO     UNSUPPORTED_SIGNAL
#endif
#endif

#ifndef SIGKILL
#define SIGKILL   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGPIPE
#define SIGPIPE   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGPROF
#define SIGPROF   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGPWF
#define SIGPWF    UNSUPPORTED_SIGNAL
#endif

#ifndef SIGQUIT
#define SIGPQUIT  UNSUPPORTED_SIGNAL
#endif

#ifndef SIGSTKFLT
#define SIGSTKFLT UNSUPPORTED_SIGNAL
#endif

#ifndef SIGSTOP
#define SIGSTOP   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGSYS
#define SIGSYS    UNSUPPORTED_SIGNAL
#endif

#ifndef SIGTERM
#define SIGTERM   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGTRAP
#define SIGTRAP   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGTSTP
#define SIGTSTP   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGTTIN
#define SIGTTIN   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGTTOU
#define SIGTTOU   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGURG
#define SIGURG    UNSUPPORTED_SIGNAL
#endif

#ifndef SIGUSR1
#define SIGUSR1   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGUSR2
#define SIGUSR2   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGVTALRM
#define SIGVTALRM UNSUPPORTED_SIGNAL
#endif

#ifndef SIGWINCH							// "SIGWINCH" gets 10X more Google hits than "SIGWINDOW".
#ifdef  SIGWINDOW
#define SIGWINCH  SIGWINDOW
#else
#define SIGWINCH  UNSUPPORTED_SIGNAL
#endif
#endif

#ifndef SIGXCPU
#define SIGXCPU   UNSUPPORTED_SIGNAL
#endif

#ifndef SIGXFSZ
#define SIGXFSZ  UNSUPPORTED_SIGNAL
#endif

//////////////////////////////////////////////
// The POSIX/ANSI/BSD/Linux signals we support.
//
// The intention here is that we use the row
// number in the following table as the stable
// Mythryl-side name for a signal, to make the
// Mythryl-side world signal naming independent
// of the particular int signal names used by
// the current host OS kernel, and indeed
// independent of whether they are supported
// by the current kernel.
//
// To that end, it is probably best that any signals
// added to this table GO AT THE END, rather than
// in alphabetical order.
//										// signal_table__local is used in this file and also in   src/c/machine-dependent/posix-signal.c
static Signal_Descriptor   signal_table__local[]   = {				// Signal_Descriptor	is from   src/c/config/generate-system-signals.h-for-posix-systems.h
    //                     ====================
    //
    { SIGALRM,	"SIGALRM",	"ALARM"},	// POSIX		// Alarm.  See also SIGVTALRM.
    { SIGABRT,	"SIGABRT",	"ABRT"},	// ANSI			// Abort.     On Linux == BSD4.2 SIGIOT.
    { SIGBUS,	"SIGBUS",	"BUS"},		// BSD 4.2		// BUS error.
    { SIGCHLD,	"SIGCHLD",	"CHLD"},	// POSIX		// Child status has changed.
    { SIGCONT,	"SIGCONT",	"CONT"},	// POSIX		// Continue.


    // For some reason uncommenting this and recompiling produces
    //     *** Internal error:  No signal_table entry for signal 8 ***
    // from
    //     src/lib/std/src/nj/runtime-signals-guts.pkg
    //
    // (See also SIGSEGV below.)
    //
    // I've got other fish to fry at the moment,
    // so I'm just leaving it commented out.
    //
    // It may actually make sense to not have these two here, since
    // their handling is probably hardwired at the C level (which
    // probably relates to the above problem.)
    //            -- 2012-12-08 CrT
    //
    // #ifdef SIGFPE
    //	{ SIGFPE,	"SIGFPE",	"FPE"},		// ANSI			// Floating-point exception.
    // #endif


    { SIGHUP,	"SIGHUP",	"HUP"},			// POSIX		// Hangup.
    { SIGILL,	"SIGILL",	"ILL"},			// ANSI			// Illegal instruction
    { SIGINT,	"SIGINT",	"INTERRUPT"},		// ANSI			// Interrupt.
    { SIGIO,	"SIGIO",	"IO"},			// BSD4.2		// I/O now possible.

    // SIGIOT:  See SIGABRT.

    { SIGKILL,	"SIGKILL",	"KILL"},		// POSIX		// Kill, unblockable.
    { SIGPIPE,	"SIGPIPE",	"PIPE"},		// POSIX		// Broken pipe.
    { SIGPROF,	"SIGPROF",	"PROF"},		// BSD 4.2		// Profiling alarm clock.
    { SIGPWR,	"SIGPWR",	"PWR"},			// SYS V		// Power failure restart.
    { SIGQUIT,	"SIGQUIT",	"QUIT"},		// POSIX		// Quit.



    // For some reason uncommenting this and recompiling produces
    //     *** Internal error:  No signal_table entry for signal 11 ***
    // from
    //     src/lib/std/src/nj/runtime-signals-guts.pkg
    //
    // (See also SIGFPE above.)
    //
    // I've got other fish to fry at the moment,
    // so I'm just leaving it commented out.
    //
    // It may actually make sense to not have these two here, since
    // their handling is probably hardwired at the C level (which
    // probably relates to the above problem.)
    //            -- 2012-12-08 CrT
    //
    // #ifdef SIGSEGV
    //	{ SIGSEGV,	"SIGSEGV",	"SEGV"},	// ANSI			// Segmentation violation. (Typically due to use of an invalid C pointer.)
    // #endif


    { SIGSTKFLT, "SIGSTKFLT",	"STKFLT"},		// Linux		// Stack fault.



    { SIGSTOP,	"SIGSTOP",	"STOP"},		// POSIX		// Stop, unblockable.
    { SIGSYS,	"SIGSYS",	"SYS"},			// Linux		// Bad system call.
    { SIGTERM,	"SIGTERM",	"TERMINATE"},		// POSIX		// Polite (catchable) request to terminate. http://en.wikipedia.org/wiki/SIGTERM
    { SIGTRAP,	"SIGTRAP",	"TRAP"},		// POSIX		// Trace trap
    { SIGTSTP,	"SIGTSTP",	"TSTP"},		// POSIX		// Keyboard stop.
    { SIGTTIN,	"SIGTTIN",	"TTIN"},		// POSIX		// Background read from TTY.
    { SIGTTOU,	"SIGTTOU",	"TTOU"},		// POSIX		// Backround write to TTY.
    { SIGURG,	"SIGURG",	"URG"},			// BSD 4.2		// Urgent condition on socket.
    { SIGUSR1,	"SIGUSR1",	"USR1"},		// POSIX		// User-defined signal 1.
    { SIGUSR2,	"SIGUSR2",	"USR2"},		// POSIX		// User-defined signal 2.
    { SIGVTALRM, "SIGVTALRM",	"VTALRM"},		// BSD 4.2		// Alarm.  See also SIGALRM.
    { SIGWINCH,	"SIGWINCH",	"WINCH"},		// BSD 4.3		// Window size change.
    { SIGXCPU,	"SIGXCPU",	"XCPU"},		// BSD 4.2		// CPU limit exceeded.
    { SIGXFSZ,	"SIGXFSZ",	"XFSZ"},		// BSD 4.2		// File size limit exceeded.
};
#define SIGNAL_TABLE_SIZE_IN_SLOTS	(sizeof(signal_table__local) / sizeof(Signal_Descriptor))




Runtime_System_Signal_Table*   sort_runtime_system_signal_table   () {					// Called from   src/c/config/generate-system-signals.h-for-posix-systems.c
    //                         ================================						// Called from   src/c/config/generate-posix-signal-table-c.c
    //
    Signal_Descriptor**  signals =   MALLOC_VEC( Signal_Descriptor*, SIGNAL_TABLE_SIZE_IN_SLOTS );

    // Insertion-sort the signal table by increasing signal number.
    // If there are duplicate definitions of a sig value
    // the first is kept and the rest are dropped.
    // We need this because some systems alias signals.
    //
    int n = 0;
    for (int i = 0;  i < SIGNAL_TABLE_SIZE_IN_SLOTS;  i++) {
	//
        // Invariant: signals[0..n-1] is sorted
        //
	Signal_Descriptor* p =  &signal_table__local[ i ];

	int  j;
	for (j = 0;  j < n;  j++) {
	    //
	    if (signals[j]->kernel_id_for_signal == p->kernel_id_for_signal)		break;	      // A duplicate -- drop it.

	    if (signals[j]->kernel_id_for_signal > p->kernel_id_for_signal) {
	        //
                // Insert the signal at position j:
                //
		for (int k = n;  k >= j;  k--)   signals[k] = signals[k-1];
		//
		signals[j] = p;
		n++;
		break;
	    }
	}
	if (j == n) {
	    signals[n++] = p;
	}
    }

    // At this point 'n' is the number of system signals and
    // signals[n-1]->sig is the largest system signal code.
    //


    Runtime_System_Signal_Table*  signal_db
	=
	MALLOC_CHUNK( Runtime_System_Signal_Table );

    signal_db->sigs	= signals;
    signal_db->posix_signal_kinds	= n;
    signal_db->lowest_valid_posix_signal_number	= signals[0]->kernel_id_for_signal;
    signal_db->highest_valid_posix_signal_number= signals[n-1]->kernel_id_for_signal;

    return signal_db;

}


// COPYRIGHT (c) 1995 by AT&T Bell Laboratories.
// Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
// released under Gnu Public Licence version 3.


