// make-package-literals-via-bytecode-interpreter.c

//////////////////////////////////////////////////////////////////////////////////////////////
// APPARENT SEGFAULT BUG -- 2012-01-02 CrT
//
// Mythryl segfaults every now and then while "linking" and this module
// appears to be the reason.  What appears to be happening is that the
// logic here assumes that
//    (1) Every heapcleaner call leaves at least 64KB free in gen0.
//    (2) Strings are never bigger than 64K.
// From examining the logging currently enabled, it appears that heapcleaning
// leaves more like 8KB free in gen0, and that some strings are in fact bigger
// than 64KB.
//    [ Later (2012-01-31):  From a careful reading of  src/c/heapcleaner/heapclean-agegroup0.c
//      it is clear that a minor heapclean will necessarily always leave agegroup0 completely
//      empty -- meaning circa 256KB free -- so I need to investigate why it appears to leave
//      8K or so sometimes.  Prosumably broken reporting.
//    ]
// We have a fn   check_agegroup0_overrun_tripwire_buffer      in   src/c/heapcleaner/heap-debug-stuff.c
// We have a fn   partition_agegroup0_buffer_between_pthreads  in   src/c/heapcleaner/pthread-heapcleaner-stuff.c
// To add flavor to the mix:
//    *  In src/c/heapcleaner/make-strings-and-vectors-etc.c
//       we seem to make a point of never allocating more than MAX_AGEGROUP0_ALLOCATION_SIZE_IN_WORDS
//       words in gen0, but in this file we appear to make no such effort.
//    *  Doing a two-generation heapcleaning should resolve the problem, but
//       in fact segfaults us -- search for [XYZZY].
//////////////////////////////////////////////////////////////////////////////////////////////


// Problem
// =======
//
// When we generate a
//
//     foo.pkg.compiled
//
// file, we must somehow preserve foo.pkg's various
// literals and values -- which may include lists, records,
// tuples, trees etc -- on disk in a form allowing reconstitution
// when foo.pkg.compiled is later loaded into a running process.
//
// Solution
// ========
//
// We represent the literals as a bytecode program which
// when executed constructs the required values.  That is
// the job of the
//
//     Val   make_package_literals_via_bytecode_interpreter   (Task* task,   Unt8* bytecode_vector,   int bytecode_vector_bytesize)
//
// function in this file.  Our
//
//    bytecode_vector
//    bytecode_vector_bytesize
//
// arguments give the bytecode vector to execute,
// which was generated in
//
//     src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg

#include "../mythryl-config.h"

#include <string.h>

#include "runtime-configuration.h"
#include "runtime-base.h"
#include "make-strings-and-vectors-etc.h"
#include "heap.h"

// Codes for literal machine instructions (version 1):
//   INT(i)		0x01 <i>
//   RAW32[i]		0x02 <i>
//   RAW32[i1,..,in]	0x03 <n> <i1> ... <in>
//   RAW64[r]		0x04 <r>
//   RAW64[r1,..,rn]	0x05 <n> <r1> ... <rn>
//   STR[c1,..,cn]	0x06 <n> <c1> ... <cn>
//   LIT(k)		0x07 <k>			// Dup k-th element on stack.
//   VECTOR(n)		0x08 <n>			// Push vector containing n elements popped from stack.
//   RECORD(n)		0x09 <n>			// Push record containing n elements popped from stack.
//   RETURN		0xff				// Return top-of-stack value.
//
//
// These MUST be kept in sync with the bytecode generation logic in
//
//     src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg
//
#define V1_MAGIC	0x19981022							// Generated by put_magic	in    src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg
#define MAKE_TAGGED_INT		0x01								// Generated by put_int		in    src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg
//
#define I_RAW32		0x02								// Generated by put_raw32	in    src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg
#define I_RAW32L	0x03	// "L" == "List"					// Generated by put_raw32	in    src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg
//
#define I_RAW64		0x04								// Generated by put_raw64	in    src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg
#define I_RAW64L	0x05	// "L" == "List"					// Generated by put_raw64	in    src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg
//
#define I_STR		0x06    // "STR" == "String"					// Generated by put_string	in    src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg
#define I_LIT		0x07	// "LIT" == "Literal"					// Generated by put_lit		in    src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg
//
#define I_VECTOR	0x08								// Generated by put_vector	in    src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg
#define I_RECORD	0x09								// Generated by put_record	in    src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg
//
#define I_RETURN	0xff								// Generated by put_return	in    src/lib/compiler/back/top/main/make-nextcode-literals-bytecode-vector.pkg



// Fetch a 32-bit int from address 'p' in big-endian order:				// 64-bit issue.
// 
#define GET32(p,pc)	\
    ( (p[pc+0] << 24)	\
    | (p[pc+1] << 16)	\
    | (p[pc+2] <<  8)	\
    | (p[pc+3] <<  0)	\
    )

#define LIST_CONS_CELL_BYTESIZE	(WORD_BYTESIZE*3)		// Size of a list cons cell in bytes.



static double   get_double   (Unt8* p)   {
    //          ==========
    //
    union {
	double	d;
	Unt8	b[ sizeof( double ) ];
    } u;

    #ifdef BYTE_ORDER_LITTLE
	//
	for (int i = sizeof(double);   i --> 0;  ) {
	    //
	    u.b[i] =  *p++;
	}
    #else
	for (int i = 0;   i < sizeof(double);   i++) {
	    //
	    u.b[i] = p[i];
	}
    #endif

    return u.d;
}

static int   ensure_sufficient_space__may_heapclean   (Task* task,  int bytes_needed,  int free_bytes,  Roots* extra_roots)   {
    //       ======================================
    //
    // Check that sufficient space is available for the
    // literal chunk that we are about to allocate.
    // Note that the cons cell has already been accounted
    // for in bytes_free but not in bytes_needed.
    //
    if (bytes_needed > free_bytes
    &&  need_to_call_heapcleaner( task, bytes_needed + LIST_CONS_CELL_BYTESIZE)
    ){
										log_if("ensure_sufficient_space__may_heapclean calling heapcleaner <---------------------------------");
	call_heapcleaner_with_extra_roots (task, 1, extra_roots );

	free_bytes = 0;

    } else {

	free_bytes -= bytes_needed;
    }

    return free_bytes;
}



Val   make_package_literals_via_bytecode_interpreter__may_heapclean   (Task* task,   Unt8* bytecode_vector,   int bytecode_vector_bytesize,  Roots* extra_roots)   {
    //=============================================================
    //
    // bytecode_vector is a Mythryl-heap vector datachunk cast to Unt8*.
    //
    // NOTE: We allocate all of the chunks in agegroup 1,
    // but allocate the vector of literals in agegroup0.
    //
    // We get called at the C level in
    //
    //    src/c/main/load-compiledfiles.c
    //
    // This fn gets exported to the Mythryl level as
    //
    //     make_package_literals_via_bytecode_interpreter
    // in
    //     src/lib/compiler/execution/code-segments/code-segment.pkg
    // via
    //     src/c/lib/heap/libmythryl-heap.c
    //
    // Our ultimate Mythryl-level invocation is in
    //
    //     src/lib/compiler/execution/main/link-and-run-package.pkg

    Val	stack = HEAP_NIL;

    Roots roots1 = { (Val*)&bytecode_vector, extra_roots };
    Roots roots2 = { &stack,                &roots1	 };

								do_debug_logging =  TRUE;
								check_agegroup0_overrun_tripwire_buffer( task, "make_package_literals_via_bytecode_interpreter__may_heapclean/AAA" );


    int pc = 0;								// 'pc' will be our 'program counter' offset into bytecode_vector.


    if (bytecode_vector_bytesize <= 8)   return HEAP_NIL;		// bytecode_vector has an 8-byte header, so length <= 8 means nothing to do.

    Val_Sized_Unt  magic
	=
	GET32(bytecode_vector,pc);   pc += 4;

    Val_Sized_Unt  max_depth						/* This variable is currently unused, so suppress 'unused var' compiler warning: */   		__attribute__((unused))
	=
	GET32(bytecode_vector,pc);   pc += 4;

    if (magic != V1_MAGIC)   die("bogus literal magic number %#x", magic);


    int free_bytes = 0;							// Free bytes in our agegroup0 buffer. This is a known-lower-limit, not an exact number.


Val_Sized_Int* tripwirebuf = (Val_Sized_Int*) (((char*)(task->real_heap_allocation_limit)) + MIN_FREE_BYTES_IN_AGEGROUP0_BUFFER);

    // Uncommenting this seems to segfault us?!

    for (;;) {
	//
	ASSERT(pc < bytecode_vector_bytesize);

	free_bytes -= LIST_CONS_CELL_BYTESIZE;	// Space for stack cons cell.

	if (free_bytes < ONE_K_BINARY) {
	    //
	    if (need_to_call_heapcleaner(task, 64*ONE_K_BINARY)) {
		//
		{   Roots roots1 = { (Val*)&bytecode_vector, extra_roots  };
		    Roots roots2 = { &stack,                 &roots1	  };
		    //
		    call_heapcleaner_with_extra_roots (task, 1, &roots2 );
		}
            }

	    free_bytes = 64*ONE_K_BINARY;
	}


if (tripwirebuf[0] != 0) log_if("luptop TRIPWIRE BUFFER TRASHED!");

	switch (bytecode_vector[ pc++ ]) {
	    //
	case MAKE_TAGGED_INT:										// Make 31-bit in-pointer int on 32-bit machines, 63-bit in-pointer in on 64-bit machines.
	    {
		int i = GET32(bytecode_vector,pc);	pc += 4;					// 64-bit issue.

		stack = LIST_CONS(task, TAGGED_INT_FROM_C_INT(i), stack);				// LIST_CONST		is from   src/c/h/make-strings-and-vectors-etc.h
	    }
	    break;

	case I_RAW32:
	    {
		int i = GET32(bytecode_vector,pc);	pc += 4;					// 64-bit issue.

		Val result =  make_one_word_int(task, i );

		stack = LIST_CONS(task, result, stack);
		free_bytes -= 2*WORD_BYTESIZE;
	    }
	    break;

	case I_RAW32L:
	    {
		int n = GET32(bytecode_vector,pc);	pc += 4;					// 64-bit issue.

		ASSERT(n > 0);

		int free_bytes_needed = 4*(n+1);									// 64-bit issue.
		free_bytes = ensure_sufficient_space__may_heapclean(task, free_bytes_needed, free_bytes, &roots2);

		set_slot_in_nascent_heapchunk (task, 0, MAKE_TAGWORD(n, FOUR_BYTE_ALIGNED_NONPOINTER_DATA_BTAG));

		for (int j = 1;  j <= n;  j++) {
		    //
		    int i = GET32(bytecode_vector,pc);	pc += 4;							// 64-bit issue.

		    set_slot_in_nascent_heapchunk (task, j, (Val)i);
		}

		Val result =  commit_nascent_heapchunk(task, n );

		stack = LIST_CONS(task, result, stack);
	    }
	    break;

	case I_RAW64:
	    {
		double d = get_double(&(bytecode_vector[pc]));	pc += 8;						// 64-bit issue.

		Val result = make_float64(task, d );

		stack = LIST_CONS(task, result, stack);

		free_bytes -= 4*WORD_BYTESIZE;		// Extra 4 bytes for alignment padding.				// 64-bit issue.
	    }
	    break;

	case I_RAW64L:
	    {
		int n = GET32(bytecode_vector,pc);	pc += 4;							// 64-bit issue.

		ASSERT(n > 0);

		int free_bytes_needed = 8*(n+1);									// 64-bit issue.
		free_bytes = ensure_sufficient_space__may_heapclean(task, free_bytes_needed, free_bytes, &roots2);

		#ifdef ALIGN_FLOAT64S
		    // Force FLOAT64_BYTESIZE alignment (descriptor is off by one word)
		    //
		    task->heap_allocation_pointer = (Val*)((Punt)(task->heap_allocation_pointer) | WORD_BYTESIZE);
		#endif

		int j = 2*n;							// Number of words.			// 64-bit issue...?

		set_slot_in_nascent_heapchunk (task, 0, MAKE_TAGWORD(j, EIGHT_BYTE_ALIGNED_NONPOINTER_DATA_BTAG));

		Val result =  commit_nascent_heapchunk(task, j );

		for (int j = 0;  j < n;  j++) {
		    //
		    PTR_CAST(double*, result)[j] = get_double(&(bytecode_vector[pc]));	pc += 8;			// 64-bit issue.
		}
		stack = LIST_CONS(task, result, stack);
	    }
	    break;

	case I_STR:
	    {
		int n = GET32(bytecode_vector,pc);		pc += 4;						// 64-bit issue.

		if (n == 0) {
		    //
		    stack = LIST_CONS(task, ZERO_LENGTH_STRING__GLOBAL, stack);

		    break;
		}

		int j = BYTES_TO_WORDS(n+1);								// '+1' to include space for '\0'.

		// The space request includes space for the data-chunk header word and
		// the sequence header chunk.
		//
		int free_bytes_needed = WORD_BYTESIZE*(j+1+3);								// 64-bit issue.

		free_bytes = ensure_sufficient_space__may_heapclean(task, free_bytes_needed, free_bytes, &roots2);

		// Allocate the data chunk:
		//
		set_slot_in_nascent_heapchunk(task, 0, MAKE_TAGWORD(j, FOUR_BYTE_ALIGNED_NONPOINTER_DATA_BTAG));
		set_slot_in_nascent_heapchunk (task, j, 0);								// So word-by-word string equality works.

		Val result = commit_nascent_heapchunk (task, j);

		memcpy (PTR_CAST(void*, result), &bytecode_vector[pc], n);		pc += n;

		// Allocate the header chunk:
		//
		result = make_vector_header(task, STRING_TAGWORD, result, n);

		// Push on stack:
		//
		stack = LIST_CONS(task, result, stack);

	    }
	    break;

	case I_LIT:
	    {

		int n = GET32(bytecode_vector,pc);	pc += 4;							// 64-bit issue.

		Val result = stack;

		for (int j = 0;  j < n;  j++) {
		    //
		    result = LIST_TAIL(result);
		}

		stack = LIST_CONS(task, LIST_HEAD(result), stack);

	    }
	    break;

	  case I_VECTOR:
	    {

		int n = GET32(bytecode_vector,pc);	pc += 4;							// 64-bit issue.

		if (n == 0) {
		    //
		    stack = LIST_CONS(task, ZERO_LENGTH_VECTOR__GLOBAL, stack);
		    //
		    break;
		}

		// The space request includes space
		// for the data-chunk header word and
		// the sequence header chunk.
		//
		int free_bytes_needed = WORD_BYTESIZE*(n+1+3);								// 64-bit issue.
		free_bytes = ensure_sufficient_space__may_heapclean(task, free_bytes_needed, free_bytes, &roots2);

		// Allocate the data chunk:
		//
		set_slot_in_nascent_heapchunk(task, 0, MAKE_TAGWORD(n, RO_VECTOR_DATA_BTAG));

		// Top of stack is last element in vector:
		//
		for (int j = n;  j > 0;  j--) {
		    //
		    set_slot_in_nascent_heapchunk(task, j, LIST_HEAD(stack));

		    stack = LIST_TAIL(stack);
		}

		Val result =  commit_nascent_heapchunk(task, n );

		result =  make_vector_header(task, TYPEAGNOSTIC_RO_VECTOR_TAGWORD, result, n);

		stack = LIST_CONS(task, result, stack);

	    }
	    break;

	case I_RECORD:
	    {

		int n = GET32(bytecode_vector,pc);	pc += 4;								// 64-bit issue.

		if (n == 0) {
		    //
		    stack = LIST_CONS(task, HEAP_VOID, stack);
		    //
		    break;

		} else {

		    int free_bytes_needed = 4*(n+1);

		    free_bytes = ensure_sufficient_space__may_heapclean(task, free_bytes_needed, free_bytes, &roots2);

		    set_slot_in_nascent_heapchunk(task, 0, MAKE_TAGWORD(n, PAIRS_AND_RECORDS_BTAG));
		}

		// Top of stack is last element in record:
		//
		for (int j = n;  j > 0;  j--) {
		    //
		    set_slot_in_nascent_heapchunk(task, j, LIST_HEAD(stack));

		    stack = LIST_TAIL(stack);
		}

		Val result = commit_nascent_heapchunk(task, n );

		stack = LIST_CONS(task, result, stack);

	    }
	    break;

	case I_RETURN:
	    ASSERT(pc == bytecode_vector_bytesize);

								check_agegroup0_overrun_tripwire_buffer( task, "make_package_literals_via_bytecode_interpreter__may_heapclean/ZZZ" );
	    return  LIST_HEAD( stack );
	    break;

	default:
	    die ("bogus literal opcode #%x @ %d", bytecode_vector[pc-1], pc-1);
	}								// switch
    }									// while

																do_debug_logging =  FALSE;
}									// fun make_package_literals_via_bytecode_interpreter__may_heapclean


// COPYRIGHT (c) 1997 Bell Labs, Lucent Technologies.
// Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
// released under Gnu Public Licence version 3.




/*
##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[A-Za-z]"			 		 	 #
# End:									 #
##########################################################################
*/

