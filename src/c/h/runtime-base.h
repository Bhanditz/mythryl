// runtime-base.h


#ifndef RUNTIME_BASE_H
#define RUNTIME_BASE_H

// Macro concatenation (ANSI CPP)
//
#ifndef CONCAT /* assyntax.h also defines CONCAT */
    # define CONCAT(a,b)	a ## b
#endif
#define CONCAT3(a,b,c)	a ## b ## c

#define ONE_K_BINARY		1024
#define ONE_MEG_BINARY 	(ONE_K_BINARY*ONE_K_BINARY)

#define SIGNAL_TABLE_SIZE_IN_SLOTS    32								// Size of signal_table__local	in   src/c/machine-dependent/interprocess-signals.c

// The generated file
//
//     sizes-of-some-c-types--autogenerated.h
//
// defines various size-macros
// and the following types:
//
// Int16	-- 16-bit signed integer
// Int1	-- 32-bit signed integer
// Int2	-- 64-bit signed integer (64-bit machines only)
// Unt16	-- 16-bit unsigned integer
// Unt1	-- 32-bit unsigned integer
// Unt2	-- 64-bit unsigned integer (64-bit machines only)
// Unt8		-- Unsigned 8-bit integer.
// Vunt	-- Unsigned integer large enough for one Mythryl Val.
// Vint	--   Signed integer large enough for one Mythryl Val.
// Vunt	-- Unsigned integer large enough for an address.
//
#include "sizes-of-some-c-types--autogenerated.h"


#define PAIR_BYTESIZE			(2*WORD_BYTESIZE)					// Size of a pair.
#define FLOAT64_SIZE_IN_WORDS		(FLOAT64_BYTESIZE / WORD_BYTESIZE)			// Vunt's per double.
#define PAIR_SIZE_IN_WORDS		2							// Vunt's per pair.
#define SPECIAL_CHUNK_SIZE_IN_WORDS	2							// Vunt's per special chunk.

// Convert a number of bytes
// to an even number of words:
//
#define BYTES_TO_WORDS(n)	(((n)+(WORD_BYTESIZE-1)) >> LOG2_BYTES_PER_WORD)

// Convert from double to word units:
//
#define DOUBLES_TO_WORDS(n)	((n) * FLOAT64_SIZE_IN_WORDS)

// On 32-bit machines it is useful to
// align doubles on 8-byte boundaries:
//
#ifndef SIZES_C_64_MYTHRYL_64
#  define ALIGN_FLOAT64S
#endif


#ifndef _ASM_

#include "../mythryl-config.h"

#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>

typedef  Int1  Bool;
typedef  Int1  Status;

// Assertions for debugging:
//
#if NEED_TO_EXECUTE_ASSERTS
    //
    extern void assert_fail (const char *a, const char *file, int line);
//  #define ASSERT(A)	((A) ? ((void)0) : assert_fail(#A, __FILE__, __LINE__))
    #define ASSERT(A)	{ if (!(A)) assert_fail(#A, __FILE__, __LINE__); }
#else
    #define ASSERT(A)	{ }
#endif

// Convert a bigendian 32-bit quantity
// into the host machine's representation:
//
#if defined(BYTE_ORDER_BIG)
    //
    #define BIGENDIAN_TO_HOST(x)	(x)
    //
#elif defined(BYTE_ORDER_LITTLE)
    //
    extern Unt1 swap_word_bytes (Unt1 x);
    #define BIGENDIAN_TO_HOST(x)	swap_word_bytes(x)
    //
#else
    #error must define endian
#endif

// Round i up to the nearest multiple of n,
// where n is a power of 2
//
#define ROUND_UP_TO_POWER_OF_TWO(i, n)		(((i)+((n)-1)) & ~((n)-1))


// Extract the bitfield of width WIDTH
// starting at position POS from I:
//
#define XBITFIELD(I,POS,WIDTH)		(((I) >> (POS)) & ((1<<(WIDTH))-1))

// Aliases for malloc/free, so 
// that we can easily replace them:
//
#define MALLOC(size)	malloc(size)
#define _FREE		free
#define FREE(p)		_FREE(p)

#define MALLOC_CHUNK(t)	((t*)MALLOC(sizeof(t)))		// Allocate a new C chunk of type t.
#define MALLOC_VEC(t,n)	((t*)MALLOC((n)*sizeof(t)))	// Allocate a new C array of type t chunks.

#define CLEAR_MEMORY(m, size)	(memset((m), 0, (size)))

// C types used in the run-time system:
//
#ifdef SIZES_C_64_MYTHRYL_32
    //
    typedef Unt1  Val;
#else
    //
    typedef   struct { Vunt v[1]; }   Valchunk;	// Just something for a Val to point to.
    //
    typedef   Valchunk*   Val;					// Only place Valchunk type is used.
#endif
//
typedef struct hostthread		Hostthread;		// struct hostthread	def in   this file.
typedef struct task			Task;			// struct task		def in   this file.
typedef struct heap			Heap;			// struct heap		def in   src/c/h/heap.h

#include <pthread.h>						// Posix threads:			https://computing.llnl.gov/tutorials/pthreads/

typedef pthread_mutex_t			Mutex;			// A mutual-exclusion lock:		https://computing.llnl.gov/tutorials/pthreads/#Mutexes
typedef pthread_cond_t			Condvar;		// Condition variable:			https://computing.llnl.gov/tutorials/pthreads/#ConditionVariables

#if defined(HAVE_PTHREAD_BARRIER_T)

  typedef pthread_barrier_t    Barrier;    // A barrier.
  typedef pthread_barrier_attr_t  BarrierAttr;  // A barrier attributes.

#else

  // OpenBSD hostthreads does not include hostthread barriers so we need to provide our own.
  // Blatantly stolen from here: http://www.howforge.com/implementing-barrier-in-hostthreads
  typedef struct {
    //
    int    needed;
    int    called;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    //
 } Barrier;

 typedef struct {
    // empty
 } BarrierAttr;


  // Barrier functions:
#   define pthread_barrier_init(b,a,n) barrier_init_emulation(b,n)
#   define hostthread_barrier_destroy(b) barrier_destroy_emulation(b)
#   define pthread_barrier_wait(b) barrier_wait_emulation(b)
  int barrier_init_emulation ( Barrier * barrier, int needed );
  int barrier_destroy_emulation ( Barrier * barrier );
  int barrier_wait_emulation ( Barrier * barrier);

  // This gets returned from barrier_wait_emulation when the requisite
  // number of threads has been reached...
#   define PTHREAD_BARRIER_SERIAL_THREAD -1

#endif


typedef pthread_t 			Ptid;			// A hostthread id.
    //
    // NB; Ptid MUST be pthread_t from <pthread.h> because in
    // pth__pthread_create from src/c/hostthread/hostthread-on-posix-threads.c
    // we pass a pointer to task->hostthread->ptid as pthread_t*.



// System_Constant
//
// In C, system constants are usually integers.
// We represent these in the Mythryl system as
// (Int, String) pairs, where the integer is the
// C constant and the string is a short version
// of the symbolic name used in C (e.g., the constant
// EINTR might be represented as (4, "INTR")).
//
// We currently maintain two tables of this type at the C level:
//     errno_sysconsts_table__global	in   src/c/lib/posix-error/errno-sysconsts-table.c
//     signal_sysconsts_table__local	in   src/c/o/posix-signal-table--autogenerated.c
//
typedef struct {
    //
    int	   id;
    char*  name;
    //
} System_Constant;

// Sysconsts
//
typedef struct {
    //
    int		       constants_count;
    System_Constant*   constants_vector;
    //
} Sysconsts;



typedef  struct roots  {  Val* root;  struct roots* next;  }  Roots;
    //
    // We use this type to pass a list of "roots" (Mythryl heap
    // values referenced from C code) to call_heapcleaner_with_extra_roots.
    //
    // By allocating these on the stack and linking them together,
    // we can pass an indefinite number of extra roots, including
    // chaining extra roots to those passed in by a parent fn.
    //
    // See also: "Protecting Mythryl Heap Pointers in C Runtime Code"
    // in
    //     src/A.GARBAGE-COLLECTOR.OVERVIEW


////////////////////////////////////////////////////////////////////////////
// Task -- C view of the state of a Mythryl computation.

#include "system-dependent-root-register-indices.h"

#if (!defined(BIGCOUNTER_H) && defined(ICOUNT))
    #include "bigcounter.h"
#endif

#define CALLEE_SAVED_REGISTERS_COUNT	3

#define AGEGROUP0_OVERRUN_TRIPWIRE_BUFFER_VALUE		 (0xDEADBEEF)								// Value to fill tripwire buffer with. Was zero, but that is far too common a value -- might miss buffer overrun.
#define AGEGROUP0_OVERRUN_TRIPWIRE_BUFFER_SIZE_IN_WORDS  (16)									// Was (10*1024) for awhile, but that appears to roughly double heapcleaning CPU time.
#define AGEGROUP0_OVERRUN_TRIPWIRE_BUFFER_SIZE_IN_BYTES  (sizeof(Val) * AGEGROUP0_OVERRUN_TRIPWIRE_BUFFER_SIZE_IN_WORDS)
    //
    // Added these on suspicion that a Heisenbug I've been seeing
    // might be due to overrunning heap_allocation_limit.  The idea
    // is to have an always-zero buffer of this size immediately after
    // real_heap_allocation_limit, and have the heapcleaner check that
    // it stays all-zeros as expected.       -- 2011-12-19 CrT



// Basically holds the register and the					// NB: I believe the layout here is embedded in the assembly code in
// private agegroup0 heap allocation sub-buffer.			//     src/c/machine-dependent/prim.intel32.asm
//									//     src/c/machine-dependent/prim.pwrpc32.asm
//									//     src/c/machine-dependent/prim.sparc32.asm
//									//     src/c/machine-dependent/prim.intel32.masm
//									//
//									// so if you change the layout you'll have to update the asm files.   -- 2011-12-19 CrT


/* typedef  struct task  Task; */					// Defined in runtime-base.h
									// Initialized by   set_up_hostthread_state   in   src/c/main/runtime-state.c
//
// NB: If you ADD or REMOVE FIELDS here, you should update
//     src/c/config/generate-task-and-hostthread-struct-field-offsets-h.c
//
struct task {
    //
    Heap*	heap;							// The heap. task->heap is the same for all tasks.
    Hostthread* hostthread;						// The Hostthread on which it is running. If you change the offset of this field you'll probably need to change:
									//     hostthread_offtask   in   src/lib/compiler/back/low/main/intel32/machine-properties-intel32.pkg
    Val*	heap_allocation_buffer;					// The agegroup0 buffer.
    Val*	heap_allocation_pointer;				// We allocate heap memory just by advancing this pointer.
    Val*	heap_allocation_limit;					// We heapclean when heap_allocation_pointer reaches this point.  Must be at least MIN_FREE_BYTES_IN_AGEGROUP0_BUFFER short of true buffer end.
    Vunt	heap_allocation_buffer_bytesize;			// Phystical size.
    //
    // The following fields hold the contents of
    // Mythryl registers while we are executing
    // C-layer code:
    //
    Val		argument;						// Argument to current function/closure. Since we treat calling and returning as the same thing, this will also hold the result of the call.
    Val		fate;							// "Return address".
    Val		current_closure;					// Currently executing closure ("function").
    //
    Val		link_register;						// A valid program counter value -- initially at least entrypoint in 'closure'.
									// Semantics still more than a little mysterious.
									// Datum:   If you do   find . -name '*.c' -print | xargs egrep link_register
									//          you'll find we (almost?) alwways set it either to HEAP_VOID
									//          or else to GET_CODE_ADDRESS_FROM_CLOSURE(closure), for example   task->link_register   = GET_CODE_ADDRESS_FROM_CLOSURE( task->current_closure );
									//          in   src/c/main/run-mythryl-code-and-runtime-eventloop.c
									//          where   #define GET_CODE_ADDRESS_FROM_CLOSURE(c)	(GET_TUPLE_SLOT_AS_VAL(c, 0))   in   src/c/h/runtime-values.h:

    Val		program_counter;					// Address of Mythryl code to execute; when
									// calling a Mythryl function from C, this			NB:  The garbage collector treats link_register as a root but not
									// holds the same value as the link_register.			program_counter, so presumably it always points into the same <something>. -- 2011-11-15 CrT

    Val		exception_fate;						// Exception handler (?)
    Val		current_thread;						// When the Mythryl thread scheduler is running this will hold a value of type Microthread.  Type
									// Microthread	def in   src/lib/src/lib/thread-kit/src/core-thread-kit/internal-threadkit-types.pkg

    Val		callee_saved_registers[ CALLEE_SAVED_REGISTERS_COUNT ];	// This holds the C-level callee-save registers while we're executing Mythryl code.

    Val		heap_changelog;						// The cons-list of updates to the heap. These are allocated on the heap at each update, used by heapcleaner to detect (new) intergenerational pointers.

    Val		fault_exception;					// The exception packet for a hardware fault.
    Vunt	faulting_program_counter;				// The program counter of the faulting instruction.

    Vunt*	mythryl_stackframe__ptr_for__c_signal_handler;		// c_signal_handler() uses this pointer to zero heap_allocation_limit -- see ZERO_HEAP_ALLOCATION_LIMIT_FROM_C_SIGNAL_HANDLER in src/c/h/system-dependent-signal-get-set-etc.h

    Val*	protected_c_arg;					// Used to protect one arg from garbage collection by RELEASE_MYTHRYL_HEAP in src/c/h/runtime-base.h
    Val		heapvoid;						// Dummy for protected_c_arg to point to when not being used.  Initialized to HEAP_VOID.

    #if NEED_SOFTWARE_GENERATED_PERIODIC_EVENTS
	//
	Val*	real_heap_allocation_limit;				// We ab/use heapchecks to generate events by setting an artificially small heap_allocation_limit value; in such cases this holds the real value.
	Bool	software_generated_periodic_event_is_pending;
	Bool	in_software_generated_periodic_event_handler;
    #endif
};


// Type for our pth__heapcleaner_state__global global:
//
typedef enum {
    //
    HEAPCLEANER_IS_OFF,			// No heapcleaner activity; all hostthreads running mythryl code (or blocked).
    HEAPCLEANER_IS_STARTING,		// One hostthread has set mode = HOSTTHREAD_IS_HEAPCLEANING and become primary heapcleaner; it is waiting for HOSTTHREAD_IS_RUNNING count to drop to zero.
    HEAPCLEANER_IS_RUNNING		// No HOSTTHREAD_IS_RUNNING hostthreads; primary heapcleaner hostthread is heapcleaning, secondary mode = HOSTTHREAD_IS_HEAPCLEANING hostthreads are waiting for it to finish and set HEAPCLEANER_IS_OFF.
    //
} Heapcleaner_State;

// Type of a hostthread->mode field:
//
typedef enum {
    //
    HOSTTHREAD_IS_RUNNING,		// Normal state of a running Mythryl hostthread.
    HOSTTHREAD_IS_BLOCKED,		// For when a hostthread is I/O blocked at the C level on a sleep(), select(), read() or such.  MUST NOT REFERENCE MYTHRYL HEAP IN ANY WAY WHEN IN THIS STATE because heapcleaner may be running!
    HOSTTHREAD_IS_PRIMARY_HEAPCLEANER,	// Hostthread has suspended HOSTTHREAD_IS_RUNNING mode for duration of heapcleaning. It initiated this heapcleaning and will do the actual work.
    HOSTTHREAD_IS_SECONDARY_HEAPCLEANER,// Hostthread has suspended HOSTTHREAD_IS_RUNNING mode for duration of heapcleaning. It did not initiate this heapcleaning and will do no actual heapcleaning work.
    HOSTTHREAD_IS_VOID			// No kernel thread allocated -- unused slot in hostthread table.
    //
} Hostthread_Mode;
    //
    // See comments at bottom of   src/c/hostthread/hostthread-on-posix-threads.c
    // Mode of a Hostthread.		// hostthread is defined in   this file
    //
    // To switch a hostthread between the two
    // RUNNING modes, use the macros
    //
    //     RELEASE_MYTHRYL_HEAP		// HOSTTHREAD_IS_RUNNING  ->  HOSTTHREAD_IS_BLOCKED  state transition.
    //     RECOVER_MYTHRYL_HEAP		// HOSTTHREAD_IS_BLOCKED  ->  HOSTTHREAD_IS_RUNNING  state transition.


///////////////////////////////////////////////////////////////////
// State of a 'Hostthread', the Mythryl wrapper for a
// posix thread sharing access to the Mythryl heap.

#include "system-dependent-signal-stuff.h"
#include "runtime-timer.h"



// Define our per-posix-thread state information.
//
// NB: If you ADD or REMOVE FIELDS here, you should update
//     src/c/config/generate-task-and-hostthread-struct-field-offsets-h.c
//
struct hostthread {						// typedef struct hostthread	Hostthread	  def above.
    //
    Heap* heap;		  					// The heap.  All tasks share the same Heap. (While having separate agegroup0 sub-buffers.)
								// 'Heap' is defined in	  src/c/h/runtime-base.h

    Task* task;							// The state of the Mythryl task that is running on this Hostthread.
				        			// The SML/NJ codebase says "Eventually we will support multiple Mythryl tasks per Hostthread,"
								// but I see no advantage to this and think the Hostthread and Task records should be merged.  -- 2012-10-11 CrT
    // Signal related fields:
    //
    Bool	executing_mythryl_code;				// TRUE while executing Mythryl code.
    Bool	interprocess_signal_pending;			// Is there an interprocess signal awaiting handling?
    Bool	mythryl_handler_for_interprocess_signal_is_running;	// Is a Mythryl signal handler active? 
    //
    Signals_Seen_And_Done_Counts
	all_posix_signals;					// Summary count for all system signals.
    //
    int		next_posix_signal_id;				// ID (e.g., SIGALRM) and 
    int		next_posix_signal_count;			// count of next signal to handle.
    //
    Signals_Seen_And_Done_Counts
	posix_signal_counts[ SIGNAL_TABLE_SIZE_IN_SLOTS ];	// Per-signal counts of pending signals.
    //
    int		posix_signal_rotor;				// Ihe index in previous of the next slot to check, round-robin style.

    Time*	cpu_time_at_start_of_last_heapclean;		// The cumulative CPU time at the start of the last heapclean -- see src/c/main/timers.c
    Time*	cumulative_cleaning_cpu_time;			// The cumulative cleaning time.

    Unt1	ccall_limit_pointer_mask;			// For raw-C-call interface.


    Hostthread_Mode  mode;					// Do NOT change this unless holding   pth__mutex.  Signal pth__condvar after such changes.
								// Valid values for 'mode' are HOSTTHREAD_IS_RUNNING/HOSTTHREAD_IS_BLOCKED/HOSTTHREAD_IS_HEAPCLEANING/HOSTTHREAD_IS_VOID -- see src/c/h/runtime-base.h

    char*	name;						// Human-readable thread name for debugging and display.

    int		id;						// Our own private small-int id for the record. We assign these sequentially starting at 1.
    Ptid	ptid;	       					// Our os-assigned hostthread-identifier ("tid").	(pthread_t appears in practice to be "unsigned long int" in Linux, from a quick grep of /usr/include/*.h)
	//
	// NB; 'ptid' MUST be declared Ptid (i.e., pthread_t from <pthread.h>)
	//     because in  pth__pthread_create   from   src/c/hostthread/hostthread-on-posix-threads.c
	//     we pass a pointer to task->hostthread->ptid as pthread_t* to avoid race conditions.
	//
	// Ptid def is   typedef pthread_t Ptid;   in   src/c/h/runtime-base.h


};



///////////////////////////////////////////////////////////////////
// Run-time system messages:
//
extern void say       (char* fmt, ...);										// say								def in    src/c/main/error-reporting.c
extern void debug_say (char* fmt, ...);										// debug_say							def in    src/c/main/error-reporting.c
extern void say_error (char*,     ...);										// say_error							def in    src/c/main/error-reporting.c
extern void die       (char*,     ...);										// die								def in    src/c/main/error-reporting.c

extern Bool do_debug_logging;											// Used to control special debug logging.			def in   src/c/lib/heap/libmythryl-heap.c

extern void print_stats_and_exit      (int code);								// print_stats_and_exit						def in    src/c/main/runtime-main.c

typedef   struct cleaner_args   Heapcleaner_Args;
    //
    // An abstract type whose representation depends
    // on the particular cleaner being used.

extern Heapcleaner_Args*   handle_heapcleaner_commandline_arguments   (char** argv);				// handle_heapcleaner_commandline_arguments			def in   src/c/heapcleaner/heapcleaner-initialization.c

extern void  load_compiled_files__may_heapclean (const char* filename, Heapcleaner_Args*, Roots*);		// load_compiled_files__may_heapclean				def in   src/c/main/load-compiledfiles.c
extern void  load_and_run_heap_image__may_heapclean (const char* filename,  Heapcleaner_Args*, Roots*);		// load_and_run_heap_image__may_heapclean			def in   src/c/main/load-and-run-heap-image.c

extern Task* make_task               (Bool is_boot, Heapcleaner_Args* params);					// make_task							def in   src/c/main/runtime-state.c
extern void initialize_task (Task *task);									// initialize_task						def in   src/c/main/runtime-state.c



extern void save_c_state    (Task *task, Roots*);								// save_c_state							def in   src/c/main/runtime-state.c
extern void restore_c_state (Task *task, Roots*);								// restore_c_state						def in   src/c/main/runtime-state.c
    //
    // These two are used (only) in
    //
    //     src/c/main/load-compiledfiles.c
    //
    // where they are used to bracket a call to
    //
    //     run_mythryl_function__may_heapclean
    //
    // which can (and does) execute arbitrary Mythryl compiled code.
    //
    // They must in particular protect C pointers into the
    // Mythryl heap from any possible garbage collections.



extern void set_up_timers ();

extern Val    run_mythryl_function__may_heapclean (Task *task, Val f, Val arg, Bool use_fate, Roots*);		// run_mythryl_function__may_heapclean				def in   src/c/main/run-mythryl-code-and-runtime-eventloop.c

extern void   reset_timers (Hostthread* hostthread);
extern void   run_mythryl_task_and_runtime_eventloop__may_heapclean (Task* task, Roots*);			// run_mythryl_task_and_runtime_eventloop__may_heapclean	def in   src/c/main/run-mythryl-code-and-runtime-eventloop.c
extern void   raise_mythryl_exception (Task* task, Val exn);							// raise_mythryl_exception					def in   src/c/main/run-mythryl-code-and-runtime-eventloop.c
extern void   handle_uncaught_exception   (Val e);								// handle_uncaught_exception					def in   src/c/main/runtime-exception-stuff.c

extern void   set_up_fault_handlers ();										// set_up_fault_handlers				def in   src/c/machine-dependent/posix-arithmetic-trap-handlers.c
														// set_up_fault_handlers					def in   src/c/machine-dependent/cygwin-fault.c
														// set_up_fault_handlers					def in   src/c/machine-dependent/win32-fault.c
#if NEED_SOFTWARE_GENERATED_PERIODIC_EVENTS
    //
    extern void reset_heap_allocation_limit_for_software_generated_periodic_events (Task *task);
#endif


///////////////////////////////////////////////////////////////////////////
// Support for RELEASE_MYTHRYL_HEAP.
//
// The problem to be solved by RELEASE_MYTHRYL_HEAP
// is that while we are doing a slow syscall (or just a
// slow C op, like compressing a largish string) we cannot
// respond to a request to enter heapcleaner mode,
// and consequently all other hostthreads could wind up blocked
// waiting for us to join them in heapcleaner mode -- thus
// defeating much of the point of having multiple kernel threads
// running. (Minor heapcleanings happen about 200 times per second.)
//
// Our basic solution is that before doing such an op we
// reliquish heap access rights by changing our hostthread
// status from HOSTTHREAD_IS_RUNNING to HOSTTHREAD_IS_BLOCKED;
// the other hostthreads then know we're out of the loop and can go
// ahead and do a heapcleaning without us.
//
// Our solution creates the problem that any Mythryl heap values
// used by the slow system call or C function must therefor be
// copied out of the Mythryl heap, since heapcleaning may move
// them around arbitrarily without warning so long as we have
// HOSTTHREAD_IS_BLOCKED set.
//
// So here we implement functionality to copy values out of the
// Mythryl heap.  Obviously, we cannot use static buffers, since
// they would be shared between all hostthreads;  we have to use
// either stack storage or malloc()ed storage.  Malloc()ing is
// slow and stack storage is fixed-size (unless we use nonstandard
// gcc features) so we use stack storage for small stuff and
// malloc()ed space for large stuff:
//
#define MAX_STACK_BUFFERED_MYTHRYL_HEAP_VALUE (4*1024)		// Any number large enough so copying it takes longer than malloc()ing it.
//
typedef  struct  {
    //
    void* heap_space;						// NULL if stack_space was big enough, otherwise a malloc()d buffer that needs to be free()d later.
    //
    char stack_space[ MAX_STACK_BUFFERED_MYTHRYL_HEAP_VALUE ];	// Small stuff gets buffered in here.
    //
} Mythryl_Heap_Value_Buffer;
//
extern void*   buffer_mythryl_heap_value	( Mythryl_Heap_Value_Buffer*, void* heapval, int heapval_bytesize );		//   buffer_mythryl_heap_value			def in   src/c/main/runtime-state.c
extern void*   buffer_mythryl_heap_nonvalue	( Mythryl_Heap_Value_Buffer*,                int heapval_bytesize );		//   buffer_mythryl_heap_nonvalue		def in   src/c/main/runtime-state.c
extern void  unbuffer_mythryl_heap_value	( Mythryl_Heap_Value_Buffer* );							// unbuffer_mythryl_heap_value			def in   src/c/main/runtime-state.c




extern char*  mythryl_program_name__global;					// Command name used to invoke the runtime.  mythryl_program_name__global	is from   src/c/main/runtime-main.c

extern char** raw_commandline_args__global;					// argv untouched, directly from main(). Defined in   src/c/main/runtime-main.c   and used (only) in   src/c/lib/heap/libmythryl-heap.c
extern char** commandline_args_without_argv0_or_runtime_args__global;		// Does not include program name (argv[0]) or --runtime-xxx=yyy.  Used various places, set in src/c/main/runtime-main.c
    //
    // These are two views of the command line arguments.
    // raw_args is essentially argv[].
    // commandline_arguments is argv[] with runtime system arguments stripped
    // out (e.g., those of the form --runtime-xxx[=yyy]).
    // commandline_arguments is argv[] with runtime system arguments stripped
    // out (e.g., those of the form --runtime-xxx[=yyy]).

extern char*  mythryl_script__global;						// Contents of MYTHRYL_SCRIPT environment variable at startup.  This var is cleared immediately upon being read.	Def in src/c/main/runtime-main.c
extern int    verbosity__global;						// Used only in   src/c/heapcleaner/import-heap.c  and in   src/c/main/runtime-main.c
extern Bool   codechunk_comment_display_is_enabled__global;			// Set per   --show-code-chunk-comments	  commandline switch in   src/c/main/runtime-main.c
extern Bool   heapcleaner_messages_are_enabled__global;				// Set                                                       in   src/c/lib/heap/heapcleaner-control.c
extern Bool   unlimited_heap_is_enabled__global;				// Set per   --unlimited-heap             commandline switch in   src/c/heapcleaner/heapcleaner-initialization.c
extern Bool   saw_shebang_line__global;						// Intended only for debug; currently never used; set	     in   src/c/main/runtime-main.c
extern Bool   running_script__global;						// Used only for debug;  set				     in   src/c/main/runtime-main.c
										//                       read				     in   src/c/hostthread/hostthread-on-posix-threads.c	

extern Hostthread*	hostthread_table__global [];				// hostthread_table__global	def in   src/c/main/runtime-state.c
    //
    // Table of all active posix threads in process.
    // (Or at least, all posix threads running Mythryl
    // code or accessing the Mythryl heap.)
    //
    // In multithreaded operation this table is modified
    // only by code in   src/c/hostthread/hostthread-on-posix-threads.c
    // serialized by the pth__mutex
    // in that file.     

extern Heapcleaner_State  pth__heapcleaner_state__global;			// Grab pth__mutex before changing this.
extern int                pth__running_hostthreads_count__global;		// Grab pth__mutex before changing this.
    //
    // These are both defined in   src/c/hostthread/hostthread-on-posix-threads.c
    // See comments at bottom of   src/c/hostthread/hostthread-on-posix-threads.c

extern void   pth__validate_running_hostthreads_count (void);			// Explicitly verify that pth__running_hostthreads_count__global is correct by looping over hostthread_table__global[].


// log_if declaration.
//
// Conditional tracing to a logfile
// designed to work in concert with
//
//     src/lib/src/lib/thread-kit/src/lib/logger.pkg
//
// At the Mythryl level one calls
//
//     internet_socket__premicrothread::set_printif_fd
//
// from
//
//     src/lib/std/src/socket/internet-socket--premicrothread.pkg
//
// to enable this tracing by setting
//
//     log_if_fd
//
// after which desired C modules can call log_if
// to write lines into the tracelog file.


extern void   log_if   (const char * fmt, ...);					// log_if fmt string should NOT contain newlines -- one will be appended automatically.
extern int    log_if_fd;
extern void   log_if_to_stderr (const char * fmt, ...);				// Just like log_if, but writes to stderr.



// Some convenience macros -- is there a better place for them?

#ifndef MIN
#define MIN(a,b)  ((a) > (b) ? (b) : (a))
#endif

#ifndef MAX
#define MAX(a,b)  ((a) < (b) ? (b) : (a))
#endif



///////////////////////////////////////////////////////////////////////////////
// We wrap C system calls in
//   RELEASE_MYTHRYL_HEAP
//   RECOVER_MYTHRYL_HEAP
// calls.  This has the effect of removing
// the blocked hostthread from the set of RUNNING
// hostthreads, allowing the remaining hostthreads
// to do heapcleanings ("garbage collections")
// in a timely manner:
//
extern void release_mythryl_heap(  Hostthread* hostthread,  const char* fn_name,  Val* arg  );		// release_mythryl_heap		def in   src/c/hostthread/hostthread-on-posix-threads.c
extern void recover_mythryl_heap(  Hostthread* hostthread,  const char* fn_name             );		// recover_mythryl_heap		def in   src/c/hostthread/hostthread-on-posix-threads.c
//
#define RELEASE_MYTHRYL_HEAP( hostthread, fn_name, arg )	release_mythryl_heap(  hostthread,  fn_name,  arg  )
#define RECOVER_MYTHRYL_HEAP( hostthread, fn_name      )	recover_mythryl_heap(  hostthread,  fn_name        )
    //
    // For background comments see Note[1]


#define ENTER_MYTHRYL_CALLABLE_C_FN(fn_name)    do { note_fn_entry_in_syscall_log(task, fn_name); } while(0)	// Useful for debugging heap corruption.  Should be #define'd to the empty string in production code.
#define  EXIT_MYTHRYL_CALLABLE_C_FN(fn_name)    do {  note_fn_exit_in_syscall_log(task, fn_name); } while(0)	// Useful for debugging heap corruption.  Should be #define'd to the empty string in production code.
    //
    // These macros are intended to provide a hook to track calls from
    // Mythryl code into the C level.  The immediate motivation is
    // to log them in a leaky circular ram buffer so as to be able
    // to dump the last N after heap corruption is detected, say by
    // check_agegroup0_overrun_tripwire_buffer() in src/c/heapcleaner/heap-debug-stuff.c
    //
    // The intention is macro be defined at the top of essentially
    // every function with the argslist (Task* task, Val arg), which
    // is to say the entrypoint functions from Mythryl to C.
    //
    // One minor exception is the do_breakpoint_0 ... do_breakpoint_9
    // functions; tracking them would not aid debugging.

#if !NEED_SOFTWARE_GENERATED_PERIODIC_EVENTS \
 || !NEED_HOSTTHREAD_SUPPORT_FOR_SOFTWARE_GENERATED_PERIODIC_EVENTS
    //
    #error Multicore runtime currently requires polling support.
#endif

#if HAVE_SYS_TYPES_H
    #include <sys/types.h>
#endif

#if HAVE_SYS_PCTRL_H
    #include <sys/prctl.h>
#endif

#if HAVE_UNISTD_H
    #include <unistd.h>
#endif





////////////////////////////////////////////////////////////////////////////
// Statically pre-allocated mutexs, condvars and such:
//
extern Mutex	    pth__ramlog_mutex;						// Used in src/c/main/ramlog.c
extern Mutex	    pth__mutex;							// Governs  hostthread->mode, pth__heapcleaner_state__global, pth__running_hostthreads_count__global ... -- see  src/c/hostthread/hostthread-on-posix-threads.c
extern Condvar	    pth__condvar;						// Waits on hostthread->mode, pth__heapcleaner_state__global, pth__running_hostthreads_count__global ... -- see  src/c/hostthread/hostthread-on-posix-threads.c
//
//


////////////////////////////////////////////////////////////////////////////
// PACKAGE STARTUP AND SHUTDOWN
//
extern void     pth__start_up		(void);					// Called once near the top of main() to initialize the package.  Allocates our static locks, may also mmap() memory for arena or whatever.
extern void     pth__shut_down		(void);					// Called once just before calling exit(), to release any OS resources.



////////////////////////////////////////////////////////////////////////////
// HOSTTHREAD START/STOP/ETC SUPPORT
//
extern char*    pth__pthread_create	( int* hostthread_table_slot,
					  Val thread,
					  Val closure
					);						// Called with (thread, closure) and if a hostthread is available starts closure running on a new hostthread and returns TRUE.
//											// Returns FALSE if we're already maxed out on allowed number of hostthreads.
//											// This gets exported to the Mythryl level as  "hostthread", "make_hostthread"  via   src/c/lib/hostthread/libmythryl-hostthread.c
//											// and instantiated   at the Mythryl leval as  "make_hostthread"             in    src/lib/std/src/hostthread.pkg
//
extern void     pth__pthread_exit		(Task* task);				// Reverse of above, more or less.
//											// On Solaris this appears to actually stop and kill the thread.
//											// On SGI this appears to just suspend the thread pending another request to run something on it.
//											// Presumably the difference is that thread de/allocation is cheaper on Solaris than on SGI...?
// 
//
extern char*    pth__pthread_join		(Task* task, Val hostthread_table_slot);	// Wait until subthread exits.
// 
extern Hostthread* pth__get_hostthread_by_id	(int  id);				// 
extern Hostthread* pth__get_hostthread_by_ptid	(Ptid ptid);				// Needed to find record for current hostthread in contexts like signal handlers where it is not (otherwise) available.
//											// Hostthread is typedef'ed in src/c/h/runtime-base.h
//
extern int	pth__get_hostthread_id		(void);					// Small-int unique identifier for hostthread.
extern Ptid	pth__get_hostthread_ptid	(void);					// Used to initialize hostthread_table__global[0]->pid in   src/c/main/runtime-state.c
//											// This just calls getpid()  in                         src/c/hostthread/hostthread-on-sgi.c
//											// This returns thr_self() (I don't wanna know) in      src/c/hostthread/hostthread-on-solaris.c


////////////////////////////////////////////////////////////////////////////
// HOSTTHREAD GARBAGE COLLECTION SUPPORT
//
extern void  partition_agegroup0_buffer_between_hostthreads   (Hostthread *hostthread_table[]);
extern int   pth__start_heapcleaning    (Task*);
extern void  pth__finish_heapcleaning   (Task*);

extern int   pth__start_heapcleaning_with_extra_roots   (Task *task, Roots* extra_roots);
//
extern Val*  pth__extra_heapcleaner_roots__global [];



////////////////////////////////////////////////////////////////////////////
//                   MUTEX LOCKS
//
// We use our "mutex" locks to perform mutual exclusion,
// ensuring consistency of shared mutable datastructures
// by ensuring that at most one hostthread at a time is
// updating that datastructure.  Typically we allocate
// one such mutex for each major shared mutable datastructure,
// which persists for as long as that datastructure.
//
// Tutorial:   https://computing.llnl.gov/tutorials/hostthreads/#Mutexes
//

extern Vunt	pth__mutex_make    (void);
//
extern char*		pth__mutex_destroy	(Task* task, Vunt mutex_id);			// http://pubs.opengroup.org/onlinepubs/007904975/functions/pthread_mutex_init.html
extern char*		pth__mutex_lock		(Task* task, Vunt mutex_id);			// http://pubs.opengroup.org/onlinepubs/007904975/functions/pthread_mutex_lock.html
extern char*		pth__mutex_unlock	(Task* task, Vunt mutex_id);			// http://pubs.opengroup.org/onlinepubs/007904975/functions/pthread_mutex_lock.html
extern char*		pth__mutex_trylock	(Task* task, Vunt mutex_id, Bool* result);	// http://pubs.opengroup.org/onlinepubs/007904975/functions/pthread_mutex_lock.html
//														// pth__mutex_trylock returns FALSE if lock was acquired, TRUE if it was busy.

////////////////////////////////////////////////////////////////////////////
//                   CONDITIONAL VARIABLES
//
// Condition variables (in conjunction with mutexes)
// provide a way for a hostthread to wait for (typically)
// a particular variable to assume a particular value,
// without having to poll.
//
// Tutorial:   https://computing.llnl.gov/tutorials/hostthreads/#ConditionVariables
//
extern Vunt	pth__condvar_make    (void);

extern char*   pth__condvar_init		(Task* task, Condvar* condvar);			// http://pubs.opengroup.org/onlinepubs/007904975/functions/pthread_cond_init.html
    //
    // Prepare the condition variable for use.
    // This may allocate resources or such internally.
    // Caveats:
    //
    //  o Behavior is undefined if pth__condvar_init()
    //   is called on an already-initialized condition variable.
    //   (Call pth__condvar_destroy first.)

extern char*   pth__condvar_destroy		(Task* task, Vunt condvar_id);		// http://pubs.opengroup.org/onlinepubs/007904975/functions/pthread_cond_init.html
    //
    // Undo the effects of   pth__condvar_init ()   on the condition variable.
    // ("Destroy" is poor nomenclature; "reset" would be better.)
    //
    //  o After calling pth__condvar_destroy on a condition variable
    //    one may call  pth__condvar_init on it; all other operations are undefined.
    //
    //  o Behavior is undefined if pth__condvar_destroy()
    //    is called when a hostthread is blocked on the condition variable.

extern char*   pth__condvar_wait   (Task* task, Vunt condvar_id, Vunt mutex_id);		// http://pubs.opengroup.org/onlinepubs/007904975/functions/pthread_cond_wait.html
    //
    // Atomically release mutex and block on the condition variable.
    // Upon return we will again hold the mutex.  (Return is triggered
    // by a call to   pth__condvar_signal or pth__condvar_broadcast.)

extern char*   pth__condvar_signal   (Task* task, Vunt condvar_id);				// http://pubs.opengroup.org/onlinepubs/007904975/functions/pthread_cond_signal.html
    //
    // Unblock at least one hostthread waiting on condvar,
    // except no effect if no hostthreads are blocked on condvar,
    //
    // If more than one hostthread is blocked on condvar the scheduling
    // policy determines the order in which threads are unblocked.
    //
    // If multiple hostthreads are unblocked, they compete for the
    // associated mutex as though they had call called pth__mutex_lock().

extern char*   pth__condvar_broadcast   (Task* task, Vunt condvar_id);			// http://pubs.opengroup.org/onlinepubs/007904975/functions/pthread_cond_signal.html
    //
    // Unblock all hostthreads waiting on condvar, which might be none.
    //
    // If multiple hostthreads are unblocked, they compete for the
    // associated mutex as though they had all called pth__mutex_lock().



////////////////////////////////////////////////////////////////////////////
//                   BARRIERS
//
// We use our "barriers" to perform essentially the
// opposite of mutual exclusion, ensuring that all
// hostthreads in a set have completed their part of
// a shared task before any of them are allowed to
// proceed past the "barrier".
//
// The basic use protocol is:
//
//  o Call pth__barrier_init() before doing anything else.
//
//  o Call pth__barrier_wait() to synchronize multiple hostthreads.
//
//  o Call pth__barrier_detroy() before calling pth__barrier_init() again.
//
//  o Never call  pth__barrier_init() or pth__barrier_detroy()
//    while hostthreads are blocked on the barrier.
//
extern Vunt	pth__barrier_make    (void);
extern char*	pth__barrier_free    (Task* task, Vunt barrier_id);

extern char*    pth__barrier_init 	(Task* task, Vunt barrier_id, int threads);	// http://pubs.opengroup.org/onlinepubs/007904975/functions/pthread_barrier_init.html
    //
    // Tell the barrier how many threads must be
    // present at it before they can pass. This
    // may allocate resources or such internally.
    // Caveats:
    //
    //  o Behavior is undefined if pth__barrier_init()
    //   is called on an already-initialized barrier.
    //   (Call pth__barrier_destroy first.)
    //
    //  o Behavior is undefined if pth__barrier_init()
    //    is called when a hostthread is blocked on the barrier.
    //    (That is, if some hostthread has not returned from
    //    pth__barrier_wait)

extern char*    pth__barrier_wait (Task* task, Vunt barrier_id, Bool* result);	// http://pubs.opengroup.org/onlinepubs/007904975/functions/pthread_barrier_wait.html
    //
    // Block currently executing hostthread until the proper
    // number of hostthreads are waiting at the barrier.
    // This number is specified via pth__barrier_init().
    //
    // When released, one hostthread at barrier gets a TRUE
    // back pth__barrier_wait(), the others  get a FALSE;
    // this lets them easily "elect a leader" if desired.
    // (This is particularly useful for ensuring that
    // pth__barrier_destroy() gets called exactly once
    // after use of a barrier.)
    //
    //  o Behavior is undefined if calling pth__barrier_wait
    //    wait on an uninitialized barrier.
    //    A barrier is "uninitialized" if
    //      * pth__barrier_init() has never been called on it, or if
    //      * pth__barrier_init() has not been called on it since the last
    //        pth__barrier_destroy() call on it.





//////////////////////////////////////////////////////////////////////////////////////
//            SYSCALL_LOG
// 
// Our regular log facility in
//
//     src/c/main/error-reporting.c
//
// is good for many debug jobs, but some calls are
// so frequent that logging them would spam the logfile
// and choke the disk.
//
// Our idea here is to handle such cases using a circular
// in-memory queue that perpetually overwrites old entries
// with new, allowing us to retrieve (say) the last 1024
// entries made in case of a segfault or so.  Sort of time
// travel lite. :-)
//
// In keeping with the low-overhead theme, we log only fixed
// strings, rather than arbitrary strings created per-log-entry
// as in the main error-reporting.c logic.

#define LOG2_SYSCALL_LOG_ENTRIES	10						// 10==1024 Syscall_Log entries.
#define SYSCALL_LOG_ENTRIES		(1 << LOG2_SYSCALL_LOG_ENTRIES)			// This keeps things a power of two, so that we can
#define SYSCALL_LOG_MASK		(SYSCALL_LOG_ENTRIES-1)				// construct a mask to implement fast queue wrap-around.

#define SYSCALL_LOG_FN_ENTRY 		(1 << 0)
#define SYSCALL_LOG_FN_EXIT 		(1 << 1)

typedef struct {
    int		id;									// task->hostthread->id which made the syscall_log entry.
    int		flags;
    int		number;									// Sequential numbering of all syscalls seen.
    const char* fn_name;
} Syscall_Log_Entry;

extern Syscall_Log_Entry syscall_log_circular_queue[ SYSCALL_LOG_ENTRIES ];		// This holds the last thousand or so syscall_log entries made.
extern int   	         syscall_log_next_entry_to_write;				// This points to next index to write in syscall_log_circular_queue[].
extern int		 syscalls_seen;
extern int		 syscall_log_and_ramlog_enabled;				// Starts TRUE, set FALSE in enter_debug_loop() in   src/c/machine-dependent/posix-arithmetic-trap-handlers.c
    //
    // These are defined in src/c/heapcleaner/heap-debug-stuff.c
    // which also implements debug_syscall_log() to display the contents.


extern void   clear_ramlog  (void);							// clear_ramlog		is from   src/c/main/ramlog.c
extern void   ramlog_printf (char* fmt, ...);						// ramlog_printf	is from   src/c/main/ramlog.c
extern void   debug_ramlog  (int lines_to_print);					// debug_ramlog		is from   src/c/main/ramlog.c
extern void   dump_ramlog__guts (FILE* fd );						// dump_ramlog__guts	is from   src/c/main/ramlog.c
extern void   dump_ramlog__raw  (FILE* fd );						// dump_ramlog__raw	is from   src/c/main/ramlog.c
    //
    // ramlog_printf writes one line into a 64K circular buffer,
    // overwriting old stuff as it goes.  Each fmt should end
    // with a '\n' and contain no other '\n's and no '\0's.
    // As a practical matter I recommend a format like
    //     ramlog_printf("#%d ...\n", syscalls_seen, ...);
    // so as to allow correlation with the syscall log.	
    //
    // debug_ramlog() lists the last n lines in ramlog;
    // it is intended to be called interactively from gdb.
    //
    // The idea of ramlog is to allow logging stuff which would
    // be too voluminous for logging to disk, so that we can at
    // least still see the last few entries after a segfault or
    // such.

inline int syscall_log_nex2( int i) { return (i+2) & SYSCALL_LOG_MASK; }
inline int syscall_log_next( int i) { return (i+1) & SYSCALL_LOG_MASK; }
inline int syscall_log_prev( int i) { return (i-1) & SYSCALL_LOG_MASK; }
inline int syscall_log_pre2( int i) { return (i-2) & SYSCALL_LOG_MASK; }

inline void  note_fn_entry_in_syscall_log   (Task* task, const char* fn_name) {
    //       ============================
    //
    if (!syscall_log_and_ramlog_enabled)   return;

    int e = syscall_log_next_entry_to_write;

    ++ syscalls_seen;

    Syscall_Log_Entry* r =  &syscall_log_circular_queue[ syscall_log_pre2( e ) ];

    if (r->fn_name == fn_name) {
        //
	r->number = syscalls_seen;

    } else {

	syscall_log_next_entry_to_write =   syscall_log_next( e );				// No hostthread mutual exclusion here; I'm not too worried about very occasionally losing a syscall_log entry.
	//
	r =  &syscall_log_circular_queue[  e ];
	//
	r->fn_name = fn_name;
	r->id      = task->hostthread->id;
	r->flags   = SYSCALL_LOG_FN_ENTRY;
	r->number  = syscalls_seen;
    }
}

inline void  note_fn_exit_in_syscall_log   (Task* task, const char* fn_name) {
    //       ===========================
    //
    if (!syscall_log_and_ramlog_enabled)   return;

    int e = syscall_log_next_entry_to_write;

    ++ syscalls_seen;

    Syscall_Log_Entry* r =  &syscall_log_circular_queue[ syscall_log_pre2( e ) ];

    if (r->fn_name == fn_name) {
        //
	r->number = syscalls_seen;

    } else {
	syscall_log_next_entry_to_write =   syscall_log_next( e );				// No hostthread mutual exclusion here; I'm not too worried about very occasionally losing a syscall_log entry.
	//
	r =  &syscall_log_circular_queue[  e ];
	//
	r->fn_name = fn_name;
	r->id      = task->hostthread->id;
	r->flags   = SYSCALL_LOG_FN_EXIT;
	r->number  = syscalls_seen;
    }
}

extern int   portable_signal_id_to_host_os_signal_id(  int   signal_id       );			// portable_signal_id_to_host_os_signal_id	is from   src/c/machine-dependent/interprocess-signals.c
extern int   host_os_signal_id_to_portable_signal_id(  int   signal_id       );			// host_os_signal_id_to_portable_signal_id	is from   src/c/machine-dependent/interprocess-signals.c
extern int   ascii_signal_name_to_portable_signal_id(  char* signal_name     );			// ascii_signal_name_to_portable_signal_id	is from   src/c/machine-dependent/interprocess-signals.c
extern int   maximum_valid_portable_signal_id(         void                  );			// maximum_valid_portable_signal_id		is from   src/c/machine-dependent/interprocess-signals.c
extern void  c_fake_signal_handler( int hostthread_id, int portable_signal_id);			// c_fake_signal_handler			is from   src/c/machine-dependent/interprocess-signals.c

#endif // _ASM_ 



#ifndef HEAP_IMAGE_SYMBOL
#define HEAP_IMAGE_SYMBOL       "lib7_heap_image"
#define HEAP_IMAGE_LEN_SYMBOL   "lib7_heap_image_len"

#endif




#endif // RUNTIME_BASE_H



//////////////////////////////////////////////////////////////////////////////
//
// Note[1]:
//
//     RELEASE_MYTHRYL_HEAP
//     RECOVER_MYTHRYL_HEAP
//
// The problem to be solved here is that when
// multiple hostthreads (kernel threads) share the
// Mythryl heap, all threads must enter heapcleaning
// mode before heapcleaning can begin, which happens
// about 200 times per second:  If one hostthread is
// blocked in a sleep() or select() or whatever for
// a long time (on the millisecond scale), all other
// hostthreads will wind up dead in the water until the
// offending hostthread finally wakes up, defeating much
// of the point of having multiple hostthreads running.
//
// Our solution is that any hostthread starting a potentially
// lengthy C operation (which does not involve the Mythryl heap!)
// should do
//
//     RELEASE_MYTHRYL_HEAP( task->hostthread, __func__, &arg );		// Pass &arg if 'arg' (or any part of it) is live at this point, else NULL.
//         //
//         slow_c_operation_not_using_mythryl_heap();
//         //
//     RECOVER_MYTHRYL_HEAP( task->hostthread, __func__ );
//
//  (These are expected to be used in one of the 
//  Mythryl/C interface fns taking (Task* task, Val arg)
//  as arguments. Think very carefully before using them
//  elsewhere -- there may be Val args in the caller which
//  are unprotected from the heapcleaner!)
//
// Those macros can then explicitly remove the hostthread from
// the 'active' set (by changing hostthread->mode from
// HOSTTHREAD_IS_RUNNING to HOSTTHREAD_IS_BLOCKED) before
// the slow operation and then changing hostthread->mode back to
// HOSTTHREAD_IS_RUNNING afterward, with of course proper
// mutex protection on the latter to assure that the hostthread
// does not attempt to resume using the heap during heapcleaning.
//
// NB: Because the heapcleaner (garbage collector) may move
//     things around -- and delete them! -- you must:
//
//     o  Use the third arg to RELEASE_MYTHRYL_HEAP
//        to protect the main Val arg to the fn if
//        any part of 'arg' is live, else pass NULL.
//
//     o  NOT reference the Mythryl heap in any
//        way between RELEASE_MYTHRYL_HEAP and
//        RECOVER_MYTHRYL_HEAP.
//
//     o  Treat all Mythryl-heap references -except-
//        'arg' as garbage after RECOVER_MYTHRYL_HEAP,
//        re-fetching them as necessary. 
//
// The functions
//
//     buffer_mythryl_heap_value
//   unbuffer_mythryl_heap_value
//
// may be used to buffer Mythryl heap value(s) in C
// (i.e., on the C stack or heap) for use between
//
//     RELEASE_MYTHRYL_HEAP
//     RECOVER_MYTHRYL_HEAP
//
// Examples of doing do may be found in (for example):
// 
//     src/c/lib/posix-file-system/openf.c
//     src/c/lib/posix-file-system/opendir.c
//     src/c/lib/posix-file-system/chown.c
//     src/c/lib/posix-file-system/chmod.c



// COPYRIGHT (c) 1992 AT&T Bell Laboratories
// Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
// released per terms of SMLNJ-COPYRIGHT.


