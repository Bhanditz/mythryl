// runtime-globals.h
//
// These are global refcells readable and writable
// by both C run-time code and Mythryl code.



#ifndef RUNTIME_GLOBALS_H
#define RUNTIME_GLOBALS_H

#include "runtime-values.h"


extern Val*  c_roots__global[];						// A table of pointers to global C variables that are potential garbage-collection roots.
extern int   c_roots_count__global;					// c_roots__global and c_roots_count__global	are from   src/c/main/construct-runtime-package.c


// "Current function" hook for profiling:
//
extern Val	this_fn_profiling_hook_refcell__global   [];
#define         THIS_FN_PROFILING_HOOK_REFCELL__GLOBAL   PTR_CAST( Val,  this_fn_profiling_hook_refcell__global +1 )

// Pointer to the pervasive package:
//
extern Val	pervasive_package_pickle_list_refcell__global	[];
#define		PERVASIVE_PACKAGE_PICKLE_LIST_REFCELL__GLOBAL		PTR_CAST( Val,  pervasive_package_pickle_list_refcell__global +1 )

// Hook to pass POSIX interprocess signals up to the Mythryl level.
// Incoming posix signals are noted by   c_signal_handler   in
//     src/c/machine-dependent/interprocess-signals.c
// which sets a
//     hostthread->interprocess_signal_pending
// flag which gets noticed next pass through by the logic in
//     src/c/main/run-mythryl-code-and-runtime-eventloop.c
// which then (via our pointer here) arranges to 'return' to
// the mythryl-side function
//     root_mythryl_handler_for_posix_signals
// in
//     src/lib/std/src/nj/interprocess-signals-guts.pkg
// All POSIX signals are handled via this single hook;
// individual signals are distinguished
//
extern Val	posix_interprocess_signal_handler_refcell__global	[];
#define		POSIX_INTERPROCESS_SIGNAL_HANDLER_REFCELL__GLOBAL	PTR_CAST( Val,  posix_interprocess_signal_handler_refcell__global + 1 )



// The _id0 extensions here are generated by LIB7_EXNID in
//     src/c/main/construct-runtime-package.c
//
extern Val      runtime_exception__global_id0	[];
#define         RUNTIME_EXCEPTION__GLOBAL	PTR_CAST( Val,  runtime_exception__global_id0  +1 )
//
extern Val	divide_exception__global_id0	[];
#define		DIVIDE_EXCEPTION__GLOBAL		PTR_CAST( Val,  divide_exception__global_id0   +1 )
//
extern Val	overflow_exception__global_id0	[];
#define         OVERFLOW_EXCEPTION__GLOBAL	PTR_CAST( Val,  overflow_exception__global_id0 +1 )



extern Val   runtime_package__global;
    //
    // This will point to a carefully constructed fake which
    // looks like a normal compiled package from the Mythryl
    // side but actually links to compiled C+assembly code.
    // It gets constructed in
    //
    //     src/c/main/construct-runtime-package.c
    //
    // and then patched in by a special hack
    //	
    //     src/c/main/load-compiledfiles.c


#ifdef ASM_MATH
    extern Val mathvec__global;
#endif

#if defined(ASM_MATH)
    //
    extern Val ln_id__global_id0[];						// Referenced only on following line.
    #define    LN_ID__GLOBAL  PTR_CAST( Val,  ln_id__global_id0 +1)		// Referenced only in   src/c/main/construct-runtime-package.c
    //
    extern Val sqrt_id__global_id0[];						// Referenced only on following line. 
    #define    SQRT_ID__GLOBAL PTR_CAST( Val,  sqrt_id__global_id0 +1)		// Referenced only in   src/c/main/construct-runtime-package.c
#endif										// Is there any reason not to just move this stuff to construct-runtime-package.c?  XXX BUGGO FIXME


////////////////////////////////////////////////////////////////
// Signal/event-handling assembly code support.
// ============================================
//
// The following four globals are assembly code
// from (depending upon platform) one of:
//
//     src/c/machine-dependent/prim.intel32.asm
//     src/c/machine-dependent/prim.intel32.masm
//     src/c/machine-dependent/prim.sparc32.asm
//     src/c/machine-dependent/prim.pwrpc32.asm
//
// resume_after_handling_signal
//     Code to to resume execution from where we were
//     before we went off to handle an interprocess signal.
//     This is a standard two-argument function.
// 
// return_from_signal_handler_c
//     This gets generated by a
//         ASM_CONT(return_from_signal_handler)
//     statement in
//         src/c/main/construct-runtime-package.c
//     and maps to
//         return_from_signal_handler_asm
//     in one of the above four assembly files.  (Presumably
//     "_c" for the C world and "_asm" for the assembly world.)
//
extern Val  resume_after_handling_signal [];
extern Val* return_from_signal_handler_c;
//
extern Val  resume_after_handling_software_generated_periodic_event [];
extern Val* return_from_software_generated_periodic_event_handler_c;
    //
    // Just like the previous two.
//
extern Val  call_cfun_v[];							// See   call_cfun_asm                           in   src/c/machine-dependent/prim.intel32.asm  (and more generally src/c/machine-dependent/prim*asm)
extern Val  handle_uncaught_exception_closure_v[];				// See   handle_uncaught_exception_closure_asm   in   src/c/machine-dependent/prim.intel32.asm  (and more generally src/c/machine-dependent/prim*asm)
extern Val* return_to_c_level_c;						// See   return_to_c_level_asm                   in   src/c/machine-dependent/prim.intel32.asm  (and more generally src/c/machine-dependent/prim*asm)
    //
    // The above three get actually defined by the statements
    //
    //     ASM_CLOSURE(call_cfun);
    //     ASM_CLOSURE(handle_uncaught_exception_closure);
    //     ASM_CONT(return_to_c_level);
    //
    // in
    //
    //     src/c/main/construct-runtime-package.c
    //
    // but refer ultimately to the assembly language functions
    //
    //     handle_uncaught_exception_closure_asm
    //     call_cfun_asm
    //     return_to_c_level_asm
    // 
    // from the above four assembly files.

extern Val   software_generated_periodic_events_handler_refcell__global   [];
#define      SOFTWARE_GENERATED_PERIODIC_EVENTS_HANDLER_REFCELL__GLOBAL   PTR_CAST( Val,  software_generated_periodic_events_handler_refcell__global +1 )


/////////////////////////////////////////////////////////////////
// Software generated periodic events, and multicore references.
//

extern Val  software_generated_periodic_event_interval_refcell__global   [];
#define     SOFTWARE_GENERATED_PERIODIC_EVENT_INTERVAL_REFCELL__GLOBAL   PTR_CAST( Val,  software_generated_periodic_event_interval_refcell__global +1 )

extern Val   software_generated_periodic_events_switch_refcell__global  [];
#define      SOFTWARE_GENERATED_PERIODIC_EVENTS_SWITCH_REFCELL__GLOBAL  PTR_CAST( Val,  software_generated_periodic_events_switch_refcell__global +1)

extern Val   microthread_switch_lock_refcell__global   [];
#define      MICROTHREAD_SWITCH_LOCK_REFCELL__GLOBAL   PTR_CAST( Val,  microthread_switch_lock_refcell__global +1 )
    //
    // Set in:             src/c/hostthread/hostthread-on-posix-threads.c
    // Read in:            src/lib/src/lib/thread-kit/src/core-thread-kit/microthread-preemptive-scheduler.pkg
    // C declaration:      src/c/h/runtime-globals.h
    // C defininition:     src/c/main/construct-runtime-package.c
    // Mythryl declation:  src/lib/core/init/runtime.api
    // Mythryl definition: src/lib/core/init/runtime.pkg 
    // Semantics:          Counts number of hostthread-level mutexes held by the hostthread running microthread-preemptive-scheduler.pkg
    // Rationale:          It is essential not to switch between microthreads while holding a mutex:
    //                     some other microthread will promptly try to acquire the same mutex and
    //                     block, hanging the system.  Trying to enforce this retail at the Mythryl
    //                     level proved error-prone (e.g., the call to increment the counter can
    //                     trigger a garbage collector probe and thus a microthread switch before
    //                     the counter gets incremented; also, it is easy to forget to do this on
    //                     some mutex call) so we switched to maintaining the count at the C level,
    //                     in the un/lock mutex functions.  But the count needs to be tested at the
    //                     Mythryl level in alarm_handler() in microthread-preemptive-scheduler.pkg,
    //                     so the refcell needs to be visible at both C and Mythryl levels, hence its
    //                     declaration here rather than at the Mythryl level. 
    //


extern void   set_up_list_of_c_functions_callable_from_mythryl   ();				// set_up_list_of_c_functions_callable_from_mythryl		def in    src/c/lib/mythryl-callable-c-libraries.c
extern Val    find_mythryl_callable_c_function   (char* lib_name, char* fun_name);		// find_mythryl_callable_c_function				def in    src/c/lib/mythryl-callable-c-libraries.c

extern void   publish_runtime_package_contents ();						// publish_runtime_package_contents				def in    src/c/main/construct-runtime-package.c
extern void   construct_runtime_package__global (Task* task);					// construct_runtime_package__global				def in    src/c/main/construct-runtime-package.c


#ifdef SIZES_C_64_MYTHRYL_32
    extern void  patch_static_heapchunk_32_bit_addresses  ();					// From src/c/main/construct-runtime-package.c
#endif

#endif // RUNTIME_GLOBALS_H


// COPYRIGHT (c) 1992 AT&T Bell Laboratories
// Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
// released per terms of SMLNJ-COPYRIGHT.


