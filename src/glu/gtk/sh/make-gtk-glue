#!/usr/bin/mythryl

# To minimize code redundancy and consequent
# reliability and maintenance headaches in
#
#     src/glu/gtk/c/in-sub/mythryl-gtk-library-in-c-subprocess.c
#
# we synthesize simple repetitive functions
# directly from their
#
#     src/glu/gtk/src/gtk-client.api
#
# type declarations.
#
# The specifications for these functions and
# related declarations and docs are in
#
#     src/glu/gtk/etc/library-glue.plan
#
# (See top-of-file comments there.)
#
# We are invoked by doing
# 
#     make gtk-glue
#
# At the top level.  This is not done as part
# of a normal build;  I run it by hand after
# I've updated (say) library-glue.plan

stipulate
    package fil =  file__premicrothread;												# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package lms =  list_mergesort;													# list_mergesort		is from   src/lib/src/list-mergesort.pkg
    package iow =  io_wait_hostthread;													# io_wait_hostthread		is from   src/lib/std/src/hostthread/io-wait-hostthread.pkg
    package mlb =  make_library_binding;												# make_library_binding		is from   src/lib/make-library-glue/make-library-glue.pkg
herein

{    
# iow::test "make-gtk-glue: testt/AAA";



    mlb::make_library_binding
	{
	  lib_name						=>  "gtk",								# Must match the   #define CLIB_NAME "gtk"   line in   src/glu/gtk/c/in-main/libmythryl-gtk.c
	  library_binding_specification				=>  "src/glu/gtk/etc/library-glue.plan",
	  xxx_client_api					=>  "src/glu/gtk/src/gtk-client.api",
	  xxx_client_g_pkg					=>  "src/glu/gtk/src/gtk-client-g.pkg",
	  xxx_client_driver_api					=>  "src/glu/gtk/src/gtk-client-driver.api",
	  xxx_client_driver_for_library_in_c_subprocess_pkg	=>  "src/glu/gtk/src/gtk-client-driver-for-library-in-c-subprocess.pkg",
	  xxx_client_driver_for_library_in_main_process_pkg	=>  "src/glu/gtk/src/gtk-client-driver-for-library-in-main-process.pkg",
	  mythryl_xxx_library_in_c_subprocess_c			=>  "src/glu/gtk/c/in-sub/mythryl-gtk-library-in-c-subprocess.c",
	  libmythryl_xxx_c					=>  "src/glu/gtk/c/in-main/libmythryl-gtk.c",
	  section_libref_xxx_tex				=>  "src/glu/gtk/doc/tex/section-libref-gtk.tex"
	}
	[																# Plugins that extend base mlb functionality.
	  mlb::LIBCALL_TO_ARGS_FN  libcall_to_args_fn,
	  mlb::BUILD_A ("callback-fn", build_callback_function),
	  #
	  mlb::BUILD_ARG_LOAD_FOR_MYTHRYL_XXX_LIBRARY_IN_C_SUBPROCESS_C ("w", build_arg_load_for_w_in_c_subprocess),
	  mlb::BUILD_ARG_LOAD_FOR_MYTHRYL_XXX_LIBRARY_IN_MAIN_PROCESS_C ("w", build_arg_load_for_w_in_main_process),
	  #
	  mlb::BUILD_CUSTOM_BODY_PLAIN_FUN_FOR_'MYTHRYL_XXX_LIBRARY_IN_C_SUBPROCESS_C' ("new Widget", new_widget_custom_body_plain_fun_subprocess),
	  mlb::BUILD_CUSTOM_BODY_PLAIN_FUN_FOR_'MYTHRYL_XXX_LIBRARY_IN_C_SUBPROCESS_C' (    "Widget",     widget_custom_body_plain_fun_subprocess),
	  #
	  mlb::BUILD_CUSTOM_BODY_PLAIN_FUN_FOR_'LIBMYTHRYL_XXX_C'                      ("new Widget", new_widget_custom_body_plain_fun_mainprocess),
	  mlb::BUILD_CUSTOM_BODY_PLAIN_FUN_FOR_'LIBMYTHRYL_XXX_C'                      (    "Widget",     widget_custom_body_plain_fun_mainprocess),
	  #
	  mlb::FIGURE_FUNCTION_RESULT_TYPE						(   "Widget", figure_function_result_type),
	  #
	  mlb::DO_COMMAND_FOR_'XXX_CLIENT_DRIVER_FOR_LIBRARY_IN_C_SUBPROCESS_PKG' ("new Widget", "do_int_command"),
	  mlb::DO_COMMAND_FOR_'XXX_CLIENT_DRIVER_FOR_LIBRARY_IN_C_SUBPROCESS_PKG' (    "Widget", "do_int_command")
	]
	where
	    fun figure_function_result_type  fn_name
		=
		if (fn_name =~ ./^make_/)   "new Widget";
		else                            "Widget";
		fi;


	    fun new_widget_custom_body_plain_fun_subprocess  { fn_name,  libcall,  to_mythryl_xxx_library_in_c_subprocess_c_funs, path: mlb::Paths}
		=
		{   to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "        int slot = find_free_widget_slot ();\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("        widget[slot] = " + libcall + ";\n");
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(             \"" + fn_name + "%d\\n\", slot);      fflush( stdout );\n");
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT:" + fn_name + "%d\\n\", slot);      fflush( log_fd );\n");
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-glue/make-library-glue.pkg:  build_plain_fun_for_'mythryl_xxx_library_in_c_subprocess_c'  per  " + path.library_binding_specification + ". */\n");
		};

	    fun widget_custom_body_plain_fun_subprocess  { fn_name,  libcall,  to_mythryl_xxx_library_in_c_subprocess_c_funs, path: mlb::Paths }
		=
		{   to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("        GtkWidget* widget = (GtkWidget*) " + libcall + ";\n");
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "        int slot = get_widget_id( widget );\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(              \"" + fn_name + "%d\\n\", slot);      fflush( stdout );\n");
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%d\\n\", slot);      fflush( log_fd );\n");
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-glue/make-library-glue.pkg:  build_plain_fun_for_'mythryl_xxx_library_in_c_subprocess_c'  per  " + path.library_binding_specification + ". */\n");
		};

	    fun new_widget_custom_body_plain_fun_mainprocess  { fn_name,  libcall,  to_libmythryl_xxx_c_funs, path: mlb::Paths }
		=
		{   to_libmythryl_xxx_c_funs  "\n";
		    to_libmythryl_xxx_c_funs  "    int slot = find_free_widget_slot ();\n";
		    to_libmythryl_xxx_c_funs  "\n";
		    to_libmythryl_xxx_c_funs ("    widget[slot] = " + libcall + ";\n");
		    to_libmythryl_xxx_c_funs  "\n";
		    to_libmythryl_xxx_c_funs  "    return TAGGED_INT_FROM_C_INT(slot);\n";
		};

	    fun widget_custom_body_plain_fun_mainprocess  { fn_name,  libcall,  to_libmythryl_xxx_c_funs, path: mlb::Paths }
		=
		{   to_libmythryl_xxx_c_funs  "\n";
		    to_libmythryl_xxx_c_funs ("    GtkWidget* widget = (GtkWidget*) " + libcall + ";\n");
		    to_libmythryl_xxx_c_funs  "\n";
		    to_libmythryl_xxx_c_funs  "    int slot = get_widget_id( widget );\n";
		    to_libmythryl_xxx_c_funs  "\n";
		    to_libmythryl_xxx_c_funs  "    return TAGGED_INT_FROM_C_INT(slot);\n";
		};



	    fun libcall_to_args_fn  libcall
		=
		# libcall contains embedded arguments like w0, i1, f2, b3, s4.
		#
		# The argument letter gives us the argument type:
		#
		#    w == widget
		#    i == int
		#    f == double  (Mythryl "Float")
		#    b == bool
		#    s == string
		#
		# The argument digit gives us the argument order:
		#
		#    0 == first arg
		#    1 == second arg
		#    ...
		#
		# Get list of above args, sorting by
		# trailing digit and dropping duplicates.
		#
		# Our implementation here differs from the
		# default implementation in 
		#
		#     src/lib/make-library-glue/make-library-glue.pkg
		#
		# only by adding support for 'w' ("widget"):
		#
		{    raw_list    =  regex::find_all  ./\b[bfisw][0-9]\b/  libcall;
		    #
		    cooked_list =  uniquesort  compare_fn  raw_list;

		    cooked_list;
		}
		where	
		    fun compare_fn (xn, yn)					# Compare "w0" and "b1" as "0" and "1":
			=
			{   xn' = string::extract (xn, 1, NULL);
			    yn' = string::extract (yn, 1, NULL);

			    string::compare (xn', yn');
			};
		end;        


	    fun build_arg_load_for_w_in_c_subprocess  (arg_type, a, libcall)
		=
		{
		    # Usually we fetch a widget as just
		    #
		    #    GtkWidget* widget    =  widget_arg( argc, argv, 0 );
		    #
		    # or such, but in a few cases we must cast to
		    # another type:
		    #  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)   widget_arg( argc, argv, 0 );
		    #  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)        widget_arg( argc, argv, 0 );
		    #  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0 =  (GtkRadioButton*)  widget_arg( argc, argv, 0 );

		    widget_type
			=
			if   (libcall =~ (sprintf   "GTK_ADJUSTMENT\\(\\s*w%d\\s*\\)" a))   "GtkAdjustment";
			elif (libcall =~ (sprintf        "GTK_SCALE\\(\\s*w%d\\s*\\)" a))   "GtkScale";
			elif (libcall =~ (sprintf "GTK_RADIO_BUTTON\\(\\s*w%d\\s*\\)" a))   "GtkRadioButton";
			else								    "GtkWidget";
			fi;

		    sprintf  "        %-14s    w%d =    %-16s  widget_arg( argc, argv, %d );\n" (widget_type + "*") a  ("(" + widget_type + "*)") a;
		};


	    fun build_arg_load_for_w_in_main_process  (arg_type, a, libcall)
		=
		{
		    # Usually we fetch a widget as just
		    #
		    #    GtkWidget* widget    =  widget_arg( argc, argv, 0 );
		    #
		    # or such, but in a few cases we must cast to
		    # another type:
		    #  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)   widget_arg( argc, argv, 0 );
		    #  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)        widget_arg( argc, argv, 0 );
		    #  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0 =  (GtkRadioButton*)  widget_arg( argc, argv, 0 );

		    widget_type
			=
			if   (libcall =~ (sprintf   "GTK_ADJUSTMENT\\(\\s*w%d\\s*\\)" a))   "GtkAdjustment";
			elif (libcall =~ (sprintf        "GTK_SCALE\\(\\s*w%d\\s*\\)" a))   "GtkScale";
			elif (libcall =~ (sprintf "GTK_RADIO_BUTTON\\(\\s*w%d\\s*\\)" a))   "GtkRadioButton";
			else								    "GtkWidget";
			fi;

		    sprintf  "    %-14s    w%d  =    %-16s  widget[ GET_TUPLE_SLOT_AS_INT( arg, %d) ];\n"
			      (widget_type + "*")
			      a
			      ("(" + widget_type + "*)")
			      (a+1)				# +1 because first arg is always Session.
		    ;
		};


	    fun build_callback_function (r: mlb::Builder_Stuff)
		=
		{
		    fn_name  =  r.get_field(r.state, "fn-name");		# "set_foo_callback"
		    fn_type  =  r.get_field(r.state, "fn-type");		# "Session -> Widget -> Foo_Callback -> Void"
		    lowtype  =  r.get_field(r.state, "lowtype");		# "G_OBJECT"

		    callback_name
			=
			(regex::find_first_group 1 ./^set_(.*)_callback$/  fn_name)
			except
			    NOT_FOUND
				=
				die_x(sprintf "%s: callback-fn fn-name '%s' does not have form 'set_foo_callback' for any 'foo'\n"
					     (r.get_field_location (r.state, "fn-name"))
					     fn_name
				    );

		    callback_type		# E.g., "Void_Callback"
			=
			(regex::find_first_group 1 ./^Session\s+->\s+Widget\s+->\s+(\S+)\s+->\s+Void$/ fn_type)
			except
			    NOT_FOUND
				=
				die_x(sprintf "%s: callback-fn fn-type '%s' does not have form 'Session -> Widget -> Foo_Callback -> Void' for any 'foo'\n"
					     (r.get_field_location (r.state, "fn-type"))
					     fn_type
				    );

		    callback_name =   regex::replace_all  ./'/  "2"  callback_name;		# Primes don't work in C!

		    c_fn_name =  "set_"  +  callback_name  +  "_callback";

		    build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c'( r, callback_name,          lowtype );
		    build_set_callback_fn_for_'libmythryl_xxx_c'(                      r, callback_name, fn_type, lowtype );

		    r.build_table_entry_for_'libmythryl_xxx_c' (c_fn_name, fn_type);
		    r.build_trie_entry_for_'mythryl_xxx_library_in_c_subprocess_c'  (c_fn_name );

		    url =   case (r.maybe_get_field (r.state, "url"))
				#
				THE field =>  field;
				NULL      =>  "http://library.gnome.org/devel/gobject/unstable/gobject-Signals.html#g-signal-connect";
			    esac;

		    r.note__section_libref_xxx_tex__entry { state => r.state, fn_name, url, fn_type, libcall => "g_signal_connect" };

		    libcall     = "w0";		# Give arg counts and types to the following two functions.
		    result_type = "Int";		# Give result information   to the following two functions.

		    r.build_fun_declaration_for_'xxx_client_driver_api'				(c_fn_name, libcall, result_type);
		    r.build_fun_definition_for_'xxx_client_driver_for_library_in_c_subprocess_pkg'	(c_fn_name, libcall, result_type);

		    r.build_fun_declaration_for_'xxx_client_api'					(fn_name, fn_type);
		    r.build_fun_definition_for_'xxx_client_driver_for_library_in_main_process_pkg'	(fn_name, c_fn_name, fn_type, libcall, result_type);

		    r.build_callback_fun_for_'xxx_client_g_pkg'( 				  r.state, fn_name, callback_type);
		}
		where
		    # Synthesize a function for   mythryl-xxx-library-in-c-subprocess.c  like
		    #
		    #    static void
		    #    do__set_foo_callback( int argc, unsigned char** argv )
		    #    {
		    #	check_argc( "do__foo_callback", 1, argc );
		    #
		    #	{   GtkWidget* widget    =  widget_arg( argc, argv, 0 );
		    #
		    #	    int id   =  find_free_callback_id ();
		    #
		    #	    g_signal_connect( G_OBJECT(widget), "foo", G_CALLBACK( run_foo_callback ), (void*)id );
		    #
		    #	    printf(               "set_foo_callback%d\n", id );	fflush( stdout );
		    #	    fprintf(log_fd, "SENT: set_foo_callback%d\n", id );	fflush( log_fd );
		    #	}
		    #    }
		    #
		    fun build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c' (r: mlb::Builder_Stuff, callback_name, lowtype)
			=
    # The logic here has
    # inputs:
    #     callback_name
    #     lowtype
    # output:
    #     String
			{   r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "static void\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("do__set_" + callback_name + "_callback( int argc, unsigned char** argv )\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "{\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("    check_argc( \"do__set_" + callback_name + "_callback\", 1, argc );\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "    {   GtkWidget* widget    =  widget_arg( argc, argv, 0 );\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "        int id   =  find_free_callback_id ();\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("        g_signal_connect( " + lowtype + "(widget), \"" + callback_name + "\", G_CALLBACK( run_" + callback_name + "_callback ), (void*)id );\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(              \"set_" + callback_name + "_callback%d\\n\", id );      fflush( stdout );\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT: set_" + callback_name + "_callback%d\\n\", id );      fflush( log_fd );\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-glue/make-library-glue.pkg:  build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c'  per  " + r.path.library_binding_specification + ".*/\n");

			    r.custom_fns_autobuilt_for_'mythryl_xxx_library_in_c_subprocess_c'
				:=
				*r.custom_fns_autobuilt_for_'mythryl_xxx_library_in_c_subprocess_c'
				+ 1;
			};

		    # Synthesize a function for   libmythryl-xxx.c  like
		    #
		    #   /* do__set_foo_callback : Session -> Widget -> Void_Callback -> Void;
		    #    */
		    #   static Val do__set_foo_callback (Task* task, Val arg)
		    #   {
		    #       GtkWidget*        w0 =    (GtkWidget*)      widget[ GET_TUPLE_SLOT_AS_INT( arg, 1) ];	// '1' because 'arg' is a duple (session, widget).
		    #
		    #       int id   =  find_free_callback_id ();
		    #
		    #       g_signal_connect( G_OBJECT(widget), "clicked", G_CALLBACK( run_clicked_callback ), (void*)id );
		    #
		    #       return TAGGED_INT_FROM_C_INT(id);
		    #   }
		    #    
		    fun build_set_callback_fn_for_'libmythryl_xxx_c'
			( r: mlb::Builder_Stuff,
			  callback_name,
			  fn_type,			# E.g., "Session -> Widget -> Void_Callback -> Void".
			  lowtype
			)
			=
    # The logic here has
    # inputs:
    #     callback_name
    #     fn_type
    #     lowtype
    # output:
    #     String
			{   r.to_libmythryl_xxx_c_funs "\n";
			    r.to_libmythryl_xxx_c_funs "\n";
			    r.to_libmythryl_xxx_c_funs("/*  do__set_" + callback_name + "_callback : " + fn_type + "\n");
			    r.to_libmythryl_xxx_c_funs " */\n";
			    r.to_libmythryl_xxx_c_funs("static Val   do__set_" + callback_name + "_callback (Task* task, Val arg)\n");
			    r.to_libmythryl_xxx_c_funs "{\n";
			    r.to_libmythryl_xxx_c_funs  "\n";
			    r.to_libmythryl_xxx_c_funs  "    GtkWidget*        w0 __attribute__((unused)) =    (GtkWidget*)      widget[ GET_TUPLE_SLOT_AS_INT( arg, 1) ];        // '1' because 'arg' is a duple (session, widget).\n";
			    r.to_libmythryl_xxx_c_funs  "\n";		# The '__attribute__((unused))' is just to suppress some   unused variable 'w0'   compiler warnings.
			    r.to_libmythryl_xxx_c_funs "    int id   =  find_free_callback_id ();\n";
			    r.to_libmythryl_xxx_c_funs "\n";
			    r.to_libmythryl_xxx_c_funs("    g_signal_connect( " + lowtype + "(w0), \"" + callback_name + "\", G_CALLBACK( run_" + callback_name + "_callback ), (void*)id );\n");
			    r.to_libmythryl_xxx_c_funs "\n";
			    r.to_libmythryl_xxx_c_funs "    return TAGGED_INT_FROM_C_INT(id);\n";
			    r.to_libmythryl_xxx_c_funs  "}\n";
			    r.to_libmythryl_xxx_c_funs("/* Above fn built by src/lib/make-library-glue/make-library-glue.pkg:  build_set_callback_fn_for_'libmythryl_xxx_c'  per  " + r.path.library_binding_specification + ".*/\n");
			    r.to_libmythryl_xxx_c_funs  "\n";
			    r.to_libmythryl_xxx_c_funs  "\n";

			    r.custom_fns_autobuilt_for_'libmythryl_xxx_c'
				:=
				*r.custom_fns_autobuilt_for_'libmythryl_xxx_c'
				+ 1;
			};
		end;


	end;

    exit_x(0);
};
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
