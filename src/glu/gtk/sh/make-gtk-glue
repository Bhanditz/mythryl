#!/usr/bin/mythryl

# To minimize code redundancy and consequent
# reliability and maintenance headaches in
#
#     src/glu/gtk/c/in-sub/mythryl-gtk-library-in-c-subprocess.c
#
# we synthesize simple repetitive functions
# directly from their
#
#     src/glu/gtk/src/gtk-client.api
#
# type declarations.
#
# The specifications for these functions and
# related declarations and docs are in
#
#     src/glu/gtk/etc/library-glue.plan
#
# (See top-of-file comments there.)
#
# We are invoked by doing
# 
#     make gtk-glue
#
# At the top level.  This is not done as part
# of a normal build;  I run it by hand after
# I've updated (say) library-glue.plan

stipulate
    package fil =  file__premicrothread;												# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package lms =  list_mergesort;													# list_mergesort		is from   src/lib/src/list-mergesort.pkg
    package iow =  io_wait_hostthread;													# io_wait_hostthread		is from   src/lib/std/src/hostthread/io-wait-hostthread.pkg
    package mlb =  make_library_binding;												# make_library_binding		is from   src/lib/make-library-glue/make-library-glue.pkg
herein

{    
# iow::test "make-gtk-glue: testt/AAA";



    mlb::make_library_binding
	{
	  lib_name						=>  "gtk",								# Must match the   #define CLIB_NAME "gtk"   line in   src/glu/gtk/c/in-main/libmythryl-gtk.c
	  library_binding_specification				=>  "src/glu/gtk/etc/library-glue.plan",
	  xxx_client_api					=>  "src/glu/gtk/src/gtk-client.api",
	  xxx_client_g_pkg					=>  "src/glu/gtk/src/gtk-client-g.pkg",
	  xxx_client_driver_api					=>  "src/glu/gtk/src/gtk-client-driver.api",
	  xxx_client_driver_for_library_in_c_subprocess_pkg	=>  "src/glu/gtk/src/gtk-client-driver-for-library-in-c-subprocess.pkg",
	  xxx_client_driver_for_library_in_main_process_pkg	=>  "src/glu/gtk/src/gtk-client-driver-for-library-in-main-process.pkg",
	  mythryl_xxx_library_in_c_subprocess_c			=>  "src/glu/gtk/c/in-sub/mythryl-gtk-library-in-c-subprocess.c",
	  libmythryl_xxx_c					=>  "src/glu/gtk/c/in-main/libmythryl-gtk.c",
	  section_libref_xxx_tex				=>  "src/glu/gtk/doc/tex/section-libref-gtk.tex"
	}
	[																# Plugins that extend base mlb functionality.
	  mlb::LIBCALL_TO_ARGS_FN  libcall_to_args_fn,
	  mlb::BUILD_A ("callback-fn", build_callback_function),
	  #
	  mlb::BUILD_ARG_LOAD_FOR_'MYTHRYL_XXX_LIBRARY_IN_C_SUBPROCESS' ("w", build_arg_load_for_'mythryl_xxx_library_in_c_subprocess_c'),
	  mlb::BUILD_ARG_LOAD_FOR_'LIBMYTHRYL_XXX_C'                    ("w", build_arg_load_for_'libmythryl_xxx_c'),
	  #
	  mlb::HANDLE_NONSTANDARD_RESULT_TYPE_FOR__BUILD_PLAIN_FUN_FOR__'MYTHRYL_XXX_LIBRARY_IN_C_SUBPROCESS_C' ("new Widget", handle_'new_widget'_result_type_for__build_plain_fun_for_'mythryl_xxx_library_in_c_subprocess_c'),
	  mlb::HANDLE_NONSTANDARD_RESULT_TYPE_FOR__BUILD_PLAIN_FUN_FOR__'MYTHRYL_XXX_LIBRARY_IN_C_SUBPROCESS_C' (    "Widget",     handle_'widget'_result_type_for__build_plain_fun_for_'mythryl_xxx_library_in_c_subprocess_c'),
	  #
	  mlb::HANDLE_NONSTANDARD_RESULT_TYPE_FOR__BUILD_PLAIN_FUN_FOR__'LIBMYTHRYL_XXX_C'                      ("new Widget", handle_'new_widget'_result_type_for__build_plain_fun_for_'libmythryl_xxx_c'),
	  mlb::HANDLE_NONSTANDARD_RESULT_TYPE_FOR__BUILD_PLAIN_FUN_FOR__'LIBMYTHRYL_XXX_C'                      (    "Widget",     handle_'widget'_result_type_for__build_plain_fun_for_'libmythryl_xxx_c'),
	  #
	  mlb::FIGURE_FUNCTION_RESULT_TYPE						(   "Widget", figure_function_result_type),
	  #
	  mlb::DO_COMMAND_FOR_'XXX_CLIENT_DRIVER_FOR_LIBRARY_IN_C_SUBPROCESS_PKG' ("new Widget", "do_int_command"),			# See   build_fun_definition_for_'xxx_client_driver_for_library_in_c_subprocess_pkg'	in   src/lib/make-library-glue/make-library-glue.pkg
	  mlb::DO_COMMAND_FOR_'XXX_CLIENT_DRIVER_FOR_LIBRARY_IN_C_SUBPROCESS_PKG' (    "Widget", "do_int_command"),			# "                                                                                "
	  #
	  mlb::DO_COMMAND_TO_STRING_FN ("w", "widget_to_string"),									# See   write_do_command								in   src/lib/make-library-glue/make-library-glue.pkg
	  #
	  mlb::CLIENT_DRIVER_ARG_TYPE    ("w",          "Int/*Widget*/"),								# See   xxx_client_driver_api_type							in   src/lib/make-library-glue/make-library-glue.pkg
	  mlb::CLIENT_DRIVER_RESULT_TYPE ("new Widget", "Int /*new Widget*/"),								# See   xxx_client_driver_api_type							in   src/lib/make-library-glue/make-library-glue.pkg
	  mlb::CLIENT_DRIVER_RESULT_TYPE (    "Widget", "Int /*Widget*/")								# See   xxx_client_driver_api_type							in   src/lib/make-library-glue/make-library-glue.pkg
	]
	where
	    # The context here is that
	    #
	    #     build_plain_function
	    # in
	    #     src/lib/make-library-glue/make-library-glue.pkg
	    #
	    # has called   figure_function_result_type
	    #
	    # to compute the result type of the function.
	    # This can be manually specified via a
	    #
	    #     result: Foo
	    #
	    # line in (say)   src/glu/gtk/etc/library-glue.plan
	    #
	    # but is usually resolved to one of
	    #
	    #	"Bool"
	    #	"Float"
	    #	"Int"
	    #	"String"
	    #	"Void"
	    #
	    # just by picking off the final " -> Foo" clause in the fieldset's
	    #
	    #     fn-type:  Zot -> Foo
	    #
	    # line.  However when the type is unrecognized it is handed off to us.
	    # In the case of 'widget' we need to generate different code for a
	    # newly constructed widget vs a pre-existing widget -- see below fns
	    #
	    #    handle_'new_widget'_result_type_for__build_plain_fun_for_'mythryl_xxx_library_in_c_subprocess_c'
	    #    handle_'widget'_result_type_for__build_plain_fun_for_'mythryl_xxx_library_in_c_subprocess_c'
	    #    handle_'new_widget'_result_type_for__build_plain_fun_for_'libmythryl_xxx_c'
	    #    handle_'widget'_result_type_for__build_plain_fun_for_'libmythryl_xxx_c'
	    #
	    # Here we make the required new/old widget distinction
	    # by keying on the 'make_' prefix to the fn_name:
	    #
	    fun figure_function_result_type  fn_name
		=
		if (fn_name =~ ./^make_/)   "new Widget";
		else                            "Widget";
		fi;


	    # The context for the next two fns is that
	    #     build_plain_fun_for_'mythryl_xxx_library_in_c_subprocess_c'
	    # in
	    #     src/lib/make-library-glue/make-library-glue.pkg
	    #
	    # is building a
	    #
	    #     src/glu/gtk/c/in-sub/mythryl-gtk-library-in-c-subprocess.c
	    #
	    # function like	
	    #
	    #	static void
	    #	do__make_label( int argc, unsigned char** argv )
	    #	{
	    #	    check_argc( "do__make_label", 1, argc );
	    #	    {
	    #		char*             s0 =                      string_arg( argc, argv, 0 );
	    #
	    #		int slot = find_free_widget_slot ();
	    #
	    #		widget[slot] = gtk_label_new( /*label*/s0 );
	    #
	    #		 printf(             "make_label%d\n", slot);      fflush( stdout );
	    #		fprintf(log_fd, "SENT:make_label%d\n", slot);      fflush( log_fd );
	    #	    }
	    #	}
	    #
	    # or
	    #	static void
	    #	do__get_white_graphics_context( int argc, unsigned char** argv )
	    #	{
	    #	    check_argc( "do__get_white_graphics_context", 1, argc );
	    #
	    #	    {
	    #		GtkWidget*        w0 =    (GtkWidget*)      widget_arg( argc, argv, 0 );
	    #
	    #		GtkWidget* widget = (GtkWidget*) /*widget*/w0->style->white_gc;
	    #
	    #		int slot = get_widget_id( widget );
	    #
	    #		 printf(              "get_white_graphics_context%d\n", slot);      fflush( stdout );
	    #		fprintf(log_fd, "SENT: get_white_graphics_context%d\n", slot);      fflush( log_fd );
	    #	    }
	    #	}
	    #
	    # but has had to punt to us because the function's return type
	    # is something other than the four standard preprogrammed ones:
	    #
	    #     Void
	    #     Bool
	    #     Float
	    #     Int
	    #
	    fun handle_'new_widget'_result_type_for__build_plain_fun_for_'mythryl_xxx_library_in_c_subprocess_c'  { fn_name,  libcall,  to_mythryl_xxx_library_in_c_subprocess_c_funs, path: mlb::Paths}
		=
		{   to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "        int slot = find_free_widget_slot ();\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("        widget[slot] = " + libcall + ";\n");
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(             \"" + fn_name + "%d\\n\", slot);      fflush( stdout );\n");
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT:" + fn_name + "%d\\n\", slot);      fflush( log_fd );\n");
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-glue/make-library-glue.pkg:  build_plain_fun_for_'mythryl_xxx_library_in_c_subprocess_c'  per  " + path.library_binding_specification + ". */\n");
		};

	    fun handle_'widget'_result_type_for__build_plain_fun_for_'mythryl_xxx_library_in_c_subprocess_c'  { fn_name,  libcall,  to_mythryl_xxx_library_in_c_subprocess_c_funs, path: mlb::Paths }
		=
		{   to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("        GtkWidget* widget = (GtkWidget*) " + libcall + ";\n");
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "        int slot = get_widget_id( widget );\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(              \"" + fn_name + "%d\\n\", slot);      fflush( stdout );\n");
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%d\\n\", slot);      fflush( log_fd );\n");
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
		    to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-glue/make-library-glue.pkg:  build_plain_fun_for_'mythryl_xxx_library_in_c_subprocess_c'  per  " + path.library_binding_specification + ". */\n");
		};



	    # The context for the next two fns is that
	    #     build_plain_fun_for_'libmythryl_xxx_c'
	    # in
	    #     src/lib/make-library-glue/make-library-glue.pkg
	    #
	    # is building a
	    #
	    #     src/glu/gtk/c/in-main/libmythryl-gtk.c
	    #
	    # function like	
	    #
	    #	/* do__make_label
	    #	 *
	    #	 * gtk-client.api        type:   (Session, String) -> Widget
	    #	 * gtk-client-driver.api type:   (Session, String) -> Int (*new Widget*)
	    #	 */
	    #	static Val   do__make_label   (Task* task, Val arg)
	    #	{
	    #	    char*             s0 =   HEAP_STRING_AS_C_STRING (GET_TUPLE_SLOT_AS_VAL( arg, 1));
	    #
	    #	    int slot = find_free_widget_slot ();
	    #
	    #	    widget[slot] = gtk_label_new( /*label*/s0 );
	    #
	    #	    return TAGGED_INT_FROM_C_INT(slot);
	    #	}
	    #
	    # or
	    #
	    #	/* do__get_white_graphics_context
	    #	 *
	    #	 * gtk-client.api        type:   (Session, Widget) -> Widget
	    #	 * gtk-client-driver.api type:   (Session, Int(*Widget*)) -> Int (*Widget*)
	    #	 */
	    #	static Val   do__get_white_graphics_context   (Task* task, Val arg)
	    #	{
	    #	    GtkWidget*        w0  =    (GtkWidget*)      widget[ GET_TUPLE_SLOT_AS_INT( arg, 1) ];
	    #
	    #	    GtkWidget* widget = (GtkWidget*) /*widget*/w0->style->white_gc;
	    #
	    #	    int slot = get_widget_id( widget );
	    #
	    #	    return TAGGED_INT_FROM_C_INT(slot);
	    #	}
	    #
	    # but has had to punt to us because the function's return type
	    # is something other than the four standard preprogrammed ones:
	    #
	    #     Void
	    #     Bool
	    #     Float
	    #     Int
	    #
	    fun handle_'new_widget'_result_type_for__build_plain_fun_for_'libmythryl_xxx_c'  { fn_name,  libcall,  to_libmythryl_xxx_c_funs, path: mlb::Paths }
		=
		{   to_libmythryl_xxx_c_funs  "\n";
		    to_libmythryl_xxx_c_funs  "    int slot = find_free_widget_slot ();\n";
		    to_libmythryl_xxx_c_funs  "\n";
		    to_libmythryl_xxx_c_funs ("    widget[slot] = " + libcall + ";\n");
		    to_libmythryl_xxx_c_funs  "\n";
		    to_libmythryl_xxx_c_funs  "    return TAGGED_INT_FROM_C_INT(slot);\n";
		};

	    fun handle_'widget'_result_type_for__build_plain_fun_for_'libmythryl_xxx_c'  { fn_name,  libcall,  to_libmythryl_xxx_c_funs, path: mlb::Paths }
		=
		{   to_libmythryl_xxx_c_funs  "\n";
		    to_libmythryl_xxx_c_funs ("    GtkWidget* widget = (GtkWidget*) " + libcall + ";\n");
		    to_libmythryl_xxx_c_funs  "\n";
		    to_libmythryl_xxx_c_funs  "    int slot = get_widget_id( widget );\n";
		    to_libmythryl_xxx_c_funs  "\n";
		    to_libmythryl_xxx_c_funs  "    return TAGGED_INT_FROM_C_INT(slot);\n";
		};



	    fun libcall_to_args_fn  libcall
		=
		# We are called (only) by
		#     count_args
		#     get_nth_arg_type
		#     arg_types_are_all_unique
		# in  
		#     src/lib/make-library-glue/make-library-glue.pkg
		#
		# 'libcall' is from a 'libcall:' line in    src/glu/gtk/etc/library-glue.plan
		# looking something like                    libcall: gtk_table_set_row_spacing( GTK_TABLE(/*table*/w0), /*row*/i1, /*spacing*/i2)
		#
		# 'libcall' contains embedded arguments like 'w0', 'i1', 'f2', 'b3', 's4'.
		# They are what we are interested in here;
		# our job is to return a sorted, duplicate-free list of them.
		#
		# The argument letter gives us the argument type:
		#
		#    w == widget
		#    i == int
		#    f == double  (Mythryl "Float")
		#    b == bool
		#    s == string
		#
		# The argument digit gives us the argument order:
		#
		#    0 == first arg
		#    1 == second arg
		#    ...
		#
		# Get list of above args, sorting by
		# trailing digit and dropping duplicates.
		#
		# Our implementation here differs from the
		# default implementation in 
		#
		#     src/lib/make-library-glue/make-library-glue.pkg
		#
		# only by adding support for 'w' ("widget"):
		#
		{    raw_list    =  regex::find_all  ./\b[bfisw][0-9]\b/  libcall;
		    #
		    cooked_list =  uniquesort  compare_fn  raw_list;

		    cooked_list;
		}
		where	
		    fun compare_fn (xn, yn)					# Compare "w0" and "b1" as "0" and "1":
			=
			{   xn' = string::extract (xn, 1, NULL);
			    yn' = string::extract (yn, 1, NULL);

			    string::compare (xn', yn');
			};
		end;        


	    fun build_arg_load_for_'mythryl_xxx_library_in_c_subprocess_c'  (arg_type, a, libcall)
		=
		# The general context here is that we are building some
		#     src/glu/gtk/c/in-sub/mythryl-gtk-library-in-c-subprocess.c
		# fn like
		#
		#	static void
		#	do__make_table( int argc, unsigned char** argv )
		#	{
		#	    check_argc( "do__make_table", 3, argc );
		#
		#	    {
		#		int               i0 =                         int_arg( argc, argv, 0 );
		#		int               i1 =                         int_arg( argc, argv, 1 );
		#		int               b2 =                        bool_arg( argc, argv, 2 );
		#
		#		int slot = find_free_widget_slot ();
		#
		#		widget[slot] = gtk_table_new ( /*rows*/i0, /*cols*/i1, /*homogeneous*/b2 );
		#
		#		 printf(             "make_table%d\n", slot);      fflush( stdout );
		#		fprintf(log_fd, "SENT:make_table%d\n", slot);      fflush( log_fd );
		#	    }
		#	}
		#
		# and we've reached the point of wanting to generate
		# one of the central int_arg/bool_arg/... lines.
		#
		# We will be called by
		#
		#     build_fun_arg_loads_for_'mythryl_xxx_library_in_c_subprocess_c'
		# in
		#     src/lib/make-library-glue/make-library-glue.pkg
		#
		# whenever it encounters an arg type other than
		#
		#     i (int),
		#     b (bool)
		#     s (string)
		#     f (double)
		#
		# This allows us to add support for otherwise unsupported
		# arg types, in particular 'w' for Widget.
		{
		    # Usually we fetch a widget as just
		    #
		    #    GtkWidget* widget    =  widget_arg( argc, argv, 0 );
		    #
		    # or such, but in a few cases we must cast to
		    # another type:
		    #  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)   widget_arg( argc, argv, 0 );
		    #  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)        widget_arg( argc, argv, 0 );
		    #  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0 =  (GtkRadioButton*)  widget_arg( argc, argv, 0 );

		    widget_type
			=
			if   (libcall =~ (sprintf   "GTK_ADJUSTMENT\\(\\s*w%d\\s*\\)" a))   "GtkAdjustment";
			elif (libcall =~ (sprintf        "GTK_SCALE\\(\\s*w%d\\s*\\)" a))   "GtkScale";
			elif (libcall =~ (sprintf "GTK_RADIO_BUTTON\\(\\s*w%d\\s*\\)" a))   "GtkRadioButton";
			else								    "GtkWidget";
			fi;

		    sprintf  "        %-14s    w%d =    %-16s  widget_arg( argc, argv, %d );\n" (widget_type + "*") a  ("(" + widget_type + "*)") a;
		};


	    fun build_arg_load_for_'libmythryl_xxx_c'  (arg_type, a, libcall)
		=
		# The general context here is that we are building some
		#     src/glu/gtk/c/in-main/libmythryl-gtk.c
		# fn like
		#
		#	/* do__make_table
		#	 *
		#	 * gtk-client.api        type:    { session: Session,   rows: Int,   cols: Int,   homogeneous: Bool }   ->   Widget
		#	 * gtk-client-driver.api type:   (Session, Int, Int, Bool) -> Int (*new Widget*)
		#	 */
		#	static Val   do__make_table   (Task* task, Val arg)
		#	{
		#
		#	    int               i0 =                            GET_TUPLE_SLOT_AS_INT( arg, 1);
		#	    int               i1 =                            GET_TUPLE_SLOT_AS_INT( arg, 2);
		#	    int               b2 =                            GET_TUPLE_SLOT_AS_VAL( arg, 3) == HEAP_TRUE;
		#
		#	    int slot = find_free_widget_slot ();
		#
		#	    widget[slot] = gtk_table_new ( /*rows*/i0, /*cols*/i1, /*homogeneous*/b2 );
		#
		#	    return TAGGED_INT_FROM_C_INT(slot);
		#	}
		#
		# and we've reached the point of wanting to generate
		# one of the central GET_TUPLE_SLOT* lines.
		#
		# We will be called by
		#
		#     build_fun_arg_loads_for__'libmythryl_xxx_c'
		# in
		#     src/lib/make-library-glue/make-library-glue.pkg
		#
		# whenever it encounters an arg type other than
		#
		#     i (int),
		#     b (bool)
		#     s (string)
		#     f (double)
		#
		# This allows us to add support for otherwise unsupported
		# arg types, in particular 'w' for Widget.
		{
		    # Usually we fetch a widget as just
		    #
		    #    GtkWidget* widget    =  widget_arg( argc, argv, 0 );
		    #
		    # or such, but in a few cases we must cast to
		    # another type:
		    #  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)   widget_arg( argc, argv, 0 );
		    #  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)        widget_arg( argc, argv, 0 );
		    #  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0 =  (GtkRadioButton*)  widget_arg( argc, argv, 0 );

		    widget_type
			=
			if   (libcall =~ (sprintf   "GTK_ADJUSTMENT\\(\\s*w%d\\s*\\)" a))   "GtkAdjustment";
			elif (libcall =~ (sprintf        "GTK_SCALE\\(\\s*w%d\\s*\\)" a))   "GtkScale";
			elif (libcall =~ (sprintf "GTK_RADIO_BUTTON\\(\\s*w%d\\s*\\)" a))   "GtkRadioButton";
			else								    "GtkWidget";
			fi;

		    sprintf  "    %-14s    w%d  =    %-16s  widget[ GET_TUPLE_SLOT_AS_INT( arg, %d) ];\n"
			      (widget_type + "*")
			      a
			      ("(" + widget_type + "*)")
			      (a+1)				# +1 because first arg is always Session.
		    ;
		};


	    fun build_callback_function (r: mlb::Builder_Stuff)
		=
		# We will be called whenever
		#     handle_fieldset()  
		# in
		#     src/lib/make-library-glue/make-library-glue.pkg
		# encounters a paragraph in
		#     src/glu/gtk/etc/library-glue.plan
		# containing the line
		#     build-a: callback-fn
		#
		# The 'callback-fn'  build-a: type is unsupported by
		# make-library-glue.pkg proper, which only supports
		#
		#     build-a: plain-fn
		#     build-a: fn-doc
		#     build-a: mythryl-type
		#     build-a: mythryl-code
		#
		# Consequently we bear full responsibility for generating
		# all required code in all required patchpoints in all
		# relevant asourcefiles.  Our 'r' argument gives us all
		# required resources to do so.
		#
		{
		    fn_name  =  r.get_field(r.state, "fn-name");		# "set_foo_callback"
		    fn_type  =  r.get_field(r.state, "fn-type");		# "Session -> Widget -> Foo_Callback -> Void"
		    lowtype  =  r.get_field(r.state, "lowtype");		# "G_OBJECT"

		    callback_name
			=
			(regex::find_first_group 1 ./^set_(.*)_callback$/  fn_name)
			except
			    NOT_FOUND
				=
				die_x(sprintf "%s: callback-fn fn-name '%s' does not have form 'set_foo_callback' for any 'foo'\n"
					     (r.get_field_location (r.state, "fn-name"))
					     fn_name
				    );

		    callback_type		# E.g., "Void_Callback"
			=
			(regex::find_first_group 1 ./^Session\s+->\s+Widget\s+->\s+(\S+)\s+->\s+Void$/ fn_type)
			except
			    NOT_FOUND
				=
				die_x(sprintf "%s: callback-fn fn-type '%s' does not have form 'Session -> Widget -> Foo_Callback -> Void' for any 'foo'\n"
					     (r.get_field_location (r.state, "fn-type"))
					     fn_type
				    );

		    callback_name =   regex::replace_all  ./'/  "2"  callback_name;		# Primes don't work in C!

		    c_fn_name =  "set_"  +  callback_name  +  "_callback";

		    build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c'( r, callback_name,          lowtype );
		    build_set_callback_fn_for_'libmythryl_xxx_c'(                      r, callback_name, fn_type, lowtype );

		    r.build_table_entry_for_'libmythryl_xxx_c'                      (c_fn_name, fn_type);
		    r.build_trie_entry_for_'mythryl_xxx_library_in_c_subprocess_c'  (c_fn_name );

		    url =   case (r.maybe_get_field (r.state, "url"))
				#
				THE field =>  field;
				NULL      =>  "http://library.gnome.org/devel/gobject/unstable/gobject-Signals.html#g-signal-connect";
			    esac;

		    r.note__section_libref_xxx_tex__entry { state => r.state, fn_name, url, fn_type, libcall => "g_signal_connect" };

		    libcall     = "w0";			# Give arg counts and types to the following two functions.
		    result_type = "Int";		# Give result information   to the following two functions.

		    r.build_fun_declaration_for_'xxx_client_driver_api'					(c_fn_name, libcall, result_type);
		    r.build_fun_definition_for_'xxx_client_driver_for_library_in_c_subprocess_pkg'	(c_fn_name, libcall, result_type);

		    r.build_fun_declaration_for_'xxx_client_api'					(fn_name, fn_type);
		    r.build_fun_definition_for_'xxx_client_driver_for_library_in_main_process_pkg'	(fn_name, c_fn_name, fn_type, libcall, result_type);

		    r.build_callback_fun_for_'xxx_client_g_pkg'( 				  r.state, fn_name, callback_type);
		}
		where
		    # Synthesize a function for   mythryl-xxx-library-in-c-subprocess.c  like
		    #
		    #    static void
		    #    do__set_foo_callback( int argc, unsigned char** argv )
		    #    {
		    #	check_argc( "do__foo_callback", 1, argc );
		    #
		    #	{   GtkWidget* widget    =  widget_arg( argc, argv, 0 );
		    #
		    #	    int id   =  find_free_callback_id ();
		    #
		    #	    g_signal_connect( G_OBJECT(widget), "foo", G_CALLBACK( run_foo_callback ), (void*)id );
		    #
		    #	    printf(               "set_foo_callback%d\n", id );	fflush( stdout );
		    #	    fprintf(log_fd, "SENT: set_foo_callback%d\n", id );	fflush( log_fd );
		    #	}
		    #    }
		    #
		    fun build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c' (r: mlb::Builder_Stuff, callback_name, lowtype)
			=
			{   r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "static void\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("do__set_" + callback_name + "_callback( int argc, unsigned char** argv )\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "{\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("    check_argc( \"do__set_" + callback_name + "_callback\", 1, argc );\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "    {   GtkWidget* widget    =  widget_arg( argc, argv, 0 );\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "        int id   =  find_free_callback_id ();\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("        g_signal_connect( " + lowtype + "(widget), \"" + callback_name + "\", G_CALLBACK( run_" + callback_name + "_callback ), (void*)id );\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(              \"set_" + callback_name + "_callback%d\\n\", id );      fflush( stdout );\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT: set_" + callback_name + "_callback%d\\n\", id );      fflush( log_fd );\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-glue/make-library-glue.pkg:  build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c'  per  " + r.path.library_binding_specification + ".*/\n");

			    r.custom_fns_codebuilt_for_'mythryl_xxx_library_in_c_subprocess_c'
				:=
				*r.custom_fns_codebuilt_for_'mythryl_xxx_library_in_c_subprocess_c'
				+ 1;
			};

		    # Synthesize a function for   libmythryl-xxx.c  like
		    #
		    #   /* do__set_foo_callback : Session -> Widget -> Void_Callback -> Void;
		    #    */
		    #   static Val do__set_foo_callback (Task* task, Val arg)
		    #   {
		    #       GtkWidget*        w0 =    (GtkWidget*)      widget[ GET_TUPLE_SLOT_AS_INT( arg, 1) ];	// '1' because 'arg' is a duple (session, widget).
		    #
		    #       int id   =  find_free_callback_id ();
		    #
		    #       g_signal_connect( G_OBJECT(widget), "clicked", G_CALLBACK( run_clicked_callback ), (void*)id );
		    #
		    #       return TAGGED_INT_FROM_C_INT(id);
		    #   }
		    #    
		    fun build_set_callback_fn_for_'libmythryl_xxx_c'
			( r: mlb::Builder_Stuff,
			  callback_name,
			  fn_type,			# E.g., "Session -> Widget -> Void_Callback -> Void".
			  lowtype
			)
			=
			{   r.to_libmythryl_xxx_c_funs "\n";
			    r.to_libmythryl_xxx_c_funs "\n";
			    r.to_libmythryl_xxx_c_funs("/*  do__set_" + callback_name + "_callback : " + fn_type + "\n");
			    r.to_libmythryl_xxx_c_funs " */\n";
			    r.to_libmythryl_xxx_c_funs("static Val   do__set_" + callback_name + "_callback (Task* task, Val arg)\n");
			    r.to_libmythryl_xxx_c_funs "{\n";
			    r.to_libmythryl_xxx_c_funs  "\n";
			    r.to_libmythryl_xxx_c_funs  "    GtkWidget*        w0 __attribute__((unused)) =    (GtkWidget*)      widget[ GET_TUPLE_SLOT_AS_INT( arg, 1) ];        // '1' because 'arg' is a duple (session, widget).\n";
			    r.to_libmythryl_xxx_c_funs  "\n";		# The '__attribute__((unused))' is just to suppress some   unused variable 'w0'   compiler warnings.
			    r.to_libmythryl_xxx_c_funs "    int id   =  find_free_callback_id ();\n";
			    r.to_libmythryl_xxx_c_funs "\n";
			    r.to_libmythryl_xxx_c_funs("    g_signal_connect( " + lowtype + "(w0), \"" + callback_name + "\", G_CALLBACK( run_" + callback_name + "_callback ), (void*)id );\n");
			    r.to_libmythryl_xxx_c_funs "\n";
			    r.to_libmythryl_xxx_c_funs "    return TAGGED_INT_FROM_C_INT(id);\n";
			    r.to_libmythryl_xxx_c_funs  "}\n";
			    r.to_libmythryl_xxx_c_funs("/* Above fn built by src/lib/make-library-glue/make-library-glue.pkg:  build_set_callback_fn_for_'libmythryl_xxx_c'  per  " + r.path.library_binding_specification + ".*/\n");
			    r.to_libmythryl_xxx_c_funs  "\n";
			    r.to_libmythryl_xxx_c_funs  "\n";

			    r.custom_fns_codebuilt_for_'libmythryl_xxx_c'
				:=
				*r.custom_fns_codebuilt_for_'libmythryl_xxx_c'
				+ 1;
			};
		end;


	end;

    exit_x(0);
};
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
