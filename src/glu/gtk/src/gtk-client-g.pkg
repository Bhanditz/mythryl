# gtk-client-g.pkg
#
# Here we handle the low-level Gtk-binding functionality
# common to our Gtk-in-main-process and Gtk-in-subprocess
# implementations;  the functionality specific to those two
# is handled by gtk_client_driver_for_library_in_main_process and gtk_client_driver_for_library_in_c_subprocess.			# gtk_client_driver_for_library_in_main_process		is from   src/glu/gtk/src/gtk-client-driver-for-library-in-main-process.pkg
#																	# gtk_client_driver_for_library_in_c_subprocess		is from   src/glu/gtk/src/gtk-client-driver-for-library-in-c-subprocess.pkg

# Compiled by:
#     src/lib/std/standard.lib

# Autogeneration of parts of this file done by:
#
#     src/glu/gtk/sh/make-gtk-glue
# per src/glu/gtk/etc/construction.plan

# Unit tests in:
#     src/glu/gtk/src/test/gtk-client-for-library-in-c-subprocess-unit-test.pkg

# Compare with:
#     src/glu/gtk/src/easy-gtk.pkg

# The other end of the pipe is implemented in:
#
#     src/glu/gtk/c/in-sub/mythryl-gtk-library-in-c-subprocess.c
#
# See the comments in that file for a description
# of the pipe protocol used.



###		"Each design decision constrains all subsequent
###              design decisions, making each successive design
###              problem harder to solve.  Tackle the hardest
###              design problems first, when you have the greatest
###              freedom to maneuver."


# This generic is invoked once each for
# our Gtk-in-main-processs
# and Gtk-in-subprocess
# implementations:
#
#     src/glu/gtk/src/gtk-client-for-library-in-main-process.pkg
#     src/glu/gtk/src/gtk-client-for-library-in-c-subprocess.pkg
#
#
generic package   gtk_client_g   (
    #             ===== 
    drv: Gtk_Client_Driver							# Gtk_Client_Driver		is from   src/glu/gtk/src/gtk-client-driver.api
	#
	# When called by gtk-client-for-library-in-main-process.pkg   drv == gtk_client_driver_for_library_in_main_process		# gtk_client_driver_for_library_in_main_process		is from   src/glu/gtk/src/gtk-client-driver-for-library-in-main-process.pkg
	# When called by gtk-client-for-library-in-c-subprocess.pkg   drv == gtk_client_driver_for_library_in_c_subprocess		# gtk_client_driver_for_library_in_c_subprocess		is from   src/glu/gtk/src/gtk-client-driver-for-library-in-c-subprocess.pkg
)
:
Gtk_Client									# Gtk_Client			is from   src/glu/gtk/src/gtk-client.api
{
    include gtk_event;								# gtk_event			is from   src/glu/gtk/src/gtk-event.pkg


    #################################################################################################
    # The following stuff gets copied directly from the
    #     build-a: mythryl-type
    # section of
    #     src/glu/gtk/etc/construction.plan
    # via handle_fieldset -> build_mythryl_type -> to_xxx_client_api_types in
    #     src/lib/make-library-glue/make-library-glue.pkg
    # This section is duplicated in
    #     src/glu/gtk/src/gtk-client.api
    # Do not edit this or following lines -- they are autobuilt.  (patchname="types")
    # Do not edit this or preceding lines -- they are autobuilt.
    #################################################################################################

    package int_map =  int_red_black_map;

    Session = { subsession:   drv::Session,
		#
		callback_map:   { void:            Ref( int_map::Map( Void            -> Void )),
				  bool:            Ref( int_map::Map( Bool            -> Void )),
				  float:           Ref( int_map::Map( Float           -> Void )),
				  button_event:    Ref( int_map::Map( Button_Event    -> Void )),
				  motion_event:    Ref( int_map::Map( Motion_Event    -> Void )),
				  key_event:       Ref( int_map::Map( Key_Event       -> Void )),
				  expose_event:    Ref( int_map::Map( Expose_Event    -> Void )),
				  configure_event: Ref( int_map::Map( Configure_Event -> Void ))
				},
				#
				# The callback maps let us find the appropriate
				# Mythryl callback function to run when our GTK
				# server process says to run callback #127 or such.
				#
				# To keep the typechecker happy we need a separate
				# map for each callback type.

		widget_tree:    Ref( Widget ),

		widgets_by_easy_id:  Ref( string_map::Map( Widget ) )
		    #
		    # The "easy_id" map is support for easy-gtk.{api,pkg},
		    # where widgets are constructed from tree structured
		    # specifications and thus lack natural names; assigning
		    # a widget a text "easy_id" name allows it to be retrieved
		    # later by name if needed.
	      };

    #
    fun set_easy_id (session: Session, id, widget)
        =
        session.widgets_by_easy_id
            :=
            string_map::set( *session.widgets_by_easy_id, id, widget );

    #
    fun drop_easy_id (session: Session, id)
        =
        session.widgets_by_easy_id
            :=
            #1 (string_map::drop (*session.widgets_by_easy_id, id ) );

    #
    fun get_by_easy_id (session: Session, id)
        =
        the (string_map::get( *session.widgets_by_easy_id, id ) );



    stipulate


    herein



	#
	fun sum_table_attach_options  options
	    =
	    sum_options' (options, 0)
	    where
		fun sum_options' ([], result)
			=>
			result;

		    sum_options' (option ! rest, result)
			=>
			{   value
				=
				case option
				    TABLE_EXPAND => 1;
				    TABLE_SHRINK => 2;
				    TABLE_FILL   => 4;
				esac;

			    sum_options' (rest, result + value);
			};
		end;
	    end;





	#
	fun destroy_widget_tree  (session: Session)
            =
	    drv::destroy_widget (session.subsession, *session.widget_tree);	# Note break in pattern -- there is no drv::destroy_widget_tree.


	#
	fun run_eventloop_indefinitely (session: Session)
            =
            drv::run_eventloop_indefinitely session.subsession;

	#
	fun run_eventloop_once { session: Session, block_until_event: Bool }
            =
            drv::run_eventloop_once (session.subsession, block_until_event);

	#
        fun make_session []
		=>
		{   callback_map  =   { void            =>  REF (int_map::empty:   int_map::Map( Void            -> Void )),
					bool            =>  REF (int_map::empty:   int_map::Map( Bool            -> Void )),
					float           =>  REF (int_map::empty:   int_map::Map( Float           -> Void )),
					button_event    =>  REF (int_map::empty:   int_map::Map( Button_Event    -> Void )),
					motion_event    =>  REF (int_map::empty:   int_map::Map( Motion_Event    -> Void )),
					key_event       =>  REF (int_map::empty:   int_map::Map( Key_Event       -> Void )),
					expose_event    =>  REF (int_map::empty:   int_map::Map( Expose_Event    -> Void )),
					configure_event =>  REF (int_map::empty:   int_map::Map( Configure_Event -> Void ))
				      };

		    subsession =  drv::make_session  callback_map;

		    session = { subsession,
				callback_map,
				widget_tree	    =>  REF 0,
				widgets_by_easy_id  =>  REF string_map::empty
			      };

		    session;
		};

            make_session (arg ! args)
		=>
		raise exception GTK_ERROR "make_session: args not supported yet.";
	end;


    #################################################################################################
    # The following stuff gets built from paragraphs in
    #     src/glu/gtk/etc/construction.plan
    # via logic in
    #     src/lib/make-library-glue/make-library-glue.pkg
    # viz:
    #     build_plain_fn -> build_plain_fun_for_'xxx_client_g_pkg' -> to_xxx_client_g_pkg_funs
    #         build-a: plain-fn
    #         fn-name:
    #         fn-type:
    #         libcall:
    #     build_callback_fun_for_'xxx_client_g_pkg' -> to_xxx_client_g_pkg_funs
    #        fn_name, callback_type, hand-built code can be supplied via code:
    #     build_mythryl_code -> to_xxx_client_g_pkg_funs
    #        build-a: mythryl-code
    #        code:
    # Do not edit this or following lines -- they are autobuilt.  (patchname="functions")
 
    # Callbacks taking a boolean argument:
    #
    fun set_value_changed_callback           s w c = note_float_callback          (s, c, drv::set_value_changed_callback           (s.subsession, w));	# Handle 'value_changed' signal
    # Do not edit this or preceding lines -- they are autobuilt.
    #################################################################################################

	#
	fun get_widget_allocation (session: Session, widget)
	    =
	    {   my (x, y, wide, high)
		    =
		    drv::get_widget_allocation (session.subsession, widget);

		{ x, y, wide, high };
	    };

	#
	fun get_window_pointer (session: Session, window)
	    =
	    {   my (x, y, modifiers)
		    =
		    drv::get_window_pointer (session.subsession, window); 

		{ x, y, modifiers => int_to_modifier_list modifiers };
            };

	#
        fun make_dialog (session: Session)
            =
	    {   my (dialog, vbox, action_area)
		    = 
                    drv::make_dialog  session.subsession;

		{ dialog, vbox, action_area };
            };

	#
        fun set_widget_tree  (session: Session,  widget)
            =
            session.widget_tree := widget;

	#
        fun quit_eventloop  (session: Session)
            =
            drv::quit_eventloop  session.subsession;

	fun unref_object (session: Session, widget)
            =
            drv::unref_object (session.subsession, widget);

    end;

    stipulate
	include eight_byte_float;
    herein
	fun clamp { min, max, value }
	    =
	    if   (value < min)   min;
	    elif (value > max)   max;
	    else                 value;
    	    fi;
    end;
};




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
