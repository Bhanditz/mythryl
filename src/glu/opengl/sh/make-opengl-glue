#!/usr/bin/mythryl

# To minimize code redundancy and consequent
# reliability and maintenance headaches in
#
#     src/glu/opengl/c/in-sub/mythryl-opengl-library-in-c-subprocess.c
#
# we synthesize simple repetitive functions
# directly from their
#
#     src/glu/opengl/src/opengl-client.api
#
# type declarations.
#
# The specifications for these functions and
# related declarations and docs are in
#
#     src/glu/opengl/etc/library-glue.plan
#
# (See top-of-file comments there.)
#
# We are invoked by doing
# 
#     make opengl-glue
#
# At the top level.  This is not done as part
# of a normal build;  I run it by hand after
# I've updated (say) library-glue.plan

stipulate
    package fil =  file__premicrothread;													# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package lms =  list_mergesort;														# list_mergesort		is from   src/lib/src/list-mergesort.pkg
    package iow =  io_wait_hostthread;														# io_wait_hostthread		is from   src/lib/std/src/hostthread/io-wait-hostthread.pkg
    package mlb =  make_library_binding;													# make_library_binding		is from   src/lib/make-library-glue/make-library-glue.pkg
herein

{    
# iow::test "make-opengl-glue: testt/AAA";

    mlb::make_library_binding
	{
	  lib_name						=>  "opengl",									# Must match the   #define CLIB_NAME "opengl"   line in   src/glu/opengl/c/in-main/libmythryl-opengl.c
	  library_binding_specification				=>  "src/glu/opengl/etc/library-glue.plan",
	  xxx_client_api					=>  "src/glu/opengl/src/opengl-client.api",
	  xxx_client_g_pkg					=>  "src/glu/opengl/src/opengl-client-g.pkg",
	  xxx_client_driver_api					=>  "src/glu/opengl/src/opengl-client-driver.api",
	  xxx_client_driver_for_library_in_c_subprocess_pkg	=>  "src/glu/opengl/src/opengl-client-driver-for-library-in-c-subprocess.pkg",
	  xxx_client_driver_for_library_in_main_process_pkg	=>  "src/glu/opengl/src/opengl-client-driver-for-library-in-main-process.pkg",
	  mythryl_xxx_library_in_c_subprocess_c			=>  "src/glu/opengl/c/in-sub/mythryl-opengl-library-in-c-subprocess.c",
	  libmythryl_xxx_c					=>  "src/glu/opengl/c/in-main/libmythryl-opengl.c",
	  section_libref_xxx_tex				=>  "src/glu/opengl/doc/tex/section-libref-opengl.tex"
	}
	[																		# Plugins that extend base mlb functionality.
	  mlb::BUILD_A ("callback-fn", build_callback_function)
	]
	where
	    fun build_callback_function (r: mlb::Builder_Stuff)
		=
		# We will be called whenever
		#     handle_fieldset()  
		# in
		#     src/lib/make-library-glue/make-library-glue.pkg
		# encounters a paragraph in
		#     src/glu/opengl/etc/library-glue.plan
		# containing the line
		#     build-a: callback-fn
		#
		# The 'callback-fn'  build-a: type is unsupported by
		# make-library-glue.pkg proper, which only supports
		#
		#     build-a: plain-fn
		#     build-a: fn-doc
		#     build-a: mythryl-type
		#     build-a: mythryl-code
		#
		# Consequently we bear full responsibility for generating
		# all required code in all required patchpoints in all
		# relevant asourcefiles.  Our 'r' argument gives us all
		# required resources to do so.
		#
		{
		    fn_name  =  r.get_field(r.state, "fn-name");		# "set_foo_callback"
		    fn_type  =  r.get_field(r.state, "fn-type");		# "Session -> Widget -> Foo_Callback -> Void"
		    lowtype  =  r.get_field(r.state, "lowtype");		# "G_OBJECT"

		    callback_name
			=
			(regex::find_first_group 1 ./^set_(.*)_callback$/  fn_name)
			except
			    NOT_FOUND
				=
				die_x(sprintf "%s: callback-fn fn-name '%s' does not have form 'set_foo_callback' for any 'foo'\n"
					     (r.get_field_location (r.state, "fn-name"))
					     fn_name
				    );

		    callback_type		# E.g., "Void_Callback"
			=
			(regex::find_first_group 1 ./^Session\s+->\s+Widget\s+->\s+(\S+)\s+->\s+Void$/ fn_type)
			except
			    NOT_FOUND
				=
				die_x(sprintf "%s: callback-fn fn-type '%s' does not have form 'Session -> Widget -> Foo_Callback -> Void' for any 'foo'\n"
					     (r.get_field_location (r.state, "fn-type"))
					     fn_type
				    );

		    callback_name =   regex::replace_all  ./'/  "2"  callback_name;		# Primes don't work in C!

		    c_fn_name =  "set_"  +  callback_name  +  "_callback";

		    build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c'( r, callback_name,          lowtype );
		    build_set_callback_fn_for_'libmythryl_xxx_c'(                      r, callback_name, fn_type, lowtype );

		    r.build_table_entry_for_'libmythryl_xxx_c'                      (c_fn_name, fn_type);
		    r.build_trie_entry_for_'mythryl_xxx_library_in_c_subprocess_c'  (c_fn_name );

		    url =   case (r.maybe_get_field (r.state, "url"))
				#
				THE field =>  field;
				NULL      =>  "http://library.gnome.org/devel/gobject/unstable/gobject-Signals.html#g-signal-connect";
			    esac;

		    r.note__section_libref_xxx_tex__entry { state => r.state, fn_name, url, fn_type, libcall => "g_signal_connect" };

		    libcall     = "w0";			# Give arg counts and types to the following two functions.
		    result_type = "Int";		# Give result information   to the following two functions.

		    r.build_fun_declaration_for_'xxx_client_driver_api'					(c_fn_name, libcall, result_type);
		    r.build_fun_definition_for_'xxx_client_driver_for_library_in_c_subprocess_pkg'	(c_fn_name, libcall, result_type);

		    r.build_fun_declaration_for_'xxx_client_api'					(fn_name, fn_type);
		    r.build_fun_definition_for_'xxx_client_driver_for_library_in_main_process_pkg'	(fn_name, c_fn_name, fn_type, libcall, result_type);

		    r.build_callback_fun_for_'xxx_client_g_pkg'( 				  r.state, fn_name, callback_type);
		}
		where
		    # Synthesize a function for   mythryl-xxx-library-in-c-subprocess.c  like
		    #
		    #    static void
		    #    do__set_foo_callback( int argc, unsigned char** argv )
		    #    {
		    #	check_argc( "do__foo_callback", 1, argc );
		    #
		    #	{   GtkWidget* widget    =  widget_arg( argc, argv, 0 );
		    #
		    #	    int id   =  find_free_callback_id ();
		    #
		    #	    g_signal_connect( G_OBJECT(widget), "foo", G_CALLBACK( run_foo_callback ), (void*)id );
		    #
		    #	    printf(               "set_foo_callback%d\n", id );	fflush( stdout );
		    #	    fprintf(log_fd, "SENT: set_foo_callback%d\n", id );	fflush( log_fd );
		    #	}
		    #    }
		    #
		    fun build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c' (r: mlb::Builder_Stuff, callback_name, lowtype)
			=
			{   r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "static void\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("do__set_" + callback_name + "_callback( int argc, unsigned char** argv )\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "{\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("    check_argc( \"do__set_" + callback_name + "_callback\", 1, argc );\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "    {   GtkWidget* widget    =  widget_arg( argc, argv, 0 );\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "        int id   =  find_free_callback_id ();\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("        g_signal_connect( " + lowtype + "(widget), \"" + callback_name + "\", G_CALLBACK( run_" + callback_name + "_callback ), (void*)id );\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(              \"set_" + callback_name + "_callback%d\\n\", id );      fflush( stdout );\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT: set_" + callback_name + "_callback%d\\n\", id );      fflush( log_fd );\n");
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
			    r.to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-glue/make-library-glue.pkg:  build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c'  per  " + r.path.library_binding_specification + ".*/\n");

			    r.custom_fns_codebuilt_for_'mythryl_xxx_library_in_c_subprocess_c'
				:=
				*r.custom_fns_codebuilt_for_'mythryl_xxx_library_in_c_subprocess_c'
				+ 1;
			};

		    # Synthesize a function for   libmythryl-xxx.c  like
		    #
		    #   /* do__set_foo_callback : Session -> Widget -> Void_Callback -> Void;
		    #    */
		    #   static Val do__set_foo_callback (Task* task, Val arg)
		    #   {
		    #       GtkWidget*        w0 =    (GtkWidget*)      widget[ GET_TUPLE_SLOT_AS_INT( arg, 1) ];	// '1' because 'arg' is a duple (session, widget).
		    #
		    #       int id   =  find_free_callback_id ();
		    #
		    #       g_signal_connect( G_OBJECT(widget), "clicked", G_CALLBACK( run_clicked_callback ), (void*)id );
		    #
		    #       return TAGGED_INT_FROM_C_INT(id);
		    #   }
		    #    
		    fun build_set_callback_fn_for_'libmythryl_xxx_c'
			( r: mlb::Builder_Stuff,
			  callback_name,
			  fn_type,			# E.g., "Session -> Widget -> Void_Callback -> Void".
			  lowtype
			)
			=
			{   r.to_libmythryl_xxx_c_funs "\n";
			    r.to_libmythryl_xxx_c_funs "\n";
			    r.to_libmythryl_xxx_c_funs("/*  do__set_" + callback_name + "_callback : " + fn_type + "\n");
			    r.to_libmythryl_xxx_c_funs " */\n";
			    r.to_libmythryl_xxx_c_funs("static Val   do__set_" + callback_name + "_callback (Task* task, Val arg)\n");
			    r.to_libmythryl_xxx_c_funs "{\n";
			    r.to_libmythryl_xxx_c_funs  "\n";
			    r.to_libmythryl_xxx_c_funs  "    GtkWidget*        w0 __attribute__((unused)) =    (GtkWidget*)      widget[ GET_TUPLE_SLOT_AS_INT( arg, 1) ];        // '1' because 'arg' is a duple (session, widget).\n";
			    r.to_libmythryl_xxx_c_funs  "\n";		# The '__attribute__((unused))' is just to suppress some   unused variable 'w0'   compiler warnings.
			    r.to_libmythryl_xxx_c_funs "    int id   =  find_free_callback_id ();\n";
			    r.to_libmythryl_xxx_c_funs "\n";
			    r.to_libmythryl_xxx_c_funs("    g_signal_connect( " + lowtype + "(w0), \"" + callback_name + "\", G_CALLBACK( run_" + callback_name + "_callback ), (void*)id );\n");
			    r.to_libmythryl_xxx_c_funs "\n";
			    r.to_libmythryl_xxx_c_funs "    return TAGGED_INT_FROM_C_INT(id);\n";
			    r.to_libmythryl_xxx_c_funs  "}\n";
			    r.to_libmythryl_xxx_c_funs("/* Above fn built by src/lib/make-library-glue/make-library-glue.pkg:  build_set_callback_fn_for_'libmythryl_xxx_c'  per  " + r.path.library_binding_specification + ".*/\n");
			    r.to_libmythryl_xxx_c_funs  "\n";
			    r.to_libmythryl_xxx_c_funs  "\n";

			    r.custom_fns_codebuilt_for_'libmythryl_xxx_c'
				:=
				*r.custom_fns_codebuilt_for_'libmythryl_xxx_c'
				+ 1;
			};
		end;
	end;


    exit_x(0);
};
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
