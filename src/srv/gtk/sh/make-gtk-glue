#!/usr/bin/mythryl

# To minimize code redundancy and consequent
# reliability and maintenance headaches in
#
#     src/srv/gtk/c/mythryl-gtk-server-in-c-subprocess.c
#
# we synthesize simple repetitive functions
# directly from their
#
#     src/lib/src/gtk-client.api
#
# type declarations.
#
# The specifications for these functions and
# related declarations and docs are in
#
#     src/srv/gtk/etc/gtk-glue.config
#
# (See top-of-file comments there.)
#
# We are invoked by doing
# 
#     make gtk-glue
#
# At the top level.  This is not done as part
# of a normal build;  I run it by hand after
# I've updated (say) gtk-glue.config

stipulate
    package fil =  file__premicrothread;						# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package lms =  list_mergesort;							# list_mergesort		is from   src/lib/src/list-mergesort.pkg
    package iow =  io_wait_hostthread;							# io_wait_hostthread		is from   src/lib/std/src/hostthread/io-wait-hostthread.pkg
herein

{    
# iow::test "make-gtk-glue: testt/AAA";

    # The list of files which we patch:
    #
    config_file_path             =  "src/srv/gtk/etc/gtk-glue.config";
    gtk_api_path                 =  "src/lib/src/gtk-client.api";
    gtk_g_pkg_path               =  "src/lib/src/gtk-client-g.pkg";
    gtk_driver_api_path          =  "src/lib/src/gtk-client-driver.api";
    gtk_via_pipe_driver_pkg_path =  "src/lib/src/gtk-client-driver-for-server-in-c-subprocess.pkg";
    gtk_driver_pkg_path          =  "src/lib/src/gtk-client-driver-for-server-in-main-process.pkg";
    mythryl_gtk_server_c_path    =  "src/srv/gtk/c/mythryl-gtk-server-in-c-subprocess.c";
    gtk_driver_c_path            =  "src/srv/gtk/lib/mythryl-gtk-server-in-main-process.c";
    cfun_list_h_path             =  "src/srv/gtk/lib/cfun-list.h";
    libref_tex_path              =  "doc/tex/section-libref-gtk.tex";

    gtk_driver_plain_fns_autogenerated    =  REF 0;
    gtk_driver_callback_fns_autogenerated =  REF 0;

    gtk_server_plain_fns_autogenerated     =  REF 0;
    gtk_server_callback_fns_autogenerated  =  REF 0;

    gtk_g_pkg_plain_fns_handgenerated     =  REF 0;
    gtk_g_pkg_plain_fns_autogenerated     =  REF 0;

    gtk_g_pkg_callback_fns_handgenerated  =  REF 0;
    gtk_g_pkg_callback_fns_autogenerated  =  REF 0;


    # Lists of synthesized code strings to
    # be inserted in the above files.  Most
    # files have just one such insertion point
    # ("intron") but some have two, for example
    # one for synthesized type declarations
    # and one for synthesized functions.
    #
    # These will all be in reverse
    # order while being contructed:
    #
    gtk_driver_api_intron            =  REF ([]: List(String));
    gtk_via_pipe_driver_pkg_intron   =  REF ([]: List(String));
    gtk_driver_pkg_intron            =  REF ([]: List(String));
    gtk_api_funs_intron              =  REF ([]: List(String));
    gtk_api_types_intron             =  REF ([]: List(String));
    gtk_g_pkg_funs_intron            =  REF ([]: List(String));
    gtk_g_pkg_types_intron           =  REF ([]: List(String));
    mythryl_gtk_server_c_funs_intron =  REF ([]: List(String));
    mythryl_gtk_server_c_trie_intron =  REF ([]: List(String));
    cfun_list_h_intron               =  REF ([]: List(String));
    gtk_driver_c_intron              =  REF ([]: List(String));
    libref_tex_table1_intron         =  REF ([]: List(String));
    libref_tex_table2_intron         =  REF ([]: List(String));


    # Little functions to prepend
    # strings to the above lists:
    #
    fun to_gtk_driver_api            string =   gtk_driver_api_intron            :=  string !  *gtk_driver_api_intron;
    fun to_gtk_via_pipe_driver_pkg   string =   gtk_via_pipe_driver_pkg_intron   :=  string !  *gtk_via_pipe_driver_pkg_intron;
    fun to_gtk_driver_pkg            string =   gtk_driver_pkg_intron            :=  string !  *gtk_driver_pkg_intron;
    fun to_gtk_g_pkg_funs            string =   gtk_g_pkg_funs_intron            :=  string !  *gtk_g_pkg_funs_intron;
    fun to_gtk_g_pkg_types           string =   gtk_g_pkg_types_intron           :=  string !  *gtk_g_pkg_types_intron;
    fun to_gtk_api_funs              string =   gtk_api_funs_intron              :=  string !  *gtk_api_funs_intron;
    fun to_gtk_api_types             string =   gtk_api_types_intron             :=  string !  *gtk_api_types_intron;
    fun to_mythryl_gtk_server_c_funs string =   mythryl_gtk_server_c_funs_intron :=  string !  *mythryl_gtk_server_c_funs_intron;
    fun to_mythryl_gtk_server_c_trie string =   mythryl_gtk_server_c_trie_intron :=  string !  *mythryl_gtk_server_c_trie_intron;
    fun to_cfun_list_h               string =   cfun_list_h_intron               :=  string !  *cfun_list_h_intron;
    fun to_gtk_driver_c              string =   gtk_driver_c_intron              :=  string !  *gtk_driver_c_intron;
    fun to_libref_table1_tex         string =   libref_tex_table1_intron         :=  string !  *libref_tex_table1_intron;
    fun to_libref_table2_tex         string =   libref_tex_table2_intron         :=  string !  *libref_tex_table2_intron;



    # We divide the files we patch into exons and introns
    # according to the scheme
    #
    #        exon
    #        # Do not edit this or following lines -- they are autogenerated by make-gtk-glue./)
    #        intron
    #        # Do not edit this or preceding lines -- they are autogenerated by make-gtk-glue./)
    #        exon
    #        
    # where the exons are literal program text provided by the
    # programmer whereas the introns are literal program text
    # which we synthesize.  (The shown 'do not edit' lines are
    # considered part of the exons.)
    #
    # We represent such a file in memory as a list of file
    # segments (that is, exons and introns) where each segment
    # is in turn a list of lines represented as strings:
    #
    File_Segment = EXON   List(String)
		 | INTRON List(String)
		 ;

    Patchable_File
	=
	PATCHABLE_FILE {
	    filename:  String,
	    contents:  List(File_Segment)
	};


    # Read and return a Patchable_File:
    #
    fun read_patchable_file  filename
	=
	{   fd = fil::open_for_read filename
		 except
		    io_exceptions::IO _
			=
			{   fprintf stderr "Fatal: Unable to open input file '%s'" filename;
			    exit_x(1);
			};
	    contents
		=
		read_exon ([], [])
		where
		    fun read_exon (segments, lines)
			=
			case (fil::read_line  fd)
			    #
			    NULL => reverse ((EXON (reverse lines)) ! segments);

			    THE line
				=>
				if (line =~ ./ Do not edit this or following lines -- they are autogenerated by make-gtk-glue./)

				    read_intron ((EXON (reverse (line ! lines))) ! segments, []);
				else
				    read_exon (segments, line ! lines);
				fi;	
			esac

		    also
		    fun read_intron (segments, lines)
			=
			case (fil::read_line  fd)
			    #
			    NULL =>
				{   fprintf stderr "Fatal: Missing 'Do not edit this or preceding lines' line in %s" filename;
				    exit_x(1);
				};

			    THE line
				=>
				if (line =~ ./ Do not edit this or preceding lines -- they are autogenerated by make-gtk-glue./)
				    #
				    read_exon ((INTRON (reverse lines)) ! segments, [ line ]);
				else
				    read_intron (segments, line ! lines);
				fi;	
			esac;
		end;

	    fil::close_input  fd;

	    PATCHABLE_FILE { filename, contents };
	};

    # Write a patchable file back into the filesystem.
    #
    fun write_patchable_file
	(PATCHABLE_FILE { filename, contents })
	introns
	=
	{   intron_lines_written = REF 0;

	    tmp_filename = filename + "~";

	    fd = fil::open_for_write  tmp_filename
		 except
		    io_exceptions::IO _
			=
			{   fprintf stderr "Fatal: Unable to open output file '%s'" tmp_filename;
			    exit_x(1);
			};


	    fun write_exon_lines  (line ! rest)
		    =>
		    {   fil::write (fd, line);
			#
			write_exon_lines  rest;
		    };

		write_exon_lines [] =>  ();
	    end;


	    fun write_intron_lines  (line ! rest)					# Actually 'line' may be just a string (i.e., line fragment).
		    =>
		    {   fil::write (fd, line);
			intron_lines_written := *intron_lines_written + 1;		# This is the only difference between us and write_exon_lines.
			write_intron_lines rest;
		    };

		write_intron_lines  [] =>  ();
	    end;


	    write_exon (contents, introns)
	    where
		fun write_exon (((EXON lines) ! rest), introns)
			=>
			{
			    write_exon_lines lines;
			    write_intron (rest, introns);
			};

		    write_exon _
			=>
			raise exception FAIL "Internal bug";
		end

		also
		fun write_intron ((INTRON _) ! exons, (INTRON lines) ! introns)
			=>
			{
			    write_intron_lines lines;
			    write_exon (exons, introns);
			};

		    write_intron ([], [])
			=>
			();

		    write_intron _
			=>
			raise exception FAIL "Internal bug";
		end;
	    end;	

	    fil::close_output fd;   

	    winix__premicrothread::file::remove_file  filename;

	    winix__premicrothread::file::rename_file { from => tmp_filename, to => filename };

	    printf "Successfully patched %4d lines in %s\n"  *intron_lines_written  filename;
	};





    # Field is a contiguous sequence of lines
    # all with the same linetype field:
    #
    #    foo:  this
    #    foo:  that
    #
    # Most fields will be single-line, but this format
    # supports conveniently including blocks of code,
    # such as complete function definitions.
    #
    # We treat a field as a single string containing
    # embedded newlines, stripped of the linetype field
    # and the colon.  
    #
    Field = { string:  Ref(String),
	      line_1:  Ref(Int),
	      line_n:  Ref(Int),
	      used:    Ref(Bool)
	    };

    State = { line_number:  Ref(Int),

	      fd:           fil::Input_Stream,

	      fields:       Ref( string_map::Map( Field ))
	    };

    #
    fun field_location (field: Field)
	=
	*field.line_1 == *field.line_n  ??  sprintf "line %d" *field.line_1
					::  sprintf "lines %d-%d" *field.line_1 *field.line_n;

    #
    fun maybe_get_field (state: State, field_name)
	=
	case (string_map::get (*state.fields, field_name))
	    #
	    THE field => { field.used := TRUE;  THE *field.string; };
	    NULL      => NULL;
	esac;

    #
    fun get_field (state: State, field_name)
	=
	case (string_map::get (*state.fields, field_name))
	    #
	    THE field => { field.used := TRUE; 
			  *field.string;
			 };

	    NULL      => die_x (sprintf "Required field %s missing at line %d\n"  field_name  *state.line_number);
	esac;

    #
    fun get_field_location (state: State, field_name)
	=
	case (string_map::get (*state.fields, field_name))
	    #
	    THE field => { field.used := TRUE;  field_location field; };
	    #
	    NULL      => die_x (sprintf "Required field %s missing at line %d\n"  field_name  *state.line_number);
	esac;

    #
    fun clear_state (state: State)
	=
	{   foreach (string_map::keyvals_list *state.fields) .{
		#
		#pair -> (field_name, field);

		if (not *field.used)
		    #
		    die_x(sprintf "Field %s at %s unsupported.\n"
				 field_name
				 (field_location field)
			);
		fi;
	    }; 

	    state.fields :=  (string_map::empty: string_map::Map( Field ));
	};




    # lowhalf contains embedded arguments like w0, i1, f2, b3, s4.
    #
    # The argument letter gives us the argument type:
    #
    #    w == widget
    #    i == int
    #    f == double  (Mythryl "Float")
    #    b == bool
    #    s == string
    #
    # The argument digit gives us the argument order:
    #
    #    0 == first arg
    #    1 == second arg
    #    ...

    # Get list of above args, sorting by trailing digit
    # and dropping duplicates:
    #
    fun get_args  lowhalf
	=
	{   # Compare "w0" and "b1" as "0" and "1":
	    #
	    fun compare_fn (xn, yn)
		=
		{   xn' = string::extract (xn, 1, NULL);
		    yn' = string::extract (yn, 1, NULL);

		    string::compare (xn', yn');
		};

	    raw_list    =  regex::find_all  ./\b[bfisw][0-9]\b/  lowhalf;

	    cooked_list =  uniquesort  compare_fn  raw_list;

	    cooked_list;
	};        

    # Count number of arguments.
    # We need this for check_argc():
    #
    fun count_args  lowhalf
	=
	list::length (get_args  lowhalf);

    #
    fun get_nth_arg_type (n, lowhalf)
	=
	{   arg_list =  get_args  lowhalf;

	    if (n <   0
	    or  n >=  list::length  arg_list
	    )
		raise exception FAIL (sprintf "get_nth_arg_type: No %d-th arg in '%s'!" n lowhalf);
	    fi;

	    arg = list::nth (arg_list, n);		# Fetch "w0" or "i0" or such.

	    string::extract (arg, 0, THE 1);	# Convert "w0" to "w" or "i0" to "i" etc.
	};

    #
    fun arg_types_are_all_unique  lowhalf
	=
	{   # Get the list of parameters,
	    # something like [ "w0", "i1", "i2" ]:
	    #
	    args  =  get_args  lowhalf;

	    # Turn parameter list into type list,
	    # something like [ 'w', 'i', 'i' ]:
	    #
	    types =  map   .{ string::get (#string,0); }   args;

	    # Eliminate duplicate types from above:
	    #
	    types =   uniquesort  char::compare  types;

	    # If 'args' is same length as 'types' then
	    # all types are unique:
	    #
	    list::length args  ==  list::length types;
	};

    #
    fun gtk_driver_api_type (lowhalf, result_type)
	=
	{
	    input_type =  REF "(Session";

	    arg_count = count_args  lowhalf;

	    for (a = 0;  a < arg_count;  ++a) {

		t = get_nth_arg_type( a, lowhalf );

		case t
		    "b" =>     input_type :=  *input_type  +  ", Bool";
		    "i" =>     input_type :=  *input_type  +  ", Int";
		    "f" =>     input_type :=  *input_type  +  ", Float";
		    "s" =>     input_type :=  *input_type  +  ", String";
		    "w" =>     input_type :=  *input_type  +  ", Int/*Widget*/";

		     _  =>     raise exception FAIL (sprintf "Unsupported arg type '%s'" t);
		esac;
	    };

	    input_type :=  *input_type  +  ")";


	    output_type
		=
		case result_type

		    "new Widget" =>  "Int /*new Widget*/";
		    "Bool"       =>  "Bool";
		    "Float"      =>  "Float";
		    "Int"        =>  "Int";
		    "Widget"     =>  "Int /*Widget*/";
		    "Void"       =>  "Void";

		     _           => raise exception FAIL ("gtk_driver_api_type: Unsupported result type: " + result_type);
		esac;

	    (*input_type, output_type);
	};
    #        
    stipulate

	line_count = REF 2;

    herein

	fun write_gtk_driver_api_function  (fn_name, lowhalf, result_type)
	    =
	    {
		# Add a blank line every three declarations:
		#
		line_count := *line_count + 1;

		if ((*line_count % 3) == 0)

		    to_gtk_driver_api  "\n";
		fi;

		to_gtk_driver_api  (sprintf  "    %-40s"  (fn_name + ":"));


		my (input_type, output_type)
		    =
		    gtk_driver_api_type (lowhalf, result_type);


		to_gtk_driver_api (sprintf "%-40s -> %s;\n"  input_type output_type);
	    };
    end;






    #
    fun write_do_command (do_command, fn_name, lowhalf, result_prefix, result_expression)
	=
	{
	    if (result_expression != "")
		 to_gtk_via_pipe_driver_pkg ("        {   result = " + do_command + " (session");
	    else to_gtk_via_pipe_driver_pkg ("        " + do_command + " (session");
	    fi;

	    if (result_prefix != "") 
		to_gtk_via_pipe_driver_pkg  (.', "' + result_prefix + .'"');
	    fi;

	    to_gtk_via_pipe_driver_pkg  (.', "' + fn_name + .'"');

	    prefix = .' + " " +';

	    arg_count = count_args lowhalf;

	    for (a = 0;  a < arg_count;  ++a) {
		#
		t = get_nth_arg_type( a, lowhalf );

		case t
		    "b" =>   to_gtk_via_pipe_driver_pkg   (sprintf  "%s bool_to_string %s%d"              prefix t a);
		    "f" =>   to_gtk_via_pipe_driver_pkg   (sprintf  "%s eight_byte_float::to_string %s%d"  prefix t a);
		    "i" =>   to_gtk_via_pipe_driver_pkg   (sprintf  "%s int::to_string %s%d"              prefix t a);
		    "s" =>   to_gtk_via_pipe_driver_pkg   (sprintf  "%s string_to_string %s%d"            prefix t a);
		    "w" =>   to_gtk_via_pipe_driver_pkg   (sprintf  "%s widget_to_string %s%d"            prefix t a);
		    #
		     _  =>   raise exception FAIL ("Unsupported arg type '" + t + "'");
		esac;
	    };

	    to_gtk_via_pipe_driver_pkg ");\n";


	    if (result_expression != "")
		#
		to_gtk_via_pipe_driver_pkg "\n";
		to_gtk_via_pipe_driver_pkg ("            " + result_expression + "\n");
		to_gtk_via_pipe_driver_pkg "        };\n\n\n";
	    else
		to_gtk_via_pipe_driver_pkg "\n\n";
	    fi;
	};

    # Generate a function for   src/lib/src/gtk-client-driver-for-server-in-c-subprocess.pkg
    # looking like
    #
    #    fun make_status_bar_context_id (session, w0, s1)	# Int
    #        =
    #        do_int_command (session, "make_status_bar_context_id", "make_status_bar_context_id" + " " + widget_to_string w0 + " " + string_to_string s1);
    #
    fun write_gtk_via_pipe_driver_pkg_function (fn_name, lowhalf, result_type)
	=
	{
	    to_gtk_via_pipe_driver_pkg ("    fun " + fn_name + " (session");
	    #
	    arg_count = count_args( lowhalf );

	    for (a = 0;  a < arg_count;  ++a) {
		#
		arg_type = get_nth_arg_type( a, lowhalf );

		to_gtk_via_pipe_driver_pkg  (sprintf ", %s%d" arg_type a);
	    };

	    to_gtk_via_pipe_driver_pkg (")\t# " + result_type + "\n");
	    to_gtk_via_pipe_driver_pkg ("        =\n");

	    if   (result_type == "new Widget")   write_do_command ("do_int_command",    fn_name, lowhalf, fn_name, "");
	    elif (result_type == "Widget")       write_do_command ("do_int_command",    fn_name, lowhalf, fn_name, "");
	    elif (result_type == "Int")          write_do_command ("do_int_command",    fn_name, lowhalf, fn_name, "");
	    elif (result_type == "Bool")         write_do_command ("do_string_command", fn_name, lowhalf, fn_name, "the (int::from_string result) != 0;");
	    elif (result_type == "Float")        write_do_command ("do_string_command", fn_name, lowhalf, fn_name, "the (eight_byte_float::from_string result);");
	    elif (result_type == "Void")         write_do_command ("do_void_command",   fn_name, lowhalf, "", "");
	    else
		raise exception FAIL ("Unsupported result type: " + result_type);
	    fi;
	};

    #
    fun n_blanks n
	=
	n_blanks' (n, "")
	where
	    fun n_blanks' (0, string) => string;
		n_blanks' (i, string) => n_blanks' (i - 1, " " + string);
	    end;
	end;

    # Generate a function for   src/lib/src/gtk-client-driver-for-server-in-main-process.pkg
    # looking like
    #
    # NEED TO WORK OUT APPROPRIATE VARIATION FOR THIS
    #
    #    fun make_status_bar_context_id (session, w0, s1)	# Int
    #        =
    #        do_int_command (session, "make_status_bar_context_id", "make_status_bar_context_id" + " " + widget_to_string w0 + " " + string_to_string s1);
    #
    fun write_gtk_driver_pkg_function (fn_name, fn_name2, fn_type, lowhalf, result_type)
	=
	{
	    # Construct gtk-client-driver-for-server-in-main-process.pkg level type for this function.
	    # The gtk-client-g.pkg level type may involve records or tuples,
	    # but at this level we always have tuples:
	    #
	    (gtk_driver_api_type (lowhalf, result_type))
		->
	        (input_type, output_type);

	    to_gtk_driver_pkg "\n";
	    to_gtk_driver_pkg
		(sprintf "    #      %-80s   # gtk-client.api type\n"
			 ( (n_blanks (string::length fn_name))
			 + (fn_type =~ ./^\(/ ?? "" :: " ")			   # If type starts with a paren exdent it one space.
			 +  fn_type
			 )
		);

	    to_gtk_driver_pkg
		(sprintf "    my %s:   %s%s -> %s\n"
			  fn_name2
			 (input_type =~ ./^\(/ ?? "" :: " ")		   # If type starts with a paren exdent it one space.
			  input_type
			  output_type
		);

	    to_gtk_driver_pkg "        =\n";

	    to_gtk_driver_pkg
		(sprintf "        ci::find_c_function { lib_name => \"gtk\", fun_name => \"%s\" };\n"
			  fn_name2
		);

	    to_gtk_driver_pkg "\n";


    #	to_gtk_driver_pkg ("#    fun " + fn_name + " (session");
    #
    #	arg_count = count_args( lowhalf );
    #
    #	for (a = 0;  a < arg_count;  ++a) {
    #
    #	    arg_type = get_nth_arg_type( a, lowhalf );
    #
    #	    to_gtk_driver_pkg  (sprintf ", %s%d" arg_type a);
    #	};
    #
    #	to_gtk_driver_pkg (")\t# " + result_type + "\n");
    #	to_gtk_driver_pkg ("#        =\n");


    #	if   (result_type == "new Widget")   write_do_command ("do_int_command",    fn_name, lowhalf, fn_name, "");
    #	elif (result_type == "Widget")       write_do_command ("do_int_command",    fn_name, lowhalf, fn_name, "");
    #	elif (result_type == "Int")          write_do_command ("do_int_command",    fn_name, lowhalf, fn_name, "");
    #	elif (result_type == "Bool")         write_do_command ("do_string_command", fn_name, lowhalf, fn_name, "the (int::from_string result) != 0;");
    #	elif (result_type == "Float")        write_do_command ("do_string_command", fn_name, lowhalf, fn_name, "the (eight_byte_float::from_string result);");
    #	elif (result_type == "Void")         write_do_command ("do_void_command",   fn_name, lowhalf, "", "");
    #	else
    #	    raise exception FAIL ("Unsupported result type: " + result_type);
    #	fi;
	};


    # Convert .|gtk_foo| to .|gtk\_foo|
    # to protect it from TeX's ire:
    #
    fun slash_underlines  string
	=
	{
	    regex::replace_all ./_/ .|\_| string;
	};


    # Write a trie line into file  src/srv/gtk/c/mythryl-gtk-server-in-c-subprocess.c
    #
    fun write_trie_entry_for_gtk_server_c  name
	=
	{
	    to_mythryl_gtk_server_c_trie
	       (sprintf
		    "    set_trie( trie, %-46s%-46s);\n"
		    (.'"'  + name + .'",')
		    ("do_" + name));
	};	

    # Write a line like
    #
    #     CFUNC("init",	_lib7_Gtk_gtk_init,		"Void -> Void")
    #
    # into file   src/srv/gtk/lib/cfun-list.h
    #
    fun write_cfun_list_h_entry (fn_name, fn_type)
	=
	{    to_cfun_list_h (sprintf "CFUNC(%-44s%-44s%-54s%s%s)\n"
				     ("\""         + fn_name + "\",")
				     ("\""         + fn_name + "\",")
				     ("_lib7_Gtk_" + fn_name + ",")
				     (fn_type =~ ./^\(/ ?? "" :: " ")			   # If type starts with a paren exdent it one space.
				     ("\""         + fn_type + "\"")
			    );
	};

    Doc_Entry
	=
	{ fn_name:  String,
	  lowhalf: String,
	  url:      String,
	  fn_type:  String
	};

    doc_entries
	=
	REF ([]: List( Doc_Entry ));

    # Note a tex documentation table
    # line for file  section-libref-gtk.tex.
    #
    # We delay writing these until the
    # entire specfile has been processed
    # so as to be able to sort the doc
    # table entries alphabetically:
    #
    fun note_libref_tex_entry
	{ state,
	  fn_name,		# E.g. "make_window"
	  lowhalf,		# E.g. "gtk_table_set_col_spacing( GTK_TABLE(/*table*/w0), /*col*/i1, /*spacing*/i2)"
	  url,		# E.g. "http://library.gnome.org/devel/gtk/stable/GtkTable.html#gtk-table-set-col-spacing"
	  fn_type		# E.g. "Session -> Widget"
	}
	=
	{
	    # Get name of the C Gtk function/var
	    # wrapped by this Mythryl function:
	    #
	    lowhalf
		=
		case (maybe_get_field(state,"doc-fn"))

		    THE field => field;	# doc-fn is a manual override used when lowhalf is unusable for documentation.

		    NULL =>
			{   # lowhalf is something like   gtk_widget_set_size_request( GTK_WIDGET(/*widget*/w0), /*wide*/i1, /*high*/i2)
			    # but all we want here is the
			    # initial function name:
			    #
			    lowhalf =  regex::find_first ./[A-Za-z0-9_']+/ lowhalf
				       except
					   NOT_FOUND = "";

			    # If lowhalf does not begin with [Gg], it
			    # is probably not useful in this context:
			    #
			    lowhalf =  (lowhalf =~ ./^[Gg]/)  ??  lowhalf
							      ::  "";

			    lowhalf;
			};	
		esac;


	    fn_name =  slash_underlines  fn_name;
	    lowhalf =  slash_underlines  lowhalf;
	    url     =  slash_underlines  url;		# Probably not needed.
	    fn_type =  slash_underlines  fn_type;

	    doc_entries
		:=
		{ fn_name, lowhalf, url, fn_type } ! *doc_entries;
	};

    # Write tex documentation table into file  section-libref-gtk.tex:
    #
    fun write_libref_tex_table
	( field1: Doc_Entry -> String,
	  field2: Doc_Entry -> String,
	  to_section: String -> Void
	)
	=
	{
	    # Define the sort order for the table:
	    #
	    fun compare_fn
		( a: Doc_Entry,
		  b: Doc_Entry
		)
		=
		{   a1 = field1 a;    a2 = field2 a;
		    b1 = field1 b;    b2 = field2 b;

		    # If primary keys are equal,
		    # sort on the secondary keys:
		    #
		    if (a1 != b1)   a1 > b1;
		    else            a2 > b2;
		    fi;
		};

	    entries =  lms::sort_list  compare_fn  *doc_entries;

	    foreach entries .{

		#entry -> { fn_name, lowhalf, url, fn_type };

		entry1 = field1 #entry;
		entry2 = field2 #entry;

		if (entry1 != "")
		    to_section
			(sprintf "%s & %s & %s & %s \\\\ \\hline\n"
			    entry1
			    entry2
			    (url == "" ?? ""
				       :: (.|\ahref{\url{| + url + "}}{doc}"))
			    fn_type
			);
		fi;
	    };
	};

    #
    fun generate_mythryl_gtk_server_c_fun_header (fn_name, args)
	=
	{
	    to_mythryl_gtk_server_c_funs   "\n";
	    to_mythryl_gtk_server_c_funs  "static void\n";
	    to_mythryl_gtk_server_c_funs ("do_" + fn_name + "( int argc, unsigned char** argv )\n");
	    to_mythryl_gtk_server_c_funs  "{\n";
	    to_mythryl_gtk_server_c_funs (sprintf "    check_argc( \"do_%s\", %d, argc );\n" fn_name args);
	    to_mythryl_gtk_server_c_funs  "\n";
	    to_mythryl_gtk_server_c_funs  "    {\n";
	};


    # Generate C code
    # to fetch all the arguments
    # out of argc/argv:
    #
    fun generate_mythryl_gtk_server_c_fun_arg_loads (fn_name, args, lowhalf)
	=
	{
	    for (a = 0;   a < args;  ++a) {

		# Remember type of this arg,
		# which will be one of:
		#   w (widget),
		#   i (int),
		#   b (bool)
		#   s (string)
		#   f (double):
		#
		arg_type = get_nth_arg_type( a, lowhalf );

		if   (arg_type == "b")    to_mythryl_gtk_server_c_funs (sprintf  "        int               b%d =                        bool_arg( argc, argv, %d );\n"  a a);
		elif (arg_type == "f")    to_mythryl_gtk_server_c_funs (sprintf  "        double            f%d =                      double_arg( argc, argv, %d );\n"  a a);
		elif (arg_type == "i")    to_mythryl_gtk_server_c_funs (sprintf  "        int               i%d =                         int_arg( argc, argv, %d );\n"  a a);
		elif (arg_type == "s")    to_mythryl_gtk_server_c_funs (sprintf  "        char*             s%d =                      string_arg( argc, argv, %d );\n"  a a);
		elif (arg_type == "w")

		    # Usually we fetch a widget as just
		    #
		    #    GtkWidget* widget    =  widget_arg( argc, argv, 0 );
		    #
		    # or such, but in a few cases we must cast to
		    # another type:
		    #  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)   widget_arg( argc, argv, 0 );
		    #  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)        widget_arg( argc, argv, 0 );
		    #  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0  =  (GtkRadioButton*) widget_arg( argc, argv, 0 );

		    widget_type = REF "GtkWidget";

		    if   (lowhalf =~ (sprintf   "GTK_ADJUSTMENT\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkAdjustment";
		    elif (lowhalf =~ (sprintf        "GTK_SCALE\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkScale";
		    elif (lowhalf =~ (sprintf "GTK_RADIO_BUTTON\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkRadioButton";
		    fi;

		    to_mythryl_gtk_server_c_funs (sprintf  "        %-14s    w%d =    %-16s  widget_arg( argc, argv, %d );\n" (*widget_type + "*") a  ("(" + *widget_type + "*)") a);

		else
		    raise exception FAIL ("Bug: unsupported arg type '" + arg_type + "' #" + int::to_string a + " from lowhalf '" + lowhalf + "\n");
		fi;

	    };
	};

    # Synthesize a function for   mythryl-gtk-server-in-c-subprocess.c  like
    # 
    #    static void
    #    do_set_adjustment_value( int argc, unsigned char** argv )
    #    {
    #        check_argc( "do_make_label", 2, argc );
    #    
    #        {   GtkAdjustment* w0 =  (GtkAdjustment*) widget_arg( argc, argv, 0 );
    #            double         f1 =                   double_arg( argc, argv, 1 );
    #
    #    	     gtk_adjustment_set_value( GTK_ADJUSTMENT(w0), /*value*/f1);
    #        }
    #    }
    #    
    fun write_mythryl_gtk_server_c_plain_fun
	( state: State,
	  fn_name,			# E.g., "make_window2"
	  fn_type,			# E.g., "Session -> Widget".
	  lowhalf,			# E.g., "gtk_window_new( GTK_WINDOW_TOPLEVEL )".
	  result			# E.g., "Float"
	)
	=
	{
	    arg_count = count_args( lowhalf );

	    generate_mythryl_gtk_server_c_fun_header    (fn_name, arg_count);
	    generate_mythryl_gtk_server_c_fun_arg_loads (fn_name, arg_count, lowhalf);

	    case result

		"Void"
		    =>
		    {   # Now we just print
			# the supplied gtk call
			# and wrap up:
			#
			to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs ("        " + lowhalf + ";\n");
			to_mythryl_gtk_server_c_funs "    }\n";
			to_mythryl_gtk_server_c_funs "}\n";
			to_mythryl_gtk_server_c_funs "/* Above fn generated by src/lib/src/make-gtk-glue: write_mythryl_gtk_server_c_plain_fun. */\n";
		    };

		"new Widget"
		    =>
		    {   to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs "        int slot = find_free_widget_slot ();\n";
			to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs("        widget[slot] = " + lowhalf + ";\n");
			to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs("         printf(             \"" + fn_name + "%d\\n\", slot);      fflush( stdout );\n");
			to_mythryl_gtk_server_c_funs("        fprintf(log_fd, \"SENT:" + fn_name + "%d\\n\", slot);      fflush( log_fd );\n");
			to_mythryl_gtk_server_c_funs "    }\n";
			to_mythryl_gtk_server_c_funs "}\n";
			to_mythryl_gtk_server_c_funs "/* Above fn generated by src/lib/src/make-gtk-glue: write_mythryl_gtk_server_c_plain_fun. */\n";
		    };

		"Widget"
		    =>
		    {   to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs("        GtkWidget* widget = (GtkWidget*) " + lowhalf + ";\n");
			to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs "        int slot = get_widget_id( widget );\n";
			to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs("         printf(              \"" + fn_name + "%d\\n\", slot);      fflush( stdout );\n");
			to_mythryl_gtk_server_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%d\\n\", slot);      fflush( log_fd );\n");
			to_mythryl_gtk_server_c_funs "    }\n";
			to_mythryl_gtk_server_c_funs "}\n";
			to_mythryl_gtk_server_c_funs "/* Above fn generated by src/lib/src/make-gtk-glue: write_mythryl_gtk_server_c_plain_fun. */\n";
		    };

		"Bool"
		    =>
		    {   to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs("        int result = " + lowhalf + ";\n");
			to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs("         printf(              \"" + fn_name + "%d\\n\", result);      fflush( stdout );\n");
			to_mythryl_gtk_server_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%d\\n\", result);      fflush( log_fd );\n");
			to_mythryl_gtk_server_c_funs "    }\n";
			to_mythryl_gtk_server_c_funs "}\n";
			to_mythryl_gtk_server_c_funs "/* Above fn generated by src/lib/src/make-gtk-glue: write_mythryl_gtk_server_c_plain_fun. */\n";
		    };

		"Float"
		    =>
		    {   to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs("        double result = " + lowhalf + ";\n");
			to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs("         printf(              \"" + fn_name + "%f\\n\", result);      fflush( stdout );\n");
			to_mythryl_gtk_server_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%f\\n\", result);      fflush( log_fd );\n");
			to_mythryl_gtk_server_c_funs "    }\n";
			to_mythryl_gtk_server_c_funs "}\n";
			to_mythryl_gtk_server_c_funs "/* Above fn generated by src/lib/src/make-gtk-glue: write_mythryl_gtk_server_c_plain_fun. */\n";

		    };

		"Int"
		    =>
		    {   to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs("        int result = " + lowhalf + ";\n");
			to_mythryl_gtk_server_c_funs "\n";
			to_mythryl_gtk_server_c_funs("         printf(              \"" + fn_name + "%d\\n\", result);      fflush( stdout );\n");
			to_mythryl_gtk_server_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%d\\n\", result);      fflush( log_fd );\n");
			to_mythryl_gtk_server_c_funs "    }\n";
			to_mythryl_gtk_server_c_funs "}\n";
			to_mythryl_gtk_server_c_funs "/* Above fn generated by src/lib/src/make-gtk-glue: write_mythryl_gtk_server_c_plain_fun. */\n";
		    };

		_   =>  raise exception FAIL (sprintf "Unsupported result type '%s' at line %d" result *state.line_number);

	    esac;

	    gtk_server_plain_fns_autogenerated
		:=
		*gtk_server_plain_fns_autogenerated
		+ 1;
	};

    #
    fun generate_gtk_driver_c_fun_header (fn_name, fn_type, args, lowhalf, result_type)
	=
	{
	    my (input_type, output_type)
		=
		gtk_driver_api_type (lowhalf, result_type);

	    # C comments don't nest, so we must change
	    # any C comments in input_type or output_type:
	    #
	    input_type  = regex::replace_all   .|/\*|   "(*"    input_type;
	    input_type  = regex::replace_all   .|\*/|   "*)"    input_type;
	    #
	    output_type = regex::replace_all   .|/\*|   "(*"   output_type;
	    output_type = regex::replace_all   .|\*/|   "*)"   output_type;


	    to_gtk_driver_c ("/* _lib7_Gtk_" + fn_name + "\n");
	    to_gtk_driver_c  " *\n";
	    to_gtk_driver_c (" * gtk-client.api        type:   " + (   fn_type =~ ./^\(/ ?? "" :: " ") + fn_type + "\n");
	    to_gtk_driver_c (" * gtk-client-driver.api type:   " + (input_type =~ ./^\(/ ?? "" :: " ") + input_type + " -> " + output_type + "\n");
	    to_gtk_driver_c  " */\n";
	    to_gtk_driver_c ("Val   _lib7_Gtk_" + fn_name + "   (Task* task, Val arg)\n");
	    to_gtk_driver_c  "{\n";
	    to_gtk_driver_c  "#if (HAVE_GTK_2_0_GTK_GTK_H || HAVE_GTK_GTK_H)\n";
	    to_gtk_driver_c  "\n";
	};

    #
    fun generate_gtk_driver_c_fun_trailer ()
	=
	{
	    to_gtk_driver_c  "#else\n";
	    to_gtk_driver_c  "    extern char* no_gtk_support_in_runtime;\n";
	    to_gtk_driver_c  "    return RAISE_ERROR__MAY_HEAPCLEAN(task, no_gtk_support_in_runtime, NULL);\n";
	    to_gtk_driver_c  "#endif\n";
	    to_gtk_driver_c  "}\n";
	    to_gtk_driver_c "/* Above fn generated by src/lib/src/make-gtk-glue: write_gtk_driver_c_plain_fun. */\n";
	    to_gtk_driver_c  "\n";
	    to_gtk_driver_c  "\n";
	};


    # Generate C code
    # to fetch all the arguments
    # out of argc/argv:
    #
    fun generate_gtk_driver_c_fun_arg_loads (fn_name, fn_type, args, lowhalf)
	=
	{
	    case args
		0 => ();

    #            Having just one argument used to be a special case
    #            because then we passed the argument directly rather
    #            than packed within a tuple.  But the first argument
    #            to a gtk-client-driver-for-server-in-main-process.pkg function is always a Session,
    #            and it is more efficient to pass on the tuple from
    #            that layer to the mythryl-gtk-server-in-main-process.c layer rather than
    #            unpacking and repacking just to get rid of the Session
    #            argument, consequently if we have any arguments of
    #            interest (i.e., non-Session arguments) at this point
    #            we will always have a tuple, eliminating the special
    #	         case.  I've left this code here, commented out, just
    #            in case this situation changes and it is needed again:
    #
    #
    #            1 => {  arg_type = get_nth_arg_type( 0, lowhalf );
    #
    #		    if   (arg_type == "b")    to_gtk_driver_c "    int    b0 = TAGGED_INT_TO_C_INT(arg) == HEAP_TRUE;\n";
    #		    elif (arg_type == "f")    to_gtk_driver_c "    double f0 = *(PTR_CAST(double*, arg));\n";
    #		    elif (arg_type == "i")    to_gtk_driver_c "    int    i0 = TAGGED_INT_TO_C_INT(arg);\n";
    #		    elif (arg_type == "s")    to_gtk_driver_c "    char*  s0 = HEAP_STRING_AS_C_STRING(arg);\n";
    #		    elif (arg_type == "w")
    #
    #			# Usually we fetch a widget as just
    #			#
    #			#    GtkWidget* widget    =  widget[ TAGGED_INT_TO_C_INT(arg) ];
    #			#
    #			# or such, but in a few cases we must cast to
    #			# another type:
    #			#  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)  widget[ TAGGED_INT_TO_C_INT(arg) ];
    #			#  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)       widget[ TAGGED_INT_TO_C_INT(arg) ];
    #			#  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0 =  (GtkRadioButton*) widget[ TAGGED_INT_TO_C_INT(arg) ];
    #
    #			widget_type = REF "GtkWidget";
    #
    #			if   (lowhalf =~   ./GTK_ADJUSTMENT\(\s*w0\s*\)/)   widget_type := "GtkAdjustment";
    #			elif (lowhalf =~        ./GTK_SCALE\(\s*w0\s*\)/)   widget_type := "GtkScale";
    #			elif (lowhalf =~ ./GTK_RADIO_BUTTON\(\s*w0\s*\)/)   widget_type := "GtkRadioButton";
    #			fi;
    #
    #			to_gtk_driver_c (sprintf  "    %-14s    w0 =    %-16s  widget[ TAGGED_INT_TO_C_INT(arg) ];\n"
    #                                                  (*widget_type + "*")
    #                                                  ("(" + *widget_type + "*)")
    #                                        );
    #
    #		    else
    #			raise exception FAIL ("Bug: unsupported arg type '" + arg_type + "' #0 from lowhalf '" + lowhalf + "\n");
    #		    fi;
    #		};

		_ => {  if (args < 0)  die_x "generate_gtk_driver_c_fun_arg_loads: Negative 'args' value not supported.";  fi;
			#
			for (a = 0;   a < args;  ++a) {
			    #
			    # Remember type of this arg,
			    # which will be one of:
			    #   w (widget),
			    #   i (int),
			    #   b (bool)
			    #   s (string)
			    #   f (double):
			    #
			    arg_type = get_nth_arg_type( a, lowhalf );

			    if   (arg_type == "b")    to_gtk_driver_c (sprintf  "    int               b%d =                            GET_TUPLE_SLOT_AS_VAL( arg, %d) == HEAP_TRUE;\n"   a (a+1)); # +1 because 1st arg is always Session.
			    elif (arg_type == "f")    to_gtk_driver_c (sprintf  "    double            f%d =        *(PTR_CAST(double*, GET_TUPLE_SLOT_AS_VAL( arg, %d)));\n"              a (a+1));
			    elif (arg_type == "i")    to_gtk_driver_c (sprintf  "    int               i%d =                            GET_TUPLE_SLOT_AS_INT( arg, %d);\n"                a (a+1));
			    elif (arg_type == "s")    to_gtk_driver_c (sprintf  "    char*             s%d =   HEAP_STRING_AS_C_STRING (GET_TUPLE_SLOT_AS_VAL( arg, %d));\n"               a (a+1));
			    elif (arg_type == "w")

				# Usually we fetch a widget as just
				#
				#    GtkWidget* widget    =  widget[ GET_TUPLE_SLOT_AS_INT (arg, i) ];
				#
				# or such, but in a few cases we must cast to
				# another type:
				#  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)   widget[ GET_TUPLE_SLOT_AS_INT( arg, i) ];
				#  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)        widget[ GET_TUPLE_SLOT_AS_INT( arg, i) ];
				#  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0  =  (GtkRadioButton*) widget[ GET_TUPLE_SLOT_AS_INT( arg, i) ];

				widget_type = REF "GtkWidget";

				if   (lowhalf =~ (sprintf   "GTK_ADJUSTMENT\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkAdjustment";
				elif (lowhalf =~ (sprintf        "GTK_SCALE\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkScale";
				elif (lowhalf =~ (sprintf "GTK_RADIO_BUTTON\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkRadioButton";
				fi;

				to_gtk_driver_c (sprintf  "    %-14s    w%d  =    %-16s  widget[ GET_TUPLE_SLOT_AS_INT( arg, %d) ];\n"
							  (*widget_type + "*")
							  a
							  ("(" + *widget_type + "*)")
							  (a+1)				# +1 because first arg is always Session.
						);

			    else
				raise exception FAIL ("Bug: unsupported arg type '" + arg_type + "' #" + int::to_string a + " from lowhalf '" + lowhalf + "\n");
			    fi;

			};
		    };
	    esac;
	};
    #
    fun generate_gtk_driver_c_fun_body
	( state: State,
	  fn_name,			# E.g., "make_window2"
	  fn_type,			# E.g., "Session -> Widget".
	  lowhalf,			# E.g., "gtk_window_new( GTK_WINDOW_TOPLEVEL )".
	  result_type		# E.g., "Float"
	)
	=
	{
	    case result_type

		"Void"
		    =>
		    {   # Now we just print
			# the supplied gtk call
			# and wrap up:
			#
			to_gtk_driver_c "\n";
			to_gtk_driver_c ("    " + lowhalf + ";\n");
			to_gtk_driver_c "\n";
			to_gtk_driver_c  "    return HEAP_VOID;\n";
		    };

		"new Widget"
		    =>
		    {   to_gtk_driver_c  "\n";
			to_gtk_driver_c  "    int slot = find_free_widget_slot ();\n";
			to_gtk_driver_c  "\n";
			to_gtk_driver_c ("    widget[slot] = " + lowhalf + ";\n");
			to_gtk_driver_c  "\n";
			to_gtk_driver_c  "    return TAGGED_INT_FROM_C_INT(slot);\n";
		    };

		"Widget"
		    =>
		    {   to_gtk_driver_c  "\n";
			to_gtk_driver_c ("    GtkWidget* widget = (GtkWidget*) " + lowhalf + ";\n");
			to_gtk_driver_c  "\n";
			to_gtk_driver_c  "    int slot = get_widget_id( widget );\n";
			to_gtk_driver_c  "\n";
			to_gtk_driver_c  "    return TAGGED_INT_FROM_C_INT(slot);\n";
		    };

		"Bool"
		    =>
		    {   to_gtk_driver_c  "\n";
			to_gtk_driver_c ("    int result = " + lowhalf + ";\n");
			to_gtk_driver_c  "\n";
			to_gtk_driver_c  "    return  result ? HEAP_TRUE : HEAP_FALSE;\n";
		    };

		"Float"
		    =>
		    {   to_gtk_driver_c  "\n";
			to_gtk_driver_c ("    double d = " + lowhalf + ";\n");
			to_gtk_driver_c  "\n";
			to_gtk_driver_c  "    return  make_float64(task, d );\n";
		    };

		"Int"
		    =>
		    {   to_gtk_driver_c  "\n";
			to_gtk_driver_c ("    int result = " + lowhalf + ";\n");
			to_gtk_driver_c  "\n";
			to_gtk_driver_c  "    return TAGGED_INT_FROM_C_INT(result);\n";
		    };

		_   =>  raise exception FAIL (sprintf "Unsupported result type '%s' at line %d"  result_type  *state.line_number);

	    esac;
	};

    # Synthesize a function for   mythryl-gtk-server-in-main-process.c  like
    # 
    #   /* _lib7_Gtk_gtk_init : Void -> Void
    #    *
    #    *
    #    */
    #   
    #   Val _lib7_Gtk_gtk_init (Task* task, Val arg)
    #   {
    #   #if (HAVE_GTK_2_0_GTK_GTK_H || HAVE_GTK_GTK_H)
    #   
    #       int y         = INT1_LIB7toC( GET_TUPLE_SLOT_AS_INT(arg, 0) );
    #       char *symname = HEAP_STRING_AS_C_STRING(   GET_TUPLE_SLOT_AS_VAL   (arg, 1) );
    #       int lazy      =                GET_TUPLE_SLOT_AS_VAL   (arg, 2) == HEAP_TRUE;
    #
    #       int result = move( y, x );
    #   
    #       if (result == ERR)     return RAISE_ERROR__MAY_HEAPCLEAN(task, "move", NULL);
    #   
    #       return HEAP_VOID;
    #   #else
    #       extern char* no_gtk_support_in_runtime;
    #   
    #       return RAISE_ERROR__MAY_HEAPCLEAN(task, no_gtk_support_in_runtime, NULL);
    #   #endif
    #   }
    #    
    #    
    #    
    # Cheatsheet:
    #    
    #   Accepting a lone float arg:
    #      double d = *(PTR_CAST(double*, arg));					# Example in src/c/lib/math/cos64.c
    #
    #   Accepting a lone int arg:
    #      int socket = TAGGED_INT_TO_C_INT(arg);					# Example in src/c/lib/socket/accept.c
    #
    #   Accepting a lone string arg:							# Example in src/c/lib/posix-file-system/readlink.c
    #      char* path = HEAP_STRING_AS_C_STRING(arg);
    #
    #   Accepting a lone Null_Or( Tuple ) arg:						# Example in src/c/lib/socket/get-protocol-by-name.c
    #       
    #   Accepting a Bool from a tuple:      						# Example in src/c/lib/dynamic-loading/dlopen.c
    #     int lazy = GET_TUPLE_SLOT_AS_VAL (arg, 1) == HEAP_TRUE;
    #
    #   Accepting an Int from a tuple:							# Example in src/c/lib/posix-file-system/fchown.c
    #     int fd =  GET_TUPLE_SLOT_AS_INT (arg, 0);
    #
    #   Accepting a String from a tuple:						# Example in src/c/lib/dynamic-loading/dlsym.c
    #     char *symname = HEAP_STRING_AS_C_STRING (GET_TUPLE_SLOT_AS_VAL (arg, 1));
    #       
    #   Accepting a Float from a tuple:							# THIS IS MY OWN GUESS!
    #     double d =  *(PTR_CAST(double*, GET_TUPLE_SLOT_AS_VAL(arg,%d)));
    #
    #   Accepting a Null_Or(String) from a tuple:   					# Example in src/c/lib/dynamic-loading/dlopen.c
    #       
    #       
    #   Returning
    #
    #     Void:    return HEAP_VOID;							# Defined in src/c/h/runtime-values.h
    #     TRUE:    return HEAP_TRUE;							# Defined in src/c/h/runtime-values.h
    #     FALSE:   return HEAP_FALSE;							# Defined in src/c/h/runtime-values.h
    #     Int:     return TAGGED_INT_FROM_C_INT(size);					# Defined in src/c/h/runtime-values.h
    #     NULL:    return OPTION_NULL;							# Defined in src/c/h/make-strings-and-vectors-etc.h    Example in src/c/machine-dependent/interprocess-signals.c
    #     THE foo: return OPTION_THE(task, foo);					# Defined in src/c/h/make-strings-and-vectors-etc.h
    #              									# Example in src/c/machine-dependent/interprocess-signals.c
    #
    #   Returning a float:
    #              return  make_float64(task, cos(d) );					# Defined in src/c/h/make-strings-and-vectors-etc.h
    #
    #   Returning a string:
    #       Val result = allocate_nonempty_ascii_string__may_heapclean(task, size, NULL);
    #	strncpy (HEAP_STRING_AS_C_STRING(result), buf, size);
    #	return result;
    #    
    #   Returning a tuple:									# Example from src/c/lib/date/gmtime.c
    #
    #       set_slot_in_nascent_heapchunk(task, 0, MAKE_TAGWORD(PAIRS_AND_RECORDS_BTAG, 9));
    #       set_slot_in_nascent_heapchunk(task, 1, TAGGED_INT_FROM_C_INT(tm->tm_sec));
    #       ...
    #       set_slot_in_nascent_heapchunk(task, 9, TAGGED_INT_FROM_C_INT(tm->tm_isdst));
    #
    #       return commit_nascent_heapchunk(task, 9);
    #    
    #    
    #     Return functions which check ERR
    #     and optionally raise an exception:             src/c/lib/raise-error.h
    #
    #	CHK_RETURN_VAL(task, status, val)	Check status for an error (< 0); if okay,
    #					then return val.  Otherwise raise
    #					SYSTEM_ERROR with the appropriate system
    #					error message.
    #
    #	CHK_RETURN(task, status)	Check status for an error (< 0); if okay,
    #					then return it as the result (after
    #					converting to an Lib7 int).
    #
    #	CHK_RETURN_UNIT(task, status)	Check status for an error (< 0); if okay,
    #					then return Void.
    #
    #     GET_TUPLE_SLOT_AS_VAL &Co        are from:  src/c/h/runtime-values.h
    #     allocate_nonempty_ascii_string__may_heapclean    is from:  src/c/h/make-strings-and-vectors-etc.h
    #     CHK_RETURN_VAL &Co are from:  src/c/lib/raise-error.h
    #
    fun write_gtk_driver_c_plain_fun
	( state: State,
	  fn_name,			# E.g., "make_window2"
	  fn_type,			# E.g., "Session -> Widget".
	  lowhalf,			# E.g., "gtk_window_new( GTK_WINDOW_TOPLEVEL )".
	  result_type		# E.g., "Float"
	)
	=
	{   arg_count =  count_args( lowhalf );
	    #
	    generate_gtk_driver_c_fun_header    (       fn_name, fn_type, arg_count, lowhalf, result_type);
	    generate_gtk_driver_c_fun_arg_loads (       fn_name, fn_type, arg_count, lowhalf);
	    generate_gtk_driver_c_fun_body      (state, fn_name, fn_type, lowhalf, result_type);

	    generate_gtk_driver_c_fun_trailer ();

	    gtk_driver_plain_fns_autogenerated
		:=
		*gtk_driver_plain_fns_autogenerated
		+ 1;
	};

    # Given a lowhalf like      "gtk_foo( /*bar_to_int bar*/i0, /*zot*/i1 )"
    # and a parameter name like  "i0" or "i1"
    # return nickname like       "bar_to_int bar" or "zot"
    # if available, else         "i0" or "i1":
    #
    fun arg_name (arg, lowhalf)
	=
	{   regex = .|/\*([A-Za-z0-9_' ]+)\*/| + arg;	# Something like:   /*([A-Za-z0-9_' ]+)*/f0

	    (regex::find_first_group 1 regex lowhalf)
	    except
		NOT_FOUND = arg;
	};

    # Given a lowhalf like      "gtk_foo( /*bar_to_int bar*/i0, /*zot*/i1 )"
    # and a parameter name like  "i0" or "i1"
    # return nickname like       "bar" or "zot"
    # if available, else         "i0" or "i1":
    #
    fun param_name (arg, lowhalf)
	=
	{   regex = .|/\*([A-Za-z0-9_' ]+)\*/| + arg;		# Something like:   /*([A-Za-z0-9_' ]+)*/f0

	    {
		name = regex::find_first_group 1 regex lowhalf;

		# If 'name' contains blanks, we want
		# only the part after the last blank:
		# 
		name = (regex::find_first_group 1 .|^[:A-Za-z0-9_' ]+ ([A-Za-z0-9_']+)$| name)
		       except
			   NOT_FOUND = name;

		name;
	    }
	    except NOT_FOUND = arg;
	};

    # Synthesize a function for   gtk-client-g.pkg  like
    # 
    #	 #
    #        fun make_vertical_scale_with_range (session: Session, min, max, step)
    #            =
    #	    drv::make_vertical_scale_with_range (session.subsession, min, max, step);
    #
    fun write_gtk_g_pkg_plain_fun( state: State,  fn_name, lowhalf)
	=
	case (maybe_get_field (state, "code"))
	    #
	    THE field
		=>
		{   to_gtk_g_pkg_funs  "        #\n";
		    to_gtk_g_pkg_funs  field;
		    to_gtk_g_pkg_funs  "            \n";
		    to_gtk_g_pkg_funs  "            # Above function handgenerated via write_gtk_pkg_plain_fun.\n";
		    to_gtk_g_pkg_funs  "\n";

		    gtk_g_pkg_plain_fns_handgenerated
			:=
			*gtk_g_pkg_plain_fns_handgenerated + 1;
		};

	    NULL =>
		{
		    arg_count = count_args( lowhalf );

		    fun make_args get_name		# get_name will be arg_name or param_name.
			=
			for (a = 0; a < arg_count; ++a) {

			    # Remember type of this arg,
			    # which will be one of:
			    #   w (widget),
			    #   i (int),
			    #   b (bool)
			    #   s (string)
			    #   f (double):
			    #
			    arg_type = get_nth_arg_type( a, lowhalf );

			    arg = sprintf "%s%d" arg_type a;

			    to_gtk_g_pkg_funs (sprintf ", %s" (get_name (arg, lowhalf)));
			}; 

		    # Select between  foo  (session.subsession, bar, zot);
		    #                 foo { session.subsession, bar, zot };
		    #
		    my (lparen, rparen)
			=
			# It is a poor idea to have gtk-client-g.pkg functions
			# with multiple arguments of the same type use
			# argument tuples, because it is too easy to
			# mis-order such arguments, and the compiler
			# type checking won't flag it -- in such cases
			# it is better to use argument records:
			#
			arg_types_are_all_unique  lowhalf
			    ??  ( "(" ,  ")" )
			    ::  ( "{ ", " }" );

		    to_gtk_g_pkg_funs "\n";
		    to_gtk_g_pkg_funs "        #\n";
		    to_gtk_g_pkg_funs "        fun ";
		    to_gtk_g_pkg_funs fn_name;


		    to_gtk_g_pkg_funs (sprintf " %ssession: Session"  lparen);
		    make_args  param_name;
		    to_gtk_g_pkg_funs (sprintf "%s\n" rparen);


		    # Select between  drv::foo   session.subsession;
		    #                 drv::foo  (session.subsession, bar, zot);
		    #
		    my (lparen, rparen)
			=
			arg_count == 0
			    ??  (" ", "" )
			    ::  ("(", ")");

		    fn_name =   regex::replace_all ./'/ "2" fn_name;		# Primes don't work in C!

		    to_gtk_g_pkg_funs          "            =\n";
		    to_gtk_g_pkg_funs (sprintf "            drv::%s %ssession.subsession" fn_name lparen);
		    make_args  arg_name;
		    to_gtk_g_pkg_funs (sprintf "%s;\n" rparen);

		    to_gtk_g_pkg_funs "            \n";
		    to_gtk_g_pkg_funs "            # Above function autogenerated by write_gtk_pkg_plain_fun.\n";
		    to_gtk_g_pkg_funs "\n";


		    gtk_g_pkg_plain_fns_autogenerated
			:=
			*gtk_g_pkg_plain_fns_autogenerated
			+ 1;
		};
	esac;

    # Synthesize a function for   gtk-client-g.pkg  like
    # 
    #	 #
    #	 fun set_clicked_callback  s w c = set_void_callback (s, c, drv::set_clicked_callback (s.subsession, w));	# Handle "clicked" signal.
    #
    fun write_gtk_g_pkg_callback_fun
	( state: State,
	  fn_name,			# E.g. "set_foo_callback"
	  callback_type		# E.g. "Void_Callback"
	)
	=
	case (maybe_get_field (state, "code"))
	    #
	    THE field
		=>
		{   to_gtk_g_pkg_funs  "        #\n";
		    to_gtk_g_pkg_funs  field;
		    to_gtk_g_pkg_funs  "            \n";
		    to_gtk_g_pkg_funs  "            # Above function handgenerated via write_gtk_pkg_callback_fun.\n";
		    to_gtk_g_pkg_funs  "\n";

		    gtk_g_pkg_callback_fns_handgenerated
			:=
			*gtk_g_pkg_callback_fns_handgenerated + 1;
		};

	    NULL =>
		{
		    signal_name
			=
			(regex::find_first_group 1 ./^set_(.*)_callback$/  fn_name)
			except
			    NOT_FOUND
				=
				die_x(sprintf "write_gtk_g_pkg_callback_fun: fn_name '%s' does not have form set_foo_callback for any foo\n" fn_name);

		    note_callback_fn = "note_" + (tolower callback_type);		# "Void_Callback" -> "note_void_callback"

		    to_gtk_g_pkg_funs
			(    sprintf "    fun %-36s s w c = %-28s (s, c, drv::%-36s (s.subsession, w));\t# Handle '%s' signal\n"
				     fn_name
				     note_callback_fn
				     fn_name
				     signal_name
			);

		    gtk_g_pkg_callback_fns_autogenerated
			:=
			*gtk_g_pkg_callback_fns_autogenerated
			+ 1;
		};
	esac;


    # Synthesize a function for   mythryl-gtk-server-in-c-subprocess.c  like
    #
    #    static void
    #    do_set_foo_callback( int argc, unsigned char** argv )
    #    {
    #	check_argc( "do_foo_callback", 1, argc );
    #
    #	{   GtkWidget* widget    =  widget_arg( argc, argv, 0 );
    #
    #	    int id   =  find_free_callback_id ();
    #
    #	    g_signal_connect( G_OBJECT(widget), "foo", G_CALLBACK( run_foo_callback ), (void*)id );
    #
    #	    printf(               "set_foo_callback%d\n", id );	fflush( stdout );
    #	    fprintf(log_fd, "SENT: set_foo_callback%d\n", id );	fflush( log_fd );
    #	}
    #    }
    #
    fun write_gtk_server_c_set_callback_fun (callback_name, lowtype)
	=
	{
	    to_mythryl_gtk_server_c_funs "\n";
	    to_mythryl_gtk_server_c_funs "static void\n";
	    to_mythryl_gtk_server_c_funs("do_set_" + callback_name + "_callback( int argc, unsigned char** argv )\n");
	    to_mythryl_gtk_server_c_funs "{\n";
	    to_mythryl_gtk_server_c_funs("    check_argc( \"do_set_" + callback_name + "_callback\", 1, argc );\n");
	    to_mythryl_gtk_server_c_funs "\n";
	    to_mythryl_gtk_server_c_funs "    {   GtkWidget* widget    =  widget_arg( argc, argv, 0 );\n";
	    to_mythryl_gtk_server_c_funs "\n";
	    to_mythryl_gtk_server_c_funs "        int id   =  find_free_callback_id ();\n";
	    to_mythryl_gtk_server_c_funs "\n";
	    to_mythryl_gtk_server_c_funs("        g_signal_connect( " + lowtype + "(widget), \"" + callback_name + "\", G_CALLBACK( run_" + callback_name + "_callback ), (void*)id );\n");
	    to_mythryl_gtk_server_c_funs "\n";
	    to_mythryl_gtk_server_c_funs("         printf(              \"set_" + callback_name + "_callback%d\\n\", id );      fflush( stdout );\n");
	    to_mythryl_gtk_server_c_funs("        fprintf(log_fd, \"SENT: set_" + callback_name + "_callback%d\\n\", id );      fflush( log_fd );\n");
	    to_mythryl_gtk_server_c_funs "    }\n";
	    to_mythryl_gtk_server_c_funs "}\n";
	    to_mythryl_gtk_server_c_funs "/* Above fn generated by src/lib/src/make-gtk-glue: write_gtk_server_c_set_callback_fun. */\n";

	    gtk_server_callback_fns_autogenerated
		:=
		*gtk_server_callback_fns_autogenerated
		+ 1;
	};


    # Synthesize a function for   mythryl-gtk-server-in-main-process.c  like
    #
    #   /* _lib7_Gtk_set_foo_callback : Session -> Widget -> Void_Callback -> Void;
    #    */
    #   Val _lib7_Gtk_set_foo_callback (Task* task, Val arg)
    #   {
    #   #if (HAVE_GTK_2_0_GTK_GTK_H || HAVE_GTK_GTK_H)
    #   
    #       GtkWidget*        w0 =    (GtkWidget*)      widget[ GET_TUPLE_SLOT_AS_INT( arg, 1) ];	// '1' because 'arg' is a duple (session, widget).
    #
    #       int id   =  find_free_callback_id ();
    #
    #       g_signal_connect( G_OBJECT(widget), "clicked", G_CALLBACK( run_clicked_callback ), (void*)id );
    #
    #       return TAGGED_INT_FROM_C_INT(id);
    #   #else
    #       extern char* no_gtk_support_in_runtime;
    #
    #       return RAISE_ERROR__MAY_HEAPCLEAN(task, no_gtk_support_in_runtime, NULL);
    #   #endif
    #   }
    #    
    fun write_gtk_driver_c_set_callback_fun
	( callback_name,
	  fn_type,			# E.g., "Session -> Widget -> Void_Callback -> Void".
	  lowtype
	)
	=
	{
	    to_gtk_driver_c "\n";
	    to_gtk_driver_c "\n";
	    to_gtk_driver_c("/*  _lib7_Gtk_set_" + callback_name + "_callback : " + fn_type + "\n");
	    to_gtk_driver_c " */\n";
	    to_gtk_driver_c("Val   _lib7_Gtk_set_" + callback_name + "_callback (Task* task, Val arg)\n");
	    to_gtk_driver_c "{\n";
	    to_gtk_driver_c  "#if (HAVE_GTK_2_0_GTK_GTK_H || HAVE_GTK_GTK_H)\n";
	    to_gtk_driver_c  "\n";
	    to_gtk_driver_c  "    GtkWidget*        w0 __attribute__((unused)) =    (GtkWidget*)      widget[ GET_TUPLE_SLOT_AS_INT( arg, 1) ];        // '1' because 'arg' is a duple (session, widget).\n";
	    to_gtk_driver_c  "\n";		# The '__attribute__((unused))' is just to suppress some   unused variable 'w0'   compiler warnings.
	    to_gtk_driver_c "    int id   =  find_free_callback_id ();\n";
	    to_gtk_driver_c "\n";
	    to_gtk_driver_c("    g_signal_connect( " + lowtype + "(w0), \"" + callback_name + "\", G_CALLBACK( run_" + callback_name + "_callback ), (void*)id );\n");
	    to_gtk_driver_c "\n";
	    to_gtk_driver_c "    return TAGGED_INT_FROM_C_INT(id);\n";
	    to_gtk_driver_c  "#else\n";
	    to_gtk_driver_c  "    extern char* no_gtk_support_in_runtime;\n";
	    to_gtk_driver_c "\n";
	    to_gtk_driver_c  "    return RAISE_ERROR__MAY_HEAPCLEAN(task, no_gtk_support_in_runtime, NULL);\n";
	    to_gtk_driver_c  "#endif\n";
	    to_gtk_driver_c  "}\n";
	    to_gtk_driver_c "/* Above fn generated by src/lib/src/make-gtk-glue: write_gtk_driver_c_set_callback_fun. */\n";
	    to_gtk_driver_c  "\n";
	    to_gtk_driver_c  "\n";

	    gtk_driver_callback_fns_autogenerated
		:=
		*gtk_driver_callback_fns_autogenerated
		+ 1;
	};

    # Synthesize a gtk-client.api line like
    #
    #      make_window:    Session -> Widget;
    #
    stipulate

	line_count = REF 2;

    herein

	#
	fun write_gtk_api_function_declaration (fn_name, fn_type)
	    =
	    {
		# Add a blank line every three declarations:
		#
		line_count := *line_count + 1;

		if ((*line_count % 3) == 0)

		    to_gtk_api_funs  "\n";
		fi;

		# The 'if' here is just to exdent by one char
		# types starting with a paren, so that we get
		#
		#     foo:    Session -> Void;
		#     bar:   (Session, Widget) -> Void;
		#
		# rather than the slightly rattier looking  
		#
		#     foo:    Session -> Void;
		#     bar:    (Session, Widget) -> Void;
		#
		if (fn_type =~ ./^\(/)	to_gtk_api_funs (sprintf "    %-40s%s;\n"  (fn_name + ":")  fn_type);
		else			to_gtk_api_funs (sprintf "    %-41s%s;\n"  (fn_name + ":")  fn_type);
		fi;
	    };
    end;

    #
    fun update_field (state: State, field_name, field_line)
	=
	{
	    case (string_map::get (*state.fields, field_name))

		THE field
		    =>
		    {   field.string := *field.string + field_line;
			field.line_n := *state.line_number;

			string_map::set (*state.fields, field_name, field);

			();
		    };

		NULL =>
		    {   field = { string =>  REF field_line,
				  line_1 =>  REF *state.line_number,
				  line_n =>  REF *state.line_number,
				  used   =>  REF FALSE
				};

			state.fields
			    :=
			    string_map::set (*state.fields, field_name, field);

			();
		    };
	    esac;
	};

    #
    fun make_callback_function (state: State)
	=
	{
	    fn_name  =  get_field(state, "fn-name");		# "set_foo_callback"
	    fn_type  =  get_field(state, "fn-type");		# "Session -> Widget -> Foo_Callback -> Void"
	    lowtype  =  get_field(state, "lowtype");		# "G_OBJECT"

	    callback_name
		=
		(regex::find_first_group 1 ./^set_(.*)_callback$/  fn_name)
		except
		    NOT_FOUND
			=
			die_x(sprintf "%s: callback-fn fn-name '%s' does not have form 'set_foo_callback' for any 'foo'\n"
				     (get_field_location (state, "fn-name"))
				     fn_name
			    );

	    callback_type		# E.g., "Void_Callback"
		=
		(regex::find_first_group 1 ./^Session\s+->\s+Widget\s+->\s+(\S+)\s+->\s+Void$/ fn_type)
		except
		    NOT_FOUND
			=
			die_x(sprintf "%s: callback-fn fn-type '%s' does not have form 'Session -> Widget -> Foo_Callback -> Void' for any 'foo'\n"
				     (get_field_location (state, "fn-type"))
				     fn_type
			    );

	    callback_name
		=
		regex::replace_all ./'/ "2" callback_name;		# Primes don't work in C!

	    fn_name2 = "set_" + callback_name + "_callback";

	    write_gtk_server_c_set_callback_fun( callback_name, lowtype );
	    write_gtk_driver_c_set_callback_fun( callback_name, fn_type, lowtype );

	    write_cfun_list_h_entry          (fn_name2, fn_type);
	    write_trie_entry_for_gtk_server_c( fn_name2 );

	    url =   case (maybe_get_field(state,"url"))
			THE field => field;
			NULL      => "http://library.gnome.org/devel/gobject/unstable/gobject-Signals.html#g-signal-connect";
		    esac;

	    note_libref_tex_entry { state, fn_name, url, fn_type, lowhalf => "g_signal_connect" };

	    lowhalf    = "w0";		# Give arg counts and types to the following two functions.
	    result_type = "Int";		# Give result information   to the following two functions.

	    write_gtk_driver_api_function          (fn_name2, lowhalf, result_type);
	    write_gtk_via_pipe_driver_pkg_function (fn_name2, lowhalf, result_type);
	    write_gtk_driver_pkg_function          (fn_name, fn_name2, fn_type, lowhalf, result_type);
	    write_gtk_api_function_declaration     (fn_name, fn_type);
	    write_gtk_g_pkg_callback_fun(    state, fn_name, callback_type);
	};

    #
    fun make_plain_function (state: State)
	=
	{	
	    url   = case (maybe_get_field(state,"url"))
			#	
			THE field => field;
			NULL      => "";
		    esac;

	    fn_name =  get_field(state, "fn-name");	# E.g., "make_window".
	    fn_type =  get_field(state, "fn-type");	# E.g., "Session -> Widget".
	    lowhalf =  get_field(state, "lowhalf");	# E.g., "gtk_window_new( GTK_WINDOW_TOPLEVEL )".

	    fn_name2 =  regex::replace_all  ./'/  "2"  fn_name;

	    # result_type can be "Int", "String", "Bool", "Float" or "Void".
	    #
	    # It can also be "Widget" or "new Widget", the difference being
	    # that in the former case the mythryl-gtk-server-in-c-subprocess.c logic can merely
	    # fetch it out of its array  widget[],  whereas in the latter a
	    # new entry is being created in  widget[].
	    #
	    # We can usually deduce the difference:  If fn_name starts with
	    # "make_" then we have the "new Widget" case, otherwise we have
	    # the "Widget" case:
	    #
	    result_type
		=
		case (maybe_get_field (state, "result"))
		    #
		    THE string => string;
		    #
		    NULL =>
			# Pick off terminal  " -> Void"
			# or whatever from fn_type
			# and switch on it:
			#
			case (regex::find_first_group 1 ./->\s*([A-Za-z_']+)\s*$/ fn_type)
			     "Bool"   => "Bool";
			     "Float"  => "Float";
			     "Int"    => "Int";
			     "String" => "String";
			     "Void"   => "Void";

			     "Widget"
				=>
				if (fn_name =~ ./^make_/)   "new Widget";
				else                            "Widget";
				fi;

			     other =>  die_x(sprintf "Unsupported result fn-type %s in type %s at %s..\n"
						    other
						    fn_type
						   (get_field_location (state, "fn-type"))
					  );
			esac
			except
			    NOT_FOUND
				=
				die_x(sprintf "Unsupported result fn-type %s at %s..\n"
					     fn_type
					     (get_field_location (state, "fn-type"))
				    );
		esac;

	    write_mythryl_gtk_server_c_plain_fun (state, fn_name2, fn_type, lowhalf, result_type);
	    write_gtk_driver_c_plain_fun         (state, fn_name2, fn_type, lowhalf, result_type);
	    write_cfun_list_h_entry                     (fn_name2, fn_type);

	    write_trie_entry_for_gtk_server_c( fn_name2 );

	    note_libref_tex_entry { state, fn_name, lowhalf, url, fn_type };

	    write_gtk_driver_api_function           (fn_name2, lowhalf, result_type);
	    write_gtk_via_pipe_driver_pkg_function  (fn_name2, lowhalf, result_type);

	    write_gtk_driver_pkg_function           (fn_name, fn_name2, fn_type, lowhalf, result_type);
	    write_gtk_api_function_declaration      (fn_name, fn_type);

	    write_gtk_g_pkg_plain_fun( state, fn_name, lowhalf);
	};


    #
    fun make_function_doc (state: State)
	=
	{	
	    url    = case (maybe_get_field(state,"url"))
			 #	
			 THE field => field;
			 NULL      => "";
		     esac;

	    fn_name  =  get_field(state, "fn-name");	# "make_window" or such.
	    fn_type  =  get_field(state, "fn-type");	# "Session -> Widget" or such.

	    note_libref_tex_entry { state, fn_name, lowhalf => "", url, fn_type };
	};


    #
    fun make_mythryl_type (state: State)
	=
	{	
	    type     =  get_field(state, "type");

	    to_gtk_api_types    type;
	    to_gtk_g_pkg_types  type;
	};

    fun make_mythryl_code (state: State)
	=
	{	
	    code     =  get_field(state, "code");

	    to_gtk_g_pkg_funs  code;
	};


    #
    fun handle_fieldset (state: State)
	=
	{
	    if (not  (string_map::is_empty  *state.fields))
		#
		case (trim (get_field (state, "make")))
		    #
		    "callback-fn"  =>  make_callback_function  state;
		    "plain-fn"     =>  make_plain_function     state;
		    "fn-doc"       =>  make_function_doc       state;
		    "mythryl-type" =>  make_mythryl_type       state;
		    "mythryl-code" =>  make_mythryl_code       state;

		    other => die_x (sprintf "Unsupported 'make' field value '%s' at %s\n" other (get_field_location (state, "make")));
		esac;

		clear_state  state;
	    fi;
	};    

    # Scan src/srv/gtk/etc/gtk-glue.config
    # digesting the blank-line-delimited
    # config info paragraphs, then
    # synthesize code accordingly:
    # 
    fun process_config_file ()
	=
	{   fun loop  (state: State)
		=
		case (fil::read_line  state.fd)
		    #
		    NULL => handle_fieldset  state;			# Done.
		    #
		    THE input_line
			=>
			{   state.line_number :=  *state.line_number + 1;
			    #
			    if (input_line =~ ./^\s*#/)
				#
				# Ignore comment lines:
				#
				loop  state;

			    elif (input_line =~ ./^\s*$/)

				# Empty line marks the end of a field cluster,
				# so process any fields we have in hand:
				#
				handle_fieldset  state;

			    else

				# Line format should be  "line-type: rest".
				# Split it into two strings at the ':' and
				# dispatch on the line type:
				#
				case (regex::find_first_groups_all ./^([^:]+):(.*\n)$/ input_line)
				    #
				    [ line_type, line_contents ]
					=>
					{   # Drop leading and trailing whitespace:
					    #
					    line_type
						=
						trim  line_type;

					    line_contents
						=
						case line_type
						    "type"      =>       line_contents;	# Contains raw indented code, so leave whitespace in place and restore dropped newline.
						    "code"      =>       line_contents;	# Contains raw indented code, so leave whitespace in place and restore dropped newline.
						    _           => trim  line_contents;	# Drop leading and trailing whitespace.
						esac;

					    update_field (state,  line_type,  line_contents);
					};

				    _
					=>
					die_x ("make-gtk-glue: UNRecognized gtk-glue.config line: '" + (chomp input_line) + "'\n");
				esac
				except
				    NOT_FOUND
					=
					die_x (sprintf "make-gtk-glue: Unrecognized gtk-glue.config line %d: '%s'\n" *state.line_number (chomp input_line));

			    fi;

			    loop  state;				# Scan rest of file.
			};
		esac;

	    config_file_in =  fil::open_for_read  config_file_path;

	    loop { line_number =>  REF 0,
		   fd          =>  config_file_in,
		   fields      =>  REF (string_map::empty: string_map::Map( Field ))
		 };

	    fil::close_input  config_file_in;
	};


    gtk_driver_api          =  read_patchable_file   gtk_driver_api_path;
    gtk_via_pipe_driver_pkg =  read_patchable_file   gtk_via_pipe_driver_pkg_path;
    gtk_driver_pkg          =  read_patchable_file   gtk_driver_pkg_path;
    gtk_g_pkg               =  read_patchable_file   gtk_g_pkg_path;
    gtk_api                 =  read_patchable_file   gtk_api_path;
    mythryl_gtk_server_c    =  read_patchable_file   mythryl_gtk_server_c_path;
    cfun_list_h             =  read_patchable_file   cfun_list_h_path;
    gtk_driver_c            =  read_patchable_file   gtk_driver_c_path;



    process_config_file    ();



    printf "%4d   plain     functions autogenerated for mythryl-gtk-server-in-main-process.c\n"         *gtk_driver_plain_fns_autogenerated;
    printf "%4d   callback  functions autogenerated for mythryl-gtk-server-in-main-process.c\n"         *gtk_driver_callback_fns_autogenerated;

    printf "%4d   plain     functions autogenerated for mythryl-gtk-server-in-c-subprocess.c\n" *gtk_server_plain_fns_autogenerated;
    printf "%4d   callback  functions autogenerated for mythryl-gtk-server-in-c-subprocess.c\n" *gtk_server_callback_fns_autogenerated;

    printf "%4d   plain     functions autogenerated for gtk-client-g.pkg\n"            *gtk_g_pkg_plain_fns_autogenerated;
    printf "%4d   plain     functions handgenerated for gtk-client-g.pkg\n"            *gtk_g_pkg_plain_fns_handgenerated;

    printf "%4d   callback  functions autogenerated for gtk-client-g.pkg\n"            *gtk_g_pkg_callback_fns_autogenerated;
    printf "%4d   callback  functions handgenerated for gtk-client-g.pkg\n"            *gtk_g_pkg_callback_fns_handgenerated;



    write_patchable_file  gtk_driver_api           [ INTRON (reverse *gtk_driver_api_intron)          ];
    write_patchable_file  gtk_via_pipe_driver_pkg  [ INTRON (reverse *gtk_via_pipe_driver_pkg_intron) ];
    write_patchable_file  gtk_driver_pkg           [ INTRON (reverse *gtk_driver_pkg_intron)          ];
    write_patchable_file  gtk_api                  [ INTRON (reverse *gtk_api_types_intron),
						     INTRON (reverse *gtk_api_funs_intron)
						   ];
    write_patchable_file  gtk_g_pkg                [ INTRON (reverse *gtk_g_pkg_types_intron),
						     INTRON (reverse *gtk_g_pkg_funs_intron)
						   ];
    write_patchable_file  mythryl_gtk_server_c     [ INTRON (reverse *mythryl_gtk_server_c_funs_intron),
						     INTRON (reverse *mythryl_gtk_server_c_trie_intron)
						   ];
    write_patchable_file  cfun_list_h              [ INTRON (reverse *cfun_list_h_intron)             ];
    write_patchable_file  gtk_driver_c             [ INTRON (reverse *gtk_driver_c_intron)            ];



    if (-F libref_tex_path)
	#
	libref_tex =  read_patchable_file   libref_tex_path;

	write_libref_tex_table  (.fn_name, .lowhalf, to_libref_table1_tex);
	write_libref_tex_table  (.lowhalf, .fn_name, to_libref_table2_tex);

	write_patchable_file  libref_tex           [ INTRON (reverse *libref_tex_table1_intron),
						     INTRON (reverse *libref_tex_table2_intron)
						   ];
    fi;


    exit_x(0);
};
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
