generic package ml_lex_lr_vals_fun(package token:  Token;)
 : (weak) api { package parser_data : Parser_Data;
       package tokens : Ml_Lex_Tokens;
   }
 { 
package parser_data{
package header { 
# mythryl-lex.grammar

package s = lex_spec;

package re = regular_expression;
package sis = re::symbol_set;

my sym_table: Ref quickstring_map::Map re::Re
            = REF quickstring_map::empty ;

wildcard = sis::complement (sis::singleton 0u10);      # Everything but \n.

fun char_to_sym c = one_word_unt::from_int (char::to_int c);
fun str_to_sym s = char_to_sym (string::get_byte_as_char (s, 0));


};
package lr_table = token::lr_table;
package token = token;
stipulate include package   lr_table; herein 
my table={   action_rows =
"\
\\x01\x00\x01\x00\x00\x00\x00\x00\
\\x01\x00\x04\x00\x49\x00\x1e\x00\x48\x00\x00\x00\
\\x01\x00\x05\x00\x21\x00\x07\x00\x20\x00\x14\x00\x1f\x00\x15\x00\x1e\x00\
\\x16\x00\x1d\x00\x19\x00\x1c\x00\x00\x00\
\\x01\x00\x06\x00\x47\x00\x0f\x00\x2c\x00\x00\x00\
\\x01\x00\x08\x00\x44\x00\x09\x00\x43\x00\x10\x00\x42\x00\x14\x00\x33\x00\
\\x15\x00\x32\x00\x00\x00\
\\x01\x00\x08\x00\x4e\x00\x10\x00\x42\x00\x14\x00\x33\x00\x15\x00\x32\x00\x00\x00\
\\x01\x00\x0b\x00\x2e\x00\x00\x00\
\\x01\x00\x0b\x00\x3b\x00\x1e\x00\x3a\x00\x00\x00\
\\x01\x00\x0b\x00\x51\x00\x00\x00\
\\x01\x00\x0f\x00\x2c\x00\x1a\x00\x2b\x00\x00\x00\
\\x01\x00\x0f\x00\x2c\x00\x1a\x00\x53\x00\x00\x00\
\\x01\x00\x0f\x00\x2c\x00\x1c\x00\x4a\x00\x00\x00\
\\x01\x00\x10\x00\x35\x00\x13\x00\x34\x00\x14\x00\x33\x00\x15\x00\x32\x00\x00\x00\
\\x01\x00\x10\x00\x42\x00\x14\x00\x33\x00\x15\x00\x32\x00\x00\x00\
\\x01\x00\x13\x00\x34\x00\x14\x00\x33\x00\x15\x00\x32\x00\x00\x00\
\\x01\x00\x14\x00\x33\x00\x15\x00\x32\x00\x00\x00\
\\x01\x00\x17\x00\x23\x00\x00\x00\
\\x01\x00\x18\x00\x4b\x00\x00\x00\
\\x01\x00\x19\x00\x10\x00\x1d\x00\x0f\x00\x1f\x00\x0e\x00\x21\x00\x0d\x00\
\\x22\x00\x0c\x00\x23\x00\x0b\x00\x24\x00\x0a\x00\x25\x00\x09\x00\
\\x26\x00\x08\x00\x27\x00\x07\x00\x00\x00\
\\x01\x00\x19\x00\x13\x00\x00\x00\
\\x01\x00\x1b\x00\x11\x00\x00\x00\
\\x01\x00\x1b\x00\x12\x00\x00\x00\
\\x01\x00\x1b\x00\x3c\x00\x00\x00\
\\x01\x00\x1b\x00\x54\x00\x00\x00\
\\x01\x00\x1c\x00\x24\x00\x00\x00\
\\x01\x00\x1d\x00\x05\x00\x00\x00\
\\x01\x00\x20\x00\x15\x00\x00\x00\
\\x01\x00\x20\x00\x38\x00\x00\x00\
\\x01\x00\x20\x00\x4f\x00\x00\x00\
\\x56\x00\x00\x00\
\\x57\x00\x00\x00\
\\x58\x00\x02\x00\x04\x00\x00\x00\
\\x59\x00\x00\x00\
\\x5a\x00\x00\x00\
\\x5b\x00\x00\x00\
\\x5c\x00\x00\x00\
\\x5d\x00\x00\x00\
\\x5e\x00\x00\x00\
\\x5f\x00\x00\x00\
\\x60\x00\x00\x00\
\\x61\x00\x00\x00\
\\x62\x00\x00\x00\
\\x63\x00\x20\x00\x15\x00\x00\x00\
\\x64\x00\x00\x00\
\\x65\x00\x03\x00\x22\x00\x05\x00\x21\x00\x07\x00\x20\x00\x14\x00\x1f\x00\
\\x15\x00\x1e\x00\x16\x00\x1d\x00\x19\x00\x1c\x00\x00\x00\
\\x66\x00\x00\x00\
\\x67\x00\x00\x00\
\\x68\x00\x00\x00\
\\x69\x00\x00\x00\
\\x6a\x00\x00\x00\
\\x6b\x00\x05\x00\x21\x00\x07\x00\x20\x00\x14\x00\x1f\x00\x15\x00\x1e\x00\
\\x16\x00\x1d\x00\x19\x00\x1c\x00\x00\x00\
\\x6c\x00\x05\x00\x21\x00\x07\x00\x20\x00\x14\x00\x1f\x00\x15\x00\x1e\x00\
\\x16\x00\x1d\x00\x19\x00\x1c\x00\x00\x00\
\\x6d\x00\x0c\x00\x29\x00\x0d\x00\x28\x00\x0e\x00\x27\x00\x18\x00\x26\x00\x00\x00\
\\x6e\x00\x0c\x00\x29\x00\x0d\x00\x28\x00\x0e\x00\x27\x00\x18\x00\x26\x00\x00\x00\
\\x6f\x00\x00\x00\
\\x70\x00\x00\x00\
\\x71\x00\x00\x00\
\\x72\x00\x00\x00\
\\x73\x00\x00\x00\
\\x74\x00\x00\x00\
\\x75\x00\x00\x00\
\\x76\x00\x00\x00\
\\x77\x00\x00\x00\
\\x78\x00\x00\x00\
\\x79\x00\x00\x00\
\\x7a\x00\x00\x00\
\\x7b\x00\x00\x00\
\\x7c\x00\x00\x00\
\\x7d\x00\x00\x00\
\\x7e\x00\x00\x00\
\\x7f\x00\x13\x00\x3e\x00\x00\x00\
\\x80\x00\x00\x00\
\\x81\x00\x00\x00\
\\x82\x00\x00\x00\
\\x83\x00\x13\x00\x4d\x00\x00\x00\
\\x84\x00\x00\x00\
\\x85\x00\x00\x00\
\\x86\x00\x00\x00\
\\x87\x00\x00\x00\
\";
    action_row_numbers =
"\x1f\x00\x19\x00\x1e\x00\x20\x00\
\\x12\x00\x14\x00\x15\x00\x13\x00\
\\x25\x00\x26\x00\x28\x00\x27\x00\
\\x1a\x00\x2c\x00\x10\x00\x24\x00\
\\x22\x00\x23\x00\x18\x00\x2a\x00\
\\x3b\x00\x35\x00\x33\x00\x09\x00\
\\x2c\x00\x1d\x00\x06\x00\x3e\x00\
\\x3d\x00\x3c\x00\x0c\x00\x02\x00\
\\x1b\x00\x02\x00\x21\x00\x2b\x00\
\\x07\x00\x38\x00\x37\x00\x36\x00\
\\x34\x00\x16\x00\x02\x00\x2d\x00\
\\x3f\x00\x46\x00\x04\x00\x42\x00\
\\x4e\x00\x4d\x00\x0f\x00\x0e\x00\
\\x03\x00\x01\x00\x30\x00\x0b\x00\
\\x11\x00\x39\x00\x2e\x00\x32\x00\
\\x0d\x00\x4c\x00\x4a\x00\x48\x00\
\\x4b\x00\x45\x00\x43\x00\x05\x00\
\\x41\x00\x40\x00\x1c\x00\x02\x00\
\\x29\x00\x08\x00\x47\x00\x0d\x00\
\\x44\x00\x31\x00\x0a\x00\x3a\x00\
\\x49\x00\x17\x00\x2f\x00\x00\x00";
   goto_table =
"\
\\x01\x00\x53\x00\x02\x00\x01\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x03\x00\x04\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x04\x00\x12\x00\x00\x00\
\\x05\x00\x19\x00\x06\x00\x18\x00\x08\x00\x17\x00\x09\x00\x16\x00\
\\x0a\x00\x15\x00\x0b\x00\x14\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x04\x00\x23\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x0a\x00\x28\x00\x0b\x00\x14\x00\x00\x00\
\\x00\x00\
\\x05\x00\x2b\x00\x06\x00\x18\x00\x08\x00\x17\x00\x09\x00\x16\x00\
\\x0a\x00\x15\x00\x0b\x00\x14\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x0c\x00\x2f\x00\x0d\x00\x2e\x00\x10\x00\x2d\x00\x00\x00\
\\x08\x00\x34\x00\x09\x00\x16\x00\x0a\x00\x15\x00\x0b\x00\x14\x00\x00\x00\
\\x07\x00\x35\x00\x00\x00\
\\x08\x00\x37\x00\x09\x00\x16\x00\x0a\x00\x15\x00\x0b\x00\x14\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x09\x00\x3b\x00\x0a\x00\x15\x00\x0b\x00\x14\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x0e\x00\x3f\x00\x0f\x00\x3e\x00\x10\x00\x3d\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x0d\x00\x43\x00\x10\x00\x2d\x00\x00\x00\
\\x0c\x00\x44\x00\x0d\x00\x2e\x00\x10\x00\x2d\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x0a\x00\x28\x00\x0b\x00\x14\x00\x00\x00\
\\x0f\x00\x4a\x00\x10\x00\x3d\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x0e\x00\x3f\x00\x0f\x00\x3e\x00\x10\x00\x3d\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x08\x00\x4e\x00\x09\x00\x16\x00\x0a\x00\x15\x00\x0b\x00\x14\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x0f\x00\x50\x00\x10\x00\x3d\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\";
   numstates = 84;
   numrules = 50;
 s = REF "";  index = REF 0;
    string_to_int = \\ () = 
    {    i = *index;
         index := i+2;
         string::get_byte(*s, i) + string::get_byte(*s, i+1) * 256;
    };

    string_to_list = \\ s' =
    {   len = string::length_in_bytes s';
        fun f () =
           if (*index < len)
           string_to_int() ! f();
           else NIL; fi;
        index := 0;
        s := s';
        f ();
   };

   string_to_pairlist =   \\ (conv_key, conv_entry) =   f
   where 
         fun f ()
             =
             case (string_to_int ())
                 0 => EMPTY;
                 n => PAIR (conv_key (n - 1), conv_entry (string_to_int()), f());
             esac;
   end;

   string_to_pairlist_default =   \\ (conv_key, conv_entry) =
    {   conv_row = string_to_pairlist (conv_key, conv_entry);
       \\ () =
       {   default = conv_entry (string_to_int());
           row = conv_row();
          (row, default);
       };
   };

    string_to_table = \\ (convert_row, s') =
    {   len = string::length_in_bytes s';
        fun f ()
            =
           if (*index < len)
              convert_row() ! f();
           else NIL; fi;
        s := s';
        index := 0;
        f ();
     };

stipulate
  memo = rw_vector::make_rw_vector (numstates+numrules, ERROR);
  my _ ={   fun g i
                =
                {   rw_vector::set (memo, i, REDUCE (i-numstates));
                    g (i+1);
                };

            fun f i
                =
                if   (i == numstates)
                     g i;
                else    rw_vector::set (memo, i, SHIFT (STATE i));
                         f (i+1);
                fi;

            f 0
            except
                INDEX_OUT_OF_BOUNDS =  ();
        };
herein
    entry_to_action
        =
        \\ 0 =>  ACCEPT;
           1 =>  ERROR;
           j =>  rw_vector::get (memo, (j - 2));
        end;
end;

   goto_table = rw_vector::from_list (string_to_table (string_to_pairlist (NONTERM, STATE), goto_table));
   action_rows = string_to_table (string_to_pairlist_default (TERM, entry_to_action), action_rows);
   action_row_numbers = string_to_list action_row_numbers;
   action_table
    =
    {   action_row_lookup
            =
            {   a=rw_vector::from_list (action_rows);

                \\ i =   rw_vector::get (a, i);
            };

        rw_vector::from_list (map action_row_lookup action_row_numbers);
    };

    lr_table::make_lr_table {
        actions => action_table,
        gotos   => goto_table,
        rule_count   => numrules,
        state_count  => numstates,
        initial_state => STATE 0   };
};
end;
stipulate include package   header; herein
Source_Position = Int;
Arg = Void;
package values { 
Semantic_Value = TM_VOID | NT_VOID  Void -> Void | LEXSTATE Void ->  (String) | ACT Void ->  (String) | ID Void ->  (String) | REPS Void ->  (Int) | UNICHAR Void ->  (one_word_unt::Unt)
 | CHAR Void ->  (String) | DECLS Void ->  (String) | QQ_NON_CARAT Void ->  (one_word_unt::Unt) | QQ_A_CHAR Void ->  (one_word_unt::Unt) | QQ_CHAR_RANGE Void ->  (sis::Set)
 | QQ_CHAR_ILK' Void ->  (sis::Set) | QQ_CHAR_ILK Void ->  (sis::Set) | QQ_IN_EXPRESSION Void ->  (re::Re) | QQ_EXPRESSION Void ->  (re::Re) | QQ_CAT_EXPRESSION Void ->  (re::Re)
 | QQ_OR_EXPRESSION Void ->  (re::Re) | QQ_RULE_STATES Void ->  (quickstring_set::Set) | QQ_RULE Void ->  (s::Rule) | QQ_RULES Void ->  (List s::Rule )
 | QQ_START_STATES Void ->  (quickstring_set::Set) | QQ_DEFS Void ->  (s::Config) | QQ_DECLSS Void ->  (String) | QQ_START Void ->  (s::Spec);
};
Semantic_Value = values::Semantic_Value;
Result = s::Spec;
end;
package error_recovery{
include package lr_table;
infix my 60 @@;
fun x @@ y = y ! x;
is_keyword =
\\ _ => FALSE; end;
my preferred_change:   List( (List( Terminal ), List( Terminal )) ) = 
NIL;
no_shift = 
\\ (TERM 0) => TRUE; _ => FALSE; end;
show_terminal =
\\ (TERM 0) => "EOFX"
; (TERM 1) => "DECLS"
; (TERM 2) => "LT"
; (TERM 3) => "GT"
; (TERM 4) => "LP"
; (TERM 5) => "RP"
; (TERM 6) => "LB"
; (TERM 7) => "RB"
; (TERM 8) => "RBD"
; (TERM 9) => "LCB"
; (TERM 10) => "RCB"
; (TERM 11) => "QMARK"
; (TERM 12) => "STAR"
; (TERM 13) => "PLUS"
; (TERM 14) => "BAR"
; (TERM 15) => "CARAT"
; (TERM 16) => "DOLLAR"
; (TERM 17) => "SLASH"
; (TERM 18) => "DASH"
; (TERM 19) => "CHAR"
; (TERM 20) => "UNICHAR"
; (TERM 21) => "DOT"
; (TERM 22) => "EQ"
; (TERM 23) => "REPS"
; (TERM 24) => "ID"
; (TERM 25) => "ARROW"
; (TERM 26) => "ACT"
; (TERM 27) => "SEMI"
; (TERM 28) => "LEXMARK"
; (TERM 29) => "COMMA"
; (TERM 30) => "STATES"
; (TERM 31) => "LEXSTATE"
; (TERM 32) => "COUNT"
; (TERM 33) => "REJECTTOK"
; (TERM 34) => "FULL"
; (TERM 35) => "UNICODE"
; (TERM 36) => "STRUCTX"
; (TERM 37) => "HEADER"
; (TERM 38) => "ARG"
; (TERM 39) => "POSARG"
; _ => "bogus-term"; end;
stipulate include package   header; herein
errtermvalue=
\\ _ => values::TM_VOID;
 end; end;
my terms:  List( Terminal ) = NIL
 @@ (TERM 39) @@ (TERM 38) @@ (TERM 37) @@ (TERM 36) @@ (TERM 35) @@ (TERM 34) @@ (TERM 33) @@ (TERM 32) @@ (TERM 30) @@ (TERM 29) @@ (TERM 28) @@ (TERM 27) @@ (TERM 25) @@ (TERM 22) @@ (TERM 21) @@ 
(TERM 18) @@ (TERM 17) @@ (TERM 16) @@ (TERM 15) @@ (TERM 14) @@ (TERM 13) @@ (TERM 12) @@ (TERM 11) @@ (TERM 10) @@ (TERM 9) @@ (TERM 8) @@ (TERM 7) @@ (TERM 6) @@ (TERM 5) @@ (TERM 4) @@ (TERM 3)
 @@ (TERM 2) @@ (TERM 0);
};
package actions {
exception MLY_ACTION Int;
stipulate include package   header; herein
actions = 
\\ (i392, default_position, stack, 
    (()): Arg) = 
case (i392, stack)
  ( 0,  ( ( _,  ( values::QQ_RULES rules1,  _,  rules1right)) !  _ !  ( _,  ( values::QQ_DEFS defs1,  _,  _)) !  _ !  ( _,  ( values::QQ_DECLSS declss1,  declss1left,  _)) !  rest671)) => {  my  
result = values::QQ_START (\\  _ =  {  my  (declss as declss1) = declss1 ();
 my  (defs as defs1) = defs1 ();
 my  (rules as rules1) = rules1 ();
 (
s::SPEC { decls => declss, 
		          conf  => defs, 
			  rules => rules});
 } );
 ( lr_table::NONTERM 0,  ( result,  declss1left,  rules1right),  rest671);
 } 
;  ( 1,  ( ( _,  ( values::DECLS decls1,  decls1left,  decls1right)) !  rest671)) => {  my  result = values::QQ_DECLSS (\\  _ =  {  my  (decls as decls1) = decls1 ();
 (decls);
 } );
 ( 
lr_table::NONTERM 1,  ( result,  decls1left,  decls1right),  rest671);
 } 
;  ( 2,  ( rest671)) => {  my  result = values::QQ_DECLSS (\\  _ =  (""));
 ( lr_table::NONTERM 1,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 3,  ( rest671)) => {  my  result = values::QQ_DEFS (\\  _ =  (s::make_config()));
 ( lr_table::NONTERM 2,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 4,  ( ( _,  ( _,  _,  semi1right)) !  ( _,  ( values::QQ_START_STATES start_states1,  _,  _)) !  _ !  ( _,  ( values::QQ_DEFS defs1,  defs1left,  _)) !  rest671)) => {  my  result = 
values::QQ_DEFS (\\  _ =  {  my  (defs as defs1) = defs1 ();
 my  (start_states as start_states1) = start_states1 ();
 (s::upd_start_states (defs, start_states));
 } );
 ( lr_table::NONTERM 2,  ( 
result,  defs1left,  semi1right),  rest671);
 } 
;  ( 5,  ( ( _,  ( values::ACT act1,  _,  act1right)) !  _ !  ( _,  ( values::QQ_DEFS defs1,  defs1left,  _)) !  rest671)) => {  my  result = values::QQ_DEFS (\\  _ =  {  my  (defs as defs1) = defs1
 ();
 my  (act as act1) = act1 ();
 (s::upd_header (defs, 
		   string::substring (act, 1, string::length_in_bytes act - 2)));
 } );
 ( lr_table::NONTERM 2,  ( result,  defs1left,  act1right),  
rest671);
 } 
;  ( 6,  ( ( _,  ( values::ID id1,  _,  id1right)) !  _ !  ( _,  ( values::QQ_DEFS defs1,  defs1left,  _)) !  rest671)) => {  my  result = values::QQ_DEFS (\\  _ =  {  my  (defs as defs1) = defs1 ();

 my  (id as id1) = id1 ();
 (s::upd_struct_name (defs, id));
 } );
 ( lr_table::NONTERM 2,  ( result,  defs1left,  id1right),  rest671);
 } 
;  ( 7,  ( ( _,  ( values::ACT act1,  _,  act1right)) !  _ !  ( _,  ( values::QQ_DEFS defs1,  defs1left,  _)) !  rest671)) => {  my  result = values::QQ_DEFS (\\  _ =  {  my  (defs as defs1) = defs1
 ();
 my  (act as act1) = act1 ();
 (s::upd_arg (defs, act));
 } );
 ( lr_table::NONTERM 2,  ( result,  defs1left,  act1right),  rest671);
 } 
;  ( 8,  ( ( _,  ( _,  _,  unicode1right)) !  ( _,  ( values::QQ_DEFS defs1,  defs1left,  _)) !  rest671)) => {  my  result = values::QQ_DEFS (\\  _ =  {  my  (defs as defs1) = defs1 ();
 (
s::upd_clamp (defs, s::NO_CLAMP));
 } );
 ( lr_table::NONTERM 2,  ( result,  defs1left,  unicode1right),  rest671);
 } 
;  ( 9,  ( ( _,  ( _,  _,  full1right)) !  ( _,  ( values::QQ_DEFS defs1,  defs1left,  _)) !  rest671)) => {  my  result = values::QQ_DEFS (\\  _ =  {  my  (defs as defs1) = defs1 ();
 (
s::upd_clamp (defs, s::CLAMP255));
 } );
 ( lr_table::NONTERM 2,  ( result,  defs1left,  full1right),  rest671);
 } 
;  ( 10,  ( ( _,  ( _,  _,  count1right)) !  ( _,  ( values::QQ_DEFS defs1,  defs1left,  _)) !  rest671)) => {  my  result = values::QQ_DEFS (\\  _ =  {  my  (defs as defs1) = defs1 ();
 (defs);
 } )
;
 ( lr_table::NONTERM 2,  ( result,  defs1left,  count1right),  rest671);
 } 
;  ( 11,  ( ( _,  ( _,  _,  rejecttok1right)) !  ( _,  ( values::QQ_DEFS defs1,  defs1left,  _)) !  rest671)) => {  my  result = values::QQ_DEFS (\\  _ =  {  my  (defs as defs1) = defs1 ();
 (defs)
;
 } );
 ( lr_table::NONTERM 2,  ( result,  defs1left,  rejecttok1right),  rest671);
 } 
;  ( 12,  ( ( _,  ( _,  _,  semi1right)) !  ( _,  ( values::QQ_OR_EXPRESSION or_expression1,  _,  _)) !  _ !  ( _,  ( values::ID id1,  _,  _)) !  ( _,  ( values::QQ_DEFS defs1,  defs1left,  _)) !  
rest671)) => {  my  result = values::QQ_DEFS (\\  _ =  {  my  (defs as defs1) = defs1 ();
 my  (id as id1) = id1 ();
 my  (or_expression as or_expression1) = or_expression1 ();
 (
 {  sym_table :=   quickstring_map::set (*sym_table, quickstring__premicrothread::from_string id, or_expression);
		     defs;
                  }
                );
 } );
 ( lr_table::NONTERM 2,  ( 
result,  defs1left,  semi1right),  rest671);
 } 
;  ( 13,  ( ( _,  ( values::LEXSTATE lexstate1,  lexstate1left,  lexstate1right)) !  rest671)) => {  my  result = values::QQ_START_STATES (\\  _ =  {  my  (lexstate as lexstate1) = lexstate1 ();
 (
quickstring_set::singleton (quickstring__premicrothread::from_string lexstate));
 } );
 ( lr_table::NONTERM 3,  ( result,  lexstate1left,  lexstate1right),  rest671);
 } 
;  ( 14,  ( ( _,  ( values::QQ_START_STATES start_states1,  _,  start_states1right)) !  ( _,  ( values::LEXSTATE lexstate1,  lexstate1left,  _)) !  rest671)) => {  my  result = values::QQ_START_STATES
 (\\  _ =  {  my  (lexstate as lexstate1) = lexstate1 ();
 my  (start_states as start_states1) = start_states1 ();
 (
quickstring_set::add (start_states, quickstring__premicrothread::from_string lexstate));
 } );
 ( lr_table::NONTERM 3,  ( result,  lexstate1left,  start_states1right),  rest671);
 } 
;  ( 15,  ( rest671)) => {  my  result = values::QQ_RULES (\\  _ =  ([]));
 ( lr_table::NONTERM 4,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 16,  ( ( _,  ( values::QQ_RULES rules1,  _,  rules1right)) !  ( _,  ( values::QQ_RULE rule1,  rule1left,  _)) !  rest671)) => {  my  result = values::QQ_RULES (\\  _ =  {  my  (rule as rule1) = 
rule1 ();
 my  (rules as rules1) = rules1 ();
 (rule ! rules);
 } );
 ( lr_table::NONTERM 4,  ( result,  rule1left,  rules1right),  rest671);
 } 
;  ( 17,  ( ( _,  ( values::ACT act1,  _,  act1right)) !  _ !  ( _,  ( values::QQ_OR_EXPRESSION or_expression1,  or_expression1left,  _)) !  rest671)) => {  my  result = values::QQ_RULE (\\  _ =  { 
 my  (or_expression as or_expression1) = or_expression1 ();
 my  (act as act1) = act1 ();
 ((NULL, or_expression), act);
 } );
 ( lr_table::NONTERM 5,  ( result,  or_expression1left,  act1right),  
rest671);
 } 
;  ( 18,  ( ( _,  ( values::ACT act1,  _,  act1right)) !  _ !  ( _,  ( values::QQ_OR_EXPRESSION or_expression1,  _,  _)) !  _ !  ( _,  ( values::QQ_RULE_STATES rule_states1,  _,  _)) !  ( _,  ( _,  
lt1left,  _)) !  rest671)) => {  my  result = values::QQ_RULE (\\  _ =  {  my  (rule_states as rule_states1) = rule_states1 ();
 my  (or_expression as or_expression1) = or_expression1 ();
 my  (act
 as act1) = act1 ();
 ((THE rule_states, or_expression), act);
 } );
 ( lr_table::NONTERM 5,  ( result,  lt1left,  act1right),  rest671);
 } 
;  ( 19,  ( ( _,  ( values::LEXSTATE lexstate1,  lexstate1left,  lexstate1right)) !  rest671)) => {  my  result = values::QQ_RULE_STATES (\\  _ =  {  my  (lexstate as lexstate1) = lexstate1 ();
 (
quickstring_set::singleton (quickstring__premicrothread::from_string lexstate));
 } );
 ( lr_table::NONTERM 6,  ( result,  lexstate1left,  lexstate1right),  rest671);
 } 
;  ( 20,  ( ( _,  ( values::LEXSTATE lexstate1,  _,  lexstate1right)) !  _ !  ( _,  ( values::QQ_RULE_STATES rule_states1,  rule_states1left,  _)) !  rest671)) => {  my  result = 
values::QQ_RULE_STATES (\\  _ =  {  my  (rule_states as rule_states1) = rule_states1 ();
 my  (lexstate as lexstate1) = lexstate1 ();
 (
quickstring_set::add (rule_states, quickstring__premicrothread::from_string lexstate));
 } );
 ( lr_table::NONTERM 6,  ( result,  rule_states1left,  lexstate1right),  rest671);
 } 
;  ( 21,  ( ( _,  ( values::QQ_CAT_EXPRESSION cat_expression1,  _,  cat_expression1right)) !  _ !  ( _,  ( values::QQ_OR_EXPRESSION or_expression1,  or_expression1left,  _)) !  rest671)) => {  my  
result = values::QQ_OR_EXPRESSION (\\  _ =  {  my  (or_expression as or_expression1) = or_expression1 ();
 my  (cat_expression as cat_expression1) = cat_expression1 ();
 (
re::make_or (or_expression, cat_expression));
 } );
 ( lr_table::NONTERM 7,  ( result,  or_expression1left,  cat_expression1right),  rest671);
 } 
;  ( 22,  ( ( _,  ( values::QQ_CAT_EXPRESSION cat_expression1,  cat_expression1left,  cat_expression1right)) !  rest671)) => {  my  result = values::QQ_OR_EXPRESSION (\\  _ =  {  my  (cat_expression
 as cat_expression1) = cat_expression1 ();
 (cat_expression);
 } );
 ( lr_table::NONTERM 7,  ( result,  cat_expression1left,  cat_expression1right),  rest671);
 } 
;  ( 23,  ( ( _,  ( values::QQ_EXPRESSION expression1,  _,  expression1right)) !  ( _,  ( values::QQ_CAT_EXPRESSION cat_expression1,  cat_expression1left,  _)) !  rest671)) => {  my  result = 
values::QQ_CAT_EXPRESSION (\\  _ =  {  my  (cat_expression as cat_expression1) = cat_expression1 ();
 my  (expression as expression1) = expression1 ();
 (re::make_meld (cat_expression, expression))
;
 } );
 ( lr_table::NONTERM 8,  ( result,  cat_expression1left,  expression1right),  rest671);
 } 
;  ( 24,  ( ( _,  ( values::QQ_EXPRESSION expression1,  expression1left,  expression1right)) !  rest671)) => {  my  result = values::QQ_CAT_EXPRESSION (\\  _ =  {  my  (expression as expression1) = 
expression1 ();
 (expression);
 } );
 ( lr_table::NONTERM 8,  ( result,  expression1left,  expression1right),  rest671);
 } 
;  ( 25,  ( ( _,  ( _,  _,  qmark1right)) !  ( _,  ( values::QQ_EXPRESSION expression1,  expression1left,  _)) !  rest671)) => {  my  result = values::QQ_EXPRESSION (\\  _ =  {  my  (expression as 
expression1) = expression1 ();
 (re::make_option expression);
 } );
 ( lr_table::NONTERM 9,  ( result,  expression1left,  qmark1right),  rest671);
 } 
;  ( 26,  ( ( _,  ( _,  _,  star1right)) !  ( _,  ( values::QQ_EXPRESSION expression1,  expression1left,  _)) !  rest671)) => {  my  result = values::QQ_EXPRESSION (\\  _ =  {  my  (expression as 
expression1) = expression1 ();
 (re::make_closure expression);
 } );
 ( lr_table::NONTERM 9,  ( result,  expression1left,  star1right),  rest671);
 } 
;  ( 27,  ( ( _,  ( _,  _,  plus1right)) !  ( _,  ( values::QQ_EXPRESSION expression1,  expression1left,  _)) !  rest671)) => {  my  result = values::QQ_EXPRESSION (\\  _ =  {  my  (expression as 
expression1) = expression1 ();
 (re::make_at_least (expression, 1));
 } );
 ( lr_table::NONTERM 9,  ( result,  expression1left,  plus1right),  rest671);
 } 
;  ( 28,  ( ( _,  ( _,  _,  rcb1right)) !  ( _,  ( values::REPS reps1,  _,  _)) !  ( _,  ( values::QQ_EXPRESSION expression1,  expression1left,  _)) !  rest671)) => {  my  result = 
values::QQ_EXPRESSION (\\  _ =  {  my  (expression as expression1) = expression1 ();
 my  (reps as reps1) = reps1 ();
 (re::make_repetition (expression, reps, reps));
 } );
 ( lr_table::NONTERM 9,  ( 
result,  expression1left,  rcb1right),  rest671);
 } 
;  ( 29,  ( ( _,  ( _,  _,  rcb1right)) !  ( _,  ( values::REPS reps2,  _,  _)) !  _ !  ( _,  ( values::REPS reps1,  _,  _)) !  ( _,  ( values::QQ_EXPRESSION expression1,  expression1left,  _)) !  
rest671)) => {  my  result = values::QQ_EXPRESSION (\\  _ =  {  my  (expression as expression1) = expression1 ();
 my  reps1 = reps1 ();
 my  reps2 = reps2 ();
 (
re::make_repetition (expression, reps1, reps2));
 } );
 ( lr_table::NONTERM 9,  ( result,  expression1left,  rcb1right),  rest671);
 } 
;  ( 30,  ( ( _,  ( values::QQ_IN_EXPRESSION in_expression1,  in_expression1left,  in_expression1right)) !  rest671)) => {  my  result = values::QQ_EXPRESSION (\\  _ =  {  my  (in_expression as 
in_expression1) = in_expression1 ();
 (in_expression);
 } );
 ( lr_table::NONTERM 9,  ( result,  in_expression1left,  in_expression1right),  rest671);
 } 
;  ( 31,  ( ( _,  ( values::CHAR char1,  char1left,  char1right)) !  rest671)) => {  my  result = values::QQ_IN_EXPRESSION (\\  _ =  {  my  (char as char1) = char1 ();
 (
re::make_symbol_set (sis::singleton (str_to_sym char)));
 } );
 ( lr_table::NONTERM 10,  ( result,  char1left,  char1right),  rest671);
 } 
;  ( 32,  ( ( _,  ( values::UNICHAR unichar1,  unichar1left,  unichar1right)) !  rest671)) => {  my  result = values::QQ_IN_EXPRESSION (\\  _ =  {  my  (unichar as unichar1) = unichar1 ();
 (
re::make_symbol_set (sis::singleton unichar));
 } );
 ( lr_table::NONTERM 10,  ( result,  unichar1left,  unichar1right),  rest671);
 } 
;  ( 33,  ( ( _,  ( _,  dot1left,  dot1right)) !  rest671)) => {  my  result = values::QQ_IN_EXPRESSION (\\  _ =  (re::make_symbol_set wildcard));
 ( lr_table::NONTERM 10,  ( result,  dot1left,  
dot1right),  rest671);
 } 
;  ( 34,  ( ( _,  ( _,  _,  rcb1right)) !  ( _,  ( values::ID id1,  id1left,  _)) !  rest671)) => {  my  result = values::QQ_IN_EXPRESSION (\\  _ =  {  my  (id as id1) = id1 ();
 (
case (quickstring_map::get (*sym_table, quickstring__premicrothread::from_string id))
		      THE re =>  re;
		      NULL   =>  raise exception DIE ("'" + id + "' not defined");
                 esac
                
);
 } );
 ( lr_table::NONTERM 10,  ( result,  id1left,  rcb1right),  rest671);
 } 
;  ( 35,  ( ( _,  ( _,  _,  rp1right)) !  ( _,  ( values::QQ_OR_EXPRESSION or_expression1,  _,  _)) !  ( _,  ( _,  lp1left,  _)) !  rest671)) => {  my  result = values::QQ_IN_EXPRESSION (\\  _ =  { 
 my  (or_expression as or_expression1) = or_expression1 ();
 (or_expression);
 } );
 ( lr_table::NONTERM 10,  ( result,  lp1left,  rp1right),  rest671);
 } 
;  ( 36,  ( ( _,  ( values::QQ_CHAR_ILK char_ilk1,  _,  char_ilk1right)) !  _ !  ( _,  ( _,  lb1left,  _)) !  rest671)) => {  my  result = values::QQ_IN_EXPRESSION (\\  _ =  {  my  (char_ilk as 
char_ilk1) = char_ilk1 ();
 (re::make_symbol_set (sis::complement char_ilk));
 } );
 ( lr_table::NONTERM 10,  ( result,  lb1left,  char_ilk1right),  rest671);
 } 
;  ( 37,  ( ( _,  ( values::QQ_CHAR_ILK char_ilk1,  _,  char_ilk1right)) !  ( _,  ( _,  lb1left,  _)) !  rest671)) => {  my  result = values::QQ_IN_EXPRESSION (\\  _ =  {  my  (char_ilk as char_ilk1)
 = char_ilk1 ();
 (re::make_symbol_set char_ilk);
 } );
 ( lr_table::NONTERM 10,  ( result,  lb1left,  char_ilk1right),  rest671);
 } 
;  ( 38,  ( ( _,  ( _,  _,  rb1right)) !  ( _,  ( values::QQ_CHAR_ILK' char_ilk'1,  char_ilk'1left,  _)) !  rest671)) => {  my  result = values::QQ_CHAR_ILK (\\  _ =  {  my  (char_ilk' as char_ilk'1)
 = char_ilk'1 ();
 (char_ilk');
 } );
 ( lr_table::NONTERM 11,  ( result,  char_ilk'1left,  rb1right),  rest671);
 } 
;  ( 39,  ( ( _,  ( _,  _,  rb1right)) !  ( _,  ( values::QQ_CHAR_ILK' char_ilk'1,  _,  _)) !  ( _,  ( _,  dash1left,  _)) !  rest671)) => {  my  result = values::QQ_CHAR_ILK (\\  _ =  {  my  (
char_ilk' as char_ilk'1) = char_ilk'1 ();
 (sis::add (char_ilk', char_to_sym '-'));
 } );
 ( lr_table::NONTERM 11,  ( result,  dash1left,  rb1right),  rest671);
 } 
;  ( 40,  ( ( _,  ( _,  _,  rbd1right)) !  ( _,  ( values::QQ_CHAR_ILK' char_ilk'1,  char_ilk'1left,  _)) !  rest671)) => {  my  result = values::QQ_CHAR_ILK (\\  _ =  {  my  (char_ilk' as char_ilk'1)
 = char_ilk'1 ();
 (sis::add (char_ilk', char_to_sym '-'));
 } );
 ( lr_table::NONTERM 11,  ( result,  char_ilk'1left,  rbd1right),  rest671);
 } 
;  ( 41,  ( ( _,  ( values::QQ_NON_CARAT non_carat1,  non_carat1left,  non_carat1right)) !  rest671)) => {  my  result = values::QQ_CHAR_ILK' (\\  _ =  {  my  (non_carat as non_carat1) = non_carat1 ()
;
 (sis::singleton non_carat);
 } );
 ( lr_table::NONTERM 12,  ( result,  non_carat1left,  non_carat1right),  rest671);
 } 
;  ( 42,  ( ( _,  ( values::QQ_A_CHAR a_char1,  _,  a_char1right)) !  _ !  ( _,  ( values::QQ_NON_CARAT non_carat1,  non_carat1left,  _)) !  rest671)) => {  my  result = values::QQ_CHAR_ILK' (\\  _ = 
 {  my  (non_carat as non_carat1) = non_carat1 ();
 my  (a_char as a_char1) = a_char1 ();
 (sis::interval (non_carat, a_char));
 } );
 ( lr_table::NONTERM 12,  ( result,  non_carat1left,  a_char1right
),  rest671);
 } 
;  ( 43,  ( ( _,  ( values::QQ_CHAR_RANGE char_range1,  _,  char_range1right)) !  ( _,  ( values::QQ_CHAR_ILK' char_ilk'1,  char_ilk'1left,  _)) !  rest671)) => {  my  result = values::QQ_CHAR_ILK'
 (\\  _ =  {  my  (char_ilk' as char_ilk'1) = char_ilk'1 ();
 my  (char_range as char_range1) = char_range1 ();
 (sis::union (char_range, char_ilk'));
 } );
 ( lr_table::NONTERM 12,  ( result,  
char_ilk'1left,  char_range1right),  rest671);
 } 
;  ( 44,  ( ( _,  ( values::QQ_A_CHAR a_char2,  _,  a_char2right)) !  _ !  ( _,  ( values::QQ_A_CHAR a_char1,  a_char1left,  _)) !  rest671)) => {  my  result = values::QQ_CHAR_RANGE (\\  _ =  {  my  
a_char1 = a_char1 ();
 my  a_char2 = a_char2 ();
 (sis::interval (a_char1, a_char2));
 } );
 ( lr_table::NONTERM 13,  ( result,  a_char1left,  a_char2right),  rest671);
 } 
;  ( 45,  ( ( _,  ( values::QQ_A_CHAR a_char1,  a_char1left,  a_char1right)) !  rest671)) => {  my  result = values::QQ_CHAR_RANGE (\\  _ =  {  my  (a_char as a_char1) = a_char1 ();
 (
sis::singleton a_char);
 } );
 ( lr_table::NONTERM 13,  ( result,  a_char1left,  a_char1right),  rest671);
 } 
;  ( 46,  ( ( _,  ( _,  carat1left,  carat1right)) !  rest671)) => {  my  result = values::QQ_A_CHAR (\\  _ =  (char_to_sym '^'));
 ( lr_table::NONTERM 14,  ( result,  carat1left,  carat1right),  
rest671);
 } 
;  ( 47,  ( ( _,  ( values::QQ_NON_CARAT non_carat1,  non_carat1left,  non_carat1right)) !  rest671)) => {  my  result = values::QQ_A_CHAR (\\  _ =  {  my  (non_carat as non_carat1) = non_carat1 ();

 (non_carat);
 } );
 ( lr_table::NONTERM 14,  ( result,  non_carat1left,  non_carat1right),  rest671);
 } 
;  ( 48,  ( ( _,  ( values::CHAR char1,  char1left,  char1right)) !  rest671)) => {  my  result = values::QQ_NON_CARAT (\\  _ =  {  my  (char as char1) = char1 ();
 (str_to_sym char);
 } );
 ( 
lr_table::NONTERM 15,  ( result,  char1left,  char1right),  rest671);
 } 
;  ( 49,  ( ( _,  ( values::UNICHAR unichar1,  unichar1left,  unichar1right)) !  rest671)) => {  my  result = values::QQ_NON_CARAT (\\  _ =  {  my  (unichar as unichar1) = unichar1 ();
 (unichar);
 } 
);
 ( lr_table::NONTERM 15,  ( result,  unichar1left,  unichar1right),  rest671);
 } 
; _ => raise exception (MLY_ACTION i392);
esac;
end;
void = values::TM_VOID;
extract = \\ a = (\\ values::QQ_START x => x;
 _ => { exception PARSE_INTERNAL;
	 raise exception PARSE_INTERNAL; }; end ) a ();
};
};
package tokens : (weak) Ml_Lex_Tokens {
Semantic_Value = parser_data::Semantic_Value;
Token (X,Y) = token::Token(X,Y);
fun eofx (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 0, (parser_data::values::TM_VOID, p1, p2));
fun decls (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 1, (parser_data::values::DECLS (\\ () = i), p1, p2));
fun lt (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 2, (parser_data::values::TM_VOID, p1, p2));
fun gt (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 3, (parser_data::values::TM_VOID, p1, p2));
fun lp (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 4, (parser_data::values::TM_VOID, p1, p2));
fun rp (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 5, (parser_data::values::TM_VOID, p1, p2));
fun lb (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 6, (parser_data::values::TM_VOID, p1, p2));
fun rb (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 7, (parser_data::values::TM_VOID, p1, p2));
fun rbd (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 8, (parser_data::values::TM_VOID, p1, p2));
fun lcb (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 9, (parser_data::values::TM_VOID, p1, p2));
fun rcb (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 10, (parser_data::values::TM_VOID, p1, p2));
fun qmark (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 11, (parser_data::values::TM_VOID, p1, p2));
fun star (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 12, (parser_data::values::TM_VOID, p1, p2));
fun plus (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 13, (parser_data::values::TM_VOID, p1, p2));
fun bar (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 14, (parser_data::values::TM_VOID, p1, p2));
fun carat (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 15, (parser_data::values::TM_VOID, p1, p2));
fun dollar (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 16, (parser_data::values::TM_VOID, p1, p2));
fun slash (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 17, (parser_data::values::TM_VOID, p1, p2));
fun dash (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 18, (parser_data::values::TM_VOID, p1, p2));
fun char (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 19, (parser_data::values::CHAR (\\ () = i), p1, p2));
fun unichar (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 20, (parser_data::values::UNICHAR (\\ () = i), p1, p2));
fun dot (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 21, (parser_data::values::TM_VOID, p1, p2));
fun eq (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 22, (parser_data::values::TM_VOID, p1, p2));
fun reps (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 23, (parser_data::values::REPS (\\ () = i), p1, p2));
fun id (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 24, (parser_data::values::ID (\\ () = i), p1, p2));
fun arrow (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 25, (parser_data::values::TM_VOID, p1, p2));
fun act (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 26, (parser_data::values::ACT (\\ () = i), p1, p2));
fun semi (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 27, (parser_data::values::TM_VOID, p1, p2));
fun lexmark (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 28, (parser_data::values::TM_VOID, p1, p2));
fun comma (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 29, (parser_data::values::TM_VOID, p1, p2));
fun states (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 30, (parser_data::values::TM_VOID, p1, p2));
fun lexstate (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 31, (parser_data::values::LEXSTATE (\\ () = i), p1, p2));
fun count (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 32, (parser_data::values::TM_VOID, p1, p2));
fun rejecttok (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 33, (parser_data::values::TM_VOID, p1, p2));
fun full (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 34, (parser_data::values::TM_VOID, p1, p2));
fun unicode (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 35, (parser_data::values::TM_VOID, p1, p2));
fun structx (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 36, (parser_data::values::TM_VOID, p1, p2));
fun header (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 37, (parser_data::values::TM_VOID, p1, p2));
fun arg (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 38, (parser_data::values::TM_VOID, p1, p2));
fun posarg (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 39, (parser_data::values::TM_VOID, p1, p2));
};
};
