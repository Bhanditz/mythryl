generic package libfile_lr_vals_fun(package token:  Token;)
 : (weak) api { package parser_data : Parser_Data;
       package tokens : Libfile_Tokens;
   }
 { 
package parser_data{
package header { 
## libfile.grammar
## (C) 1999, 2001 Lucent Technologies, Bell Laboratories
## Author: Matthias Blume (blume@research.bell-labs.com)



# Mythryl-Yacc grammar for .lib library-definition files


package ad  =  anchor_dictionary;			# anchor_dictionary			is from   src/app/makelib/paths/anchor-dictionary.pkg
package lga =  libfile_grammar_actions;			# libfile_grammar_actions		is from   src/app/makelib/parse/libfile-grammar-actions.pkg
package lg  =  inter_library_dependency_graph;		# inter_library_dependency_graph	is from   src/app/makelib/depend/inter-library-dependency-graph.pkg
package mvi =  makelib_version_intlist;			# makelib_version_intlist		is from   src/app/makelib/stuff/makelib-version-intlist.pkg
package pmt =  private_makelib_tools;			# private_makelib_tools			is from   src/app/makelib/tools/main/private-makelib-tools.pkg
package sy  =  symbol;					# symbol				is from   src/lib/compiler/front/basics/map/symbol.pkg


};
package lr_table = token::lr_table;
package token = token;
stipulate include package   lr_table; herein 
my table={   action_rows =
"\
\\x01\x00\x01\x00\x00\x00\x00\x00\
\\x01\x00\x02\x00\xc2\x00\x03\x00\xc2\x00\x07\x00\xc2\x00\x08\x00\xc2\x00\
\\x0a\x00\xc2\x00\x0b\x00\xc2\x00\x0d\x00\xc2\x00\x0e\x00\xc2\x00\
\\x0f\x00\xc2\x00\x10\x00\xc2\x00\x11\x00\xc2\x00\x12\x00\xc2\x00\
\\x13\x00\xc2\x00\x14\x00\xc2\x00\x15\x00\xc2\x00\x1c\x00\xc2\x00\
\\x1d\x00\xc2\x00\x21\x00\xc2\x00\x00\x00\
\\x01\x00\x02\x00\x33\x00\x03\x00\x32\x00\x00\x00\
\\x01\x00\x02\x00\x33\x00\x03\x00\x32\x00\x0a\x00\x67\x00\x00\x00\
\\x01\x00\x02\x00\x33\x00\x03\x00\x32\x00\x20\x00\x31\x00\x00\x00\
\\x01\x00\x02\x00\x6b\x00\x00\x00\
\\x01\x00\x04\x00\x28\x00\x06\x00\x27\x00\x0a\x00\x26\x00\x16\x00\x25\x00\
\\x1b\x00\x24\x00\x1e\x00\x23\x00\x00\x00\
\\x01\x00\x04\x00\x28\x00\x06\x00\x27\x00\x0a\x00\x46\x00\x1b\x00\x24\x00\x00\x00\
\\x01\x00\x04\x00\x28\x00\x12\x00\x0e\x00\x13\x00\x0d\x00\x14\x00\x0c\x00\
\\x15\x00\x0b\x00\x00\x00\
\\x01\x00\x05\x00\x1c\x00\x00\x00\
\\x01\x00\x05\x00\x1d\x00\x00\x00\
\\x01\x00\x05\x00\x1e\x00\x00\x00\
\\x01\x00\x05\x00\x1f\x00\x00\x00\
\\x01\x00\x07\x00\x04\x00\x08\x00\x03\x00\x00\x00\
\\x01\x00\x07\x00\x13\x00\x08\x00\x12\x00\x09\x00\x1b\x00\x0a\x00\x16\x00\
\\x0d\x00\x10\x00\x11\x00\x0f\x00\x12\x00\x0e\x00\x13\x00\x0d\x00\
\\x14\x00\x0c\x00\x15\x00\x0b\x00\x21\x00\x0a\x00\x00\x00\
\\x01\x00\x07\x00\x13\x00\x08\x00\x12\x00\x09\x00\x72\x00\x0a\x00\x16\x00\
\\x0d\x00\x10\x00\x11\x00\x0f\x00\x12\x00\x0e\x00\x13\x00\x0d\x00\
\\x14\x00\x0c\x00\x15\x00\x0b\x00\x21\x00\x0a\x00\x00\x00\
\\x01\x00\x07\x00\x13\x00\x08\x00\x12\x00\x0a\x00\x11\x00\x0d\x00\x10\x00\
\\x11\x00\x0f\x00\x12\x00\x0e\x00\x13\x00\x0d\x00\x14\x00\x0c\x00\
\\x15\x00\x0b\x00\x21\x00\x0a\x00\x00\x00\
\\x01\x00\x07\x00\x13\x00\x08\x00\x12\x00\x0a\x00\x16\x00\x0b\x00\x4b\x00\
\\x0d\x00\x10\x00\x11\x00\x0f\x00\x12\x00\x0e\x00\x13\x00\x0d\x00\
\\x14\x00\x0c\x00\x15\x00\x0b\x00\x21\x00\x0a\x00\x00\x00\
\\x01\x00\x07\x00\x13\x00\x08\x00\x12\x00\x0a\x00\x16\x00\x0d\x00\x10\x00\
\\x0e\x00\x57\x00\x0f\x00\x56\x00\x10\x00\x55\x00\x11\x00\x0f\x00\
\\x12\x00\x0e\x00\x13\x00\x0d\x00\x14\x00\x0c\x00\x15\x00\x0b\x00\
\\x21\x00\x0a\x00\x00\x00\
\\x01\x00\x07\x00\x13\x00\x08\x00\x12\x00\x0a\x00\x16\x00\x0d\x00\x10\x00\
\\x10\x00\x7a\x00\x11\x00\x0f\x00\x12\x00\x0e\x00\x13\x00\x0d\x00\
\\x14\x00\x0c\x00\x15\x00\x0b\x00\x21\x00\x0a\x00\x00\x00\
\\x01\x00\x07\x00\x13\x00\x08\x00\x12\x00\x0a\x00\x16\x00\x0d\x00\x10\x00\
\\x11\x00\x0f\x00\x12\x00\x0e\x00\x13\x00\x0d\x00\x14\x00\x0c\x00\
\\x15\x00\x0b\x00\x21\x00\x0a\x00\x00\x00\
\\x01\x00\x07\x00\x13\x00\x08\x00\x12\x00\x0a\x00\x16\x00\x12\x00\x0e\x00\
\\x13\x00\x0d\x00\x14\x00\x0c\x00\x15\x00\x0b\x00\x21\x00\x0a\x00\x00\x00\
\\x01\x00\x09\x00\x2d\x00\x00\x00\
\\x01\x00\x0a\x00\x17\x00\x00\x00\
\\x01\x00\x0a\x00\x2c\x00\x00\x00\
\\x01\x00\x0a\x00\x47\x00\x00\x00\
\\x01\x00\x0b\x00\x4c\x00\x00\x00\
\\x01\x00\x0b\x00\x4f\x00\x00\x00\
\\x01\x00\x0b\x00\x62\x00\x19\x00\x3f\x00\x1c\x00\x3e\x00\x1d\x00\x3d\x00\x00\x00\
\\x01\x00\x0b\x00\x63\x00\x17\x00\x43\x00\x18\x00\x42\x00\x00\x00\
\\x01\x00\x0b\x00\x63\x00\x17\x00\x43\x00\x18\x00\x42\x00\x19\x00\x41\x00\
\\x1a\x00\x40\x00\x00\x00\
\\x01\x00\x0b\x00\x70\x00\x00\x00\
\\x01\x00\x0b\x00\x71\x00\x00\x00\
\\x01\x00\x0b\x00\x73\x00\x00\x00\
\\x01\x00\x0b\x00\x7d\x00\x00\x00\
\\x01\x00\x0e\x00\x79\x00\x0f\x00\x78\x00\x10\x00\x77\x00\x00\x00\
\\x01\x00\x10\x00\x84\x00\x00\x00\
\\x01\x00\x17\x00\x43\x00\x18\x00\x42\x00\x19\x00\x41\x00\x1a\x00\x40\x00\x00\x00\
\\x89\x00\x00\x00\
\\x8a\x00\x00\x00\
\\x8b\x00\x00\x00\
\\x8c\x00\x00\x00\
\\x8d\x00\x00\x00\
\\x8e\x00\x00\x00\
\\x8f\x00\x07\x00\x13\x00\x08\x00\x12\x00\x0a\x00\x16\x00\x0d\x00\x10\x00\
\\x11\x00\x0f\x00\x12\x00\x0e\x00\x13\x00\x0d\x00\x14\x00\x0c\x00\
\\x15\x00\x0b\x00\x21\x00\x0a\x00\x00\x00\
\\x90\x00\x07\x00\x13\x00\x08\x00\x12\x00\x0a\x00\x16\x00\x0d\x00\x10\x00\
\\x11\x00\x0f\x00\x12\x00\x0e\x00\x13\x00\x0d\x00\x14\x00\x0c\x00\
\\x15\x00\x0b\x00\x21\x00\x0a\x00\x00\x00\
\\x91\x00\x00\x00\
\\x91\x00\x02\x00\x2b\x00\x00\x00\
\\x91\x00\x19\x00\x3f\x00\x1c\x00\x3e\x00\x1d\x00\x3d\x00\x00\x00\
\\x92\x00\x00\x00\
\\x93\x00\x1f\x00\x19\x00\x20\x00\x18\x00\x00\x00\
\\x94\x00\x00\x00\
\\x95\x00\x00\x00\
\\x96\x00\x00\x00\
\\x97\x00\x00\x00\
\\x98\x00\x00\x00\
\\x99\x00\x00\x00\
\\x9a\x00\x00\x00\
\\x9b\x00\x1f\x00\x19\x00\x00\x00\
\\x9c\x00\x00\x00\
\\x9d\x00\x00\x00\
\\x9e\x00\x00\x00\
\\x9f\x00\x00\x00\
\\xa0\x00\x00\x00\
\\xa1\x00\x00\x00\
\\xa2\x00\x02\x00\x33\x00\x03\x00\x32\x00\x0d\x00\x3a\x00\x11\x00\x39\x00\x00\x00\
\\xa2\x00\x02\x00\x33\x00\x03\x00\x32\x00\x0d\x00\x3a\x00\x11\x00\x39\x00\
\\x19\x00\x3f\x00\x1c\x00\x3e\x00\x1d\x00\x3d\x00\x00\x00\
\\xa3\x00\x00\x00\
\\xa4\x00\x02\x00\x33\x00\x03\x00\x32\x00\x00\x00\
\\xa4\x00\x02\x00\x33\x00\x03\x00\x32\x00\x0c\x00\x7f\x00\x00\x00\
\\xa5\x00\x00\x00\
\\xa6\x00\x00\x00\
\\xa7\x00\x00\x00\
\\xa8\x00\x00\x00\
\\xa9\x00\x0a\x00\x67\x00\x00\x00\
\\xaa\x00\x00\x00\
\\xab\x00\x0c\x00\x51\x00\x00\x00\
\\xac\x00\x00\x00\
\\xad\x00\x00\x00\
\\xae\x00\x00\x00\
\\xaf\x00\x00\x00\
\\xb0\x00\x00\x00\
\\xb1\x00\x00\x00\
\\xb2\x00\x00\x00\
\\xb3\x00\x00\x00\
\\xb4\x00\x00\x00\
\\xb5\x00\x00\x00\
\\xb6\x00\x00\x00\
\\xb7\x00\x00\x00\
\\xb8\x00\x00\x00\
\\xb9\x00\x00\x00\
\\xba\x00\x18\x00\x42\x00\x00\x00\
\\xbb\x00\x00\x00\
\\xbc\x00\x00\x00\
\\xbd\x00\x00\x00\
\\xbe\x00\x00\x00\
\\xbf\x00\x00\x00\
\\xc0\x00\x19\x00\x3f\x00\x00\x00\
\\xc1\x00\x19\x00\x3f\x00\x1c\x00\x3e\x00\x00\x00\
\\xc3\x00\x00\x00\
\\xc4\x00\x17\x00\x43\x00\x18\x00\x42\x00\x00\x00\
\\xc5\x00\x17\x00\x43\x00\x18\x00\x42\x00\x00\x00\
\\xc6\x00\x00\x00\
\\xc7\x00\x00\x00\
\\xc8\x00\x00\x00\
\\xc9\x00\x00\x00\
\\xca\x00\x00\x00\
\\xcb\x00\x00\x00\
\\xcc\x00\x00\x00\
\\xcd\x00\x00\x00\
\\xce\x00\x00\x00\
\";
    action_row_numbers =
"\x0d\x00\x10\x00\x2c\x00\x17\x00\
\\x32\x00\x37\x00\x2a\x00\x0e\x00\
\\x36\x00\x09\x00\x0a\x00\x0b\x00\
\\x0c\x00\x34\x00\x06\x00\x2f\x00\
\\x18\x00\x35\x00\x16\x00\x2d\x00\
\\x2e\x00\x04\x00\x15\x00\x15\x00\
\\x2b\x00\x41\x00\x69\x00\x68\x00\
\\x67\x00\x66\x00\x59\x00\x30\x00\
\\x25\x00\x06\x00\x07\x00\x19\x00\
\\x06\x00\x58\x00\x57\x00\x11\x00\
\\x1a\x00\x29\x00\x02\x00\x41\x00\
\\x1b\x00\x6d\x00\x6c\x00\x6e\x00\
\\x6b\x00\x6a\x00\x3a\x00\x39\x00\
\\x4c\x00\x41\x00\x28\x00\x50\x00\
\\x06\x00\x33\x00\x12\x00\x06\x00\
\\x06\x00\x06\x00\x07\x00\x07\x00\
\\x07\x00\x07\x00\x63\x00\x5d\x00\
\\x07\x00\x08\x00\x1c\x00\x1e\x00\
\\x31\x00\x38\x00\x14\x00\x4a\x00\
\\x26\x00\x3b\x00\x4a\x00\x05\x00\
\\x43\x00\x42\x00\x3d\x00\x3e\x00\
\\x2e\x00\x06\x00\x62\x00\x61\x00\
\\x01\x00\x64\x00\x65\x00\x5c\x00\
\\x5b\x00\x1d\x00\x1f\x00\x20\x00\
\\x60\x00\x5a\x00\x0f\x00\x21\x00\
\\x4b\x00\x44\x00\x4e\x00\x4d\x00\
\\x51\x00\x56\x00\x4f\x00\x23\x00\
\\x13\x00\x30\x00\x5f\x00\x5e\x00\
\\x41\x00\x3c\x00\x22\x00\x45\x00\
\\x52\x00\x53\x00\x41\x00\x06\x00\
\\x3f\x00\x40\x00\x27\x00\x49\x00\
\\x46\x00\x03\x00\x24\x00\x42\x00\
\\x44\x00\x44\x00\x54\x00\x55\x00\
\\x47\x00\x48\x00\x00\x00";
   goto_table =
"\
\\x01\x00\x86\x00\x00\x00\
\\x03\x00\x07\x00\x06\x00\x06\x00\x0f\x00\x05\x00\x10\x00\x04\x00\
\\x1b\x00\x03\x00\x00\x00\
\\x03\x00\x13\x00\x04\x00\x12\x00\x06\x00\x06\x00\x0f\x00\x05\x00\
\\x10\x00\x04\x00\x1b\x00\x03\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x06\x00\x18\x00\x0f\x00\x05\x00\x10\x00\x04\x00\x1b\x00\x03\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x0d\x00\x20\x00\x0e\x00\x1f\x00\x12\x00\x1e\x00\x00\x00\
\\x02\x00\x28\x00\x05\x00\x27\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x06\x00\x18\x00\x0f\x00\x05\x00\x10\x00\x04\x00\x1b\x00\x03\x00\x00\x00\
\\x05\x00\x27\x00\x00\x00\
\\x11\x00\x2e\x00\x19\x00\x2d\x00\x1a\x00\x2c\x00\x00\x00\
\\x0f\x00\x05\x00\x10\x00\x32\x00\x1b\x00\x03\x00\x00\x00\
\\x0f\x00\x05\x00\x10\x00\x33\x00\x1b\x00\x03\x00\x00\x00\
\\x00\x00\
\\x09\x00\x36\x00\x0a\x00\x35\x00\x11\x00\x34\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x05\x00\x3a\x00\x07\x00\x39\x00\x00\x00\
\\x00\x00\
\\x0d\x00\x20\x00\x0e\x00\x42\x00\x12\x00\x1e\x00\x00\x00\
\\x0d\x00\x43\x00\x12\x00\x1e\x00\x00\x00\
\\x00\x00\
\\x0d\x00\x47\x00\x0e\x00\x46\x00\x12\x00\x1e\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x06\x00\x48\x00\x0f\x00\x05\x00\x10\x00\x04\x00\x1b\x00\x03\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x11\x00\x4b\x00\x00\x00\
\\x09\x00\x4c\x00\x0a\x00\x35\x00\x11\x00\x34\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x15\x00\x4e\x00\x00\x00\
\\x09\x00\x50\x00\x0a\x00\x35\x00\x11\x00\x34\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x0d\x00\x20\x00\x0e\x00\x51\x00\x12\x00\x1e\x00\x00\x00\
\\x00\x00\
\\x06\x00\x48\x00\x08\x00\x52\x00\x0f\x00\x05\x00\x10\x00\x04\x00\
\\x1b\x00\x03\x00\x00\x00\
\\x0d\x00\x20\x00\x0e\x00\x56\x00\x12\x00\x1e\x00\x00\x00\
\\x0d\x00\x20\x00\x0e\x00\x57\x00\x12\x00\x1e\x00\x00\x00\
\\x0d\x00\x20\x00\x0e\x00\x58\x00\x12\x00\x1e\x00\x00\x00\
\\x0d\x00\x59\x00\x12\x00\x1e\x00\x00\x00\
\\x0d\x00\x5a\x00\x12\x00\x1e\x00\x00\x00\
\\x0d\x00\x5b\x00\x12\x00\x1e\x00\x00\x00\
\\x0d\x00\x5c\x00\x12\x00\x1e\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x0d\x00\x5d\x00\x12\x00\x1e\x00\x00\x00\
\\x0f\x00\x5f\x00\x12\x00\x5e\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x03\x00\x62\x00\x06\x00\x06\x00\x0f\x00\x05\x00\x10\x00\x04\x00\
\\x1b\x00\x03\x00\x00\x00\
\\x17\x00\x64\x00\x18\x00\x63\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x17\x00\x64\x00\x18\x00\x66\x00\x00\x00\
\\x13\x00\x68\x00\x14\x00\x67\x00\x00\x00\
\\x00\x00\
\\x09\x00\x6b\x00\x0a\x00\x35\x00\x0b\x00\x6a\x00\x11\x00\x34\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x05\x00\x6c\x00\x00\x00\
\\x0d\x00\x20\x00\x0e\x00\x6d\x00\x12\x00\x1e\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x06\x00\x18\x00\x0f\x00\x05\x00\x10\x00\x04\x00\x1b\x00\x03\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x11\x00\x73\x00\x16\x00\x72\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x0c\x00\x74\x00\x00\x00\
\\x06\x00\x48\x00\x0f\x00\x05\x00\x10\x00\x04\x00\x1b\x00\x03\x00\x00\x00\
\\x05\x00\x3a\x00\x07\x00\x79\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x09\x00\x7a\x00\x0a\x00\x35\x00\x11\x00\x34\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x11\x00\x73\x00\x16\x00\x7c\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x09\x00\x7e\x00\x0a\x00\x35\x00\x11\x00\x34\x00\x00\x00\
\\x0d\x00\x20\x00\x0e\x00\x7f\x00\x12\x00\x1e\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x11\x00\x81\x00\x17\x00\x80\x00\x00\x00\
\\x00\x00\
\\x09\x00\x6b\x00\x0a\x00\x35\x00\x0b\x00\x83\x00\x11\x00\x34\x00\x00\x00\
\\x11\x00\x73\x00\x16\x00\x84\x00\x00\x00\
\\x11\x00\x73\x00\x16\x00\x85\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\";
   numstates = 135;
   numrules = 70;
 s = REF "";  index = REF 0;
    string_to_int = \\ () = 
    {    i = *index;
         index := i+2;
         string::get_byte(*s, i) + string::get_byte(*s, i+1) * 256;
    };

    string_to_list = \\ s' =
    {   len = string::length_in_bytes s';
        fun f () =
           if (*index < len)
           string_to_int() ! f();
           else NIL; fi;
        index := 0;
        s := s';
        f ();
   };

   string_to_pairlist =   \\ (conv_key, conv_entry) =   f
   where 
         fun f ()
             =
             case (string_to_int ())
                 0 => EMPTY;
                 n => PAIR (conv_key (n - 1), conv_entry (string_to_int()), f());
             esac;
   end;

   string_to_pairlist_default =   \\ (conv_key, conv_entry) =
    {   conv_row = string_to_pairlist (conv_key, conv_entry);
       \\ () =
       {   default = conv_entry (string_to_int());
           row = conv_row();
          (row, default);
       };
   };

    string_to_table = \\ (convert_row, s') =
    {   len = string::length_in_bytes s';
        fun f ()
            =
           if (*index < len)
              convert_row() ! f();
           else NIL; fi;
        s := s';
        index := 0;
        f ();
     };

stipulate
  memo = rw_vector::make_rw_vector (numstates+numrules, ERROR);
  my _ ={   fun g i
                =
                {   rw_vector::set (memo, i, REDUCE (i-numstates));
                    g (i+1);
                };

            fun f i
                =
                if   (i == numstates)
                     g i;
                else    rw_vector::set (memo, i, SHIFT (STATE i));
                         f (i+1);
                fi;

            f 0
            except
                INDEX_OUT_OF_BOUNDS =  ();
        };
herein
    entry_to_action
        =
        \\ 0 =>  ACCEPT;
           1 =>  ERROR;
           j =>  rw_vector::get (memo, (j - 2));
        end;
end;

   goto_table = rw_vector::from_list (string_to_table (string_to_pairlist (NONTERM, STATE), goto_table));
   action_rows = string_to_table (string_to_pairlist_default (TERM, entry_to_action), action_rows);
   action_row_numbers = string_to_list action_row_numbers;
   action_table
    =
    {   action_row_lookup
            =
            {   a=rw_vector::from_list (action_rows);

                \\ i =   rw_vector::get (a, i);
            };

        rw_vector::from_list (map action_row_lookup action_row_numbers);
    };

    lr_table::make_lr_table {
        actions => action_table,
        gotos   => goto_table,
        rule_count   => numrules,
        state_count  => numstates,
        initial_state => STATE 0   };
};
end;
stipulate include package   header; herein
Source_Position = Int;
Arg = { libfile: ad::File, path_root: ad::Path_Root, complain_about_obsolete_syntax: (Source_Position, Source_Position) -> Void, report_error: (Source_Position, Source_Position) -> String -> Void, make_member: ( { name: String,
		      make_path: Void -> ad::Dir_Path
		    },
		    Source_Position,
		    Source_Position,
		    Null_Or lga::Cm_Ilk,
		    Null_Or List lga::Tool_Option
		  ) -> lga::Members, this_library: Null_Or ad::File , makelib_state: makelib_state::Makelib_State, primordial_library: lg::Library };
package values { 
Semantic_Value = TM_VOID | NT_VOID  Void -> Void | INEQSYM Void ->  (libfile_grammar_actions::Ineqsym) | EQSYM Void ->  (libfile_grammar_actions::Eqsym)
 | MULSYM Void ->  (libfile_grammar_actions::Mulsym) | ADDSYM Void ->  (libfile_grammar_actions::Addsym) | ERRORX Void ->  (String) | NUMBER Void ->  (Int) | ML_ID Void ->  (String)
 | MAKELIB_ID Void ->  (String) | FILE_NATIVE Void ->  (String) | FILE_STANDARD Void ->  (String)
 | QQ_SUBLIB_OR_APIPKG_EXPORTS Void ->  ((Null_Or ad::File, lga::Plaint_Sink) -> lga::Exports_Symbolset) | QQ_NULL_OR_SRCFILE Void ->  (Null_Or ad::File ) | QQ_SRCFILE Void ->  (ad::File)
 | QQ_OPTTOOLOPTS Void ->  (Null_Or List lga::Tool_Option  ) | QQ_PTOOLOPTS Void ->  (List lga::Tool_Option ) | QQ_TOOLOPTS Void ->  (List lga::Tool_Option )
 | QQ_NULL_OR_ILK_QUALIFIER Void ->  (Null_Or lga::Cm_Ilk ) | QQ_ILK Void ->  (lga::Cm_Ilk) | QQ_WORD Void ->  (lga::Cm_Symbol) | QQ_MAKELIB_ID Void ->  (lga::Cm_Symbol)
 | QQ_PATHNAME Void ->  ({ name: String, make_path: Void -> ad::Dir_Path }) | QQ_ML_SYMBOLSET Void ->  (lga::Exports_Symbolset) | QQ_ML_SYMBOL Void ->  (sy::Symbol)
 | QQ_BOOL_EXP Void ->  (lga::Bool_Expression) | QQ_INT_EXP Void ->  (lga::Int_Expression) | QQ_ELSE_MEMBERS Void ->  (lga::Members) | QQ_GUARDED_MEMBERS Void ->  ((lga::Members, lga::Members))
 | QQ_MEMBER Void ->  (lga::Members) | QQ_MEMBERS Void ->  (lga::Members) | QQ_ELSE_EXPORTS Void ->  (lga::Exports_Symbolset)
 | QQ_CONDITIONAL_EXPORTS Void ->  ((lga::Exports_Symbolset, lga::Exports_Symbolset)) | QQ_EXPORT Void ->  (lga::Exports_Symbolset) | QQ_EXPORTS Void ->  (lga::Exports_Symbolset)
 | QQ_ZERO_OR_MORE_EXPORTS Void ->  (lga::Exports_Symbolset) | QQ_ONE_OR_MORE_EXPORTS Void ->  (lga::Exports_Symbolset) | QQ_MAKELIB_VERSION_INTLIST Void ->  (mvi::Makelib_Version_Intlist)
 | QQ_LIBRARY Void ->  (lg::Library);
};
Semantic_Value = values::Semantic_Value;
Result = lg::Library;
end;
package error_recovery{
include package lr_table;
infix my 60 @@;
fun x @@ y = y ! x;
is_keyword =
\\ (TERM 6) => TRUE; (TERM 7) => TRUE; (TERM 8) => TRUE; (TERM 12) => TRUE; (TERM 13) => TRUE; (TERM 14) => TRUE; (TERM 15) => TRUE; (TERM 21) => TRUE; (TERM 17) => TRUE; (TERM 18) => TRUE; (TERM 19)
 => TRUE; (TERM 20) => TRUE; _ => FALSE; end;
my preferred_change:   List( (List( Terminal ), List( Terminal )) ) = 
(NIL
, NIL
 @@ (TERM 9)) ! 
NIL;
no_shift = 
\\ (TERM 0) => TRUE; _ => FALSE; end;
show_terminal =
\\ (TERM 0) => "EOF"
; (TERM 1) => "FILE_STANDARD"
; (TERM 2) => "FILE_NATIVE"
; (TERM 3) => "MAKELIB_ID"
; (TERM 4) => "ML_ID"
; (TERM 5) => "NUMBER"
; (TERM 6) => "SUBLIBRARY_EXPORTS"
; (TERM 7) => "LIBRARY_EXPORTS"
; (TERM 8) => "LIBRARY_COMPONENTS"
; (TERM 9) => "LPAREN"
; (TERM 10) => "RPAREN"
; (TERM 11) => "COLON"
; (TERM 12) => "IF_T"
; (TERM 13) => "ELIF_T"
; (TERM 14) => "ELSE_T"
; (TERM 15) => "ENDIF"
; (TERM 16) => "ERRORX"
; (TERM 17) => "PKG_T"
; (TERM 18) => "API_T"
; (TERM 19) => "GENERIC_T"
; (TERM 20) => "GENERIC_API_T"
; (TERM 21) => "DEFINED"
; (TERM 22) => "ADDSYM"
; (TERM 23) => "MULSYM"
; (TERM 24) => "EQSYM"
; (TERM 25) => "INEQSYM"
; (TERM 26) => "TILDE"
; (TERM 27) => "AND_T"
; (TERM 28) => "OR_T"
; (TERM 29) => "NOT_T"
; (TERM 30) => "STAR"
; (TERM 31) => "DASH"
; (TERM 32) => "API_OR_PKG_EXPORTS"
; _ => "bogus-term"; end;
stipulate include package   header; herein
errtermvalue=
\\ _ => values::TM_VOID;
 end; end;
my terms:  List( Terminal ) = NIL
 @@ (TERM 32) @@ (TERM 31) @@ (TERM 30) @@ (TERM 29) @@ (TERM 28) @@ (TERM 27) @@ (TERM 26) @@ (TERM 21) @@ (TERM 20) @@ (TERM 19) @@ (TERM 18) @@ (TERM 17) @@ (TERM 15) @@ (TERM 14) @@ (TERM 13) @@ 
(TERM 12) @@ (TERM 11) @@ (TERM 10) @@ (TERM 9) @@ (TERM 8) @@ (TERM 7) @@ (TERM 6) @@ (TERM 0);
};
package actions {
exception MLY_ACTION Int;
stipulate include package   header; herein
actions = 
\\ (i392, default_position, stack, 
    ( { libfile, path_root, complain_about_obsolete_syntax, report_error, make_member, this_library, makelib_state, primordial_library }): Arg) = 
case (i392, stack)
  ( 0,  ( ( _,  ( values::QQ_MEMBERS members1,  _,  members1right)) !  _ !  ( _,  ( values::QQ_ZERO_OR_MORE_EXPORTS zero_or_more_exports1,  _,  _)) !  ( _,  ( _,  sublibrary_exports1left,  _)) !  
rest671)) => {  my  result = values::QQ_LIBRARY (\\  _ =  {  my  (zero_or_more_exports as zero_or_more_exports1) = zero_or_more_exports1 ();
 my  (members as members1) = members1 ();
 (
   lga::make_sublibrary {
							path         => libfile,
							exports      => zero_or_more_exports,
							members,
							makelib_state,
							this_library,
							primordial_library
                                                    }
                                                
);
 } );
 ( lr_table::NONTERM 0,  ( result,  sublibrary_exports1left,  members1right),  rest671);
 } 
;  ( 1,  ( ( _,  ( values::QQ_MEMBERS members1,  _,  members1right)) !  _ !  ( _,  ( values::QQ_ONE_OR_MORE_EXPORTS one_or_more_exports1,  _,  _)) !  _ !  ( _,  ( values::QQ_MAKELIB_VERSION_INTLIST 
makelib_version_intlist1,  _,  _)) !  _ !  ( _,  ( _,  library_exports1left,  _)) !  rest671)) => {  my  result = values::QQ_LIBRARY (\\  _ =  {  my  (makelib_version_intlist as 
makelib_version_intlist1) = makelib_version_intlist1 ();
 my  (one_or_more_exports as one_or_more_exports1) = one_or_more_exports1 ();
 my  (members as members1) = members1 ();
 (
   lga::make_main_library {
							path			=>  libfile,
							exports     		=>  one_or_more_exports,
							makelib_version_intlist =>  THE makelib_version_intlist,
							members,
							makelib_state,
							primordial_library
                                                    }
                                                
);
 } );
 ( lr_table::NONTERM 0,  ( result,  library_exports1left,  members1right),  rest671);
 } 
;  ( 2,  ( ( _,  ( values::QQ_MEMBERS members1,  _,  members1right)) !  _ !  ( _,  ( values::QQ_ONE_OR_MORE_EXPORTS one_or_more_exports1,  _,  _)) !  ( _,  ( _,  library_exports1left,  _)) !  rest671)
) => {  my  result = values::QQ_LIBRARY (\\  _ =  {  my  (one_or_more_exports as one_or_more_exports1) = one_or_more_exports1 ();
 my  (members as members1) = members1 ();
 (
    lga::make_main_library {
						 	path			=> libfile,
							exports     		=> one_or_more_exports,
							makelib_version_intlist	=> NULL,
							members,
							makelib_state,
							primordial_library
                                                    }
                                                
);
 } );
 ( lr_table::NONTERM 0,  ( result,  library_exports1left,  members1right),  rest671);
 } 
;  ( 3,  ( ( _,  ( values::FILE_STANDARD file_standard1,  (file_standardleft as file_standard1left),  (file_standardright as file_standard1right))) !  rest671)) => {  my  result = 
values::QQ_MAKELIB_VERSION_INTLIST (\\  _ =  {  my  (file_standard as file_standard1) = file_standard1 ();
 (
   lga::cm_version				# Here we're abusing FILE_STANDARD to match a version intlist string like "12.3.9"
						       (   file_standard,
						           report_error (  file_standardleft,
							                   file_standardright
                                                )      )   
);
 } );
 ( lr_table::NONTERM 1,  ( result,  file_standard1left,  file_standard1right),  rest671);
 } 
;  ( 4,  ( ( _,  ( values::QQ_EXPORT export1,  export1left,  export1right)) !  rest671)) => {  my  result = values::QQ_ONE_OR_MORE_EXPORTS (\\  _ =  {  my  (export as export1) = export1 ();
 (export)
;
 } );
 ( lr_table::NONTERM 2,  ( result,  export1left,  export1right),  rest671);
 } 
;  ( 5,  ( ( _,  ( values::QQ_EXPORT export1,  _,  export1right)) !  ( _,  ( values::QQ_ONE_OR_MORE_EXPORTS one_or_more_exports1,  one_or_more_exports1left,  _)) !  rest671)) => {  my  result = 
values::QQ_ONE_OR_MORE_EXPORTS (\\  _ =  {  my  (one_or_more_exports as one_or_more_exports1) = one_or_more_exports1 ();
 my  (export as export1) = export1 ();
 (
lga::union_of_exports_symbolsets (one_or_more_exports, export));
 } );
 ( lr_table::NONTERM 2,  ( result,  one_or_more_exports1left,  export1right),  rest671);
 } 
;  ( 6,  ( rest671)) => {  my  result = values::QQ_ZERO_OR_MORE_EXPORTS (\\  _ =  (lga::default_library_exports));
 ( lr_table::NONTERM 3,  ( result,  default_position,  default_position),  rest671)
;
 } 
;  ( 7,  ( ( _,  ( values::QQ_ONE_OR_MORE_EXPORTS one_or_more_exports1,  one_or_more_exports1left,  one_or_more_exports1right)) !  rest671)) => {  my  result = values::QQ_ZERO_OR_MORE_EXPORTS (\\  _
 =  {  my  (one_or_more_exports as one_or_more_exports1) = one_or_more_exports1 ();
 (one_or_more_exports);
 } );
 ( lr_table::NONTERM 3,  ( result,  one_or_more_exports1left,  
one_or_more_exports1right),  rest671);
 } 
;  ( 8,  ( rest671)) => {  my  result = values::QQ_EXPORTS (\\  _ =  (lga::empty_exports));
 ( lr_table::NONTERM 4,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 9,  ( ( _,  ( values::QQ_EXPORT export1,  _,  export1right)) !  ( _,  ( values::QQ_EXPORTS exports1,  exports1left,  _)) !  rest671)) => {  my  result = values::QQ_EXPORTS (\\  _ =  {  my  (
exports as exports1) = exports1 ();
 my  (export as export1) = export1 ();
 (lga::union_of_exports_symbolsets (exports, export));
 } );
 ( lr_table::NONTERM 4,  ( result,  exports1left,  export1right)
,  rest671);
 } 
;  ( 10,  ( ( _,  ( values::QQ_ML_SYMBOLSET ml_symbolset1,  ml_symbolset1left,  ml_symbolset1right)) !  rest671)) => {  my  result = values::QQ_EXPORT (\\  _ =  {  my  (ml_symbolset as ml_symbolset1)
 = ml_symbolset1 ();
 (ml_symbolset);
 } );
 ( lr_table::NONTERM 5,  ( result,  ml_symbolset1left,  ml_symbolset1right),  rest671);
 } 
;  ( 11,  ( ( _,  ( values::QQ_CONDITIONAL_EXPORTS conditional_exports1,  _,  conditional_exports1right)) !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_expleft,  bool_expright)) !  ( _,  ( _,  
if_t1left,  _)) !  rest671)) => {  my  result = values::QQ_EXPORT (\\  _ =  {  my  (bool_exp as bool_exp1) = bool_exp1 ();
 my  (conditional_exports as conditional_exports1) = conditional_exports1 ()
;
 (lga::conditional_exports
						  (bool_exp, conditional_exports, report_error (bool_expleft, bool_expright)));
 } );
 ( lr_table::NONTERM 5,  ( result,  if_t1left,  conditional_exports1right),  
rest671);
 } 
;  ( 12,  ( ( _,  ( values::ERRORX errorx1,  (errorxleft as errorx1left),  (errorxright as errorx1right))) !  rest671)) => {  my  result = values::QQ_EXPORT (\\  _ =  {  my  (errorx as errorx1) = 
errorx1 ();
 (lga::error_export (\\ () = report_error (errorxleft, errorxright) errorx));
 } );
 ( lr_table::NONTERM 5,  ( result,  errorx1left,  errorx1right),  rest671);
 } 
;  ( 13,  ( ( _,  ( _,  sublibrary_exports1left,  sublibrary_exports1right)) !  rest671)) => {  my  result = values::QQ_SUBLIB_OR_APIPKG_EXPORTS (\\  _ =  (lga::sublibrary_exported_symbols));
 ( 
lr_table::NONTERM 26,  ( result,  sublibrary_exports1left,  sublibrary_exports1right),  rest671);
 } 
;  ( 14,  ( ( _,  ( _,  api_or_pkg_exports1left,  api_or_pkg_exports1right)) !  rest671)) => {  my  result = values::QQ_SUBLIB_OR_APIPKG_EXPORTS (\\  _ =  (lga::api_or_pkg_exported_symbols));
 ( 
lr_table::NONTERM 26,  ( result,  api_or_pkg_exports1left,  api_or_pkg_exports1right),  rest671);
 } 
;  ( 15,  ( ( _,  ( values::QQ_ML_SYMBOL ml_symbol1,  (ml_symbolleft as ml_symbol1left),  (ml_symbolright as ml_symbol1right))) !  rest671)) => {  my  result = values::QQ_ML_SYMBOLSET (\\  _ =  {  my 
 (ml_symbol as ml_symbol1) = ml_symbol1 ();
 (lga::exports_symbolset_from_symbol
						     (ml_symbol,
						      report_error (ml_symbolleft,
							            ml_symbolright)));
 } );
 ( 
lr_table::NONTERM 15,  ( result,  ml_symbol1left,  ml_symbol1right),  rest671);
 } 
;  ( 16,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_EXPORTS exports1,  _,  _)) !  ( _,  ( _,  lparen1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOLSET (\\  _ =  {  my  (
exports as exports1) = exports1 ();
 (exports);
 } );
 ( lr_table::NONTERM 15,  ( result,  lparen1left,  rparen1right),  rest671);
 } 
;  ( 17,  ( ( _,  ( values::QQ_ML_SYMBOLSET ml_symbolset2,  _,  ml_symbolset2right)) !  _ !  ( _,  ( values::QQ_ML_SYMBOLSET ml_symbolset1,  ml_symbolset1left,  _)) !  rest671)) => {  my  result = 
values::QQ_ML_SYMBOLSET (\\  _ =  {  my  ml_symbolset1 = ml_symbolset1 ();
 my  ml_symbolset2 = ml_symbolset2 ();
 (
lga::intersection_of_exports_symbolsets
					             (ml_symbolset1,
					              ml_symbolset2));
 } );
 ( lr_table::NONTERM 15,  ( result,  ml_symbolset1left,  ml_symbolset2right),  
rest671);
 } 
;  ( 18,  ( ( _,  ( values::QQ_ML_SYMBOLSET ml_symbolset2,  _,  ml_symbolset2right)) !  _ !  ( _,  ( values::QQ_ML_SYMBOLSET ml_symbolset1,  ml_symbolset1left,  _)) !  rest671)) => {  my  result = 
values::QQ_ML_SYMBOLSET (\\  _ =  {  my  ml_symbolset1 = ml_symbolset1 ();
 my  ml_symbolset2 = ml_symbolset2 ();
 (
lga::difference_of_exports_symbolsets
					            (ml_symbolset1,
					             ml_symbolset2));
 } );
 ( lr_table::NONTERM 15,  ( result,  ml_symbolset1left,  ml_symbolset2right),  rest671)
;
 } 
;  ( 19,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_NULL_OR_SRCFILE null_or_srcfile1,  null_or_srcfileleft,  null_or_srcfileright)) !  _ !  ( _,  ( values::QQ_SUBLIB_OR_APIPKG_EXPORTS 
sublib_or_apipkg_exports1,  sublib_or_apipkg_exports1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOLSET (\\  _ =  {  my  (sublib_or_apipkg_exports as sublib_or_apipkg_exports1) = 
sublib_or_apipkg_exports1 ();
 my  (null_or_srcfile as null_or_srcfile1) = null_or_srcfile1 ();
 (
sublib_or_apipkg_exports						# lga::sublibrary_exported_symbols  or  lga::api_or_pkg_exported_symbols
					            (null_or_srcfile,
					             report_error (null_or_srcfileleft, null_or_srcfileright)
                                                )   
);
 } );
 ( lr_table::NONTERM 15,  ( result,  sublib_or_apipkg_exports1left,  rparen1right),  rest671);
 } 
;  ( 20,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_OPTTOOLOPTS opttoolopts1,  _,  _)) !  ( _,  ( values::QQ_PATHNAME pathname1,  pathnameleft,  pathnameright)) !  _ !  ( _,  ( _,  
library_exports1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOLSET (\\  _ =  {  my  (pathname as pathname1) = pathname1 ();
 my  (opttoolopts as opttoolopts1) = opttoolopts1 ();
 (
lga::export_freezefile
						   ( ad::file (pathname.make_path ()),
						     report_error (pathnameleft, pathnameright),
						     { hasoptions =>
							  not_null opttoolopts,
						       elab => \\ () =
							  make_member
							      (pathname,
							       pathnameleft,
							       pathnameright,
							       NULL,
							       opttoolopts),
						       this_library
                                                      }
                                                ) 
);
 } );
 ( lr_table::NONTERM 15,  ( result,  library_exports1left,  rparen1right),  rest671);
 } 
;  ( 21,  ( ( _,  ( values::QQ_ELSE_EXPORTS else_exports1,  _,  else_exports1right)) !  ( _,  ( values::QQ_EXPORTS exports1,  exports1left,  _)) !  rest671)) => {  my  result = 
values::QQ_CONDITIONAL_EXPORTS (\\  _ =  {  my  (exports as exports1) = exports1 ();
 my  (else_exports as else_exports1) = else_exports1 ();
 ((exports, else_exports));
 } );
 ( lr_table::NONTERM 6, 
 ( result,  exports1left,  else_exports1right),  rest671);
 } 
;  ( 22,  ( ( _,  ( _,  endif1left,  endif1right)) !  rest671)) => {  my  result = values::QQ_ELSE_EXPORTS (\\  _ =  (lga::empty_exports));
 ( lr_table::NONTERM 7,  ( result,  endif1left,  endif1right
),  rest671);
 } 
;  ( 23,  ( ( _,  ( _,  _,  endif1right)) !  ( _,  ( values::QQ_EXPORTS exports1,  _,  _)) !  ( _,  ( _,  else_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ELSE_EXPORTS (\\  _ =  {  my  (
exports as exports1) = exports1 ();
 (exports);
 } );
 ( lr_table::NONTERM 7,  ( result,  else_t1left,  endif1right),  rest671);
 } 
;  ( 24,  ( ( _,  ( values::QQ_CONDITIONAL_EXPORTS conditional_exports1,  _,  conditional_exports1right)) !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_expleft,  bool_expright)) !  ( _,  ( _,  
elif_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ELSE_EXPORTS (\\  _ =  {  my  (bool_exp as bool_exp1) = bool_exp1 ();
 my  (conditional_exports as conditional_exports1) = 
conditional_exports1 ();
 (lga::conditional_exports
						    (bool_exp, conditional_exports,
						     report_error (bool_expleft, bool_expright)));
 } );
 ( lr_table::NONTERM 7,  ( result,  
elif_t1left,  conditional_exports1right),  rest671);
 } 
;  ( 25,  ( rest671)) => {  my  result = values::QQ_MEMBERS (\\  _ =  (lga::empty_members));
 ( lr_table::NONTERM 8,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 26,  ( ( _,  ( values::QQ_MEMBERS members1,  _,  members1right)) !  ( _,  ( values::QQ_MEMBER member1,  member1left,  _)) !  rest671)) => {  my  result = values::QQ_MEMBERS (\\  _ =  {  my  (
member as member1) = member1 ();
 my  (members as members1) = members1 ();
 (lga::members (member, members));
 } );
 ( lr_table::NONTERM 8,  ( result,  member1left,  members1right),  rest671);
 } 
;  ( 27,  ( rest671)) => {  my  result = values::QQ_TOOLOPTS (\\  _ =  ([]));
 ( lr_table::NONTERM 21,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 28,  ( ( _,  ( values::QQ_TOOLOPTS toolopts1,  _,  toolopts1right)) !  ( _,  ( values::QQ_PATHNAME pathname1,  pathname1left,  _)) !  rest671)) => {  my  result = values::QQ_TOOLOPTS (\\  _ =  { 
 my  (pathname as pathname1) = pathname1 ();
 my  (toolopts as toolopts1) = toolopts1 ();
 (lga::string pathname ! toolopts);
 } );
 ( lr_table::NONTERM 21,  ( result,  pathname1left,  toolopts1right)
,  rest671);
 } 
;  ( 29,  ( ( _,  ( values::QQ_TOOLOPTS toolopts1,  _,  toolopts1right)) !  ( _,  ( values::QQ_PTOOLOPTS ptoolopts1,  _,  _)) !  _ !  ( _,  ( values::QQ_PATHNAME pathname1,  pathname1left,  _)) !  
rest671)) => {  my  result = values::QQ_TOOLOPTS (\\  _ =  {  my  (pathname as pathname1) = pathname1 ();
 my  (ptoolopts as ptoolopts1) = ptoolopts1 ();
 my  (toolopts as toolopts1) = toolopts1 ();

 (
lga::subopts
						     { name         =>  pathname.name,
						       tool_options =>  ptoolopts
                                                     }
						     ! toolopts
                                                
);
 } );
 ( lr_table::NONTERM 21,  ( result,  pathname1left,  toolopts1right),  rest671);
 } 
;  ( 30,  ( ( _,  ( values::QQ_TOOLOPTS toolopts1,  _,  toolopts1right)) !  ( _,  ( values::QQ_PATHNAME pathname2,  _,  _)) !  _ !  ( _,  ( values::QQ_PATHNAME pathname1,  pathname1left,  _)) !  
rest671)) => {  my  result = values::QQ_TOOLOPTS (\\  _ =  {  my  pathname1 = pathname1 ();
 my  pathname2 = pathname2 ();
 my  (toolopts as toolopts1) = toolopts1 ();
 (
lga::subopts
						     { name         =>  pathname1.name,
						       tool_options =>  [lga::string pathname2]
                                                     }
						 ! toolopts);
 } );
 ( 
lr_table::NONTERM 21,  ( result,  pathname1left,  toolopts1right),  rest671);
 } 
;  ( 31,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_TOOLOPTS toolopts1,  _,  _)) !  ( _,  ( _,  lparen1left,  _)) !  rest671)) => {  my  result = values::QQ_PTOOLOPTS (\\  _ =  {  my  (
toolopts as toolopts1) = toolopts1 ();
 (toolopts);
 } );
 ( lr_table::NONTERM 22,  ( result,  lparen1left,  rparen1right),  rest671);
 } 
;  ( 32,  ( rest671)) => {  my  result = values::QQ_OPTTOOLOPTS (\\  _ =  (NULL));
 ( lr_table::NONTERM 23,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 33,  ( ( _,  ( values::QQ_PTOOLOPTS ptoolopts1,  ptoolopts1left,  ptoolopts1right)) !  rest671)) => {  my  result = values::QQ_OPTTOOLOPTS (\\  _ =  {  my  (ptoolopts as ptoolopts1) = ptoolopts1
 ();
 (THE ptoolopts);
 } );
 ( lr_table::NONTERM 23,  ( result,  ptoolopts1left,  ptoolopts1right),  rest671);
 } 
;  ( 34,  ( rest671)) => {  my  result = values::QQ_NULL_OR_ILK_QUALIFIER (\\  _ =  (NULL));
 ( lr_table::NONTERM 20,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 35,  ( ( _,  ( values::QQ_ILK ilk1,  _,  ilk1right)) !  ( _,  ( _,  colon1left,  _)) !  rest671)) => {  my  result = values::QQ_NULL_OR_ILK_QUALIFIER (\\  _ =  {  my  (ilk as ilk1) = ilk1 ();
 (
THE ilk);
 } );
 ( lr_table::NONTERM 20,  ( result,  colon1left,  ilk1right),  rest671);
 } 
;  ( 36,  ( ( _,  ( values::QQ_OPTTOOLOPTS opttoolopts1,  _,  opttoolopts1right)) !  ( _,  ( values::QQ_NULL_OR_ILK_QUALIFIER null_or_ilk_qualifier1,  _,  _)) !  ( _,  ( values::QQ_PATHNAME pathname1
,  (pathnameleft as pathname1left),  pathnameright)) !  rest671)) => {  my  result = values::QQ_MEMBER (\\  _ =  {  my  (pathname as pathname1) = pathname1 ();
 my  (null_or_ilk_qualifier as 
null_or_ilk_qualifier1) = null_or_ilk_qualifier1 ();
 my  (opttoolopts as opttoolopts1) = opttoolopts1 ();
 (
make_member (pathname,
							   pathnameleft,
							   pathnameright,
							   null_or_ilk_qualifier,
							   opttoolopts));
 } );
 ( lr_table::NONTERM 9,  ( result,  pathname1left,  
opttoolopts1right),  rest671);
 } 
;  ( 37,  ( ( _,  ( values::QQ_GUARDED_MEMBERS guarded_members1,  _,  guarded_members1right)) !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_expleft,  bool_expright)) !  ( _,  ( _,  if_t1left,  _))
 !  rest671)) => {  my  result = values::QQ_MEMBER (\\  _ =  {  my  (bool_exp as bool_exp1) = bool_exp1 ();
 my  (guarded_members as guarded_members1) = guarded_members1 ();
 (
lga::guarded_members (bool_exp, guarded_members, report_error (bool_expleft, bool_expright)));
 } );
 ( lr_table::NONTERM 9,  ( result,  if_t1left,  guarded_members1right),  rest671);
 } 
;  ( 38,  ( ( _,  ( values::ERRORX errorx1,  (errorxleft as errorx1left),  (errorxright as errorx1right))) !  rest671)) => {  my  result = values::QQ_MEMBER (\\  _ =  {  my  (errorx as errorx1) = 
errorx1 ();
 (lga::error_member (\\ () =  report_error (errorxleft, errorxright) errorx));
 } );
 ( lr_table::NONTERM 9,  ( result,  errorx1left,  errorx1right),  rest671);
 } 
;  ( 39,  ( ( _,  ( values::QQ_WORD word1,  word1left,  word1right)) !  rest671)) => {  my  result = values::QQ_ILK (\\  _ =  {  my  (word as word1) = word1 ();
 (lga::ilk word);
 } );
 ( 
lr_table::NONTERM 19,  ( result,  word1left,  word1right),  rest671);
 } 
;  ( 40,  ( ( _,  ( values::QQ_ELSE_MEMBERS else_members1,  _,  else_members1right)) !  ( _,  ( values::QQ_MEMBERS members1,  members1left,  _)) !  rest671)) => {  my  result = 
values::QQ_GUARDED_MEMBERS (\\  _ =  {  my  (members as members1) = members1 ();
 my  (else_members as else_members1) = else_members1 ();
 ((members, else_members));
 } );
 ( lr_table::NONTERM 10,  ( 
result,  members1left,  else_members1right),  rest671);
 } 
;  ( 41,  ( ( _,  ( _,  endif1left,  endif1right)) !  rest671)) => {  my  result = values::QQ_ELSE_MEMBERS (\\  _ =  (lga::empty_members));
 ( lr_table::NONTERM 11,  ( result,  endif1left,  
endif1right),  rest671);
 } 
;  ( 42,  ( ( _,  ( _,  _,  endif1right)) !  ( _,  ( values::QQ_MEMBERS members1,  _,  _)) !  ( _,  ( _,  else_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ELSE_MEMBERS (\\  _ =  {  my  (
members as members1) = members1 ();
 (members);
 } );
 ( lr_table::NONTERM 11,  ( result,  else_t1left,  endif1right),  rest671);
 } 
;  ( 43,  ( ( _,  ( values::QQ_GUARDED_MEMBERS guarded_members1,  _,  guarded_members1right)) !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_expleft,  bool_expright)) !  ( _,  ( _,  elif_t1left,  _))
 !  rest671)) => {  my  result = values::QQ_ELSE_MEMBERS (\\  _ =  {  my  (bool_exp as bool_exp1) = bool_exp1 ();
 my  (guarded_members as guarded_members1) = guarded_members1 ();
 (
lga::guarded_members (bool_exp, guarded_members, report_error (bool_expleft, bool_expright)));
 } );
 ( lr_table::NONTERM 11,  ( result,  elif_t1left,  guarded_members1right),  rest671);
 } 
;  ( 44,  ( ( _,  ( values::FILE_STANDARD file_standard1,  file_standard1left,  file_standard1right)) !  rest671)) => {  my  result = values::QQ_WORD (\\  _ =  {  my  (file_standard as file_standard1)
 = file_standard1 ();
 (lga::cm_symbol file_standard);
 } );
 ( lr_table::NONTERM 18,  ( result,  file_standard1left,  file_standard1right),  rest671);
 } 
;  ( 45,  ( ( _,  ( values::MAKELIB_ID makelib_id1,  makelib_id1left,  makelib_id1right)) !  rest671)) => {  my  result = values::QQ_MAKELIB_ID (\\  _ =  {  my  (makelib_id as makelib_id1) = 
makelib_id1 ();
 (lga::cm_symbol makelib_id);
 } );
 ( lr_table::NONTERM 17,  ( result,  makelib_id1left,  makelib_id1right),  rest671);
 } 
;  ( 46,  ( ( _,  ( values::NUMBER number1,  number1left,  number1right)) !  rest671)) => {  my  result = values::QQ_INT_EXP (\\  _ =  {  my  (number as number1) = number1 ();
 (lga::number number)
;
 } );
 ( lr_table::NONTERM 12,  ( result,  number1left,  number1right),  rest671);
 } 
;  ( 47,  ( ( _,  ( values::QQ_MAKELIB_ID makelib_id1,  makelib_id1left,  makelib_id1right)) !  rest671)) => {  my  result = values::QQ_INT_EXP (\\  _ =  {  my  (makelib_id as makelib_id1) = 
makelib_id1 ();
 (lga::variable  makelib_state  makelib_id);
 } );
 ( lr_table::NONTERM 12,  ( result,  makelib_id1left,  makelib_id1right),  rest671);
 } 
;  ( 48,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_INT_EXP int_exp1,  _,  _)) !  ( _,  ( _,  lparen1left,  _)) !  rest671)) => {  my  result = values::QQ_INT_EXP (\\  _ =  {  my  (
int_exp as int_exp1) = int_exp1 ();
 (int_exp);
 } );
 ( lr_table::NONTERM 12,  ( result,  lparen1left,  rparen1right),  rest671);
 } 
;  ( 49,  ( ( _,  ( values::QQ_INT_EXP int_exp2,  _,  int_exp2right)) !  ( _,  ( values::ADDSYM addsym1,  _,  _)) !  ( _,  ( values::QQ_INT_EXP int_exp1,  int_exp1left,  _)) !  rest671)) => {  my  
result = values::QQ_INT_EXP (\\  _ =  {  my  int_exp1 = int_exp1 ();
 my  (addsym as addsym1) = addsym1 ();
 my  int_exp2 = int_exp2 ();
 (lga::add (int_exp1, addsym, int_exp2));
 } );
 ( 
lr_table::NONTERM 12,  ( result,  int_exp1left,  int_exp2right),  rest671);
 } 
;  ( 50,  ( ( _,  ( values::QQ_INT_EXP int_exp2,  _,  int_exp2right)) !  ( _,  ( values::MULSYM mulsym1,  _,  _)) !  ( _,  ( values::QQ_INT_EXP int_exp1,  int_exp1left,  _)) !  rest671)) => {  my  
result = values::QQ_INT_EXP (\\  _ =  {  my  int_exp1 = int_exp1 ();
 my  (mulsym as mulsym1) = mulsym1 ();
 my  int_exp2 = int_exp2 ();
 (lga::mul (int_exp1, mulsym, int_exp2));
 } );
 ( 
lr_table::NONTERM 12,  ( result,  int_exp1left,  int_exp2right),  rest671);
 } 
;  ( 51,  ( ( _,  ( values::QQ_INT_EXP int_exp1,  _,  int_exp1right)) !  ( _,  ( _,  tilde1left,  _)) !  rest671)) => {  my  result = values::QQ_INT_EXP (\\  _ =  {  my  (int_exp as int_exp1) = 
int_exp1 ();
 (lga::negate int_exp);
 } );
 ( lr_table::NONTERM 12,  ( result,  tilde1left,  int_exp1right),  rest671);
 } 
;  ( 52,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_ML_SYMBOL ml_symbol1,  _,  _)) !  _ !  ( _,  ( _,  defined1left,  _)) !  rest671)) => {  my  result = values::QQ_BOOL_EXP (\\  _ =  { 
 my  (ml_symbol as ml_symbol1) = ml_symbol1 ();
 (lga::ml_defined ml_symbol);
 } );
 ( lr_table::NONTERM 13,  ( result,  defined1left,  rparen1right),  rest671);
 } 
;  ( 53,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_MAKELIB_ID makelib_id1,  _,  _)) !  _ !  ( _,  ( _,  defined1left,  _)) !  rest671)) => {  my  result = values::QQ_BOOL_EXP (\\  _ = 
 {  my  (makelib_id as makelib_id1) = makelib_id1 ();
 (lga::is_defined_hostproperty makelib_state makelib_id);
 } );
 ( lr_table::NONTERM 13,  ( result,  defined1left,  rparen1right),  rest671);
 } 
;  ( 54,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  _,  _)) !  ( _,  ( _,  lparen1left,  _)) !  rest671)) => {  my  result = values::QQ_BOOL_EXP (\\  _ =  {  my  (
bool_exp as bool_exp1) = bool_exp1 ();
 (bool_exp);
 } );
 ( lr_table::NONTERM 13,  ( result,  lparen1left,  rparen1right),  rest671);
 } 
;  ( 55,  ( ( _,  ( values::QQ_BOOL_EXP bool_exp2,  _,  bool_exp2right)) !  _ !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_exp1left,  _)) !  rest671)) => {  my  result = values::QQ_BOOL_EXP (\\  _
 =  {  my  bool_exp1 = bool_exp1 ();
 my  bool_exp2 = bool_exp2 ();
 (lga::conj (bool_exp1,        bool_exp2));
 } );
 ( lr_table::NONTERM 13,  ( result,  bool_exp1left,  bool_exp2right),  rest671)
;
 } 
;  ( 56,  ( ( _,  ( values::QQ_BOOL_EXP bool_exp2,  _,  bool_exp2right)) !  _ !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_exp1left,  _)) !  rest671)) => {  my  result = values::QQ_BOOL_EXP (\\  _
 =  {  my  bool_exp1 = bool_exp1 ();
 my  bool_exp2 = bool_exp2 ();
 (lga::disj (bool_exp1,        bool_exp2));
 } );
 ( lr_table::NONTERM 13,  ( result,  bool_exp1left,  bool_exp2right),  rest671)
;
 } 
;  ( 57,  ( ( _,  ( values::QQ_BOOL_EXP bool_exp2,  _,  bool_exp2right)) !  ( _,  ( values::EQSYM eqsym1,  _,  _)) !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_exp1left,  _)) !  rest671)) => {  my 
 result = values::QQ_BOOL_EXP (\\  _ =  {  my  bool_exp1 = bool_exp1 ();
 my  (eqsym as eqsym1) = eqsym1 ();
 my  bool_exp2 = bool_exp2 ();
 (lga::beq  (bool_exp1, eqsym, bool_exp2));
 } );
 ( 
lr_table::NONTERM 13,  ( result,  bool_exp1left,  bool_exp2right),  rest671);
 } 
;  ( 58,  ( ( _,  ( values::QQ_BOOL_EXP bool_exp1,  _,  bool_exp1right)) !  ( _,  ( _,  not_t1left,  _)) !  rest671)) => {  my  result = values::QQ_BOOL_EXP (\\  _ =  {  my  (bool_exp as bool_exp1) = 
bool_exp1 ();
 (lga::not bool_exp);
 } );
 ( lr_table::NONTERM 13,  ( result,  not_t1left,  bool_exp1right),  rest671);
 } 
;  ( 59,  ( ( _,  ( values::QQ_INT_EXP int_exp2,  _,  int_exp2right)) !  ( _,  ( values::INEQSYM ineqsym1,  _,  _)) !  ( _,  ( values::QQ_INT_EXP int_exp1,  int_exp1left,  _)) !  rest671)) => {  my  
result = values::QQ_BOOL_EXP (\\  _ =  {  my  int_exp1 = int_exp1 ();
 my  (ineqsym as ineqsym1) = ineqsym1 ();
 my  int_exp2 = int_exp2 ();
 (lga::ineq (int_exp1, ineqsym, int_exp2));
 } );
 ( 
lr_table::NONTERM 13,  ( result,  int_exp1left,  int_exp2right),  rest671);
 } 
;  ( 60,  ( ( _,  ( values::QQ_INT_EXP int_exp2,  _,  int_exp2right)) !  ( _,  ( values::EQSYM eqsym1,  _,  _)) !  ( _,  ( values::QQ_INT_EXP int_exp1,  int_exp1left,  _)) !  rest671)) => {  my  
result = values::QQ_BOOL_EXP (\\  _ =  {  my  int_exp1 = int_exp1 ();
 my  (eqsym as eqsym1) = eqsym1 ();
 my  int_exp2 = int_exp2 ();
 (lga::eq   (int_exp1,   eqsym, int_exp2));
 } );
 ( 
lr_table::NONTERM 13,  ( result,  int_exp1left,  int_exp2right),  rest671);
 } 
;  ( 61,  ( ( _,  ( values::ML_ID ml_id1,  _,  ml_id1right)) !  ( _,  ( _,  pkg_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOL (\\  _ =  {  my  (ml_id as ml_id1) = ml_id1 ();
 (
lga::my_package ml_id);
 } );
 ( lr_table::NONTERM 14,  ( result,  pkg_t1left,  ml_id1right),  rest671);
 } 
;  ( 62,  ( ( _,  ( values::ML_ID ml_id1,  _,  ml_id1right)) !  ( _,  ( _,  api_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOL (\\  _ =  {  my  (ml_id as ml_id1) = ml_id1 ();
 (
lga::my_api ml_id);
 } );
 ( lr_table::NONTERM 14,  ( result,  api_t1left,  ml_id1right),  rest671);
 } 
;  ( 63,  ( ( _,  ( values::ML_ID ml_id1,  _,  ml_id1right)) !  ( _,  ( _,  generic_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOL (\\  _ =  {  my  (ml_id as ml_id1) = ml_id1 ();
 (
lga::my_g   ml_id);
 } );
 ( lr_table::NONTERM 14,  ( result,  generic_t1left,  ml_id1right),  rest671);
 } 
;  ( 64,  ( ( _,  ( values::ML_ID ml_id1,  _,  ml_id1right)) !  ( _,  ( _,  generic_api_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOL (\\  _ =  {  my  (ml_id as ml_id1) = ml_id1 ()
;
 (lga::my_generic_api    ml_id);
 } );
 ( lr_table::NONTERM 14,  ( result,  generic_api_t1left,  ml_id1right),  rest671);
 } 
;  ( 65,  ( ( _,  ( values::FILE_STANDARD file_standard1,  (file_standardleft as file_standard1left),  (file_standardright as file_standard1right))) !  rest671)) => {  my  result = values::QQ_PATHNAME
 (\\  _ =  {  my  (file_standard as file_standard1) = file_standard1 ();
 (
 { name   => file_standard,
						   make_path => \\ () =  lga::file_standard
                                                                         makelib_state
									   ( file_standard,
									     path_root,
                                                                             report_error (file_standardleft, file_standardright)
                                                                           )
                                                 }
                                                
);
 } );
 ( lr_table::NONTERM 16,  ( result,  file_standard1left,  file_standard1right),  rest671);
 } 
;  ( 66,  ( ( _,  ( values::FILE_NATIVE file_native1,  (file_nativeleft as file_native1left),  (file_nativeright as file_native1right))) !  rest671)) => {  my  result = values::QQ_PATHNAME (\\  _ = 
 {  my  (file_native as file_native1) = file_native1 ();
 (
 { name
                                                        =>
                                                        file_native,

						    make_path
                                                        =>
                                                        \\ ()
                                                            =
                                                            lga::file_native
								( file_native,
								  path_root,
								  report_error
								  (file_nativeleft, file_nativeright)
								)
                                                 }
                                                
);
 } );
 ( lr_table::NONTERM 16,  ( result,  file_native1left,  file_native1right),  rest671);
 } 
;  ( 67,  ( ( _,  ( values::QQ_PATHNAME pathname1,  pathname1left,  pathname1right)) !  rest671)) => {  my  result = values::QQ_SRCFILE (\\  _ =  {  my  (pathname as pathname1) = pathname1 ();
 (
ad::file
						     (pathname.make_path ()));
 } );
 ( lr_table::NONTERM 24,  ( result,  pathname1left,  pathname1right),  rest671);
 } 
;  ( 68,  ( ( _,  ( values::QQ_SRCFILE srcfile1,  srcfile1left,  srcfile1right)) !  rest671)) => {  my  result = values::QQ_NULL_OR_SRCFILE (\\  _ =  {  my  (srcfile as srcfile1) = srcfile1 ();
 (
THE srcfile);
 } );
 ( lr_table::NONTERM 25,  ( result,  srcfile1left,  srcfile1right),  rest671);
 } 
;  ( 69,  ( ( _,  ( _,  dash1left,  dash1right)) !  rest671)) => {  my  result = values::QQ_NULL_OR_SRCFILE (\\  _ =  (NULL));
 ( lr_table::NONTERM 25,  ( result,  dash1left,  dash1right),  rest671)
;
 } 
; _ => raise exception (MLY_ACTION i392);
esac;
end;
void = values::TM_VOID;
extract = \\ a = (\\ values::QQ_LIBRARY x => x;
 _ => { exception PARSE_INTERNAL;
	 raise exception PARSE_INTERNAL; }; end ) a ();
};
};
package tokens : (weak) Libfile_Tokens {
Semantic_Value = parser_data::Semantic_Value;
Token (X,Y) = token::Token(X,Y);
fun eof (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 0, (parser_data::values::TM_VOID, p1, p2));
fun file_standard (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 1, (parser_data::values::FILE_STANDARD (\\ () = i), p1, p2));
fun file_native (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 2, (parser_data::values::FILE_NATIVE (\\ () = i), p1, p2));
fun makelib_id (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 3, (parser_data::values::MAKELIB_ID (\\ () = i), p1, p2));
fun ml_id (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 4, (parser_data::values::ML_ID (\\ () = i), p1, p2));
fun number (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 5, (parser_data::values::NUMBER (\\ () = i), p1, p2));
fun sublibrary_exports (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 6, (parser_data::values::TM_VOID, p1, p2));
fun library_exports (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 7, (parser_data::values::TM_VOID, p1, p2));
fun library_components (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 8, (parser_data::values::TM_VOID, p1, p2));
fun lparen (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 9, (parser_data::values::TM_VOID, p1, p2));
fun rparen (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 10, (parser_data::values::TM_VOID, p1, p2));
fun colon (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 11, (parser_data::values::TM_VOID, p1, p2));
fun if_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 12, (parser_data::values::TM_VOID, p1, p2));
fun elif_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 13, (parser_data::values::TM_VOID, p1, p2));
fun else_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 14, (parser_data::values::TM_VOID, p1, p2));
fun endif (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 15, (parser_data::values::TM_VOID, p1, p2));
fun errorx (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 16, (parser_data::values::ERRORX (\\ () = i), p1, p2));
fun pkg_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 17, (parser_data::values::TM_VOID, p1, p2));
fun api_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 18, (parser_data::values::TM_VOID, p1, p2));
fun generic_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 19, (parser_data::values::TM_VOID, p1, p2));
fun generic_api_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 20, (parser_data::values::TM_VOID, p1, p2));
fun defined (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 21, (parser_data::values::TM_VOID, p1, p2));
fun addsym (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 22, (parser_data::values::ADDSYM (\\ () = i), p1, p2));
fun mulsym (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 23, (parser_data::values::MULSYM (\\ () = i), p1, p2));
fun eqsym (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 24, (parser_data::values::EQSYM (\\ () = i), p1, p2));
fun ineqsym (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 25, (parser_data::values::INEQSYM (\\ () = i), p1, p2));
fun tilde (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 26, (parser_data::values::TM_VOID, p1, p2));
fun and_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 27, (parser_data::values::TM_VOID, p1, p2));
fun or_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 28, (parser_data::values::TM_VOID, p1, p2));
fun not_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 29, (parser_data::values::TM_VOID, p1, p2));
fun star (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 30, (parser_data::values::TM_VOID, p1, p2));
fun dash (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 31, (parser_data::values::TM_VOID, p1, p2));
fun api_or_pkg_exports (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 32, (parser_data::values::TM_VOID, p1, p2));
};
};
