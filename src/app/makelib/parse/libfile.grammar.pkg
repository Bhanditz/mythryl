generic package libfile_lr_vals_fun(package token:  Token;)
 : (weak) api { package parser_data : Parser_Data;
       package tokens : Libfile_Tokens;
   }
 { 
package parser_data{
package header { 
## libfile.grammar
## (C) 1999, 2001 Lucent Technologies, Bell Laboratories
## Author: Matthias Blume (blume@research.bell-labs.com)



# Mythryl-Yacc grammar for .lib library-definition files


package ad  =  anchor_dictionary;			# anchor_dictionary			is from   src/app/makelib/paths/anchor-dictionary.pkg
package lga =  libfile_grammar_actions;			# libfile_grammar_actions		is from   src/app/makelib/parse/libfile-grammar-actions.pkg
package lg  =  inter_library_dependency_graph;		# inter_library_dependency_graph	is from   src/app/makelib/depend/inter-library-dependency-graph.pkg
package mvi =  makelib_version_intlist;			# makelib_version_intlist		is from   src/app/makelib/stuff/makelib-version-intlist.pkg
package pmt =  private_makelib_tools;			# private_makelib_tools			is from   src/app/makelib/tools/main/private-makelib-tools.pkg
package sy  =  symbol;					# symbol				is from   src/lib/compiler/front/basics/map/symbol.pkg


};
package lr_table = token::lr_table;
package token = token;
stipulate include lr_table; herein 
my table={   action_rows =
"\
\\001\000\001\000\000\000\000\000\
\\001\000\002\000\194\000\003\000\194\000\007\000\194\000\008\000\194\000\
\\010\000\194\000\011\000\194\000\013\000\194\000\014\000\194\000\
\\015\000\194\000\016\000\194\000\017\000\194\000\018\000\194\000\
\\019\000\194\000\020\000\194\000\021\000\194\000\028\000\194\000\
\\029\000\194\000\033\000\194\000\000\000\
\\001\000\002\000\051\000\003\000\050\000\000\000\
\\001\000\002\000\051\000\003\000\050\000\010\000\103\000\000\000\
\\001\000\002\000\051\000\003\000\050\000\032\000\049\000\000\000\
\\001\000\002\000\107\000\000\000\
\\001\000\004\000\040\000\006\000\039\000\010\000\038\000\022\000\037\000\
\\027\000\036\000\030\000\035\000\000\000\
\\001\000\004\000\040\000\006\000\039\000\010\000\070\000\027\000\036\000\000\000\
\\001\000\004\000\040\000\018\000\014\000\019\000\013\000\020\000\012\000\
\\021\000\011\000\000\000\
\\001\000\005\000\028\000\000\000\
\\001\000\005\000\029\000\000\000\
\\001\000\005\000\030\000\000\000\
\\001\000\005\000\031\000\000\000\
\\001\000\007\000\004\000\008\000\003\000\000\000\
\\001\000\007\000\019\000\008\000\018\000\009\000\027\000\010\000\022\000\
\\013\000\016\000\017\000\015\000\018\000\014\000\019\000\013\000\
\\020\000\012\000\021\000\011\000\033\000\010\000\000\000\
\\001\000\007\000\019\000\008\000\018\000\009\000\114\000\010\000\022\000\
\\013\000\016\000\017\000\015\000\018\000\014\000\019\000\013\000\
\\020\000\012\000\021\000\011\000\033\000\010\000\000\000\
\\001\000\007\000\019\000\008\000\018\000\010\000\017\000\013\000\016\000\
\\017\000\015\000\018\000\014\000\019\000\013\000\020\000\012\000\
\\021\000\011\000\033\000\010\000\000\000\
\\001\000\007\000\019\000\008\000\018\000\010\000\022\000\011\000\075\000\
\\013\000\016\000\017\000\015\000\018\000\014\000\019\000\013\000\
\\020\000\012\000\021\000\011\000\033\000\010\000\000\000\
\\001\000\007\000\019\000\008\000\018\000\010\000\022\000\013\000\016\000\
\\014\000\087\000\015\000\086\000\016\000\085\000\017\000\015\000\
\\018\000\014\000\019\000\013\000\020\000\012\000\021\000\011\000\
\\033\000\010\000\000\000\
\\001\000\007\000\019\000\008\000\018\000\010\000\022\000\013\000\016\000\
\\016\000\122\000\017\000\015\000\018\000\014\000\019\000\013\000\
\\020\000\012\000\021\000\011\000\033\000\010\000\000\000\
\\001\000\007\000\019\000\008\000\018\000\010\000\022\000\013\000\016\000\
\\017\000\015\000\018\000\014\000\019\000\013\000\020\000\012\000\
\\021\000\011\000\033\000\010\000\000\000\
\\001\000\007\000\019\000\008\000\018\000\010\000\022\000\018\000\014\000\
\\019\000\013\000\020\000\012\000\021\000\011\000\033\000\010\000\000\000\
\\001\000\009\000\045\000\000\000\
\\001\000\010\000\023\000\000\000\
\\001\000\010\000\044\000\000\000\
\\001\000\010\000\071\000\000\000\
\\001\000\011\000\076\000\000\000\
\\001\000\011\000\079\000\000\000\
\\001\000\011\000\098\000\025\000\063\000\028\000\062\000\029\000\061\000\000\000\
\\001\000\011\000\099\000\023\000\067\000\024\000\066\000\000\000\
\\001\000\011\000\099\000\023\000\067\000\024\000\066\000\025\000\065\000\
\\026\000\064\000\000\000\
\\001\000\011\000\112\000\000\000\
\\001\000\011\000\113\000\000\000\
\\001\000\011\000\115\000\000\000\
\\001\000\011\000\125\000\000\000\
\\001\000\014\000\121\000\015\000\120\000\016\000\119\000\000\000\
\\001\000\016\000\132\000\000\000\
\\001\000\023\000\067\000\024\000\066\000\025\000\065\000\026\000\064\000\000\000\
\\137\000\000\000\
\\138\000\000\000\
\\139\000\000\000\
\\140\000\000\000\
\\141\000\000\000\
\\142\000\000\000\
\\143\000\007\000\019\000\008\000\018\000\010\000\022\000\013\000\016\000\
\\017\000\015\000\018\000\014\000\019\000\013\000\020\000\012\000\
\\021\000\011\000\033\000\010\000\000\000\
\\144\000\007\000\019\000\008\000\018\000\010\000\022\000\013\000\016\000\
\\017\000\015\000\018\000\014\000\019\000\013\000\020\000\012\000\
\\021\000\011\000\033\000\010\000\000\000\
\\145\000\000\000\
\\145\000\002\000\043\000\000\000\
\\145\000\025\000\063\000\028\000\062\000\029\000\061\000\000\000\
\\146\000\000\000\
\\147\000\031\000\025\000\032\000\024\000\000\000\
\\148\000\000\000\
\\149\000\000\000\
\\150\000\000\000\
\\151\000\000\000\
\\152\000\000\000\
\\153\000\000\000\
\\154\000\000\000\
\\155\000\031\000\025\000\000\000\
\\156\000\000\000\
\\157\000\000\000\
\\158\000\000\000\
\\159\000\000\000\
\\160\000\000\000\
\\161\000\000\000\
\\162\000\002\000\051\000\003\000\050\000\013\000\058\000\017\000\057\000\000\000\
\\162\000\002\000\051\000\003\000\050\000\013\000\058\000\017\000\057\000\
\\025\000\063\000\028\000\062\000\029\000\061\000\000\000\
\\163\000\000\000\
\\164\000\002\000\051\000\003\000\050\000\000\000\
\\164\000\002\000\051\000\003\000\050\000\012\000\127\000\000\000\
\\165\000\000\000\
\\166\000\000\000\
\\167\000\000\000\
\\168\000\000\000\
\\169\000\010\000\103\000\000\000\
\\170\000\000\000\
\\171\000\012\000\081\000\000\000\
\\172\000\000\000\
\\173\000\000\000\
\\174\000\000\000\
\\175\000\000\000\
\\176\000\000\000\
\\177\000\000\000\
\\178\000\000\000\
\\179\000\000\000\
\\180\000\000\000\
\\181\000\000\000\
\\182\000\000\000\
\\183\000\000\000\
\\184\000\000\000\
\\185\000\000\000\
\\186\000\024\000\066\000\000\000\
\\187\000\000\000\
\\188\000\000\000\
\\189\000\000\000\
\\190\000\000\000\
\\191\000\000\000\
\\192\000\025\000\063\000\000\000\
\\193\000\025\000\063\000\028\000\062\000\000\000\
\\195\000\000\000\
\\196\000\023\000\067\000\024\000\066\000\000\000\
\\197\000\023\000\067\000\024\000\066\000\000\000\
\\198\000\000\000\
\\199\000\000\000\
\\200\000\000\000\
\\201\000\000\000\
\\202\000\000\000\
\\203\000\000\000\
\\204\000\000\000\
\\205\000\000\000\
\\206\000\000\000\
\";
    action_row_numbers =
"\013\000\016\000\044\000\023\000\
\\050\000\055\000\042\000\014\000\
\\054\000\009\000\010\000\011\000\
\\012\000\052\000\006\000\047\000\
\\024\000\053\000\022\000\045\000\
\\046\000\004\000\021\000\021\000\
\\043\000\065\000\105\000\104\000\
\\103\000\102\000\089\000\048\000\
\\037\000\006\000\007\000\025\000\
\\006\000\088\000\087\000\017\000\
\\026\000\041\000\002\000\065\000\
\\027\000\109\000\108\000\110\000\
\\107\000\106\000\058\000\057\000\
\\076\000\065\000\040\000\080\000\
\\006\000\051\000\018\000\006\000\
\\006\000\006\000\007\000\007\000\
\\007\000\007\000\099\000\093\000\
\\007\000\008\000\028\000\030\000\
\\049\000\056\000\020\000\074\000\
\\038\000\059\000\074\000\005\000\
\\067\000\066\000\061\000\062\000\
\\046\000\006\000\098\000\097\000\
\\001\000\100\000\101\000\092\000\
\\091\000\029\000\031\000\032\000\
\\096\000\090\000\015\000\033\000\
\\075\000\068\000\078\000\077\000\
\\081\000\086\000\079\000\035\000\
\\019\000\048\000\095\000\094\000\
\\065\000\060\000\034\000\069\000\
\\082\000\083\000\065\000\006\000\
\\063\000\064\000\039\000\073\000\
\\070\000\003\000\036\000\066\000\
\\068\000\068\000\084\000\085\000\
\\071\000\072\000\000\000";
   goto_table =
"\
\\001\000\134\000\000\000\
\\003\000\007\000\006\000\006\000\015\000\005\000\016\000\004\000\
\\027\000\003\000\000\000\
\\003\000\019\000\004\000\018\000\006\000\006\000\015\000\005\000\
\\016\000\004\000\027\000\003\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\024\000\015\000\005\000\016\000\004\000\027\000\003\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\013\000\032\000\014\000\031\000\018\000\030\000\000\000\
\\002\000\040\000\005\000\039\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\024\000\015\000\005\000\016\000\004\000\027\000\003\000\000\000\
\\005\000\039\000\000\000\
\\017\000\046\000\025\000\045\000\026\000\044\000\000\000\
\\015\000\005\000\016\000\050\000\027\000\003\000\000\000\
\\015\000\005\000\016\000\051\000\027\000\003\000\000\000\
\\000\000\
\\009\000\054\000\010\000\053\000\017\000\052\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\005\000\058\000\007\000\057\000\000\000\
\\000\000\
\\013\000\032\000\014\000\066\000\018\000\030\000\000\000\
\\013\000\067\000\018\000\030\000\000\000\
\\000\000\
\\013\000\071\000\014\000\070\000\018\000\030\000\000\000\
\\000\000\
\\000\000\
\\006\000\072\000\015\000\005\000\016\000\004\000\027\000\003\000\000\000\
\\000\000\
\\000\000\
\\017\000\075\000\000\000\
\\009\000\076\000\010\000\053\000\017\000\052\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\021\000\078\000\000\000\
\\009\000\080\000\010\000\053\000\017\000\052\000\000\000\
\\000\000\
\\000\000\
\\013\000\032\000\014\000\081\000\018\000\030\000\000\000\
\\000\000\
\\006\000\072\000\008\000\082\000\015\000\005\000\016\000\004\000\
\\027\000\003\000\000\000\
\\013\000\032\000\014\000\086\000\018\000\030\000\000\000\
\\013\000\032\000\014\000\087\000\018\000\030\000\000\000\
\\013\000\032\000\014\000\088\000\018\000\030\000\000\000\
\\013\000\089\000\018\000\030\000\000\000\
\\013\000\090\000\018\000\030\000\000\000\
\\013\000\091\000\018\000\030\000\000\000\
\\013\000\092\000\018\000\030\000\000\000\
\\000\000\
\\000\000\
\\013\000\093\000\018\000\030\000\000\000\
\\015\000\095\000\018\000\094\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\098\000\006\000\006\000\015\000\005\000\016\000\004\000\
\\027\000\003\000\000\000\
\\023\000\100\000\024\000\099\000\000\000\
\\000\000\
\\000\000\
\\023\000\100\000\024\000\102\000\000\000\
\\019\000\104\000\020\000\103\000\000\000\
\\000\000\
\\009\000\107\000\010\000\053\000\011\000\106\000\017\000\052\000\000\000\
\\000\000\
\\000\000\
\\005\000\108\000\000\000\
\\013\000\032\000\014\000\109\000\018\000\030\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\024\000\015\000\005\000\016\000\004\000\027\000\003\000\000\000\
\\000\000\
\\000\000\
\\017\000\115\000\022\000\114\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\012\000\116\000\000\000\
\\006\000\072\000\015\000\005\000\016\000\004\000\027\000\003\000\000\000\
\\005\000\058\000\007\000\121\000\000\000\
\\000\000\
\\000\000\
\\009\000\122\000\010\000\053\000\017\000\052\000\000\000\
\\000\000\
\\000\000\
\\017\000\115\000\022\000\124\000\000\000\
\\000\000\
\\000\000\
\\009\000\126\000\010\000\053\000\017\000\052\000\000\000\
\\013\000\032\000\014\000\127\000\018\000\030\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\017\000\129\000\023\000\128\000\000\000\
\\000\000\
\\009\000\107\000\010\000\053\000\011\000\131\000\017\000\052\000\000\000\
\\017\000\115\000\022\000\132\000\000\000\
\\017\000\115\000\022\000\133\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\";
   numstates = 135;
   numrules = 70;
 s = REF "";  index = REF 0;
    string_to_int = fn () = 
    {    i = *index;
         index := i+2;
         char::to_int (string::get(*s, i)) + char::to_int (string::get(*s, i+1)) * 256;
    };

    string_to_list = fn s' =
    {   len = string::length s';
        fun f () =
           if (*index < len)
           string_to_int() ! f();
           else NIL; fi;
        index := 0;
        s := s';
        f ();
   };

   string_to_pairlist =   fn (conv_key, conv_entry) =   f
   where 
         fun f ()
             =
             case (string_to_int ())
                 0 => EMPTY;
                 n => PAIR (conv_key (n - 1), conv_entry (string_to_int()), f());
             esac;
   end;

   string_to_pairlist_default =   fn (conv_key, conv_entry) =
    {   conv_row = string_to_pairlist (conv_key, conv_entry);
       fn () =
       {   default = conv_entry (string_to_int());
           row = conv_row();
          (row, default);
       };
   };

    string_to_table = fn (convert_row, s') =
    {   len = string::length s';
        fun f ()
            =
           if (*index < len)
              convert_row() ! f();
           else NIL; fi;
        s := s';
        index := 0;
        f ();
     };

stipulate
  memo = rw_vector::make_rw_vector (numstates+numrules, ERROR);
  my _ ={   fun g i
                =
                {   rw_vector::set (memo, i, REDUCE (i-numstates));
                    g (i+1);
                };

            fun f i
                =
                if   (i == numstates)
                     g i;
                else    rw_vector::set (memo, i, SHIFT (STATE i));
                         f (i+1);
                fi;

            f 0
            except
                (SUBSCRIPT|INDEX_OUT_OF_BOUNDS) =  ();
        };
herein
    entry_to_action
        =
        fn 0 =>  ACCEPT;
           1 =>  ERROR;
           j =>  rw_vector::get (memo, (j - 2));
        end;
end;

   goto_table = rw_vector::from_list (string_to_table (string_to_pairlist (NONTERM, STATE), goto_table));
   action_rows = string_to_table (string_to_pairlist_default (TERM, entry_to_action), action_rows);
   action_row_numbers = string_to_list action_row_numbers;
   action_table
    =
    {   action_row_lookup
            =
            {   a=rw_vector::from_list (action_rows);

                fn i =   rw_vector::get (a, i);
            };

        rw_vector::from_list (map action_row_lookup action_row_numbers);
    };

    lr_table::make_lr_table {
        actions => action_table,
        gotos   => goto_table,
        rule_count   => numrules,
        state_count  => numstates,
        initial_state => STATE 0   };
};
end;
stipulate include header; herein
Source_Position = Int;
Arg = { libfile: ad::File, path_root: ad::Path_Root, complain_about_obsolete_syntax: (Source_Position, Source_Position) -> Void, report_error: (Source_Position, Source_Position) -> String -> Void, make_member: ( { name: String,
		      make_path: Void -> ad::Dir_Path
		    },
		    Source_Position,
		    Source_Position,
		    Null_Or lga::Cm_Ilk,
		    Null_Or List lga::Tool_Option
		  ) -> lga::Members, this_library: Null_Or ad::File , makelib_state: makelib_state::Makelib_State, primordial_library: lg::Library };
package values { 
Semantic_Value = TM_VOID | NT_VOID  Void -> Void | INEQSYM Void ->  (libfile_grammar_actions::Ineqsym) | EQSYM Void ->  (libfile_grammar_actions::Eqsym)
 | MULSYM Void ->  (libfile_grammar_actions::Mulsym) | ADDSYM Void ->  (libfile_grammar_actions::Addsym) | ERRORX Void ->  (String) | NUMBER Void ->  (Int) | ML_ID Void ->  (String)
 | MAKELIB_ID Void ->  (String) | FILE_NATIVE Void ->  (String) | FILE_STANDARD Void ->  (String)
 | QQ_SUBLIB_OR_APIPKG_EXPORTS Void ->  ((Null_Or ad::File, lga::Plaint_Sink) -> lga::Exports_Symbolset) | QQ_NULL_OR_SRCFILE Void ->  (Null_Or ad::File ) | QQ_SRCFILE Void ->  (ad::File)
 | QQ_OPTTOOLOPTS Void ->  (Null_Or List lga::Tool_Option  ) | QQ_PTOOLOPTS Void ->  (List lga::Tool_Option ) | QQ_TOOLOPTS Void ->  (List lga::Tool_Option )
 | QQ_NULL_OR_ILK_QUALIFIER Void ->  (Null_Or lga::Cm_Ilk ) | QQ_ILK Void ->  (lga::Cm_Ilk) | QQ_WORD Void ->  (lga::Cm_Symbol) | QQ_MAKELIB_ID Void ->  (lga::Cm_Symbol)
 | QQ_PATHNAME Void ->  ({ name: String, make_path: Void -> ad::Dir_Path }) | QQ_ML_SYMBOLSET Void ->  (lga::Exports_Symbolset) | QQ_ML_SYMBOL Void ->  (sy::Symbol)
 | QQ_BOOL_EXP Void ->  (lga::Bool_Expression) | QQ_INT_EXP Void ->  (lga::Int_Expression) | QQ_ELSE_MEMBERS Void ->  (lga::Members) | QQ_GUARDED_MEMBERS Void ->  ((lga::Members, lga::Members))
 | QQ_MEMBER Void ->  (lga::Members) | QQ_MEMBERS Void ->  (lga::Members) | QQ_ELSE_EXPORTS Void ->  (lga::Exports_Symbolset)
 | QQ_CONDITIONAL_EXPORTS Void ->  ((lga::Exports_Symbolset, lga::Exports_Symbolset)) | QQ_EXPORT Void ->  (lga::Exports_Symbolset) | QQ_EXPORTS Void ->  (lga::Exports_Symbolset)
 | QQ_ZERO_OR_MORE_EXPORTS Void ->  (lga::Exports_Symbolset) | QQ_ONE_OR_MORE_EXPORTS Void ->  (lga::Exports_Symbolset) | QQ_MAKELIB_VERSION_INTLIST Void ->  (mvi::Makelib_Version_Intlist)
 | QQ_LIBRARY Void ->  (lg::Library);
};
Semantic_Value = values::Semantic_Value;
Result = lg::Library;
end;
package error_recovery{
include lr_table;
infix my 60 @@;
fun x @@ y = y ! x;
is_keyword =
fn (TERM 6) => TRUE; (TERM 7) => TRUE; (TERM 8) => TRUE; (TERM 12) => TRUE; (TERM 13) => TRUE; (TERM 14) => TRUE; (TERM 15) => TRUE; (TERM 21) => TRUE; (TERM 17) => TRUE; (TERM 18) => TRUE; (TERM 19)
 => TRUE; (TERM 20) => TRUE; _ => FALSE; end;
my preferred_change:   List( (List( Terminal ), List( Terminal )) ) = 
(NIL
, NIL
 @@ (TERM 9)) ! 
NIL;
no_shift = 
fn (TERM 0) => TRUE; _ => FALSE; end;
show_terminal =
fn (TERM 0) => "EOF"
; (TERM 1) => "FILE_STANDARD"
; (TERM 2) => "FILE_NATIVE"
; (TERM 3) => "MAKELIB_ID"
; (TERM 4) => "ML_ID"
; (TERM 5) => "NUMBER"
; (TERM 6) => "SUBLIBRARY_EXPORTS"
; (TERM 7) => "LIBRARY_EXPORTS"
; (TERM 8) => "LIBRARY_COMPONENTS"
; (TERM 9) => "LPAREN"
; (TERM 10) => "RPAREN"
; (TERM 11) => "COLON"
; (TERM 12) => "IF_T"
; (TERM 13) => "ELIF_T"
; (TERM 14) => "ELSE_T"
; (TERM 15) => "ENDIF"
; (TERM 16) => "ERRORX"
; (TERM 17) => "PKG_T"
; (TERM 18) => "API_T"
; (TERM 19) => "GENERIC_T"
; (TERM 20) => "GENERIC_API_T"
; (TERM 21) => "DEFINED"
; (TERM 22) => "ADDSYM"
; (TERM 23) => "MULSYM"
; (TERM 24) => "EQSYM"
; (TERM 25) => "INEQSYM"
; (TERM 26) => "TILDE"
; (TERM 27) => "AND_T"
; (TERM 28) => "OR_T"
; (TERM 29) => "NOT_T"
; (TERM 30) => "STAR"
; (TERM 31) => "DASH"
; (TERM 32) => "API_OR_PKG_EXPORTS"
; _ => "bogus-term"; end;
stipulate include header; herein
errtermvalue=
fn _ => values::TM_VOID;
 end; end;
my terms:  List( Terminal ) = NIL
 @@ (TERM 32) @@ (TERM 31) @@ (TERM 30) @@ (TERM 29) @@ (TERM 28) @@ (TERM 27) @@ (TERM 26) @@ (TERM 21) @@ (TERM 20) @@ (TERM 19) @@ (TERM 18) @@ (TERM 17) @@ (TERM 15) @@ (TERM 14) @@ (TERM 13) @@ 
(TERM 12) @@ (TERM 11) @@ (TERM 10) @@ (TERM 9) @@ (TERM 8) @@ (TERM 7) @@ (TERM 6) @@ (TERM 0);
};
package actions {
exception MLY_ACTION Int;
stipulate include header; herein
actions = 
fn (i392, default_position, stack, 
    ( { libfile, path_root, complain_about_obsolete_syntax, report_error, make_member, this_library, makelib_state, primordial_library }): Arg) = 
case (i392, stack)
  ( 0,  ( ( _,  ( values::QQ_MEMBERS members1,  _,  members1right)) !  _ !  ( _,  ( values::QQ_ZERO_OR_MORE_EXPORTS zero_or_more_exports1,  _,  _)) !  ( _,  ( _,  sublibrary_exports1left,  _)) !  
rest671)) => {  my  result = values::QQ_LIBRARY (fn  _ =  {  my  (zero_or_more_exports as zero_or_more_exports1) = zero_or_more_exports1 ();
 my  (members as members1) = members1 ();
 (
   lga::make_sublibrary {
							path         => libfile,
							exports      => zero_or_more_exports,
							members,
							makelib_state,
							this_library,
							primordial_library
                                                    }
                                                
);
 } );
 ( lr_table::NONTERM 0,  ( result,  sublibrary_exports1left,  members1right),  rest671);
 } 
;  ( 1,  ( ( _,  ( values::QQ_MEMBERS members1,  _,  members1right)) !  _ !  ( _,  ( values::QQ_ONE_OR_MORE_EXPORTS one_or_more_exports1,  _,  _)) !  _ !  ( _,  ( values::QQ_MAKELIB_VERSION_INTLIST 
makelib_version_intlist1,  _,  _)) !  _ !  ( _,  ( _,  library_exports1left,  _)) !  rest671)) => {  my  result = values::QQ_LIBRARY (fn  _ =  {  my  (makelib_version_intlist as 
makelib_version_intlist1) = makelib_version_intlist1 ();
 my  (one_or_more_exports as one_or_more_exports1) = one_or_more_exports1 ();
 my  (members as members1) = members1 ();
 (
   lga::make_main_library {
							path			=>  libfile,
							exports     		=>  one_or_more_exports,
							makelib_version_intlist =>  THE makelib_version_intlist,
							members,
							makelib_state,
							primordial_library
                                                    }
                                                
);
 } );
 ( lr_table::NONTERM 0,  ( result,  library_exports1left,  members1right),  rest671);
 } 
;  ( 2,  ( ( _,  ( values::QQ_MEMBERS members1,  _,  members1right)) !  _ !  ( _,  ( values::QQ_ONE_OR_MORE_EXPORTS one_or_more_exports1,  _,  _)) !  ( _,  ( _,  library_exports1left,  _)) !  rest671)
) => {  my  result = values::QQ_LIBRARY (fn  _ =  {  my  (one_or_more_exports as one_or_more_exports1) = one_or_more_exports1 ();
 my  (members as members1) = members1 ();
 (
    lga::make_main_library {
						 	path			=> libfile,
							exports     		=> one_or_more_exports,
							makelib_version_intlist	=> NULL,
							members,
							makelib_state,
							primordial_library
                                                    }
                                                
);
 } );
 ( lr_table::NONTERM 0,  ( result,  library_exports1left,  members1right),  rest671);
 } 
;  ( 3,  ( ( _,  ( values::FILE_STANDARD file_standard1,  (file_standardleft as file_standard1left),  (file_standardright as file_standard1right))) !  rest671)) => {  my  result = 
values::QQ_MAKELIB_VERSION_INTLIST (fn  _ =  {  my  (file_standard as file_standard1) = file_standard1 ();
 (
   lga::cm_version				# Here we're abusing FILE_STANDARD to match a version intlist string like "12.3.9"
						       (   file_standard,
						           report_error (  file_standardleft,
							                   file_standardright
                                                )      )   
);
 } );
 ( lr_table::NONTERM 1,  ( result,  file_standard1left,  file_standard1right),  rest671);
 } 
;  ( 4,  ( ( _,  ( values::QQ_EXPORT export1,  export1left,  export1right)) !  rest671)) => {  my  result = values::QQ_ONE_OR_MORE_EXPORTS (fn  _ =  {  my  (export as export1) = export1 ();
 (export)
;
 } );
 ( lr_table::NONTERM 2,  ( result,  export1left,  export1right),  rest671);
 } 
;  ( 5,  ( ( _,  ( values::QQ_EXPORT export1,  _,  export1right)) !  ( _,  ( values::QQ_ONE_OR_MORE_EXPORTS one_or_more_exports1,  one_or_more_exports1left,  _)) !  rest671)) => {  my  result = 
values::QQ_ONE_OR_MORE_EXPORTS (fn  _ =  {  my  (one_or_more_exports as one_or_more_exports1) = one_or_more_exports1 ();
 my  (export as export1) = export1 ();
 (
lga::union_of_exports_symbolsets (one_or_more_exports, export));
 } );
 ( lr_table::NONTERM 2,  ( result,  one_or_more_exports1left,  export1right),  rest671);
 } 
;  ( 6,  ( rest671)) => {  my  result = values::QQ_ZERO_OR_MORE_EXPORTS (fn  _ =  (lga::default_library_exports));
 ( lr_table::NONTERM 3,  ( result,  default_position,  default_position),  rest671)
;
 } 
;  ( 7,  ( ( _,  ( values::QQ_ONE_OR_MORE_EXPORTS one_or_more_exports1,  one_or_more_exports1left,  one_or_more_exports1right)) !  rest671)) => {  my  result = values::QQ_ZERO_OR_MORE_EXPORTS (fn  _
 =  {  my  (one_or_more_exports as one_or_more_exports1) = one_or_more_exports1 ();
 (one_or_more_exports);
 } );
 ( lr_table::NONTERM 3,  ( result,  one_or_more_exports1left,  
one_or_more_exports1right),  rest671);
 } 
;  ( 8,  ( rest671)) => {  my  result = values::QQ_EXPORTS (fn  _ =  (lga::empty_exports));
 ( lr_table::NONTERM 4,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 9,  ( ( _,  ( values::QQ_EXPORT export1,  _,  export1right)) !  ( _,  ( values::QQ_EXPORTS exports1,  exports1left,  _)) !  rest671)) => {  my  result = values::QQ_EXPORTS (fn  _ =  {  my  (
exports as exports1) = exports1 ();
 my  (export as export1) = export1 ();
 (lga::union_of_exports_symbolsets (exports, export));
 } );
 ( lr_table::NONTERM 4,  ( result,  exports1left,  export1right)
,  rest671);
 } 
;  ( 10,  ( ( _,  ( values::QQ_ML_SYMBOLSET ml_symbolset1,  ml_symbolset1left,  ml_symbolset1right)) !  rest671)) => {  my  result = values::QQ_EXPORT (fn  _ =  {  my  (ml_symbolset as ml_symbolset1)
 = ml_symbolset1 ();
 (ml_symbolset);
 } );
 ( lr_table::NONTERM 5,  ( result,  ml_symbolset1left,  ml_symbolset1right),  rest671);
 } 
;  ( 11,  ( ( _,  ( values::QQ_CONDITIONAL_EXPORTS conditional_exports1,  _,  conditional_exports1right)) !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_expleft,  bool_expright)) !  ( _,  ( _,  
if_t1left,  _)) !  rest671)) => {  my  result = values::QQ_EXPORT (fn  _ =  {  my  (bool_exp as bool_exp1) = bool_exp1 ();
 my  (conditional_exports as conditional_exports1) = conditional_exports1 ()
;
 (lga::conditional_exports
						  (bool_exp, conditional_exports, report_error (bool_expleft, bool_expright)));
 } );
 ( lr_table::NONTERM 5,  ( result,  if_t1left,  conditional_exports1right),  
rest671);
 } 
;  ( 12,  ( ( _,  ( values::ERRORX errorx1,  (errorxleft as errorx1left),  (errorxright as errorx1right))) !  rest671)) => {  my  result = values::QQ_EXPORT (fn  _ =  {  my  (errorx as errorx1) = 
errorx1 ();
 (lga::error_export (fn () = report_error (errorxleft, errorxright) errorx));
 } );
 ( lr_table::NONTERM 5,  ( result,  errorx1left,  errorx1right),  rest671);
 } 
;  ( 13,  ( ( _,  ( _,  sublibrary_exports1left,  sublibrary_exports1right)) !  rest671)) => {  my  result = values::QQ_SUBLIB_OR_APIPKG_EXPORTS (fn  _ =  (lga::sublibrary_exported_symbols));
 ( 
lr_table::NONTERM 26,  ( result,  sublibrary_exports1left,  sublibrary_exports1right),  rest671);
 } 
;  ( 14,  ( ( _,  ( _,  api_or_pkg_exports1left,  api_or_pkg_exports1right)) !  rest671)) => {  my  result = values::QQ_SUBLIB_OR_APIPKG_EXPORTS (fn  _ =  (lga::api_or_pkg_exported_symbols));
 ( 
lr_table::NONTERM 26,  ( result,  api_or_pkg_exports1left,  api_or_pkg_exports1right),  rest671);
 } 
;  ( 15,  ( ( _,  ( values::QQ_ML_SYMBOL ml_symbol1,  (ml_symbolleft as ml_symbol1left),  (ml_symbolright as ml_symbol1right))) !  rest671)) => {  my  result = values::QQ_ML_SYMBOLSET (fn  _ =  {  my 
 (ml_symbol as ml_symbol1) = ml_symbol1 ();
 (lga::exports_symbolset_from_symbol
						     (ml_symbol,
						      report_error (ml_symbolleft,
							            ml_symbolright)));
 } );
 ( 
lr_table::NONTERM 15,  ( result,  ml_symbol1left,  ml_symbol1right),  rest671);
 } 
;  ( 16,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_EXPORTS exports1,  _,  _)) !  ( _,  ( _,  lparen1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOLSET (fn  _ =  {  my  (
exports as exports1) = exports1 ();
 (exports);
 } );
 ( lr_table::NONTERM 15,  ( result,  lparen1left,  rparen1right),  rest671);
 } 
;  ( 17,  ( ( _,  ( values::QQ_ML_SYMBOLSET ml_symbolset2,  _,  ml_symbolset2right)) !  _ !  ( _,  ( values::QQ_ML_SYMBOLSET ml_symbolset1,  ml_symbolset1left,  _)) !  rest671)) => {  my  result = 
values::QQ_ML_SYMBOLSET (fn  _ =  {  my  ml_symbolset1 = ml_symbolset1 ();
 my  ml_symbolset2 = ml_symbolset2 ();
 (
lga::intersection_of_exports_symbolsets
					             (ml_symbolset1,
					              ml_symbolset2));
 } );
 ( lr_table::NONTERM 15,  ( result,  ml_symbolset1left,  ml_symbolset2right),  
rest671);
 } 
;  ( 18,  ( ( _,  ( values::QQ_ML_SYMBOLSET ml_symbolset2,  _,  ml_symbolset2right)) !  _ !  ( _,  ( values::QQ_ML_SYMBOLSET ml_symbolset1,  ml_symbolset1left,  _)) !  rest671)) => {  my  result = 
values::QQ_ML_SYMBOLSET (fn  _ =  {  my  ml_symbolset1 = ml_symbolset1 ();
 my  ml_symbolset2 = ml_symbolset2 ();
 (
lga::difference_of_exports_symbolsets
					            (ml_symbolset1,
					             ml_symbolset2));
 } );
 ( lr_table::NONTERM 15,  ( result,  ml_symbolset1left,  ml_symbolset2right),  rest671)
;
 } 
;  ( 19,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_NULL_OR_SRCFILE null_or_srcfile1,  null_or_srcfileleft,  null_or_srcfileright)) !  _ !  ( _,  ( values::QQ_SUBLIB_OR_APIPKG_EXPORTS 
sublib_or_apipkg_exports1,  sublib_or_apipkg_exports1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOLSET (fn  _ =  {  my  (sublib_or_apipkg_exports as sublib_or_apipkg_exports1) = 
sublib_or_apipkg_exports1 ();
 my  (null_or_srcfile as null_or_srcfile1) = null_or_srcfile1 ();
 (
sublib_or_apipkg_exports						# lga::sublibrary_exported_symbols  or  lga::api_or_pkg_exported_symbols
					            (null_or_srcfile,
					             report_error (null_or_srcfileleft, null_or_srcfileright)
                                                )   
);
 } );
 ( lr_table::NONTERM 15,  ( result,  sublib_or_apipkg_exports1left,  rparen1right),  rest671);
 } 
;  ( 20,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_OPTTOOLOPTS opttoolopts1,  _,  _)) !  ( _,  ( values::QQ_PATHNAME pathname1,  pathnameleft,  pathnameright)) !  _ !  ( _,  ( _,  
library_exports1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOLSET (fn  _ =  {  my  (pathname as pathname1) = pathname1 ();
 my  (opttoolopts as opttoolopts1) = opttoolopts1 ();
 (
lga::export_freezefile
						   ( ad::file (pathname.make_path ()),
						     report_error (pathnameleft, pathnameright),
						     { hasoptions =>
							  not_null opttoolopts,
						       elab => fn () =
							  make_member
							      (pathname,
							       pathnameleft,
							       pathnameright,
							       NULL,
							       opttoolopts),
						       this_library
                                                      }
                                                ) 
);
 } );
 ( lr_table::NONTERM 15,  ( result,  library_exports1left,  rparen1right),  rest671);
 } 
;  ( 21,  ( ( _,  ( values::QQ_ELSE_EXPORTS else_exports1,  _,  else_exports1right)) !  ( _,  ( values::QQ_EXPORTS exports1,  exports1left,  _)) !  rest671)) => {  my  result = 
values::QQ_CONDITIONAL_EXPORTS (fn  _ =  {  my  (exports as exports1) = exports1 ();
 my  (else_exports as else_exports1) = else_exports1 ();
 ((exports, else_exports));
 } );
 ( lr_table::NONTERM 6, 
 ( result,  exports1left,  else_exports1right),  rest671);
 } 
;  ( 22,  ( ( _,  ( _,  endif1left,  endif1right)) !  rest671)) => {  my  result = values::QQ_ELSE_EXPORTS (fn  _ =  (lga::empty_exports));
 ( lr_table::NONTERM 7,  ( result,  endif1left,  endif1right
),  rest671);
 } 
;  ( 23,  ( ( _,  ( _,  _,  endif1right)) !  ( _,  ( values::QQ_EXPORTS exports1,  _,  _)) !  ( _,  ( _,  else_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ELSE_EXPORTS (fn  _ =  {  my  (
exports as exports1) = exports1 ();
 (exports);
 } );
 ( lr_table::NONTERM 7,  ( result,  else_t1left,  endif1right),  rest671);
 } 
;  ( 24,  ( ( _,  ( values::QQ_CONDITIONAL_EXPORTS conditional_exports1,  _,  conditional_exports1right)) !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_expleft,  bool_expright)) !  ( _,  ( _,  
elif_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ELSE_EXPORTS (fn  _ =  {  my  (bool_exp as bool_exp1) = bool_exp1 ();
 my  (conditional_exports as conditional_exports1) = 
conditional_exports1 ();
 (lga::conditional_exports
						    (bool_exp, conditional_exports,
						     report_error (bool_expleft, bool_expright)));
 } );
 ( lr_table::NONTERM 7,  ( result,  
elif_t1left,  conditional_exports1right),  rest671);
 } 
;  ( 25,  ( rest671)) => {  my  result = values::QQ_MEMBERS (fn  _ =  (lga::empty_members));
 ( lr_table::NONTERM 8,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 26,  ( ( _,  ( values::QQ_MEMBERS members1,  _,  members1right)) !  ( _,  ( values::QQ_MEMBER member1,  member1left,  _)) !  rest671)) => {  my  result = values::QQ_MEMBERS (fn  _ =  {  my  (
member as member1) = member1 ();
 my  (members as members1) = members1 ();
 (lga::members (member, members));
 } );
 ( lr_table::NONTERM 8,  ( result,  member1left,  members1right),  rest671);
 } 
;  ( 27,  ( rest671)) => {  my  result = values::QQ_TOOLOPTS (fn  _ =  ([]));
 ( lr_table::NONTERM 21,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 28,  ( ( _,  ( values::QQ_TOOLOPTS toolopts1,  _,  toolopts1right)) !  ( _,  ( values::QQ_PATHNAME pathname1,  pathname1left,  _)) !  rest671)) => {  my  result = values::QQ_TOOLOPTS (fn  _ =  { 
 my  (pathname as pathname1) = pathname1 ();
 my  (toolopts as toolopts1) = toolopts1 ();
 (lga::string pathname ! toolopts);
 } );
 ( lr_table::NONTERM 21,  ( result,  pathname1left,  toolopts1right)
,  rest671);
 } 
;  ( 29,  ( ( _,  ( values::QQ_TOOLOPTS toolopts1,  _,  toolopts1right)) !  ( _,  ( values::QQ_PTOOLOPTS ptoolopts1,  _,  _)) !  _ !  ( _,  ( values::QQ_PATHNAME pathname1,  pathname1left,  _)) !  
rest671)) => {  my  result = values::QQ_TOOLOPTS (fn  _ =  {  my  (pathname as pathname1) = pathname1 ();
 my  (ptoolopts as ptoolopts1) = ptoolopts1 ();
 my  (toolopts as toolopts1) = toolopts1 ();

 (
lga::subopts
						     { name         =>  pathname.name,
						       tool_options =>  ptoolopts
                                                     }
						     ! toolopts
                                                
);
 } );
 ( lr_table::NONTERM 21,  ( result,  pathname1left,  toolopts1right),  rest671);
 } 
;  ( 30,  ( ( _,  ( values::QQ_TOOLOPTS toolopts1,  _,  toolopts1right)) !  ( _,  ( values::QQ_PATHNAME pathname2,  _,  _)) !  _ !  ( _,  ( values::QQ_PATHNAME pathname1,  pathname1left,  _)) !  
rest671)) => {  my  result = values::QQ_TOOLOPTS (fn  _ =  {  my  pathname1 = pathname1 ();
 my  pathname2 = pathname2 ();
 my  (toolopts as toolopts1) = toolopts1 ();
 (
lga::subopts
						     { name         =>  pathname1.name,
						       tool_options =>  [lga::string pathname2]
                                                     }
						 ! toolopts);
 } );
 ( 
lr_table::NONTERM 21,  ( result,  pathname1left,  toolopts1right),  rest671);
 } 
;  ( 31,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_TOOLOPTS toolopts1,  _,  _)) !  ( _,  ( _,  lparen1left,  _)) !  rest671)) => {  my  result = values::QQ_PTOOLOPTS (fn  _ =  {  my  (
toolopts as toolopts1) = toolopts1 ();
 (toolopts);
 } );
 ( lr_table::NONTERM 22,  ( result,  lparen1left,  rparen1right),  rest671);
 } 
;  ( 32,  ( rest671)) => {  my  result = values::QQ_OPTTOOLOPTS (fn  _ =  (NULL));
 ( lr_table::NONTERM 23,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 33,  ( ( _,  ( values::QQ_PTOOLOPTS ptoolopts1,  ptoolopts1left,  ptoolopts1right)) !  rest671)) => {  my  result = values::QQ_OPTTOOLOPTS (fn  _ =  {  my  (ptoolopts as ptoolopts1) = ptoolopts1
 ();
 (THE ptoolopts);
 } );
 ( lr_table::NONTERM 23,  ( result,  ptoolopts1left,  ptoolopts1right),  rest671);
 } 
;  ( 34,  ( rest671)) => {  my  result = values::QQ_NULL_OR_ILK_QUALIFIER (fn  _ =  (NULL));
 ( lr_table::NONTERM 20,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 35,  ( ( _,  ( values::QQ_ILK ilk1,  _,  ilk1right)) !  ( _,  ( _,  colon1left,  _)) !  rest671)) => {  my  result = values::QQ_NULL_OR_ILK_QUALIFIER (fn  _ =  {  my  (ilk as ilk1) = ilk1 ();
 (
THE ilk);
 } );
 ( lr_table::NONTERM 20,  ( result,  colon1left,  ilk1right),  rest671);
 } 
;  ( 36,  ( ( _,  ( values::QQ_OPTTOOLOPTS opttoolopts1,  _,  opttoolopts1right)) !  ( _,  ( values::QQ_NULL_OR_ILK_QUALIFIER null_or_ilk_qualifier1,  _,  _)) !  ( _,  ( values::QQ_PATHNAME pathname1
,  (pathnameleft as pathname1left),  pathnameright)) !  rest671)) => {  my  result = values::QQ_MEMBER (fn  _ =  {  my  (pathname as pathname1) = pathname1 ();
 my  (null_or_ilk_qualifier as 
null_or_ilk_qualifier1) = null_or_ilk_qualifier1 ();
 my  (opttoolopts as opttoolopts1) = opttoolopts1 ();
 (
make_member (pathname,
							   pathnameleft,
							   pathnameright,
							   null_or_ilk_qualifier,
							   opttoolopts));
 } );
 ( lr_table::NONTERM 9,  ( result,  pathname1left,  
opttoolopts1right),  rest671);
 } 
;  ( 37,  ( ( _,  ( values::QQ_GUARDED_MEMBERS guarded_members1,  _,  guarded_members1right)) !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_expleft,  bool_expright)) !  ( _,  ( _,  if_t1left,  _))
 !  rest671)) => {  my  result = values::QQ_MEMBER (fn  _ =  {  my  (bool_exp as bool_exp1) = bool_exp1 ();
 my  (guarded_members as guarded_members1) = guarded_members1 ();
 (
lga::guarded_members (bool_exp, guarded_members, report_error (bool_expleft, bool_expright)));
 } );
 ( lr_table::NONTERM 9,  ( result,  if_t1left,  guarded_members1right),  rest671);
 } 
;  ( 38,  ( ( _,  ( values::ERRORX errorx1,  (errorxleft as errorx1left),  (errorxright as errorx1right))) !  rest671)) => {  my  result = values::QQ_MEMBER (fn  _ =  {  my  (errorx as errorx1) = 
errorx1 ();
 (lga::error_member (fn () =  report_error (errorxleft, errorxright) errorx));
 } );
 ( lr_table::NONTERM 9,  ( result,  errorx1left,  errorx1right),  rest671);
 } 
;  ( 39,  ( ( _,  ( values::QQ_WORD word1,  word1left,  word1right)) !  rest671)) => {  my  result = values::QQ_ILK (fn  _ =  {  my  (word as word1) = word1 ();
 (lga::ilk word);
 } );
 ( 
lr_table::NONTERM 19,  ( result,  word1left,  word1right),  rest671);
 } 
;  ( 40,  ( ( _,  ( values::QQ_ELSE_MEMBERS else_members1,  _,  else_members1right)) !  ( _,  ( values::QQ_MEMBERS members1,  members1left,  _)) !  rest671)) => {  my  result = 
values::QQ_GUARDED_MEMBERS (fn  _ =  {  my  (members as members1) = members1 ();
 my  (else_members as else_members1) = else_members1 ();
 ((members, else_members));
 } );
 ( lr_table::NONTERM 10,  ( 
result,  members1left,  else_members1right),  rest671);
 } 
;  ( 41,  ( ( _,  ( _,  endif1left,  endif1right)) !  rest671)) => {  my  result = values::QQ_ELSE_MEMBERS (fn  _ =  (lga::empty_members));
 ( lr_table::NONTERM 11,  ( result,  endif1left,  
endif1right),  rest671);
 } 
;  ( 42,  ( ( _,  ( _,  _,  endif1right)) !  ( _,  ( values::QQ_MEMBERS members1,  _,  _)) !  ( _,  ( _,  else_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ELSE_MEMBERS (fn  _ =  {  my  (
members as members1) = members1 ();
 (members);
 } );
 ( lr_table::NONTERM 11,  ( result,  else_t1left,  endif1right),  rest671);
 } 
;  ( 43,  ( ( _,  ( values::QQ_GUARDED_MEMBERS guarded_members1,  _,  guarded_members1right)) !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_expleft,  bool_expright)) !  ( _,  ( _,  elif_t1left,  _))
 !  rest671)) => {  my  result = values::QQ_ELSE_MEMBERS (fn  _ =  {  my  (bool_exp as bool_exp1) = bool_exp1 ();
 my  (guarded_members as guarded_members1) = guarded_members1 ();
 (
lga::guarded_members (bool_exp, guarded_members, report_error (bool_expleft, bool_expright)));
 } );
 ( lr_table::NONTERM 11,  ( result,  elif_t1left,  guarded_members1right),  rest671);
 } 
;  ( 44,  ( ( _,  ( values::FILE_STANDARD file_standard1,  file_standard1left,  file_standard1right)) !  rest671)) => {  my  result = values::QQ_WORD (fn  _ =  {  my  (file_standard as file_standard1)
 = file_standard1 ();
 (lga::cm_symbol file_standard);
 } );
 ( lr_table::NONTERM 18,  ( result,  file_standard1left,  file_standard1right),  rest671);
 } 
;  ( 45,  ( ( _,  ( values::MAKELIB_ID makelib_id1,  makelib_id1left,  makelib_id1right)) !  rest671)) => {  my  result = values::QQ_MAKELIB_ID (fn  _ =  {  my  (makelib_id as makelib_id1) = 
makelib_id1 ();
 (lga::cm_symbol makelib_id);
 } );
 ( lr_table::NONTERM 17,  ( result,  makelib_id1left,  makelib_id1right),  rest671);
 } 
;  ( 46,  ( ( _,  ( values::NUMBER number1,  number1left,  number1right)) !  rest671)) => {  my  result = values::QQ_INT_EXP (fn  _ =  {  my  (number as number1) = number1 ();
 (lga::number number)
;
 } );
 ( lr_table::NONTERM 12,  ( result,  number1left,  number1right),  rest671);
 } 
;  ( 47,  ( ( _,  ( values::QQ_MAKELIB_ID makelib_id1,  makelib_id1left,  makelib_id1right)) !  rest671)) => {  my  result = values::QQ_INT_EXP (fn  _ =  {  my  (makelib_id as makelib_id1) = 
makelib_id1 ();
 (lga::variable  makelib_state  makelib_id);
 } );
 ( lr_table::NONTERM 12,  ( result,  makelib_id1left,  makelib_id1right),  rest671);
 } 
;  ( 48,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_INT_EXP int_exp1,  _,  _)) !  ( _,  ( _,  lparen1left,  _)) !  rest671)) => {  my  result = values::QQ_INT_EXP (fn  _ =  {  my  (
int_exp as int_exp1) = int_exp1 ();
 (int_exp);
 } );
 ( lr_table::NONTERM 12,  ( result,  lparen1left,  rparen1right),  rest671);
 } 
;  ( 49,  ( ( _,  ( values::QQ_INT_EXP int_exp2,  _,  int_exp2right)) !  ( _,  ( values::ADDSYM addsym1,  _,  _)) !  ( _,  ( values::QQ_INT_EXP int_exp1,  int_exp1left,  _)) !  rest671)) => {  my  
result = values::QQ_INT_EXP (fn  _ =  {  my  int_exp1 = int_exp1 ();
 my  (addsym as addsym1) = addsym1 ();
 my  int_exp2 = int_exp2 ();
 (lga::add (int_exp1, addsym, int_exp2));
 } );
 ( 
lr_table::NONTERM 12,  ( result,  int_exp1left,  int_exp2right),  rest671);
 } 
;  ( 50,  ( ( _,  ( values::QQ_INT_EXP int_exp2,  _,  int_exp2right)) !  ( _,  ( values::MULSYM mulsym1,  _,  _)) !  ( _,  ( values::QQ_INT_EXP int_exp1,  int_exp1left,  _)) !  rest671)) => {  my  
result = values::QQ_INT_EXP (fn  _ =  {  my  int_exp1 = int_exp1 ();
 my  (mulsym as mulsym1) = mulsym1 ();
 my  int_exp2 = int_exp2 ();
 (lga::mul (int_exp1, mulsym, int_exp2));
 } );
 ( 
lr_table::NONTERM 12,  ( result,  int_exp1left,  int_exp2right),  rest671);
 } 
;  ( 51,  ( ( _,  ( values::QQ_INT_EXP int_exp1,  _,  int_exp1right)) !  ( _,  ( _,  tilde1left,  _)) !  rest671)) => {  my  result = values::QQ_INT_EXP (fn  _ =  {  my  (int_exp as int_exp1) = 
int_exp1 ();
 (lga::negate int_exp);
 } );
 ( lr_table::NONTERM 12,  ( result,  tilde1left,  int_exp1right),  rest671);
 } 
;  ( 52,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_ML_SYMBOL ml_symbol1,  _,  _)) !  _ !  ( _,  ( _,  defined1left,  _)) !  rest671)) => {  my  result = values::QQ_BOOL_EXP (fn  _ =  { 
 my  (ml_symbol as ml_symbol1) = ml_symbol1 ();
 (lga::ml_defined ml_symbol);
 } );
 ( lr_table::NONTERM 13,  ( result,  defined1left,  rparen1right),  rest671);
 } 
;  ( 53,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_MAKELIB_ID makelib_id1,  _,  _)) !  _ !  ( _,  ( _,  defined1left,  _)) !  rest671)) => {  my  result = values::QQ_BOOL_EXP (fn  _ = 
 {  my  (makelib_id as makelib_id1) = makelib_id1 ();
 (lga::is_defined_hostproperty makelib_state makelib_id);
 } );
 ( lr_table::NONTERM 13,  ( result,  defined1left,  rparen1right),  rest671);
 } 
;  ( 54,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  _,  _)) !  ( _,  ( _,  lparen1left,  _)) !  rest671)) => {  my  result = values::QQ_BOOL_EXP (fn  _ =  {  my  (
bool_exp as bool_exp1) = bool_exp1 ();
 (bool_exp);
 } );
 ( lr_table::NONTERM 13,  ( result,  lparen1left,  rparen1right),  rest671);
 } 
;  ( 55,  ( ( _,  ( values::QQ_BOOL_EXP bool_exp2,  _,  bool_exp2right)) !  _ !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_exp1left,  _)) !  rest671)) => {  my  result = values::QQ_BOOL_EXP (fn  _
 =  {  my  bool_exp1 = bool_exp1 ();
 my  bool_exp2 = bool_exp2 ();
 (lga::conj (bool_exp1,        bool_exp2));
 } );
 ( lr_table::NONTERM 13,  ( result,  bool_exp1left,  bool_exp2right),  rest671)
;
 } 
;  ( 56,  ( ( _,  ( values::QQ_BOOL_EXP bool_exp2,  _,  bool_exp2right)) !  _ !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_exp1left,  _)) !  rest671)) => {  my  result = values::QQ_BOOL_EXP (fn  _
 =  {  my  bool_exp1 = bool_exp1 ();
 my  bool_exp2 = bool_exp2 ();
 (lga::disj (bool_exp1,        bool_exp2));
 } );
 ( lr_table::NONTERM 13,  ( result,  bool_exp1left,  bool_exp2right),  rest671)
;
 } 
;  ( 57,  ( ( _,  ( values::QQ_BOOL_EXP bool_exp2,  _,  bool_exp2right)) !  ( _,  ( values::EQSYM eqsym1,  _,  _)) !  ( _,  ( values::QQ_BOOL_EXP bool_exp1,  bool_exp1left,  _)) !  rest671)) => {  my 
 result = values::QQ_BOOL_EXP (fn  _ =  {  my  bool_exp1 = bool_exp1 ();
 my  (eqsym as eqsym1) = eqsym1 ();
 my  bool_exp2 = bool_exp2 ();
 (lga::beq  (bool_exp1, eqsym, bool_exp2));
 } );
 ( 
lr_table::NONTERM 13,  ( result,  bool_exp1left,  bool_exp2right),  rest671);
 } 
;  ( 58,  ( ( _,  ( values::QQ_BOOL_EXP bool_exp1,  _,  bool_exp1right)) !  ( _,  ( _,  not_t1left,  _)) !  rest671)) => {  my  result = values::QQ_BOOL_EXP (fn  _ =  {  my  (bool_exp as bool_exp1) = 
bool_exp1 ();
 (lga::not bool_exp);
 } );
 ( lr_table::NONTERM 13,  ( result,  not_t1left,  bool_exp1right),  rest671);
 } 
;  ( 59,  ( ( _,  ( values::QQ_INT_EXP int_exp2,  _,  int_exp2right)) !  ( _,  ( values::INEQSYM ineqsym1,  _,  _)) !  ( _,  ( values::QQ_INT_EXP int_exp1,  int_exp1left,  _)) !  rest671)) => {  my  
result = values::QQ_BOOL_EXP (fn  _ =  {  my  int_exp1 = int_exp1 ();
 my  (ineqsym as ineqsym1) = ineqsym1 ();
 my  int_exp2 = int_exp2 ();
 (lga::ineq (int_exp1, ineqsym, int_exp2));
 } );
 ( 
lr_table::NONTERM 13,  ( result,  int_exp1left,  int_exp2right),  rest671);
 } 
;  ( 60,  ( ( _,  ( values::QQ_INT_EXP int_exp2,  _,  int_exp2right)) !  ( _,  ( values::EQSYM eqsym1,  _,  _)) !  ( _,  ( values::QQ_INT_EXP int_exp1,  int_exp1left,  _)) !  rest671)) => {  my  
result = values::QQ_BOOL_EXP (fn  _ =  {  my  int_exp1 = int_exp1 ();
 my  (eqsym as eqsym1) = eqsym1 ();
 my  int_exp2 = int_exp2 ();
 (lga::eq   (int_exp1,   eqsym, int_exp2));
 } );
 ( 
lr_table::NONTERM 13,  ( result,  int_exp1left,  int_exp2right),  rest671);
 } 
;  ( 61,  ( ( _,  ( values::ML_ID ml_id1,  _,  ml_id1right)) !  ( _,  ( _,  pkg_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOL (fn  _ =  {  my  (ml_id as ml_id1) = ml_id1 ();
 (
lga::my_package ml_id);
 } );
 ( lr_table::NONTERM 14,  ( result,  pkg_t1left,  ml_id1right),  rest671);
 } 
;  ( 62,  ( ( _,  ( values::ML_ID ml_id1,  _,  ml_id1right)) !  ( _,  ( _,  api_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOL (fn  _ =  {  my  (ml_id as ml_id1) = ml_id1 ();
 (
lga::my_api ml_id);
 } );
 ( lr_table::NONTERM 14,  ( result,  api_t1left,  ml_id1right),  rest671);
 } 
;  ( 63,  ( ( _,  ( values::ML_ID ml_id1,  _,  ml_id1right)) !  ( _,  ( _,  generic_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOL (fn  _ =  {  my  (ml_id as ml_id1) = ml_id1 ();
 (
lga::my_g   ml_id);
 } );
 ( lr_table::NONTERM 14,  ( result,  generic_t1left,  ml_id1right),  rest671);
 } 
;  ( 64,  ( ( _,  ( values::ML_ID ml_id1,  _,  ml_id1right)) !  ( _,  ( _,  generic_api_t1left,  _)) !  rest671)) => {  my  result = values::QQ_ML_SYMBOL (fn  _ =  {  my  (ml_id as ml_id1) = ml_id1 ()
;
 (lga::my_generic_api    ml_id);
 } );
 ( lr_table::NONTERM 14,  ( result,  generic_api_t1left,  ml_id1right),  rest671);
 } 
;  ( 65,  ( ( _,  ( values::FILE_STANDARD file_standard1,  (file_standardleft as file_standard1left),  (file_standardright as file_standard1right))) !  rest671)) => {  my  result = values::QQ_PATHNAME
 (fn  _ =  {  my  (file_standard as file_standard1) = file_standard1 ();
 (
 { name   => file_standard,
						   make_path => fn () =  lga::file_standard
                                                                         makelib_state
									   ( file_standard,
									     path_root,
                                                                             report_error (file_standardleft, file_standardright)
                                                                           )
                                                 }
                                                
);
 } );
 ( lr_table::NONTERM 16,  ( result,  file_standard1left,  file_standard1right),  rest671);
 } 
;  ( 66,  ( ( _,  ( values::FILE_NATIVE file_native1,  (file_nativeleft as file_native1left),  (file_nativeright as file_native1right))) !  rest671)) => {  my  result = values::QQ_PATHNAME (fn  _ = 
 {  my  (file_native as file_native1) = file_native1 ();
 (
 { name
                                                        =>
                                                        file_native,

						    make_path
                                                        =>
                                                        fn ()
                                                            =
                                                            lga::file_native
								( file_native,
								  path_root,
								  report_error
								  (file_nativeleft, file_nativeright)
								)
                                                 }
                                                
);
 } );
 ( lr_table::NONTERM 16,  ( result,  file_native1left,  file_native1right),  rest671);
 } 
;  ( 67,  ( ( _,  ( values::QQ_PATHNAME pathname1,  pathname1left,  pathname1right)) !  rest671)) => {  my  result = values::QQ_SRCFILE (fn  _ =  {  my  (pathname as pathname1) = pathname1 ();
 (
ad::file
						     (pathname.make_path ()));
 } );
 ( lr_table::NONTERM 24,  ( result,  pathname1left,  pathname1right),  rest671);
 } 
;  ( 68,  ( ( _,  ( values::QQ_SRCFILE srcfile1,  srcfile1left,  srcfile1right)) !  rest671)) => {  my  result = values::QQ_NULL_OR_SRCFILE (fn  _ =  {  my  (srcfile as srcfile1) = srcfile1 ();
 (
THE srcfile);
 } );
 ( lr_table::NONTERM 25,  ( result,  srcfile1left,  srcfile1right),  rest671);
 } 
;  ( 69,  ( ( _,  ( _,  dash1left,  dash1right)) !  rest671)) => {  my  result = values::QQ_NULL_OR_SRCFILE (fn  _ =  (NULL));
 ( lr_table::NONTERM 25,  ( result,  dash1left,  dash1right),  rest671)
;
 } 
; _ => raise exception (MLY_ACTION i392);
esac;
end;
void = values::TM_VOID;
extract = fn a = (fn values::QQ_LIBRARY x => x;
 _ => { exception PARSE_INTERNAL;
	 raise exception PARSE_INTERNAL; }; end ) a ();
};
};
package tokens : (weak) Libfile_Tokens {
Semantic_Value = parser_data::Semantic_Value;
Token (X,Y) = token::Token(X,Y);
fun eof (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 0, (parser_data::values::TM_VOID, p1, p2));
fun file_standard (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 1, (parser_data::values::FILE_STANDARD (fn () = i), p1, p2));
fun file_native (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 2, (parser_data::values::FILE_NATIVE (fn () = i), p1, p2));
fun makelib_id (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 3, (parser_data::values::MAKELIB_ID (fn () = i), p1, p2));
fun ml_id (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 4, (parser_data::values::ML_ID (fn () = i), p1, p2));
fun number (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 5, (parser_data::values::NUMBER (fn () = i), p1, p2));
fun sublibrary_exports (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 6, (parser_data::values::TM_VOID, p1, p2));
fun library_exports (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 7, (parser_data::values::TM_VOID, p1, p2));
fun library_components (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 8, (parser_data::values::TM_VOID, p1, p2));
fun lparen (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 9, (parser_data::values::TM_VOID, p1, p2));
fun rparen (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 10, (parser_data::values::TM_VOID, p1, p2));
fun colon (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 11, (parser_data::values::TM_VOID, p1, p2));
fun if_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 12, (parser_data::values::TM_VOID, p1, p2));
fun elif_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 13, (parser_data::values::TM_VOID, p1, p2));
fun else_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 14, (parser_data::values::TM_VOID, p1, p2));
fun endif (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 15, (parser_data::values::TM_VOID, p1, p2));
fun errorx (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 16, (parser_data::values::ERRORX (fn () = i), p1, p2));
fun pkg_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 17, (parser_data::values::TM_VOID, p1, p2));
fun api_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 18, (parser_data::values::TM_VOID, p1, p2));
fun generic_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 19, (parser_data::values::TM_VOID, p1, p2));
fun generic_api_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 20, (parser_data::values::TM_VOID, p1, p2));
fun defined (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 21, (parser_data::values::TM_VOID, p1, p2));
fun addsym (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 22, (parser_data::values::ADDSYM (fn () = i), p1, p2));
fun mulsym (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 23, (parser_data::values::MULSYM (fn () = i), p1, p2));
fun eqsym (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 24, (parser_data::values::EQSYM (fn () = i), p1, p2));
fun ineqsym (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 25, (parser_data::values::INEQSYM (fn () = i), p1, p2));
fun tilde (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 26, (parser_data::values::TM_VOID, p1, p2));
fun and_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 27, (parser_data::values::TM_VOID, p1, p2));
fun or_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 28, (parser_data::values::TM_VOID, p1, p2));
fun not_t (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 29, (parser_data::values::TM_VOID, p1, p2));
fun star (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 30, (parser_data::values::TM_VOID, p1, p2));
fun dash (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 31, (parser_data::values::TM_VOID, p1, p2));
fun api_or_pkg_exports (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 32, (parser_data::values::TM_VOID, p1, p2));
};
};
