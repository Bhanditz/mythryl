## simple-thread.pkg

# Compiled by:
#     src/app/makelib/simple-concurrency/simple-concurrency.sublib



# OVERVIEW
# ========
#
# This is a very simple thread package used by
#
#     src/app/makelib/compile/compile-in-dependency-order-g.pkg
#     src/app/makelib/mythryl-compiler-compiler/mythryl-compiler-compiler-g.pkg
#
# when running multiple copies of the compiler in
# parallel as unix subprocesses so as to save wall-clock
# time when compiling on multi-core machines.
#
# This package does nothing that thread-kit doesn't do better;
# it is here only so we can do parallel compiles even when
# thread-kit isn't installed.
#
#
#
#         NB: Throughout this file, 'thread' refers to lightweight
#             application-specific threads, not heavyweight threads
#             managed by the OS kernel.  In other words, we are here
#             concerned at the in-process level with multiprogramming,
#             not multiprocessing.  (Our unix subprocesses do give
#             us multiprocessing, of course.)
#
#
#
# We create threads using a 'make_simple_thread' command
# which takes a function to compute and returns a 'thread'
# object to the compiler:
#
#     thread = sit::make_simple_thread .{ something_to_compute (); };
#
# We also supply a 'wait_for_thread_to_finish_then_return_its_result' function which may be applied
# to such thread objects, and which yields the final result
# computed by the thread:
#
#     result =  sit::wait_for_thread_to_finish_then_return_its_result  my_thread;
#
# Calling 'wait_for_thread_to_finish_then_return_its_result' on a thread T which has not yet
# completed its computation blocks the caller until T terminates.
#
# Thus, a thread exists in one of two states:
#
#   o RUNNING, when it is associated with a queue of blocked
#     threads waiting to read its result value, and
#
#   o DONE, when it is associated with its return value.
#
# 
# 
# 
# Virtual Threads
# ---------------
# 
# "Virtual threads" essentially make our thread wait queues
# available without the bother of having an actual thread.
#
# A virtual thread is created via
#
#      my_virtual_thread =  sit::spawn_virtual_thread ();
#
# Note that no actual function to compute is specified,
# and none ever exists.  But threads which do
#
#     sit::wait_for_thread_to_finish_then_return_its_result  my_virtual_thread;
#
# block just as though it was a regular running thread.
#
# Since there is no actual code running, by default these
# threads would block forever. Consequently, we provide a
#
#     sit::terminate_virtual_thread
#	  #
#         my_virtual_thread;
#
# call which simulates termination of the virtual thread
# and unblocks all threads waiting on its result
# (which is always Void).
#
# Thus, virtual threads facilitate simple kinds of
# manual thread scheduling without having to sink
# all the way to the callcc level.
# 
#
# 
# 
# Stream Proxy Threads
# --------------------
# 
# Since the main purpose of this package is to support
# compiler interaction with multiple compiler subprocesses,
# we need to have have a way for a thread to block
# until input becomes available from a given unix pipe.
# Stream proxy threads answer this need.
#
# A stream proxy thread is created by doing
#
#     my_proxy_thread
#         =
#         sit::spawn_stream_proxy_thread
#	      #
#             (pipe: file::Input_Stream);
#
# where the stream in question is a pipe from
# a fork()ed unix subprocess.   Any thread which
# reads the "result" of such a proxy thread via
#
#     sit::wait_for_thread_to_finish_then_return_its_result  my_proxy_thread;
#
# will then block until input is available from
# that unix subprocess.
#
# Underneath, this is implemented using a unix
# select() / poll() call;  stream proxy threads
# are essentially a graceful way providing
# thread access to select() / poll() functionality.
# 
# 
# 
# Priorities
# ----------
# 
# To provide some minimal control over scheduling
# of runnable threads, we allow threads to specify
# integer priorities by calling
# 
#     sit::wait_for_thread_to_finish_then_return_its_result_running_at_priority  some_priority  some_thread;
# 
# instead of just
# 
#     sit::wait_for_thread_to_finish_then_return_its_result                            some_thread;
# 
# priority.  When multiple threads are ready to run,
# the thread with the highest priority is selected:
#
#     low_priority  = 1;
#     high_priority = 999;
#
#     starting_gun =  sit::spawn_virtual_thread ();
#
#     goes_first  = sit::make_thread .{ sit::wait_for_thread_to_finish_then_return_its_result_running_at_priority high_priority starting_gun;  print "I went first!\n"; };
#     goes_second = sit::make_thread .{ sit::wait_for_thread_to_finish_then_return_its_result_running_at_priority low_priority  starting_gun;  print "I went second.\n"; };
#
#     sit::terminate_virtual_thread  starting_gun;
# 
# The above will result in 'goes_first' and 'goes_second'
# executing in the obvious order.



# IMPLEMENTATION NOTES
# ====================
#
# Since the point of this package is to provide an
# extremely lightweight alternative to the full
# thread-kit package, we keep things simple by
# providing bare-minumum functionality:
#
#    o We do no pre-emption.  The only way
#      for a thread to give up control of
#      the processor is to terminate or
#      call sit::wait_for_thread_to_finish_then_return_its_result on another thread.
#
#    o We do select() / poll() calls to check
#      for input from subprocesses only when
#      sit::wait_for_thread_to_finish_then_return_its_result is called
#      and there are no runnable threads.
#      
#    o For a priority queue we use a simple
#      list maintained using O(N**2) insertion
#      sort.  
#      
# These simplifications work fine for 
#      
#     src/app/makelib/compile/compile-in-dependency-order-g.pkg
#     src/app/makelib/mythryl-compiler-compiler/mythryl-compiler-compiler-g.pkg
#      
# which are written with them in mind, but may
# easily cause problems in general.  For example,
# spewing commands to the subprocesses without
# pausing to read return results from them will
# quickly produce deadlock.
#
# So, in general -- use thread-kit. :)



api Simple_Thread {
    #
    Thread_Void;
	#
	# "Thread_Void" is essentially the same as "Void".
	# We use it to make sure that only
	# "spawn_virtual_thread"-generated
	# threads are going to be explicitly
	# terminated via 'terminate_virtual_thread':


    Simple_Thread(X);					# X is the thread result type.
	#
	# Externally visible
	# type of a thread:

    make_simple_thread
	:
        (Void -> X)
        ->
	Simple_Thread(X);


    # Read result of given thread, if
    # necessary first waiting for it
    # to terminate:
    #
    wait_for_thread_to_finish_then_return_its_result:                     Simple_Thread(X) -> X;			# Waits, then resumes running at low priority. 
    wait_for_thread_to_finish_then_return_its_result_running_at_priority:  Int -> Simple_Thread(X) -> X;		# Waits, then resumes running at given priority.
	#
	# Priority when using               wait_for_thread_to_finish_then_return_its_result_running_at_priority
	# is always higher than when using  wait_for_thread_to_finish_then_return_its_result


    # Create a "thread" which will
    # "terminate" when the given
    # input stream has input ready
    # to be read:
    #
    spawn_stream_proxy_thread
        :
        file::Input_Stream -> Simple_Thread( Void );

    make_wait_queue					# Create a "thread" which will (only) "terminate" when   run_all_threads_in_wait_queue  is called.
        :
        Void -> Simple_Thread( Thread_Void );

    run_all_threads_in_wait_queue
        :
        Simple_Thread( Thread_Void )	# moves to the run queue
	->				# all threads in wait queue.
	Void				# 
        ;                               # 

    reset_thread_manager:     Void -> Void;		# Forget all threads and threads waiting on them.
    no_runnable_threads:      Void -> Bool;		# Check whether there are any (other) runnable threads.
};


stipulate
    package fat =  fate;				# fate			is from   src/lib/std/src/nj/fate.pkg
    package fil =  file;				# file			is from   src/lib/std/src/posix/file.pkg
    package pio =  file::pure_io;			# file::pure_io		is from   src/lib/std/src/io/file-g.pkg
    package tbi =  text_base_io;			# text_base_io		is from   src/lib/std/src/io/text-base-io.pkg
    package wio =  winix::io;				# winix::io		is from   src/lib/std/src/posix/winix-io.pkg
    package wnx =  winix;				# winix			is from   src/lib/std/winix.pkg
herein

    package   simple_thread
    :         Simple_Thread
    {
	Thread_Void = Void;

	# Type for (thread, priority) pairs in our priority queues: 
	#
	Priority_Queue_Entry
	    =
	    (fat::Fate( Void ), Int);


	Thread_State(X)
	  = DONE(X)						# Value of thread. 
	  | RUNNING  List( Priority_Queue_Entry )		# Threads waiting for thread value to be computed. 
	  ;
	    #
	    # Type to hold thread state.
	    # State is initially RUNNING, carrying a list of
	    # threads waiting for the result of this thread.
	    # Once the thread result value is known,
	    # we change the state to DONE(result), and move all
	    # the previously waiting threads to the run queue:

	Simple_Thread(X)
	    =
	    Ref( Thread_State(X) );


	Thread_Priority_Queue					# Type for simple, brain-dead priority queue.  Entries are (thread, priority) pairs.
	    =
	    Ref( List( Priority_Queue_Entry ) );


	fun enqueue  (qref as REF queue, x as (_, x_priority))
	    =
	    # Insert (value, priority) pair x
	    # into priority queue 'qr' via side-effect,
	    # keeping the latter sorted by priority.
	    #
	    qref :=  insert  queue
	    where
		fun insert []
			=>
			[x];

		    insert ((y as (_, y_priority)) ! rest)				# This results in an idiot O(N**2) insertion sort.  Why not just use a red-black-tree or priority queue? -- 2011-09-21 CrT
			=>
			if (x_priority >= y_priority)   x ! y ! rest;
			else                            y ! insert rest;
			fi;
			#
			# NB: The ">=" is important here. If we had used ">" then
			# the code in mythryl-compiler-compiler-g.pkg would not
			# perform as desired.  In particular, the parser
			# thread would end up being scheduled first,
			# effectively preventing the "cmb" message
			# from being sent to the slaves. (With preemption
			# this would not be a problem.)
		end;
	    end;


	# Pop first entry off priority queue
	# via side-effect, and return the
	# popped entry:
	#
	fun dequeue (REF [])
		=>
		NULL;

	    dequeue (queue_ref as REF (first ! rest))
		=>
		{   queue_ref := rest;
		    #
		    THE first;
		};
	end;

	# Create our priority queue of ready-to-run
	# (thread, priority) pairs, initialized to empty:
	#
	runnable_threads_priority_queue			# XXX BUGGO FIXME more thread-hostile global state :(
	    =
	    (REF []):   Thread_Priority_Queue;

	# Create our list of unix pipe input file descriptors
	# to watch.  Each entry pairs a file descriptor with
	# a proxy Thread which we will "terminate" once there
	# is input available to read from that pipe, and which
	# in the meantime holds the list of threads waiting
	# to read from that pipe:
	#
	unix_pipes_to_watch				# XXX BUGGO FIXME more thread-hostile global state :(
	    =
	    REF ( []:   List( ( Simple_Thread( Void ),
				wio::Poll_Request
			    ) )
		);

	# Reset all state managed by this package:
	#
	fun reset_thread_manager ()
	    =
	    {    runnable_threads_priority_queue :=  [];
		 unix_pipes_to_watch             :=  [];
	    };

	#
	fun no_runnable_threads ()
	    =
	    list::null *runnable_threads_priority_queue;


	# A thread has terminated, returning 'result'.
	#
	# The thread record 'r' holds the list of threads
	# waiting for this thread to terminate.
	#
	# Change the thread state from RUNNING to DONE (result)
	# via side-effect, and move the waiting threads
	# to the run queue:
	#
	fun handle_thread_termination (thread_state as REF (RUNNING waiting_threads), result)
		=>
		{   thread_state :=  DONE result;
		    #
		    apply'
			waiting_threads
			(fn waiting_thread =  enqueue (runnable_threads_priority_queue, waiting_thread));
		};

	    handle_thread_termination (REF (DONE _), _)
		=>
		{   fil::say ["thread terminated twice!\n"];
		    #
		    raise exception FAIL "thread";
		};
	end;

	#
	fun make_wait_queue ()
	    =
	    (REF (RUNNING [])):  Simple_Thread( Thread_Void );

	#
	fun run_all_threads_in_wait_queue (REF (DONE ()))
		 =>
		 ();

	    run_all_threads_in_wait_queue  waiting_threads
		=>
		handle_thread_termination (waiting_threads, ());
	end;

	#
	fun select_on_input_file_descriptors ()
	    =
	    case *unix_pipes_to_watch
		#
		[]  =>  {   fil::say ["deadlock!\n"];
			    #
			    raise exception FAIL "thread";
			};

		subprocesses
		    =>
		    {   # Get a poll list of unix descriptors
			# corresponding to our unix subprocesses: 
			#	
			poll_requests
			    =
			    map #2 subprocesses;



			# Do a Unix-level poll on our child-pid list.
			# Since there is nothing else to do (we are only
			# called if 'runnable_threads_priority_queue' is empty),
			# we can afford to block at the unix process level
			# until at  least one child has exited:
			#	
			poll_results_list
			    =
			    wio::poll_io_descriptors  { poll_requests,  timeout => NULL };

			# Partition our input list into two
			# lists not/ready of those which have/not
			# completed execution:
			#
			fun is_ready (_, poll_request: wio::Poll_Request)
			    =
			    {   fun same_io_descriptor  (poll_result: wio::Poll_Result)
				    =
				    wio::compare
					(
					  poll_request.io_descriptor,
					  poll_result.io_descriptor
					)
					==
					EQUAL;

				list::exists
				    same_io_descriptor
				    poll_results_list;
			    };

			my (ready, not_ready)
			    =
			    list::partition
				is_ready
				subprocesses;


			# Schedule the 'not_ready' pids
			# to be checked again next time around:
			#	
			unix_pipes_to_watch
			    :=
			    not_ready;

			# For each 'ready' list entry (which represents
			# a unix subprocess pipe stream which now has
			# output available for us to read) mark the matching
			# proxy thread as terminated, which moves to the
			# run queue any threads waiting to read its result:
			#
			apply
			    (fn (proxy_thread, _) =  handle_thread_termination (proxy_thread, ()))
			    ready;

			# There should now be a ready-to-run
			# thread in the run queue, since:
			#
			# (1) The above poll doesn't return until a
			#     subprocess has something to read;
			#
			# (2) We then set the thread corresponding
			#     to that subprocess to DONE, which moves all
			#     threads waiting on it to the run queue;
			#
			# (3) There should be at least one such thread
			#     -- that which spawned that unix subprocess.
			#
			# So -- switch to the highest-priority thread in
			#     runnable_threads_priority_queue:
			#
			case (dequeue  runnable_threads_priority_queue)
			    #
			     NULL
				 =>
				 {   fil::say ["src/app/makelib/simple-concurrency/simple-thread.pkg: select_on_input_file_descriptors failed to wake anybody up!\n"];
				   #	
				     raise exception FAIL "thread";
				 };

			     THE (thread_state, _)
				 =>
				 fat::resume_fate thread_state ();
			esac;
		    };
	    esac;


	# Pick next thread to run, and run it. 
	# If we have more than one local ready-to-run
	# thread, we run the highest-priority one of them.
	# Otherwise, we wait for input from one of our
	# forked unix subprocesses:
	#
	fun run_highest_priority_runnable_thread_else_select_on_input_file_descriptors ()
	    =
	    case  (dequeue  runnable_threads_priority_queue)
		#	  
		THE (thread_state, _)
		    =>
		    fat::resume_fate  thread_state ();				# Run local fate. 

		NULL =>   select_on_input_file_descriptors ();			# Wait for Unix-level input. 
	    esac;


	stipulate
	      # Read thread result, with given priority.
	      #
	      # This suspends execution of the current
	      # thread until target thread finishes.
	      #
	      # A thread's priority has no effect while
	      # it is waiting, but becomes its scheduling
	      # priority once it is ready to run -- when
	      # a thread with multiple waiting threads
	      # is fixed, the highest-priority thread
	      # runs first.
	      #
	      # When we do finally run again, the value
	      # of the thread becomes the return value
	      # of the result call:
	      #
	    fun wait_for_thread_to_finish_then_return_its_result_running_at_priority' _ (REF (DONE result))
		    =>
		    # Thread is DONE, just return its result:
		    #
		    result;

		 wait_for_thread_to_finish_then_return_its_result_running_at_priority' priority (thread_state as REF (RUNNING thread_state_list))
		    => 
		    # Thread is not done:  Add ourself to thread's wait
		    # queue and schedule some other thread to run:
		    #
		    {   fat::call_with_current_fate
			    #
			    (fn current_thread
				=
				{   thread_state :=  RUNNING ((current_thread, priority) ! thread_state_list);
				    #
				    run_highest_priority_runnable_thread_else_select_on_input_file_descriptors ();
				}
			    );

			wait_for_thread_to_finish_then_return_its_result_running_at_priority'  priority  thread_state;
		    };
	    end;
	herein

	    #
	    fun wait_for_thread_to_finish_then_return_its_result  thread
		=
		wait_for_thread_to_finish_then_return_its_result_running_at_priority'  0  thread;


	    fun wait_for_thread_to_finish_then_return_its_result_running_at_priority  priority  thread
		=
		wait_for_thread_to_finish_then_return_its_result_running_at_priority'  (priority + 1)  thread;
	end;

	# Fire off an internal thread. 
	#
	# 'thunk_for_thread_to_run' is the thunk
	# to be evaluated by the new thread.
	#
	# Return the matching Thread.
	#
	fun make_simple_thread  thunk_for_thread_to_run
	    =
	    {   new_thread = REF (RUNNING []);        # The value we return to caller.

		# We capture two fates here in succession:
		# o   'return_fate', which is the thread which will return from the 'make_thread' call;
		# o   'thread_fate'  which is the make_simple_thread()ed thread, which will
		#	    1) Evaluate thunk_for_thread_to_run ()
		#	    2) Store thunk_for_thread_to_run()'s result into the returned condition 'c',
		#	       waking any threads waiting on it.
		#	    3) Terminate the thread by calling
		#          run_highest_priority_runnable_thread_else_select_on_input_file_descriptors ().
		# We put 'thread_fate' in the run queue and then
		# have 'make_thread' return 'thread':
		#
		fat::call_with_current_fate
		    #
		    (fn return_fate
			=
			{   fat::call_with_current_fate
				#
				(fn thread_fate
				    =
				    {   enqueue  (runnable_threads_priority_queue,  (thread_fate, -1));
					#
					fat::resume_fate  return_fate  new_thread;
				    }
				);

			    handle_thread_termination (new_thread, thunk_for_thread_to_run ());

			    run_highest_priority_runnable_thread_else_select_on_input_file_descriptors ();
			}
		    );
	    };


						    # lib7			is from   src/lib/std/lib7.pkg

	# Construct and return a "thread"
	# which will "terminate" when the
	# given (unix pipe) input stream
	# has data to be read.
	#
	# As a side effect, we add the returned
	# thread plus the Unix poll descriptor
	# to our unix_pipes_to_watch.
	#
	# We implement the required functionality by
	# polling this list for pending input whenever
	# we have nothing else to do:
	#
	fun spawn_stream_proxy_thread						# Called (only) from   src/app/makelib/simple-concurrency/compile-client.pkg
		#
		(input_stream:  fil::Input_Stream)
	    =
	    {   reader_and_vector
		    =
		    pio::get_reader  (fil::get_instream  input_stream);

		thread
		    =
		    case reader_and_vector
			#
			(tbi::READER { io_descriptor => THE io_descriptor, ... }, "")
			    =>
			    {   thread  =  REF (RUNNING []);
				#
				request = { io_descriptor,
					    readable => TRUE,
					    writable => FALSE,
					    oobdable => FALSE
					  };

				unix_pipes_to_watch
				    :=
				    (thread, request) ! *unix_pipes_to_watch;

				thread;
			    };

			(_, "") =>  {   fil::say ["spawn_stream_proxy_thread: bad stream\n"];
					#
					raise exception FAIL "concur";
				    };

			(_, _)  =>   REF (DONE ());
		    esac;

		fil::set_instream						# Sets input_stream to point to a new REF-cell holding same reader_and_vector as before.
		    (
		      input_stream,
		      pio::make_instream  reader_and_vector			# This allocates a new REF-cell holding reader_and_vector.
		    );

		thread;
	    };			# fun spawn_stream_proxy_thread
    };
end;



## (C) 1999 Lucent Technologies, Bell Laboratories
## Author: Matthias Blume (blume@kurims.kyoto-u.ac.jp)
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################

