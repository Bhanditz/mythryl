## makelib-client-queen.pkg

# Compiled by:
#     src/app/makelib/concurrency/makelib-concurrency.sublib



# This is a simple facility to allow spreading
# the work of a complete 'make' across multiple
# processors on one machine, or even across
# multiple machines sharing a common filesystem,
# using Unix processes connected by pipes and ssh
# connections and such.
#
# Compile servers are unix processes running the
# Mythryl compiler.  We identify compile servers
# using small integer ids issued by next_id(), and
# maintain a global table
#
#     all_makelib_servers
#
# mapping ids to Makelib_Server records.
#
# Basically all we do in this module is to 
# spawn compile server subprocesses on request,
# track currently live subprocesses, and pass
# compile requests to them.
#
# This whole facility is still rather crude and
# not very robust.
#
# In this file we implement the client side of
# the protocol;  the server side is implemented in
#
#     src/app/makelib/main/makelib-server.pkg
#
#
# We are invoked (only) from
#
#     src/app/makelib/mythryl-compiler-compiler/mythryl-compiler-compiler-g.pkg
#     src/app/makelib/main/makelib-g.pkg
#
# which use us to implement parallel compiles during
# a make, to take advantage of multiple CPUs, multiple
# cores, and/or multiple workstations.
#
# For additional discussion, see
#
#     src/app/makelib/doc/13-parallel.tex


# We must (alas!) use weak sealing here;
# otherwise the hack in
#     $ROOT/src/lib/core/makelib/makelib.lib
# fails.


stipulate
    package ad  =  anchor_dictionary;					# anchor_dictionary	is from   src/app/makelib/paths/anchor-dictionary.pkg
    package im  =  int_map;						# int_map		is from   src/app/makelib/stuff/int-map.pkg
    package mtq =  makelib_thread_queen;				# makelib_thread_queen	is from   src/app/makelib/concurrency/makelib-thread-queen.pkg
    package ps  =  posix_signals;					# posix_signals		is from   src/lib/std/src/posix/posix-signals.pkg
    package psx =  posix_1003_1b;					# posix_1003_1b		is from   src/lib/std/src/posix-1003.1b/posix-1003-1b.pkg
    package rs  =  runtime_signals;					# runtime_signals	is from   src/lib/std/src/nj/runtime-signals.pkg
    package spn =  spawn;						# spawn			is from   src/lib/std/src/posix/spawn.pkg
herein

    package   makelib_client_queen
    : (weak)  Makelib_Client_Queen					# Makelib_Client_Queen	is from   src/app/makelib/concurrency/makelib-client-queen.api
    {
	# To allow compiling test versions etc in a
	# different filetree than the default, we
	# we allow optional rewriting of absolute
	# pathnames.  (We presume relative pathnames
	# will stay ok, and that anchored pathnames
	# will be handled by resetting the anchors.)	XXX SUCKO FIXME I'm phasing this stuff out -- 2011-01-07 CrT
	#
	Path_Translator
	    =
	    Null_Or( String -> String ); 

									# spawn			is from   src/lib/std/src/posix/spawn.pkg
									# file			is from   src/lib/std/src/posix/file.pkg
	# This is our internal compile server representation:
	# 
	Makelib_Server
	    =
	    MAKELIB_SERVER
	      {
		id:      Int,						# A small integer uniquely identifying the server. Ids are generated sequentially by next_id().
		name:    String,					# An arbitrary server name. This is used purely human-interface purposes; code operation in no way depends upon it.
		#
		process: spn::Process ( file::Input_Stream,		# Our link to the actual unix-level subprocess.
					file::Output_Stream
				      ),
		#
		path_translator:	Path_Translator,		# See "Path_Translator" comment above. 
		priority:		Int,				# If more than one server is idle (rare), we'll use the one with the numerically highest priority.
		alive:			Ref( Bool ),			# Is underlying unix process still alive and responsive?  Starts FALSE, set to TRUE by shutdown().
		makelib_thread_queen:	mtq::Makelib_Thread_Queen
	      };

	Makelib_Client_Queen
	  =
	  { makelib_thread_queen:	mtq::Makelib_Thread_Queen,
	    #
	    next_id:	Ref(Int),
	    enabled:	Ref(Bool),
	    #	    
	    idle_makelib_servers:	Ref( List( Makelib_Server ) ),
	    #	    
	    threads_waiting_for_a_free_makelib_server:	Ref( mtq::Makelib_Thread(Void) ),
	    #	    
	    all_makelib_servers:	Ref( im::Map(Makelib_Server) )	# Tracks all live compile servers as a map from server.id values to Server records.
	  };

	fun make_makelib_client_queen  makelib_thread_queen
	  =
	  { makelib_thread_queen,
	    #
	    next_id => REF 0,
	    enabled => REF FALSE,
	    #
	    idle_makelib_servers => REF ([]:  List(Makelib_Server)),
	    #
	    threads_waiting_for_a_free_makelib_server  =>  REF (mtq::make_wait_queue  makelib_thread_queen),
	    #
	    all_makelib_servers =>   REF (im::empty:  im::Map(Makelib_Server))		# Tracks all live compile servers as a map from server.id values to Server records.
	  };

	#
	fun makelib_server_name (MAKELIB_SERVER server)
	    =
	    server.name;

	#
	fun mark_as_dead  (MAKELIB_SERVER server)
	    =
	    server.alive := FALSE;


	#
	fun server_input_stream  (MAKELIB_SERVER server) =   (spn::streams_of server.process).from_stream;
	fun server_output_stream (MAKELIB_SERVER server) =   (spn::streams_of server.process).to_stream;



	# A function which returns successive integers
	# on successive calls.
	#
	# We use this to assign unique ids to our
	# compile servers:
	#
	fun next_id  (queen: Makelib_Client_Queen)
	    =
	    {   result =  *queen.next_id;
		#
		queen.next_id  :=   result + 1;
		#
		result;
	    };


	stipulate
	    #
	    fun makelib_server_count (queen: Makelib_Client_Queen)
		=
		im::vals_count  *queen.all_makelib_servers;
	herein
	    #
	    fun all_idle    (queen: Makelib_Client_Queen) =   length (*queen.idle_makelib_servers) == makelib_server_count queen;
	    fun no_servers  (queen: Makelib_Client_Queen) =   makelib_server_count queen == 0;
	    fun all_servers (queen: Makelib_Client_Queen) =   im::vals_list *queen.all_makelib_servers;
	    #
	    fun note_server (queen: Makelib_Client_Queen) (s as MAKELIB_SERVER server)
		=
		{   ns   =  makelib_server_count  queen;							# WTF does this accomplish?
		    #
		    queen.all_makelib_servers
			:=
			im::set (*queen.all_makelib_servers, server.id, s);
		};
	    #
	    fun drop_server (queen: Makelib_Client_Queen) (MAKELIB_SERVER server)
		=
		{   queen.all_makelib_servers
			:=
			#1 (im::drop (*queen.all_makelib_servers, server.id));

		    # If this was the last server, then we need to wake up
		    # everyone who is currently waiting to grab a server.
		    # The "grab"-loop will then gracefully fail and
		    # not cause a deadlock.
		    #
		    if (no_servers queen)
			#
			file::log ["No more servers -> back to sequential mode.\n"];
			#
			mtq::run_all_threads_in_wait_queue  queen.makelib_thread_queen  *queen.threads_waiting_for_a_free_makelib_server;
		    fi;
		};
	end;
									# say			is from   src/lib/std/src/io/say.pkg
									# thread		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread.pkg


	# Translate absolute pathname encoding;
	# relative and anchored paths stay unchanged:
	#
	fun maybe_translate_filename (filename, MAKELIB_SERVER server)
	    =
	    case server.path_translator
		#	  
		NULL          =>    filename;
		#	  
		THE translate =>    if (ad::encoding_is_absolute  filename)
					#
				        translate filename;
				    else          filename;
				    fi;
	    esac;

									# safely		is from   src/lib/std/safely.pkg
									# file			is from   src/lib/std/src/posix/file.pkg
	# Protect some code segments from sigPIPE signals... 
	#
	fun protect_from_sigpipe  work
	    =
	    {   pipe =  ps::sig_pipe;
		#
		fun disable ()  =          rs::set_signal_handler (pipe, rs::IGNORE);
		fun reenable sa =  ignore( rs::set_signal_handler (pipe, sa));

		safely::do
		    { open_it  => disable,
		      close_it => reenable,
		      cleanup  => fn _ = ()
		    }
		    (fn _ = work ());
	    };


	# Send a message to a server. This must be sigPIPE-protected. 
	#
	fun send (s as MAKELIB_SERVER server, msg)
	    =
	    {   output_stream =  server_output_stream  s;
		#
		file::log ["-> ", server.name, " : ", msg];

		protect_from_sigpipe (  fn () =  {  file::write (output_stream, msg);
						    file::flush output_stream;
						 }
						 except _ = ()
				     );
	    };
	#
	fun show_idle  (queen: Makelib_Client_Queen)
	    =
	    file::log ("Idle:" ! fold_right (fn (MAKELIB_SERVER server', l) =  " " ! server'.name ! l)
					    ["\n"]
					    *queen.idle_makelib_servers
		      );



	# Mark a server idle;
	# signal all those who are
	# currently waiting for that:
	#
	fun mark_idle  (queen: Makelib_Client_Queen)  (s as MAKELIB_SERVER server)
	    =
	    {   queen.idle_makelib_servers
		    :=
		    s ! *queen.idle_makelib_servers;
		
	        mtq::run_all_threads_in_wait_queue  queen.makelib_thread_queen *queen.threads_waiting_for_a_free_makelib_server;

	        file::log ["Scheduler: server ", server.name, " has become idle.\n"];

	        show_idle queen;
	    };



									    # say		is from   src/lib/std/src/io/say.pkg
	# Grab an idle server;
	# wait if necessary;
	# reinitialize condition if taking the only server:
	#
	fun grab_idle_server (queen: Makelib_Client_Queen)
	    =
	    # We need to check the following every time (at least the
	    # "no_servers" part) because it might be that all servers
	    # have meanwhile gone away for some reason (crashed, etc.).

    # WE APPEAR TO HAVE AN INFINITE LOOP RUNNING THROUGH HERE :(
	    if (not *queen.enabled  or  no_servers queen)
		#
		NULL;
	    else
		case *queen.idle_makelib_servers
		    #
		    []  =>
			{   # Add ourself to list of threads
			    # waiting for a free compile server:
			    #
			    mtq::wait_for_thread_to_finish_then_return_result  queen.makelib_thread_queen  *queen.threads_waiting_for_a_free_makelib_server;

			    # 2007-10-03 CrT: The below grab_idle_server() call results in
			    # a tight spinloop when all servers
			    # are busy -- which will frequently
			    # be the case in practice!
			    # This whole design sucks, obviously :(                             XXX BUGGO FIXME
			    #
			    # Also, one second is an awfully long
			    # time to sleep, but we apparently don't
			    # currently have a library call capable
			    # of waiting for less than a second
			    # (e.g., I can't find Mythryl-level access to
			    # select().                             XXX BUGGO FIXME       LATER:  select() is available via  winix_io::wait_for_io_opportunity from src/lib/std/src/posix/winix-io.pkg
			    #
			    psx::sleep (time::from_seconds (large_int::from_int 1));		# A quick hack to ameliorate a spinwait loop.

			    grab_idle_server queen;
			};

		    [only as MAKELIB_SERVER only_server]
			=>
			{   file::log ["Scheduler: taking last idle server (",  only_server.name,  ").\n"];

			    queen.idle_makelib_servers := [];

			    queen.threads_waiting_for_a_free_makelib_server :=  mtq::make_wait_queue  queen.makelib_thread_queen;

			    THE only;
			};

		    first ! rest
			=>
			{   fun find_best_server (best_yet, [], tried)
				    =>
				    (best_yet, tried);

				find_best_server (best as MAKELIB_SERVER best_yet, (this as MAKELIB_SERVER this_try) ! untried, tried)
				    =>
				    if (this_try.priority > best_yet.priority)   find_best_server (this, untried, best ! tried);
				    else                                         find_best_server (best, untried, this ! tried);
				    fi;
			    end;

			    (find_best_server (first, rest, []))
				->
				(best as MAKELIB_SERVER best_server,  rest);

			    file::log ["Scheduler: taking idle server (", best_server.name, ").\n"];

			    queen.idle_makelib_servers :=  rest;

			    show_idle  queen;

			    THE best;
			};
		esac;
	    fi;
	#
	fun wait_status  (queen: Makelib_Client_Queen)  { server => s as MAKELIB_SERVER server, echo }
	    =
	    loop []
	    where
		name =  server.name;
		#
		input_stream =   server_input_stream  s;
		#
		fun unexpected l
		    =
		    file::say ("! Unexpected response from server " ! name ! ":" ! fold_right word ["\n"] l)
		    where
		        fun word (w, l)
			    =
			    " " ! w ! l;
		    end;
		#
		fun server_exit ()
		    =
		    {   what =  if  (protect_from_sigpipe
					 (fn () =  spn::reap server.process)   ==   winix::process::success
				)
                                     "shut down";
				else "crashed";
                                fi;

			mark_as_dead  s;
			file::say ["[!Server ", name, " has ", what, ".]\n"];
			drop_server queen s;
		    };

		show =  if echo   fn report =  file::say (reverse report);
			else      fn _      =  ();
                        fi;
		#
		fun loop report
		    =
		    if (not *server.alive)
			#
			FALSE;
		    else
			case (mtq::read_line_from_unix_pipe  queen.makelib_thread_queen  input_stream)				# While waiting yields the process, allowing other Makelib_Threads to run.
			    #
			    NULL => {   server_exit ();
					FALSE;
				    };

			    THE line
				=>
				{   file::log ["<- ", name, ": ", line];

				    case (string::tokens  char::is_space  line)
					#
					["SLAVE:", "ok"   ] =>  {   mark_idle queen s;
								    show report;
								    TRUE;
								};

					["SLAVE:", "error"] =>  {   mark_idle queen s;
								    FALSE;			# Suppress error message because it will be re-enacted locally.
								};

					"SLAVE:" ! l	    =>  {   unexpected l;
								    loop report;
								};

					_   		    =>  {
								    loop (line ! report);
								};
				    esac;
				};
			esac;
		    fi;
	    end;



	# Send a "ping" to all servers and wait for the "pong" responses.
	# 
	# This should work for all servers, busy or no.  Busy servers will
	# take longer to respond because they first need to finish what
	# they are doing.
	#
	# We use wait_all after we receive an interrupt signal.
	#
	# The ping-pong protocol does not suffer from
	# the race condition that we would have if we wanted
	# to only wait for "ok"s from currently busy servers.
	#
	# The race would happen when an interrupt occurs between receiving
	# "ok" and marking the corresponding server idle).
	#
	fun wait_all  (queen: Makelib_Client_Queen)  narrate_to_stdout
	    =
	    {   all =  all_servers queen;
		#
		fun ping (s as MAKELIB_SERVER server)
		    =
		    {   name =  server.name;

			input_stream
			    =
			    server_input_stream  s;


								    # thread	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread.pkg
								    # file	is from   src/lib/std/src/posix/file.pkg
								    # say	is from   src/lib/std/src/io/say.pkg
								    # string	is from   src/lib/std/string.pkg
								    # list	is from   src/lib/std/src/list.pkg

			#
			fun loop ()
			    =
			    if *server.alive
				#
				case (mtq::read_line_from_unix_pipe  queen.makelib_thread_queen  input_stream)			# While waiting this yields the process, allowing other Makelib_Threads to run.
				    #
				    NULL
					=>
					file::log ["<-(EOF) ", name, "\n"];     #  server has gone away -> no pong 

				    THE line
					=>
					{   file::log ["<- ", name, ": ", line];

					    case (string::tokens  char::is_space  line)
						#
						["SLAVE:", "pong"] =>  ();
						_                  =>  loop ();
					    esac;
					};
				esac;
			    fi;

			send (s, "ping\n");
			loop ();
		    };

		threads_waiting_for_a_free_makelib_server'
		    =
		    mtq::make_wait_queue queen.makelib_thread_queen;

		if (not (list::null all))
		    #
		    mtq::run_all_threads_in_wait_queue  queen.makelib_thread_queen  threads_waiting_for_a_free_makelib_server';

		    if narrate_to_stdout   file::say ["Waiting for attached servers to become idle...\n"];   fi;
		fi;

		apply ping all;

		queen.idle_makelib_servers :=  all;

		queen.threads_waiting_for_a_free_makelib_server
		    :=
		    threads_waiting_for_a_free_makelib_server';
	    };
	#
	fun shutdown (queen: Makelib_Client_Queen)  (s as MAKELIB_SERVER server, method')
	    =
	    if *server.alive
		#
		method' ();
		#
		wait_for_exit ()
		where
		    fun unidle ()
			=
			queen.idle_makelib_servers
			    :=
			    #2 (   list::partition 
				       (fn MAKELIB_SERVER s' =   s'.id == server.id)
				       *queen.idle_makelib_servers
			       );
		    #
		    fun wait_for_exit ()
			=
			{   unidle ();
			    ignore (wait_status queen { server => s, echo => FALSE });

			    if *server.alive
				#		        
				wait_for_exit ();
			    fi;
			};
		end;
	    fi;

					###################################################################
					#                         "If any question why we died,
					#                          Tell them, because our fathers lied."
					#
					#                                           -- Rudyard Kipling
					###################################################################


							    # spawn	is from   src/lib/std/src/posix/spawn.pkg
	#
	fun stop_makelib_server (queen: Makelib_Client_Queen) (s as MAKELIB_SERVER _     )   =   shutdown queen (s, fn () =  send (s, "shutdown\n"));
	fun kill_makelib_server (queen: Makelib_Client_Queen) (s as MAKELIB_SERVER server)   =   shutdown queen (s, fn () =  spn::kill (server.process, psx::signal::term));


	# This function is (only) invoked
	# by   start_a_makelib_server
        # and  start_makelib_servers
	# in
	#     src/app/makelib/main/makelib-g.pkg
	# 
	# A typical invocation would be
	# 
	#    makelib::makelib_server::start_a_makelib_server
	#        {
	#          name            =>  "A",
	#          path_translator =>  NULL,
	#          priority        =>  0,
	#          cmd             =>  ("/path/to/bin/mythryld", ["--compile-server"])
	#        };
	# 
	fun start_makelib_server
	    #
	    (queen: Makelib_Client_Queen) 
	    #
	    { name,			# String name for server.  Arbitrary, used to label server output for human consumption.
	      cmd,			# E.g. ("/usr/bin/foo", ["-x", "this", "that"])  --  command passed to spn::execute.
	      path_translator,		# Usually NULL, used to translate filenames on remote compile servers with different directory trees.
	      priority			# Integer priority affecting which compile server to use if more than one is idle (rare).
	    }
	    =
	    {   process =  spn::spawn_process  cmd;
		#
		id      =  next_id  queen;

		server  =   MAKELIB_SERVER
			      { id,
				name,
				process,
				#
				path_translator,
				priority,
				#
				alive => REF TRUE,
				makelib_thread_queen => queen.makelib_thread_queen
			      };

		if (wait_status  queen  { server, echo => FALSE })
		    #                
		    note_server  queen  server;
		    THE server;
		else
		    NULL;
		fi;
	    };

	#
	fun compile_api_or_pkg_file
		#
		(queen: Makelib_Client_Queen)
		#
		(sourcefile_name:  String)					# Full path for   foo.api   or   foo.pkg   file to compile.
	    =
	    case (grab_idle_server queen)
		#	  
		NULL =>   FALSE;
		#
		THE (server as MAKELIB_SERVER s)
		    =>
		    {   filename =  maybe_translate_filename (sourcefile_name, server);
			file::say ["[(", s.name, "): compiling ", filename, "]\n"];
			send (server, cat ["compile ", filename, "\n"]);
			wait_status  queen  { server, echo => TRUE };
		    };
	    esac;										# say		is from   src/lib/std/src/io/say.pkg

	#
	fun reset_makelib_server
		#
		(queen: Makelib_Client_Queen)
		#
		narrate_to_stdout
	    =
	    {   mtq::reset_thread_manager  queen.makelib_thread_queen;
		#
		wait_all  queen  narrate_to_stdout;
	    };

	#
	fun start_all_makelib_servers
		#	
		(queen: Makelib_Client_Queen)
		#	
		start_fn
	    =
	    {   servers =  *queen.idle_makelib_servers;
		#
		queen.idle_makelib_servers :=  [];

		server_threads
		    =
		    map'
			servers
			(fn server =  mtq::make_makelib_thread  queen.makelib_thread_queen  .{ start_fn server; });

		safely::do									# safely	is from   src/lib/std/safely.pkg
                  {
		    open_it  =>  fn () = (),
		    close_it =>  fn () = (),
		    cleanup  =>  (reset_makelib_server queen)
		  } .{
		    apply'  server_threads   (mtq::wait_for_thread_to_finish_then_return_result  queen.makelib_thread_queen);
                  };
	    };


	# Handle changes in current working directory:
	#
	fun change_directory
		#
		(queen: Makelib_Client_Queen)
		#
		directory				# "cd" == "change directory"
	    =
	    start_all_makelib_servers  queen  st
	    where
		fun st server
		    =
		    {   directory' =  maybe_translate_filename (directory, server);
			#
			send (server, cat ["cd ", directory', "\n"]);
			#
			ignore (wait_status queen { server, echo => FALSE });
		    };
	    end;


	# This is called from makelib_g in
	#
	#     src/app/makelib/main/makelib-g.pkg
	#
	# as part of set-up for doing makes:
	#
	fun set_up_all_makelib_servers_for_new_make
		#
		(queen: Makelib_Client_Queen)
		#
		{
		  platform: String,			#  "intel32-linux" or such.                         
		  libfile:  String			#  Sourcefile path for the project .lib file. 
		}
	    =
	    start_all_makelib_servers  queen  st
	    where
		fun st server
		    =
		    {   localized_libfile_name   =   maybe_translate_filename (libfile, server);
			#
			send (server, cat ["cm ", platform, " ", localized_libfile_name, "\n"]);
			#
			ignore  (wait_status  queen  { server, echo => FALSE });
		    };
	    end;

	#
	fun make_compiler
	      #	
	      (queen: Makelib_Client_Queen)
	      #	
              { generated_filename_infix,	# Normally "";   if this is (e.g.) ".pwrpc32-macos", instead of "foo.pkg.compiled" we'll generate "foo.pkg.pwrpc32-macos.compiled".
		platform,			#  "intel32-linux" or such -- architecture+OS.
	        root				# Always "src/etc/mythryl-compiler-root.lib", root .lib file for the complete compiler.
	      }
	    =
	    start_all_makelib_servers  queen  st
	    where
		fun st server
		    =
		    {   send (server, cat ["cmb ", generated_filename_infix, " ", platform, " ", root, "\n"]);
			#
			ignore  (wait_status  queen  { server, echo => FALSE });
		    };

	    end;

	#
	fun make_compiler_reset
	      #	
	      (queen: Makelib_Client_Queen)
	      #	
              {
		platform				#  "intel32-linux" or such. 
	      }
	    =
	    start_all_makelib_servers  queen  st
	    where
		fun st server
		    =
		    {   send (server, cat ["cmb_reset ", platform, "\n"]);
			#
			ignore (wait_status  queen  { server, echo => FALSE });
		    };

	    end;
	#
	fun enable  (queen: Makelib_Client_Queen)   =   queen.enabled := TRUE;
	fun disable (queen: Makelib_Client_Queen)   =   queen.enabled := FALSE;
	#
	fun with_servers
		#	
		(queen: Makelib_Client_Queen)
		#
		(function: Void -> X)
	    =
	    safely::do				# safely	is from   src/lib/std/safely.pkg
		{
		  open_it  =>  fn () = enable  queen,
		  close_it =>  fn () = disable queen,
		  cleanup  =>  reset_makelib_server queen
		}
		function;



	#                           "Too much work and too much energy
	#                            kill a man just as effectively as
	#                            too much assorted vice or too much drink."
	#
	#                                           -- Rudyard Kipling



#										my _ =
#	ad::add_cwd_watcher  change_directory;					# "cwd" == "current working directory"


    };
end;

## (C) 1999 Lucent Technologies, Bell Laboratories
## Author: Matthias Blume (blume@kurims.kyoto-u.ac.jp)
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################
