## one-word-int-loop.pkg
#
# First benchmark implemented;  Basic test of untagged-int arithmetic speed.

# Compiled by:
#     src/app/benchmarks/benchmarks.lib

stipulate
    package bj  =  benchmark_junk;						# benchmark_junk	is from   src/app/benchmarks/benchmark-junk.pkg
    package i1w =  one_word_int;						# one_word_int		is from   src/lib/std/one-word-int.pkg
herein

    package one_word_int_loop:   Benchmark  {					# Benchmark		is from   src/app/benchmarks/benchmark.api
	#
	fun run arg								# We always pass in an arg, to make sure the compiler can't treat the benchmark as a constant expression.
	    =
	    bj::time_run
		#
		"src/app/benchmarks/one-word-int-loop.pkg"			# Benchmark name for reporting purposes.
		#
		.{
		    one_billion =  i1w::from_int (1000 * 1000 * 1000);		# Actually, integer constants are typeagnostic, but let's be totally explicit here.

		    fun inner_loop (0, result)
			    =>
			    result;
			
			inner_loop (i: i1w::Int, result: i1w::Int)
			    =>
			    if ((i & 1) == 0)  inner_loop (i - 1, result - 1);	# The only point of this is to make 'result' something the optimizer won't optimize away.
			    else               inner_loop (i - 1, result + 1);
			    fi;
		    end;

		    fun outer_loop (0: i1w::Int, result: i1w::Int) =>  result;
			outer_loop (i: i1w::Int, result: i1w::Int) =>  inner_loop (1000 * 1000 * 1000, result);
		    end;

		    arg =  i1w::from_int  arg;

		    result = outer_loop  (arg,  i1w::from_int 0);

		    i1w::to_int  result;					# We always return a result, to make sure the compiler can't treat the benchmark as dead code.
		};
    };
end;