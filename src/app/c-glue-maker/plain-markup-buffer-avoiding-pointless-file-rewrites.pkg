## plain-markup-buffer-avoiding-pointless-file-rewrites.pkg

# Compiled by:
#     src/app/c-glue-maker/c-glue-maker.lib



#    A simple pretty-printing device that eventually writes to a
#    text file unless the current contents of that file coincide
#    with what was written.


stipulate
    package fil =  file__premicrothread;				# file__premicrothread	is from   src/lib/std/src/posix/file--premicrothread.pkg
herein

    package plain_markup_buffer_avoiding_pointless_file_rewrites
    : (weak)
    api {
	include Markup_Buffer;						# Markup_Buffer	is from   src/lib/prettyprint/big/src/markup-buffer.api

	open:  (String, Int) -> Markup_Buffer;
	close:  Markup_Buffer -> Void;

    }
    {

	Markup_Buffer = MARKUP_BUFFER  { filename: String,
			markup_buffer:   Ref(  List(  String ) ),
			wid:      Int
		      };

	Textstyle = Void;		    #  Bo textstyle support 

	fun same_textstyle    _ = TRUE;
	fun push_textstyle    _ = ();
	fun pop_textstyle     _ = ();
	fun default_textstyle _ = ();


	#  Allocate an empty markup_buffer and remember the file name. 

	fun open (f, w)
	    =
	    MARKUP_BUFFER { filename => f,
		  markup_buffer   => REF [],
		  wid      => w
		};

	# Calculate the final output and
	# compare it with the current
	# contents of the file.
	#
	# If they differ, write the file:

	fun close (MARKUP_BUFFER { markup_buffer => REF l, filename, ... } )
	    =
	    {   s =   cat (reverse l);

		fun write ()
		    =
		    {   f = fil::open_for_write filename;
			fil::write (f, s);
			fil::close_output f;
		    };

		{   f = fil::open_for_read filename;
		    s' = fil::read_all f;

		    fil::close_input f;

		    if (s != s')    write ();    fi;
		}
		except
		    _ = write ();
	    };

	# Maximum printing depth (in terms of boxes) 
	#
	fun depth _ = NULL;

	# The width of the device 
	#
	fun line_width (MARKUP_BUFFER { wid, ... } ) = THE wid;

	# The suggested maximum width of text on a line 
	#
	fun text_width _ = NULL;

	# Write a string/character in the current textstyle to the device 
	#
	fun string (MARKUP_BUFFER { markup_buffer, ... }, s)
	    =
	    markup_buffer := s ! *markup_buffer;

	fun char (d, c) = string (d, string::from_char c);
	fun space (d, n) = string (d, number_string::pad_left ' ' n "");
	fun newline d = string (d, "\n");

	fun flush d = ();
    };
end;


## (C) 2002, Lucent Technologies, Bell Labs
## author: Matthias Blume (blume@research.bell-labs.com)
