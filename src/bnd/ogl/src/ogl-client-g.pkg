# ogl-client-g.pkg
#
# Here we handle the low-level Ogl-binding functionality
# common to our Ogl-in-main-process and Ogl-in-subprocess
# implementations;  the functionality specific to those two
# is handled by ogl_client_driver_for_library_in_main_process and ogl_client_driver_for_library_in_c_subprocess.			# ogl_client_driver_for_library_in_main_process		is from   src/bnd/ogl/src/ogl-client-driver-for-library-in-main-process.pkg
#																	# ogl_client_driver_for_library_in_c_subprocess		is from   src/bnd/ogl/src/ogl-client-driver-for-library-in-c-subprocess.pkg

# Compiled by:
#     src/lib/std/standard.lib

# Autogeneration of parts of this file done by:
#
#     src/bnd/ogl/sh/make-ogl-glue
# per src/bnd/ogl/etc/library-binding.specification

# Unit tests in:
#     src/bnd/ogl/src/test/ogl-client-for-library-in-c-subprocess-unit-test.pkg

# Compare with:
#     src/bnd/ogl/src/easy-ogl.pkg

# The other end of the pipe is implemented in:
#
#     src/bnd/ogl/c/in-sub/mythryl-ogl-library-in-c-subprocess.c
#
# See the comments in that file for a description
# of the pipe protocol used.



###		"Each design decision constrains all subsequent
###              design decisions, making each successive design
###              problem harder to solve.  Tackle the hardest
###              design problems first, when you have the greatest
###              freedom to maneuver."


# This generic is invoked once each for
# our Ogl-in-main-processs
# and Ogl-in-subprocess
# implementations:
#
#     src/bnd/ogl/src/ogl-client-for-library-in-main-process.pkg
#     src/bnd/ogl/src/ogl-client-for-library-in-c-subprocess.pkg
#
#
generic package   ogl_client_g   (
    #             ===== 
    drv: Ogl_Client_Driver								# Ogl_Client_Driver		is from   src/bnd/ogl/src/ogl-client-driver.api
	#
	# When called by ogl-client-for-library-in-main-process.pkg	drv == ogl_client_driver_for_library_in_main_process		# ogl_client_driver_for_library_in_main_process		is from   src/bnd/ogl/src/ogl-client-driver-for-library-in-main-process.pkg
	# When called by ogl-client-for-library-in-c-subprocess.pkg	drv == ogl_client_driver_for_library_in_c_subprocess		# ogl_client_driver_for_library_in_c_subprocess		is from   src/bnd/ogl/src/ogl-client-driver-for-library-in-c-subprocess.pkg
)
:
Ogl_Client									# Ogl_Client		is from   src/bnd/ogl/src/ogl-client.api
{
    include ogl_event;								# ogl_event		is from   src/bnd/ogl/src/ogl-event.pkg

# Do not edit this or following lines -- they are autobuilt by make-library-binding.

   #  
# Do not edit this or preceding lines -- they are autobuilt by make-library-binding.

    package int_map =  int_red_black_map;

    Session = { subsession:   drv::Session,
		#
		callback_map:   { void:            Ref( int_map::Map( Void            -> Void )),
				  bool:            Ref( int_map::Map( Bool            -> Void )),
				  float:           Ref( int_map::Map( Float           -> Void ))
				}
				#
				# The callback maps let us find the appropriate
				# Mythryl callback function to run when our Ogl
				# server process says to run callback #127 or such.
				#
				# To keep the typechecker happy we need a separate
				# map for each callback type.
	      };

    #
#    fun set_easy_id (session: Session, id, widget)
#        =
#        session.widgets_by_easy_id
#            :=
#            string_map::set( *session.widgets_by_easy_id, id, widget );

    #
#    fun drop_easy_id (session: Session, id)
#        =
#        session.widgets_by_easy_id
#            :=
#            #1 (string_map::drop (*session.widgets_by_easy_id, id ) );

    #
#    fun get_by_easy_id (session: Session, id)
#        =
#        the (string_map::get( *session.widgets_by_easy_id, id ) );
#


    stipulate


    herein




	#
#	fun run_eventloop_indefinitely (session: Session)
#            =
#            drv::run_eventloop_indefinitely session.subsession;
#
	#
#	fun run_eventloop_once { session: Session, block_until_event: Bool }
#            =
#            drv::run_eventloop_once (session.subsession, block_until_event);
#

	#
        fun make_session []
		=>
		{   callback_map  =   { void            =>  REF (int_map::empty:   int_map::Map( Void            -> Void )),
					bool            =>  REF (int_map::empty:   int_map::Map( Bool            -> Void )),
					float           =>  REF (int_map::empty:   int_map::Map( Float           -> Void ))
#					button_event    =>  REF (int_map::empty:   int_map::Map( Button_Event    -> Void )),
#					motion_event    =>  REF (int_map::empty:   int_map::Map( Motion_Event    -> Void )),
#					key_event       =>  REF (int_map::empty:   int_map::Map( Key_Event       -> Void )),
#					expose_event    =>  REF (int_map::empty:   int_map::Map( Expose_Event    -> Void )),
#					configure_event =>  REF (int_map::empty:   int_map::Map( Configure_Event -> Void ))
				      };

		    subsession =  drv::make_session  callback_map;

		    session = { subsession,
				callback_map
#				widget_tree	    =>  REF 0,
#				widgets_by_easy_id  =>  REF string_map::empty
			      };

		    session;
		};

            make_session (arg ! args)
		=>
		raise exception FAIL "make_session: args not supported yet.";
	end;

# Do not edit this or following lines -- they are autobuilt by make-library-binding.

        #
 
 
    # Handlers for X events :		http://library.gnome.org/devel/gtk-tutorial/stable/x182.html
    #
 
    # Callbacks taking a boolean argument:
    #

        #
        fun print_hello_world (session: Session)
            =
            drv::print_hello_world  session.subsession;
            
            # Above function autobuilt by src/lib/make-library-binding/make-library-binding.pkg:  write_plain_fun_to_'xxx_client_g_pkg'  per  src/bnd/ogl/etc/library-binding.specification.

# Do not edit this or preceding lines -- they are autobuilt by make-library-binding.

	#
#	fun get_widget_allocation (session: Session, widget)
#	    =
#	    {   my (x, y, wide, high)
#		    =
#		    drv::get_widget_allocation (session.subsession, widget);
#
#		{ x, y, wide, high };
#	    };

	#
#        fun make_dialog (session: Session)
#            =
#	    {   my (dialog, vbox, action_area)
#		    = 
#                    drv::make_dialog  session.subsession;
#
#		{ dialog, vbox, action_area };
#            };

	#
#        fun set_widget_tree  (session: Session,  widget)
#            =
#            session.widget_tree := widget;

	#
#        fun quit_eventloop  (session: Session)
#            =
#            drv::quit_eventloop  session.subsession;
#
#	fun unref_object (session: Session, widget)
#            =
#            drv::unref_object (session.subsession, widget);
#
    end;

#    stipulate
#	include eight_byte_float;
#    herein
#	fun clamp { min, max, value }
#	    =
#	    if   (value < min)   min;
#	    elif (value > max)   max;
#	    else                 value;
#    	    fi;
#    end;
};




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
