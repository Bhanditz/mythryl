## make-library-binding.pkg
#
#
#
# BIGGEST PROBLEM AT PRESENT IS THAT ALL THE 'widget' STUFF IS GTK-SPECIFIC.  --2013-01-13 CrT
#
# The offending functions are:
#
#	fun build_fun_arg_loads_into_'mythryl_xxx_library_in_c_subprocess_c' (fn_name, args, libcall)
#	fun write_plain_fun_to_'mythryl_xxx_library_in_c_subprocess_c'
#	fun build_fun_arg_loads_into_'libmythryl_xxx_c' (fn_name, fn_type, args, libcall)
#	fun build_fun_body_for_'libmythryl_xxx_c'
#	fun build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c' (callback_name, lowtype)
#	fun build_set_callback_fn_for_'libmythryl_xxx_c'
#
# The latter two above are the most problematic because they will always
# build code including the string "GtkWidget".
#
#
#
# Autobuild much of the code required
# to make a C library like Gtk or OpenGL
# available at the Mythryl level, driven
# by a library-binding.specification file.
#
# The format of library-binding-specification
# files is documents in Note[1] at bottom of file.
#
# make-library-binding.pkg really shouldn't be in
# standard.lib because it is not of general interest,
# but at the moment that is the path of least
# resistance.    -- 2013-01-12 CrT

# Compiled by:
#     src/lib/std/standard.lib

api      Make_Library_Binding
{
    Path =  {   library_binding_specification				:  String,		# E.g. "src/bnd/gtk/etc/library-binding.specification"
		lib_name						:  String,		# E.g. "ogl" -- Must match the   #define CLIB_NAME "ogl"   line in   src/bnd/xxx/c/in-main/libmythryl-xxx.c
												# Files which will be patched:
		xxx_client_api						:  String,		# E.g. "src/bnd/gtk/src/gtk-client.api"
		xxx_client_g_pkg					:  String,		# E.g. "src/bnd/gtk/src/gtk-client-g.pkg"
		xxx_client_driver_api					:  String,		# E.g. "src/bnd/gtk/src/gtk-client-driver.api"
		xxx_client_driver_for_library_in_c_subprocess_pkg	:  String,		# E.g. "src/bnd/gtk/src/gtk-client-driver-for-library-in-c-subprocess.pkg"
		xxx_client_driver_for_library_in_main_process_pkg	:  String,		# E.g, "src/bnd/gtk/src/gtk-client-driver-for-library-in-main-process.pkg"
		mythryl_xxx_library_in_c_subprocess_c			:  String,		# E.g. "src/bnd/gtk/c/in-sub/mythryl-gtk-library-in-c-subprocess.c"
		libmythryl_xxx_c					:  String,		# E.g. "src/bnd/gtk/c/in-main/libmythryl-gtk.c"
		section_libref_xxx_tex					:  String		# E.g., "doc/tex/section-libref-gtk.tex";
	    };

    make_library_binding: Path -> Void;
};

stipulate
    package fil =  file__premicrothread;							# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package lms =  list_mergesort;								# list_mergesort		is from   src/lib/src/list-mergesort.pkg
    package iow =  io_wait_hostthread;								# io_wait_hostthread		is from   src/lib/std/src/hostthread/io-wait-hostthread.pkg
    package psx =  posixlib;									# posixlib			is from   src/lib/std/src/psx/posixlib.pkg
    #
    exit_x = winix__premicrothread::process::exit_x;
    =~          =  regex::(=~);
    sort	=  lms::sort_list;
    chomp	=  string::chomp;
    tolower     =  string::to_lower;
    uniquesort  =  lms::sort_list_and_drop_duplicates;

    fun isfile     filename
	=
	psx::stat::is_file      (psx::stat  filename)  except _ = FALSE;

    #
    fun die_x message
	=
	{   print message;
	    exit_x 1;
	};



    # The following are all duplicates of definitions in
    #     src/app/makelib/main/makelib-g.pkg
    # -- possibly a better place should be found
    # for them:

    # Convert    src/bnd/xxx/c/in-sub/mythryl-xxx-library-in-c-subprocess.c
    # to                              mythryl-xxx-library-in-c-subprocess.c
    # and such:
    #
    fun basename filename
	=
	(regex::find_first_group 1 .|/([^/]+)$| filename)
	except
	    NOT_FOUND = filename;

    # Convert    src/bnd/xxx/c/in-sub/mythryl-xxx-library-in-c-subprocess.c
    # to         src/bnd/xxx/c/in-sub
    # and such:
    #
    fun dirname filename
	=
	(regex::find_first_group 1 .|^(.*)/[^/]+$| filename)
	except
	    NOT_FOUND = ".";								# This follows linux dirname(1), and also produces sensible results.

    # Drop leading and trailing
    # whitespace from a string.
    #
    fun trim string
	=
	{   =~ = regex::(=~);

	    if (string =~ ./^\s*$/)

		"";

	    else
		# Drop trailing whitespace:
		#
		string
		    =
		    (regex::find_first_group 1 ./^(.*\S)\s*$/ string)
		    except
			NOT_FOUND = string;

		# Drop leading whitespace:
		#
		string
		    =
		    (regex::find_first_group 1 ./^\s*(\S.*)$/ string)
		    except
			NOT_FOUND = string;

		string;
	    fi;
	};
herein

    package  make_library_binding:
	     Make_Library_Binding
    {
	Path =    { library_binding_specification			:  String,
		    lib_name					:  String,		# E.g. "ogl" -- try to make it 3 chars for symmetry. Must be legal in an identifier.
		    #
		    xxx_client_api					:  String,
		    xxx_client_g_pkg					:  String,
		    xxx_client_driver_api				:  String,
		    xxx_client_driver_for_library_in_c_subprocess_pkg	:  String,
		    xxx_client_driver_for_library_in_main_process_pkg	:  String,
		    mythryl_xxx_library_in_c_subprocess_c		:  String,
		    libmythryl_xxx_c					:  String,
		    section_libref_xxx_tex				:  String
		  };

	fun make_library_binding  (path: Path)
	    =
	    {
		xxx_client_driver_api					=  read_patchable_file   path.xxx_client_driver_api;
		xxx_client_driver_for_library_in_c_subprocess_pkg	=  read_patchable_file   path.xxx_client_driver_for_library_in_c_subprocess_pkg;
		xxx_client_driver_for_library_in_main_process_pkg	=  read_patchable_file   path.xxx_client_driver_for_library_in_main_process_pkg;
		xxx_client_g_pkg					=  read_patchable_file   path.xxx_client_g_pkg;
		xxx_client_api						=  read_patchable_file   path.xxx_client_api;
		mythryl_xxx_library_in_c_subprocess_c			=  read_patchable_file   path.mythryl_xxx_library_in_c_subprocess_c;
		libmythryl_xxx_c					=  read_patchable_file   path.libmythryl_xxx_c;



		process_library_binding_specification_file    ();



		printf "%4d   plain     functions autobuilt for %s\n"		*plain_fns_autobuilt_for_'libmythryl_xxx_c'					(basename  path.libmythryl_xxx_c);
		printf "%4d   callback  functions autobuilt for %s\n"		*callback_fns_autobuilt_for_'libmythryl_xxx_c'				(basename  path.libmythryl_xxx_c);

		printf "%4d   plain     functions autobuilt for %s\n"		*plain_fns_autobuilt_for_'mythryl_xxx_library_in_c_subprocess_c'		(basename  path.mythryl_xxx_library_in_c_subprocess_c);
		printf "%4d   callback  functions autobuilt for %s\n"		*callback_fns_autobuilt_for_'mythryl_xxx_library_in_c_subprocess_c'		(basename  path.mythryl_xxx_library_in_c_subprocess_c);

		printf "%4d   plain     functions autobuilt for %s\n"		*plain_fns_autobuilt_for_'xxx_client_g_pkg'					(basename  path.xxx_client_g_pkg);
		printf "%4d   plain     functions handbuilt for %s\n"		*plain_fns_handbuilt_for_'xxx_client_g_pkg'					(basename  path.xxx_client_g_pkg);

		printf "%4d   callback  functions autobuilt for %s\n"		*callback_fns_handbuilt_for_'xxx_client_g_pkg'				(basename  path.xxx_client_g_pkg);
		printf "%4d   callback  functions handbuilt for %s\n"		*callback_fns_handbuilt_for_'xxx_client_g_pkg'				(basename  path.xxx_client_g_pkg);



		write_patchable_file  xxx_client_driver_api				  [ INTRON (reverse *intron_for_'xxx_client_driver_api')				];
		write_patchable_file  xxx_client_driver_for_library_in_c_subprocess_pkg   [ INTRON (reverse *intron_for_'xxx_client_driver_for_library_in_c_subprocess_pkg')	];
		write_patchable_file  xxx_client_driver_for_library_in_main_process_pkg   [ INTRON (reverse *intron_for_'xxx_client_driver_for_library_in_main_process_pkg')	];

		write_patchable_file  xxx_client_api					  [ INTRON (reverse *types_intron_for_'xxx_client_api'),
											    INTRON (reverse *funs_intron_for_'xxx_client_api')
											  ];

		write_patchable_file  xxx_client_g_pkg					  [ INTRON (reverse *types_intron_for_'xxx_client_g_pkg'),
											    INTRON (reverse *funs_intron_for_'xxx_client_g_pkg')
											  ];

		write_patchable_file  mythryl_xxx_library_in_c_subprocess_c		  [ INTRON (reverse *funs_intron_for_'mythryl_xxx_library_in_c_subprocess_c'),
											    INTRON (reverse *trie_intron_for_'mythryl_xxx_library_in_c_subprocess_c')
											  ];

		write_patchable_file  libmythryl_xxx_c					  [ INTRON (reverse *funs_intron_for_'libmythryl_xxx_c'),
											    INTRON (reverse *table_intron_for_'libmythryl_xxx_c')
											  ];



		if (isfile  path.section_libref_xxx_tex)
		    #
		    section_libref_xxx_tex =  read_patchable_file   path.section_libref_xxx_tex;

		    write_section_libref_xxx_tex_table  (.fn_name, .libcall, to_section_libref_xxx_tex_table1);
		    write_section_libref_xxx_tex_table  (.libcall, .fn_name, to_section_libref_xxx_tex_table2);

		    write_patchable_file  section_libref_xxx_tex			  [ INTRON (reverse *table1_intron_for_'section_libref_xxx_tex'),
											    INTRON (reverse *table2_intron_for_'section_libref_xxx_tex')
											  ];
		fi;
	    }
	    where
		plain_fns_autobuilt_for_'libmythryl_xxx_c'    =  REF 0;
		callback_fns_autobuilt_for_'libmythryl_xxx_c' =  REF 0;

		plain_fns_autobuilt_for_'mythryl_xxx_library_in_c_subprocess_c'     =  REF 0;
		callback_fns_autobuilt_for_'mythryl_xxx_library_in_c_subprocess_c'  =  REF 0;

		plain_fns_handbuilt_for_'xxx_client_g_pkg'     =  REF 0;
		plain_fns_autobuilt_for_'xxx_client_g_pkg'     =  REF 0;

		callback_fns_handbuilt_for_'xxx_client_g_pkg'  =  REF 0;
		callback_fns_handbuilt_for_'xxx_client_g_pkg'  =  REF 0;


		# Lists of synthesized code strings to
		# be inserted in the above files.  Most
		# files have just one such insertion point
		# ("intron") but some have two, for example
		# one for synthesized type declarations
		# and one for synthesized functions.
		#
		# These will all be in reverse
		# order while being contructed:
		#
		intron_for_'xxx_client_driver_api'				=  REF ([]: List(String));
		intron_for_'xxx_client_driver_for_library_in_c_subprocess_pkg'	=  REF ([]: List(String));
		intron_for_'xxx_client_driver_for_library_in_main_process_pkg'	=  REF ([]: List(String));
		funs_intron_for_'xxx_client_api'              			=  REF ([]: List(String));
		types_intron_for_'xxx_client_api'             			=  REF ([]: List(String));
		funs_intron_for_'xxx_client_g_pkg'            			=  REF ([]: List(String));
		types_intron_for_'xxx_client_g_pkg'				=  REF ([]: List(String));
		funs_intron_for_'mythryl_xxx_library_in_c_subprocess_c'		=  REF ([]: List(String));
		trie_intron_for_'mythryl_xxx_library_in_c_subprocess_c'		=  REF ([]: List(String));
		table_intron_for_'libmythryl_xxx_c'				=  REF ([]: List(String));
		funs_intron_for_'libmythryl_xxx_c'				=  REF ([]: List(String));
		table1_intron_for_'section_libref_xxx_tex'			=  REF ([]: List(String));
		table2_intron_for_'section_libref_xxx_tex'			=  REF ([]: List(String));


		# Little functions to prepend
		# strings to the above lists:
		#
		fun to_xxx_client_driver_api					string =   intron_for_'xxx_client_driver_api'					:=  string !  *intron_for_'xxx_client_driver_api';
		fun to_xxx_client_driver_for_library_in_c_subprocess_pkg	string =   intron_for_'xxx_client_driver_for_library_in_c_subprocess_pkg'	:=  string !  *intron_for_'xxx_client_driver_for_library_in_c_subprocess_pkg';
		fun to_xxx_client_driver_for_library_in_main_process_pkg	string =   intron_for_'xxx_client_driver_for_library_in_main_process_pkg'	:=  string !  *intron_for_'xxx_client_driver_for_library_in_main_process_pkg';
		fun to_xxx_client_g_pkg_funs					string =   funs_intron_for_'xxx_client_g_pkg'					:=  string !  *funs_intron_for_'xxx_client_g_pkg';
		fun to_xxx_client_g_pkg_types					string =   types_intron_for_'xxx_client_g_pkg'					:=  string !  *types_intron_for_'xxx_client_g_pkg';
		fun to_xxx_client_api_funs					string =   funs_intron_for_'xxx_client_api'					:=  string !  *funs_intron_for_'xxx_client_api';
		fun to_xxx_client_api_types					string =   types_intron_for_'xxx_client_api'					:=  string !  *types_intron_for_'xxx_client_api';
		fun to_mythryl_xxx_library_in_c_subprocess_c_funs		string =   funs_intron_for_'mythryl_xxx_library_in_c_subprocess_c'		:=  string !  *funs_intron_for_'mythryl_xxx_library_in_c_subprocess_c';
		fun to_mythryl_xxx_library_in_c_subprocess_c_trie		string =   trie_intron_for_'mythryl_xxx_library_in_c_subprocess_c'		:=  string !  *trie_intron_for_'mythryl_xxx_library_in_c_subprocess_c';
		fun to_libmythryl_xxx_c_table					string =   table_intron_for_'libmythryl_xxx_c'					:=  string !  *table_intron_for_'libmythryl_xxx_c';
		fun to_libmythryl_xxx_c_funs					string =   funs_intron_for_'libmythryl_xxx_c'					:=  string !  *funs_intron_for_'libmythryl_xxx_c';
		fun to_section_libref_xxx_tex_table1				string =   table1_intron_for_'section_libref_xxx_tex'				:=  string !  *table1_intron_for_'section_libref_xxx_tex';
		fun to_section_libref_xxx_tex_table2				string =   table2_intron_for_'section_libref_xxx_tex'				:=  string !  *table2_intron_for_'section_libref_xxx_tex';



		# We divide the files we patch into exons and introns
		# according to the scheme
		#
		#        exon
		#        # Do not edit this or following lines -- they are autobuilt by make-library-binding./)
		#        intron
		#        # Do not edit this or preceding lines -- they are autobuilt by make-library-binding./)
		#        exon
		#        
		# where the exons are literal program text provided by the
		# programmer whereas the introns are literal program text
		# which we synthesize.  (The shown 'do not edit' lines are
		# considered part of the exons.)
		#
		# We represent such a file in memory as a list of file
		# segments (that is, exons and introns) where each segment
		# is in turn a list of lines represented as strings:
		#
		File_Segment = EXON   List(String)
			     | INTRON List(String)
			     ;

		Patchable_File
		    =
		    PATCHABLE_FILE {
			filename:  String,
			contents:  List(File_Segment)
		    };


		# Read and return a Patchable_File:
		#
		fun read_patchable_file  filename
		    =
		    {   fd = fil::open_for_read filename
			     except
				io_exceptions::IO _
				    =
				    {   fprintf fil::stderr "Fatal: Unable to open input file '%s'" filename;
					exit_x(1);
				    };
			contents
			    =
			    read_exon ([], [])
			    where
				fun read_exon (segments, lines)
				    =
				    case (fil::read_line  fd)
					#
					NULL => reverse ((EXON (reverse lines)) ! segments);

					THE line
					    =>
					    if (line =~ ./ Do not edit this or following lines -- they are autobuilt by make-library-binding./)

						read_intron ((EXON (reverse (line ! lines))) ! segments, []);
					    else
						read_exon (segments, line ! lines);
					    fi;	
				    esac

				also
				fun read_intron (segments, lines)
				    =
				    case (fil::read_line  fd)
					#
					NULL =>
					    {   fprintf fil::stderr "Fatal: Missing 'Do not edit this or preceding lines' line in %s" filename;
						exit_x(1);
					    };

					THE line
					    =>
					    if (line =~ ./ Do not edit this or preceding lines -- they are autobuilt by make-library-binding./)
						#
						read_exon ((INTRON (reverse lines)) ! segments, [ line ]);
					    else
						read_intron (segments, line ! lines);
					    fi;	
				    esac;
			    end;

			fil::close_input  fd;

			PATCHABLE_FILE { filename, contents };
		    };

		# Write a patchable file back into the filesystem.
		#
		fun write_patchable_file
		    (PATCHABLE_FILE { filename, contents })
		    introns
		    =
		    {   intron_lines_written = REF 0;

			tmp_filename = filename + "~";

			fd = fil::open_for_write  tmp_filename
			     except
				io_exceptions::IO _
				    =
				    {   fprintf fil::stderr "Fatal: Unable to open output file '%s'" tmp_filename;
					exit_x(1);
				    };


			fun write_exon_lines  (line ! rest)
				=>
				{   fil::write (fd, line);
				    #
				    write_exon_lines  rest;
				};

			    write_exon_lines [] =>  ();
			end;


			fun write_intron_lines  (line ! rest)					# Actually 'line' may be just a string (i.e., line fragment).
				=>
				{   fil::write (fd, line);
				    intron_lines_written := *intron_lines_written + 1;		# This is the only difference between us and write_exon_lines.
				    write_intron_lines rest;
				};

			    write_intron_lines  [] =>  ();
			end;


			write_exon (contents, introns)
			where
			    fun write_exon (((EXON lines) ! rest), introns)
				    =>
				    {
					write_exon_lines lines;
					write_intron (rest, introns);
				    };

				write_exon _
				    =>
				    raise exception FAIL "Internal bug";
			    end

			    also
			    fun write_intron ((INTRON _) ! exons, (INTRON lines) ! introns)
				    =>
				    {
					write_intron_lines lines;
					write_exon (exons, introns);
				    };

				write_intron ([], [])
				    =>
				    ();

				write_intron _
				    =>
				    raise exception FAIL "Internal bug";
			    end;
			end;	

			fil::close_output fd;   

			winix__premicrothread::file::remove_file  filename;

			winix__premicrothread::file::rename_file { from => tmp_filename, to => filename };

			printf "Successfully patched %4d lines in %s\n"  *intron_lines_written  filename;
		    };





		# Field is a contiguous sequence of lines
		# all with the same linetype field:
		#
		#    foo:  this
		#    foo:  that
		#
		# Most fields will be single-line, but this format
		# supports conveniently including blocks of code,
		# such as complete function definitions.
		#
		# We treat a field as a single string containing
		# embedded newlines, stripped of the linetype field
		# and the colon.  
		#
		Field = { string:  Ref(String),
			  line_1:  Ref(Int),
			  line_n:  Ref(Int),
			  used:    Ref(Bool)
			};

		State = { line_number:  Ref(Int),

			  fd:           fil::Input_Stream,

			  fields:       Ref( string_map::Map( Field ))
			};

		#
		fun field_location (field: Field)
		    =
		    *field.line_1 == *field.line_n  ??  sprintf "line %d" *field.line_1
						    ::  sprintf "lines %d-%d" *field.line_1 *field.line_n;

		#
		fun maybe_get_field (state: State, field_name)
		    =
		    case (string_map::get (*state.fields, field_name))
			#
			THE field => { field.used := TRUE;  THE *field.string; };
			NULL      => NULL;
		    esac;

		#
		fun get_field (state: State, field_name)
		    =
		    case (string_map::get (*state.fields, field_name))
			#
			THE field => { field.used := TRUE; 
				      *field.string;
				     };

			NULL      => die_x (sprintf "Required field %s missing at line %d\n"  field_name  *state.line_number);
		    esac;

		#
		fun get_field_location (state: State, field_name)
		    =
		    case (string_map::get (*state.fields, field_name))
			#
			THE field => { field.used := TRUE;  field_location field; };
			#
			NULL      => die_x (sprintf "Required field %s missing at line %d\n"  field_name  *state.line_number);
		    esac;

		#
		fun clear_state (state: State)
		    =
		    {   foreach (string_map::keyvals_list *state.fields) .{
			    #
			    #pair -> (field_name, field);

			    if (not *field.used)
				#
				die_x(sprintf "Field %s at %s unsupported.\n"
					     field_name
					     (field_location field)
				    );
			    fi;
			}; 

			state.fields :=  (string_map::empty: string_map::Map( Field ));
		    };




		# libcall contains embedded arguments like w0, i1, f2, b3, s4.
		#
		# The argument letter gives us the argument type:
		#
		#    w == widget
		#    i == int
		#    f == double  (Mythryl "Float")
		#    b == bool
		#    s == string
		#
		# The argument digit gives us the argument order:
		#
		#    0 == first arg
		#    1 == second arg
		#    ...

		# Get list of above args, sorting by trailing digit
		# and dropping duplicates:
		#
		fun get_args  libcall
		    =
		    {	raw_list    =  regex::find_all  ./\b[bfisw][0-9]\b/  libcall;
			#
			cooked_list =  uniquesort  compare_fn  raw_list;

			cooked_list;
		    }
		    where	
			fun compare_fn (xn, yn)					# Compare "w0" and "b1" as "0" and "1":
			    =
			    {   xn' = string::extract (xn, 1, NULL);
				yn' = string::extract (yn, 1, NULL);

				string::compare (xn', yn');
			    };
		    end;        

		# Count number of arguments.
		# We need this for check_argc():
		#
		fun count_args  libcall
		    =
		    list::length (get_args  libcall);

		#
		fun get_nth_arg_type (n, libcall)
		    =
		    {   arg_list =  get_args  libcall;

			if (n <   0
			or  n >=  list::length  arg_list
			)
			    raise exception FAIL (sprintf "get_nth_arg_type: No %d-th arg in '%s'!" n libcall);
			fi;

			arg = list::nth (arg_list, n);		# Fetch "w0" or "i0" or such.

			string::extract (arg, 0, THE 1);	# Convert "w0" to "w" or "i0" to "i" etc.
		    };

		#
		fun arg_types_are_all_unique  libcall
		    =
		    {   # Get the list of parameters,
			# something like [ "w0", "i1", "i2" ]:
			#
			args  =  get_args  libcall;

			# Turn parameter list into type list,
			# something like [ 'w', 'i', 'i' ]:
			#
			types =  map   .{ string::get (#string,0); }   args;

			# Eliminate duplicate types from above:
			#
			types =   uniquesort  char::compare  types;

			# If 'args' is same length as 'types' then
			# all types are unique:
			#
			list::length args  ==  list::length types;
		    };

		#
		fun xxx_client_driver_api_type (libcall, result_type)
		    =
		    {   input_type =  REF "(Session";
			#
			arg_count  =  count_args  libcall;

			for (a = 0;  a < arg_count;  ++a) {
			    #
			    t = get_nth_arg_type( a, libcall );

			    case t
				"b" =>     input_type :=  *input_type  +  ", Bool";
				"i" =>     input_type :=  *input_type  +  ", Int";
				"f" =>     input_type :=  *input_type  +  ", Float";
				"s" =>     input_type :=  *input_type  +  ", String";
				"w" =>     input_type :=  *input_type  +  ", Int/*Widget*/";

				 _  =>     raise exception FAIL (sprintf "Unsupported arg type '%s'" t);
			    esac;
			};

			input_type :=  *input_type  +  ")";


			output_type
			    =
			    case result_type
				#
				"new Widget" =>  "Int /*new Widget*/";
				"Bool"       =>  "Bool";
				"Float"      =>  "Float";
				"Int"        =>  "Int";
				"Widget"     =>  "Int /*Widget*/";
				"Void"       =>  "Void";

				 _           => raise exception FAIL ("xxx_client_driver_api_type: Unsupported result type: " + result_type);
			    esac;

			(*input_type, output_type);
		    };
		#        
		stipulate
		    #
		    line_count = REF 2;

		herein

		    fun write_fun_declaration_to_'xxx_client_driver_api'  (fn_name, libcall, result_type)
			=
			{
			    # Add a blank line every three declarations:
			    #
			    line_count :=  *line_count + 1;
			    #	
			    if ((*line_count % 3) == 0)
				#
				to_xxx_client_driver_api  "\n";
			    fi;

			    to_xxx_client_driver_api  (sprintf  "    %-40s"  (fn_name + ":"));


			    (xxx_client_driver_api_type  (libcall,  result_type))
				->
				(input_type,  output_type);


			    to_xxx_client_driver_api  (sprintf "%-40s -> %s;\n"  input_type  output_type);
			};
		end;






		#
		fun write_do_command (do_command, fn_name, libcall, result_prefix, result_expression)
		    =
		    {
			if (result_expression != "")
			     to_xxx_client_driver_for_library_in_c_subprocess_pkg ("        {   result = " + do_command + " (session");
			else to_xxx_client_driver_for_library_in_c_subprocess_pkg ("        " + do_command + " (session");
			fi;

			if (result_prefix != "") 
			    to_xxx_client_driver_for_library_in_c_subprocess_pkg  (.', "' + result_prefix + .'"');
			fi;

			to_xxx_client_driver_for_library_in_c_subprocess_pkg  (.', "' + fn_name + .'"');

			prefix = .' + " " +';

			arg_count = count_args libcall;

			for (a = 0;  a < arg_count;  ++a) {
			    #
			    t = get_nth_arg_type( a, libcall );

			    case t
				"b" =>   to_xxx_client_driver_for_library_in_c_subprocess_pkg   (sprintf  "%s bool_to_string %s%d"		prefix t a);
				"f" =>   to_xxx_client_driver_for_library_in_c_subprocess_pkg   (sprintf  "%s eight_byte_float::to_string %s%d"	prefix t a);
				"i" =>   to_xxx_client_driver_for_library_in_c_subprocess_pkg   (sprintf  "%s int::to_string %s%d"		prefix t a);
				"s" =>   to_xxx_client_driver_for_library_in_c_subprocess_pkg   (sprintf  "%s string_to_string %s%d"		prefix t a);
				"w" =>   to_xxx_client_driver_for_library_in_c_subprocess_pkg   (sprintf  "%s widget_to_string %s%d"		prefix t a);
				#
				 _  =>   raise exception FAIL ("Unsupported arg type '" + t + "'");
			    esac;
			};

			to_xxx_client_driver_for_library_in_c_subprocess_pkg ");\n";


			if (result_expression != "")
			    #
			    to_xxx_client_driver_for_library_in_c_subprocess_pkg "\n";
			    to_xxx_client_driver_for_library_in_c_subprocess_pkg ("            " + result_expression + "\n");
			    to_xxx_client_driver_for_library_in_c_subprocess_pkg "        };\n\n\n";
			else
			    to_xxx_client_driver_for_library_in_c_subprocess_pkg "\n\n";
			fi;
		    };

		# Build a function for   src/bnd/xxx/src/xxx-client-driver-for-library-in-c-subprocess.pkg
		# looking like
		#
		#    fun make_status_bar_context_id (session, w0, s1)	# Int
		#        =
		#        do_int_command (session, "make_status_bar_context_id", "make_status_bar_context_id" + " " + widget_to_string w0 + " " + string_to_string s1);
		#
		fun write_fun_definition_to_'xxx_client_driver_for_library_in_c_subprocess_pkg' (fn_name, libcall, result_type)
		    =
		    {   to_xxx_client_driver_for_library_in_c_subprocess_pkg ("    fun " + fn_name + " (session");
			#
			arg_count = count_args( libcall );

			for (a = 0;  a < arg_count;  ++a) {
			    #
			    arg_type = get_nth_arg_type( a, libcall );

			    to_xxx_client_driver_for_library_in_c_subprocess_pkg  (sprintf ", %s%d" arg_type a);
			};

			to_xxx_client_driver_for_library_in_c_subprocess_pkg (")\t# " + result_type + "\n");
			to_xxx_client_driver_for_library_in_c_subprocess_pkg ("        =\n");

			if   (result_type == "new Widget")   write_do_command ("do_int_command",    fn_name, libcall, fn_name, "");
			elif (result_type == "Widget")       write_do_command ("do_int_command",    fn_name, libcall, fn_name, "");
			elif (result_type == "Int")          write_do_command ("do_int_command",    fn_name, libcall, fn_name, "");
			elif (result_type == "Bool")         write_do_command ("do_string_command", fn_name, libcall, fn_name, "the (int::from_string result) != 0;");
			elif (result_type == "Float")        write_do_command ("do_string_command", fn_name, libcall, fn_name, "the (eight_byte_float::from_string result);");
			elif (result_type == "Void")         write_do_command ("do_void_command",   fn_name, libcall, "", "");
			else
			    raise exception FAIL ("Unsupported result type: " + result_type);
			fi;
		    };

		#
		fun n_blanks n
		    =
		    n_blanks' (n, "")
		    where
			fun n_blanks' (0, string) => string;
			    n_blanks' (i, string) => n_blanks' (i - 1, " " + string);
			end;
		    end;

		# Build a function for   src/bnd/xxx/src/xxx-client-driver-for-library-in-main-process.pkg
		# looking like
		#
		# NEED TO WORK OUT APPROPRIATE VARIATION FOR THIS
		#
		#    fun make_status_bar_context_id (session, w0, s1)	# Int
		#        =
		#        do_int_command (session, "make_status_bar_context_id", "make_status_bar_context_id" + " " + widget_to_string w0 + " " + string_to_string s1);
		#
		fun write_fun_definition_to_'xxx_client_driver_for_library_in_main_process_pkg' (fn_name, c_fn_name, fn_type, libcall, result_type)
		    =
		    {
			# Construct xxx-client-driver-for-library-in-main-process.pkg level type for this function.
			# The xxx-client-g.pkg level type may involve records or tuples,
			# but at this level we always have tuples:
			#
			(xxx_client_driver_api_type (libcall, result_type))
			    ->
			    (input_type, output_type);

			to_xxx_client_driver_for_library_in_main_process_pkg "\n";
			to_xxx_client_driver_for_library_in_main_process_pkg
			    (sprintf "    #      %-80s   # %s type\n"
				     ( (n_blanks (string::length fn_name))
				     + (fn_type =~ ./^\(/ ?? "" :: " ")			   # If type starts with a paren exdent it one space.
				     +  fn_type
				     )
				     (basename path.xxx_client_api)
			    );

			to_xxx_client_driver_for_library_in_main_process_pkg
			    (sprintf "    my %s:   %s%s -> %s\n"
				      c_fn_name
				     (input_type =~ ./^\(/ ?? "" :: " ")		   # If type starts with a paren exdent it one space.
				      input_type
				      output_type
			    );

			to_xxx_client_driver_for_library_in_main_process_pkg "        =\n";

			to_xxx_client_driver_for_library_in_main_process_pkg
			    (sprintf "        ci::find_c_function { lib_name => \"%s\", fun_name => \"%s\" };\n"
				path.lib_name	
				c_fn_name
			    );

			to_xxx_client_driver_for_library_in_main_process_pkg "\n";


		#	to_xxx_client_driver_for_library_in_main_process_pkg ("#    fun " + fn_name + " (session");
		#
		#	arg_count = count_args( libcall );
		#
		#	for (a = 0;  a < arg_count;  ++a) {
		#
		#	    arg_type = get_nth_arg_type( a, libcall );
		#
		#	    to_xxx_client_driver_for_library_in_main_process_pkg  (sprintf ", %s%d" arg_type a);
		#	};
		#
		#	to_xxx_client_driver_for_library_in_main_process_pkg (")\t# " + result_type + "\n");
		#	to_xxx_client_driver_for_library_in_main_process_pkg ("#        =\n");


		#	if   (result_type == "new Widget")   write_do_command ("do_int_command",    fn_name, libcall, fn_name, "");
		#	elif (result_type == "Widget")       write_do_command ("do_int_command",    fn_name, libcall, fn_name, "");
		#	elif (result_type == "Int")          write_do_command ("do_int_command",    fn_name, libcall, fn_name, "");
		#	elif (result_type == "Bool")         write_do_command ("do_string_command", fn_name, libcall, fn_name, "the (int::from_string result) != 0;");
		#	elif (result_type == "Float")        write_do_command ("do_string_command", fn_name, libcall, fn_name, "the (eight_byte_float::from_string result);");
		#	elif (result_type == "Void")         write_do_command ("do_void_command",   fn_name, libcall, "", "");
		#	else
		#	    raise exception FAIL ("Unsupported result type: " + result_type);
		#	fi;
		    };


		# Convert .|xxx_foo| to .|xxx\_foo|
		# to protect it from TeX's ire:
		#
		fun slash_underlines  string
		    =
		    {
			regex::replace_all ./_/ .|\_| string;
		    };


		# Write a trie line into file  src/bnd/xxx/c/in-sub/mythryl-xxx-library-in-c-subprocess.c
		#
		fun write_trie_entry_to_'mythryl_xxx_library_in_c_subprocess_c'  name
		    =
		    {
			to_mythryl_xxx_library_in_c_subprocess_c_trie
			   (sprintf
				"    set_trie( trie, %-46s%-46s);\n"
				(.'"'  + name + .'",')
				("do__" + name));
		    };	

		# Write a line like
		#
		#     CFUNC("init",	do__gtk_init,		"Void -> Void")
		#
		# into file   src/bnd/xxx/c/in-main/libmythryl-xxx.c
		#
		fun write_table_entry_to_'libmythryl_xxx_c' (fn_name, fn_type)
		    =
		    {   to_libmythryl_xxx_c_table
                            (sprintf "CFUNC(%-44s%-44s%-54s%s%s)\n"
				("\""   + fn_name + "\",")
				("\""   + fn_name + "\",")
				("do__" + fn_name + ",")
				(fn_type =~ ./^\(/ ?? "" :: " ")			   # If type starts with a paren exdent it one space.
				("\""         + fn_type + "\"")
			    );
		    };

		Doc_Entry
		    =
		    { fn_name:  String,
		      libcall:  String,
		      url:      String,
		      fn_type:  String
		    };

		doc_entries =  REF ([]: List( Doc_Entry ));

		# Note a tex documentation table
		# line for file  section-libref-xxx.tex.
		#
		fun note_section_libref_xxx_tex_entry
		    { state,
		      fn_name,		# E.g. "make_window"
		      libcall,		# E.g. "gtk_table_set_col_spacing( GTK_TABLE(/*table*/w0), /*col*/i1, /*spacing*/i2)"
		      url,		# E.g. "http://library.gnome.org/devel/gtk/stable/GtkTable.html#gtk-table-set-col-spacing"
		      fn_type		# E.g. "Session -> Widget"
		    }
		    =
		    {
			# Get name of the C Gtk function/var
			# wrapped by this Mythryl function:
			#
			libcall
			    =
			    case (maybe_get_field(state,"doc-fn"))
				#
				THE field => field;	# doc-fn is a manual override used when libcall is unusable for documentation.

				NULL =>
				    {   # libcall is something like   gtk_widget_set_size_request( GTK_WIDGET(/*widget*/w0), /*wide*/i1, /*high*/i2)
					# but all we want here is the
					# initial function name:
					#
					libcall =  regex::find_first ./[A-Za-z0-9_']+/ libcall
						   except
						       NOT_FOUND = "";

					# If libcall does not begin with [Gg], it
					# is probably not useful in this context:
					#
					libcall =  (libcall =~ ./^[Gg]/)  ??  libcall
									  ::  "";

					libcall;
				    };	
			    esac;


			fn_name =  slash_underlines  fn_name;
			libcall =  slash_underlines  libcall;
			url     =  slash_underlines  url;		# Probably not needed.
			fn_type =  slash_underlines  fn_type;

			doc_entries :=   { fn_name, libcall, url, fn_type }  !  *doc_entries;
		    };

		# Write tex documentation table into file  section-libref-xxx.tex:
		#
		fun write_section_libref_xxx_tex_table
		    ( field1: Doc_Entry -> String,
		      field2: Doc_Entry -> String,
		      to_section: String -> Void
		    )
		    =
		    {
			# Define the sort order for the table:
			#
			fun compare_fn
			    ( a: Doc_Entry,
			      b: Doc_Entry
			    )
			    =
			    {   a1 = field1 a;    a2 = field2 a;
				b1 = field1 b;    b2 = field2 b;

				# If primary keys are equal,
				# sort on the secondary keys:
				#
				if (a1 != b1)   a1 > b1;
				else            a2 > b2;
				fi;
			    };

			entries =  sort  compare_fn  *doc_entries;

			foreach entries .{

			    #entry -> { fn_name, libcall, url, fn_type };

			    entry1 = field1 #entry;
			    entry2 = field2 #entry;

			    if (entry1 != "")
				to_section
				    (sprintf "%s & %s & %s & %s \\\\ \\hline\n"
					entry1
					entry2
					(url == "" ?? ""
						   :: (.|\ahref{\url{| + url + "}}{doc}"))
					fn_type
				    );
			    fi;
			};
		    };

		#
		fun build_fun_header_into_'mythryl_xxx_library_in_c_subprocess_c' (fn_name, args)
		    =
		    {   to_mythryl_xxx_library_in_c_subprocess_c_funs   "\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs  "static void\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs ("do__" + fn_name + "( int argc, unsigned char** argv )\n");
			to_mythryl_xxx_library_in_c_subprocess_c_funs  "{\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs (sprintf "    check_argc( \"do__%s\", %d, argc );\n" fn_name args);
			to_mythryl_xxx_library_in_c_subprocess_c_funs  "\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs  "    {\n";
		    };


		# Build C code
		# to fetch all the arguments
		# out of argc/argv:
		#
		fun build_fun_arg_loads_into_'mythryl_xxx_library_in_c_subprocess_c' (fn_name, args, libcall)
		    =
		    {   for (a = 0;   a < args;  ++a) {

			    # Remember type of this arg,
			    # which will be one of:
			    #   w (widget),
			    #   i (int),
			    #   b (bool)
			    #   s (string)
			    #   f (double):
			    #
			    arg_type = get_nth_arg_type( a, libcall );

			    if   (arg_type == "b")    to_mythryl_xxx_library_in_c_subprocess_c_funs (sprintf  "        int               b%d =                        bool_arg( argc, argv, %d );\n"  a a);
			    elif (arg_type == "f")    to_mythryl_xxx_library_in_c_subprocess_c_funs (sprintf  "        double            f%d =                      double_arg( argc, argv, %d );\n"  a a);
			    elif (arg_type == "i")    to_mythryl_xxx_library_in_c_subprocess_c_funs (sprintf  "        int               i%d =                         int_arg( argc, argv, %d );\n"  a a);
			    elif (arg_type == "s")    to_mythryl_xxx_library_in_c_subprocess_c_funs (sprintf  "        char*             s%d =                      string_arg( argc, argv, %d );\n"  a a);
			    elif (arg_type == "w")

# The logic here has
# inputs:
#     a
#     libcall
# output:
#     String
# This logic is (largely?) duplicated in    build_fun_arg_loads_into_'libmythryl_xxx_c'
				# Usually we fetch a widget as just
				#
				#    GtkWidget* widget    =  widget_arg( argc, argv, 0 );
				#
				# or such, but in a few cases we must cast to
				# another type:
				#  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)   widget_arg( argc, argv, 0 );
				#  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)        widget_arg( argc, argv, 0 );
				#  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0 =  (GtkRadioButton*)  widget_arg( argc, argv, 0 );

				widget_type =  REF "GtkWidget";

				if   (libcall =~ (sprintf   "GTK_ADJUSTMENT\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkAdjustment";
				elif (libcall =~ (sprintf        "GTK_SCALE\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkScale";
				elif (libcall =~ (sprintf "GTK_RADIO_BUTTON\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkRadioButton";
				fi;

				to_mythryl_xxx_library_in_c_subprocess_c_funs (sprintf  "        %-14s    w%d =    %-16s  widget_arg( argc, argv, %d );\n" (*widget_type + "*") a  ("(" + *widget_type + "*)") a);

			    else
				raise exception FAIL ("Bug: unsupported arg type '" + arg_type + "' #" + int::to_string a + " from libcall '" + libcall + "\n");
			    fi;

			};
		    };

		# Synthesize a function for   mythryl-xxx-library-in-c-subprocess.c  like
		# 
		#    static void
		#    do__set_adjustment_value( int argc, unsigned char** argv )
		#    {
		#        check_argc( "do__make_label", 2, argc );
		#    
		#        {   GtkAdjustment* w0 =  (GtkAdjustment*) widget_arg( argc, argv, 0 );
		#            double         f1 =                   double_arg( argc, argv, 1 );
		#
		#    	     gtk_adjustment_set_value( GTK_ADJUSTMENT(w0), /*value*/f1);
		#        }
		#    }
		#    
		fun write_plain_fun_to_'mythryl_xxx_library_in_c_subprocess_c'
		    ( state: State,
		      fn_name,			# E.g., "make_window2"
		      fn_type,			# E.g., "Session -> Widget".
		      libcall,			# E.g., "gtk_window_new( GTK_WINDOW_TOPLEVEL )".
		      result			# E.g., "Float"
		    )
		    =
		    {   arg_count =  count_args  libcall;
			#
			build_fun_header_into_'mythryl_xxx_library_in_c_subprocess_c'    (fn_name, arg_count);
			build_fun_arg_loads_into_'mythryl_xxx_library_in_c_subprocess_c' (fn_name, arg_count, libcall);

			case result
			    #
			    "Void"
				=>
				{   # Now we just print
				    # the supplied gtk call
				    # and wrap up:
				    #
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs ("        " + libcall + ";\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-binding/make-library-binding.pkg:  write_plain_fun_to_'mythryl_xxx_library_in_c_subprocess_c'  per  " + path.library_binding_specification + ". */\n");
				};

			    "new Widget"
				=>
# Logic here has inputs:
#     libcall
#     fn_name
				{   to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "        int slot = find_free_widget_slot ();\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("        widget[slot] = " + libcall + ";\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(             \"" + fn_name + "%d\\n\", slot);      fflush( stdout );\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT:" + fn_name + "%d\\n\", slot);      fflush( log_fd );\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-binding/make-library-binding.pkg:  write_plain_fun_to_'mythryl_xxx_library_in_c_subprocess_c'  per  " + path.library_binding_specification + ". */\n");
				};

			    "Widget"
				=>
# Logic here has inputs:
#     libcall
#     fn_name
				{   to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("        GtkWidget* widget = (GtkWidget*) " + libcall + ";\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "        int slot = get_widget_id( widget );\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(              \"" + fn_name + "%d\\n\", slot);      fflush( stdout );\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%d\\n\", slot);      fflush( log_fd );\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-binding/make-library-binding.pkg:  write_plain_fun_to_'mythryl_xxx_library_in_c_subprocess_c'  per  " + path.library_binding_specification + ". */\n");
				};

			    "Bool"
				=>
				{   to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("        int result = " + libcall + ";\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(              \"" + fn_name + "%d\\n\", result);      fflush( stdout );\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%d\\n\", result);      fflush( log_fd );\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-binding/make-library-binding.pkg:  write_plain_fun_to_'mythryl_xxx_library_in_c_subprocess_c'  per  " + path.library_binding_specification + ". */\n");
				};

			    "Float"
				=>
				{   to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("        double result = " + libcall + ";\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(              \"" + fn_name + "%f\\n\", result);      fflush( stdout );\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%f\\n\", result);      fflush( log_fd );\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-binding/make-library-binding.pkg:  write_plain_fun_to_'mythryl_xxx_library_in_c_subprocess_c'  per  " + path.library_binding_specification + ". */\n");

				};

			    "Int"
				=>
				{   to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("        int result = " + libcall + ";\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(              \"" + fn_name + "%d\\n\", result);      fflush( stdout );\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%d\\n\", result);      fflush( log_fd );\n");
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
				    to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-binding/make-library-binding.pkg:  write_plain_fun_to_'mythryl_xxx_library_in_c_subprocess_c'  per  " + path.library_binding_specification + ". */\n");
				};

			    _   =>  raise exception FAIL (sprintf "Unsupported result type '%s' at line %d" result *state.line_number);

			esac;

			plain_fns_autobuilt_for_'mythryl_xxx_library_in_c_subprocess_c'
			    :=
			    *plain_fns_autobuilt_for_'mythryl_xxx_library_in_c_subprocess_c'
			    + 1;
		    };

		#
		fun build_fun_header_into_'libmythryl_xxx_c' (fn_name, fn_type, args, libcall, result_type)
		    =
		    {
			(xxx_client_driver_api_type  (libcall,  result_type))
			    ->
			    (input_type, output_type);
			    

			# C comments don't nest, so we must change
			# any C comments in input_type or output_type:
			#
			input_type  = regex::replace_all   .|/\*|   "(*"    input_type;
			input_type  = regex::replace_all   .|\*/|   "*)"    input_type;
			#
			output_type = regex::replace_all   .|/\*|   "(*"   output_type;
			output_type = regex::replace_all   .|\*/|   "*)"   output_type;


			to_libmythryl_xxx_c_funs ("/* do__" + fn_name + "\n");
			to_libmythryl_xxx_c_funs  " *\n";
			to_libmythryl_xxx_c_funs (" * " + (basename path.xxx_client_api) + "        type:   " + (   fn_type =~ ./^\(/ ?? "" :: " ") + fn_type + "\n");
			to_libmythryl_xxx_c_funs (" * " + (basename path.xxx_client_driver_api) + " type:   " + (input_type =~ ./^\(/ ?? "" :: " ") + input_type + " -> " + output_type + "\n");
			to_libmythryl_xxx_c_funs  " */\n";
			to_libmythryl_xxx_c_funs ("static Val   do__" + fn_name + "   (Task* task, Val arg)\n");
			to_libmythryl_xxx_c_funs  "{\n";
			to_libmythryl_xxx_c_funs  "\n";
		    };

		#
		fun build_fun_trailer_into_'libmythryl_xxx_c' ()
		    =
		    {
			to_libmythryl_xxx_c_funs  "}\n";
			to_libmythryl_xxx_c_funs("/* Above fn built by src/lib/make-library-binding/make-library-binding.pkg:  write_libmythryl_xxx_c_plain_fun  per  " + path.library_binding_specification + ". */\n");
			to_libmythryl_xxx_c_funs  "\n";
			to_libmythryl_xxx_c_funs  "\n";
		    };


		# Build C code
		# to fetch all the arguments
		# out of argc/argv:
		#
		fun build_fun_arg_loads_into_'libmythryl_xxx_c' (fn_name, fn_type, args, libcall)
		    =
		    {
			case args
			    0 => ();

		#            Having just one argument used to be a special case
		#            because then we passed the argument directly rather
		#            than packed within a tuple.  But the first argument
		#            to a gtk-client-driver-for-library-in-main-process.pkg function is always a Session,
		#            and it is more efficient to pass on the tuple from
		#            that layer to the mythryl-gtk-library-in-main-process.c layer rather than
		#            unpacking and repacking just to get rid of the Session
		#            argument, consequently if we have any arguments of
		#            interest (i.e., non-Session arguments) at this point
		#            we will always have a tuple, eliminating the special
		#	         case.  I've left this code here, commented out, just
		#            in case this situation changes and it is needed again:
		#
		#
		#            1 => {  arg_type = get_nth_arg_type( 0, libcall );
		#
		#		    if   (arg_type == "b")    to_libmythryl_xxx_c_funs "    int    b0 = TAGGED_INT_TO_C_INT(arg) == HEAP_TRUE;\n";
		#		    elif (arg_type == "f")    to_libmythryl_xxx_c_funs "    double f0 = *(PTR_CAST(double*, arg));\n";
		#		    elif (arg_type == "i")    to_libmythryl_xxx_c_funs "    int    i0 = TAGGED_INT_TO_C_INT(arg);\n";
		#		    elif (arg_type == "s")    to_libmythryl_xxx_c_funs "    char*  s0 = HEAP_STRING_AS_C_STRING(arg);\n";
		#		    elif (arg_type == "w")
		#
		#			# Usually we fetch a widget as just
		#			#
		#			#    GtkWidget* widget    =  widget[ TAGGED_INT_TO_C_INT(arg) ];
		#			#
		#			# or such, but in a few cases we must cast to
		#			# another type:
		#			#  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)  widget[ TAGGED_INT_TO_C_INT(arg) ];
		#			#  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)       widget[ TAGGED_INT_TO_C_INT(arg) ];
		#			#  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0 =  (GtkRadioButton*) widget[ TAGGED_INT_TO_C_INT(arg) ];
		#
		#			widget_type = REF "GtkWidget";
		#
		#			if   (libcall =~   ./GTK_ADJUSTMENT\(\s*w0\s*\)/)   widget_type := "GtkAdjustment";
		#			elif (libcall =~        ./GTK_SCALE\(\s*w0\s*\)/)   widget_type := "GtkScale";
		#			elif (libcall =~ ./GTK_RADIO_BUTTON\(\s*w0\s*\)/)   widget_type := "GtkRadioButton";
		#			fi;
		#
		#			to_libmythryl_xxx_c_funs (sprintf  "    %-14s    w0 =    %-16s  widget[ TAGGED_INT_TO_C_INT(arg) ];\n"
		#                                                  (*widget_type + "*")
		#                                                  ("(" + *widget_type + "*)")
		#                                        );
		#
		#		    else
		#			raise exception FAIL ("Bug: unsupported arg type '" + arg_type + "' #0 from libcall '" + libcall + "\n");
		#		    fi;
		#		};

			    _ => {  if (args < 0)  die_x "build_fun_arg_loads_into_'libmythryl_xxx_c': Negative 'args' value not supported.";  fi;
				    #
				    for (a = 0;   a < args;  ++a) {
					#
					# Remember type of this arg,
					# which will be one of:
					#   w (widget),
					#   i (int),
					#   b (bool)
					#   s (string)
					#   f (double):
					#
					arg_type = get_nth_arg_type( a, libcall );

					if   (arg_type == "b")    to_libmythryl_xxx_c_funs (sprintf  "    int               b%d =                            GET_TUPLE_SLOT_AS_VAL( arg, %d) == HEAP_TRUE;\n"   a (a+1)); # +1 because 1st arg is always Session.
					elif (arg_type == "f")    to_libmythryl_xxx_c_funs (sprintf  "    double            f%d =        *(PTR_CAST(double*, GET_TUPLE_SLOT_AS_VAL( arg, %d)));\n"              a (a+1));
					elif (arg_type == "i")    to_libmythryl_xxx_c_funs (sprintf  "    int               i%d =                            GET_TUPLE_SLOT_AS_INT( arg, %d);\n"                a (a+1));
					elif (arg_type == "s")    to_libmythryl_xxx_c_funs (sprintf  "    char*             s%d =   HEAP_STRING_AS_C_STRING (GET_TUPLE_SLOT_AS_VAL( arg, %d));\n"               a (a+1));
					elif (arg_type == "w")

# The logic here has
# inputs:
#     a
#     libcall
# output:
#     String
# This logic is (largely?) duplicated in    build_fun_arg_loads_into_'mythryl_xxx_library_in_c_subprocess_c'
					    # Usually we fetch a widget as just
					    #
					    #    GtkWidget* widget    =  widget[ GET_TUPLE_SLOT_AS_INT (arg, i) ];
					    #
					    # or such, but in a few cases we must cast to
					    # another type:
					    #  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)   widget[ GET_TUPLE_SLOT_AS_INT( arg, i) ];
					    #  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)        widget[ GET_TUPLE_SLOT_AS_INT( arg, i) ];
					    #  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0  =  (GtkRadioButton*) widget[ GET_TUPLE_SLOT_AS_INT( arg, i) ];

					    widget_type = REF "GtkWidget";

					    if   (libcall =~ (sprintf   "GTK_ADJUSTMENT\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkAdjustment";
					    elif (libcall =~ (sprintf        "GTK_SCALE\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkScale";
					    elif (libcall =~ (sprintf "GTK_RADIO_BUTTON\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkRadioButton";
					    fi;

					    to_libmythryl_xxx_c_funs (sprintf  "    %-14s    w%d  =    %-16s  widget[ GET_TUPLE_SLOT_AS_INT( arg, %d) ];\n"
								      (*widget_type + "*")
								      a
								      ("(" + *widget_type + "*)")
								      (a+1)				# +1 because first arg is always Session.
							    );

					else
					    raise exception FAIL ("Bug: unsupported arg type '" + arg_type + "' #" + int::to_string a + " from libcall '" + libcall + "\n");
					fi;

				    };
				};
			esac;
		    };
		#
		fun build_fun_body_into_'libmythryl_xxx_c'
		    ( state: State,
		      fn_name,			# E.g., "make_window2"
		      fn_type,			# E.g., "Session -> Widget".
		      libcall,			# E.g., "gtk_window_new( GTK_WINDOW_TOPLEVEL )".
		      result_type		# E.g., "Float"
		    )
		    =
		    {
			case result_type
			    #
			    "Void"
				=>
				{   # Now we just print
				    # the supplied gtk call
				    # and wrap up:
				    #
				    to_libmythryl_xxx_c_funs "\n";
				    to_libmythryl_xxx_c_funs ("    " + libcall + ";\n");
				    to_libmythryl_xxx_c_funs "\n";
				    to_libmythryl_xxx_c_funs  "    return HEAP_VOID;\n";
				};

# The logic here has
# inputs:
#     libcall
# output:
#     String
			    "new Widget"
				=>
				{   to_libmythryl_xxx_c_funs  "\n";
				    to_libmythryl_xxx_c_funs  "    int slot = find_free_widget_slot ();\n";
				    to_libmythryl_xxx_c_funs  "\n";
				    to_libmythryl_xxx_c_funs ("    widget[slot] = " + libcall + ";\n");
				    to_libmythryl_xxx_c_funs  "\n";
				    to_libmythryl_xxx_c_funs  "    return TAGGED_INT_FROM_C_INT(slot);\n";
				};

# The logic here has
# inputs:
#     libcall
# output:
#     String
			    "Widget"
				=>
				{   to_libmythryl_xxx_c_funs  "\n";
				    to_libmythryl_xxx_c_funs ("    GtkWidget* widget = (GtkWidget*) " + libcall + ";\n");
				    to_libmythryl_xxx_c_funs  "\n";
				    to_libmythryl_xxx_c_funs  "    int slot = get_widget_id( widget );\n";
				    to_libmythryl_xxx_c_funs  "\n";
				    to_libmythryl_xxx_c_funs  "    return TAGGED_INT_FROM_C_INT(slot);\n";
				};

			    "Bool"
				=>
				{   to_libmythryl_xxx_c_funs  "\n";
				    to_libmythryl_xxx_c_funs ("    int result = " + libcall + ";\n");
				    to_libmythryl_xxx_c_funs  "\n";
				    to_libmythryl_xxx_c_funs  "    return  result ? HEAP_TRUE : HEAP_FALSE;\n";
				};

			    "Float"
				=>
				{   to_libmythryl_xxx_c_funs  "\n";
				    to_libmythryl_xxx_c_funs ("    double d = " + libcall + ";\n");
				    to_libmythryl_xxx_c_funs  "\n";
				    to_libmythryl_xxx_c_funs  "    return  make_float64(task, d );\n";
				};

			    "Int"
				=>
				{   to_libmythryl_xxx_c_funs  "\n";
				    to_libmythryl_xxx_c_funs ("    int result = " + libcall + ";\n");
				    to_libmythryl_xxx_c_funs  "\n";
				    to_libmythryl_xxx_c_funs  "    return TAGGED_INT_FROM_C_INT(result);\n";
				};

			    _   =>  raise exception FAIL (sprintf "Unsupported result type '%s' at line %d"  result_type  *state.line_number);

			esac;
		    };

		# Synthesize a function for   libmythryl-xxx.c  like
		# 
		#   /* do__gtk_init : Void -> Void
		#    *
		#    *
		#    */
		#   
		#   static Val do__gtk_init (Task* task, Val arg)
		#   {
		#       int y         = INT1_LIB7toC(              GET_TUPLE_SLOT_AS_INT(arg, 0) );
		#       char *symname = HEAP_STRING_AS_C_STRING(   GET_TUPLE_SLOT_AS_VAL(arg, 1) );
		#       int lazy      =                            GET_TUPLE_SLOT_AS_VAL(arg, 2) == HEAP_TRUE;
		#
		#       int result = move( y, x );
		#   
		#       if (result == ERR)     return RAISE_ERROR__MAY_HEAPCLEAN(task, "move", NULL);
		#   
		#       return HEAP_VOID;
		#   }
		#    
		#    
		#    
		# Cheatsheet:
		#    
		#   Accepting a lone float arg:
		#      double d = *(PTR_CAST(double*, arg));						# Example in src/c/lib/math/cos64.c
		#
		#   Accepting a lone int arg:
		#      int socket = TAGGED_INT_TO_C_INT(arg);						# Example in src/c/lib/socket/accept.c
		#
		#   Accepting a lone string arg:							# Example in src/c/lib/posix-file-system/readlink.c
		#      char* path = HEAP_STRING_AS_C_STRING(arg);
		#
		#   Accepting a lone Null_Or( Tuple ) arg:						# Example in src/c/lib/socket/get-protocol-by-name.c
		#       
		#   Accepting a Bool from a tuple:      						# Example in src/c/lib/dynamic-loading/dlopen.c
		#     int lazy = GET_TUPLE_SLOT_AS_VAL (arg, 1) == HEAP_TRUE;
		#
		#   Accepting an Int from a tuple:							# Example in src/c/lib/posix-file-system/fchown.c
		#     int fd =  GET_TUPLE_SLOT_AS_INT (arg, 0);
		#
		#   Accepting a String from a tuple:							# Example in src/c/lib/dynamic-loading/dlsym.c
		#     char *symname = HEAP_STRING_AS_C_STRING (GET_TUPLE_SLOT_AS_VAL (arg, 1));
		#       
		#   Accepting a Float from a tuple:							# THIS IS MY OWN GUESS!
		#     double d =  *(PTR_CAST(double*, GET_TUPLE_SLOT_AS_VAL(arg,%d)));
		#
		#   Accepting a Null_Or(String) from a tuple:   					# Example in src/c/lib/dynamic-loading/dlopen.c
		#       
		#       
		#   Returning
		#
		#     Void:    return HEAP_VOID;							# Defined in src/c/h/runtime-values.h
		#     TRUE:    return HEAP_TRUE;							# Defined in src/c/h/runtime-values.h
		#     FALSE:   return HEAP_FALSE;							# Defined in src/c/h/runtime-values.h
		#     Int:     return TAGGED_INT_FROM_C_INT(size);					# Defined in src/c/h/runtime-values.h
		#     NULL:    return OPTION_NULL;							# Defined in src/c/h/make-strings-and-vectors-etc.h    Example in src/c/machine-dependent/interprocess-signals.c
		#     THE foo: return OPTION_THE(task, foo);						# Defined in src/c/h/make-strings-and-vectors-etc.h
		#              										# Example in src/c/machine-dependent/interprocess-signals.c
		#
		#   Returning a float:
		#              return  make_float64(task, cos(d) );					# Defined in src/c/h/make-strings-and-vectors-etc.h
		#
		#   Returning a string:
		#       Val result = allocate_nonempty_ascii_string__may_heapclean(task, size, NULL);
		#	strncpy (HEAP_STRING_AS_C_STRING(result), buf, size);
		#	return result;
		#    
		#   Returning a tuple:									# Example from src/c/lib/date/gmtime.c
		#
		#       set_slot_in_nascent_heapchunk(task, 0, MAKE_TAGWORD(PAIRS_AND_RECORDS_BTAG, 9));
		#       set_slot_in_nascent_heapchunk(task, 1, TAGGED_INT_FROM_C_INT(tm->tm_sec));
		#       ...
		#       set_slot_in_nascent_heapchunk(task, 9, TAGGED_INT_FROM_C_INT(tm->tm_isdst));
		#
		#       return commit_nascent_heapchunk(task, 9);
		#    
		#    
		#     Return functions which check ERR
		#     and optionally raise an exception:             src/c/lib/raise-error.h
		#
		#	CHK_RETURN_VAL(task, status, val)	Check status for an error (< 0); if okay,
		#					then return val.  Otherwise raise
		#					SYSTEM_ERROR with the appropriate system
		#					error message.
		#
		#	CHK_RETURN(task, status)	Check status for an error (< 0); if okay,
		#					then return it as the result (after
		#					converting to an Lib7 int).
		#
		#	CHK_RETURN_UNIT(task, status)	Check status for an error (< 0); if okay,
		#					then return Void.
		#
		#     GET_TUPLE_SLOT_AS_VAL &Co        are from:  src/c/h/runtime-values.h
		#     allocate_nonempty_ascii_string__may_heapclean    is from:  src/c/h/make-strings-and-vectors-etc.h
		#     CHK_RETURN_VAL &Co are from:  src/c/lib/raise-error.h
		#
		fun write_plain_fun_to_'libmythryl_xxx_c'
		    ( state: State,
		      fn_name,			# E.g., "make_window2"
		      fn_type,			# E.g., "Session -> Widget".
		      libcall,			# E.g., "gtk_window_new( GTK_WINDOW_TOPLEVEL )".
		      result_type		# E.g., "Float"
		    )
		    =
		    {   arg_count =  count_args( libcall );
			#
			   build_fun_header_into_'libmythryl_xxx_c' (       fn_name, fn_type, arg_count, libcall, result_type);
			build_fun_arg_loads_into_'libmythryl_xxx_c' (       fn_name, fn_type, arg_count, libcall);
			     build_fun_body_into_'libmythryl_xxx_c' (state, fn_name, fn_type, libcall, result_type);
			  build_fun_trailer_into_'libmythryl_xxx_c' ();

			plain_fns_autobuilt_for_'libmythryl_xxx_c'
			    :=
			    *plain_fns_autobuilt_for_'libmythryl_xxx_c'
			    + 1;
		    };

		# Given a libcall like      "gtk_foo( /*bar_to_int bar*/i0, /*zot*/i1 )"
		# and a parameter name like  "i0" or "i1"
		# return nickname like       "bar_to_int bar" or "zot"
		# if available, else         "i0" or "i1":
		#
		fun arg_name (arg, libcall)
		    =
		    {   regex = .|/\*([A-Za-z0-9_' ]+)\*/| + arg;	# Something like:   /*([A-Za-z0-9_' ]+)*/f0

			(regex::find_first_group 1 regex libcall)
			except
			    NOT_FOUND = arg;
		    };

		# Given a libcall like      "gtk_foo( /*bar_to_int bar*/i0, /*zot*/i1 )"
		# and a parameter name like  "i0" or "i1"
		# return nickname like       "bar" or "zot"
		# if available, else         "i0" or "i1":
		#
		fun param_name (arg, libcall)
		    =
		    {   regex = .|/\*([A-Za-z0-9_' ]+)\*/| + arg;		# Something like:   /*([A-Za-z0-9_' ]+)*/f0

			{
			    name = regex::find_first_group 1 regex libcall;

			    # If 'name' contains blanks, we want
			    # only the part after the last blank:
			    # 
			    name = (regex::find_first_group 1 .|^[:A-Za-z0-9_' ]+ ([A-Za-z0-9_']+)$| name)
				   except
				       NOT_FOUND = name;

			    name;
			}
			except NOT_FOUND = arg;
		    };

		# Synthesize a function for   gtk-client-g.pkg  like
		# 
		#	 #
		#        fun make_vertical_scale_with_range (session: Session, min, max, step)
		#            =
		#	    drv::make_vertical_scale_with_range (session.subsession, min, max, step);
		#
		fun write_plain_fun_to_'xxx_client_g_pkg' (state: State,  fn_name, libcall)
		    =
		    case (maybe_get_field (state, "code"))
			#
			THE field
			    =>
			    {   to_xxx_client_g_pkg_funs  "        #\n";
				to_xxx_client_g_pkg_funs  field;
				to_xxx_client_g_pkg_funs  "            \n";
				to_xxx_client_g_pkg_funs  "            # Above function handbuilt via src/lib/make-library-binding/make-library-binding.pkg: write_plain_fun_to_'xxx_client_g_pkg'.\n";
				to_xxx_client_g_pkg_funs  "\n";

				plain_fns_handbuilt_for_'xxx_client_g_pkg'
				    :=
				    *plain_fns_handbuilt_for_'xxx_client_g_pkg' + 1;
			    };

			NULL =>
			    {
				arg_count = count_args( libcall );

				fun make_args get_name		# get_name will be arg_name or param_name.
				    =
				    for (a = 0; a < arg_count; ++a) {

					# Remember type of this arg,
					# which will be one of:
					#   w (widget),
					#   i (int),
					#   b (bool)
					#   s (string)
					#   f (double):
					#
					arg_type = get_nth_arg_type( a, libcall );

					arg = sprintf "%s%d" arg_type a;

					to_xxx_client_g_pkg_funs (sprintf ", %s" (get_name (arg, libcall)));
				    }; 

				# Select between  foo  (session.subsession, bar, zot);
				#                 foo { session.subsession, bar, zot };
				#
				my (lparen, rparen)
				    =
				    # It is a poor idea to have xxx-client-g.pkg functions
				    # with multiple arguments of the same type use
				    # argument tuples, because it is too easy to
				    # mis-order such arguments, and the compiler
				    # type checking won't flag it -- in such cases
				    # it is better to use argument records:
				    #
				    arg_types_are_all_unique  libcall
					??  ( "(" ,  ")" )
					::  ( "{ ", " }" );

				to_xxx_client_g_pkg_funs "\n";
				to_xxx_client_g_pkg_funs "        #\n";
				to_xxx_client_g_pkg_funs "        fun ";
				to_xxx_client_g_pkg_funs fn_name;


				to_xxx_client_g_pkg_funs (sprintf " %ssession: Session"  lparen);
				make_args  param_name;
				to_xxx_client_g_pkg_funs (sprintf "%s\n" rparen);


				# Select between  drv::foo   session.subsession;
				#                 drv::foo  (session.subsession, bar, zot);
				#
				my (lparen, rparen)
				    =
				    arg_count == 0
					??  (" ", "" )
					::  ("(", ")");

				fn_name =   regex::replace_all ./'/ "2" fn_name;		# Primes don't work in C!

				to_xxx_client_g_pkg_funs          "            =\n";
				to_xxx_client_g_pkg_funs (sprintf "            drv::%s %ssession.subsession" fn_name lparen);
				make_args  arg_name;
				to_xxx_client_g_pkg_funs (sprintf "%s;\n" rparen);

				to_xxx_client_g_pkg_funs "            \n";
				to_xxx_client_g_pkg_funs("            # Above function autobuilt by src/lib/make-library-binding/make-library-binding.pkg:  write_plain_fun_to_'xxx_client_g_pkg'  per  " + path.library_binding_specification + ".\n");
				to_xxx_client_g_pkg_funs "\n";


				plain_fns_autobuilt_for_'xxx_client_g_pkg'
				    :=
				    *plain_fns_autobuilt_for_'xxx_client_g_pkg'
				    + 1;
			    };
		    esac;

		# Synthesize a function for   xxx-client-g.pkg  like
		# 
		#	 #
		#	 fun set_clicked_callback  s w c = set_void_callback (s, c, drv::set_clicked_callback (s.subsession, w));	# Handle "clicked" signal.
		#
		fun write_callback_fun_to_'xxx_client_g_pkg'
		    ( state: State,
		      fn_name,			# E.g. "set_foo_callback"
		      callback_type		# E.g. "Void_Callback"
		    )
		    =
		    case (maybe_get_field (state, "code"))
			#
			THE field
			    =>
			    {   to_xxx_client_g_pkg_funs  "        #\n";
				to_xxx_client_g_pkg_funs  field;
				to_xxx_client_g_pkg_funs  "            \n";
				to_xxx_client_g_pkg_funs  "            # Above function handbuilt via src/lib/make-library-binding/make-library-binding.pkg:  write_callback_fun_to_'xxx_client_g_pkg'.\n";
				to_xxx_client_g_pkg_funs  "\n";

				callback_fns_handbuilt_for_'xxx_client_g_pkg'
				    :=
				    *callback_fns_handbuilt_for_'xxx_client_g_pkg' + 1;
			    };

			NULL =>
			    {
				signal_name
				    =
				    (regex::find_first_group 1 ./^set_(.*)_callback$/  fn_name)
				    except
					NOT_FOUND
					    =
					    die_x(sprintf "write_callback_fun_to_'xxx_client_g_pkg': fn_name '%s' does not have form set_foo_callback for any foo\n" fn_name);

				note_callback_fn = "note_" + (tolower callback_type);		# "Void_Callback" -> "note_void_callback"

				to_xxx_client_g_pkg_funs
				    (    sprintf "    fun %-36s s w c = %-28s (s, c, drv::%-36s (s.subsession, w));\t# Handle '%s' signal\n"
						 fn_name
						 note_callback_fn
						 fn_name
						 signal_name
				    );

				callback_fns_handbuilt_for_'xxx_client_g_pkg'
				    :=
				    *callback_fns_handbuilt_for_'xxx_client_g_pkg'
				    + 1;
			    };
		    esac;


		# Synthesize a function for   mythryl-xxx-library-in-c-subprocess.c  like
		#
		#    static void
		#    do__set_foo_callback( int argc, unsigned char** argv )
		#    {
		#	check_argc( "do__foo_callback", 1, argc );
		#
		#	{   GtkWidget* widget    =  widget_arg( argc, argv, 0 );
		#
		#	    int id   =  find_free_callback_id ();
		#
		#	    g_signal_connect( G_OBJECT(widget), "foo", G_CALLBACK( run_foo_callback ), (void*)id );
		#
		#	    printf(               "set_foo_callback%d\n", id );	fflush( stdout );
		#	    fprintf(log_fd, "SENT: set_foo_callback%d\n", id );	fflush( log_fd );
		#	}
		#    }
		#
		fun build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c' (callback_name, lowtype)
		    =
# The logic here has
# inputs:
#     callback_name
#     lowtype
# output:
#     String
		    {   to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs "static void\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs("do__set_" + callback_name + "_callback( int argc, unsigned char** argv )\n");
			to_mythryl_xxx_library_in_c_subprocess_c_funs "{\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs("    check_argc( \"do__set_" + callback_name + "_callback\", 1, argc );\n");
			to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs "    {   GtkWidget* widget    =  widget_arg( argc, argv, 0 );\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs "        int id   =  find_free_callback_id ();\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs("        g_signal_connect( " + lowtype + "(widget), \"" + callback_name + "\", G_CALLBACK( run_" + callback_name + "_callback ), (void*)id );\n");
			to_mythryl_xxx_library_in_c_subprocess_c_funs "\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs("         printf(              \"set_" + callback_name + "_callback%d\\n\", id );      fflush( stdout );\n");
			to_mythryl_xxx_library_in_c_subprocess_c_funs("        fprintf(log_fd, \"SENT: set_" + callback_name + "_callback%d\\n\", id );      fflush( log_fd );\n");
			to_mythryl_xxx_library_in_c_subprocess_c_funs "    }\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs "}\n";
			to_mythryl_xxx_library_in_c_subprocess_c_funs("/* Above fn built by src/lib/make-library-binding/make-library-binding.pkg:  build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c'  per  " + path.library_binding_specification + ".*/\n");

			callback_fns_autobuilt_for_'mythryl_xxx_library_in_c_subprocess_c'
			    :=
			    *callback_fns_autobuilt_for_'mythryl_xxx_library_in_c_subprocess_c'
			    + 1;
		    };


		# Synthesize a function for   libmythryl-xxx.c  like
		#
		#   /* do__set_foo_callback : Session -> Widget -> Void_Callback -> Void;
		#    */
		#   static Val do__set_foo_callback (Task* task, Val arg)
		#   {
		#       GtkWidget*        w0 =    (GtkWidget*)      widget[ GET_TUPLE_SLOT_AS_INT( arg, 1) ];	// '1' because 'arg' is a duple (session, widget).
		#
		#       int id   =  find_free_callback_id ();
		#
		#       g_signal_connect( G_OBJECT(widget), "clicked", G_CALLBACK( run_clicked_callback ), (void*)id );
		#
		#       return TAGGED_INT_FROM_C_INT(id);
		#   }
		#    
		fun build_set_callback_fn_for_'libmythryl_xxx_c'
		    ( callback_name,
		      fn_type,			# E.g., "Session -> Widget -> Void_Callback -> Void".
		      lowtype
		    )
		    =
# The logic here has
# inputs:
#     callback_name
#     fn_type
#     lowtype
# output:
#     String
		    {   to_libmythryl_xxx_c_funs "\n";
			to_libmythryl_xxx_c_funs "\n";
			to_libmythryl_xxx_c_funs("/*  do__set_" + callback_name + "_callback : " + fn_type + "\n");
			to_libmythryl_xxx_c_funs " */\n";
			to_libmythryl_xxx_c_funs("static Val   do__set_" + callback_name + "_callback (Task* task, Val arg)\n");
			to_libmythryl_xxx_c_funs "{\n";
			to_libmythryl_xxx_c_funs  "\n";
			to_libmythryl_xxx_c_funs  "    GtkWidget*        w0 __attribute__((unused)) =    (GtkWidget*)      widget[ GET_TUPLE_SLOT_AS_INT( arg, 1) ];        // '1' because 'arg' is a duple (session, widget).\n";
			to_libmythryl_xxx_c_funs  "\n";		# The '__attribute__((unused))' is just to suppress some   unused variable 'w0'   compiler warnings.
			to_libmythryl_xxx_c_funs "    int id   =  find_free_callback_id ();\n";
			to_libmythryl_xxx_c_funs "\n";
			to_libmythryl_xxx_c_funs("    g_signal_connect( " + lowtype + "(w0), \"" + callback_name + "\", G_CALLBACK( run_" + callback_name + "_callback ), (void*)id );\n");
			to_libmythryl_xxx_c_funs "\n";
			to_libmythryl_xxx_c_funs "    return TAGGED_INT_FROM_C_INT(id);\n";
			to_libmythryl_xxx_c_funs  "}\n";
			to_libmythryl_xxx_c_funs("/* Above fn built by src/lib/make-library-binding/make-library-binding.pkg:  build_set_callback_fn_for_'libmythryl_xxx_c'  per  " + path.library_binding_specification + ".*/\n");
			to_libmythryl_xxx_c_funs  "\n";
			to_libmythryl_xxx_c_funs  "\n";

			callback_fns_autobuilt_for_'libmythryl_xxx_c'
			    :=
			    *callback_fns_autobuilt_for_'libmythryl_xxx_c'
			    + 1;
		    };

		# Synthesize a xxx-client.api line like
		#
		#      make_window:    Session -> Widget;
		#
		stipulate

		    line_count = REF 2;

		herein

		    #
		    fun write_fun_declaration_to_'xxx_client_api' (fn_name, fn_type)
			=
			{
			    # Add a blank line every three declarations:
			    #
			    line_count := *line_count + 1;

			    if ((*line_count % 3) == 0)
				#
				to_xxx_client_api_funs  "\n";
			    fi;

			    # The 'if' here is just to exdent by one char
			    # types starting with a paren, so that we get
			    #
			    #     foo:    Session -> Void;
			    #     bar:   (Session, Widget) -> Void;
			    #
			    # rather than the slightly rattier looking  
			    #
			    #     foo:    Session -> Void;
			    #     bar:    (Session, Widget) -> Void;
			    #
			    if (fn_type =~ ./^\(/)	to_xxx_client_api_funs (sprintf "    %-40s%s;\n"  (fn_name + ":")  fn_type);
			    else			to_xxx_client_api_funs (sprintf "    %-41s%s;\n"  (fn_name + ":")  fn_type);
			    fi;
			};
		end;

		#
		fun update_field (state: State, field_name, field_line)
		    =
		    {
			case (string_map::get (*state.fields, field_name))
			    #
			    THE field
				=>
				{   field.string := *field.string + field_line;
				    field.line_n := *state.line_number;

				    string_map::set (*state.fields, field_name, field);

				    ();
				};

			    NULL =>
				{   field = { string =>  REF field_line,
					      line_1 =>  REF *state.line_number,
					      line_n =>  REF *state.line_number,
					      used   =>  REF FALSE
					    };

				    state.fields
					:=
					string_map::set (*state.fields, field_name, field);

				    ();
				};
			esac;
		    };

		#
		fun make_callback_function (state: State)
		    =
		    {
			fn_name  =  get_field(state, "fn-name");		# "set_foo_callback"
			fn_type  =  get_field(state, "fn-type");		# "Session -> Widget -> Foo_Callback -> Void"
			lowtype  =  get_field(state, "lowtype");		# "G_OBJECT"

			callback_name
			    =
			    (regex::find_first_group 1 ./^set_(.*)_callback$/  fn_name)
			    except
				NOT_FOUND
				    =
				    die_x(sprintf "%s: callback-fn fn-name '%s' does not have form 'set_foo_callback' for any 'foo'\n"
						 (get_field_location (state, "fn-name"))
						 fn_name
					);

			callback_type		# E.g., "Void_Callback"
			    =
			    (regex::find_first_group 1 ./^Session\s+->\s+Widget\s+->\s+(\S+)\s+->\s+Void$/ fn_type)
			    except
				NOT_FOUND
				    =
				    die_x(sprintf "%s: callback-fn fn-type '%s' does not have form 'Session -> Widget -> Foo_Callback -> Void' for any 'foo'\n"
						 (get_field_location (state, "fn-type"))
						 fn_type
					);

			callback_name =   regex::replace_all  ./'/  "2"  callback_name;		# Primes don't work in C!

			c_fn_name =  "set_"  +  callback_name  +  "_callback";

			build_set_callback_fn_for_'mythryl_xxx_library_in_c_subprocess_c'( callback_name,          lowtype );
			build_set_callback_fn_for_'libmythryl_xxx_c'(                      callback_name, fn_type, lowtype );

			write_table_entry_to_'libmythryl_xxx_c' (c_fn_name, fn_type);
			write_trie_entry_to_'mythryl_xxx_library_in_c_subprocess_c'  (c_fn_name );

			url =   case (maybe_get_field (state,"url"))
				    #
				    THE field =>  field;
				    NULL      =>  "http://library.gnome.org/devel/gobject/unstable/gobject-Signals.html#g-signal-connect";
				esac;

			note_section_libref_xxx_tex_entry { state, fn_name, url, fn_type, libcall => "g_signal_connect" };

			libcall     = "w0";		# Give arg counts and types to the following two functions.
			result_type = "Int";		# Give result information   to the following two functions.

			write_fun_declaration_to_'xxx_client_driver_api'				(c_fn_name, libcall, result_type);
			write_fun_definition_to_'xxx_client_driver_for_library_in_c_subprocess_pkg'	(c_fn_name, libcall, result_type);

			write_fun_declaration_to_'xxx_client_api'					(fn_name, fn_type);
			write_fun_definition_to_'xxx_client_driver_for_library_in_main_process_pkg'	(fn_name, c_fn_name, fn_type, libcall, result_type);

			write_callback_fun_to_'xxx_client_g_pkg'( 				  state, fn_name, callback_type);
		    };

		#
		fun figure_function_result_type  (state: State,  fn_name,  fn_type)
		    =
		    # result_type can be "Int", "String", "Bool", "Float" or "Void".
		    #
		    # It can also be "Widget" or "new Widget", the difference being
		    # that in the former case the mythryl-xxx-library-in-c-subprocess.c logic can merely
		    # fetch it out of its array  widget[],  whereas in the latter a
		    # new entry is being created in  widget[].
		    #
		    # We can usually deduce the difference:  If fn_name starts with
		    # "make_" then we have the "new Widget" case, otherwise we have
		    # the "Widget" case:
		    #
		    case (maybe_get_field (state, "result"))
			#
			THE string => string;
			#
			NULL =>
			    # Pick off terminal  " -> Void"
			    # or whatever from fn_type
			    # and switch on it:
			    #
			    case (regex::find_first_group 1 ./->\s*([A-Za-z_']+)\s*$/ fn_type)
				 "Bool"   => "Bool";
				 "Float"  => "Float";
				 "Int"    => "Int";
				 "String" => "String";
				 "Void"   => "Void";

				 "Widget"
				    =>
				    if (fn_name =~ ./^make_/)   "new Widget";
				    else                            "Widget";
				    fi;

				 other =>  die_x(sprintf "Unsupported result fn-type %s in type %s at %s..\n"
							other
							fn_type
						       (get_field_location (state, "fn-type"))
					      );
			    esac
			    except
				NOT_FOUND
				    =
				    die_x(sprintf "Unsupported result fn-type %s at %s..\n"
						 fn_type
						 (get_field_location (state, "fn-type"))
					);
		    esac;


		fun make_plain_function (state: State)
		    =
		    {	
			url   = case (maybe_get_field(state,"url"))
				    #	
				    THE field => field;
				    NULL      => "";
				esac;

			fn_name =  get_field (state, "fn-name");					# E.g., "make_window".
			fn_type =  get_field (state, "fn-type");					# E.g., "Session -> Widget".
			libcall =  get_field (state, "libcall");					# E.g., "gtk_window_new( GTK_WINDOW_TOPLEVEL )".

			c_fn_name =  regex::replace_all  ./'/  "2"  fn_name;				# C fn names cannot contain apostrophes.

			result_type =  figure_function_result_type  (state, fn_name, fn_type);

			write_plain_fun_to_'mythryl_xxx_library_in_c_subprocess_c' (state, c_fn_name, fn_type, libcall, result_type);
			write_plain_fun_to_'libmythryl_xxx_c'                      (state, c_fn_name, fn_type, libcall, result_type);
			write_table_entry_to_'libmythryl_xxx_c'                           (c_fn_name, fn_type);

			write_trie_entry_to_'mythryl_xxx_library_in_c_subprocess_c'(       c_fn_name );

			note_section_libref_xxx_tex_entry { state, fn_name, libcall, url, fn_type };

			write_fun_declaration_to_'xxx_client_driver_api'				(c_fn_name, libcall, result_type);
			write_fun_definition_to_'xxx_client_driver_for_library_in_c_subprocess_pkg'	(c_fn_name, libcall, result_type);

			write_fun_declaration_to_'xxx_client_api'					(fn_name, fn_type);
			write_fun_definition_to_'xxx_client_driver_for_library_in_main_process_pkg'	(fn_name, c_fn_name, fn_type, libcall, result_type);

			write_plain_fun_to_'xxx_client_g_pkg'					(state,  fn_name, libcall);
		    };


		#
		fun make_function_doc (state: State)
		    =
		    {	
			url    = case (maybe_get_field(state,"url"))
				     #	
				     THE field => field;
				     NULL      => "";
				 esac;

			fn_name  =  get_field(state, "fn-name");	# "make_window" or such.
			fn_type  =  get_field(state, "fn-type");	# "Session -> Widget" or such.

			note_section_libref_xxx_tex_entry { state, fn_name, libcall => "", url, fn_type };
		    };


		#
		fun make_mythryl_type (state: State)
		    =
		    {	
			type     =  get_field(state, "type");
			#
			to_xxx_client_api_types		type;
			to_xxx_client_g_pkg_types	type;
		    };

		fun make_mythryl_code (state: State)
		    =
		    {	
			code     =  get_field(state, "code");
			#
			to_xxx_client_g_pkg_funs  code;
		    };


		#
		fun handle_fieldset (state: State)
		    =
		    {
			if (not  (string_map::is_empty  *state.fields))
			    #
			    case (trim (get_field (state, "build-a")))
				#
				"callback-fn"  =>  make_callback_function  state;
				"plain-fn"     =>  make_plain_function     state;
				"fn-doc"       =>  make_function_doc       state;
				"mythryl-type" =>  make_mythryl_type       state;
				"mythryl-code" =>  make_mythryl_code       state;
				#
				other => die_x (sprintf "Unsupported 'build-a' field value '%s' at %s\n" other (get_field_location (state, "build-a")));
			    esac;

			    clear_state  state;
			fi;
		    };    

		# Scan src/bnd/xxx/etc/library-binding.specification
		# digesting the blank-line-delimited
		# config info paragraphs, then
		# build code accordingly:
		# 
		fun process_library_binding_specification_file ()
		    =
		    {	config_file_in =  fil::open_for_read  path.library_binding_specification;
			#
			loop { line_number =>  REF 0,
			       fd          =>  config_file_in,
			       fields      =>  REF (string_map::empty: string_map::Map( Field ))
			     };

			fil::close_input  config_file_in;
		    }
		    where
		        fun loop  (state: State)
			    =
			    case (fil::read_line  state.fd)
				#
				NULL => handle_fieldset  state;			# Done.
				#
				THE input_line
				    =>
				    {   state.line_number :=  *state.line_number + 1;
					#
					if (input_line =~ ./^\s*#/)			# If it is a comment line,
					    #
					    loop  state;				# ignore it.

					elif (input_line =~ ./^\s*$/)			# If it is a blank line, it marks the end of a field cluster,
					    #
					    handle_fieldset  state;			# so process any fields we have in hand:

					else

					    # Line format should be  "line-type: rest".
					    # Split it into two strings at the ':' and
					    # dispatch on the line type:
					    #
					    case (regex::find_first_groups_all ./^([^:]+):(.*\n)$/ input_line)
						#
						[ line_type, line_contents ]
						    =>
						    {   # Drop leading and trailing whitespace:
							#
							line_type =  trim  line_type;

							line_contents
							    =
							    case line_type
								"type"      =>       line_contents;	# Contains raw indented code, so leave whitespace in place and restore dropped newline.
								"code"      =>       line_contents;	# Contains raw indented code, so leave whitespace in place and restore dropped newline.
								_           => trim  line_contents;	# Drop leading and trailing whitespace.
							    esac;

							update_field (state,  line_type,  line_contents);
						    };

						_   =>   die_x ("UNRecognized library-binding.specification line: '" + (chomp input_line) + "'  -- make-library-binding.pkg\n");
					    esac
					    except
						NOT_FOUND =  die_x (sprintf "Unrecognized library-binding.specification line %d: '%s'    -- make-library-binding.pkg\n" *state.line_number (chomp input_line));

					fi;

					loop  state;				# Scan rest of file.
				    };
			    esac;

		    end;


	    end;
    };
end;

###################################################################################
# Note[1]:  Format of             library-binding.specification               files
#
#
# A library-binding.specification file is broken
# into logical paragraphs separated by blank lines.
#
# In general each paragraph describes one end-user-callable
# function in the Gtk API.
#
# Each paragraph consists of one or more lines;
# each line begins with a colon-delimited type
# field determining its semantics.
#
# Supported line types are:
#
#     make:     Must appear in every paragraph.
#               Determines which make-library-binding function processes the paragraph:
#                   plain-fn       make_plain_function      # The usual case.
#                   callback-fn    make_callback_function   # Special-purpose variant.
#                   fn-doc         make_function_doc        # Document fn without code generation, e.g. for Mythryl-only fns.
#                   mythryl-code   make_mythryl_code        # Special hack to deposit verbatim Mythryl code.
#                   mythryl-type   make_mythryl_type        # Special hack to deposit verbatim Mythryl declarations.
#
#     The 'make' line determines which other
#     lines may appear in the paragraph, per the
#     following table. ("X" == mandatory, "O" == optional):
#
#                  callback-fn   fn-doc   plain-fn   mythryl-code  mythryl-type
#                  -----------   ------   --------   ------------  -----------
#
#         fn-name:      X           X         X
#         fn-type:      X           X         X
#         lowtype:      X                     X
#         libcall:                            X
#         result:                             O
#         doc-fn:       O           O         O
#         url:          O           O         O
#         code:         O                     O            X
#         type:                                                         X
#
#
#     fn-name:  Name of the end-user-callable Mythryl function,   e.g. halt_and_catch_fire
#     fn-type:  Mythryl type for the function,                    e.g. Int -> Void
#     url:      URL documenting the underlying C Gtk function,    e.g. http://library.gnome.org/devel/gtk/stable/gtk-General.html#gtk-init
#     code:     Literal Mythryl code to be inserted near bottom of gtk-client-g.pkg
#     type:     Literal Mythryl code to be inserted near top    of gtk-client-g.pkg and also in gtk-client.api
#     lowtype:  Gtk cast macro for widget: Usually G_OBJECT, occasionally GTK_MENU_ITEM or such.
#
#     doc-fn:   Usually name of fn for documentation purposes is obtained from 'libcall' line,
#               but this line may be used to specify it explicitly.
#
#     libcall:  C-level gtk call to make                          e.g. gtk_layout_put( GTK_LAYOUT(w0), GTK_WIDGET(w1), i2, i3)
#
#		libcall contains embedded arguments like w0, i1, f2, b3, s4.
#		
#		The argument letter gives us the argument type:
#		
#		   w == widget
#		   i == int
#		   f == double  (Mythryl "Float")
#		   b == bool
#		   s == string
#		
#		The argument digit gives us the argument order:
#		
#		   0 == first arg
#		   1 == second arg
#		   ...
#
#
#     result:   C-level result type for call.  In practice we always default
#               this and make-library-binding deduces it from the Mythryl type.
#               #
#               Can be one of "Int", "String", "Bool", "Float" or "Void".
#               #
#               Can also be "Widget" or "new Widget", the difference being
#	        that in the former case the mythryl-gtk-server.c logic can merely
#	        fetch it out of its array  widget[],  whereas in the latter a
#	        new entry is being created in  widget[].
#               #
#               We can usually deduce the difference:  If fn_name starts with
#	        "make_" then we have the "new Widget" case, otherwise we have
#	        the "Widget" case:



## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
