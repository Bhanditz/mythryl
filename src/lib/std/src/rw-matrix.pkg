## rw-matrix.pkg
#
# Two-dimensional matrices.

# Compiled by:
#     src/lib/std/src/standard-core.sublib



###                  "Engineering is like acting,
###                   in that when it is well done,
###                   it goes unnoticed and unapplauded."



#DO set_control "compiler::trap_int_overflow" "TRUE";

stipulate
    package rwv =  rw_vector;				# rw_vector		is from   src/lib/std/src/rw-vector.pkg
    package rws =  rw_vector_slice;			# rw_vector_slice	is from   src/lib/std/src/rw-vector-slice.pkg
    package inl =  inline_t;				# inline_t		is from   src/lib/core/init/built-in.pkg
herein

    package   rw_matrix
    :         Rw_Matrix					# Rw_Matrix		is from   src/lib/std/src/matrix.api
    {							# inline_t		is from   src/lib/core/init/built-in.pkg
	ltu = inl::default_int::ltu;

	unsafe_set = inl::poly_rw_vector::set;
	unsafe_get = inl::poly_rw_vector::get;


	Rw_Matrix(X)
	    =
	    { data:   rwv::Rw_Vector(X),
	      nrows:  Int,
	      ncols:  Int
	    };

	Region(X)
	    =
	    { base:   Rw_Matrix(X),
	      row:    Int,
	      col:    Int,
	      nrows:  Null_Or( Int ),
	      ncols:  Null_Or( Int )
	    };

	make_matrix'
	    =
	    inl::poly_rw_vector::make_nonempty_rw_vector;

	# Compute the index of an matrix element 
	#
	fun unsafe_index ( { nrows, ncols, ... }: Rw_Matrix(X), i, j)
	    =
	    (i * ncols + j);

	fun index (arr, i, j)
	    =
	    if ((ltu (i, arr.nrows) and ltu (j, arr.ncols)))
		#
		unsafe_index (arr, i, j);
	    else
		raise exception exceptions_guts::SUBSCRIPT;					# exceptions_guts	is from   src/lib/std/src/exceptions-guts.pkg
	    fi;

	fun check_size (nrows, ncols)
	    =
	    if  (nrows < 0
	    or   ncols < 0
	    )
		raise exception exceptions_guts::SIZE;
	    else
		n = nrows * ncols
		    except
			OVERFLOW = raise exception exceptions_guts::SIZE;

		if (n > core::maximum_vector_length)	raise exception exceptions_guts::SIZE;	fi;

		n;
	    fi;

	fun make_matrix ((nrows, ncols), v)
	    =
	    case (check_size (nrows, ncols))
		#
		0 => { data => inl::poly_rw_vector::make_zero_length_vector(), nrows => 0, ncols => 0 };
		n => { data => make_matrix' (n, v), nrows, ncols };
	    esac;

	fun from_list rows
	    =
	    case (list::reverse rows)
		#	  
		[]  =>
		    { data  => inl::poly_rw_vector::make_zero_length_vector(),
		      nrows => 0,
		      ncols => 0
		    };

		last_row ! rest
		    =>
		    {
			columns = list::length last_row;


			fun check ([], rows, l)
				=>
				(rows, l);

			    check (row ! rest, rows, l)
				=>
				check (rest, rows+1, check_row (row, 0))
				where
				    fun check_row ([], n)
					    =>
					    {   if   (n != columns   )   raise exception exceptions_guts::SIZE;   fi;
						l;
					    };

					check_row (x ! r, n)
					    =>
					    x ! check_row (r, n+1);
				    end;
				end;
			end;

			(check (rest, 1, last_row))
			    ->
			    (rows, data);
			    

			{ data => rw_vector::from_list data, nrows => rows, ncols => columns };
		    };
	    esac;



	fun from_fn ((nrows, ncols), f)
	    =
	    case (check_size (nrows, ncols))
		#
		0 => { data => inl::poly_rw_vector::make_zero_length_vector(), nrows, ncols };
		#
		n => {

		    arr = make_matrix' (n, f (0, 0));

		    fun lp1 (i, j, k)
			=
			if (i < nrows)
			    #
			    lp2 (i, 0, k);
			fi

		    also
		    fun lp2 (i, j, k)
			=
			if (j < ncols)
			    #
			    unsafe_set (arr, k, f (i, j));
			    lp2 (i, j+1, k+1);
			else
			    lp1 (i+1, 0, k);
			fi;

		    lp2 (0, 1, 1);  #  we've already done (0, 0) 

		    { data => arr, nrows, ncols };
		};
	    esac;



	fun get (a, (i, j))    =  unsafe_get (a.data, index (a, i, j));
	fun set (a, (i, j), v) =  unsafe_set (a.data, index (a, i, j), v);


	fun dimensions { data, nrows, ncols }
	    =
	    (nrows, ncols);


	fun columns (arr:  Rw_Matrix(X)) =  arr.ncols;
	fun rows    (arr:  Rw_Matrix(X)) =  arr.nrows;


	fun row ( { data, nrows, ncols }, i)
	    =
	    {   stop = i*ncols;
		#
		fun make_vec (j, l)
		    =
		    if (j < stop)
			 vector::from_list l;
		    else
			 make_vec (j - 1, rwv::get (data, j) ! l);
		    fi;

		if (not (ltu (nrows, i)))
		    #
		    make_vec (stop+ncols - 1, []);
		else 
		    raise exception exceptions_guts::SUBSCRIPT;
		fi;
	    };

	fun column ( { data, nrows, ncols }, j)
	    =
	    {   fun make_vec (i, l)
		    =
		    if (i < 0)
			vector::from_list l;
		    else
			make_vec (i-ncols, rwv::get (data, i) ! l);
		    fi;

		if (not (ltu (ncols, j)))
		    make_vec ((rwv::length data - ncols) + j, []);	           
		else
		    raise exception exceptions_guts::SUBSCRIPT;
		fi;
	    };

	Index = DONE
	      | INDEX  { i: Int, r: Int, c: Int }
	      ;

	fun check_region { base=> { data, nrows, ncols }, row, col, nrows=>nr, ncols=>nc }
	    =
	    {   fun check (start, n, NULL)
			=>
			if  (start < 0
			or   start > n
			)
			     raise exception exceptions_guts::SUBSCRIPT;
			else
			     n-start;
			fi;

		    check (start, n, THE len)
			=>
			if ((start < 0) or (len < 0) or (n < start+len))
			    #
			    raise exception exceptions_guts::SUBSCRIPT;
			else
			    len;
			fi;
		end;

		nr = check (row, nrows, nr);
		nc = check (col, ncols, nc);

		{ data, i => (row*ncols + col), r=>row, c=>col, nr, nc };
	    };

	fun copy { src:  Region(X), dst: Rw_Matrix(X), dst_row, dst_col }
	    =
	    {   check_region src;

		src -> { base,
			row    => srow,   col   => scol,
			 nrows => snrows, ncols => sncols
		       };

		base ->  { data => bdata, ncols => bncols, nrows => bnrows };
		dst  ->  { data => ddata, ncols => dncols, nrows => dnrows };

		src_nrows = the_else (snrows, bnrows - srow);
		src_ncols = the_else (sncols, bncols - scol);

		fun dn (i, d, s)
		    =
		    if (i > 0 )
			#
			# We might be better off doing this directly
			# instead of calling the rw_vector_slice module:
			#	
			rws::copy { src => rws::make_slice (bdata, s, THE src_ncols),
				   dst => ddata, di => d
				 };

			dn (i - 1, d + dncols, s + bncols);
		    fi;


		fun up (i, d, s)
		    =
		    if (i > 0)
			#
			rws::copy { src => rws::make_slice (bdata, s, THE src_ncols),
				   dst => ddata, di => d
				 };

			up (i - 1, d - dncols, s - bncols);
		    fi;

		if  (src_nrows + dst_row > dnrows
		or   src_ncols + dst_col > dncols
		)
		    raise exception exceptions_guts::SUBSCRIPT;
		else
		    if (dst_row <= srow)
			#
			dn ( src_nrows,
			     dst_row * dncols + dst_col,
			     srow * bncols + scol
			   );
		    else
			up ( src_nrows,
			     (dst_row + src_nrows - 1) * dncols + dst_col,
			     (srow + src_nrows - 1) * bncols + scol
			   );
		    fi;
		fi;
	    };


	# This function generates a stream of indices
	# for the given region in row-major order.
	#
	fun iterate arg
	    =
	    (data, iter)
	    where  

		(check_region arg)
		    ->
		    { data, i, r, c=>c_start, nr, nc };

		ii = REF i;
		ri = REF r;
		ci = REF c_start;

		r_end = r+nr;
		c_end = c_start+nc;

		row_delta = arg.base.ncols - nc;

		fun make_index (r, c)
		    =
		    {   i = *ii;
			#
			ii := i+1;
			INDEX { i, c, r };
		    };

		fun iter ()
		    =
		    {   r = *ri;
			c = *ci;

			if (c < c_end)
			    #
			    ci := c+1;
			    make_index (r, c);

			elif (r+1 < r_end)

			    ii := *ii + row_delta;
			    ci := c_start;
			    ri := r+1;

			    iter ();
			else
			    DONE;
			fi;
		    };
		end;

	fun keyed_apply  f region
	    =
	    apply ()
	    where
		(iterate region) ->    (data, iter);


		fun apply ()
		    =
		    case (iter ())
			#
			DONE => ();

			INDEX { i, r, c }
			    =>
			    {   f (r, c, unsafe_get (data, i));

				apply ();
			    };
		    esac;
	    end;


	fun apply f { data, ncols, nrows }
	    =
	    rwv::apply f data;


	fun keyed_map_in_place f region
	    =
	    modify ()
	    where
		(iterate  region) ->   (data, iter);

		fun modify ()
		    =
		    case (iter ())
			#
			DONE => ();

			INDEX { i, r, c }
			    =>
			    {   unsafe_set (data, i, f (r, c, unsafe_get (data, i)));
				modify();
			    };
		    esac;
	    end;


	fun map_in_place f { data, ncols, nrows }
	    =
	    rwv::map_in_place  f  data;


	fun foldi f init region
	    =
	    fold init
	    where

		(iterate  region) ->   (data, iter);

		fun fold accum
		    =
		    case (iter ())
			#
			DONE => accum;

			INDEX { i, r, c }
			    =>
			    fold (f(r, c, unsafe_get (data, i), accum));
		    esac;
	    end;


	fun fold f init { data, ncols, nrows }
	    =
	    rwv::fold_forward f init data;


    };
end;



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1997 AT&T Research.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
