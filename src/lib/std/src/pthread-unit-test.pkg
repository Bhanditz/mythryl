## pthread-unit-test.pkg
#
# Unit/regression test functionality for
#
#    src/lib/std/src/pthread.pkg
#
# (Multiple posix threads sharing the Mythryl
# heap and executing Mythryl code.)

# Compiled by:
#     src/lib/test/unit-tests.lib

# Run by:
#     src/lib/test/all-unit-tests.pkg

package pthread_unit_test {
    #
    include unit_test;							# unit_test			is from   src/lib/src/unit-test.pkg

    my name = "src/lib/std/src/pthread-unit-test.pkg";

    fun verify_that_basic_spawn_and_join_are_working ()
	=
	{   foo = REF 0;
	    #
	    fun subthread_fn ()
		=
		{   makelib::scripting_globals::sleep 0.01;		# Give main thread a good chance to finish early if join_pthread is totally broken.
		    #
		    foo := 1;						# Give main thread visible evidence that we've run.
		    #
		    pthread::pthread_exit ();				# Die.
		};

	    subthread = pthread::spawn_pthread  subthread_fn;		# Spawn a subthread.
	    #
	    pthread::join_pthread  subthread;				# Wait for subthread to exit.
	    #
	    assert (*foo == 1);						# Verify that subthread did what we expected.
	};


    fun verify_that_basic_mutex_stuff_is_working ()
	=
	{   foo = REF 0; 
	    #
	    mutex = pthread::make_mutex (); 
	    pthread::set_up_mutex (mutex, NULL); 
	    pthread::acquire_mutex mutex; 

	    fun subthread_fn () 
		= 
		{   pthread::acquire_mutex mutex; 
		    # 
		    foo := 1; 
		    # 
		    pthread::release_mutex mutex; 
		    # 
		    pthread::pthread_exit (); 
		}; 

	    pthread =  pthread::spawn_pthread  subthread_fn; 

	    makelib::scripting_globals::sleep 0.01; 			# Give child a chance to run if mutex does not block properly.

	    assert (*foo == 0);						# Verify that child has not run.

	    pthread::release_mutex mutex; 				# Unblock child.

	    pthread::join_pthread pthread; 				# Join child.

	    pthread::free_mutex mutex;

	    assert (*foo == 1);						# Verify that child has now run.
	};

    fun verify_that_successful_trylock_works ()
	=
	{   mutex = pthread::make_mutex ();
	    #
	    pthread::set_up_mutex (mutex, NULL);
	    #
	    fun subthread_fn ()
		=
		{   assert ((pthread::try_mutex mutex) == pthread::ACQUIRED_MUTEX);
		    #
		    pthread::release_mutex mutex;			# Why not.

		    pthread::pthread_exit ();
		};

	    pthread = pthread::spawn_pthread  subthread_fn;

	    pthread::join_pthread pthread;

	    pthread::free_mutex mutex;
	};

    fun verify_that_unsuccessful_trylock_works ()
	=
	{   mutex = pthread::make_mutex ();
	    #
	    pthread::set_up_mutex (mutex, NULL);
	    #
	    pthread::acquire_mutex mutex;

	    fun subthread_fn ()
		=
		{   assert ((pthread::try_mutex mutex) == pthread::MUTEX_WAS_UNAVAILABLE);
		    #
		    pthread::pthread_exit ();
		};

	    pthread = pthread::spawn_pthread  subthread_fn;

	    makelib::scripting_globals::sleep 1.11;

	    pthread::release_mutex mutex;

	    pthread::join_pthread pthread;

	    pthread::free_mutex mutex;
	};

    fun verify_that_basic_barrier_wait_works ()
	=
	{   foo = REF 0;
	    #
	    mutex = pthread::make_mutex ();
	    pthread::set_up_mutex (mutex, NULL);

	    barrier = pthread::make_barrier ();
	    pthread::set_up_barrier { barrier, threads => 3 };

	    fun subthread_fn ()
		=
		{   pthread::wait_on_barrier barrier;
		    #
		    pthread::acquire_mutex mutex;
			#
			foo := *foo + 1;
			#
		    pthread::release_mutex mutex; 
		    #
		    pthread::pthread_exit ();
		};

	    subthread1 = pthread::spawn_pthread  subthread_fn;
	    subthread2 = pthread::spawn_pthread  subthread_fn;

	    makelib::scripting_globals::sleep 0.01;

	    assert (*foo == 0);

	    pthread::wait_on_barrier barrier;
	    pthread::clear_barrier   barrier;

	    pthread::join_pthread subthread1;

	    pthread::join_pthread subthread2;

	    assert (*foo == 2);

	    pthread::free_mutex mutex;
	    pthread::free_barrier barrier;
	};

    fun verify_barrier_wait_return_value ()
	=
	{
	    foo = REF 0;						# Every pthread will increment this.
	    bar = REF 0;						# Only the One True Pthread will increment this.

	    mutex = pthread::make_mutex ();
	    pthread::set_up_mutex (mutex, NULL);

	    barrier = pthread::make_barrier ();
	    pthread::set_up_barrier { barrier, threads => 3 };

	    fun subthread_fn ()
		=
		{
		    if (pthread::wait_on_barrier barrier)		# Exactly one pthread waiting on barrier should see a TRUE return value.
			#
			pthread::acquire_mutex mutex;
			    #
			    foo := *foo + 1;
			    bar := *bar + 1;
			    #
			pthread::release_mutex mutex;
		    else
			pthread::acquire_mutex mutex;
			    #
			    foo := *foo + 1;
			    #
			pthread::release_mutex mutex;
		    fi; 
		    #
		    pthread::pthread_exit ();
		};

	    subthread1 = pthread::spawn_pthread  subthread_fn;
	    subthread2 = pthread::spawn_pthread  subthread_fn;
	    subthread3 = pthread::spawn_pthread  subthread_fn;


	    pthread::join_pthread subthread1;
	    pthread::join_pthread subthread2;
	    pthread::join_pthread subthread3;

	    pthread::clear_barrier   barrier;

	    assert (*foo == 3);
	    assert (*bar == 1);

	    pthread::free_mutex mutex;
	    pthread::free_barrier barrier;
	};

    fun run ()
        =
        {   printf "\nDoing %s:\n" name;   
	    #
	    assert( pthread::get_pthread_id()  !=  0 );
		#
		# This is mostly just to verify that	src/c/lib/pthread/libmythryl-pthread.c
		# and					src/c/pthread/pthread-on-posix-threads.c
		# were compiled and linked into our
		# runtime executable.

	    verify_that_basic_spawn_and_join_are_working ();
	    verify_that_basic_mutex_stuff_is_working ();
	    verify_that_successful_trylock_works ();
	    verify_that_unsuccessful_trylock_works ();
	    verify_that_basic_barrier_wait_works ();
	    verify_barrier_wait_return_value ();
	    #
            summarize_unit_tests  name;
	};
};

