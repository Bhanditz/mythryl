## template-pthread.pkg
#
# This is the skeleton for persistent server pthread;
# the intention is to simplify construction of new
# server pthreads via clone-and-mutate.

# Compiled by:
#     src/lib/std/src/standard-core.sublib


stipulate
    package pth =  pthread;							# pthread			is from   src/lib/std/src/pthread.pkg
herein

    package template_pthread
    :       Template_Pthread							# Template_Pthread		is from   src/lib/std/src/pthread/template-pthread.api
    { 
	mutex   =  pth::make_mutex   (); 
	condvar =  pth::make_condvar ();  

	# One record for each request type
	# supported by the server:

	Do_This =  { input: Int,	reply: Int    -> Void };		# Edit to suit. The 'reply' thunks will typically send a do_something() request back to the originating pthread.
	Do_That =  { input: String,	reply: String -> Void };

	Request =  DO_THIS  Do_This
		|  DO_THAT  Do_That
		; 

	request_queue =  REF ([]: List(Request)); 

	fun request_queue_is_empty ()
	    =
	    case *request_queue    [] => TRUE;
	                           _  => FALSE;
	    esac;

	fun do_this' (r: Do_This)
	    =
	    {   # Edit to do actual work before replying.
		# This is the meat of the server:
		#
		r.reply r.input;
	    };

	fun do_that' (r: Do_That)
	    =
	    {   # Edit to do actual work before replying.
		# This is the meat of the server:
		#
		r.reply r.input;
	    };


	fun do_this  (request: Do_This)
	    = 
	    { 
		pth::acquire_mutex mutex;  
		    # 
		    request_queue :=  (DO_THIS request)  !  *request_queue; 
		    # 
		    pth::broadcast_condvar condvar;  
		    # 
		pth::release_mutex mutex;  
	    };           

	fun do_that  (request: Do_That)
	    = 
	    { 
		pth::acquire_mutex mutex;  
		    # 
		    request_queue :=  (DO_THAT request)  !  *request_queue; 
		    # 
		    pth::broadcast_condvar condvar;  
		    # 
		pth::release_mutex mutex;  
	    };           

	fun get_new_requests  () 
	    = 
	    { 
		pth::acquire_mutex mutex;  
		    # 
		    for (request_queue_is_empty()) {
			#
			pth::wait_on_condvar (condvar, mutex);
		    };

		    new_requests  = reverse  *request_queue; 		# 'reverse' to restore original request ordering.
		    # 
		    request_queue := []; 
		    # 
		pth::release_mutex  mutex;  
		# 
		new_requests; 
	    };           

	fun server_loop () 
	    = 
	    {   service_requests (get_new_requests()); 
		#
		server_loop (); 
	    } 
	   where 
		fun service_requests  [] 
			=> 
			(); 

		    service_requests  (request ! rest) 
			=> 
			{   service_request request; 
			    service_requests rest; 
			} 
			where 
			    fun service_request (DO_THIS r) =>  do_this' r; 
				service_request (DO_THAT r) =>  do_that' r;
			    end; 
			end;
		end; 
	    end; 

#                                                                my _ = 	# Commented out to conserve resources;
#        pth::spawn_pthread  server_loop;					# Uncomment these two lines for actual use.
    };

end;

## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
