# io-wait-pthread.api
#
# Interface to a server pthread designed to basically just
# sit in a loop doing C select() over and over on whatever
# file/pipe/socket descriptors are of current interest.
#
# Our main purpose is to offload I/O blocking from the
# main threadkit pthread so that it can run full speed				# Threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.api
# while we sit around waiting for network packets to arrive.			# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
#
# A secondary purpose of io_wait_pthread is to provide the
# clock threadkit needs to drive its pre-emptive timeslicing.
# Reppy's original CML implementation uses SIGALRM for this,
# but this has two critical disadvantages:
#
#  o  SIGALRM is a bottleneck resource which everyone wants
#     to control.
#
#  o  Worse, SIGALRM interrupts "slow" system calls, causing
#     them to return EINTR instead of a useful result, requiring
#     the relevant C code to re-try.  We can ensure that our own
#     C support code does this, but one call -- connect() --
#     *cannot* be retried, and we cannot be sure that all C
#     libraries linked into the runtime will retry properly
#     on EINTR. (In fact, I'd bet good odds that some will not.)
#
# By having our select() time out regularly and generate
# a timeslice clock for threadkit based on those timeouts
# we avoid those problems completely.
#
# See also:
#
#     src/lib/std/src/pthread/cpu-bound-task-pthreads.api
#     src/lib/std/src/pthread/io-bound-task-pthreads.api

# Compiled by:
#     src/lib/std/standard.lib

stipulate
    package tim =  time;							# time				is from   src/lib/std/time.pkg	
    package pth =  pthread;							# pthread			is from   src/lib/std/src/pthread.pkg
    package wio =  winix::io;							# winix::io			is from   src/lib/std/src/posix/winix-io.pkg
herein

    # This api is implemented in:
    #
    #     src/lib/std/src/pthread/io-wait-pthread.pkg
    #
    api Io_Wait_Pthread {
	#
	is_running: Void -> Bool;						# Returns TRUE iff the server pthread is running.
	#
	start:      String -> Bool;						# Clear the internal wait-request list and
										# start the select() pthread running (if it is not already running).
										# Returns TRUE if it started the server pthread, in which case 'String' will be logged as the client requesting startup.
										# Returns FALSE if server pthread was already running.

	Do_Stop
	  =
	  { who:   String,
	    reply: Void -> Void
	  };
        stop:     Do_Stop -> Void;

	Do_Echo
	  =
	  { what:  String,						# Primarily to test that the server is running.
	    reply: String -> Void
	  };
        echo:     Do_Echo -> Void;


        Do_Note_Iod_Reader
	  =
	  { io_descriptor:	wio::Io_Descriptor,
	    read_fn:		wio::Io_Descriptor -> Void		# Call this closure ("function") on iod whenever input is available.
	  };
	note_iod_reader: Do_Note_Iod_Reader -> Void;
	drop_iod_reader: wio::Io_Descriptor -> Void;


        Do_Note_Iod_Writer
	  =
	  { io_descriptor:	wio::Io_Descriptor,
	    write_fn:		wio::Io_Descriptor -> Void		# Call this closure ("function") on iod whenever input is available.
	  };
	note_iod_writer: Do_Note_Iod_Writer -> Void;
	drop_iod_writer: wio::Io_Descriptor -> Void;


        Do_Note_Iod_Oobder
	  =
	  { io_descriptor:	wio::Io_Descriptor,
	    oobd_fn:		wio::Io_Descriptor -> Void		# Call this closure ("function") on iod whenever out-of-band-data ("oobd") is available.
	  };
	note_iod_oobder: Do_Note_Iod_Oobder -> Void;
	drop_iod_oobder: wio::Io_Descriptor -> Void;



	get_timeout_interval:  Void -> tim::Time;
	set_timeout_interval:  tim::Time -> Void;
	    #
	    # The main job of io-wait-pthread.pkg is to sit
	    # eternally in loop running  wio::wait_for_io_opportunity.
	    # These two calls control the timeout for that call.

	get_per_loop_fn:	Void ->  Null_Or(Void -> Void);
	set_per_loop_fn:	Null_Or(Void -> Void) -> Void;
	    #
	    # The io_wait_pthread server will call this fn
	    # once each time around the loop.  This is intended
	    # mainly to provide the threadkit scheduler with a
	    # clean way of generating a clock "tick" for pre-emptive
	    # timeslicing.
	    #
	    # Note that if there is a lot of I/O going on, the
	    # loop fn may be called much more frequently than the
	    # timeout interval would suggest.  It is up to the
	    # client to deal with this, if it is a problem.
    };
end;

## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
