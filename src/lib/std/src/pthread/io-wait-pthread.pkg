# io-wait-pthread.pkg
#
# For background, see "Overview" comments in    src/lib/std/src/pthread/io-wait-pthread.api
#

# Compiled by:
#     src/lib/std/standard.lib

stipulate
    package fil =  file;							# file				is from   src/lib/std/src/posix/file.pkg
    package psx =  posix_1003_1b;						# posix_1003_1b			is from   src/lib/std/src/posix-1003.1b/posix-1003-1b.pkg
    package pth =  pthread;							# pthread			is from   src/lib/std/src/pthread.pkg
    package tim =  time;							# time				is from   src/lib/std/time.pkg
    package wio =  winix::io;							# winix::io			is from   src/lib/std/src/posix/winix-io.pkg
    package wxp =  winix::process;						# winix::process		is from   src/lib/std/src/posix/winix-process.pkg
herein

    package   io_wait_pthread
    : (weak)  Io_Wait_Pthread							# Io_Wait_Pthread		is from   src/lib/std/src/pthread/io-wait-pthread.api
    {
	pid = REF 0;								# pid of current process while server is running, otherwise zero.

	fun is_running ()
	    =
	    (*pid != 0  and   *pid == wxp::get_process_id ());			# This way, if the heap gets dumped to disk and then and reloaded, is_running() will
										# (correctly) return FALSE, even though pid may not have gotten zeroed.

	mutex   =  pth::make_mutex   (); 					# These will actually survive a heap dump/load cycle, pretty much.
	condvar =  pth::make_condvar ();  

	Pipe    =  { infd:   psx::File_Descriptor,
                     outfd:  psx::File_Descriptor
                   };

	pipe    =  REF (NULL: Null_Or( Pipe ));

	wait_requests =  REF ([]:  List( wio::Wait_Request )  );		# This is the set of file descriptors to select() on.
	timeout	      =  REF (tim::from_float_seconds 0.02);			# Set up to timeout at 50Hz.

	# One record type for each request
	# supported by the server:
	#
	Do_Stop =  { who:   String,	reply: Void   -> Void };		# Edit to suit. The 'reply' thunks will typically send a do_something() request back to the originating pthread.
	Do_Echo =  { what:  String,	reply: String -> Void };

	Request =  DO_STOP  Do_Stop						# Union of above record types, so that we can keep them all in one queue.
		|  DO_ECHO  Do_Echo
		; 

	request_queue =  REF ([]: List(Request)); 

	fun request_queue_is_empty ()						# We cannot write just    fun request_queue_is_empty () =  (*request_queue == []);
	    =									# because Request is not an equality type. (The 'reply' fields are functions
	    case *request_queue    [] => TRUE;					# and Mythryl does not support comparison of thunks for equality.)
	                           _  => FALSE;
	    esac;



	fun default_wait_request_list (pipe: Pipe)
	    =
	    {   # Our minimal request list is to read
		# the pipe that clients use to wake us:
		#
		io_descriptor =  psx::fd_to_iod  pipe.infd;
		#
		[
		  { io_descriptor,
		    readable => TRUE,
		    writable => FALSE,
		    oobdable => FALSE
		  }
		]; 
	    };

	fun do_stop (r: Do_Stop)						# Internal fn -- will execute in context of server pthread.
	    =
	    {   case *pipe							# Close pipe fds, so that we don't leak fds continually
		    #								# if some idiot stops and starts us continually.
		    THE { infd, outfd }
			=>
			{   psx::close infd;
			    psx::close outfd;
			};

		    NULL => ();
		esac;
		#
		fil::log  .{ "src/lib/std/src/pthread/io-wait-pthread.pkg: Shutting down per request from '" + r.who + "'."; };
		#
		pid := 0;
		#
		r.reply ();
		#
		pthread::pthread_exit ();		
	    };

	fun do_echo (r: Do_Echo)						# Internal fn -- will execute in context of server pthread.
	    =
	    {
		r.reply r.what;
	    };


	###############################################
	# The rest of the file is mostly boilerplate:
	###############################################

	fun stop  (request: Do_Stop)						# External fn -- will execute in context of client pthread.
	    = 
	    { 
		pth::acquire_mutex mutex;  
		    # 
		    request_queue :=  (DO_STOP request)  !  *request_queue; 
		    # 
		    pth::broadcast_condvar condvar;  
		    # 
		pth::release_mutex mutex;  
	    };           

	fun echo  (request: Do_Echo)						# External fn -- will execute in context of client pthread.
	    = 
	    { 
		pth::acquire_mutex mutex;  
		    # 
		    request_queue :=  (DO_ECHO request)  !  *request_queue; 
		    # 
		    pth::broadcast_condvar condvar;  
		    # 
		pth::release_mutex mutex;  
	    };           

	fun get_new_requests  () 
	    = 
	    { 
		pth::acquire_mutex mutex;  
		    # 
		    for (request_queue_is_empty()) {
			#
			pth::wait_on_condvar (condvar, mutex);
		    };

		    new_requests  = reverse  *request_queue; 			# 'reverse' to restore original request ordering.
		    # 
		    request_queue := []; 
		    # 
		pth::release_mutex  mutex;  
		# 
		new_requests; 
	    };           

	fun do_select ()
	    =
	    {   fds_ready_for_io
		    =
		    wio::wait_for_io_opportunity
		      { 
			wait_requests =>  *wait_requests,
			timeout	      =>  THE *timeout
		      };
		    
		process_io_ready_fds  fds_ready_for_io;
	    }
	    where
		fun process_io_ready_fds  []         => ();
		    process_io_ready_fds  (r ! rest) => {   process_io_ready_fd  r;
							    process_io_ready_fds rest;
							};
		end

		also
		fun process_io_ready_fd  { io_descriptor, readable, writable, oobdable }
		    =
		    {   pipe =  the *pipe;
			#
			if (io_descriptor == psx::fd_to_iod  pipe.infd)
			    #
			    psx::read_vector					# Read and discard the byte that was sent to us.
			      {
				file_descriptor   => pipe.infd,
				max_bytes_to_read => 1
			      };

			    ();
			else
			    ();
			fi;
		    };
	    end;


	fun server_loop () 
	    = 
	    {   service_requests (get_new_requests()); 
		#
		server_loop (); 
	    } 
	   where 
		fun service_requests  [] 
			=> 
			(); 

		    service_requests  (request ! rest) 
			=> 
			{
			    service_request request; 
			    #
			    service_requests rest; 
			} 
			where 
			    fun service_request (DO_STOP r) =>  do_stop r; 
				service_request (DO_ECHO r) =>  do_echo r;
			    end; 
			end;
		end; 
	    end; 


	fun start who								# 'who' is a string identifying the client requesting the startup, for logging purposes.
	    =
	    {   pth::acquire_mutex mutex;  
		#
		if (not (is_running ()))
		    #
		    fil::log  .{ "src/lib/std/src/pthread/io-wait-pthread.pkg: Starting up server loop in response to '" + who + "'."; };

		    pid :=  wxp::get_process_id ();

		    pth::release_mutex  mutex;  

		    pipe	  :=  THE (psx::make_pipe ());			# We do not close any existing pipe fds here because they might be stale stuff from before a heap dump/load cycle,
		     								# in which case closing them might close something we actually want this time around.

		    wait_requests :=  default_wait_request_list (the *pipe);	# By default we listen only on our private pipe.

		    timeout	  :=  tim::from_float_seconds  0.02;		# Start up with timeout frequency set to 50Hz.

		    pth::spawn_pthread  server_loop;

		    TRUE;
		else
		    # We re-initialize in this case also, so that
		    # clients will see simple predictable semantics:

		    # NB: Since we're running, we have a valid pipe;
		    # there is no reason to create a new one here.
		    
		    wait_requests :=  default_wait_request_list (the *pipe);

		    timeout	  :=  tim::from_float_seconds 0.02;

		    pth::release_mutex  mutex;  

		    FALSE;
		fi;
	    };

    };
end;

#######################################################################
# Note[1]
# Most pthread servers block on their request_queue when not busy,
# and thus can be woken by a simple pth::broadcast_condvar, but
# here we will be spending almost all our time blocked in a select(),
# so that will not work.
#
# Consequently we use a dedicated pipe to wake our server pthread.
# By always including a read of this pipe in our select() we ensureq
# that the server pthread can always we woken just by writing one
# byte to the pipe.

## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
