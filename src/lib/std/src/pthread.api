# pthread.api
#
# Mythryl-level interface to support for parallel computation
# via kernel threads (on Linux, Posix threads).
#
# We are the Mythryl side of the
#
#     src/c/lib/pthread/libmythryl-pthread.c
#
# interface to functionality defined in
#
#     src/c/h/runtime-pthread.h   
#
# and implemented in the platform-specific files
#
#     src/c/pthread/pthread-on-posix-threads.c				# pthread build on top of modern posix threads interface.
#     src/c/pthread/pthread-on-sgi.c					# pthread built on top of 1994-era SGI Irix interface.
#     src/c/pthread/pthread-on-solaris.c				# pthread build on top of 1994-era Solaris   interface.

# Compiled by:
#     src/lib/std/src/standard-core.sublib

stipulate
    package fat =  fate;						# fate					is from   src/lib/std/src/nj/fate.pkg
herein

    # This api is implemented in:
    #
    #     src/lib/std/src/pthread.pkg
    #
    api Pthread {
	#
	# For the momeent this is translated directly from p7 of
	#
	#       A Portable Multiprocessor Interface for Standard ML of New Jersey 
	#       Morrisett + Tolmach 1992 31p 
	#       http://handle.dtic.mil/100.2/ADA255639
	#       http://mythryl.org/pub/pml/a-portable-multiprocessor-interface-for-smlnj-morrisett-tolmach-1992.ps 
	#
	#

	# We present posix-theads, barriers, condition variables
	# and mutexes as opaque values to our client packages:
	#
	Pthread;
	Barrier;
	Condvar;
	Mutex;

	Try_Mutex_Result =  ACQUIRED_MUTEX | MUTEX_WAS_UNAVAILABLE;

	exception MAKE_PTRHEAD;

	get_pthread_id:		Void -> Int;

	spawn_pthread:		fat::Fate(Void) -> Pthread;
	pthread_exit:		Void -> X;

	# Mutual-exclusion locks:
	#
	make_mutex:		Void -> Mutex;
	free_mutex:		Mutex -> Void;
	set_mutex:		(Mutex, Null_Or(Void)) -> Void;				# For now, always use NULL as the arg. (Futureproofing.)
	clear_mutex:		Mutex -> Void;
	acquire_mutex:		Mutex -> Void;
	release_mutex:		Mutex -> Void;
	try_mutex:		Mutex -> Try_Mutex_Result;

	# Condition variables:
	#
	make_condvar:		Void -> Condvar;
	free_condvar:		Condvar -> Void;
	set_condvar:		(Condvar, Null_Or(Void)) -> Void;			# For now, always use NULL as the arg. (Futureproofing.)
	clear_condvar:		Condvar -> Void;
	wait_on_condvar:	(Condvar, Mutex) -> Void;
	signal_condvar:		Condvar -> Void;
	broadcast_condvar:	Condvar -> Void;

	# Barriers: Nobody proceeds until everyone proceeds:
	#
	make_barrier:		Void -> Barrier;
	free_barrier:		Barrier -> Void;
	set_barrier:		{ barrier: Barrier, threads: Int } -> Void;		# 'threads' is number of threads which must arrive at barrier before it will release them.
	clear_barrier:		Barrier -> Void;
	wait_on_barrier:	Barrier -> Bool;					# Exactly one pthread waiting at barrier gets TRUE value.
    };
end;

## Code by Jeff Prothero: Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
