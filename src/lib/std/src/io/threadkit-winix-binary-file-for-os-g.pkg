## threadkit-winix-binary-file-for-os-g.pkg
#
# Generic package which combines platform-specific code wxd
# with platform-agnostic body code to produce a complete
# platform-specific binary-file package.
#
# This is the binary-file equivalent to
#
#     src/lib/std/src/io/threadkit-winix-text-file-for-os-g.pkg
#
# It is the multithread alternative to
#
#     src/lib/std/src/io/winix-binary-file-for-os-g.pkg
#
# This is the threadkit version of the binary_file generic package
#
#     src/lib/std/src/io/winix-binary-file-for-os-g.pkg

# Compiled by:
#     src/lib/std/standard.lib




stipulate
    package iox =  io_exceptions;							# io_exceptions						is from   src/lib/std/src/io/io-exceptions.pkg
    package eow =  threadkit_io_cleanup_at_shutdown;	# "eow" == "end of world"	# threadkit_io_cleanup_at_shutdown			is from   src/lib/std/src/io/threadkit-io-cleanup-at-shutdown.pkg
    #
    package wv  = rw_vector_of_one_byte_unts;						# rw_vector_of_one_byte_unts				is from   src/lib/std/src/rw-vector-of-one-byte-unts.pkg
    package wvs = rw_vector_slice_of_one_byte_unts;					# rw_vector_slice_of_one_byte_unts			is from   src/lib/std/src/rw-vector-slice-of-one-byte-unts.pkg
    #
    package rv  = vector_of_one_byte_unts;						# vector_of_one_byte_unts				is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package rvs = vector_slice_of_one_byte_unts;					# vector_slice_of_one_byte_unts				is from   src/lib/std/src/vector-slice-of-one-byte-unts.pkg
    #
    package pos = file_position;							# file_position						is from   src/lib/std/file-position.pkg
herein

    # This generic is invoked (only) in:
    #     
    #     src/lib/std/src/posix/threadkit-binary-file.pkg
    #
    generic package   threadkit_winix_binary_file_for_os_g (
	#             ====================================
	#										# Threadkit_Winix_Extended_File_Io_Driver_For_Os	is from   src/lib/std/src/io/threadkit-winix-extended-file-io-driver-for-os.api
											# threadkit_winix_binary_file_io_driver_for_posix	is from   src/lib/std/src/posix/threadkit-winix-binary-file-io-driver-for-posix.pkg
	package wxd									# "wxd" == "WiniX file io Driver"
	    :
	    Threadkit_Winix_Extended_File_Io_Driver_For_Os
		where  drv::Rw_Vector       == threadkit_winix_base_binary_file_io_driver_for_posix::Rw_Vector
		where  drv::Vector          == threadkit_winix_base_binary_file_io_driver_for_posix::Vector
		where  drv::Rw_Vector_Slice == threadkit_winix_base_binary_file_io_driver_for_posix::Rw_Vector_Slice
		where  drv::Vector_Slice    == threadkit_winix_base_binary_file_io_driver_for_posix::Vector_Slice
		where  drv::Element         == threadkit_winix_base_binary_file_io_driver_for_posix::Element
		where  drv::File_Position   == threadkit_winix_base_binary_file_io_driver_for_posix::File_Position
		where  drv::Filereader	    == threadkit_winix_base_binary_file_io_driver_for_posix::Filereader
		where  drv::Filewriter	    == threadkit_winix_base_binary_file_io_driver_for_posix::Filewriter;
    )

    : (weak)  Threadkit_Winix_Binary_File_For_Os			# Threadkit_Winix_Binary_File_For_Os	is from   src/lib/std/src/io/threadkit-winix-binary-file-for-os.api

    {
	include threadkit;						# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg

	package drv = wxd::drv;						# wxd	is our argument.



	# Assign to a maildrop:
	#
	fun update_maildrop (mv, x)
	    =
	    {   empty mv;
		fill (mv, x);
	    };

	# An element for initializing buffers:
	#
	some_element = (0u0:  one_byte_unt::Unt);

	vec_extract =  rvs::to_vector o rvs::make_slice;
	vec_get     =  rv::get;
	rw_vec_set  =  wv::set;
	empty_vec   =  rv::from_list [];

	fun dummy_cleaner () = ();

	package pur {							# "pur" is short for "pure" (I/O).

	    Vector   = rv::Vector;
	    Element  = rv::Element;

	    Filereader    =  drv::Filereader;
	    Filewriter    =  drv::Filewriter;
	    File_Position =  drv::File_Position;

	    # ** Functional input streams **
	    #
	    Input_Stream
		=
		INPUT_STREAM  (Input_Buffer, Int)

	    also
	    Input_Buffer
		=
		INPUT_BUFFER
		  {
		    base_position:  Null_Or( File_Position ),
		    next:           Maildrop( Next ),		# When this cell is empty, it means that 
								# there is an outstanding request to the 
								# server to extend the stream. 
		    data:  Vector,
		    reader_info:  Reader_Info
		  }

	    also
	    Next
	      = NEXT  Input_Buffer	# Forward link to additional data.
	      | NO_NEXT			# Placeholder for forward link.
	      | TERMINATED		# Termination of the stream.

	    also
	    Reader_Info
		=
		READER_INFO
		  {
		    reader:		Filereader,
		    read_vector:	Int -> Vector,
		    read_vec_mailop:	Int -> threadkit::Mailop( Vector ),

		    is_closed:		Ref( Bool ),
		    get_position:	Void -> Null_Or( File_Position ),
		    tail:		Maildrop(  Maildrop(  Next ) ),		# Points to the next cell of the last buffer.

		    clean_tag:		eow::Tag
		  };

	    fun reader_info_of_ibuf (INPUT_BUFFER { reader_info, ... } )
		=
		reader_info;

	    fun best_io_quantum_of_ibuf buf
		=
		{   (reader_info_of_ibuf  buf)
			->
			READER_INFO { reader => drv::FILEREADER { best_io_quantum, ... }, ... };

		    best_io_quantum;
		};

	    fun read_vector (INPUT_BUFFER { reader_info=>READER_INFO { read_vector=>f, ... }, ... } )
		=
		f;

	    fun input_exn (READER_INFO { reader => drv::FILEREADER { name, ... }, ... }, ml_op, cause)
		=
		raise exception  iox::IO  { function => ml_op,  name,  cause };

	    Next_Data = EOF | DATA  Input_Buffer;

	    # Extend the stream by a chunk.
	    # Invariant: the next m-variable is empty on entry and full on exit.
	    #
	    fun extend_stream (read_g, ml_op, buf as INPUT_BUFFER { next, reader_info, ... } )
		=
		{   reader_info ->   READER_INFO { get_position, tail, ... };
		    #
		    base_position = get_position ();

		    chunk = read_g  (best_io_quantum_of_ibuf  buf);

		    if (rv::length chunk == 0)
			#
			fill (next, NO_NEXT);
			EOF;
		    else 
			new_next = make_empty_maildrop ();

			buf' = INPUT_BUFFER {
				base_position,
				data => chunk,
				next => new_next,
				reader_info
			      };

			# Note that we do not fill the new_next cell until
			# after the tail has been updated.  This ensures
			# that someone attempting to access the tail will
			# not acquire the lock until after we are done.
			#
			update_maildrop (tail, new_next);
			fill (next,       NEXT buf');  #  releases lock!! 
			fill (new_next, NO_NEXT);
			DATA buf';
		    fi;
		}
		except
		    ex =  {   fill (next, NO_NEXT);
			      input_exn (reader_info, ml_op, ex);
			  };


	    # Get the next buffer in the stream,
	    # extending it if necessary. 
	    # If the stream must be extended,
	    # we lock it by taking the value from the
	    # next cell; the extend_stream function
	    # is responsible for filling in the cell.
	    #
	    fun get_buffer (read_g, ml_op) (buf as INPUT_BUFFER { next, reader_info, ... } )
		=
		get (peek next)
		where
		    fun get TERMINATED  =>  EOF;
			get (NEXT buf') =>  DATA buf';

			get NO_NEXT
			    =>
			    case (empty next)
				#
				NO_NEXT => extend_stream (read_g, ml_op, buf);

				other  => {   fill (next, other);
					      get other;
					  };
			    esac;
		    end;
		end;

	    # Read a chunk that is at least the specified size 
	    #
	    fun read_chunk buf
		=
		{   (reader_info_of_ibuf buf)
			->
			READER_INFO { read_vector, reader => drv::FILEREADER { best_io_quantum, ... }, ... };

		    case (best_io_quantum - 1)
			#
			0 => (fn n = read_vector n);
			k => (fn n = read_vector (int::quot (n+k, best_io_quantum) * best_io_quantum));
				    #
				    # Round up to next multiple of best_io_quantum 
		    esac;
		};

	    fun generalized_input get_buf
		=
		get
		where
		    fun get (INPUT_STREAM (buf as INPUT_BUFFER { data, ... }, pos))
			=
			{   len = rv::length data;
			    #
			    if (pos < len)
				#
				(vec_extract (data, pos, NULL), INPUT_STREAM (buf, len));
			    else
				case (get_buf buf)
				    #
				    EOF       =>  (empty_vec, INPUT_STREAM (buf, len));
				    DATA rest =>  get (INPUT_STREAM (rest, 0));
				esac;
			    fi;
			};
		end;

	    # Terminate an input stream 
	    #
	    fun terminate (reader_info as READER_INFO { tail, clean_tag, ... } )
		=
		{   m = peek tail;
		    #
		    case (empty m)
			#
			(m' as NEXT _)
			    =>
			    {   fill (m, m');
				terminate reader_info;
			    };

			TERMINATED
			    =>
			    fill (m, TERMINATED);

		       _ => {   eow::remove_cleaner clean_tag;
				fill (m, TERMINATED);
			    };
		    esac;
		};


	    # Find the end of the stream 
	    #
	    fun find_eos (buf as INPUT_BUFFER { next, data, ... } )
		=
		case (peek next)
		    #
		    NEXT buf =>  find_eos buf;
		    _        =>  INPUT_STREAM (buf, rv::length data);
		esac;


	    fun read (stream as INPUT_STREAM (buf, _))
		=
		generalized_input
		    (get_buffer (read_vector buf, "read"))
		    stream;

	    fun read_one (INPUT_STREAM (buf, pos))
		=
		{   buf ->  INPUT_BUFFER { data, next, ... };

		    if (pos < rv::length data)
			#
			THE (vec_get (data, pos), INPUT_STREAM (buf, pos+1));
		    else
			get (peek next)
			where
			    fun get (NEXT buf) => read_one (INPUT_STREAM (buf, 0));
				get TERMINATED => NULL;

				get NO_NEXT
				    =>
				    case (empty next)
					#
					NO_NEXT
					    =>
					    case (extend_stream (read_vector buf, "read_one", buf))
						DATA rest => read_one (INPUT_STREAM (rest, 0));
						EOF       => NULL;
					    esac;

					other =>
					    {   fill (next, other);
						get other;
					    };
				    esac;
			    end;
			end;
		    fi;
		};

	    fun read_n (INPUT_STREAM (buf, pos), n)
		=
		{   fun join (item, (list, stream))
			=
			(item ! list, stream);

		    fun input_list (buf as INPUT_BUFFER { data, ... }, i, n)
			=
			{   len = rv::length data;
			    #
			    remain = len-i;

			    if (remain >= n)
				 ([vec_extract (data, i, THE n)], INPUT_STREAM (buf, i+n));
			    else
				 join ( vec_extract (data, i, NULL),
					next_buf (buf, n-remain)
				      );
			    fi;
			  }

		    also
		    fun next_buf (buf as INPUT_BUFFER { next, data, ... }, n)
			=
			get (peek next)
			where
			    fun get (NEXT buf)
				    =>
				    input_list (buf, 0, n);

				get TERMINATED
				    =>
				    ([], INPUT_STREAM (buf, rv::length data));

				get NO_NEXT
				    =>
				    case (empty next)
					#
					NO_NEXT =>
					    case (extend_stream (read_vector buf, "read_n", buf))
						#
						EOF         =>  ([], INPUT_STREAM (buf, rv::length data));
						(DATA rest) =>  input_list (rest, 0, n);
					    esac;

					other=> {   fill (next, other);
						    get other;
						};
				    esac;

			    end;
			end;

		    (input_list (buf, pos, n))
			->
			(data, stream);

		    (rv::cat data, stream);
		};

	    fun read_all (stream as INPUT_STREAM (buf, _))
		=
		{   (reader_info_of_ibuf  buf)
			->
			READER_INFO  { reader => drv::FILEREADER { avail, ... }, ... };
			

		    # Read a chunk that is as large as the available input.
		    # Note that for systems that use CR-LF for '\n', the
		    # size will be too large, but this should be okay.
		    #
		    fun big_chunk _
			=
			read_chunk  buf  delta
			where
			    delta = case (avail())
					#
					NULL  =>  best_io_quantum_of_ibuf  buf;
					THE n =>  n;
				    esac;
			end;

		    big_input
			=
			generalized_input
			    (get_buffer (big_chunk, "read_all"));

		    fun loop (v, stream)
			=
			if (rv::length v == 0)  [];
			else                   v ! loop (big_input stream);
			fi;

		    data = rv::cat (loop (big_input stream));

		    (data, find_eos buf);
		};

	    fun input1evt       _ =  raise exception FAIL "input1Evt unimplemented";
	    fun input_mailop     _ =  raise exception FAIL "inputEvt unimplemented";
	    fun input_nevt      _ =  raise exception FAIL "inputNEvt unimplemented";
	    fun input_all_mailop _ =  raise exception FAIL "inputAllEvt unimplemented";

	    # Return THE k, if k <= amount
	    # characters can be read without blocking. 
	    #
	    fun can_read (stream as INPUT_STREAM (buf, pos), amount)
		=
		if (amount < 0)
		    raise exception SIZE;
		else
		    try_input (buf, pos, amount)
		    where
    /******
			  readVecNB = case buf
			       of (INPUT_BUFFER { reader_info as READER_INFO { readVecNB=NULL, ... }, ... } ) =>
				    inputExn (reader_info, "can_read", iox::NONBLOCKING_IO_NOT_SUPPORTED)
				| (INPUT_BUFFER { reader_info=READER_INFO { readVecNB=THE f, ... }, ... } ) => f
			              esac
    ******/
			fun try_input (buf as INPUT_BUFFER { data, ... }, i, n)
			    =
			    {   len = rv::length data;
				remain = len - i;

				remain >= n  ??  THE n
					     ::  next_buf (buf, n - remain);
			    }

			also
			fun next_buf (INPUT_BUFFER { next, ... }, n)
			    =
			    get (peek next)
			    where
				fun get (NEXT buf) => try_input (buf, 0, n);
				    get TERMINATED => THE (amount - n);
				    get NO_NEXT => THE (amount - n);
				end;
    /******
				  | get NO_NEXT = case md::mTake next
				       of NO_NEXT =>
					    case extendStream (readVecNB, "can_read", buf)
					     of EOF => THE (amount - n)
					      | (DATA b) => tryInput (b, 0, n)
					    esac
					      except iox::IO { cause=WOULD_BLOCK, ... } => THE (amount - n)
					| other => (md::mPut (next, other); get other)
				      esac
    ******/

			end;

		    end;
		fi;

	    # Close an input stream given its reader_info record.
	    # We need this function for the cleanup hook
	    # to avoid a space leak.
	    #
	    fun close_in_reader_info (READER_INFO { is_closed=>REF TRUE, ... } )
		    =>
		    ();

		close_in_reader_info (reader_info as READER_INFO { is_closed, reader => drv::FILEREADER { close, ... }, ... } )
		    =>
		    {
    # ** We need some kind of lock on the input stream to do this safely!!! ** XXX BUGGO FIXME
			terminate reader_info;

			is_closed := TRUE;

			close()
			except
			    ex =  input_exn (reader_info, "close_input", ex);
		    };
	    end;


	    fun close_input (INPUT_STREAM (buf, _))
		=
		close_in_reader_info (reader_info_of_ibuf buf);


	    fun end_of_stream (INPUT_STREAM (buf as INPUT_BUFFER { next, ... }, pos))
		=
		case (empty next)
		    #
		    other as NEXT _
			=>
			{   fill (next, other);
			    FALSE;
			};

		    other
			=>
			{   buf ->  INPUT_BUFFER { data, reader_info=>READER_INFO { is_closed, ... }, ... };

			    if (pos == rv::length data)
				#
				case (other, *is_closed)
				    #
				    (NO_NEXT, FALSE)
					=>
					case (extend_stream (read_vector buf, "end_of_stream", buf))
					    #
					    EOF =>  TRUE;
					    _   =>  FALSE;
					esac;

				    _   =>
					{   fill (next, other);
					    TRUE;
					};
				esac;
			    else
				fill (next, other);
				FALSE;
			    fi;
		       };
		esac;


	    fun make_instream (reader, data)
		=
		{   reader ->  drv::FILEREADER { read_vector, read_vec_mailop, get_position, set_position, ... };
		    #
		    get_position
			=
			case (get_position, set_position)
			    #
			    (THE f, THE _)
				=>
				(fn () =  THE (f ()));

			     _   =>
				 (fn () =  NULL);
			 esac;

		    next = make_full_maildrop NO_NEXT;
		    tag  = eow::add_cleaner dummy_cleaner;

		    reader_info
			=
			READER_INFO
			  {
			    reader,
			    read_vector,
			    read_vec_mailop,
			    get_position,
			    #
			    is_closed =>  REF FALSE,
			    tail      =>  make_full_maildrop next,
			    clean_tag =>  tag
			  };

		    # * What should we do about the position in this case ?? *

		    # Suggestion: When building a stream with supplied initial data,
		    # nothing can be said about the positions inside that initial
		    # data (who knows where that data even came from!).


		    base_position
			=
			if (rv::length data == 0)    get_position ();
			else			    NULL;
			fi;

		    buf = INPUT_BUFFER {
			    base_position, data,
			    reader_info, next
			  };

		    stream =  INPUT_STREAM (buf, 0);

		    eow::rebind_cleaner
		      ( tag,
			fn () =  close_in_reader_info reader_info
		      );

		    stream;
		};

	    fun get_reader (INPUT_STREAM (buf, pos))
		=
		{   buf ->  INPUT_BUFFER { data, reader_info as READER_INFO { reader, ... }, next, ... };
		    #
		    fun get_data next
			=
			case (peek next)
			    #
			    NEXT (INPUT_BUFFER { data, next=>next', ... } )
				=>
				data ! get_data next';

			     _ => [];
			esac;


		    terminate reader_info;

		    if (pos < rv::length data)
			( reader,
			  rv::cat (vec_extract (data, pos, NULL) ! get_data next)
			);
		    else
			( reader,
			  rv::cat (get_data next)
			);
		    fi;
		};

    /*
	  # * Position operations on instreams *
	    enum in_pos = INP of {
		base:  pos,
		offset:  Int,
		reader_info:  reader_info
	      }
    */

    /*
	    fun getPosIn (INPUT_STREAM (buf, pos)) = case buf
		   of INPUT_BUFFER { basePos=NULL, reader_info, ... } =>
			inputExn (reader_info, "getPosIn", iox::RANDOM_ACCESS_IO_NOT_SUPPORTED)
		    | INPUT_BUFFER { basePos=THE p, reader_info, ... } => INP {
			  base = p, offset = pos, reader_info = reader_info
			}
		  esac
    */


    /*
	    fun filePosIn (INP { base, offset, ... } ) =
		  position.+(base, file_position::from_int offset)
    */

	    fun file_position_in (INPUT_STREAM (buf, pos))
		=
		case buf
		    #
		    INPUT_BUFFER { base_position=>NULL, reader_info, ... }
			=>
			input_exn (reader_info, "filePosIn", iox::RANDOM_ACCESS_IO_NOT_SUPPORTED);

		    INPUT_BUFFER { base_position=>THE b, ... }
			=>
			file_position::(+) (b, file_position::from_int pos);
		esac;
    /*
	    fun setPosIn (pos as INP { reader_info as READER_INFO { reader, ... }, ... } ) = let
		  fpos = filePosIn pos
		  my (drv::FILEREADER rd) = reader
		  in
		    terminate reader_info;
		    the rd.setPos fpos;
		    make_instream (drv::FILEREADER rd, empty_vec)
		  end
    */

	    # IO mailop constructors:
	    # We exploit the "functional" nature of stream IO
	    # to implement the mailop constructors.  These
	    # constructors spawn a thread to do the operation
	    # and and write the result in an iVariable that
	    # serves as the synchronization value.
	    #
	    # NOTE: This implementation has the weakness that
	    # it prevents shutdown when everything else is
	    # deadlocked, since the thread that is spawned
	    # to actually do the IO could proceed.

	    stipulate

		Result X = RES  X | EXCEPTION  Exception;

		fun do_input input_op
		    =
		    {   fun read arg
			    =
			    RES (input_op arg)
			    except
				ex = EXCEPTION ex;

			fn arg
			    =
			    guard
			       .{   reply_1shot =  make_oneshot_maildrop ();

				    make_thread "binary I/O" .{
					set (reply_1shot, read arg);
				    };

				    get'  reply_1shot
					==>
					fn (RES x)        =>  x;
					   (EXCEPTION ex) =>  raise exception ex;
					end;

				};

		    };
	    herein

		input1evt       = do_input read_one;
		input_mailop     = do_input read;

		input_nevt      = do_input read_n;
		input_all_mailop = do_input read_all;
	    end;						# stipulate


	    # ** Output streams **

	    # An output stream is implemented
	    # as a monitor using an mvar to
	    # hold its data.

	    Output_Stream_Info
		=
		OUTPUT_STREAM_INFO
		  {
		    buffer:			wv::Rw_Vector,
		    first_free_byte_in_buffer:	Ref( Int ),

		    is_closed:			Ref( Bool ),
		    buffering_mode:		Ref( iox::Buffering_Mode ),

		    writer:			Filewriter,

		    write_rw_vector:		wvs::Slice -> Void,
		    write_vector:		rvs::Slice -> Void,

		    clean_tag:  eow::Tag
		  };

	    Output_Stream
		=
		Maildrop( Output_Stream_Info );

	    fun raise_io_exception (OUTPUT_STREAM_INFO { writer => drv::FILEWRITER { name, ... }, ... }, ml_op, cause)
		=
		raise exception  iox::IO  { function => ml_op,  name,  cause };


	    # Lock access to the stream and
	    # make sure that it is not closed. 
	    #
	    fun lock_and_check_closed_out (strm_mv, ml_op)
		=
		case (empty  strm_mv)
		    #
		    (stream as OUTPUT_STREAM_INFO( { is_closed => REF TRUE, ... } ))
			=>
			{   fill (strm_mv, stream);
			    #
			    raise_io_exception (stream, ml_op, iox::CLOSED_IO_STREAM);
			};

		    stream => stream;
		esac;


	    fun flush_buffer (strm_mv, stream as OUTPUT_STREAM_INFO { buffer, first_free_byte_in_buffer, write_rw_vector, ... }, ml_op)
		=
		case *first_free_byte_in_buffer
		    #
		    0 => ();

		    n => {   write_rw_vector (wvs::make_slice (buffer, 0, THE n));
			     #
			     first_free_byte_in_buffer := 0;
			 }
			 except
			     ex =  {   fill (strm_mv, stream);
				       #
				       raise_io_exception (stream, ml_op, ex);
				   };
		esac;


	    fun write (strm_mv, v)
		=
		{   (lock_and_check_closed_out (strm_mv, "write"))
			->
			(stream as OUTPUT_STREAM_INFO os);

		    fun release ()
			=
			fill (strm_mv, stream);

		    os ->  { buffer, first_free_byte_in_buffer, buffering_mode, ... };


		    fun flush ()
			=
			flush_buffer (strm_mv, stream, "write");

		    fun flush_all ()
			=
			os.write_rw_vector  (wvs::make_full_slice  buffer)
			except
			    ex =  {   release();
				      #
				      raise_io_exception (stream, "write", ex);
				  };


		    fun write_direct ()
			=
			{   case *first_free_byte_in_buffer
				#
				0 => ();
				#
				n => {   os.write_rw_vector  (wvs::make_slice  (buffer, 0, THE n));
					 #
					 first_free_byte_in_buffer := 0;
				     };
			    esac;

			    os.write_vector  (rvs::make_full_slice  v);
			}
			except
			    ex =  {   release();
				      #
				      raise_io_exception  (stream, "write", ex);
				  };

		    fun insert copy_vec
			=
			{   buf_len  =  wv::length  buffer;
			    data_len =  rv::length  v;

			    if (data_len >= buf_len)
				#
				write_direct ();
			    else
				i = *first_free_byte_in_buffer;

				avail = buf_len - i;

				if (avail < data_len)

				    copy_vec (v, 0, avail, buffer, i);

				    flush_all ();

				    copy_vec (v, avail, data_len-avail, buffer, 0);

				    first_free_byte_in_buffer := data_len-avail;

				else

				    copy_vec (v, 0, data_len, buffer, i);

				    first_free_byte_in_buffer :=  i + data_len;

				    if (avail == data_len)   flush ();   fi;
				fi;
			    fi;
		       };

		    case *buffering_mode
			#
			iox::NO_BUFFERING
			    =>
			    write_direct ();

			_   =>
			    insert copy_vec
			    where
				fun copy_vec (from, from_i, from_len, to, to_i)
				    =
				    wvs::copy_vec
				      { from => rvs::make_slice (from, from_i, THE from_len),
					to,
					di => to_i
				      };

			    end;
		    esac;

		    release ();
		};

	    fun write_one (strm_mv, element)
		=
		release ()
		where
		    (lock_and_check_closed_out (strm_mv, "write_one"))
			->
			(stream as OUTPUT_STREAM_INFO { buffer, first_free_byte_in_buffer, buffering_mode, write_rw_vector, ... } );

		    fun release ()
			=
			fill (strm_mv, stream);

		    case *buffering_mode
			#
			iox::NO_BUFFERING
			    =>
			    {   rw_vec_set (buffer, 0, element);

				write_rw_vector (wvs::make_slice (buffer, 0, THE 1))
				except
				    ex =  {   release();
					      raise_io_exception (stream, "write_one", ex);
					  };
			    };

			 _   =>
			    {   i = *first_free_byte_in_buffer;
				#
				i' = i+1;

				rw_vec_set (buffer, i, element);

				first_free_byte_in_buffer := i';

				if (i' == wv::length  buffer)
				    #
				    flush_buffer (strm_mv, stream, "write_one");
				fi;
			    };
		    esac;
		end;

	    fun flush strm_mv
		 =
		 {   stream =  lock_and_check_closed_out (strm_mv, "flush");
		     #	
		     flush_buffer (strm_mv, stream, "flush");
		     #	
		     fill (strm_mv, stream);
		 };

	    fun close_output  strm_mv
		=
		{   (empty  strm_mv)
			->
			(stream as OUTPUT_STREAM_INFO  { writer => drv::FILEWRITER { close, ... },  is_closed,  clean_tag, ... } );

		    if (not *is_closed)
			#
			flush_buffer (strm_mv, stream, "close");
			is_closed := TRUE;
			eow::remove_cleaner clean_tag;
			close();
		    fi;

		    fill (strm_mv, stream);
		};

	    fun make_outstream  (wr as drv::FILEWRITER { best_io_quantum, write_rw_vector, write_vector, ... },  mode)
		=
		stream
		where
		    fun iterate (f, size, subslice)
			=
			lp
			where
			    fun lp sl
				=
				if (size sl != 0) 
				    #
				    n = f sl;

				    lp (subslice (sl, n, NULL));
				fi;
			end;

		    write_rw_vector' = iterate (write_rw_vector, wvs::length, wvs::make_subslice);
		    write_vector'    = iterate (write_vector,    rvs::length, rvs::make_subslice);

		    # Install a dummy cleaner:
		    #
		    tag = eow::add_cleaner dummy_cleaner;

		    stream
			=
			make_full_maildrop (
			    OUTPUT_STREAM_INFO
			      {
				buffer    =>  wv::make_rw_vector (best_io_quantum, some_element),
				first_free_byte_in_buffer       =>  REF 0,

				is_closed    => REF FALSE,
				buffering_mode => REF mode,

				writer          => wr,
				write_rw_vector => write_rw_vector',
				write_vector    => write_vector',
				clean_tag       => tag
			      }
		      );

		    eow::rebind_cleaner  (tag,  fn () = close_output stream);
		end;


	    fun get_writer strm_mv
		=
		{   (lock_and_check_closed_out (strm_mv, "getWriter"))
			->
			(stream as OUTPUT_STREAM_INFO { writer, buffering_mode, ... } );

		    (writer, *buffering_mode)
		    before
			fill (strm_mv, stream);
		};

	    # Position operations on outstreams:
	    #
	    Out_Position
		=
		OUT_POSITION
		  {
		    pos:	drv::File_Position,
		    stream:	Output_Stream
		  };

	    fun get_output_position strm_mv
		=
		{   (lock_and_check_closed_out (strm_mv, "getWriter"))
			->
			(stream as OUTPUT_STREAM_INFO { writer, ... } );

		    fun release ()
			=
			fill (strm_mv, stream);

		    flush_buffer (strm_mv, stream, "get_output_position");

		    case writer
			#
			drv::FILEWRITER { get_position => THE f, ... }
			    =>
			    OUT_POSITION { pos => f(), stream => strm_mv }
			    except
				ex =    {   release();
					    raise_io_exception (stream, "get_output_position", ex);
					};
			_   =>  {   release();
				    raise_io_exception (stream, "get_output_position", iox::RANDOM_ACCESS_IO_NOT_SUPPORTED);
				}
				before
				    release ();
		    esac;
		};

	    fun file_pos_out (OUT_POSITION { pos, stream=>strm_mv } )
		=
		{   fill (strm_mv, lock_and_check_closed_out (strm_mv, "file_pos_out"));
		    #
		    pos;
		};

	    fun set_output_position (OUT_POSITION { pos, stream=>strm_mv } )
		=
		{   (lock_and_check_closed_out (strm_mv, "set_output_position"))
			->
			(stream as OUTPUT_STREAM_INFO { writer, ... } );

		    fun release ()
			=
			fill (strm_mv, stream);

		    case writer
			#
			drv::FILEWRITER { set_position=>THE f, ... }
			    => 
			    f pos
			    except
				ex =    {   release ();
					    raise_io_exception (stream, "set_output_position", ex);
					};
			_   =>
			    {   release ();
				raise_io_exception (stream, "get_output_position", iox::RANDOM_ACCESS_IO_NOT_SUPPORTED);
			    };
		    esac;

		    release ();
		};

	    fun set_buffering_mode (strm_mv, mode)
		=
		{   (lock_and_check_closed_out (strm_mv, "setBufferMode"))
			->
			(stream as OUTPUT_STREAM_INFO { buffering_mode, ... } );

		    if (mode == iox::NO_BUFFERING)
			#		    
			flush_buffer (strm_mv, stream, "setBufferMode");
		    fi;

		    buffering_mode := mode;

		    fill (strm_mv, stream);
		};

	    fun get_buffering_mode  strm_mv
		=
		{   # Should we be checking for closed streams here??? 	XXX BUGGO FIXME
		    #
		    (lock_and_check_closed_out (strm_mv, "getBufferMode"))
			->
			(stream as OUTPUT_STREAM_INFO { buffering_mode, ... } );

		    *buffering_mode
		    before
			fill (strm_mv, stream);
		};

	};		# package pure_io 

	Vector  = rv::Vector;
	Element = rv::Element;

	Input_Stream  = Maildrop( pur::Input_Stream  );
	Output_Stream = Maildrop( pur::Output_Stream );



	# Input operations:

	fun read stream
	    =
	    {   (pur::read (empty stream))
		    ->
		    (v, stream');

		fill (stream, stream');

		v;
	    };

	fun read_one stream
	    =
	    case (pur::read_one (empty stream))
		#
		THE (element, stream')
		    =>
		    {   fill (stream, stream');
			THE element;
		    };

		NULL => NULL;
	    esac;


	fun read_n (stream, n)
	    =
	    {   (pur::read_n (empty stream, n))
		    ->
		    (v, stream');

		fill (stream, stream');

		v;
	    };

	fun read_all (stream:  Input_Stream)
	    =
	    {   (pur::read_all (empty stream))
		    ->
		    (v, stream');

		fill (stream, stream'); v;
	    };

	fun input1evt        _ =  raise exception  FAIL "input1evt unimplemented";
	fun input_mailop     _ =  raise exception  FAIL "input_mailop unimplemented";
	fun input_nevt       _ =  raise exception  FAIL "input_nevt unimplemented";
	fun input_all_mailop _ =  raise exception  FAIL "input_ell_mailop unimplemented";

	fun can_read (stream, n)
	    =
	    pur::can_read (peek stream, n);


	fun lookahead (stream:  Input_Stream)
	    =
	    case (pur::read_one (peek stream))
		#
		THE (element, _) => THE element;

		NULL => NULL;
	    esac;

	fun close_input stream
	    =
	    {   (empty  stream)
		    ->
		    (s as pur::INPUT_STREAM (buf as pur::INPUT_BUFFER { data, ... }, _));

		pur::close_input  s;

		fill (stream, pur::find_eos buf);
	    };

	fun end_of_stream stream
	    =
	    pur::end_of_stream (peek stream);
    /*
	fun getPosIn stream = pur::getPosIn (mGet stream)
	fun setPosIn (stream, p) = mUpdate (stream, pur::setPosIn p)
    */


	# Output operations:

	fun write (stream, v)     =  pur::write     (peek stream, v);
	fun write_one (stream, c) =  pur::write_one (peek stream, c);

	fun flush        stream =  pur::flush        (peek stream);
	fun close_output stream =  pur::close_output (peek stream);

	fun get_output_position stream = pur::get_output_position (peek stream);

	fun set_output_position (stream, p as pur::OUT_POSITION { stream=>stream', ... } )
	    =
	    {   update_maildrop (stream, stream');
		pur::set_output_position p;
	    };

	fun make_instream (stream:  pur::Input_Stream)      =  make_full_maildrop stream;
	fun get_instream  (stream:  Input_Stream)           =  peek stream;
	fun set_instream  (stream:  Input_Stream, stream')  =  update_maildrop (stream, stream');

	fun make_outstream (stream:  pur::Output_Stream)    =  make_full_maildrop stream;
	fun get_outstream (stream:  Output_Stream)          =  peek stream;
	fun set_outstream (stream:  Output_Stream, stream') =  update_maildrop (stream, stream');



	# Open files

	fun open_for_read fname
	    =
	    make_instream (pur::make_instream (wxd::open_for_read fname, empty_vec))
	    except
		ex =  raise exception iox::IO { function=>"open_for_read", name=>fname, cause=>ex };

	fun open_for_write  fname
	    =
	    make_outstream (pur::make_outstream (wxd::open_for_write fname, iox::BLOCK_BUFFERING))
	    except
		ex =  raise exception iox::IO { function=>"open", name=>fname, cause=>ex };

	fun open_for_append fname
	    =
	    make_outstream (pur::make_outstream (wxd::open_for_append fname, iox::NO_BUFFERING))
	    except
		ex =  raise exception iox::IO { function=>"open_for_append", name=>fname, cause=>ex };

    };											# package threadkit_winix_binary_file_for_os_g 
end;

## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
