## threadkit-winix-text-file-for-os-g.pkg
#
# The threadkit version of winix_text_file_for_os_g.					# winix_text_file_for_os_g				is from   src/lib/std/src/io/winix-text-file-for-os-g.pkg

# Compiled by:
#     src/lib/std/standard.lib


stipulate
    package cv  =  vector_of_chars;							# vector_of_chars					is from   src/lib/std/vector-of-chars.pkg
    package cvs =  vector_slice_of_chars;						# vector_slice_of_chars					is from   src/lib/std/src/vector-slice-of-chars.pkg
    package eow =  threadkit_io_cleanup_at_shutdown;	# "eow" == "end of world"	# threadkit_io_cleanup_at_shutdown			is from   src/lib/std/src/io/threadkit-io-cleanup-at-shutdown.pkg
    package iox =  io_exceptions;							# io_exceptions						is from   src/lib/std/src/io/io-exceptions.pkg
    package ri  =  runtime_internals;							# runtime_internals					is from   src/lib/std/src/nj/runtime-internals.pkg
    package td  =  threadkit_winix_base_text_file_io_driver_for_posix;			# threadkit_winix_base_text_file_io_driver_for_posix	is from   src/lib/std/src/io/threadkit-winix-base-text-file-io-driver-for-posix.pkg
    package thk =  threadkit;								# threadkit						is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    package wcs =  rw_vector_slice_of_chars;						# rw_vector_slice_of_chars				is from   src/lib/std/src/rw-vector-slice-of-chars.pkg
    package wcv =  rw_vector_of_chars;							# rw_vector_of_chars					is from   src/lib/std/rw-vector-of-chars.pkg
herein

    # This generic is invoked (only) in:
    #
    #     src/lib/std/src/posix/threadkit-winix-text-file-for-posix.pkg
    #
    generic package   threadkit_winix_text_file_for_os_g   (
	#             ==================================
	#
	package wxd									# "wxd" == "WiniX file io Driver".
	    :
	    api {
		include  Threadkit_Winix_Extended_File_Io_Driver_For_Os;		# Threadkit_Winix_Extended_File_Io_Driver_For_Os	is from   src/lib/std/src/io/threadkit-winix-extended-file-io-driver-for-os.api
		#
		stdin:		Void   -> drv::Filereader;
		stdout:		Void   -> drv::Filewriter;
		stderr:		Void   -> drv::Filewriter;
		#
		string_reader:  String -> drv::Filereader;
	    }
	    where  drv::Rw_Vector       ==  td::Rw_Vector
	    where  drv::Vector          ==  td::Vector
	    where  drv::Rw_Vector_Slice ==  td::Rw_Vector_Slice
	    where  drv::Vector_Slice    ==  td::Vector_Slice
	    where  drv::Element         ==  td::Element
	    where  drv::File_Position   ==  td::File_Position
	    where  drv::Filereader      ==  td::Filereader
	    where  drv::Filewriter      ==  td::Filewriter;

    )

    : (weak) Threadkit_Winix_Text_File_For_Os						# Threadkit_Winix_Text_File_For_Os			is from   src/lib/std/src/io/threadkit-winix-text-file-for-os.api

    {
	include threadkit;								# threadkit						is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg

	stipulate
	    package drv = wxd::drv;
	herein

	    # Assign to an MVar 
	    #
	    fun m_update (mv, x)
		=
		ignore (swap (mv, x));

	    # An element for initializing buffers:
	    #
	    some_element = '\000';

	    vec_extract = cvs::to_vector o cvs::make_slice;
	    vec_get = cv::get;
	    rw_vec_set = wcv::set;						# should rename vec -> vector all through here XXX SUCKO FIXME

	    substring_base = substring::base;
	    empty_string = "";

	    fun dummy_cleaner ()
		=
		();

	    package pur {							# Exported to client packages.
		#
		Vector   = cv::Vector;
		Element  = cv::Element;

		Filereader    =  drv::Filereader;
		Filewriter    =  drv::Filewriter;
		File_Position =  drv::File_Position;

		# Functional input streams:
		#
		Input_Stream
		    =
		    INPUT_STREAM (Input_Buffer, Int)

		also
		Input_Buffer
		    =
		    INPUT_BUFFER
		      {
			data:  Vector,
			file_position:  Null_Or( File_Position ),

			next:  Maildrop( Next ),		# When this cell is empty, it means that 
								# there is an outstanding request to the 
								# server to extend the stream. 
			global_file_stuff:  Global_File_Stuff
		      }

		also
		Next
		  = NEXT  Input_Buffer	#  forward link to additional data 
		  | NO_NEXT		#  placeholder for forward link 
		  | TERMINATED		#  termination of the stream 

		also
		Global_File_Stuff
		    =
		    GLOBAL_FILE_STUFF
		      { filereader:		Filereader,
			#
			read_vector:		Int -> Vector,
			read_vector_mailop:	Int -> thk::Mailop( Vector ),
			#
			closed:			Ref( Bool ),
			#
			get_file_position:	Void -> Null_Or( File_Position ),
			#
			last_nextref:		Maildrop(  Maildrop( Next) ),				# Points to the 'next' refcell in the last buffer. 
			#
			clean_tag:		eow::Tag
		      };


		fun global_file_stuff_of_ibuf (INPUT_BUFFER { global_file_stuff, ... } )
		    =
		    global_file_stuff;


		fun best_io_quantum_of_ibuf  buf
		    =
		    {   (global_file_stuff_of_ibuf  buf)
			    ->
			    GLOBAL_FILE_STUFF { filereader => drv::FILEREADER { best_io_quantum, ... }, ... };

			best_io_quantum;
		    };


		fun read_vector (INPUT_BUFFER { global_file_stuff=>GLOBAL_FILE_STUFF { read_vector => f, ... }, ... } )		# Should this be renamed get_read_vector? XXX QUERO FIXME
		    =
		    f;


		fun raise_io_exception (GLOBAL_FILE_STUFF { filereader => drv::FILEREADER { filename, ... }, ... }, ml_op, exn)
		    =
		    raise exception  iox::IO  { op=>ml_op,  name=>filename,  cause=>exn };


		 Next_Data = EOF
			   | DATA  Input_Buffer
			   ;


		# Extend the stream by a chunk.
		# Invariant: the next m-variable
		# is empty on entry and full on exit.
		#
		fun extend_stream (read_fn, ml_op, buf as INPUT_BUFFER { next, global_file_stuff, ... } )
		    =
		    {
			global_file_stuff ->  GLOBAL_FILE_STUFF { get_file_position, last_nextref, ... };

			file_position
			    =
			    get_file_position ();

			chunk = read_fn (best_io_quantum_of_ibuf buf);


			if (cv::length chunk == 0)

			     fill (next, NO_NEXT);
			     EOF;

			else

			    new_next = make_empty_maildrop ();

			    buf' = INPUT_BUFFER
				     {
				       file_position,
				       global_file_stuff,
				       data => chunk,
				       next => new_next
				     };

			    # Note that we do not fill the next cell
			    # until after the last_nextref has been updated.
			    #
			    # This ensures that someone attempting to
			    # access the last_nextref will not acquire the lock
			    # until after we are done.
			    #
			    m_update (last_nextref, new_next);

			    fill (next, NEXT buf');  #  releases lock!! 
			    fill (new_next, NO_NEXT);

			    DATA buf';
		       fi;
		   }
		   except ex
		       =
		       {   fill (next, NO_NEXT);
			   raise_io_exception (global_file_stuff, ml_op, ex);
		       };

		# Get the next buffer in the stream,
		# extending it if necessary.
		#
		# If the stream must be extended,
		# we lock it by taking the value from the
		# next cell; the extend_stream function
		# is responsible for filling in the cell.
		#
		fun get_next_buffer (read_fn, ml_op) (buf as INPUT_BUFFER { next, global_file_stuff, ... } )
		    =
		    get (thk::peek next)
		    where
			fun get TERMINATED  =>  EOF;
			    get (NEXT buf') =>  DATA buf';

			    get NO_NEXT     =>  case (empty next)
						    #
						    NO_NEXT => extend_stream (read_fn, ml_op, buf);
						    other  => {  fill (next, other);   get other;  };
						esac;
			end;
		    end;

		# Read a chunk that is at least the specified size:
		# 
		fun read_chunk buf
		    =
		    {   (global_file_stuff_of_ibuf  buf)
			    ->
			    GLOBAL_FILE_STUFF  {  read_vector,  filereader => drv::FILEREADER { best_io_quantum, ... }, ... };

			case (best_io_quantum - 1)
			    #
			    0 =>   fn n = read_vector n;
			    #
			    k =>   # Round up to next multiple of best_io_quantum:
				   # 
				   fn n =  read_vector (int::quot (n+k, best_io_quantum) * best_io_quantum);
			esac;
		    };

		fun generalized_input get_buf
		    =
		    get
		    where 
			fun get (INPUT_STREAM (buf as INPUT_BUFFER { data, ... }, pos))
			    =
			    {   len = cv::length data;
				#
				if (pos < len)
				    #
				    (vec_extract (data, pos, NULL), INPUT_STREAM (buf, len));
				else
				    case (get_buf buf)
					#
					DATA rest =>  get (INPUT_STREAM (rest, 0));
					EOF       =>  (empty_string, INPUT_STREAM (buf, len));
				     esac;
				fi;
			    };
		    end;

		# Terminate an input stream:
		# 
		fun terminate (global_file_stuff as GLOBAL_FILE_STUFF { last_nextref, clean_tag, ... } )
		    =
		    {   m = thk::peek last_nextref;
			#
			case (empty m)
			    #
			    (m' as NEXT _)
				=>
				{   fill (m, m');
				    #
				    terminate global_file_stuff;
				};

			    TERMINATED
				=>
				fill (m, TERMINATED);

			    _ => {   eow::remove_cleaner clean_tag;
				     fill (m, TERMINATED);
				 };
			 esac;
		      };

		# Find the end of the stream:
		# 
		fun find_eos (buf as INPUT_BUFFER { next, data, ... } )
		    =
		    case (thk::peek next)
			#
			NEXT buf =>  find_eos buf;
			_        =>  INPUT_STREAM (buf, cv::length data);
		    esac;


		fun read (stream as INPUT_STREAM (buf, _))
		    =
		    generalized_input (get_next_buffer (read_vector buf, "read")) stream;


		fun read_one (INPUT_STREAM (buf, pos))
		    =
		    {   buf ->  INPUT_BUFFER { data, next, ... };

			if (pos < cv::length data)
			    #
			    THE (vec_get (data, pos), INPUT_STREAM (buf, pos+1));
			else

			    fun get (NEXT buf)
				    =>
				    read_one (INPUT_STREAM (buf, 0));

				get TERMINATED
				    =>
				    NULL;

				get NO_NEXT
				    =>
				    case (empty next)
					#
					NO_NEXT =>   case (extend_stream (read_vector buf, "read_one", buf))
							#
							EOF       => NULL;
							DATA rest => read_one (INPUT_STREAM (rest, 0));
						    esac;

					other=> {   fill (next, other);
						    get other;
						};
				    esac;
			    end;

			    get (thk::peek next);
			fi;
		    };

		fun read_n (INPUT_STREAM (buf, pos), n)
		    =
		    {   fun join (item, (list, stream))
			    =
			    (item ! list, stream);


			fun input_list (buf as INPUT_BUFFER { data, ... }, i, n)
			    =
			    {   len = cv::length data;
				#
				remain = len-i;

				if (remain >= n)
				    #
				    ([vec_extract (data, i, THE n)], INPUT_STREAM (buf, i+n));
				else
				    join (vec_extract (data, i, NULL), next_buf (buf, n-remain));
				fi;
			    }

			also
			fun next_buf (buf as INPUT_BUFFER { next, data, ... }, n)
			    =
			    get (thk::peek next)
			    where
				fun get (NEXT buf)
					=>
					input_list (buf, 0, n);

				    get TERMINATED
					=>
					([], INPUT_STREAM (buf, cv::length data));

				    get NO_NEXT
					=>
					case (empty next)
					    #
					    NO_NEXT
						=>
						case (extend_stream (read_vector buf, "read_n", buf))
						    #
						    EOF       =>  ([], INPUT_STREAM (buf, cv::length data));
						    DATA rest =>  input_list (rest, 0, n);
						esac;

					    other=> {   fill (next, other);
							get other;
						    };
					esac;
				end;
			    end;

			my (data, stream)
			    =
			    input_list (buf, pos, n);

			(cv::cat data, stream);
		    };

		fun read_all (stream as INPUT_STREAM (buf, _))
		    =
		    {   (global_file_stuff_of_ibuf  buf)
			    ->
			    GLOBAL_FILE_STUFF { filereader => drv::FILEREADER { avail, ... }, ... };

			# Read a chunk that is as large as the available input.
			# Note that for systems that use CR-LF for '\n',
			# the size will be too large, but this should be okay.
			#
			fun big_chunk _
			    =
			    {   delta = case (avail ())
					    #
					    THE n =>  n;
					    NULL  =>  best_io_quantum_of_ibuf buf;
					esac;


				read_chunk buf delta;
			    };

			big_input
			    =
			    generalized_input (get_next_buffer (big_chunk, "read_all"));

			fun loop (v, stream)
			    =
			    if (cv::length v == 0)  [];
			    else                    v ! loop (big_input stream);
			    fi;

			data = cv::cat (loop (big_input stream));

			(data, find_eos buf);
		    };

		# Return THE k, if k <= amount characters
		# can be read without blocking.
		# 
		fun max_readable_without_blocking (stream as INPUT_STREAM (buf, pos), amount)
		    =
		    {
	/******
		      readVecNB = case buf
			   of (INPUT_BUFFER { global_file_stuff as GLOBAL_FILE_STUFF { readVecNB=NULL, ... }, ... } ) =>
				inputExn (global_file_stuff, "max_readable_without_blocking", iox::NONBLOCKING_IO_NOT_SUPPORTED)
			    | (INPUT_BUFFER { global_file_stuff=GLOBAL_FILE_STUFF { readVecNB=THE f, ... }, ... } ) => f
			  esac
	******/
		      fun try_input (buf as INPUT_BUFFER { data, ... }, i, n)
			  =
			  {   len = cv::length data;

			      remain = len - i;

			      remain >= n   ??   THE n
					    ::   next_buf (buf, n - remain);
			  }
		      also
		      fun next_buf (INPUT_BUFFER { next, ... }, n)
			  =
			  get (thk::peek next)
			  where
			      fun get (NEXT buf) => try_input (buf, 0, n);
				  get TERMINATED => THE (amount - n);
	/******
			      | get NO_NEXT = (case md::mTake next
				   of NO_NEXT =>
					case extendStream (readVecNB, "max_readable_without_blocking", buf)
					 of EOF => THE (amount - n)
					  | (DATA b) => tryInput (b, 0, n)
					esac
					  except iox::IO { cause=WOULD_BLOCK, ... } => THE (amount - n))
				    | other=> (md::mPut (next, other); get other)
				   	esac
	******/
			       get NO_NEXT => THE (amount - n);
			     end;

			  end;

			if (amount < 0)   raise exception SIZE;
			else              try_input (buf, pos, amount);
			fi;
		    };

		# Close an input stream given its global_file_stuff record;
		# we need this function for the cleanup hook to
		# avoid a space leak.
		#
		fun close_in_global_file_stuff (GLOBAL_FILE_STUFF { closed => REF TRUE, ... } )
			=>
			();

		    close_in_global_file_stuff (global_file_stuff as GLOBAL_FILE_STUFF  {  closed,  filereader => drv::FILEREADER { close, ... }, ... } )
			=>
			{
	# ** We need some kind of lock on the input stream to do this safely!!! ** XXX BUGGO FIXME
			    terminate global_file_stuff;

			    closed := TRUE;

			    close()
			    except
				ex =  raise_io_exception (global_file_stuff, "close_input", ex);
			};
		end;


		fun close_input (INPUT_STREAM (buf, _))
		    =
		    close_in_global_file_stuff  (global_file_stuff_of_ibuf  buf);


		fun end_of_stream (INPUT_STREAM (buf as INPUT_BUFFER { next, ... }, pos))
		    =
		    case (empty next)
			#
			(other as NEXT _)
			    =>
			    {   fill (next, other);
				FALSE;
			    };

			other
			    =>
			    {   buf ->  INPUT_BUFFER { data, global_file_stuff=>GLOBAL_FILE_STUFF { closed, ... }, ... };

				if (pos == cv::length data)

				    case (other, *closed)
					#
					(NO_NEXT, FALSE)
					    =>
					    case (extend_stream (read_vector buf, "end_of_stream", buf))
						#
						EOF => TRUE;
						_   => FALSE;
					    esac;

				       _ => {   fill (next, other);
						TRUE;
					    };
				    esac;

				else
				     fill (next, other);
				     FALSE;
				fi;
			    };
		    esac;

		fun make_instream' (filereader, data)
		    =
		    {   filereader ->  drv::FILEREADER { read_vector, read_vector_mailop, get_file_position, set_file_position, ... };
			#
			get_file_position
			    =
			    case (get_file_position, set_file_position)
				#
				(THE f, THE _) =>   fn () =  THE (f());
				_              =>   fn () =  NULL;
			    esac;

			next =  make_full_maildrop  NO_NEXT;

			closed_flag = REF FALSE;

			clean_tag =  eow::add_cleaner  dummy_cleaner;

			global_file_stuff
			    =
			    GLOBAL_FILE_STUFF
			      {
				filereader,
				read_vector,
				read_vector_mailop,
				get_file_position,
				clean_tag,
				#
				closed		=>  closed_flag,
				last_nextref	=>  make_full_maildrop  next
			     };

			# What should we do about the position in this case ??
			# Suggestion: When building a stream with supplied initial data,
			# nothing can be said about the positions inside that initial
			# data (who knows where that data even came from!).

			file_position
			       =
			       if (cv::length data == 0)   get_file_position ();
			       else                        NULL;
			       fi;

			buf =   INPUT_BUFFER
				  {
				    file_position,
				    data,
				    global_file_stuff,
				    next
				  };

			stream =  INPUT_STREAM (buf, 0);

			(clean_tag, stream);
		    };


		fun make_instream arg
		    =
		    {   (make_instream' arg)
			    ->
			    (tag, stream as INPUT_STREAM (INPUT_BUFFER { global_file_stuff, ... }, _));

			eow::rebind_cleaner (tag, fn () = close_in_global_file_stuff global_file_stuff);

			stream;
		    };


		fun get_reader (INPUT_STREAM (buf, pos))
		    =
		    {   buf ->  INPUT_BUFFER { data, global_file_stuff as GLOBAL_FILE_STUFF { filereader, ... }, next, ... };
			#
			fun get_data next
			    =
			    case (thk::peek next)
				#
				(NEXT (INPUT_BUFFER { data, next=>next', ... } ))
				    =>
				    data ! get_data next';

				_ => [];
			    esac;


			terminate global_file_stuff;

			if (pos < cv::length data)   (filereader, cv::cat (vec_extract (data, pos, NULL) ! get_data next));
			else			     (filereader, cv::cat (                                get_data next));
			fi;
		    };

	/*
	      # * Position operations on instreams *
		enum in_pos = INP of {
		    base:  pos,
		    offset:  Int,
		    global_file_stuff:  global_file_stuff
		  }
	*/

	/*
		fun getPosIn (INPUT_STREAM (buf, pos)) = (case buf
		       of INPUT_BUFFER { basePos=NULL, global_file_stuff, ... } =>
			    inputExn (global_file_stuff, "getPosIn", iox::RANDOM_ACCESS_IO_NOT_SUPPORTED)
			| INPUT_BUFFER { basePos=THE p, global_file_stuff, ... } => INP {
			      base = p, offset = pos, global_file_stuff = global_file_stuff
			    }
		      )		# end case
	*/
	/*
		fun filePosIn (INP { base, offset, ... } ) =
		      position.+(base, file_position::from_int offset)
	*/
		# Get the underlying file position of a stream:
		# 
		fun file_position_in (INPUT_STREAM (buf, pos))
		    =
		    case buf
			#
			INPUT_BUFFER { file_position=>NULL, global_file_stuff, ... }
			    =>
			    raise_io_exception (global_file_stuff, "filePosIn", iox::RANDOM_ACCESS_IO_NOT_SUPPORTED);

			INPUT_BUFFER { file_position=>THE base, global_file_stuff, ... }
			    =>
			    {   global_file_stuff ->  GLOBAL_FILE_STUFF { filereader => drv::FILEREADER rd, read_vector, ... };
				#
				case (rd.get_file_position, rd.set_file_position)
				    #
				    (THE get_file_position, THE set_file_position)
					=>
					{   tmp_pos = get_file_position ();
					    #
					    fun read_n 0 => ();

						read_n n => case (cv::length (read_vector n))
								#
								0 =>  raise_io_exception (global_file_stuff, "filePosIn", FAIL "bogus position");
								k =>  read_n (n-k);
							    esac;
					    end;

					    set_file_position base;
					    read_n pos;

					    get_file_position ()
					    before
						set_file_position tmp_pos;
				      };

				   _ => raise exception FAIL "filePosIn: impossible";

				esac;
			   };
		    esac;

	/*
		fun setPosIn (pos as INP { global_file_stuff as GLOBAL_FILE_STUFF { reader, ... }, ... } ) = let
		      fpos = filePosIn pos
		      my (drv::FILEREADER rd) = reader
		      in
			terminate global_file_stuff;
			the rd.setPos fpos;
			make_instream (drv::FILEREADER rd, NULL)
		      end
	*/

		# * Text stream specific operations *
		#
		fun read_line (INPUT_STREAM (buf as INPUT_BUFFER { data, ... }, pos))
		    =
		    {   fun join (item, (list, stream))
			    =
			    (item ! list, stream);

			fun next_buf (is_empty, buf as INPUT_BUFFER { next, data, ... } )
			    =
			    get (thk::peek next)
			    where
				fun last ()
				    =
				    (if is_empty  []; else ["\n"];fi, INPUT_STREAM (buf, cv::length data));

				fun get (NEXT buf)
					=>
					scan_data (buf, 0);

				    get NO_NEXT
					=>
					case (empty next)
					    #
					    NO_NEXT
						=>
						case (extend_stream (read_vector buf, "read_line", buf))
						    #
						    DATA rest =>  scan_data (rest, 0);
						    EOF       =>  last ();
						esac;

					    other
						=>
						{   fill (next, other);
						    get other;
						};
					esac;

				    get TERMINATED
					=>
					last ();
				end;
			    end

			also
			fun scan_data (buf as INPUT_BUFFER { data, ... }, i)
			    =
			    scan i
			    where
				len = cv::length data;

				fun scan j
				    =
				    if (j == len)
					#
					join (vec_extract (data, i, NULL), next_buf (FALSE, buf));
				    else
					if (vec_get (data, j) == '\n')
					    #
					    ([vec_extract (data, i, THE (j+1-i))], INPUT_STREAM (buf, j+1));
					else
					    scan (j+1);
					fi;
				    fi;
			    end;

			my (data, stream)
			    =
			    if (cv::length data == pos)   next_buf (TRUE, buf);
			    else                          scan_data (buf, pos);
			    fi;

			res_v = cv::cat data;

			if (cv::length res_v == 0)   NULL;
			else                         THE (res_v, stream);
			fi;
		    };

		# IO mailop constructors:
		# We exploit the "functional" nature of stream IO to implement the mailop
		# constructors.  These constructors spawn a thread to do the operation
		# and and write the result in an iVariable that serves as the synchronization
		# value.
		# NOTE: this implementation has the weakness that it prevents shutdown when
		# everything else is deadlocked, since the thread that is spawned to actually
		# do the IO could proceed.            XXX BUGGO FIXME
		#    
		stipulate

		    Result(X) = RESULT(X)
			      | EXCEPTION  Exception
			      ;

		    include threadkit;							# threadkit		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg

		    fun do_input input_op
			=
			{   fun read arg
				=
				RESULT (input_op arg)
				except
				    ex =  EXCEPTION ex;

			    fn arg
				=
				guard
				   .{   reply_1shot = make_oneshot_maildrop ();

					make_thread "text I/O" .{
					    set (reply_1shot, read arg);
					};

					get' reply_1shot
					    ==>
					    fn (RESULT    x ) =>  x;
					       (EXCEPTION ex) =>  raise exception ex;
					    end;
				    };

			  };
		herein

		    input1evt         =  do_input  read_one;
		    input_mailop      =  do_input  read;
		    input_nevt        =  do_input  read_n;
		    #
		    input_all_mailop  =  do_input  read_all;
		    input_line_mailop =  do_input  read_line;

		end;


		# ** Output streams **

		# an output stream is implemented as a monitor using an mvar to
		# hold its data.

		Output_Stream_Info
		    =
		    OUTPUT_STREAM_INFO
		      {
			buffer:				wcv::Rw_Vector,
			first_free_byte_in_buffer:	Ref( Int ),

			is_closed:			Ref( Bool ),
			buffering_mode:			Ref( iox::Buffering_Mode ),

			filewriter:			Filewriter,

			write_rw_vector:		wcs::Slice -> Void,
			write_vector:			cvs::Slice -> Void,

			clean_tag:			eow::Tag
		      };


		Output_Stream
		    =
		    Maildrop( Output_Stream_Info );


		fun is_nl '\n' =>  TRUE;
		    is_nl _    =>  FALSE;
		end;


		fun is_line_break (OUTPUT_STREAM_INFO { buffering_mode, ... } )
		    =
		    *buffering_mode == iox::LINE_BUFFERING
		      ??  is_nl
		      ::  (fn _ = FALSE);


		fun output_exn (OUTPUT_STREAM_INFO { filewriter => drv::FILEWRITER { filename, ... }, ... }, ml_op, cause)
		    =
		    raise exception  iox::IO {  op => ml_op,  name => filename,  cause  };

		# Lock access to the stream and make sure that it is not closed. 

		fun lock_and_check_closed_out (strm_mv, ml_op)
		    =
		    case (empty strm_mv)
			#
			stream as OUTPUT_STREAM_INFO( { is_closed=>REF TRUE, ... } )
			    =>
			    {   fill (strm_mv, stream);
				output_exn (stream, ml_op, iox::CLOSED_IO_STREAM);
			    };

			stream => stream;
		    esac;


		fun flush_buffer (strm_mv, stream as OUTPUT_STREAM_INFO { buffer, first_free_byte_in_buffer, write_rw_vector, ... }, ml_op)
		    =
		    case *first_free_byte_in_buffer
			#
			0 => ();

			n => {   write_rw_vector (wcs::make_slice (buffer, 0, THE n));
				 first_free_byte_in_buffer := 0;
			     }
			     except ex
				 =
				 {   fill (strm_mv, stream);
				     output_exn (stream, ml_op, ex);
				 };
		    esac;


		# A version of copyVec that checks for newlines, while it is copying.
		# This is used for LINE_BUFFERING output of strings and substrings.
		#
		fun line_buf_copy_vec (src, src_i, src_len, dst, dst_i)
		    =
		    cpy (src_i, dst_i, FALSE)
		    where

			stop = src_i+src_len;

			fun cpy (src_i, dst_i, lb)
			    =
			    if (src_i >= stop)
				#
				lb;
			    else
				c = vec_get (src, src_i);

				rw_vec_set (dst, dst_i, c);

				cpy (src_i+1, dst_i+1, lb or is_nl c);
			    fi;

		    end;

		# A version of copyVec for BLOCK_BUFFERING
		# output of strings and substrings. 
		#
		fun block_buf_copy_vec (from, from_i, from_len, to, to_i)
		    =
		    {   wcs::copy_vec {
			    from => cvs::make_slice (from, from_i, THE from_len),
			    to,
			    di => to_i
			};

			FALSE;
		    };

		fun write (strm_mv, v)
		    =
		    {	  case *buffering_mode
			      #
			      iox::NO_BUFFERING    =>  write_direct ();
			      iox::LINE_BUFFERING  =>  insert line_buf_copy_vec;
			      iox::BLOCK_BUFFERING =>  insert block_buf_copy_vec;
			  esac;

			  release();
		    }
		    where
		        (lock_and_check_closed_out (strm_mv, "write"))
			    ->
			    (stream as OUTPUT_STREAM_INFO os);

			fun release ()
			    =
			    fill (strm_mv, stream);

			os -> { buffer, first_free_byte_in_buffer, buffering_mode, ... };

			fun flush ()
			    =
			    flush_buffer (strm_mv, stream, "write");

			fun flush_all ()
			    =
			    os.write_rw_vector  (wcs::make_full_slice  buffer)
			    except ex
				=
				{   release();
				    #
				    output_exn (stream, "write", ex);
				};

			fun write_direct ()
			    =
			    {   case *first_free_byte_in_buffer
				    #
				    0 =>  ();
				    #
				    n =>    {   os.write_rw_vector (wcs::make_slice (buffer, 0, THE n));
						#
						first_free_byte_in_buffer := 0;
					    };
				esac;

				os.write_vector (cvs::make_full_slice v);
			    }
			    except ex
				=
				{   release ();
				    #
				    output_exn (stream, "write", ex);
				};

			fun insert copy_vec
			    =
			    {
				buf_len  =  wcv::length buffer;
				data_len =  cv::length v;

				if (data_len >= buf_len)
				    #
				    write_direct();
				else
				    i = *first_free_byte_in_buffer;
				    #
				    avail = buf_len - i;

				    if (avail < data_len)
					#
					wcs::copy_vec
						{ from => cvs::make_slice (v, 0, THE avail),
						  to   => buffer,
						  di   => i
						};
					flush_all();
					needs_flush = copy_vec (v, avail, data_len-avail, buffer, 0);

					first_free_byte_in_buffer := data_len-avail;

					needs_flush  ?:  flush ();
				    else
					needs_flush = copy_vec (v, 0, data_len, buffer, i);

					first_free_byte_in_buffer := i + data_len;

					if (needs_flush  or  avail == data_len)
					   flush ();
					fi;
				    fi;
				fi;
			    };

		      end;

		fun write_one (strm_mv, element)
		    =
		    {   (lock_and_check_closed_out (strm_mv, "write_one"))
			    ->
			    (stream as OUTPUT_STREAM_INFO { buffer, first_free_byte_in_buffer, buffering_mode, write_rw_vector, ... } );

			fun release ()
			    =
			    fill (strm_mv, stream);

			case *buffering_mode
			    #
			    iox::NO_BUFFERING
				=>
				{   rw_vec_set (buffer, 0, element);
				    #
				    write_rw_vector (wcs::make_slice (buffer, 0, THE 1))
				    except ex
					=
					{   release();
					    #
					    output_exn (stream, "write_one", ex);
					};
				};

			    iox::LINE_BUFFERING
				=>
				{   i = *first_free_byte_in_buffer;
				    #
				    i' = i+1;

				    rw_vec_set (buffer, i, element);

				    first_free_byte_in_buffer := i';

				    if (i' == wcv::length buffer  or  is_nl element)
					#
					flush_buffer (strm_mv, stream, "write_one");
				    fi;
			      };

			    iox::BLOCK_BUFFERING
				=>
				{   i  = *first_free_byte_in_buffer;
				    i' = i+1;

				    rw_vec_set (buffer, i, element);

				    first_free_byte_in_buffer := i';

				    if (i' == wcv::length buffer)
					 flush_buffer (strm_mv, stream, "write_one");
				    fi;
			      };
			esac;

			release();
		    };

		fun flush strm_mv
		    =
		    {   stream =  lock_and_check_closed_out (strm_mv, "flush");
			#
			flush_buffer (strm_mv, stream, "flush");

			fill (strm_mv, stream);
		    };

		fun close_output  strm_mv
		    =
		    {   (empty  strm_mv)
			    ->
			    (stream as OUTPUT_STREAM_INFO { filewriter => drv::FILEWRITER { close, ... }, is_closed, clean_tag, ... } );

			if (not *is_closed)
			    #
			    flush_buffer (strm_mv, stream, "close");
			    is_closed := TRUE;
			    eow::remove_cleaner clean_tag;
			    close ();
			fi;

			fill (strm_mv, stream);
		    };

		fun make_outstream' (wr as drv::FILEWRITER { best_io_quantum, write_rw_vector, write_vector, ... }, mode)
		    =
		    {   fun iterate (f, size, subslice)
			    =
			    lp
			    where
				fun lp sl
				    =
				    if (size sl != 0)
					#
					n = f sl;
					#
					lp (subslice (sl, n, NULL));
				    fi;
			    end;

			write_rw_vector' =  iterate (write_rw_vector, wcs::length, wcs::make_subslice);
			write_vector'    =  iterate (write_vector,    cvs::length, cvs::make_subslice);

			# Install a dummy cleaner:

			tag =  eow::add_cleaner dummy_cleaner;

			stream =    make_full_maildrop
				        (
					    OUTPUT_STREAM_INFO
					      {
						first_free_byte_in_buffer => REF 0,
						#
						buffer		=> wcv::make_rw_vector (best_io_quantum, some_element),
						#
						is_closed	=> REF FALSE,
						buffering_mode	=> REF mode,
						#
						filewriter	=> wr,
						write_rw_vector	=> write_rw_vector',
						write_vector	=> write_vector',
						#
						clean_tag	=> tag
					      }
					);

			(tag, stream);
		    };

		fun make_outstream  arg
		    =
		    {   (make_outstream'  arg)
			    ->
			    (tag, stream);

			eow::rebind_cleaner (tag, fn () = close_output  stream);

			stream;
		    };

		fun get_writer  strm_mv
		    =
		    {   (lock_and_check_closed_out (strm_mv, "getWriter"))
			    ->
			    (stream as OUTPUT_STREAM_INFO { filewriter, buffering_mode, ... } );

			(filewriter, *buffering_mode)
			before
			    fill (strm_mv, stream);
		    };

		# Position operations on outstreams
		#
		Out_Position
		    =
		    OUT_POSITION  {
		      pos:     drv::File_Position,
		      stream:  Output_Stream
		    };

		fun get_output_position strm_mv
		    =
		    {
			(lock_and_check_closed_out (strm_mv, "getWriter"))
			    ->
			    (stream as OUTPUT_STREAM_INFO { filewriter, ... } );

			fun release ()
			    =
			    fill (strm_mv, stream);

			flush_buffer (strm_mv, stream, "get_output_position");

			case filewriter
			    #
			    drv::FILEWRITER { get_file_position=>THE f, ... }
				=>
				OUT_POSITION { pos => f(), stream => strm_mv }
				except ex
				    =
				    {   release();
					#
					output_exn (stream, "get_output_position", ex);
				    };
			    _   =>
				{   release();
				    #
				    output_exn (stream, "get_output_position", iox::RANDOM_ACCESS_IO_NOT_SUPPORTED);
				}
				before release();
			esac;
		    };

		fun file_pos_out (OUT_POSITION { pos, stream=>strm_mv } )
		    =
		    {   fill (strm_mv, lock_and_check_closed_out (strm_mv, "filePosOut"));
			#
			pos;
		    };

		fun set_output_position (OUT_POSITION { pos, stream=>strm_mv } )
		    =
		    {   (lock_and_check_closed_out (strm_mv, "set_output_position"))
			    ->
			    (stream as OUTPUT_STREAM_INFO { filewriter, ... } );

			fun release ()
			    =
			    fill (strm_mv, stream);

			case filewriter
			    #
			    drv::FILEWRITER { set_file_position => THE f, ... }
				=>
				(f pos)
				except ex
				    =
				    {   release ();
					#
					output_exn (stream, "set_output_position", ex);
				    };

			   _ => {   release();
				    #
				    output_exn (stream, "get_output_position", iox::RANDOM_ACCESS_IO_NOT_SUPPORTED);
				};
			esac;

			release();
		    };

		fun set_buffering_mode  (strm_mv,  mode)
		    =
		    {   (lock_and_check_closed_out (strm_mv, "setBufferMode"))
			    ->
			    (stream as OUTPUT_STREAM_INFO { buffering_mode, ... } );

			if (mode == iox::NO_BUFFERING)
			    #
			    flush_buffer (strm_mv, stream, "setBufferMode");
			fi;

			buffering_mode := mode;

			fill (strm_mv, stream);
		    };

		fun get_buffering_mode  strm_mv
		    =
		    {
	# * should we be checking for closed streams here??? *

			(lock_and_check_closed_out (strm_mv, "getBufferMode"))
			    ->
			    (stream as OUTPUT_STREAM_INFO { buffering_mode, ... } );

			*buffering_mode
			before
			    fill (strm_mv, stream);
		    };

		# Text stream specific operations
		#
		fun write_substring (strm_mv, ss)
		    =
		    {   (lock_and_check_closed_out (strm_mv, "write_substring"))
			    ->
			    (stream as OUTPUT_STREAM_INFO os);

			fun release ()
			    =
			    fill (strm_mv, stream);

			(substring_base ss) ->  (v, data_start, data_len);
			os                  ->  { buffer, first_free_byte_in_buffer, buffering_mode, ... };

			buf_len =  wcv::length  buffer;

			fun flush ()
			    =
			    flush_buffer (strm_mv, stream, "write_substring");

			fun flush_all ()
			    =
			    (os.write_rw_vector (wcs::make_full_slice  buffer)
			     except ex
				=
				{   release();
				    #
				    output_exn (stream, "write_substring", ex);
				}
			    );

			fun write_direct ()
			    =
			    {   case *first_free_byte_in_buffer
				    #
				    0=> ();

				    n=> {   os.write_rw_vector (wcs::make_slice (buffer, 0, THE n));
					    #
					    first_free_byte_in_buffer := 0;
					};
				esac;

				os.write_vector (cvs::make_slice (v, data_start, THE data_len));
			    }
			    except ex
				=
				{   release ();
				    #
				    output_exn (stream, "write_substring", ex);
				};

			fun insert copy_vec
			    =
			    {   buf_len  =  wcv::length buffer;
				data_len =  cv::length v;

				if (data_len >= buf_len)
				    #
				    write_direct ();
				else
				    i = *first_free_byte_in_buffer;

				    avail = buf_len - i;

				    if (avail < data_len)
					#
					wcs::copy_vec
					    { from => cvs::make_slice (v, data_start, THE avail),
					      to   => buffer,
					      di   => i
					    };

					flush_all();

					needs_flush = copy_vec (v, avail, data_len-avail, buffer, 0);

					first_free_byte_in_buffer := data_len-avail;

					needs_flush   ?:  flush ();
				    else
					needs_flush
					    =
					    copy_vec (v, data_start, data_len, buffer, i);

					first_free_byte_in_buffer := i + data_len;

					if (needs_flush or avail == data_len)   flush();   fi;
				    fi;
				fi;
			    };

			  case *buffering_mode
			      #
			      iox::NO_BUFFERING => write_direct ();
			      iox::LINE_BUFFERING => insert line_buf_copy_vec;
			      iox::BLOCK_BUFFERING => insert block_buf_copy_vec;
			  esac;

			  release();
		      };

	    };		#  pure_io 

	    Vector  = cv::Vector;
	    Element = cv::Element;

	    Input_Stream  = Maildrop( pur::Input_Stream  );
	    Output_Stream = Maildrop( pur::Output_Stream );

	    # Input operations
	    #
	    fun read stream
		=
		{   (pur::read (empty stream))
			->
			(v, stream');

		    fill (stream, stream');

		    v;
		};

	    fun read_one stream
		=
		case (pur::read_one (empty stream))
		    #
		    THE (element, stream')
			=>
			{   fill (stream, stream');
			    THE element;
			};

		    NULL => NULL;
		esac;

	    fun read_n (stream, n)
		=
		{   (pur::read_n (empty stream, n))
			->
			(v, stream');

		    fill (stream, stream'); v;
		};

	    fun read_all (stream:  Input_Stream)
		=
		{   (pur::read_all (empty stream))
			->
			(v, stream');

		    fill (stream, stream'); v;
		};


	    # Mailop-value constructors:
	    #
	    stipulate

		Result(X)
		  = RESULT     X
		  | EXCEPTION  Exception
		  ;


		fun send_mailop (slot, v)
		    =
		    give' (slot, RESULT v);


		fun send_exn_mailop (slot, exn)
		    =
		    give' (slot, EXCEPTION exn);


		fun receive'  slot
		    =
		    take'  slot
			==>
			fn (RESULT    v  ) =>  v;
			   (EXCEPTION exn) =>  raise exception exn;
			end;

		fun do_input input_mailop (stream:  Input_Stream) nack
		    =
		    {   reply_slot = make_mailslot ();
			#
			fun input_thread ()
			    =
			    {   stream' = empty stream;
				#
				nack_mailop
				    =
				    nack ==>   (fn _ = fill (stream, stream'));

				fun handle_input (result, stream'')
				    =
				    select
				      [
					send_mailop (reply_slot, result)
					    ==>
					    (fn _ =  fill (stream, stream'')),

					nack_mailop
				      ];

				(select
				  [
				    input_mailop stream'
					==>
					handle_input,
				    nack_mailop
				  ]
				)
				except exn
				    =
				    select [
					#
					send_exn_mailop (reply_slot, exn)
					    ==>
					    (fn _ =  fill (stream, stream')),

					nack_mailop
				    ];
			    };

			make_thread "text I/O II" input_thread;

			receive' reply_slot;
		    };
	    herein

		fun input1evt (stream:  Input_Stream)
		    =
		    with_nack
			(do_input  input_mailop  stream)
		    where
			fun input_mailop (stream:  pur::Input_Stream)
			    =
			    pur::input1evt stream
				==>
				fn THE (s, stream') => (THE s, stream');
				   NULL             => (NULL, stream);
				end;
		    end;

		fun input_mailop stream
		    =
		    with_nack
			(do_input  pur::input_mailop  stream);

		fun input_nevt (stream, n)
		    =
		    with_nack
			(do_input
			    (fn stream' = pur::input_nevt (stream', n))
			    stream
			);

		fun input_all_mailop stream
		    =
		    with_nack
			(do_input  pur::input_all_mailop  stream);

	    end;		 # stipulate

	    fun max_readable_without_blocking (stream, n)
		=
		pur::max_readable_without_blocking (thk::peek stream, n);

	    fun peek (stream:  Input_Stream)
		=
		case (pur::read_one (thk::peek stream))
		    #
		    THE (element, _) =>   THE element;
		    NULL             =>   NULL;
		esac;

	    fun close_input stream
		=
		{   (empty  stream)
			->
			(s as pur::INPUT_STREAM (buffer as pur::INPUT_BUFFER { data, ... }, _));


		    pur::close_input  s;
		    fill (stream, pur::find_eos buffer);
		};

	    fun end_of_stream stream
		=
		pur::end_of_stream (thk::peek stream);
	/*
	    fun getPosIn stream = pur::getPosIn (md::mGet stream)
	    fun setPosIn (stream, p) = mUpdate (stream, pur::setPosIn p)
	*/

	    # Output operations:
	    #
	    fun write (stream, v)     =  pur::write (thk::peek stream, v);
	    fun write_one (stream, c) =  pur::write_one (thk::peek stream, c);

	    fun flush        stream   =  pur::flush        (thk::peek stream);
	    fun close_output stream   =  pur::close_output (thk::peek stream);

	    fun get_output_position stream
		=
		pur::get_output_position (thk::peek stream);

	    fun set_output_position  (stream,  p as pur::OUT_POSITION { stream=>stream', ... } )
		=
		{   m_update (stream, stream');
		    #
		    pur::set_output_position  p;
		};

	    fun make_instream  (stream:  pur::Input_Stream )          =  make_full_maildrop stream;
	    fun get_instream   (stream:       Input_Stream )          =  thk::peek stream;
	    fun set_instream   (stream:       Input_Stream , stream') =  m_update (stream, stream');

	    fun make_outstream (stream:  pur::Output_Stream)          =  make_full_maildrop stream;
	    fun get_outstream  (stream:       Output_Stream)          =  thk::peek stream;
	    fun set_outstream  (stream:       Output_Stream, stream') =  m_update (stream, stream');

	    # Figure out the proper buffering mode for a given filewriter 
	    #
	    fun buffering (drv::FILEWRITER { io_descriptor => NULL, ... } )
		    =>
		    iox::BLOCK_BUFFERING;

		buffering (drv::FILEWRITER { io_descriptor => THE iod, ... } )
		    =>
		    winix::io::iod_to_iodkind iod  ==  winix::io::kind::tty
		    ??     iox::LINE_BUFFERING
		    ::     iox::BLOCK_BUFFERING;
	    end;

	    # Open files:
	    #
	    fun open_for_read fname
		=
		make_instream (pur::make_instream (wxd::open_for_read fname, empty_string))
		except
		    ex =  raise exception iox::IO { op=>"open_for_read", name=>fname, cause=>ex };

	    fun open_for_write  fname
		=
		{   wr =   wxd::open_for_write fname;
		    #
		    make_outstream (pur::make_outstream (wr, buffering wr))
		    except
			ex =  raise exception iox::IO { op=>"open", name=>fname, cause=>ex };
		};

	    fun open_for_append fname
		=
		make_outstream (pur::make_outstream (wxd::open_for_append fname, iox::NO_BUFFERING))
		except ex
		    =
		    raise exception iox::IO { op=>"open_for_append", name=>fname, cause=>ex };

	    # Text stream specific operations:
	    #
	    fun read_line stream
		=
		null_or::map
		    (fn (s, stream') = { fill (stream, stream'); s;})
		    (pur::read_line (empty stream));

	    fun write_substring (stream, ss)
		=
		pur::write_substring (thk::peek stream, ss);

	    fun open_string src
		=
		make_instream (pur::make_instream (wxd::string_reader src, empty_string))
		except
		    cause =  raise exception  iox::IO  {  op => "open_for_read",  name => "<string>",  cause };

	    package mailslot_io
		=
		threadkit_winix_mailslot_io_g (			# threadkit_winix_mailslot_io_g		is from   src/lib/std/src/io/threadkit-winix-mailslot-io-g.pkg
		    #
		    package drv =  drv;
		    package rv  =  vector_of_chars;		# vector_of_chars			is from   src/lib/std/vector-of-chars.pkg
		    package wv  =  rw_vector_of_chars;		# rw_vector_of_chars			is from   src/lib/std/rw-vector-of-chars.pkg
		    package rvs =  vector_slice_of_chars;	# vector_slice_of_chars			is from   src/lib/std/src/vector-slice-of-chars.pkg
		    package wvs =  rw_vector_slice_of_chars;	# rw_vector_slice_of_chars		is from   src/lib/std/src/rw-vector-slice-of-chars.pkg
		);


	    # Open an Input_Stream that is connected
	    # to the output port of a channel.
	    # 
	    fun open_slot_in slot
		=
		make_instream (pur::make_instream (mailslot_io::make_filereader slot, empty_string));


	    # Open an Output_Stream that is connected
	    # to the input port of a slot.
	    #
	    fun open_slot_out ch
		=
		make_outstream (pur::make_outstream (mailslot_io::make_filewriter ch, iox::NO_BUFFERING));


	    # * Standard streams *
	    #
	    stipulate
		#
		fun make_std_in rebind
		    =
		    {   (pur::make_instream'(wxd::stdin(), empty_string))
			    ->
			    (tag, stream);

			if rebind   eow::rebind_cleaner (tag, dummy_cleaner);   fi;

			stream;
		      };

		fun make_std_out rebind
		    =
		    {
			wr = wxd::stdout();

			(pur::make_outstream'  (wr,  buffering wr))
			    ->
			    (tag, stream);

			if rebind   eow::rebind_cleaner  (tag,  fn () = pur::flush stream);   fi;

			stream;
		    };

		fun make_std_err rebind
		    =
		    {   (pur::make_outstream'  (wxd::stderr (),  iox::NO_BUFFERING))
			    ->
			    (tag, stream);

			if rebind   eow::rebind_cleaner  (tag,  fn () =  pur::flush stream);   fi;

			stream;
		    };
	    herein

		# Build the standard streams.
		# 
		# Since we are not currently running threadkit,
		# we cannot do the cleaner renaming here,
		# but that is okay,
		# since these are just place holders.
		#
		stdin  =  make_instream  (make_std_in  FALSE);
		stdout =  make_outstream (make_std_out FALSE);
		stderr =  make_outstream (make_std_err FALSE);

		fun print s
		    =
		    {   stream' = empty stdout;
			#
			pur::write (stream', s);
			pur::flush stream';
			fill (stdout, stream');
		    };

		fun scan_stream  scan_g
		    =
		    do_it
		    where
			scan = scan_g  pur::read_one;

			fun do_it stream
			    =
			    {   instream = get_instream stream;
				#
				case (scan instream)
				    #
				    THE (item, instream')
					=>
					{   set_instream (stream, instream');
					    THE item;
					};

				    NULL => NULL;
				esac;
			    };
		    end;

		# Establish a hook function to rebuild the I/O stack 
		#
							my _ =
		eow::std_stream_hook
		    :=
		    (fn () =    {   set_instream  (stdin,  make_std_in  TRUE);
				    set_outstream (stdout, make_std_out TRUE);
				    set_outstream (stderr, make_std_err TRUE);
				    #
				    ri::print_hook :=   print;
				}
		    );
	    end;								# stipulate
	end;									# stipulate
    };										# threadkit_winix_text_file_for_os_g 
end;

## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
