## file-g.pkg

# Compiled by:
#     src/lib/std/src/standard-core.sublib

# Our package macro is invoked by:
#     src/lib/std/src/posix/file.pkg
#     src/lib/std/src/win32/win32-file.pkg
#
# QUESTION: what operations should raise exceptions when the stream is
# closed?		XXX BUGGO FIXME

stipulate
    package int =  int_guts;				# int_guts			is from   src/lib/std/src/bind-int-32.pkg
    package iox =  io_exceptions;			# io_exceptions			is from   src/lib/std/src/io/io-exceptions.pkg
    package ns  =  number_string;			# number_string			is from   src/lib/std/src/number-string.pkg
    package psx =  posix_1003_1b;			# posix_1003_1b			is from   src/lib/std/src/posix-1003.1b/posix-1003-1b.pkg
    package pth =  pthread;				# pthread			is from   src/lib/std/src/pthread.pkg
    package run =  runtime;				# runtime			is from   src/lib/core/init/runtime.pkg
    package stc =  string_chartype;			# string_chartype		is from   src/lib/std/src/string-chartype.pkg
    package str =  string_guts;				# string_guts			is from   src/lib/std/src/string-guts.pkg
    #
    package rvc =     vector_of_chars;			#    vector_of_chars		is from   src/lib/std/src/vector-of-chars.pkg
    package vsc =     vector_slice_of_chars;		#    vector_slice_of_chars	is from   src/lib/std/src/vector-slice-of-chars.pkg
    package wsc =  rw_vector_slice_of_chars;		# rw_vector_slice_of_chars	is from   src/lib/std/src/rw-vector-slice-of-chars.pkg
    package wvc =  rw_vector_of_chars;			# rw_vector_of_chars		is from   src/lib/std/src/rw-vector-of-chars.pkg
    #
    package wnx =  winix_guts;				# winix_guts			is from   src/lib/std/src/posix/winix-guts.pkg
herein
							# Winix_Base_Io			is from   src/lib/std/src/io/winix-base-io.api
							# File				is from   src/lib/std/src/io/file.api
    generic package file_g (
	#
	# On unix  below argument will be		# posix_text_base_io		is from   src/lib/std/src/posix/posix-text-base-io.pkg
	# On win32 below argument will be		# win32_text_base_io       	is from   src/lib/std/src/win32/win32-text-base-io.pkg

	package winix_base_io
	    :
	    api {
		include   Winix_Base_Io;
		#
		stdin:    Void -> base_io::Reader;
		stdout:   Void -> base_io::Writer;
		stderr:   Void -> base_io::Writer;
		#
		string_reader:  String -> base_io::Reader;
	    }
	    where
		base_io == text_base_io;

    )
    : (weak)  File					# File				is from   src/lib/std/src/io/file.api
    {
	mutex = pth::make_mutex ();

	package wio					# Unpack part of our generic's argument.
	    =
	    winix_base_io::base_io;

	some_element = '\000';
	    #
	    # An element for initializing buffers.

	#    # Fast, but unsafe version (from vector_of_chars):
	#    vecSub = inline_t::vector_of_chars::get
	#    arrUpdate = inline_t::rw_vector_of_chars::update
	#
	#    # Fast vector extract operation.
	#    # This should never be called with a length of 0.
	#
	#    fun vecExtract (v, base, optLen)
	#        =
	#        ( len = rvc::length v;
	#
	#	  fun newVec n = let
	#		newV = Assembly::a::make_string n
	#		fun fill i = if (i < n)
	#		      then (
	#			inline_t::vector_of_chars::update (newV, i, vecSub (v, base+i));
	#			fill (i+1))
	#		      else ()
	#		in
	#		  fill 0; newV
	#		end;
	#
	#	    case (base, optLen)
	#	     of (0, NULL) => v
	#	      | (_, NULL) => newVec (len - base)
	#	      | (_, THE n) => newVec n
	#	    #  end case 
	#       )

	vec_extract =  vsc::to_vector  o  vsc::make_slice;
	vec_get     =  rvc::get;
	rw_vec_set  =  wvc::set;

	substring_base =  substring::base;

	empty = "";

	# Return TRUE iff we can stat the given filepath:
	#
	fun exists (filename: String)			# Or directory name or whatever.
	    =
	    {   psx::stat  filename;
		TRUE;					# If we can 'stat' it, it exists.  So far as we're concerned. :-)
	    }
	    except
		run::RUNTIME_EXCEPTION _
		    =
		    FALSE;				# If we cannot 'stat' it, it doesn't exist.


	package pio {					# "pio" == "pure_io".	Exported to clients.
	    #
	    Vector        =  rvc::Vector;
	    Element       =  rvc::Element;
	    Reader        =  wio::Reader;
	    Writer        =  wio::Writer;
	    File_Position =  wio::File_Position;

	    # *** Functional input streams ***
	    #
	    # We represent an Input_Stream by a pointer to a buffer and an offset
	    # into the buffer.  The buffers are chained by the "more" field from
	    # the beginning of the stream towards the end.  If the "more" field
	    # is EOS, then it refers to an empty buffer (consuming the EOF marker
	    # involves moving the stream from immediately in front of the EOS to
	    # to the empty buffer).  A "more" field of TERMINATED marks a
	    # terminated stream.  We also have the invariant that the "tail"
	    # field of the "info" package points to a more REF that is either
	    # NO_MORE or TERMINATED.

	    Input_Stream = INPUT_STREAM  (Input_Buffer, Int)

	    also
	    Input_Buffer
		=
		INPUT_BUFFER
		  {
		    base_position:  Null_Or( File_Position ),
		    more:  Ref( More ),
		    data:  Vector,
		    info:  Info
		  }

	    also
	    More
	      = MORE  Input_Buffer	# Forward link to additional data.
	      | EOS   Input_Buffer	# End-of-stream marker.
	      | NO_MORE			# Placeholder for forward link.
	      | TERMINATED		# Termination of the stream.

	    also
	    Info =  INFO
		      {
			reader:                    Reader,
			read_vector:               Int -> Vector,
			read_vector_nonblocking:   Null_Or (Int -> Vector),
			get_position:              Void -> Null_Or( File_Position ),
			#
			clean_tag:     io_cleanup_at_shutdown::Tag,
			#
			closed:        Ref( Bool      ),
			tail:          Ref( Ref(More) )		# Points to the MORE cell of the last buffer.
		      };

	    #
	    fun info_of_ibuf (INPUT_BUFFER i)
		=
		i.info;

	    #
	    fun chunk_size_of_ibuf  buf
		=
		{   my INFO { reader=>wio::READER rd, ... }
			=
			info_of_ibuf  buf;

		    rd.chunk_size;
		};
	    #
	    fun read_vector (INPUT_BUFFER { info=>INFO i, ... } )
		=
		i.read_vector;
	    #
	    fun input_exn (INFO { reader=>wio::READER { name, ... }, ... }, function, cause)
		=
		raise exception iox::IO { function, name, cause };

	    # This exception is raised by read_vec_nonblocking
	    # in the blocking case 
	    #
	    exception WOULD_BLOCK;
	    #
	    fun extend_stream (read_g, ml_op, buf as INPUT_BUFFER { more, info, ... } )
		=
		{   info ->  INFO { get_position, tail, ... };

		    base_position =  get_position ();
		    data     =  read_g (chunk_size_of_ibuf buf);
		    new_more =  REF NO_MORE;

		    buf' = INPUT_BUFFER { base_position, data, info,  more => new_more  };

		    next
			=
			if (rvc::length data == 0)   EOS  buf';
			else                       MORE buf';
			fi;

		    more := next;
		    tail := new_more;
		    next;
		}
		except
		    ex =  input_exn (info, ml_op, ex);

	    #
	    fun get_buffer  (read_g, ml_op)  (buf as INPUT_BUFFER { more, info, ... } )
		=
		case *more
		    #
		    TERMINATED =>  EOS buf;
		    NO_MORE    =>  extend_stream (read_g, ml_op, buf);
		    more       =>  more;
		esac;


	    # Read a chunk that is at least
	    # the specified size:
	    #
	    fun read_chunk buf
		=
		{   my INFO { read_vector, reader=>wio::READER { chunk_size, ... }, ... }
			=
			info_of_ibuf buf;

		    case (chunk_size - 1)
			#
			0 => (fn n =  read_vector n);
			#
			k => (fn n                     # Round up to next multiple of chunk_size.
				 =
				 read_vector (int::quot((n+k), chunk_size) * chunk_size));
		    esac;
		};
	    #
	    fun generalized_input  get_buf
		=
		get
		where
		    fun get (INPUT_STREAM (buf as INPUT_BUFFER { data, ... }, pos))
			=
			{   len =  rvc::length data;

			    if (pos < len)
				#
				( vec_extract (data, pos, NULL),
				  INPUT_STREAM (buf, len)
				);
			    else
				case (get_buf buf)
				    #
				    EOS buf   =>  (empty, INPUT_STREAM (buf, 0));
				    MORE rest =>  get (INPUT_STREAM (rest, 0));
				    _         =>  raise exception FAIL "bogus get_buf";
				esac;
			    fi;
			};
		end;


	    # Terminate an input stream: 
	    #
	    fun terminate (INFO { tail, clean_tag, ... } )
		=
		case *tail
		    #
		    m as REF NO_MORE
			=>
			{   io_cleanup_at_shutdown::remove_cleaner clean_tag;
			    m := TERMINATED;
			};

		    m as REF TERMINATED
			=>
		       ();

		    _   => raise exception MATCH;		# Quiet compiler.
		esac;

	    #
	    fun read (stream as INPUT_STREAM (buf, _))
		=
		generalized_input
		    (get_buffer (read_vector buf, "read"))
		    stream;

	    #
	    fun read_one (INPUT_STREAM (buf, pos))
		=
		{   buf ->  INPUT_BUFFER { data, more, ... };

		    if (pos < rvc::length data)
			#
			THE (vec_get (data, pos), INPUT_STREAM (buf, pos+1));
		    else
			case *more
			    #
			    MORE buf => read_one (INPUT_STREAM (buf, 0));
			    EOS _    => NULL;
			    #
			    NO_MORE
				=>
				case (extend_stream (read_vector buf, "read_one", buf))
				    #
				    MORE rest =>  read_one (INPUT_STREAM (rest, 0));
				    _         =>  NULL;
				esac;

			    TERMINATED
				=>
				NULL;
		       esac;
		    fi;
		};
	    #
	    fun read_n (INPUT_STREAM (buf, pos), n)
		=
		{   fun join (item, (list, stream))
			=
			(item ! list, stream);
		    #
		    fun input_list (buf as INPUT_BUFFER { data, ... }, i, n)
			=
			{   len    =  rvc::length data;
			    remain =  len-i;

			    if (remain >= n)
				#
				([vec_extract (data, i, THE n)], INPUT_STREAM (buf, i+n));
			    else
				join (
				    vec_extract (data, i, NULL),
				    next_buf (buf, n-remain)
				);
			    fi;
			}

		    also
		    fun next_buf (buf as INPUT_BUFFER { more, data, ... }, n)
			=
			case *more
			    #
			    MORE buf =>  input_list (buf, 0, n);
			    EOS  buf =>  ([], INPUT_STREAM (buf, 0));
			    #
			    NO_MORE
				=>
				case (extend_stream (read_vector buf, "read_n", buf))

				     MORE rest
					 =>
					 input_list (rest, 0, n);

				     _   =>
					 ([], INPUT_STREAM (buf, rvc::length data));
				esac;

			    TERMINATED
				=>
				([], INPUT_STREAM (buf, rvc::length data));
			esac;

		    my (data, stream)
			=
			input_list (buf, pos, n);

		    (rvc::cat data, stream);
		};
	    #
	    fun read_all (stream as INPUT_STREAM (buf, _))
		=
		{
		    my INFO { reader=>wio::READER { avail, ... }, ... }
			=
			info_of_ibuf buf;

		    # Read a chunk that is as large as the available input.
		    # Note that for systems that use CR-LF for '\n', the
		    # size will be too large, but this should be okay.
		    #
		    fun big_chunk _
			=
			{   delta
				=
				case (avail ())

				     NULL  =>  chunk_size_of_ibuf buf;
				     THE n =>  n;
				esac;

			    read_chunk buf delta;
			};

		    big_input
			=
			generalized_input (get_buffer (big_chunk, "read_all"));
		    #
		    fun loop (v, stream)
			=
			if (rvc::length v == 0)
			    #	
			    ([], stream);
			else
			    (loop (big_input stream))
				->
				(l, stream');

			    (v ! l, stream');
			fi;

		    my (data, stream')
			=
			loop (big_input stream);

		    (rvc::cat data, stream');
		};

	    # Return  THE k,  if k <= amount of characters
	    # that can be read without blocking:
	    #
	    fun can_read (stream as INPUT_STREAM (buf, pos), amount)
		=
		{   read_vector_nonblocking
			=
			case buf
			    #
			    (INPUT_BUFFER { info as INFO { read_vector_nonblocking=>NULL, ... }, ... } )
				=>
				input_exn (info, "can_read", iox::NONBLOCKING_IO_NOT_SUPPORTED);

			    (INPUT_BUFFER { info=>INFO { read_vector_nonblocking=>THE f, ... }, ... } )
				=>
				f;
			esac;

		    #
		    fun try_input (buf as INPUT_BUFFER { data, ... }, i, n)
			=
			{   len    =  rvc::length data;
			    remain =  len - i;

			    if (remain >= n)   THE n;
			    else               next_buf (buf, n - remain);
			    fi;
			  }

		    also
		    fun next_buf (INPUT_BUFFER { more, ... }, n)
			=
			case *more
			    #
			    MORE buf   =>  try_input (buf, 0, n);
			    EOS _      =>  THE (amount - n);
			    TERMINATED =>  THE (amount - n);
			    #
			    NO_MORE
				=>
				case (extend_stream (read_vector_nonblocking, "can_read", buf))
				    #
				    MORE b =>  try_input (b, 0, n);
				    _      =>  THE (amount - n);
				esac
				except
				    iox::IO { cause=>WOULD_BLOCK, ... }
					=
					THE (amount - n);
			esac;


		    if (amount < 0)   raise exception SIZE;
		    else              try_input (buf, pos, amount);
		    fi;
		};
	    #
	    fun close_input  (INPUT_STREAM (buf, _))
		=
		case (info_of_ibuf  buf)
		    #	
		    INFO { closed=>REF TRUE, ... }
			=>
			();

		    info as INFO { closed, reader=>wio::READER { close, ... }, ... }
			=>
			{   terminate info;
			    closed := TRUE;

			    close ()
			    except
				ex =  input_exn (info, "close_input", ex);
			};
		esac;

	    #
	    fun end_of_stream (INPUT_STREAM (buf, pos))
		=
		case buf
		    #
		    INPUT_BUFFER { more=>REF (MORE _), ... }  =>  FALSE;
		    INPUT_BUFFER { more=>REF (EOS _),  ... }  =>  TRUE;
		    #
		    INPUT_BUFFER { more, data, info=>INFO { closed, ... }, ... }
			=>
			if (pos != rvc::length data)
			    #
			    FALSE;
			else
			    case (*more, *closed)
				#
				(NO_MORE, FALSE)
				    =>
				    case (extend_stream (read_vector buf, "end_of_stream", buf))
					#
					(EOS _) =>  TRUE;
					_       =>  FALSE;
				    esac;

				_ => TRUE;
			    esac;
			fi;
		esac;

	    #
	    fun make_instream (reader, data)
		=
		{   reader ->  wio::READER { read_vector, read_vector_nonblocking, get_position, set_position, ... };

		    read_vector'
			=
			case read_vector
			    #
			    NULL  =>  (fn _ =  raise exception iox::BLOCKING_IO_NOT_SUPPORTED);
			    THE f =>  f;
			esac;

		    read_vector_nonblocking'
			=
			case read_vector_nonblocking
			    #
			    NULL  =>  NULL;
			    #
			    THE f
				=>
				THE (fn arg
					=
					case (f arg)
					    #
					    THE x =>  x;
					    NULL  =>  raise exception WOULD_BLOCK;
					esac
				    );
			esac;

		    get_position
			=
			case (get_position, set_position)
			    #
			    (THE f, THE _) =>   fn () =  THE (f());
			    _              =>   fn () =  NULL;
			esac;

		    more = REF NO_MORE;

		    closed_flag = REF FALSE;

		    tag =
			io_cleanup_at_shutdown::add_cleaner
			  {
			    init  =>  fn () =  closed_flag := TRUE,
			    flush =>  fn () =  (),
			    close =>  fn () =  closed_flag := TRUE
			  };

		    info = INFO
			      {
				reader,
				get_position,
				read_vector             =>  read_vector',
				read_vector_nonblocking =>  read_vector_nonblocking',
				#	
				closed                  =>  closed_flag,
				tail                    =>  REF more,
				clean_tag               =>  tag
			      };

		    # What should we do about the position when there is initial data?
		    # Suggestion: When building a stream with supplied initial data,
		    # nothing can be said about the positions inside that initial
		    # data (who knows where that data even came from!).

		    base_position
			=
			if (rvc::length data == 0)   get_position ();
			else                         NULL;
			fi;

		    INPUT_STREAM(
		      INPUT_BUFFER { base_position, data, info, more },
		      0
		    );
		};

	    #
	    fun get_reader (INPUT_STREAM (buf, pos))
		=
		{   buf ->  INPUT_BUFFER
				{ data,
				  info as INFO { reader, ... },
				  more,
				  ...
				};
		    #
		    fun get_data (MORE (INPUT_BUFFER { data, more, ... } ))
			    =>
			    data ! get_data *more;

			get_data _
			    =>
			    [];
		    end;

		    terminate info;

		    if (pos < rvc::length data)
			#
			( reader,
			  rvc::cat (vec_extract (data, pos, NULL) ! get_data *more)
			);
		    else
			( reader,
			  rvc::cat (get_data *more)
			);
		    fi;
		};

	    # Get the underlying file position of a stream:
	    #
	    fun file_position_in (INPUT_STREAM (buf, pos))
		=
		case buf
		    #
		    INPUT_BUFFER { base_position=>NULL, info, ... }
			=>
			input_exn (info, "filePosIn", iox::RANDOM_ACCESS_IO_NOT_SUPPORTED);

		    INPUT_BUFFER { base_position=>THE base, info, ... }
			=>
			{   info ->  INFO { reader=>wio::READER rd, read_vector, ... };

			    case (rd.get_position, rd.set_position)
				#
				( THE get_position,
				  THE set_position
				)
				    =>
				    {   tmp_pos =  get_position ();
					#
					fun read_n 0
						=>
						();

					    read_n n
						=>
						case (rvc::length (read_vector n))
						    #
						    0 =>  input_exn (info, "filePosIn", FAIL "bogus position");
						    k =>  read_n (n-k);
						esac;
					end;

					set_position base;
					read_n pos;

					get_position ()
					before
					    set_position tmp_pos;
				    };

				_   => raise exception FAIL "filePosIn: impossible";
			    esac;
			};
		esac;


	    # Text stream specific operations:
	    #
	    fun read_line (INPUT_STREAM (buf as INPUT_BUFFER { data, more, ... }, pos))
		=
		{   fun join (item, (list, stream))
			=
			(item ! list, stream);
		    #
		    fun next_buf (buf as INPUT_BUFFER { more, data, ... } )
			=
			{   fun last ()
				=
				(["\n"], INPUT_STREAM (buf, rvc::length data));

			    case *more
				#
				MORE buf =>  scan_data (buf, 0);
				EOS  buf =>  last ();
				#
				NO_MORE
				    =>
				    case (extend_stream (read_vector buf, "read_line", buf))
					#
					EOS _     =>  last ();
					MORE rest =>  scan_data (rest, 0);
					_         =>  raise exception MATCH;
				    esac;

				TERMINATED
				    =>
				    last ();
			    esac;
			}

		    also
		    fun scan_data (buf as INPUT_BUFFER { data, more, ... }, i)
			=
			{   len = rvc::length data;
			    #
			    fun scan j
				=
				if (j == len)
				    #
				    join (vec_extract (data, i, NULL), next_buf buf);
				else
				    if (vec_get (data, j) == '\n')
					#
					([vec_extract (data, i, THE (j+1-i))], INPUT_STREAM (buf, j+1));
				    else
					scan (j+1);
				    fi;
				fi;

			    scan i;
			  };

		    my (data, stream)
			=
			if (rvc::length data == pos)
			    #
			    case (get_buffer (read_vector buf, "read_line") buf)
				#
				EOS buf =>  ([""], INPUT_STREAM (buf, 0));
				_       =>  next_buf buf;
			    esac;
			else
			    scan_data (buf, pos);
			fi;

		    result_vec = rvc::cat data;

		    if (rvc::length result_vec == 0)   NULL;
		    else                             THE (result_vec, stream);
		    fi;
		};

	    # ** Output streams **
	    Output_Stream
		=
		OUTPUT_STREAM
		  { buf:          wvc::Rw_Vector,
		    #
		    pos:          Ref( Int ),
		    closed:       Ref( Bool ),
		    buffering:    Ref( iox::Buffering ),
		    #
		    writer:       Writer,
		    #
		    write_rw_vector: wsc::Slice -> Void,
		    write_vector:    vsc::Slice -> Void,
		    clean_tag:       io_cleanup_at_shutdown::Tag
		  };
	    #
	    fun raise_io_exception (OUTPUT_STREAM { writer=>wio::WRITER { name, ... }, ... }, ml_op, cause)
		=
		raise exception iox::IO { function=>ml_op, name, cause };

	    #
	    fun is_nl '\n' =>  TRUE;
		is_nl _    =>  FALSE;
	    end;
	    #
	    fun raise_exception_if_output_stream_is_closed (stream as OUTPUT_STREAM { closed=>REF TRUE, ... }, ml_op)
		    =>
		    raise_io_exception (stream, ml_op, iox::CLOSED_IO_STREAM);

		raise_exception_if_output_stream_is_closed _
		    =>
		    ();
	    end;
	    #
	    fun flush_buffer (stream as OUTPUT_STREAM { buf, pos, write_rw_vector, ... }, ml_op)
		=
		case *pos
		    #
		    0 => ();
		    #
		    n => {   write_rw_vector (wsc::make_slice (buf, 0, THE n));
			     pos := 0;
			 }
			 except
			     ex = raise_io_exception (stream, ml_op, ex);
		esac;


	    # A copy_vec that checks for newlines while it is copying.
	    # This is used for LINE_BUFFERING output of strings and substrings.
	    #
	    fun line_buf_copy_vec (src, src_i, src_len, dst, dst_i)
		=
		cpy (src_i, dst_i, FALSE)
		where
		    stop = src_i + src_len;
		    #
		    fun cpy (src_i, dst_i, linebreak)
			=
			if (src_i >= stop)
			    #
			    linebreak;
			else
			    c = vec_get (src, src_i);

			    rw_vec_set (dst, dst_i, c);

			    cpy (src_i+1, dst_i+1, linebreak or is_nl c);
			fi;
		end;

	    #  A copy_vec for BLOCK_BUFFERING output of strings and substrings.
	    #
	    fun block_buf_copy_vec (from, from_i, from_len, to, to_i)
		=
		{   wsc::copy_vec { from => vsc::make_slice (from, from_i, THE from_len),
				    to,
				    di => to_i
				  };
		    FALSE;
		};

	    #
	    fun write (stream as OUTPUT_STREAM output_stream, v)
		=
#		pth::with_mutex_do  mutex  .{			# TI'd like to do this to eliminate duplicate output lines in pthread-unit-text.pkg, but it makes the final x-kit regression (Show-Graph) hang. :-( -- 2012-03-03 CrT
		{
		    #
		    raise_exception_if_output_stream_is_closed  (stream, "write");

		    output_stream ->  { buf, pos, buffering, ... };
		    #
		    fun flush ()
			=
			flush_buffer (stream, "write");
		    #
		    fun write_direct ()
			=
			{   case *pos
				#
				0 =>	();
				#
				n =>    {   output_stream.write_rw_vector (wsc::make_slice (buf, 0, THE n));
					    #
					    pos := 0;
					};
			    esac;

			    output_stream.write_vector (vsc::make_full_slice v);
			}
			except
			    ex =  raise_io_exception (stream, "write", ex);
		    #
		    fun insert copy_vec
			=
			{   buf_len  =  wvc::length buf;
			    data_len =  rvc::length v;

			    if (data_len >= buf_len)
				#
				write_direct ();
			    else
				i     =  *pos;
				avail =  buf_len - i;

				if (avail < data_len)
				    #
				    wsc::copy_vec { from => vsc::make_slice (v, 0, THE avail),
						   to   => buf,
						   di   => i
						 };

				    output_stream.write_rw_vector  (wsc::make_full_slice  buf)
				    except
					ex =    {   pos :=  buf_len;
						    #
						    raise_io_exception (stream, "write", ex);
						};

				    needs_flush
					=
					copy_vec (v, avail, data_len-avail, buf, 0);

				    pos := data_len-avail;

				    if needs_flush      flush ();   fi;

				else

				    needs_flush
					=
					copy_vec (v, 0, data_len, buf, i);

				    pos :=  i + data_len;

				    if (needs_flush or (avail == data_len))
					#  
					flush ();
				    fi;
				fi;
			    fi;
			};

		    case *buffering
			#
			iox::NO_BUFFERING    =>  write_direct ();
			iox::LINE_BUFFERING  =>  insert line_buf_copy_vec;
			iox::BLOCK_BUFFERING =>  insert block_buf_copy_vec;
		    esac;

		};												# fun write

	    #
	    fun write_one (stream as OUTPUT_STREAM { buf, pos, buffering, write_rw_vector, ... }, element)
		=
		{   raise_exception_if_output_stream_is_closed (stream, "write_one");
		    #
		    case *buffering
			#
			iox::NO_BUFFERING
			    =>
			    {   rw_vec_set (buf, 0, element);
				#
				write_rw_vector (wsc::make_slice (buf, 0, THE 1))
				except
				    ex =  raise_io_exception (stream, "write_one", ex);
			    };

			iox::LINE_BUFFERING
			    =>
			    {   i  =  *pos;
				i' =  i+1;

				rw_vec_set (buf, i, element);
				pos := i';

				if  (i' == wvc::length buf
				or   is_nl element
				)
				     flush_buffer (stream, "write_one");
				fi;
			    };

			iox::BLOCK_BUFFERING
			    =>
			    {   i  =  *pos;
				i' =  i+1;

				rw_vec_set (buf, i, element);
				pos := i';

				if   (i' == wvc::length buf)

				     flush_buffer (stream, "write_one");
				fi;
			    };
		    esac;
		};
	    #
	    fun flush stream
		=
		flush_buffer (stream, "flush");

	    #
	    fun close_output (stream as OUTPUT_STREAM { writer=>wio::WRITER { close, ... }, closed, clean_tag, ... } )
		=
		if (not *closed)
		    #
		    flush_buffer (stream, "close");
		    closed := TRUE;
		    io_cleanup_at_shutdown::remove_cleaner clean_tag;
		    close ();
		fi;
	    #
	    fun make_outstream (wr as wio::WRITER { chunk_size, write_rw_vector, write_vector, ... }, mode)
		=
		{   fun iterate (f, size, subslice) sl
			=
			lp sl
			where
			    fun lp sl
				=
				if   (size sl != 0)

				     n = f sl;

				     lp (subslice (sl, n, NULL));
				fi;
			end;

		    write_rw_vector'
			=
			case write_rw_vector
			    #
			    NULL  =>  (fn _ =  raise exception iox::BLOCKING_IO_NOT_SUPPORTED);
			    THE f =>  iterate (f, wsc::length, wsc::make_subslice);
			esac;


		    write_vector'
			=
			case write_vector
			    #
			    NULL  =>  (fn _ =  raise exception iox::BLOCKING_IO_NOT_SUPPORTED);
			    THE f =>  iterate (f, vsc::length, vsc::make_subslice);
			esac;


		    # Install a dummy cleaner:
		    #
		    tag = io_cleanup_at_shutdown::add_cleaner
			      {
				init  =>  fn () =  (),
				flush =>  fn () =  (),
				close =>  fn () =  ()
			      };

		    stream
			=
			OUTPUT_STREAM
			    { buf          =>  wvc::make_rw_vector (chunk_size, some_element),
			      pos          =>  REF 0,
			      closed       =>  REF FALSE,
			      buffering    =>  REF mode,
			      writer       =>  wr,
			      clean_tag    =>  tag,
			      write_vector =>  write_vector',
			      write_rw_vector   =>  write_rw_vector'
			    };

		    io_cleanup_at_shutdown::rebind_cleaner (
			#
			tag,
			#
			{ init  =>  fn () = close_output  stream,
			  flush =>  fn () = flush         stream,
			  close =>  fn () = close_output  stream
			}
		    );

		    stream;
		};
	    #
	    fun get_writer (stream as OUTPUT_STREAM { writer, buffering, ... } )
		=
		{   flush_buffer (stream, "getWriter");
		    (writer, *buffering);
		};



	    # Position operations on outstreams:

	    Out_Position
		=
		OUT_POSITION
		    { pos:     wio::File_Position,
		      stream:  Output_Stream
		    };
	    #
	    fun get_output_position (stream as OUTPUT_STREAM { writer, ... } )
		=
		{   flush_buffer (stream, "get_output_position");

		    case writer
			#
			wio::WRITER { get_position=>THE f, ... }
			    =>
			    OUT_POSITION { pos => f(), stream }
			    except
				ex = raise_io_exception (stream, "get_output_position", ex);

			_   =>   raise_io_exception (stream, "get_output_position", iox::RANDOM_ACCESS_IO_NOT_SUPPORTED);
		    esac;
		};
	    #
	    fun file_pos_out (OUT_POSITION { pos, stream } )
		=
		{   raise_exception_if_output_stream_is_closed (stream, "filePosOut");
		    #
		    pos;
		};
	    #
	    fun set_output_position (OUT_POSITION { pos, stream as OUTPUT_STREAM { writer, ... } } )
		=
		{   raise_exception_if_output_stream_is_closed (stream, "set_output_position");

		    case writer
			#
			wio::WRITER { set_position=>THE f, ... }
			    =>
			    (f pos)
			    except
				ex =  raise_io_exception (stream, "set_output_position", ex);

			_   =>
			    raise_io_exception (stream, "get_output_position", iox::RANDOM_ACCESS_IO_NOT_SUPPORTED);
		    esac;
		};


	    # Text-specific operations:
	    #
	    fun write_substring (stream as OUTPUT_STREAM output_stream, ss)
		=
		{
		    raise_exception_if_output_stream_is_closed (stream, "write_substring");

		    (substring_base  ss)
			->
		        (v, data_start, data_len);

		    output_stream ->   { buf, pos, buffering, ... };

		    buf_len =  wvc::length  buf;

		    #
		    fun flush ()
			=
			flush_buffer (stream, "write_substring");

		    #
		    fun write_direct ()
			=
			{   case *pos
				#
				0 => ();
				#
				n =>    {   output_stream.write_rw_vector  (wsc::make_slice  (buf, 0, THE n));
					    #
					    pos := 0;
					};
			    esac;

			    output_stream.write_vector
				#
				(vsc::make_slice
				    ( v,
				      data_start,
				      THE data_len
				)   );
			}
			except
			    ex =  raise_io_exception (stream, "write_substring", ex);
		    #
		    fun insert copy_vec
			=
			{   buf_len =  wvc::length  buf;

			    if (data_len >= buf_len)
				#
				write_direct ();
			    else
				i = *pos;
				avail = buf_len - i;

				if (avail < data_len)
				    #
				    wsc::copy_vec { from =>  vsc::make_slice (v, data_start, THE avail),
						    to   =>  buf,
						    di   =>  i
						  };

				    output_stream.write_rw_vector  (wsc::make_full_slice  buf)
				    except
					ex  =	{   pos := buf_len;
						    #
						    raise_io_exception (stream, "write_substring", ex);
						};

				    needs_flush
					=
					copy_vec (v, data_start+avail, data_len-avail, buf, 0);

				    pos := data_len-avail;

				    if   needs_flush      flush ();   fi;
				else
				    needs_flush
					=
					copy_vec (v, data_start, data_len, buf, i);

				    pos := i + data_len;

				    if (needs_flush  or  avail == data_len)   flush ();   fi;
				fi;
			    fi;
			};

		    case *buffering
			#
			iox::NO_BUFFERING    =>  write_direct ();
			iox::LINE_BUFFERING  =>  insert  line_buf_copy_vec;
			iox::BLOCK_BUFFERING =>  insert  block_buf_copy_vec;
		    esac;
		};

	    #
	    fun set_buffer_mode  (stream as OUTPUT_STREAM { buffering, ... },  iox::NO_BUFFERING)
		    =>
		    {   flush_buffer (stream, "setBufferMode");
			#
			buffering := iox::NO_BUFFERING;
		    };

		set_buffer_mode  (stream as OUTPUT_STREAM { buffering, ... },  mode)
		    =>
		    {   raise_exception_if_output_stream_is_closed (stream, "setBufferMode");
			#
			buffering := mode;
		    };
	    end;

	    #
	    fun get_buffer_mode  (stream as OUTPUT_STREAM { buffering, ... } )
		=
		{   raise_exception_if_output_stream_is_closed (stream, "getBufferMode");
		    #
		    *buffering;
		};

	};									# package pio 		("pio" == "pure_io").

	Vector  =  rvc::Vector;
	Element =  rvc::Element;

	Input_Stream  = Ref( pio::Input_Stream  );				# XXX SUCKO FIXME  Jeez, more thread-hostile global mutable state in the making.
	Output_Stream = Ref( pio::Output_Stream );				# XXX SUCKO FIXME

	# Input operations:
	#
	fun read stream
	    =
	    {   (pio::read  *stream)
		    ->
		    (v, stream');

		stream := stream';

		v;
	    };

	#
	fun read_one stream
	    =
	    case (pio::read_one *stream)
		#
		NULL => NULL;
		THE (element, stream') => { stream := stream'; THE element;};
	    esac;

	#
	fun read_n (stream, n)
	    =
	    {   (pio::read_n (*stream, n))
		    ->
		    (v, stream');

		stream := stream'; v;
	    };
	#
	fun read_all (stream:  Input_Stream)
	    =
	    {   (pio::read_all  *stream)
		    ->
		    (v, s);

		stream := s;

		v;
	    };

	#
	fun can_read (stream, n)
	    =
	    pio::can_read (*stream, n);

	#
	fun lookahead (stream:  Input_Stream)
	    =
	    case (pio::read_one *stream)
		#
		THE (element, _) =>  THE element;
		NULL             =>  NULL;
	    esac;

	#
	fun close_input stream
	    =
	    {   (*stream)
		    ->
		    s as pio::INPUT_STREAM (buf as pio::INPUT_BUFFER { data, ... }, _);

		# Find the end of the stream:
		#
		fun find_eos (pio::INPUT_BUFFER { more=>REF (pio::MORE buf), ... } )
			=>
			find_eos buf;

		    find_eos (pio::INPUT_BUFFER { more=>REF (pio::EOS buf), ... } )
			=>
			find_eos buf;

		    find_eos (buf as pio::INPUT_BUFFER { data, ... } )
			=>
			pio::INPUT_STREAM (buf, rvc::length data);
		end;

		pio::close_input  s;

		stream :=  find_eos  buf;
	    };
	#
	fun end_of_stream  stream
	    =
	    pio::end_of_stream  *stream;


	# Output operations:
	#
	fun write     (stream, v) =  pio::write(*stream, v);
	fun write_one (stream, c) =  pio::write_one(*stream, c);
	#
	fun flush         stream =  pio::flush         *stream;
	fun close_output  stream =  pio::close_output  *stream;
	#
	fun get_output_position stream
	    =
	    pio::get_output_position  *stream;
	#
	fun set_output_position (stream, p as pio::OUT_POSITION { stream=>stream', ... } )
	    =
	    {   stream := stream';
		pio::set_output_position p;
	    };
	#
	fun make_instream  (stream:  pio::Input_Stream)  =  REF stream;
	fun get_instream   (stream:  Input_Stream)           =  *stream;
	fun set_instream   (stream:  Input_Stream, stream')  =  stream := stream';
	#
	fun make_outstream (stream:  pio::Output_Stream) =  REF stream;
	fun get_outstream  (stream:  Output_Stream)          =  *stream;
	fun set_outstream  (stream:  Output_Stream, stream') =  stream := stream';

	# Figure out the proper buffering mode for a given writer:
	# 
	fun buffering (wio::WRITER { io_descriptor=>NULL, ... } )
		=>
		iox::BLOCK_BUFFERING;

	    buffering (wio::WRITER { io_descriptor=>THE iod, ... } )
		=>
		if (wnx::io::kind iod
		==  wnx::io::kind::tty)   iox::LINE_BUFFERING;
		else                      iox::BLOCK_BUFFERING;
                fi;
	end;


    ######### BEGIN INTERPOLATED 'say.pkg' STUFF #######################3

	server_name =  REF NULL: Ref( Null_Or( String ));
	log_fd      =  REF NULL: Ref( Null_Or( psx::File_Descriptor ) );
	#
	fun log' stringlist
	    =
	    case (*server_name, *log_fd)
		#
		(THE name, THE fd)
		    =>
		    {   string =  (name + ":  " + (cat  stringlist));
			bytes  =  byte::string_to_bytes string;
			slice  =  vector_slice_of_one_byte_unts::make_slice (bytes, 0, NULL);
			psx::write_vector( fd, slice );
			();
		    };

		_ => ();
	    esac;

    ######### END   INTERPOLATED 'say.pkg' STUFF #######################3


	# * Open files *
	#   fun open_for_read was originally defined here... 2007-01-19 CrT 
	#
	fun open_for_write  filename
	    =
	    {   wr = winix_base_io::open_for_write  filename;
		#
		make_outstream (pio::make_outstream (wr, buffering wr));
	    }
	    except
		ex =  {    # The following produces too much noise to leave on permamently,
			   # but the usual error message for a missing source file is hopelessly
			   # vague without it.  So for now we uncomment it as needed. XXX BUGGO FIXME

    print (cat ["file-g.pkg: open: failed to open for output: <<<", filename, ">>>\n" ]);


			   raise exception iox::IO { function=>"open", name=>filename, cause=>ex };
		      };


	#
	fun open_for_append  filename
	    =
	    make_outstream
		(pio::make_outstream
		    (winix_base_io::open_for_append filename, iox::NO_BUFFERING)
		)
	    except
		cause =  raise exception iox::IO { function=>"open_for_append", name=>filename, cause };



	# Text stream specific operations
	#
	fun read_line stream
	    =
	    null_or::map
		(fn (v, s) =  { stream := s;   v;})
		(pio::read_line  *stream);

	#
	fun read_lines input_stream
	    =
	    read_lines' (input_stream, [])
	    where
		fun read_lines' (s, lines_so_far)
		    =
		    case (read_line s)
			#
			NULL     =>  reverse lines_so_far; 
			THE line =>  read_lines' (s, line ! lines_so_far);
		    esac;
	    end;
	#
	fun write_substring (stream, ss)
	    =
	    pio::write_substring (*stream, ss);

	#
	fun open_string src
	    =
	    make_instream (pio::make_instream (winix_base_io::string_reader src, empty))
	    except
		cause =  raise exception iox::IO { function=>"open_for_read", name=>"<string>", cause };


	# The standard streams stdin/stdout/stderr
	#
	stipulate
	    #
	    package sio = pio;						# "pio" == "pure_io".
	    #
	    fun make_std_in ()
		=
		{   (sio::make_instream  (winix_base_io::stdin(),  empty))
			->
			(stream as sio::INPUT_STREAM (sio::INPUT_BUFFER { info=>sio::INFO { clean_tag, ... }, ... }, _));


		    io_cleanup_at_shutdown::rebind_cleaner
			(
			  clean_tag,

			  { init  =>  fn () = (),
			    flush =>  fn () = (),
			    close =>  fn () = ()
			  }
			);

		    stream;
		};
	    #
	    fun make_std_out ()
		=
		{   wr =  winix_base_io::stdout ();

		    my (stream as sio::OUTPUT_STREAM { clean_tag, ... } )
			=
			sio::make_outstream (wr, buffering wr);

		    io_cleanup_at_shutdown::rebind_cleaner
			(
			  clean_tag,

			  { init  =>  fn () =  (),
			    flush =>  fn () =  sio::flush stream,
			    close =>  fn () =  sio::flush stream
			  }
			);

		    stream;
		  };
	    #
	    fun make_std_err ()
		=
		{   my (stream as sio::OUTPUT_STREAM { clean_tag, ... } )
			=
			sio::make_outstream (winix_base_io::stderr(), iox::NO_BUFFERING);

		    io_cleanup_at_shutdown::rebind_cleaner
			(
			  clean_tag,

			  { init  =>  fn () = (),
			    flush =>  fn () = sio::flush stream,
			    close =>  fn () = sio::flush stream
			  }
			);

		    stream;
	      };
	herein
	    stdin  =  make_instream  (make_std_in  ());
	    stdout =  make_outstream (make_std_out ());
	    stderr =  make_outstream (make_std_err ());

	    #  Establish a hook function to rebuild the I/O stack 
										 my _ = 
	    io_cleanup_at_shutdown::std_strm_hook
		:=
	       .{   {   set_instream  (stdin,  make_std_in  ());
			set_outstream (stdout, make_std_out ());
			set_outstream (stderr, make_std_err ());
		    };
		};
	end;							#  with

	#
	fun print s
	    =
	    {   write (stdout, s);
		flush stdout;
	    };

	#
	fun scan_stream  scan_g
	    =
	    {   scan =  scan_g  pio::read_one;
		#
		do_it
		where
		    fun do_it  stream
			=
			{   instrm =  get_instream  stream;
			    #
			    case (scan instrm)
				#
				NULL => NULL;
				#
				THE (item, instrm')
				    =>
				    {   set_instream (stream, instrm');
					THE item;
				    };
			    esac;

			};
		end;
	    };

	#
	fun open_for_read  filename
	    =
	    make_instream (pio::make_instream  (winix_base_io::open_for_read  filename,  empty))
	    except
		ex =  {    # The following produces too much noise to leave on permamently,
			   # but the usual error message for a missing source file is hopelessly
			   # vague without it.  So for now we uncomment it as needed. XXX BUGGO FIXME

			   # log ["file-g.pkg: open_for_read: failed to open for input: '"];
			   # log [filename];
			   # log ["'\n"];
			   # print ("file-g.pkg: psx::current_directory         = " + (psx::current_directory()) + "\n");
			   # print "file-g.pkg: open_for_read: failed to open for input: '";
			   # print filename;
			   # print "'\n";

			   raise exception iox::IO { function=>"open_for_read", name=>filename, cause=>ex };
		      };

	#
	fun lines filename
	    =
	    {    fd = open_for_read  filename;
		 result = read_lines fd;
		 close_input fd;
		 result;
	    };
	#
	fun from_lines filename lines
	    =
	    {   fd = open_for_write  filename;
		#
		map  .{ write (fd, #line); }  lines;

		flush        fd;
		close_output fd;
	    };


	###################################################################
	# Stuff from   src/lib/src/lib/thread-kit/src/lib/logger.pkg

	exception NO_SUCH_LOGTREE_NODE;

	# Where log output goes:
	#
	Log_To
	  #
	  = LOG_TO_STDOUT
	  | LOG_TO_STDERR
	  | LOG_TO_NULL
	  | LOG_TO_FILE    String
	  | LOG_TO_STREAM  Output_Stream
	  ;

	Logtree_Node
	    =
	    LOGTREE_NODE
	      {
		parent:     Null_Or (Logtree_Node),		# NULL only on root node of tree.
		name:       String,
		#
		logging:    Ref( Bool ),
		children:   Ref(  List(  Logtree_Node ) )
	      };


	# Default to printing log messages to "unknown.log":
	# until someone tells us different via 'set_logger_to':
	#
	log_to         =  REF (LOG_TO_FILE "unknown.log");
	logger_cleanup =  REF (fn () = ());

	# Set output for log messsages:
	#
	fun set_logger_to  t
	    =
	    log_to := t;
	#
	fun logger_is_set_to ()
	    =
	    *log_to;

	all_logging
	    =
	    LOGTREE_NODE
	      {
		parent    => NULL,
		name      => "logger::all_logging",
		#
		logging   => REF FALSE,
		children  => REF []
	      };
	#
	fun for_all f
	    =
	    for'
	    where
		fun for' (tm as LOGTREE_NODE { children, ... } )
		    =
		    {   f tm;

			for_children *children;
		    }

		also
		fun for_children []
			=>
			();

		    for_children (tm ! r)
			=>
			{   for' tm;
			    for_children r;
			};
		end;
	    end;

	#
	fun find_logtree_node_by_name  search_name
	    =
	    case (find [ all_logging ])
		#
		THE node =>  node;
		NULL     =>  raise exception NO_SUCH_LOGTREE_NODE;
	    esac 
	    where
		fun find [] =>   NULL;
		    #
		    find ((node as LOGTREE_NODE { name, children, ... }) ! rest)
			=>
			if (name == search_name)
			    #
			    THE node;
			else
			    case (find *children)
				#
				THE node => THE node;
				NULL     => find rest;
			    esac;
			fi;
		end;
	    end;
	#
	fun make_logtree_leaf
	    { parent => parent_node as LOGTREE_NODE parent,
	      name
	    }
	    =
	    {   avoid_duplicate_children *parent.children;

		new_node
		    =
		    LOGTREE_NODE
		      {
			name,
			parent    => THE parent_node,
			logging   =>  REF *parent.logging,
			children  =>  REF []
		      };

		parent.children
		    :=
		    new_node ! *parent.children;

		new_node;
	    }
	    where
		#
		fun avoid_duplicate_children []
			=>
			();

		   avoid_duplicate_children ((child_node as LOGTREE_NODE { name => name', ... } ) ! rest)
		       =>
		       if (name == name')
			   #
			   raise exception FAIL ("logger::make_logtree_leaf: Already have a child '" + name + "' of node '" + parent.name + "'!"  );
		       else
			   avoid_duplicate_children  rest;
		       fi;
		end;
	    end;

	# Return the name of the node
	#
	fun name_of_logtree_node (LOGTREE_NODE { name => node_name, ... } )
	    =
	    node_name;

	# Return the parent of the node
	#
	fun parent_of_logtree_node (LOGTREE_NODE { parent => node_parent, ... } )
	    =
	    node_parent;

	# Return all ancestors of node.
	# First element of list (if nonempty)
	# will always be the root node, all_logging:
	#
	fun ancestors_of_logtree_node  node
	    =
	    ancestors' (node, [])
	    where
		fun ancestors' (LOGTREE_NODE { parent => NULL, ... }, resultlist)
			=>
			resultlist;

		    ancestors' (LOGTREE_NODE { parent => THE parent, name, ... }, resultlist)
			=>
			ancestors' (parent, name ! resultlist);
		end;
	    end;


	# Turn logging on for a logtree node and its descendents:
	#
	enable
	    =
	    for_all
		(fn (LOGTREE_NODE { logging, ... } )
		    =
		    logging := TRUE);


	# Turn logging off for a logtree node and its descendents:
	#
	disable
	    =
	    for_all
		(fn (LOGTREE_NODE { logging, ... } )
		    =
		    logging := FALSE);


	# Turn logging on for a node (but not for its descendents):
	#
	fun enable_node (LOGTREE_NODE { logging, ... } )
	    =
	    logging := TRUE;


	# Return TRUE if this node is being logged
	#
	fun am_logging (LOGTREE_NODE { logging, ... } )
	    =
	    *logging;



	standardlib_logging
	    =
	    make_logtree_leaf
	      { parent => all_logging,
		name   => "standardlib::logging"
	      };
	#
					    my _ = 
	enable  standardlib_logging;

	compiler_logging
	    =
	    make_logtree_leaf
	      { parent => all_logging,
		name   => "compiler::logging"
	      };
	#
					    my _ = 
	enable  compiler_logging;



	# Return a list of the registered
	# nodes dominated by the given
	# module, and their status.
	#
	fun subtree_nodes_and_log_flags  root
	    =
	    reverse (list (root, []))
	    where
		fun list (tm as LOGTREE_NODE { logging, children, ... }, l)
		    =
		    list_children (*children, (tm, *logging) ! l)

		also
		fun list_children ([], l) => l;
		    list_children (c ! r, l) => list_children (r, list (c, l));
		end;
	    end;

	# As an interactive convenience,
	# print complete logtree indented:
	#
	fun print_logtree ()
	    =
	    print_logtree' ([all_logging], 0)
	    where
		fun print_indent 0 => ();
		    print_indent i => { print "    "; print_indent (i - 1); };
		end;
		#
		fun print_logtree' ((LOGTREE_NODE { name, logging, children, ... }) ! rest, indent)
			=>
			{   print_indent indent;

			    print (*logging ?? "TRUE   " :: "FALSE  ");
			    print name;
			    print "\n";

			    print_logtree' (*children, indent+1);

			    print_logtree' (rest, indent);
			};

		    print_logtree' ([], _)
			=>
			();
		end;
	    end;


	# NOTE: There are bookkeeping bugs when
	# changing the log destination from
	# LOG_TO_STREAM to something else
	# (where the original destination 
	# was LOG_TO_FILE).        XXX BUGGO FIXME
	#
	stipulate

	    lines_printed = REF 0;

	    # Extract the unix Int file descriptor
	    # from a Output_Stream -- this is
	    # a bit like pulling teeth:
	    #
	    fun outstream_to_fd  stream						# file		is from   src/lib/std/src/posix/file.pkg
		=								# text_base_io	is from   src/lib/std/src/io/text-base-io.pkg
		{   purestream =  get_outstream  stream;
		    #
		    (pio::get_writer  purestream)
			->
		        (writer, _);

		    fd =    case writer
				#
				text_base_io::WRITER { io_descriptor => THE iod, ... } =>  iod;
				_ => raise exception FAIL "logger.pkg: No iod in stream?!";
			    esac:	Int;	

		    fd;
		};		

	herein
	    #
	    fun logprint  message
		=
		{   fun write' stream
			=	
			{    # Leave every fourth line blank for readability:
			     #
			     if (*lines_printed & 3 == 0)
				 #
				 write (stream, "\n");
			     fi;
			     lines_printed := 1 + *lines_printed;

			     write (stream, message);

			     flush stream;
			};

										    # date		is from   src/lib/std/src/date.pkg
										    # time		is from   src/lib/std/types-only/basis-time.pkg
		    case (logger_is_set_to ())
			#
			LOG_TO_NULL    =>   ();
			#
			LOG_TO_STDOUT        =>  write'  stdout;
			LOG_TO_STDERR        =>  write'  stderr;
			LOG_TO_STREAM stream =>  write'  stream;
			#
			LOG_TO_FILE filename
			    =>
			    {   to  =   {   logfile_is_new =  not (exists  filename);
					    #
					    stream = open_for_append  filename;
					    #
					    fd =  outstream_to_fd  stream;
					    #
					    internet_socket::set_printif_fd  fd;	# Enable C-level log_if()s to this log.

					    if logfile_is_new				# There is a race condition here, but the worst that can happen is that
						#					# we wind up with two logfile headers instead of one, possibly interleaved.
						#					# Even then, the actual logfile entries will be uncorrupted.
						#
						write (stream, "# (fd==" + (int::to_string fd) + ") This is a log created " + (date::strftime "%Y-%m-%d:%H:%M:%S" (date::from_time_local (time_guts::get_current_time_utc()))) + " by:\n");
						write (stream, "# \n");
						write (stream, "#     src/lib/src/lib/thread-kit/src/lib/logger.pkg\n");
						write (stream, "# \n");
						write (stream, "# log_if line fields are:\n");
						write (stream, "# \n");
						write (stream, "#     time:           Timestamp in seconds\n");
						write (stream, "#     pid:            Kernel process id for logging process.\n");
						write (stream, "#     tid:            Thread id for logging thread.\n");
						write (stream, "#     name:           Thread name. (Assigned by application programmer.)\n");
						write (stream, "#     (no tag)        Arbitrary logged text.\n");
						write (stream, "#     (foo::logging): Finest-grain switch to dis/able logging of the message.\n");
						write (stream, "# \n");
						write (stream, "# You can suppress such a message via:   logger::disable foo::logging\n");
						write (stream, "# You can reenable such a message via:   logger::enable  foo::logging\n");
						write (stream, "# You can enable all the messages via:   logger::enable  file::all_logging\n");
						write (stream, "# \n");
						write (stream, "# If the package is not visible (or does not export its logswitch) you can use\n");
						write (stream, "# \n");
						write (stream, "#     logger::find_logtree_node_by_name\n");
						write (stream, "# \n");
						write (stream, "# to get its logswitch, for example\n");
						write (stream, "# \n");
						write (stream, "#     logger::enable  (the (file::find_logtree_node_by_name \"foo::logging\"));\n");
						write (stream, "# \n");
						write (stream, "# \n");
						write (stream, "# If you cannot access the logger package (e.g., because of the package-graph acyclicity constraint)\n");
						write (stream, "# you can substitute file::enable for logger::enable (etc).\n");
						write (stream, "# \n");
						write (stream, "# See also:  Comments in src/lib/src/lib/thread-kit/src/lib/logger.api\n");
						write (stream, "\n");
						write (stream, "\n");
						write (stream, "\n");
					    fi;

					    # Closing the logfile at shutdown seems
					    # at first blush like the tidy and proper thing
					    # to do, but in practice it seems a dubious idea:
					    #	
					    #   o The exact order of events such as cleanup calls
					    #     during shutdown is not well-defined, so we may
					    #     easily wind up trying to log stuff after
					    #     the log has already been closed.
					    #	
					    #   o Unix will close all open files at program exit()
					    #     anyhow, and since we're doing unbuffered I/O on
					    #     the log fd, there is not even any buffer
					    #     flushing needing to be done.
					    #	
					    # In short, there seems to be a significant downside to
					    # closing the stream at SHUTDOWN but no upside to speak
					    # of, so	I've commented it out.  Note that caller can
					    # always close the log manually if desired by calling
					    # 
					    #     set_logger_to LOG_TO_STDERR
					    #
					    # or such, thus implicitly closing the file.	
					    #
					    #                              -- 2010-02-26 CrT
					    #	
					    # logger_cleanup
					    #	  :=
					    #	  (fn () = close_output  stream);

					    LOG_TO_STREAM stream;
					}
					except					# threakit_debug	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit-debug.pkg
					    _ = {   print ( "logging: Unable to open \""
							  + filename
							  + "\" redirecting to stdout"
							  );

						    LOG_TO_STDOUT;
						};

				set_logger_to to;

				logprint  message;
			    };
		     esac;

		};
	end;			# stipulate

	stipulate
	    fun drop_leading_whitespace  string
		=
		if (str::length string == 0
		or  not (stc::is_space( string, 0)))
		    #
		    string;
		else
		    str::implode (drop_leading_whitespace' (str::explode  string))
		    where
			fun drop_leading_whitespace' (charlist as (c ! rest))
				=>
				if (char::is_space c)   drop_leading_whitespace' rest;
				else			charlist;    
				fi;

			    drop_leading_whitespace' [] =>   [];
			end;
		    end;
		fi;

	herein

	    #
	    fun make_logstring (LOGTREE_NODE { name, ... },  make_message_string_fn)
		=	
		{
		    # Construct the 'log_if' string to print,
		    # and then pass it to the log imp.
		    #
		    # The point of constructing the string here,
		    # rather than in the  log_if  call, is that
		    # this way we avoid the work of creating it
		    # if we're not going to print it (i.e., if
		    # logging is disabled for that call).
		    #
		    # NB: The line format we generate here should
		    # stay synched with that of the make_logstring in
		    #
		    #     src/lib/src/lib/thread-kit/src/lib/logger.pkg
		    #


		    # NB: If you change the time_string content/format you
		    #     should probably make corresponding changes in log_if in
		    #
		    #         src/c/main/error-reporting.c
		    #     and
		    # 	  src/lib/src/lib/thread-kit/src/lib/logger.pkg

		    # Get pid and left-pad with zeros to width 8:				# The intention is that 
		    #										# 
		    #
		    pid = psx::get_process_id ();						# We don't have access to sprintf() in this library, 
		    pid = int::to_string pid;							# so we do   sprintf "%8d" pid   by hand.
		    pid = ns::pad_left '0' 8 pid;

		    ptid = pth::get_pthread_id();
		    ptid = int::to_string ptid;
		    ptid = ns::pad_left '0' 8 ptid;

    #               time_string  =  date::strftime "%Y-%m-%d:%H:%M:%S" (date::from_time_local (time_guts::get_current_time_utc()));		# "2010-01-05:14:17:23" or such.
		    time_string  =  time_guts::format 6 (time_guts::get_current_time_utc());						# "1262722876.273621"   or such.

		    message_string =  drop_leading_whitespace (make_message_string_fn ());


		    # The intent here is
		    #
		    #   1) That doing unix 'sort' on a logfile will do the right thing:
		    #      sort first by time, then by process id, then by thread id.
		    #
		    #   2) To facilitate egrep/perl processing, e.g. doing stuff like
		    #            egrep 'pid=021456' logfile
		    #
		    # We fill in dummy tid= and (thread) name= values here to reduce
		    # the need for special-case code when processing logfiles:
		    #
		    logstring =  "time=" + time_string
			      +  " pid=" + pid
			      +  " ptid=" + ptid
			      +  " tid=00000000 name=" + (ns::pad_right ' ' 16 "none")
			      +  " " + message_string
			      +  "    \t(" + name + ")\n"
			      ;

		    logstring;
		};

	    #
        end;

	fun log_if (logtree_node as LOGTREE_NODE { logging, name, ... })  make_message_string_fn
	    =
	    if (*logging)
		    #
		    logprint  (make_logstring  (logtree_node, make_message_string_fn));
		    ();
	    fi;



    ######### BEGIN INTERPOLATED 'say.pkg' STUFF #######################3

	fun log  make_message_string_fn
	    =
	    {
		log_if  compiler_logging  make_message_string_fn;
	    };

	fun say  make_message_string_fn
	    =
	    {   print (make_message_string_fn ()  +  "\n");
		flush  stdout;

		log  make_message_string_fn;
	    };

    ######### END   INTERPOLATED 'say.pkg' STUFF #######################3


    };				# generic package file_g 
end;


## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.







##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"				 	 #
# End:									 #
##########################################################################

