## winix-base-file-io-driver-for-os.api
#
# Here we define the base interface between the platform-independent
# and the platform-dependent layers of our file I/O stack.
#
# The platform-dependent layer implements this interface,
# the platform-independent layer is built atop this interface.
#
# An extended version of this api is defined in
#
#     src/lib/std/src/io/winix-extended-file-io-driver-for-os.api
#
# The api for the next layer up is defined by
#
#     src/lib/std/src/io/file-io.api
#
# This api is designed for monothreaded code,
# so threadkit defines a replacement api:
#
#     src/lib/std/src/io/threadkit-winix-base-file-io-driver-for-os.api
#
# For additional overview and background see bottom-of-file comments.

# Compiled by:
#     src/lib/std/src/standard-core.sublib

# Included by:
#     src/lib/std/src/io/winix-extended-file-io-driver-for-os.api

stipulate
    package wt  =  winix_types;				# winix_types		is from   src/lib/std/src/posix/winix-types.pkg
herein

    # This api is implemented by:
    #
    #     src/lib/std/src/io/winix-base-file-io-driver-for-posix-g.pkg
    #
    api Winix_Base_File_Io_Driver_For_Os {
	#
	Element;
	Vector;
	Vector_Slice;
	Rw_Vector;
	Rw_Vector_Slice;

	eqtype File_Position;

	compare:  (File_Position, File_Position) -> Order;

	Filereader
	    =
	    FILEREADER
	      {
		name:        String, 
		chunk_size:  Int,

		# Read methods.  Any given READER is allowed to
		# omit some (which? all??) methods, in which case
		# that field will be NULL:
		#
		read_vector:                Null_Or( Int -> Vector ),				# Read up to 'Int' elements from the stream and return them packed in a fresh read-only vector.
		read_vector_nonblocking:    Null_Or( Int -> Null_Or( Vector ) ),		# Same, but return NULL immediately if no input is available at the moment.
		#
		read_rw_vector:             Null_Or( Rw_Vector_Slice -> Int ),			# Read into given rw_vector_slice, return number of elements read.
		read_rw_vector_nonblocking: Null_Or( Rw_Vector_Slice -> Null_Or( Int ) ),	# Same, but return NULL immediately if no input is available at the moment.

		block:            Null_Or( Void -> Void ),
		can_read:         Null_Or( Void -> Bool ),
		avail:            Void -> Null_Or( Int ),					# Return number of stream elements which can be read without blocking (if known) else NULL.

		get_position:     Null_Or( Void -> File_Position ),
		set_position:     Null_Or( File_Position -> Void ),
		#
		end_position:     Null_Or( Void -> File_Position ),
		verify_position:  Null_Or( Void -> File_Position ),

		close:            Void -> Void,
		io_descriptor:    Null_Or( wt::io::Io_Descriptor )
	      };

	Filewriter
	    =
	    FILEWRITER
	      {
		name:          String,
		chunk_size:    Int,

		# Write methods.  Any given FILEWRITER is allowed to
		# omit some (which? all??) methods, in which case
		# that field will be NULL:
		#
		write_vector:                 Null_Or( Vector_Slice    -> Int ),		# Write elements from given read-only slice, return number written.
		write_vector_nonblocking:     Null_Or( Vector_Slice    -> Null_Or( Int ) ),	# Same, but return NULL immediately if writing would otherwise block.
		#
		write_rw_vector:              Null_Or( Rw_Vector_Slice -> Int ),		# Write elements from given read-write slice, return number written.
		write_rw_vector_nonblocking:  Null_Or( Rw_Vector_Slice -> Null_Or( Int ) ),	# Same, but return NULL immediately if writing would otherwise block.

		block:              Null_Or( Void -> Void ),
		can_output:         Null_Or( Void -> Bool ),

		get_position:       Null_Or( Void -> File_Position  ),
		set_position:       Null_Or( File_Position  -> Void ),
		end_position:       Null_Or( Void -> File_Position  ),
		verify_position:    Null_Or( Void -> File_Position  ),

		close:              Void -> Void,
		io_descriptor:      Null_Or( wt::io::Io_Descriptor )
	      };
		#
		# Filewriter instances are created in:
		#
		#     src/lib/compiler/back/low/library/string-out-stream.pkg
		#     src/lib/std/src/posix-1003.1b/posix-io.pkg

	 open_vector:  Vector -> Filereader;

	 null_reader:  Void -> Filereader;
	 null_writer:  Void -> Filewriter;

	 augment_reader:  Filereader -> Filereader;
	 augment_writer:  Filewriter -> Filewriter;

    };
end;

########################################################################################
#                                Background and overview
#
# The purpose of this file is to define a standard api
# to file read/write services, so as to decouple clients
# of those services from implementations of them.
#
# In particular, by adopting a record-of-functions style
# api, we allow runtime substitution of different I/O
# implementations, just by passing in a different
# FILEREADER or FILEWRITER implementation.
#
# The API defined here was designed with single-threaded
# operation in mind, so the threadkit defines a separate version:
#
#     src/lib/std/src/io/threadkit-winix-base-file-io-driver-for-os.api
#
# The api we define here gets implemented in the generic
#
#     src/lib/std/src/io/winix-base-file-io-driver-for-posix-g.pkg
#
# which then gets specialized to "text" I/O vs "binary" I/O
# (a distinction largely irrelevant on Linux/Unix, but needed
# to humor end-of-line handling on Windows and MacOS) on a
# platform-specific basis, which on linux is:
#
#     src/lib/std/src/io/text-file-io-driver-for-posix.pkg
#     src/lib/std/src/io/binary-file-io-driver-for-posix.pkg
#
# From the client's point of view, the main difference between
# the two is that  the 'text' version treats files as streams of
# Char values, but the 'binary' version treats files as streams of
# eight-bit unsigned int values.

## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
