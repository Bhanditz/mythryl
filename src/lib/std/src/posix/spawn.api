## spawn.api	-- high-level api for spawning unix child processes.

# Compiled by:
#     src/lib/std/src/standard-core.sublib



# An API for running subprocesses which is richer than
# the portable one provided by Winix_Process in
#
#     src/lib/std/src/winix/winix-process.api
#
# but simpler than the raw Posix api provided by Posix_Process in
#
#     src/lib/std/src/posix-1003.1b/posix-process.api 

# This API is implemented in:
#     src/lib/std/src/posix/spawn.pkg

api Spawn {

    Process(X,Y);

    Signal;

    Exit_Status
      = W_EXITED
      | W_EXITSTATUS one_byte_unt::Unt
      | W_SIGNALED   Signal
      | W_STOPPED    Signal
      ;

    from_status
	:
        winix_types::process::Status
        ->
        Exit_Status;

    # spawn::process (path, args) is the vanilla call to
    # start up a subprocess:
    #
    process
	:
	( String,			# executable -- "/usr/bin/foo" or such.
          List(String)			# Remaining arguments for executable.
        )
        ->
        Process(X,Y);

    # spawn::process_in_environment (executable, args, env)
    # is the same as spawn::process except that we also specify
    # the complete Unix environment for the subprocess.
    #
    #   forks/execs new process running 'executable'.
    #   The new process will have environment env, and
    #   arguments args prepended by the last arc in 'executable'
    #   (following the Unix convention that the first argument
    #   is the command name).
    #   Returns an abstract type Process(X,Y) which represents
    #   the child process plus streams attached to
    #   the child process stdin/stdout.
    #
    #   Simple command searching can be obtained by using
    #     spawn::process_in_environment ("/bin/sh", "-c" . args, env)
    #
    process_in_environment
	:
        ( String,			# executable -- "/usr/bin/foo" or such.
          List(String),			# Remaining arguments for executable.
          List(String)			# Unix environment, for example [ "LOGNAME=cynbe", "SHELL=/bin/tcsh", "HOME=/pub/home/cynbe" ]
        )
        ->
        Process(X,Y);

    bash: String -> String;

    # *{ In, Out } streams_of proc
    # returns an Input_Stream and Output_Stream used to read
    # from and write to the stdout and stdin of the 
    # spawned process.
    #
    # The underlying files are set to be close-on-exec.

    txt_instream_of:    Process(      file::Input_Stream, X ) ->      file::Input_Stream;
    bin_instream_of:    Process( binary_io::Input_Stream, X ) -> binary_io::Input_Stream;

    txt_outstream_of:   Process( X,      file::Output_Stream ) ->      file::Output_Stream;
    bin_outstream_of:   Process( X, binary_io::Output_Stream ) -> binary_io::Output_Stream;

    streams_of
        :
        Process
          ( file::Input_Stream,
            file::Output_Stream
          )
        ->
        { from_stream:  file::Input_Stream,
          to_stream:    file::Output_Stream
        };

    reap:  Process(X,Y) -> winix_types::process::Status;
	#
	# Closes the associated streams and wait for the
	# child process to finish, then return its exit status.
	#
	# Note that even if the child process has already exited,
	# so that reap returns immediately,
	# the parent process should eventually reap it. Otherwise,
	# the process will remain a zombie and take a slot in the
	# process table.

    # kill (proc, signal)
    # sends the Posix signal to the associated process.

    kill:  (Process(X,Y), Signal) -> Void;

    exit:  one_byte_unt::Unt -> X;
};


# SML/NJ calls this file/package 'Unix'


## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
