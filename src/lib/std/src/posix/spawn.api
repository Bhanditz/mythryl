## spawn.api	-- high-level api for spawning unix child processes.

# Compiled by:
#     src/lib/std/src/standard-core.sublib



# An API for running subprocesses which is richer than
# the portable one provided by Winix_Process in
#
#     src/lib/std/src/winix/winix-process.api
#
# but simpler than the raw Posix api provided by Posix_Process in
#
#     src/lib/std/src/posix-1003.1b/posix-process.api 

# This API is implemented in:
#     src/lib/std/src/posix/spawn.pkg

stipulate
    package bio =  binary_io;									# binary_io		is from   src/lib/std/src/posix/binary-io.pkg
    package fil =  file;									# file			is from   src/lib/std/src/posix/file.pkg
    package u1b =  one_byte_unt;								# one_byte_unt		is from   src/lib/std/one-byte-unt.pkg
    package wt  =  winix_types;									# winix_types		is from   src/lib/std/src/posix/winix-types.pkg
herein												# winix_types		is from   src/lib/std/src/win32/winix-types.pkg

    api Spawn {
	#
	Process(X,Y);

	Signal;

	Exit_Status
	  #
	  = W_EXITED
	  | W_EXITSTATUS u1b::Unt
	  | W_SIGNALED   Signal
	  | W_STOPPED    Signal
	  ;

	from_status
	    :
	    wt::process::Status
	    ->
	    Exit_Status;

	# spawn_process (path, args) is the vanilla
	# call to start up a program in a subprocess:
	#
	spawn_process
	    :
	    ( String,				# executable -- "/usr/bin/foo" or such.
	      List(String)			# Remaining arguments for executable.
	    )
	    ->
	    Process(X,Y);

	fork_process:	Void -> Null_Or( Process(X,Y) );
	    #
	    # fork_process is basically just a spawn_process()
	    # that doesn't do an exece(), so we wind up with the
	    # subprocess being a clone of ourself.
	    #
	    # The child  sees a NULL return value,
	    # the parent sees a (THE process) return value:
	    #
	    # For a lower-level (essentially unix-level) fork() call see
	    #
	    #     src/lib/std/src/posix-1003.1b/posix-process.api
	    #     src/lib/std/src/posix-1003.1b/posix-process.pkg

	spawn_process_in_environment
	    :
	    ( String,				# executable -- "/usr/bin/foo" or such.
	      List(String),			# Remaining arguments for executable.
	      List(String)			# Unix environment, for example [ "LOGNAME=cynbe", "SHELL=/bin/tcsh", "HOME=/pub/home/cynbe" ]
	    )
	    ->
	    Process(X,Y);
	    #
	    # spawn_process_in_environment (executable, args, env)
	    # is the same as spawn_process except that we also specify
	    # the complete Unix environment for the subprocess.
	    #
	    #
	    #
	    # forks/execs new process running 'executable'.
	    # The new process will have environment env, and
	    # arguments args prepended by the last arc in 'executable'
	    # (following the Unix convention that the first argument
	    # is the command name).
	    # Returns an abstract type Process(X,Y) which represents
	    # the child process plus streams attached to
	    # the child process stdin/stdout.
	    #
	    # Sample call:
	    #
	    #   new_process
	    #       =
	    #       spawn_process_in_environment
	    #         (
	    #	    "/usr/bin/foo",							# Process to run.
	    #           [ "-x", "this", "that" ],						# argv for process. ("foo" will be prepended.)
	    #	    [ "LOGNAME=cynbe", "SHELL=/bin/tcsh", "HOME=/pub/home/cynbe" ]	# Environment for child process.
	    #	  );
	    #
	    # Simple command searching can be obtained by using
	    #     spawn_process_in_environment ("/bin/sh", "-c" . args, env)

	

	bash: String -> String;

	# *{ In, Out } streams_of proc
	# returns an Input_Stream and Output_Stream used to read
	# from and write to the stdout and stdin of the 
	# spawned process.
	#
	# The underlying files are set to be close-on-exec.

	txt_instream_of:    Process( fil::Input_Stream,  X ) ->  fil::Input_Stream;
	bin_instream_of:    Process( bio::Input_Stream,  X ) ->  bio::Input_Stream;

	txt_outstream_of:   Process( X, fil::Output_Stream ) ->  fil::Output_Stream;
	bin_outstream_of:   Process( X, bio::Output_Stream ) ->  bio::Output_Stream;

	streams_of
	    :
	    Process
	      ( fil::Input_Stream,
		fil::Output_Stream
	      )
	    ->
	    { from_stream:  fil::Input_Stream,
	      to_stream:    fil::Output_Stream
	    };

	reap:  Process(X,Y) -> wt::process::Status;
	    #
	    # Closes the associated streams and wait for the
	    # child process to finish, then return its exit status.
	    #
	    # Note that even if the child process has already exited,
	    # so that reap returns immediately,
	    # the parent process should eventually reap it. Otherwise,
	    # the process will remain a zombie and take a slot in the
	    # process table.

	# kill (proc, signal)
	# sends the Posix signal to the associated process.

	kill:  (Process(X,Y), Signal) -> Void;

	exit:  u1b::Unt -> X;
    };
end;

# SML/NJ (unhelpfully) calls this file/package 'Unix'


## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
