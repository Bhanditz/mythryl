## spawn.pkg	-- high-level support for spawning unix child processes.

# Compiled by:
#     src/lib/std/src/standard-core.sublib


# See comments in spawn.api



###                  "Waiting is a very funny activity:
###                   you can't wait twice as fast."
###
###                                 -- E.J. Dijkstra

stipulate
    package bio =  binary_io;				# binary_io		is from   src/lib/std/src/posix/binary-io.pkg
    package fil =  file;				# file			is from   src/lib/std/src/posix/file.pkg
    package ps  =  posix_signal;			# posix_signal		is from   src/lib/std/src/posix-1003.1b/posix-signal.pkg
    package pe  =  posix_1003_1b;			# posix_1003_1b		is from   src/lib/std/src/posix-1003.1b/posix-1003-1b.pkg
    package pf  =  posix_1003_1b;			# posix_1003_1b		is from   src/lib/std/src/posix-1003.1b/posix-1003-1b.pkg
    package pio =  posix_1003_1b;			# posix_1003_1b		is from   src/lib/std/src/posix-1003.1b/posix-1003-1b.pkg
    package psx =  posix_1003_1b;			# posix_1003_1b		is from   src/lib/std/src/posix-1003.1b/posix-1003-1b.pkg
    package rs  =  runtime_signals;			# runtime_signals	is from   src/lib/std/src/nj/runtime-signals.pkg
    package sst =  substring;				# substring		is from   src/lib/std/src/substring.pkg
    package u1b =  one_byte_unt_guts;			# one_byte_unt_guts	is from   src/lib/std/src/one-byte-unt-guts.pkg
    package wt  =  winix_types;				# winix_types		is from   src/lib/std/src/posix/winix-types.pkg
herein

    package   spawn
    : (weak)  Spawn					# Spawn			is from   src/lib/std/src/posix/spawn.api
    {
	Signal = ps::Signal;

	Exit_Status == psx::Exit_Status;

	Stream( A_stream )
	  #
	  = UNOPENED  pio::File_Descriptor
	  |   OPENED  { stream: A_stream,
			close: Void -> Void
		      }
	  ;

	Process_Status
	  #
	  = ALIVE  psx::Process_Id
	  | DEAD  { status:	wt::process::Status,
		    process_id:	psx::Process_Id
		  }
	  ;

	Process (A_input_stream, A_output_stream)
	    =
	    PROCESS
	      { commandname:  String,					# If commandpath was "/bin/sh", "commandname" will be "sh".
		from_stream:  Ref( Stream( A_input_stream  ) ),
		to_stream:    Ref( Stream( A_output_stream ) ),
		status:       Ref( Process_Status )
	      };

	from_status
	    =
	    psx::from_status;

	fun protect f x
	    =
	    {   rs::mask_signals rs::MASK_ALL;

		y = (f x)
		    except
			ex =  { rs::unmask_signals  rs::MASK_ALL;
				raise exception ex;
			      };

		rs::unmask_signals rs::MASK_ALL;

		y;
	    };

	fun fd_text_reader (name:  String, fd:  pio::File_Descriptor)
	    =
	    posix_text_base_io::make_reader
	      {
		blocking_mode => TRUE,
		name,
		fd
	      };

	fun fd_bin_reader (name:  String, fd:  pio::File_Descriptor)
	    =
	    posix_binary_base_io::make_reader
	      {
		name,
		fd,
		blocking_mode => TRUE
	      };

	fun fd_text_writer (name, fd)
	    =
	    posix_text_base_io::make_writer
	      {
		name,
		fd,
		append_mode   =>  FALSE,
		blocking_mode =>  TRUE,
		chunk_size    =>  4096
	      };

	fun fd_bin_writer (name, fd)
	    =
	    posix_binary_base_io::make_writer
	      {
		fd,
		name,
		append_mode   =>  FALSE,
		blocking_mode =>  TRUE,
		chunk_size    =>  4096
	      };

	fun open_txt_out_fd (name, fd)
	    =
	    fil::make_outstream (
		fil::pure_io::make_outstream (
		fd_text_writer (name, fd), io_exceptions::BLOCK_BUFFERING)
	    );

	fun open_bin_out_fd (name, fd)
	    =
	    bio::make_outstream (
		bio::pure_io::make_outstream (
		    fd_bin_writer (name, fd),
		    io_exceptions::BLOCK_BUFFERING
		)
	    );

	fun open_txt_in_fd (name, fd)
	    =
	    fil::make_instream (
		fil::pure_io::make_instream (
		    fd_text_reader (name, fd),
		    ""
		)
	    );

	fun open_bin_in_fd (name, fd)
	    =
	    bio::make_instream (
		bio::pure_io::make_instream (
		    fd_bin_reader (name, fd),
		    byte::string_to_bytes ""
		)
	    );

	fun stream_of (stream_selector, sfx, opener, closer) (PROCESS p)
	    =
	    case (stream_selector p)
		#          
		REF (OPENED s)
		    =>
		    s.stream;
		#
		r as REF (UNOPENED fd)
		    =>
		    {   s = opener ( p.commandname + "_ext_" + sfx,
				     fd
				   );

			r := OPENED { stream =>  s,
				      close  =>  fn () = closer s
				    };
			s;
		    };
	    esac;

	fun get_text_input_stream_from   p =  stream_of (.from_stream,  "txt_in",  open_txt_in_fd,  fil::close_input )  p;
	fun get_binary_input_stream_from   p =  stream_of (.from_stream,  "bin_in",  open_bin_in_fd,  bio::close_input )  p;

	fun get_text_output_stream_to  p =  stream_of (.to_stream,    "txt_out", open_txt_out_fd, fil::close_output)  p;
	fun get_binary_output_stream_to  p =  stream_of (.to_stream,    "bin_out", open_bin_out_fd, bio::close_output)  p;

	fun streams_of p
	    =
	    {  from_stream =>  get_text_input_stream_from  p,
	       to_stream   =>  get_text_output_stream_to p
	    };


	# Joe Wells suggests that it would be useful to optionally allow the subprocess to inherit
	# one or more of stdin/stdout/stderr instead of always converting them to pipes to us.
	# 
	# This suggests that instead of 
	# 
	#    spawn_process_in_environment
	#	:
	#	( String,			# executable -- "/usr/bin/foo" or such.
	#	  List(String),			# Remaining arguments for executable.
	#	  List(String)			# Unix environment, for example [ "LOGNAME=cynbe", "SHELL=/bin/tcsh", "HOME=/pub/home/cynbe" ]
	#	)
	#	->
	#	Process(X,Y);
	# 
	# we should instead have something like
	# 
	#    Spawn_Arg
	#      #
	#      = ENVIRONMENT  List(String)	# Specify unix environmet for child.  If not specified, pe::environ() is used.
	#      | STDIN	 psx::File_Descriptor	# Specify stdin  for child; making it file::stdin  leaves it unchanged. If not supplied, normal parent<->child pipe construction is done.
	#      | STDOUT	 psx::File_Descriptor	# Specify stdout for child; making it file::stdout leaves it unchanged. If not supplied, normal parent<->child pipe construction is done.
	#      | COMMAND (String, List(String)	# Specify executable and arguments for it.  If not supplied, we do a fork() but no exec().
	#      ;
	#
	#    spawn_process'
	#	:
	#	List( Spawn_Arg )
	#	->
	#	Process(X,Y);
	#    

# src/lib/std/src/posix-1003.1b/posix-file.api
#    eqtype File_Descriptor;
#    fd_to_int:     File_Descriptor -> host_int::Int;
#    int_to_fd:     host_int::Int -> File_Descriptor;

# src/lib/std/src/posix-1003.1b/posix-file.pkg
#    File_Descriptor = host_int::Int;
#    fun fd_to_int  fd = fd;


# src/lib/std/src/posix-1003.1b/posix-io.pkg
#	my pipe' : Void -> (Sy_Int, Sy_Int) =  cfun "pipe";				# pipe		def in    src/c/lib/posix-io/pipe.c
#	#
#	fun pipe ()
#	    =
#	    {   my (ifd, ofd) =   pipe' ();
#		#
#		{ infd  =>  fs::int_to_fd  ifd,
#                  outfd =>  fs::int_to_fd  ofd
#                };
#	    };


	stipulate
	    fun fork_process' ()
		=
		{   fil::flush  fil::stdout;									# Avoid anomalies due to pending output being duplicated between parent and child processes.
		    #
		    p0 = pio::pipe ();
		    p1 = pio::pipe ();

		    fun closep ()
			=
			{   pio::close  p0.outfd;	pio::close  p0.infd;
			    pio::close  p1.outfd;	pio::close  p1.infd;
			};

		    case (protect psx::fork ())
			#                  
			THE pid =>
			    {   # We're the parent process:
				#
				infd  =  p1.infd;
				outfd =  p0.outfd;

				# Close the child-side fds:
				#
				pio::close p1.outfd;
				pio::close p0.infd;

				# Set the fds close on exec:
				#
				pio::setfd  (p1.infd,   pio::fd::flags  [pio::fd::cloexec]);
				pio::setfd  (p0.outfd,  pio::fd::flags  [pio::fd::cloexec]);

				THE (pid, infd, outfd);
			    };
			#
			NULL =>
			    {   # We're the child process:
				#
				oldin  = p0.infd;	newin  = psx::int_to_fd  0;					# An fd is still an int internally.
				oldout = p1.outfd;	newout = psx::int_to_fd  1;

				pio::close  p0.outfd;
				pio::close  p1.infd;

				# Make our input fd be 0 per unix stdin/stdout/stderr convention:
				#
				if (oldin != newin)
				    #
				    pio::dup2 { old => oldin,							# Make fd 0 ("stdin") be a copy of fd for our input pipe from parent.
						new => newin
					      };
				    pio::close oldin;								# With input pipe now safely ensconced in fd 0, close the now-unneeded original fd for that pipe.
				fi;

				# Make our output fd be 1 per unix stdin/stdout/stderr convention:
				#
				if (oldout != newout)
				    #
				    pio::dup2 { old => oldout,							# Make fd 1 ("stdout") be a copy of fd for our output pipe to parent.
						new => newout
					      };
				    pio::close oldout;								# With output pipe now safely ensconced in fd 1, close the now-unneeded original fd for that pipe.
				fi;

				NULL;
			    };
		    esac
		    except
			ex = {   closep();
				 raise exception ex;
			     };
		};
	herein

	    #
	    fun fork_process ()
		=
		{   case (fork_process' ())
			#
			THE (pid, infd, outfd)
			    =>
			    # We're the parent process:
			    #
			    THE (
				PROCESS
				  {
				    commandname => "",
				    from_stream => REF  (UNOPENED infd),
				    to_stream   => REF  (UNOPENED outfd),
				    status      => REF  (ALIVE pid)
				  }
			    );

			NULL =>   NULL;					# We're the child process.
		    esac;
		};							# fun spawn_process_in_environment (commandpath, argv, env)

	    #
	    fun spawn_process_in_environment (commandpath, argv, env)
		=
		{   fun is_file      filename
			=
			psx::stat::is_file (psx::stat  filename)
			except
			    _ = FALSE;

		    fun may_execute  filename
			=
			{   include psx::s;

			    stat = psx::stat  filename;

			    all_set (flags [ ixusr ], stat.mode);	# Order of args is critical!
			};
			#
			# XXX BUGGO FIXME Checking this one bit is hardly definitive.
			#                 What does (say) Perl do?

		    if (not (is_file     commandpath))  raise exception FAIL ("spawn: No file " + commandpath + " exists."           );  fi;
		    if (not (may_execute commandpath))  raise exception FAIL ("spawn: File "    + commandpath + " is not executable.");  fi;


		    # Get bare commandname, to be arg[0]:
		    #
		    commandname						# If 'commandpath' is "/bin/sh" 'commandname' will be "sh".
			=
			sst::to_string
			    (sst::get_suffix
				(fn c =  c != '/')
				(sst::from_string commandpath)
			    );


		    case (fork_process' ())
			#
			THE (pid, infd, outfd)
			    =>
			    # We're the parent process:
			    #
			    PROCESS
			      {
				commandname,
				from_stream => REF  (UNOPENED infd),
				to_stream   => REF  (UNOPENED outfd),
				status      => REF  (ALIVE pid)
			      };

			NULL =>
			    # We're the child process:
			    #
			    psx::exece (commandpath, commandname ! argv, env);
		    esac;

		};							# fun spawn_process_in_environment (commandpath, argv, env)
	end;

	# spawn_process ( "/usr/bin/foo", [] ) 
	#								      
	fun spawn_process (executable, argv)
	    =
	    spawn_process_in_environment (executable, argv, pe::environ());


	fun kill (PROCESS { status => REF (ALIVE pid), ... }, signal)
		=>
		psx::kill (psx::K_PROC pid, signal);

	    kill _ => ();			#  raise an exception here? 
	end;





	fun reap (PROCESS { status => REF (DEAD { status, ... }), ... })
		=>
		status;

	   reap (PROCESS { status => status_ref as REF (ALIVE process_id), from_stream, to_stream, ... } )
		=>
		{
		    # 'protect' is probably too much; typically,
		    # one would only mask SIGINT, SIGQUIT and SIGHUP         XXX BUGGO FIXME
		    #
		    fun wait_proc ()
			=
			case (#2 (protect psx::waitpid (psx::W_CHILD process_id, [])))
			    #		     
			    W_EXITED                       =>  0;
			    W_EXITSTATUS           status  =>  u1b::to_int  status;
			    W_SIGNALED (ps::SIGNAL status) =>         256 + status;
			    W_STOPPED  (ps::SIGNAL status) =>         512 + status;    # This should not happen.
			esac;

		    fun close (UNOPENED fd)   =>  pio::close fd;
			close (OPENED stream) =>  stream.close ();
		    end;

		    close *from_stream;

		    close *to_stream
		    except
			_ = ();

		    status = wait_proc ();

		    status_ref :=  DEAD { status, process_id };

		    status;
		};
	end;


	fun process_id_of (PROCESS { status => REF (ALIVE process_id), ... })
		=>
		(host_unt_guts::to_int (psx::pid_to_unt process_id));

	    process_id_of (PROCESS { status => REF (DEAD { process_id, ... }), ... })
		=>
		(host_unt_guts::to_int (psx::pid_to_unt process_id));
	end;


	fun bash cmdline
	    =
	    {   child_process
		    = 
		    spawn_process ("/bin/sh", ["-c", cmdline]);

		my { from_stream, to_stream }
		    =
		    streams_of  child_process;


		fil::close_output  to_stream;

		output = fil::read_all from_stream;

		reap child_process;

		output;
	    };


	exit = psx::exit;

    };									# package spawn
									# SML/NJ calls this "unix" -- a singularly unhelpful appellation.
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
