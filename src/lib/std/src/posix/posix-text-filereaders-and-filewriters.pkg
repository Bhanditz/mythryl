## posix-text-filereaders-and-filewriters.pkg

# Compiled by:
#     src/lib/std/src/standard-core.sublib



# This implements the UNIX version of the
# OS specific text primitive IO package.
# It is implemented by a trivial translation of
# the binary operations (see posix-binary-filereaders-and-filewriters.pkg).

stipulate
    package str =  string_guts;					# string_guts			is from   src/lib/std/src/string-guts.pkg
    package int =  int_guts;					# int_guts			is from   src/lib/std/src/bind-int-32.pkg
    package pos =  file_position_guts;				# file_position_guts		is from   src/lib/std/src/bind-position-31.pkg
    package psx =  posix_1003_1b;				# posix_1003_1b			is from   src/lib/std/src/posix-1003.1b/posix-1003-1b.pkg
    #
    package binary_filereaders_and_filewriters = posix_binary_filereaders_and_filewriters;		# posix_binary_filereaders_and_filewriters		is from   src/lib/std/src/posix/posix-binary-filereaders-and-filewriters.pkg
herein

    package posix_text_filereaders_and_filewriters
    : (weak)
    api {
	include Winix_Filereaders_And_Filewriters;					# Winix_Filereaders_And_Filewriters			is from   src/lib/std/src/io/winix-filereaders-and-filewriters.api

	stdin:   Void -> filereaders_and_filewriters::Filereader;
	stdout:  Void -> filereaders_and_filewriters::Filewriter;
	stderr:  Void -> filereaders_and_filewriters::Filewriter;

	string_reader:  String -> filereaders_and_filewriters::Filereader;

    } {
        package filereaders_and_filewriters   = text_filereaders_and_filewriters;			# text_filereaders_and_filewriters			is from   src/lib/std/src/io/text-filereaders-and-filewriters.pkg

	File_Descriptor =  psx::File_Descriptor;

	buffer_size_b = 4096;

	make_filereader =  psx::make_text_reader;			# make_text_reader		def in    src/lib/std/src/posix-1003.1b/posix-io.pkg
	make_filewriter =  psx::make_text_writer;			# make_text_writer		def in    src/lib/std/src/posix-1003.1b/posix-io.pkg

	fun announce s x y
	    =
	    {
    # print "Posix: "; print (s: String); print "\n"; 
		x y;
	    };

	fun open_for_read  name
	    =
	    make_filereader
		{ fd            => announce "openf" psx::openf (name, psx::O_RDONLY, psx::o::flags []),
		  name,
		  blocking_mode => TRUE
		};

	standard_mode
	    =
	    psx::s::flags
		[	#  mode 0666 
		  psx::s::irusr, psx::s::iwusr,
		  psx::s::irgrp, psx::s::iwgrp,
		  psx::s::iroth, psx::s::iwoth
		];
								# createf			def in    src/lib/std/src/posix-1003.1b/posix-file.pkg
	fun create_file (name, mode, flags)
	    =
	    announce "createf" psx::createf (name, mode, flags, standard_mode);

	fun open_for_write  name
	    =
	    make_filewriter
		{ fd            => create_file (name, psx::O_WRONLY, psx::o::trunc),
		  name,
		  blocking_mode => TRUE,
		  append_mode   => FALSE,
		  chunk_size    => buffer_size_b
		};

	fun open_for_append  name
	    =
	    make_filewriter
		{ fd            => create_file (name, psx::O_WRONLY, psx::o::append),
		  name,
		  blocking_mode => TRUE,
		  append_mode   => TRUE,
		  chunk_size    => buffer_size_b
		};

	fun stdin ()
	    =
	    make_filereader
	      {
		fd		  => psx::stdin,
		name	  => "<stdin>",
		blocking_mode => TRUE #  Bug!  Should check!  XXX BUGGO FIXME
	      };

	fun stdout ()
	    =
	    make_filewriter
	      {
		fd		  => psx::stdout,
		name	  => "<stdout>",
		blocking_mode => TRUE,		# Bug!  Should check! XXX BUGGO FIXME
		append_mode	  => FALSE,		# Bug!  Should check! XXX BUGGO FIXME
		chunk_size	  => buffer_size_b
	      };

	fun stderr ()
	    =
	    make_filewriter
	      {
		fd		  => psx::stderr,
		name	  => "<stderr>",
		blocking_mode => TRUE,		#  Bug!  Should check! 	XXX BUGGO FIXME
		append_mode	  => FALSE,		#  Bug!  Should check!  XXX BUGGO FIXME
		chunk_size	  => buffer_size_b
	      };

	fun string_reader src
	    =
	    {
		pos = REF 0;
		closed = REF FALSE;

		fun check_closed ()
		    =
		    if  *closed    raise exception io_exceptions::CLOSED_IO_STREAM;  fi;

		len = str::length src;
		plen = pos::from_int len;

		fun avail ()
		    =
		    len - *pos;

		fun read_ro n
		    =
		    {   p = *pos;
			m = int::min (n, len-p);

			check_closed ();
			pos := p+m;
			str::substring (src, p, m);	  # Could use unchecked operations here.
		      };

		fun read_rw asl
		    =
		    {   p = *pos;

			my (buf, i, n)
			    =
			    rw_vector_slice_of_chars::base asl;

			m = int::min (n, len-p);

			check_closed ();

			pos := p+m;

			rw_vector_slice_of_chars::copy_vec
			    { from => vector_slice_of_chars::make_slice (src, p, THE m),
			      to   => buf,
			      di   => i
			    };
			m;
		    };

		fun get_position ()
		    =
		    {   check_closed();
			pos::from_int *pos;
		    };

		fun set_position p
		    =
		    {   check_closed ();

			if  (p < 0
			or   p > plen
			)
			     raise exception SUBSCRIPT;
			else
			     pos := pos::to_int p;
			fi;
		    };

		filereaders_and_filewriters::FILEREADER
		    {
		      name      => "<string>", 
		      chunk_size => len,
		      read_vector                => THE (read_ro),
		      read_rw_vector             => THE (read_rw),
		      read_vector_nonblocking    => THE (THE o read_ro),
		      read_rw_vector_nonblocking => THE (THE o read_rw),
		      block           => THE (check_closed),
		      can_read        => THE (fn () = { check_closed(); TRUE;}),
		      avail           => THE o avail,
		      get_position    => THE get_position,
		      set_position    => THE set_position,
		      end_position    => THE (fn () = { check_closed(); plen;}),
		      verify_position => THE get_position,
		      close           => fn () = closed := TRUE,
		      io_descriptor   => NULL
		    };
	      };

    }; #  posix_text_filereaders_and_filewriters 
end;



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
