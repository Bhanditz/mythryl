## xgeometry.pkg
#
# Basic geometric types and operations.
#
# The 'X' on the name is for X Windows; this
# file was originally part of x-kit, which is
# still its major user.  However, I now regard
# it as platform-independent code.
#                        -- 2014-06-27 CrT

# Compiled by:
#     src/lib/std/standard.lib


###                      "Much learning does not teach understanding."
###
###                                               -- Heraclitus  (540BC-480BC, On the Universe)


###                      "Logic will get you from A to B. Imagination will take you everywhere."
###
###                                               -- Albert Einstein


					# Xgeometry		is from   src/lib/std/2d/xgeometry.api
stipulate
    package rc = range_check;		# range_check		is from   src/lib/std/2d/range-check.pkg
herein

    package xgeometry {

	stipulate

	    fun min (col: Int, row) =   col < row  ??  col  ::  row;
	    fun max (col: Int, row) =   col > row  ??  col  ::  row;

	herein

	    # Geometric types (from xlib.h)
	    #
	    Point =   { col:  Int,
			row:  Int
		      };

	    Line =  (Point, Point);

	    Size =  { wide:  Int,
		      high:  Int
		    };

	    Box  =  { col:  Int,
		      row:  Int,

		      wide:  Int,
		      high:  Int
		    };

	    Arc  =  { col:     Int,
		      row:     Int,

		      wide:    Int,
		      high:    Int,

		      angle1:  Int,
		      angle2:  Int
		    };

	    # The size and position of a window		# XXX BUGGO FIXME This belongs in xclient, not stdlib.
	    # with respect to its parent:
	    #
	    Window_Site =   { upperleft:	Point,
			      size:		Size,
			      border_thickness:	Int
			    };

	    package point {

		# Points:
		#
		zero = { col => 0, row => 0 };

		fun col ({ col, ... }: Point) =  col;
		fun row ({ row, ... }: Point) =  row;

		fun add      ({ col=>col1, row=>row1 }, { col=>col2, row=>row2 } ) =  { col=>(col1+col2), row=>(row1+row2) };
		fun subtract ({ col=>col1, row=>row1 }, { col=>col2, row=>row2 } ) =  { col=>(col1-col2), row=>(row1-row2) };

		fun scale ({ col, row }, s ) =  { col=>s*col, row=>s*row };

		fun ne ({ col=>col1, row=>row1 }, { col=>col2, row=>row2 }) =  (col1 != col2) or  (row1 != row2);
		fun eq ({ col=>col1, row=>row1 }, { col=>col2, row=>row2 }) =  (col1 == col2) and (row1 == row2);
		fun lt ({ col=>col1, row=>row1 }, { col=>col2, row=>row2 }) =  (col1 <  col2) and (row1 <  row2);
		fun le ({ col=>col1, row=>row1 }, { col=>col2, row=>row2 }) =  (col1 <= col2) and (row1 <= row2);
		fun gt ({ col=>col1, row=>row1 }, { col=>col2, row=>row2 }) =  (col1 >  col2) and (row1 >  row2);
		fun ge ({ col=>col1, row=>row1 }, { col=>col2, row=>row2 }) =  (col1 >= col2) and (row1 >= row2);

		fun add_size ({ col, row }, { wide, high } )
		    =
		    { col =>  col + wide,
                      row =>  row + high
                    };
		#
		fun clip ({ col, row }, { wide, high })
		    =
		    { col =>  if (col <= 0)  0; elif (col < wide)  col; else (wide - 1); fi,
		      row =>  if (row <= 0)  0; elif (row < high)  row; else (high - 1); fi
		    };

		fun in_box ({ col=>px, row=>py }, { col, row, wide, high } )
		    =
		    px >=  col    and
		    py >=  row    and
		    px < col+wide and
		    py < row+high;


		# Bounding box of a list of points:
		#
		fun bounding_box []
			=>
			{ col=>0, row=>0, wide=>0, high=>0 };

		    bounding_box (({ col, row } ) ! pts)
			=>
			bb (col, row, col, row, pts)
			where
			    fun bb (minx, miny, maxx, maxy, [])
				    => 
				    { col => minx, row => miny, wide => maxx-minx+1, high => maxy-miny+1 };

				bb (minx, miny, maxx, maxy, ({ col, row } ) ! pts)
				    => 
				   bb (min (minx, col), min (miny, row), max (maxx, col), max (maxy, row), pts);
			    end;
			end;
		end;
	    };

	    package size {
		#
		fun add      ({ wide=>w1, high=>h1 }, { wide=>w2, high=>h2 } ) =  { wide=>(w1+w2), high=>(h1+h2) };
		fun subtract ({ wide=>w1, high=>h1 }, { wide=>w2, high=>h2 } ) =  { wide=>(w1-w2), high=>(h1-h2) };
		fun scale    ({ wide,     high     }, s                           ) =  { wide=>wide*s,  high=>high*s  };
		#
		fun eq       ({ wide=>w1, high=>h1 }, { wide=>w2, high=>h2 } ) =  (w1==w2 and h1==h2);
	    };

	    package box {

		fun make ({ col, row }, { wide, high } )
		    =
		    { col, row, wide, high };


		fun upperleft ({ col, row, ... }: Box)
		    =
		    { col, row };


		fun size ({ wide, high, ... }: Box)
		    =
		    { wide, high };


		fun upperleft_and_size ({ col, row, wide, high } )
		    =
		    ({ col, row }, { wide, high } );


		fun lowerright r
		    =
		    point::add_size (upperleft_and_size r);


		fun clip_point ({ col=>min_col, row=>min_row, wide, high }, { col, row } )
		    =
		    {
		      col => if (col <= min_col)  min_col; elif (col < min_col+wide)  col; else (min_col+wide - 1); fi,
		      row => if (row <= min_row)  min_row; elif (row < min_row+high)  row; else (min_row+high - 1); fi
		    };

		fun  translate ({ col, row, wide, high }, { col=>px, row=>py } ) =  { col=>col+px, row=>row+py, wide, high };
		fun rtranslate ({ col, row, wide, high }, { col=>px, row=>py } ) =  { col=>col-px, row=>row-py, wide, high };

		fun middle ({ col, row, wide, high } )
		    =
		    { col => col+(wide / 2),
		      row => row+(high / 2)
		    };

		fun intersect
			( { col=>col1, row=>row1, wide=>w1, high=>h1 },
			  { col=>col2, row=>row2, wide=>w2, high=>h2 }
			)
		    =
		    (   (col1 < (col2+w2)) and (row1 < (row2+h2))
		    and (col2 < (col1+w1)) and (row2 < (row1+h1)));

		exception INTERSECTION;

		fun intersection
			( { col=>col1, row=>row1, wide=>w1, high=>h1 },
			  { col=>col2, row=>row2, wide=>w2, high=>h2 } )
		    =
		    {   col = max (col1, col2);
			row = max (row1, row2);

			cx = min (col1+w1, col2+w2);
			cy = min (row1+h1, row2+h2);

			if (col < cx  and  row < cy)
			    #
			    { col, row, wide=>(cx-col), high=>(cy-row) };
			else
			    raise exception INTERSECTION;
			fi;
		      };

		fun union (
		      r1 as { col=>col1, row=>row1, wide=>w1, high=>h1 },
		      r2 as { col=>col2, row=>row2, wide=>w2, high=>h2 }
		    )
		    =
		    if   (w1 == 0  or  h1 == 0)    r2;
		    elif (w2 == 0  or  h2 == 0)    r1;
		    else

			col = min (col1, col2);
			row = min (row1, row2);

			cx = max (col1+w1, col2+w2);
			cy = max (row1+h1, row2+h2);

			{ col, row, wide=>(cx-col), high=>(cy-row) };
		    fi;


		fun in_box
		    ( { col=>col1, row=>row1, wide=>w1, high=>h1 },
		      { col=>col2, row=>row2, wide=>w2, high=>h2 }
		    )
		    =
		    col1 >= col2        and
		    row1 >= row2        and
		    col1+w1 <= col2+w2  and
		    row1+h1 <= row2+h2;

		fun make_nested_box
		      ( box as { col, row, wide, high }: Box,
			by:   Int
		      )
		    =
		    # Create a box nested within given box,
		    # shrunk by given number of pixels:
		    #
		    if   (by   <= 0)   box;
		    elif (high <= 2)   box;
		    elif (wide <= 2)   box;
		    else
			wide2 = wide / 2;
			high2 = high / 2;

			by = if (by > wide2)  wide2;
			     else             by;
			     fi;

			by = if (by > high2)  high2;
			     else             by;
			     fi;

			{ row => row + by,  high => high - 2*by,
			  col => col + by,  wide => wide - 2*by
			};
		    fi;



		# The symmetric difference of two sets is essentially
		# a geometric XOR operation;  it contains all elements
		# in either set but not both sets -- in other words,
		# the union minus the intersection:
		#
		#     http://en.wikipedia.org/wiki/Symmetric_difference
		#
		# Here we compute the symmetric difference of two
		# rectangles and return it as a list of rectangles:
		# 
		fun xor (r, r')
		    =
		    difference (r', r, difference (r, r',[]))
		    where
			fun difference (r as { col=>x, row=>y, wide, high }, r', result_list)
			    =
			    {   my  { col=>ix, row=>iy, wide=>iwide, high=>ihigh }		# "i-" for "intersection-".
				    =
				    intersection (r, r');

				icx = ix + iwide;		# Opposite corner of
				icy = iy + ihigh;		# intersection box.

				# (x,y) is one corner of a rectangle,
				# (cx,cy) is the opposite corner.
				#	
				# Cyclically identify all parts of the rectangle
				# which project outside the borders of the above
				# intersection rectangle, adding each of them to
				# the result list and then shrinking the argument
				# rectangle correspondingly:
				#
				fun pare (x, y, cx, cy, result_list)
				    =
				    if   (  x < ix)  pare (ix,  y,  cx,  cy, ({ col=>x,   row=>y,   high=>cy-y,   wide=>ix-x   } ) ! result_list);	# Pare off the part to the left.
				    elif (  y < iy)  pare ( x, iy,  cx,  cy, ({ col=>x,   row=>y,   high=>iy-y,   wide=>cx-x   } ) ! result_list);	# Pare off the part above. (Assuming y==0 is at top.)
				    elif (icx < cx)  pare ( x,  y, icx,  cy, ({ col=>icx, row=>y,   high=>cy-y,   wide=>cx-icx } ) ! result_list);	# Pare off the part to the right.
				    elif (icy < cy)  pare ( x,  y,  cx, icy, ({ col=>x,   row=>icy, high=>cy-icy, wide=>cx-x   } ) ! result_list);	# Pare off the part below.
				    else
					result_list;
				    fi;

				pare (x, y, x+wide, y+high, result_list);
			    }
			    except
				INTERSECTION = r ! result_list;

		    end;
	    };


	    # XXX BUGGO FIXME Remaining stuff belongs in xclient, not stdlib:

	    fun site_to_box ({ upperleft => { col, row }, size => { wide, high }, ... }: Window_Site)
		=
		{ col, row, wide, high };


	    # Validation routines:
	    #
	    fun valid_point({ col, row } )   =   rc::valid_signed16 col    and   rc::valid_signed16 row;
	    fun valid_line ((p1, p2): Line)  =       valid_point    p1     and       valid_point    p2;
	    fun valid_size ({ wide, high } ) =   rc::valid16        wide   and   rc::valid16        high;

	    fun valid_box ({ col, row, wide, high } )
		=
		rc::valid_signed16 col      and
		rc::valid_signed16 row      and 
		rc::valid16 wide            and
		rc::valid16 high;

	    fun valid_arc ({ col, row, wide, high, angle1, angle2 } )
		=
		rc::valid_signed16  col     and
		rc::valid_signed16  row     and 
		rc::valid16  wide           and
		rc::valid16  high           and 
		rc::valid_signed16  angle1  and
		rc::valid_signed16  angle2;

	    fun valid_site ({ upperleft, size, border_thickness }: Window_Site)
		= 
		valid_point  upperleft      and
		valid_size   size           and
		rc::valid16  border_thickness;

	end;		# stipulate
    };			# package geometry 

end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2014,
## released per terms of SMLNJ-COPYRIGHT.
