
generic package dotgraph_lr_vals_g(
	   #
           package token:  Token;
           package g : Traitful_Graphtree;
	   #
           make_default_graph_info:  Void -> g::Graph_Info;
           make_default_node_info :  Void -> g::Node_Info;
           make_default_edge_info :  Void -> g::Edge_Info;
         )
         { 
package parser_data{
package header { 
## dot-graph.grammar
## COPYRIGHT (c) 1994 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2015,
## released per terms of SMLNJ-COPYRIGHT.

# Parser specification for the "dot" style syntax
# defined by GraphViz.  For docs on it see:
#     http://www.graphviz.org/Documentation.php
# (The version specified here may well be a decade
# or so behind the above specifications.)

exception ERROR;

Vertex
  = NODE (String, Null_Or( String )) 
  | SUBGRAPH (g::Traitful_Graph -> g::Traitful_Graph)
  ;

# The five things we can set on Traitful_Graphs:
#
fun set_graph_trait        graph =  g::set_trait(g::GRAPH_PART     graph);
fun set_node_trait         node  =  g::set_trait(g::NODE_PART      node );
fun set_edge_trait         edge  =  g::set_trait(g::EDGE_PART      edge );
fun set_default_node_trait graph =  g::set_trait(g::PROTONODE_PART graph);
fun set_default_edge_trait graph =  g::set_trait(g::PROTOEDGE_PART graph);

fun find_subgraph (g, name)
    =
    case (g::find_subgraph (g, name))
	#
        THE sg => sg;
        NULL   => raise exception ERROR;
    esac;

stipulate
    count = REF 0;
herein
    fun anonymous ()
	=
	("_anonymous_" + (int::to_string *count))
        then
	    count := *count + 1;
end;

stipulate

    fun make_port_fn (NULL,     NULL) =>   \\ _ =  ();
        make_port_fn (THE tp,   NULL) =>   \\ e =   set_edge_trait e ("tailport",tp);
        make_port_fn (NULL,   THE hp) =>   \\ e =   set_edge_trait e ("headport",hp);
        make_port_fn (THE tp, THE hp) => { \\ e = { set_edge_trait e ("headport",hp);
                                                    set_edge_trait e ("tailport",tp);
                                                  };
                                         };
    end;

herein

    fun make_edges (vs, traits) graph
	=
        {
	    fun do_edge portfn (tail,head)
		=
		{   edge = g::make_edge { graph, head, tail, info=>NULL };
		    #
		    portfn edge;
		    #
		    apply (set_edge_trait edge) traits;
		};

	    fun mk_e (tail ! (rest as head ! l))
		    =>
		    case (tail, head)
			#
		        (NODE(t,tport), NODE(h,hport))
			    =>
			    {   do_edge (make_port_fn(tport,hport)) (g::get_or_make_node(graph,t,NULL), g::get_or_make_node(graph,h,NULL));
			        mk_e rest;
			    };

		        (NODE(name,port), SUBGRAPH mkg)
			    =>
			    {   edgefn = do_edge (make_port_fn(port,NULL));
			        t      = g::get_or_make_node(graph,name,NULL);
			        subg   = mkg graph;					# "subg" might be "subgraph"

			        g::nodes_apply (\\ n = edgefn(t,n)) subg;

		                mk_e((SUBGRAPH(\\ _ = subg)) ! l);
			    };

		        (SUBGRAPH mkg, NODE(name,port))
			    =>
			    {   edgefn =  do_edge (make_port_fn(NULL, port));
			        h      =  g::get_or_make_node(graph,name,NULL);

			        g::nodes_apply (\\ n = edgefn(n,h)) (mkg graph);

			        mk_e rest;
			    };

		        (SUBGRAPH mkg, SUBGRAPH mkg')
			    =>
			    {   edgefn = do_edge (make_port_fn(NULL, NULL));

			        tailg  = mkg  graph;
			        headg  = mkg' graph;

			        g::nodes_apply (\\ h = g::nodes_apply (\\ t = edgefn(t,h)) tailg) headg;

				mk_e((SUBGRAPH(\\ _ = headg)) ! l);
			    };
		    esac;

		mk_e _ => ();
	    end;


	    mk_e vs;

	    graph;
	};
end;


};
package lr_table = token::lr_table;
package token = token;
stipulate include package   lr_table; herein 
my table={   action_rows =
"\
\\x01\x00\x01\x00\x09\x00\x02\x00\x08\x00\x00\x00\
\\x01\x00\x03\x00\x1c\x00\x08\x00\x35\x00\x0c\x00\x18\x00\x00\x00\
\\x01\x00\x08\x00\x07\x00\x00\x00\
\\x01\x00\x08\x00\x30\x00\x00\x00\
\\x01\x00\x08\x00\x38\x00\x00\x00\
\\x01\x00\x08\x00\x3a\x00\x0e\x00\x39\x00\x00\x00\
\\x01\x00\x08\x00\x41\x00\x00\x00\
\\x01\x00\x08\x00\x45\x00\x00\x00\
\\x01\x00\x08\x00\x4b\x00\x00\x00\
\\x01\x00\x0b\x00\x49\x00\x00\x00\
\\x01\x00\x0c\x00\x0a\x00\x00\x00\
\\x01\x00\x0d\x00\x2d\x00\x00\x00\
\\x01\x00\x0f\x00\x2b\x00\x00\x00\
\\x01\x00\x0f\x00\x40\x00\x00\x00\
\\x01\x00\x0f\x00\x42\x00\x00\x00\
\\x01\x00\x10\x00\x48\x00\x00\x00\
\\x01\x00\x11\x00\x4c\x00\x00\x00\
\\x01\x00\x12\x00\x2f\x00\x00\x00\
\\x01\x00\x15\x00\x00\x00\x00\x00\
\\x4e\x00\x00\x00\
\\x4f\x00\x01\x00\x06\x00\x02\x00\x05\x00\x04\x00\x04\x00\x00\x00\
\\x50\x00\x00\x00\
\\x51\x00\x00\x00\
\\x52\x00\x00\x00\
\\x53\x00\x00\x00\
\\x54\x00\x00\x00\
\\x55\x00\x00\x00\
\\x56\x00\x00\x00\
\\x57\x00\x00\x00\
\\x58\x00\x08\x00\x3f\x00\x00\x00\
\\x59\x00\x0b\x00\x47\x00\x00\x00\
\\x5a\x00\x00\x00\
\\x5b\x00\x00\x00\
\\x5c\x00\x00\x00\
\\x5d\x00\x00\x00\
\\x5d\x00\x07\x00\x20\x00\x00\x00\
\\x5e\x00\x0d\x00\x2d\x00\x00\x00\
\\x5f\x00\x00\x00\
\\x60\x00\x01\x00\x1d\x00\x03\x00\x1c\x00\x05\x00\x1b\x00\x06\x00\x1a\x00\
\\x08\x00\x19\x00\x0c\x00\x18\x00\x00\x00\
\\x61\x00\x01\x00\x1d\x00\x03\x00\x1c\x00\x05\x00\x1b\x00\x06\x00\x1a\x00\
\\x08\x00\x19\x00\x0c\x00\x18\x00\x00\x00\
\\x62\x00\x00\x00\
\\x63\x00\x00\x00\
\\x64\x00\x0a\x00\x29\x00\x00\x00\
\\x65\x00\x00\x00\
\\x66\x00\x00\x00\
\\x67\x00\x00\x00\
\\x68\x00\x00\x00\
\\x69\x00\x07\x00\x20\x00\x00\x00\
\\x6a\x00\x00\x00\
\\x6b\x00\x00\x00\
\\x6c\x00\x00\x00\
\\x6d\x00\x00\x00\
\\x6d\x00\x12\x00\x2f\x00\x00\x00\
\\x6e\x00\x09\x00\x25\x00\x14\x00\x24\x00\x00\x00\
\\x6f\x00\x14\x00\x24\x00\x00\x00\
\\x70\x00\x09\x00\x25\x00\x00\x00\
\\x71\x00\x00\x00\
\\x72\x00\x00\x00\
\\x73\x00\x00\x00\
\\x74\x00\x00\x00\
\\x75\x00\x00\x00\
\\x76\x00\x00\x00\
\\x77\x00\x00\x00\
\\x78\x00\x00\x00\
\\x79\x00\x07\x00\x20\x00\x00\x00\
\\x7a\x00\x00\x00\
\\x7b\x00\x07\x00\x20\x00\x00\x00\
\\x7c\x00\x00\x00\
\\x7d\x00\x00\x00\
\\x7e\x00\x00\x00\
\\x7f\x00\x0c\x00\x1e\x00\x00\x00\
\\x80\x00\x00\x00\
\";
    action_row_numbers =
"\x14\x00\x02\x00\x00\x00\x17\x00\
\\x15\x00\x0a\x00\x18\x00\x16\x00\
\\x27\x00\x46\x00\x2f\x00\x2d\x00\
\\x2c\x00\x35\x00\x23\x00\x2e\x00\
\\x2a\x00\x28\x00\x26\x00\x0c\x00\
\\x31\x00\x0b\x00\x27\x00\x34\x00\
\\x1b\x00\x1a\x00\x03\x00\x19\x00\
\\x27\x00\x22\x00\x01\x00\x37\x00\
\\x36\x00\x32\x00\x04\x00\x05\x00\
\\x22\x00\x3d\x00\x24\x00\x2b\x00\
\\x29\x00\x13\x00\x30\x00\x1d\x00\
\\x0d\x00\x06\x00\x47\x00\x0e\x00\
\\x3f\x00\x42\x00\x40\x00\x33\x00\
\\x38\x00\x39\x00\x3c\x00\x07\x00\
\\x3a\x00\x3e\x00\x21\x00\x1e\x00\
\\x0f\x00\x11\x00\x45\x00\x25\x00\
\\x44\x00\x43\x00\x41\x00\x09\x00\
\\x1d\x00\x1f\x00\x20\x00\x08\x00\
\\x1c\x00\x10\x00\x3b\x00\x12\x00";
   goto_table =
"\
\\x01\x00\x4b\x00\x02\x00\x01\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x03\x00\x15\x00\x09\x00\x14\x00\x0a\x00\x13\x00\x0b\x00\x12\x00\
\\x0c\x00\x11\x00\x0d\x00\x10\x00\x0e\x00\x0f\x00\x0f\x00\x0e\x00\
\\x10\x00\x0d\x00\x14\x00\x0c\x00\x15\x00\x0b\x00\x17\x00\x0a\x00\
\\x18\x00\x09\x00\x00\x00\
\\x00\x00\
\\x16\x00\x1d\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x11\x00\x21\x00\x12\x00\x20\x00\x13\x00\x1f\x00\x00\x00\
\\x07\x00\x26\x00\x08\x00\x25\x00\x16\x00\x24\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x03\x00\x15\x00\x09\x00\x14\x00\x0c\x00\x28\x00\x0d\x00\x10\x00\
\\x0e\x00\x0f\x00\x0f\x00\x0e\x00\x10\x00\x0d\x00\x14\x00\x0c\x00\
\\x15\x00\x0b\x00\x17\x00\x0a\x00\x18\x00\x09\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x06\x00\x2a\x00\x00\x00\
\\x03\x00\x15\x00\x09\x00\x14\x00\x0a\x00\x2c\x00\x0b\x00\x12\x00\
\\x0c\x00\x11\x00\x0d\x00\x10\x00\x0e\x00\x0f\x00\x0f\x00\x0e\x00\
\\x10\x00\x0d\x00\x14\x00\x0c\x00\x15\x00\x0b\x00\x17\x00\x0a\x00\
\\x18\x00\x09\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x03\x00\x15\x00\x09\x00\x14\x00\x0a\x00\x2f\x00\x0b\x00\x12\x00\
\\x0c\x00\x11\x00\x0d\x00\x10\x00\x0e\x00\x0f\x00\x0f\x00\x0e\x00\
\\x10\x00\x0d\x00\x14\x00\x0c\x00\x15\x00\x0b\x00\x17\x00\x0a\x00\
\\x18\x00\x09\x00\x00\x00\
\\x07\x00\x26\x00\x08\x00\x30\x00\x00\x00\
\\x0f\x00\x32\x00\x10\x00\x0d\x00\x17\x00\x31\x00\x18\x00\x09\x00\x00\x00\
\\x12\x00\x34\x00\x00\x00\
\\x13\x00\x35\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x07\x00\x26\x00\x08\x00\x39\x00\x00\x00\
\\x00\x00\
\\x06\x00\x3a\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x04\x00\x3c\x00\x09\x00\x3b\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x16\x00\x41\x00\x00\x00\
\\x16\x00\x42\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x05\x00\x44\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x04\x00\x48\x00\x09\x00\x3b\x00\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\\x00\x00\
\";
   numstates = 76;
   numrules = 51;
 s = REF "";  index = REF 0;
    string_to_int = \\ () = 
    {    i = *index;
         index := i+2;
         string::get_byte(*s, i) + string::get_byte(*s, i+1) * 256;
    };

    string_to_list = \\ s' =
    {   len = string::length_in_bytes s';
        fun f () =
           if (*index < len)
           string_to_int() ! f();
           else NIL; fi;
        index := 0;
        s := s';
        f ();
   };

   string_to_pairlist =   \\ (conv_key, conv_entry) =   f
   where 
         fun f ()
             =
             case (string_to_int ())
                 0 => EMPTY;
                 n => PAIR (conv_key (n - 1), conv_entry (string_to_int()), f());
             esac;
   end;

   string_to_pairlist_default =   \\ (conv_key, conv_entry) =
    {   conv_row = string_to_pairlist (conv_key, conv_entry);
       \\ () =
       {   default = conv_entry (string_to_int());
           row = conv_row();
          (row, default);
       };
   };

    string_to_table = \\ (convert_row, s') =
    {   len = string::length_in_bytes s';
        fun f ()
            =
           if (*index < len)
              convert_row() ! f();
           else NIL; fi;
        s := s';
        index := 0;
        f ();
     };

stipulate
  memo = rw_vector::make_rw_vector (numstates+numrules, ERROR);
  my _ ={   fun g i
                =
                {   rw_vector::set (memo, i, REDUCE (i-numstates));
                    g (i+1);
                };

            fun f i
                =
                if   (i == numstates)
                     g i;
                else    rw_vector::set (memo, i, SHIFT (STATE i));
                         f (i+1);
                fi;

            f 0
            except
                INDEX_OUT_OF_BOUNDS =  ();
        };
herein
    entry_to_action
        =
        \\ 0 =>  ACCEPT;
           1 =>  ERROR;
           j =>  rw_vector::get (memo, (j - 2));
        end;
end;

   goto_table = rw_vector::from_list (string_to_table (string_to_pairlist (NONTERM, STATE), goto_table));
   action_rows = string_to_table (string_to_pairlist_default (TERM, entry_to_action), action_rows);
   action_row_numbers = string_to_list action_row_numbers;
   action_table
    =
    {   action_row_lookup
            =
            {   a=rw_vector::from_list (action_rows);

                \\ i =   rw_vector::get (a, i);
            };

        rw_vector::from_list (map action_row_lookup action_row_numbers);
    };

    lr_table::make_lr_table {
        actions => action_table,
        gotos   => goto_table,
        rule_count   => numrules,
        state_count  => numstates,
        initial_state => STATE 0   };
};
end;
stipulate include package   header; herein
Source_Position = Int;
Arg = Void;
package values { 
Semantic_Value = TM_VOID | NT_VOID  Void -> Void | SYMBOL Void ->  (String) | QQ_SUBG_HDR Void ->  (String) | QQ_SUBG_STMT Void ->  ((g::Traitful_Graph -> g::Traitful_Graph))
 | QQ_EDGE_RHS Void ->  (List ( Vertex ) ) | QQ_EDGE_STMT Void ->  ((g::Traitful_Graph -> g::Traitful_Graph)) | QQ_NODE_STMT Void ->  ((g::Traitful_Graph -> g::Traitful_Graph))
 | QQ_PORT_ANGLE Void ->  (String) | QQ_PORT_LOCATION Void ->  (String) | QQ_NODE_PORT Void ->  (Null_Or ( String ) ) | QQ_NODE_NAME Void ->  (String)
 | QQ_NODE_ID Void ->  ((String, Null_Or( String ))) | QQ_ATTR_STMT Void ->  ((g::Traitful_Graph -> g::Traitful_Graph)) | QQ_STMT1 Void ->  ((g::Traitful_Graph -> g::Traitful_Graph))
 | QQ_STMT Void ->  ((g::Traitful_Graph -> g::Traitful_Graph)) | QQ_STMT_LIST1 Void ->  ((g::Traitful_Graph -> g::Traitful_Graph)) | QQ_STMT_LIST Void ->  ((g::Traitful_Graph -> g::Traitful_Graph))
 | QQ_ATTR_SET Void ->  ((String, String)) | QQ_OPT_ATTR_LIST Void ->  (List ( (String, String)) ) | QQ_REC_ATTR_LIST Void ->  (List ( (String, String)) )
 | QQ_ATTR_LIST Void ->  (List ( (String, String)) ) | QQ_INSIDE_ATTR_LIST Void ->  (List ( (String, String)) )
 | QQ_ATTR_ILK Void ->  ((List ((String, String)) -> g::Traitful_Graph -> g::Traitful_Graph)) | QQ_GRAPH_TYPE Void ->  (String) | QQ_FILE Void ->  (Null_Or ( g::Traitful_Graph ) );
};
Semantic_Value = values::Semantic_Value;
Result = Null_Or ( g::Traitful_Graph ) ;
end;
package error_recovery{
include package lr_table;
infix my 60 @@;
fun x @@ y = y ! x;
is_keyword =
\\ _ => FALSE; end;
my preferred_change:   List( (List( Terminal ), List( Terminal )) ) = 
NIL;
no_shift = 
\\ (TERM 20) => TRUE; _ => FALSE; end;
show_terminal =
\\ (TERM 0) => "GRAPH"
; (TERM 1) => "DIGRAPH"
; (TERM 2) => "SUBGRAPH"
; (TERM 3) => "STRICT"
; (TERM 4) => "NODE"
; (TERM 5) => "EDGE"
; (TERM 6) => "EDGEOP"
; (TERM 7) => "SYMBOL"
; (TERM 8) => "COLON"
; (TERM 9) => "SEMICOLON"
; (TERM 10) => "COMMA"
; (TERM 11) => "LBRACE"
; (TERM 12) => "LBRACKET"
; (TERM 13) => "LPAREN"
; (TERM 14) => "RBRACE"
; (TERM 15) => "RBRACKET"
; (TERM 16) => "RPAREN"
; (TERM 17) => "EQUAL"
; (TERM 18) => "DOT"
; (TERM 19) => "AT"
; (TERM 20) => "EOF"
; _ => "bogus-term"; end;
stipulate include package   header; herein
errtermvalue=
\\ _ => values::TM_VOID;
 end; end;
my terms:  List( Terminal ) = NIL
 @@ (TERM 20) @@ (TERM 19) @@ (TERM 18) @@ (TERM 17) @@ (TERM 16) @@ (TERM 15) @@ (TERM 14) @@ (TERM 13) @@ (TERM 12) @@ (TERM 11) @@ (TERM 10) @@ (TERM 9) @@ (TERM 8) @@ (TERM 6) @@ (TERM 5) @@ 
(TERM 4) @@ (TERM 3) @@ (TERM 2) @@ (TERM 1) @@ (TERM 0);
};
package actions {
exception MLY_ACTION Int;
stipulate include package   header; herein
actions = 
\\ (i392, default_position, stack, 
    (()): Arg) = 
case (i392, stack)
  ( 0,  ( ( _,  ( _,  _,  rbrace1right)) !  ( _,  ( values::QQ_STMT_LIST stmt_list1,  _,  _)) !  _ !  ( _,  ( values::SYMBOL symbol1,  _,  _)) !  ( _,  ( values::QQ_GRAPH_TYPE graph_type1,  
graph_type1left,  _)) !  rest671)) => {  my  result = values::QQ_FILE (\\  _ =  {  my  (graph_type as graph_type1) = graph_type1 ();
 my  (symbol as symbol1) = symbol1 ();
 my  (stmt_list as 
stmt_list1) = stmt_list1 ();
 (
 { g = g::make_graph{ name=>symbol, make_default_graph_info, make_default_edge_info, make_default_node_info, info=>NULL};

                         g::set_trait (g::GRAPH_PART g) ("graph_type",graph_type);
                         THE (stmt_list g) ;
                       }
);
 } );
 ( lr_table::NONTERM 0,  ( result,  graph_type1left,  rbrace1right),  rest671);
 } 
;  ( 1,  ( rest671)) => {  my  result = values::QQ_FILE (\\  _ =  (NULL));
 ( lr_table::NONTERM 0,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 2,  ( ( _,  ( _,  graph1left,  graph1right)) !  rest671)) => {  my  result = values::QQ_GRAPH_TYPE (\\  _ =  ("g"));
 ( lr_table::NONTERM 1,  ( result,  graph1left,  graph1right),  rest671);
 } 
;  ( 3,  ( ( _,  ( _,  _,  graph1right)) !  ( _,  ( _,  strict1left,  _)) !  rest671)) => {  my  result = values::QQ_GRAPH_TYPE (\\  _ =  ("sg"));
 ( lr_table::NONTERM 1,  ( result,  strict1left,  
graph1right),  rest671);
 } 
;  ( 4,  ( ( _,  ( _,  digraph1left,  digraph1right)) !  rest671)) => {  my  result = values::QQ_GRAPH_TYPE (\\  _ =  ("dg"));
 ( lr_table::NONTERM 1,  ( result,  digraph1left,  digraph1right),  
rest671);
 } 
;  ( 5,  ( ( _,  ( _,  _,  digraph1right)) !  ( _,  ( _,  strict1left,  _)) !  rest671)) => {  my  result = values::QQ_GRAPH_TYPE (\\  _ =  ("sdg"));
 ( lr_table::NONTERM 1,  ( result,  strict1left,  
digraph1right),  rest671);
 } 
;  ( 6,  ( ( _,  ( _,  graph1left,  graph1right)) !  rest671)) => {  my  result = values::QQ_ATTR_ILK (\\  _ =  (\\ traits = \\ g = { apply (set_graph_trait        g) traits;  g; }));
 ( 
lr_table::NONTERM 2,  ( result,  graph1left,  graph1right),  rest671);
 } 
;  ( 7,  ( ( _,  ( _,  node1left,  node1right)) !  rest671)) => {  my  result = values::QQ_ATTR_ILK (\\  _ =  (\\ traits = \\ g = { apply (set_default_node_trait g) traits;  g; }));
 ( 
lr_table::NONTERM 2,  ( result,  node1left,  node1right),  rest671);
 } 
;  ( 8,  ( ( _,  ( _,  edge1left,  edge1right)) !  rest671)) => {  my  result = values::QQ_ATTR_ILK (\\  _ =  (\\ traits = \\ g = { apply (set_default_edge_trait g) traits;  g; }));
 ( 
lr_table::NONTERM 2,  ( result,  edge1left,  edge1right),  rest671);
 } 
;  ( 9,  ( ( _,  ( values::QQ_INSIDE_ATTR_LIST inside_attr_list1,  _,  inside_attr_list1right)) !  ( _,  ( values::NT_VOID optcomma1,  _,  _)) !  ( _,  ( values::QQ_ATTR_SET attr_set1,  attr_set1left
,  _)) !  rest671)) => {  my  result = values::QQ_INSIDE_ATTR_LIST (\\  _ =  {  my  (attr_set as attr_set1) = attr_set1 ();
 my  optcomma1 = optcomma1 ();
 my  (inside_attr_list as inside_attr_list1)
 = inside_attr_list1 ();
 (attr_set ! inside_attr_list);
 } );
 ( lr_table::NONTERM 3,  ( result,  attr_set1left,  inside_attr_list1right),  rest671);
 } 
;  ( 10,  ( rest671)) => {  my  result = values::QQ_INSIDE_ATTR_LIST (\\  _ =  ([]));
 ( lr_table::NONTERM 3,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 11,  ( rest671)) => {  my  result = values::NT_VOID (\\  _ =  ());
 ( lr_table::NONTERM 4,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 12,  ( ( _,  ( _,  comma1left,  comma1right)) !  rest671)) => {  my  result = values::NT_VOID (\\  _ =  ());
 ( lr_table::NONTERM 4,  ( result,  comma1left,  comma1right),  rest671);
 } 
;  ( 13,  ( ( _,  ( _,  _,  rbracket1right)) !  ( _,  ( values::QQ_INSIDE_ATTR_LIST inside_attr_list1,  _,  _)) !  ( _,  ( _,  lbracket1left,  _)) !  rest671)) => {  my  result = values::QQ_ATTR_LIST
 (\\  _ =  {  my  (inside_attr_list as inside_attr_list1) = inside_attr_list1 ();
 (inside_attr_list);
 } );
 ( lr_table::NONTERM 5,  ( result,  lbracket1left,  rbracket1right),  rest671);
 } 
;  ( 14,  ( ( _,  ( values::QQ_ATTR_LIST attr_list1,  _,  attr_list1right)) !  ( _,  ( values::QQ_REC_ATTR_LIST rec_attr_list1,  rec_attr_list1left,  _)) !  rest671)) => {  my  result = 
values::QQ_REC_ATTR_LIST (\\  _ =  {  my  (rec_attr_list as rec_attr_list1) = rec_attr_list1 ();
 my  (attr_list as attr_list1) = attr_list1 ();
 (rec_attr_list @ attr_list);
 } );
 ( 
lr_table::NONTERM 6,  ( result,  rec_attr_list1left,  attr_list1right),  rest671);
 } 
;  ( 15,  ( rest671)) => {  my  result = values::QQ_REC_ATTR_LIST (\\  _ =  ([]));
 ( lr_table::NONTERM 6,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 16,  ( ( _,  ( values::QQ_REC_ATTR_LIST rec_attr_list1,  rec_attr_list1left,  rec_attr_list1right)) !  rest671)) => {  my  result = values::QQ_OPT_ATTR_LIST (\\  _ =  {  my  (rec_attr_list as 
rec_attr_list1) = rec_attr_list1 ();
 (rec_attr_list);
 } );
 ( lr_table::NONTERM 7,  ( result,  rec_attr_list1left,  rec_attr_list1right),  rest671);
 } 
;  ( 17,  ( ( _,  ( values::SYMBOL symbol2,  _,  symbol2right)) !  _ !  ( _,  ( values::SYMBOL symbol1,  symbol1left,  _)) !  rest671)) => {  my  result = values::QQ_ATTR_SET (\\  _ =  {  my  symbol1
 = symbol1 ();
 my  symbol2 = symbol2 ();
 ((symbol1, symbol2));
 } );
 ( lr_table::NONTERM 8,  ( result,  symbol1left,  symbol2right),  rest671);
 } 
;  ( 18,  ( ( _,  ( values::QQ_STMT_LIST1 stmt_list11,  stmt_list11left,  stmt_list11right)) !  rest671)) => {  my  result = values::QQ_STMT_LIST (\\  _ =  {  my  (stmt_list1 as stmt_list11) = 
stmt_list11 ();
 (stmt_list1);
 } );
 ( lr_table::NONTERM 9,  ( result,  stmt_list11left,  stmt_list11right),  rest671);
 } 
;  ( 19,  ( rest671)) => {  my  result = values::QQ_STMT_LIST (\\  _ =  (\\ g = g));
 ( lr_table::NONTERM 9,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 20,  ( ( _,  ( values::QQ_STMT stmt1,  stmt1left,  stmt1right)) !  rest671)) => {  my  result = values::QQ_STMT_LIST1 (\\  _ =  {  my  (stmt as stmt1) = stmt1 ();
 (stmt);
 } );
 ( 
lr_table::NONTERM 10,  ( result,  stmt1left,  stmt1right),  rest671);
 } 
;  ( 21,  ( ( _,  ( values::QQ_STMT stmt1,  _,  stmt1right)) !  ( _,  ( values::QQ_STMT_LIST1 stmt_list11,  stmt_list11left,  _)) !  rest671)) => {  my  result = values::QQ_STMT_LIST1 (\\  _ =  {  my 
 (stmt_list1 as stmt_list11) = stmt_list11 ();
 my  (stmt as stmt1) = stmt1 ();
 (stmt o stmt_list1);
 } );
 ( lr_table::NONTERM 10,  ( result,  stmt_list11left,  stmt1right),  rest671);
 } 
;  ( 22,  ( ( _,  ( values::QQ_STMT1 stmt11,  stmt11left,  stmt11right)) !  rest671)) => {  my  result = values::QQ_STMT (\\  _ =  {  my  (stmt1 as stmt11) = stmt11 ();
 (stmt1);
 } );
 ( 
lr_table::NONTERM 11,  ( result,  stmt11left,  stmt11right),  rest671);
 } 
;  ( 23,  ( ( _,  ( _,  _,  semicolon1right)) !  ( _,  ( values::QQ_STMT1 stmt11,  stmt11left,  _)) !  rest671)) => {  my  result = values::QQ_STMT (\\  _ =  {  my  (stmt1 as stmt11) = stmt11 ();
 (
stmt1);
 } );
 ( lr_table::NONTERM 11,  ( result,  stmt11left,  semicolon1right),  rest671);
 } 
;  ( 24,  ( ( _,  ( values::QQ_NODE_STMT node_stmt1,  node_stmt1left,  node_stmt1right)) !  rest671)) => {  my  result = values::QQ_STMT1 (\\  _ =  {  my  (node_stmt as node_stmt1) = node_stmt1 ();
 (
node_stmt);
 } );
 ( lr_table::NONTERM 12,  ( result,  node_stmt1left,  node_stmt1right),  rest671);
 } 
;  ( 25,  ( ( _,  ( values::QQ_EDGE_STMT edge_stmt1,  edge_stmt1left,  edge_stmt1right)) !  rest671)) => {  my  result = values::QQ_STMT1 (\\  _ =  {  my  (edge_stmt as edge_stmt1) = edge_stmt1 ();
 (
edge_stmt);
 } );
 ( lr_table::NONTERM 12,  ( result,  edge_stmt1left,  edge_stmt1right),  rest671);
 } 
;  ( 26,  ( ( _,  ( values::QQ_ATTR_STMT attr_stmt1,  attr_stmt1left,  attr_stmt1right)) !  rest671)) => {  my  result = values::QQ_STMT1 (\\  _ =  {  my  (attr_stmt as attr_stmt1) = attr_stmt1 ();
 (
attr_stmt);
 } );
 ( lr_table::NONTERM 12,  ( result,  attr_stmt1left,  attr_stmt1right),  rest671);
 } 
;  ( 27,  ( ( _,  ( values::QQ_SUBG_STMT subg_stmt1,  subg_stmt1left,  subg_stmt1right)) !  rest671)) => {  my  result = values::QQ_STMT1 (\\  _ =  {  my  (subg_stmt as subg_stmt1) = subg_stmt1 ();
 (
\\ g = { subg_stmt g; g; });
 } );
 ( lr_table::NONTERM 12,  ( result,  subg_stmt1left,  subg_stmt1right),  rest671);
 } 
;  ( 28,  ( ( _,  ( values::QQ_ATTR_LIST attr_list1,  _,  attr_list1right)) !  ( _,  ( values::QQ_ATTR_ILK attr_ilk1,  attr_ilk1left,  _)) !  rest671)) => {  my  result = values::QQ_ATTR_STMT (\\  _
 =  {  my  (attr_ilk as attr_ilk1) = attr_ilk1 ();
 my  (attr_list as attr_list1) = attr_list1 ();
 (attr_ilk attr_list);
 } );
 ( lr_table::NONTERM 13,  ( result,  attr_ilk1left,  attr_list1right),  
rest671);
 } 
;  ( 29,  ( ( _,  ( values::QQ_ATTR_SET attr_set1,  attr_set1left,  attr_set1right)) !  rest671)) => {  my  result = values::QQ_ATTR_STMT (\\  _ =  {  my  (attr_set as attr_set1) = attr_set1 ();
 (
\\ g = { set_graph_trait g (#1 attr_set,#2 attr_set); g; });
 } );
 ( lr_table::NONTERM 13,  ( result,  attr_set1left,  attr_set1right),  rest671);
 } 
;  ( 30,  ( ( _,  ( values::QQ_NODE_PORT node_port1,  _,  node_port1right)) !  ( _,  ( values::QQ_NODE_NAME node_name1,  node_name1left,  _)) !  rest671)) => {  my  result = values::QQ_NODE_ID (\\  _
 =  {  my  (node_name as node_name1) = node_name1 ();
 my  (node_port as node_port1) = node_port1 ();
 (node_name, node_port);
 } );
 ( lr_table::NONTERM 14,  ( result,  node_name1left,  
node_port1right),  rest671);
 } 
;  ( 31,  ( ( _,  ( values::SYMBOL symbol1,  symbol1left,  symbol1right)) !  rest671)) => {  my  result = values::QQ_NODE_NAME (\\  _ =  {  my  (symbol as symbol1) = symbol1 ();
 (symbol);
 } );
 ( 
lr_table::NONTERM 15,  ( result,  symbol1left,  symbol1right),  rest671);
 } 
;  ( 32,  ( rest671)) => {  my  result = values::QQ_NODE_PORT (\\  _ =  (NULL));
 ( lr_table::NONTERM 16,  ( result,  default_position,  default_position),  rest671);
 } 
;  ( 33,  ( ( _,  ( values::QQ_PORT_LOCATION port_location1,  port_location1left,  port_location1right)) !  rest671)) => {  my  result = values::QQ_NODE_PORT (\\  _ =  {  my  (port_location as 
port_location1) = port_location1 ();
 (THE port_location);
 } );
 ( lr_table::NONTERM 16,  ( result,  port_location1left,  port_location1right),  rest671);
 } 
;  ( 34,  ( ( _,  ( values::QQ_PORT_ANGLE port_angle1,  port_angle1left,  port_angle1right)) !  rest671)) => {  my  result = values::QQ_NODE_PORT (\\  _ =  {  my  (port_angle as port_angle1) = 
port_angle1 ();
 (THE port_angle);
 } );
 ( lr_table::NONTERM 16,  ( result,  port_angle1left,  port_angle1right),  rest671);
 } 
;  ( 35,  ( ( _,  ( values::QQ_PORT_LOCATION port_location1,  _,  port_location1right)) !  ( _,  ( values::QQ_PORT_ANGLE port_angle1,  port_angle1left,  _)) !  rest671)) => {  my  result = 
values::QQ_NODE_PORT (\\  _ =  {  my  (port_angle as port_angle1) = port_angle1 ();
 my  (port_location as port_location1) = port_location1 ();
 (THE (port_angle + port_location));
 } );
 ( 
lr_table::NONTERM 16,  ( result,  port_angle1left,  port_location1right),  rest671);
 } 
;  ( 36,  ( ( _,  ( values::QQ_PORT_ANGLE port_angle1,  _,  port_angle1right)) !  ( _,  ( values::QQ_PORT_LOCATION port_location1,  port_location1left,  _)) !  rest671)) => {  my  result = 
values::QQ_NODE_PORT (\\  _ =  {  my  (port_location as port_location1) = port_location1 ();
 my  (port_angle as port_angle1) = port_angle1 ();
 (THE (port_location + port_angle));
 } );
 ( 
lr_table::NONTERM 16,  ( result,  port_location1left,  port_angle1right),  rest671);
 } 
;  ( 37,  ( ( _,  ( values::SYMBOL symbol1,  _,  symbol1right)) !  ( _,  ( _,  colon1left,  _)) !  rest671)) => {  my  result = values::QQ_PORT_LOCATION (\\  _ =  {  my  (symbol as symbol1) = symbol1
 ();
 (":" + symbol);
 } );
 ( lr_table::NONTERM 17,  ( result,  colon1left,  symbol1right),  rest671);
 } 
;  ( 38,  ( ( _,  ( _,  _,  rparen1right)) !  ( _,  ( values::SYMBOL symbol2,  _,  _)) !  _ !  ( _,  ( values::SYMBOL symbol1,  _,  _)) !  _ !  ( _,  ( _,  colon1left,  _)) !  rest671)) => {  my  
result = values::QQ_PORT_LOCATION (\\  _ =  {  my  symbol1 = symbol1 ();
 my  symbol2 = symbol2 ();
 (cat [":(",symbol1,",",symbol2,")"]);
 } );
 ( lr_table::NONTERM 17,  ( result,  colon1left,  
rparen1right),  rest671);
 } 
;  ( 39,  ( ( _,  ( values::SYMBOL symbol1,  _,  symbol1right)) !  ( _,  ( _,  at1left,  _)) !  rest671)) => {  my  result = values::QQ_PORT_ANGLE (\\  _ =  {  my  (symbol as symbol1) = symbol1 ();
 (
"@" + symbol);
 } );
 ( lr_table::NONTERM 18,  ( result,  at1left,  symbol1right),  rest671);
 } 
;  ( 40,  ( ( _,  ( values::QQ_OPT_ATTR_LIST opt_attr_list1,  _,  opt_attr_list1right)) !  ( _,  ( values::QQ_NODE_ID node_id1,  node_id1left,  _)) !  rest671)) => {  my  result = values::QQ_NODE_STMT
 (\\  _ =  {  my  (node_id as node_id1) = node_id1 ();
 my  (opt_attr_list as opt_attr_list1) = opt_attr_list1 ();
 (
\\ g = { apply (set_node_trait (g::get_or_make_node(g, #1 node_id,NULL))) opt_attr_list; g; });
 } );
 ( lr_table::NONTERM 19,  ( result,  node_id1left,  opt_attr_list1right),  rest671);
 } 
;  ( 41,  ( ( _,  ( values::QQ_OPT_ATTR_LIST opt_attr_list1,  _,  opt_attr_list1right)) !  ( _,  ( values::QQ_EDGE_RHS edge_rhs1,  _,  _)) !  ( _,  ( values::QQ_NODE_ID node_id1,  node_id1left,  _))
 !  rest671)) => {  my  result = values::QQ_EDGE_STMT (\\  _ =  {  my  (node_id as node_id1) = node_id1 ();
 my  (edge_rhs as edge_rhs1) = edge_rhs1 ();
 my  (opt_attr_list as opt_attr_list1) = 
opt_attr_list1 ();
 (make_edges((NODE node_id)       ! edge_rhs, opt_attr_list));
 } );
 ( lr_table::NONTERM 20,  ( result,  node_id1left,  opt_attr_list1right),  rest671);
 } 
;  ( 42,  ( ( _,  ( values::QQ_OPT_ATTR_LIST opt_attr_list1,  _,  opt_attr_list1right)) !  ( _,  ( values::QQ_EDGE_RHS edge_rhs1,  _,  _)) !  ( _,  ( values::QQ_SUBG_STMT subg_stmt1,  subg_stmt1left, 
 _)) !  rest671)) => {  my  result = values::QQ_EDGE_STMT (\\  _ =  {  my  (subg_stmt as subg_stmt1) = subg_stmt1 ();
 my  (edge_rhs as edge_rhs1) = edge_rhs1 ();
 my  (opt_attr_list as opt_attr_list1
) = opt_attr_list1 ();
 (make_edges((SUBGRAPH subg_stmt) ! edge_rhs, opt_attr_list));
 } );
 ( lr_table::NONTERM 20,  ( result,  subg_stmt1left,  opt_attr_list1right),  rest671);
 } 
;  ( 43,  ( ( _,  ( values::QQ_NODE_ID node_id1,  _,  node_id1right)) !  ( _,  ( _,  edgeop1left,  _)) !  rest671)) => {  my  result = values::QQ_EDGE_RHS (\\  _ =  {  my  (node_id as node_id1) = 
node_id1 ();
 ([NODE node_id]);
 } );
 ( lr_table::NONTERM 21,  ( result,  edgeop1left,  node_id1right),  rest671);
 } 
;  ( 44,  ( ( _,  ( values::QQ_EDGE_RHS edge_rhs1,  _,  edge_rhs1right)) !  ( _,  ( values::QQ_NODE_ID node_id1,  _,  _)) !  ( _,  ( _,  edgeop1left,  _)) !  rest671)) => {  my  result = 
values::QQ_EDGE_RHS (\\  _ =  {  my  (node_id as node_id1) = node_id1 ();
 my  (edge_rhs as edge_rhs1) = edge_rhs1 ();
 ((NODE node_id) ! edge_rhs);
 } );
 ( lr_table::NONTERM 21,  ( result,  
edgeop1left,  edge_rhs1right),  rest671);
 } 
;  ( 45,  ( ( _,  ( values::QQ_SUBG_STMT subg_stmt1,  _,  subg_stmt1right)) !  ( _,  ( _,  edgeop1left,  _)) !  rest671)) => {  my  result = values::QQ_EDGE_RHS (\\  _ =  {  my  (subg_stmt as 
subg_stmt1) = subg_stmt1 ();
 ([SUBGRAPH subg_stmt]);
 } );
 ( lr_table::NONTERM 21,  ( result,  edgeop1left,  subg_stmt1right),  rest671);
 } 
;  ( 46,  ( ( _,  ( values::QQ_EDGE_RHS edge_rhs1,  _,  edge_rhs1right)) !  ( _,  ( values::QQ_SUBG_STMT subg_stmt1,  _,  _)) !  ( _,  ( _,  edgeop1left,  _)) !  rest671)) => {  my  result = 
values::QQ_EDGE_RHS (\\  _ =  {  my  (subg_stmt as subg_stmt1) = subg_stmt1 ();
 my  (edge_rhs as edge_rhs1) = edge_rhs1 ();
 ((SUBGRAPH subg_stmt) ! edge_rhs);
 } );
 ( lr_table::NONTERM 21,  ( 
result,  edgeop1left,  edge_rhs1right),  rest671);
 } 
;  ( 47,  ( ( _,  ( _,  _,  rbrace1right)) !  ( _,  ( values::QQ_STMT_LIST stmt_list1,  _,  _)) !  _ !  ( _,  ( values::QQ_SUBG_HDR subg_hdr1,  subg_hdr1left,  _)) !  rest671)) => {  my  result = 
values::QQ_SUBG_STMT (\\  _ =  {  my  (subg_hdr as subg_hdr1) = subg_hdr1 ();
 my  (stmt_list as stmt_list1) = stmt_list1 ();
 (\\ g = (stmt_list (g::make_subgraph(g, subg_hdr,NULL))));
 } );
 ( 
lr_table::NONTERM 22,  ( result,  subg_hdr1left,  rbrace1right),  rest671);
 } 
;  ( 48,  ( ( _,  ( _,  _,  rbrace1right)) !  ( _,  ( values::QQ_STMT_LIST stmt_list1,  _,  _)) !  ( _,  ( _,  lbrace1left,  _)) !  rest671)) => {  my  result = values::QQ_SUBG_STMT (\\  _ =  {  my  (
stmt_list as stmt_list1) = stmt_list1 ();
 (\\ g = (stmt_list (g::make_subgraph(g,anonymous(),NULL))));
 } );
 ( lr_table::NONTERM 22,  ( result,  lbrace1left,  rbrace1right),  rest671);
 } 
;  ( 49,  ( ( _,  ( values::QQ_SUBG_HDR subg_hdr1,  subg_hdr1left,  subg_hdr1right)) !  rest671)) => {  my  result = values::QQ_SUBG_STMT (\\  _ =  {  my  (subg_hdr as subg_hdr1) = subg_hdr1 ();
 (
\\ g = find_subgraph(g, subg_hdr));
 } );
 ( lr_table::NONTERM 22,  ( result,  subg_hdr1left,  subg_hdr1right),  rest671);
 } 
;  ( 50,  ( ( _,  ( values::SYMBOL symbol1,  _,  symbol1right)) !  ( _,  ( _,  subgraph1left,  _)) !  rest671)) => {  my  result = values::QQ_SUBG_HDR (\\  _ =  {  my  (symbol as symbol1) = symbol1 ()
;
 (symbol);
 } );
 ( lr_table::NONTERM 23,  ( result,  subgraph1left,  symbol1right),  rest671);
 } 
; _ => raise exception (MLY_ACTION i392);
esac;
end;
void = values::TM_VOID;
extract = \\ a = (\\ values::QQ_FILE x => x;
 _ => { exception PARSE_INTERNAL;
	 raise exception PARSE_INTERNAL; }; end ) a ();
};
};
package tokens : (weak) Graph_Tokens {
Semantic_Value = parser_data::Semantic_Value;
Token (X,Y) = token::Token(X,Y);
fun graph (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 0, (parser_data::values::TM_VOID, p1, p2));
fun digraph (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 1, (parser_data::values::TM_VOID, p1, p2));
fun subgraph (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 2, (parser_data::values::TM_VOID, p1, p2));
fun strict (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 3, (parser_data::values::TM_VOID, p1, p2));
fun node (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 4, (parser_data::values::TM_VOID, p1, p2));
fun edge (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 5, (parser_data::values::TM_VOID, p1, p2));
fun edgeop (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 6, (parser_data::values::TM_VOID, p1, p2));
fun symbol (i, p1, p2) = token::TOKEN (parser_data::lr_table::TERM 7, (parser_data::values::SYMBOL (\\ () = i), p1, p2));
fun colon (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 8, (parser_data::values::TM_VOID, p1, p2));
fun semicolon (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 9, (parser_data::values::TM_VOID, p1, p2));
fun comma (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 10, (parser_data::values::TM_VOID, p1, p2));
fun lbrace (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 11, (parser_data::values::TM_VOID, p1, p2));
fun lbracket (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 12, (parser_data::values::TM_VOID, p1, p2));
fun lparen (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 13, (parser_data::values::TM_VOID, p1, p2));
fun rbrace (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 14, (parser_data::values::TM_VOID, p1, p2));
fun rbracket (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 15, (parser_data::values::TM_VOID, p1, p2));
fun rparen (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 16, (parser_data::values::TM_VOID, p1, p2));
fun equal (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 17, (parser_data::values::TM_VOID, p1, p2));
fun dot (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 18, (parser_data::values::TM_VOID, p1, p2));
fun at (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 19, (parser_data::values::TM_VOID, p1, p2));
fun eof (p1, p2) = token::TOKEN (parser_data::lr_table::TERM 20, (parser_data::values::TM_VOID, p1, p2));
};
};
