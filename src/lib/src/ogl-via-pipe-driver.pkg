# ogl-via-pipe-driver.pkg
#
# This file handles the Mythryl side
# of the Mythryl <-> C interface
# layer for the Mythryl Ogl-in-subprocess
# Ogl binding.
#
# Here we implement only low-level pipe-specific functionality.
# In src/lib/src/ogl-via-pipe.pkg we are passed as an argument
# to the generic handling the higher-level stuff:
#
#     ogl_g from   src/lib/src/ogl-g.pkg
#
# The other end of the pipe is implemented in C in:
#
#     src/c/ogl/mythryl-ogl-server.c
#
# See the comments in that file for a description
# of the pipe protocol used.
#
# Our alternative Ogl-in-main-process implementation is in
#
#     src/lib/src/ogl-driver.pkg

# Compiled by:
#     src/lib/std/standard.lib




stipulate
    package f8b =  eight_byte_float;					# eight_byte_float	is from   src/lib/std/eight-byte-float.pkg
    package fil =  file__premicrothread;				# file__premicrothread	is from   src/lib/std/src/posix/file--premicrothread.pkg
    package spn =  spawn__premicrothread;				# spawn__premicrothread	is from   src/lib/std/src/posix/spawn--premicrothread.pkg
herein

    package ogl_via_pipe_driver:  Ogl_Driver   {			# Ogl_Driver		is from   src/lib/src/ogl-driver.api
	#
	include ogl_event;						# ogl_event		is from   src/lib/src/ogl-event.pkg

	package int_map
	    =
	    int_red_black_map;

	Session = { process:             spn::Process( fil::Output_Stream, fil::Input_Stream, fil::Input_Stream ),

		    # The input and output pipes connecting us
		    # to the GTK server subprocess:
		    #
		    from_stream:         fil::Input_Stream,
		    to_stream:           fil::Output_Stream,

		    # An additional stream on which to log debug stuff:
		    #
		    logstream:           fil::Output_Stream,

		    callback_map:	  { void:              Ref (int_map::Map( Void            -> Void )),
					    bool:              Ref (int_map::Map( Bool            -> Void )),
					    float:             Ref (int_map::Map( Float           -> Void ))
					  }
					  # callback_map is created by our client  src/lib/src/gtk-g.pkg
					  # and passed to us via our make_session call.  We read it but never write it.
		  };

#	# Given ("FOO", "FOO187"), return 187:
#	#
#	fun get_int_suffix (prefix, string)
#	    =
#	    {   suffix =  string::extract (string, string::length  prefix, NULL);
#		#
#		case (int::from_string  suffix)
#		    #
#		    THE i =>  i;
#		    NULL  =>  raise exception FAIL ("get_int_suffix:  Bad " + prefix + " value: " + string);
#		esac;
#	    };
#
#	# Given ("FOO", "FOO..."), return "...":
#	#
#	fun get_suffix (prefix, string)
#	    =
#	    string::extract (string, string::length  prefix, NULL);


	# A line like
	#     "CALLBACK17"
	# means to execute callback 17
	# in our callback_map.
	#
	# A line like
	#     "BOOL_CALLBACK17 TRUE"
	# means to execute callback 17
	# in our bool_callback_map with an argument of TRUE.
	#
	# A line like
	#     "FLOAT_CALLBACK17 2.3"
	# means to execute callback 17
	# in our float_callback_map with an argument of 2.3.
	#
	# A line like
	#     "BUTTON_CALLBACK17 1 23.3 52.9"
	# means to tell callback 17 that mouse button 1 was clicked at x,y of (23.3, 52.9)
	# ...
	# and so forth. :)
	#
#	fun maybe_run_callback  (session: Session, callback_line: String): Void
#	    =
#	    {
#    # fil::write (session.subsession.logstream, "src/lib/src/ogl.pkg: maybe_run_callback: callback_line = '" +  callback_line + "'\n");  fil::flush session.subsession.logstream;
#		if (string::is_prefix  "CALLBACK"  callback_line)
#		    #
#    # fil::write (session.subsession.logstream, "src/lib/src/ogl.pkg: maybe_run_callback: itsa CALLBACK line.\n");  fil::flush session.subsession.logstream;
#		    callback_id
#			=
#			get_int_suffix ("CALLBACK", callback_line); 
#
#		    case (int_map::get (*session.void_callback_map, callback_id))
#		        #
#			THE callback => callback ();
#			NULL         => (); 
#		    esac;
#		fi;
#
#		if (string::is_prefix  "BOOL_CALLBACK"  callback_line)
#		    #
## fil::write (session.subsession.logstream, "src/lib/src/ogl.pkg: maybe_run_callback: itsa BOOL_CALLBACK line.\n");  fil::flush session.subsession.logstream;
#		    callback_id =  get_int_suffix ("BOOL_CALLBACK", callback_line); 
#		    bool        =  string::is_suffix "TRUE" callback_line; 
#
#		    case (int_map::get (*session.bool_callback_map, callback_id))
#			#
#			THE callback => callback bool;
#			NULL         => (); 
#		    esac;
#		fi;
#
#		if (string::is_prefix  "FLOAT_CALLBACK"  callback_line)
#		    #
## fil::write (session.subsession.logstream, "src/lib/src/ogl.pkg: maybe_run_callback: itsa FLOAT_CALLBACK line.\n");  fil::flush session.subsession.logstream;
#		    callback_id =  get_int_suffix ("FLOAT_CALLBACK", callback_line); 
#
#		    # callback_line should look like
#		    #
#		    #     "FLOAT_CALLBACK17 2.3"
#		    #
#		    # where '17' is the callback to invoke
#		    # and '2.3' is the value to pass it:
#		    #
#		    value
#			=
#			case (string::tokens  char::is_space  callback_line)
#			    #
#			    _ ! arg ! NIL => the (f8b::from_string arg);
#			    _             => raise exception OGL_ERROR "bad FLOAT_CALLBACK arg";
#			esac;
#
#		    case (int_map::get (*session.float_callback_map, callback_id))
#			#
#			THE callback => callback value;
#			NULL         => (); 
#		    esac;
#		fi;
#
#		if (string::is_prefix  "BUTTON_CALLBACK"  callback_line)
#		    #
#    # fil::write (session.subsession.logstream, "src/lib/src/ogl.pkg: maybe_run_callback: itsa BUTTON_CALLBACK line.\n");  fil::flush session.subsession.logstream;
#		    callback_id =  get_int_suffix ("BUTTON_CALLBACK", callback_line); 
#
#		    # callback_line should look like
#		    #
#		    #     "BUTTON_CALLBACK17 13 1 23.3 16.2 2314 16"
#		    #
#		    # where '17' is the callback to invoke;
#		    #       '13' is the widow receiving the event
#		    #        '1' is the button pressed;
#		    #     '23.3' is the pointer x-coord;
#		    #     '16.2' is the pointer y-coord;
#		    #     '2314' is the event time in milliseconds; and
#		    #       '16' is the bitbag of modifier keys.
#		    #
#		    value = case (string::tokens  char::is_space  callback_line)
#				#
#				_ ! window ! button ! x ! y ! time ! modifiers ! NIL
#				    =>
#				    { window    =>        the (  int::from_string  window),
#				      button    =>        the (  int::from_string  button),
#				      x         =>        the (f8b::from_string  x     ),
#				      y         =>        the (f8b::from_string  y     ),
#				      time      =>        the (  int::from_string  time  ),
#				      modifiers =>  mods (the (  int::from_string  modifiers))
#				    };
#				_            => raise exception OGL_ERROR "bad BUTTON_CALLBACK arg";
#			    esac
#			    where
#				mods = int_to_modifier_list;
#			    end;
#
#		    case (int_map::get (*session.button_event_callback_map, callback_id))
#			#
#			THE callback => callback value;
#			NULL         => (); 
#		    esac;
#		fi;
#
#		if (string::is_prefix  "MOTION_CALLBACK"  callback_line)
#		    #
#    # fil::write (session.subsession.logstream, "src/lib/src/ogl.pkg: maybe_run_callback: itsa MOTION_CALLBACK line.\n");  fil::flush session.subsession.logstream;
#		    callback_id =  get_int_suffix ("MOTION_CALLBACK", callback_line); 
#
#		    # callback_line should look like
#		    #
#		    #     "MOTION_CALLBACK17 14 19123 23.3 16.2"
#		    #
#		    # where '17' is the callback to invoke;
#		    #       '14'    is the window which received the event;
#		    #       '19123' is the millisecond-accurate sample time;
#		    #       '23.3' is the pointer x-coord; and
#		    #       '16.2' is the pointer y-coord.
#		    #
#		    value = case (string::tokens  char::is_space  callback_line)
#				#
#				_ ! window ! time ! x ! y ! modifiers ! is_hint ! NIL
#				    =>
#				    { window    =>        the (  int::from_string  window   ),
#				      time      =>        the (  int::from_string  time     ),
#				      x         =>        the (f8b::from_string  x        ),
#				      y         =>        the (f8b::from_string  y        ),
#				      modifiers =>  mods (the (  int::from_string  modifiers)),
#				      is_hint   =>  1 == (the (  int::from_string  is_hint  ))
#				    };
#				_          =>  raise exception OGL_ERROR "bad MOTION_CALLBACK arg";
#			    esac
#			    where
#				mods = int_to_modifier_list;
#			    end;
#
#		    case (int_map::get (*session.motion_event_callback_map, callback_id))
#			#
#			THE callback => callback value;
#			NULL         => (); 
#		    esac;
#		fi;
#
#		if (string::is_prefix  "EXPOSE_CALLBACK"  callback_line)
#		    #
#    # fil::write (session.subsession.logstream, "src/lib/src/ogl.pkg: maybe_run_callback: itsa EXPOSE_CALLBACK line.\n");  fil::flush session.subsession.logstream;
#		    callback_id =  get_int_suffix ("EXPOSE_CALLBACK", callback_line); 
#
#		    # callback_line should look like
#		    #
#		    #     "EXPOSE_CALLBACK17 0"
#		    #
#		    # where '17' is the callback to invoke;
#		    #       '0' is count of following expose events.
#		    #
#		    value = case (string::tokens  char::is_space  callback_line)
#				#
#				_ ! window ! count ! x ! y ! wide ! high ! NIL
#				    =>
#				    { window =>  the (int::from_string    window ),
#				      count  =>  the (int::from_string    count  ),
#				      x      =>  the (int::from_string    x      ),
#				      y      =>  the (int::from_string    y      ),
#				      wide   =>  the (int::from_string    wide   ),
#				      high   =>  the (int::from_string    high   )
#				    };
#				_          =>  raise exception OGL_ERROR "bad EXPOSE_CALLBACK arg";
#			    esac;
#
#		    case (int_map::get (*session.expose_event_callback_map, callback_id))
#			#
#			THE callback => callback value;
#			NULL         => (); 
#		    esac;
#		fi;
#
#		if (string::is_prefix  "CONFIGURE_CALLBACK"  callback_line)
#		    #
#    # fil::write (session.subsession.logstream, "src/lib/src/ogl.pkg: maybe_run_callback: itsa CONFIGURE_CALLBACK line.\n");  fil::flush session.subsession.logstream;
#		    callback_id =  get_int_suffix ("CONFIGURE_CALLBACK", callback_line); 
#
#		    # callback_line should look like
#		    #
#		    #     "CONFIGURE_CALLBACK17 8 15 600 300"
#		    #
#		    # where '17' is the callback to invoke;
#		    #       '8'  is x;
#		    #      '15'  is y;
#		    #     '600'  is wide;
#		    #     '300'  is high;
#		    #
#		    value = case (string::tokens  char::is_space  callback_line)
#				#
#				_ ! window ! x ! y ! wide ! high ! NIL
#				    =>
#				    { window =>  the (int::from_string    window ),
#				      x      =>  the (int::from_string    x      ),
#				      y      =>  the (int::from_string    y      ),
#				      wide   =>  the (int::from_string    wide   ),
#				      high   =>  the (int::from_string    high   )
#				    };
#				_          =>  raise exception OGL_ERROR "bad CONFIGURE_CALLBACK arg";
#			    esac;
#
#		    case (int_map::get (*session.configure_event_callback_map, callback_id))
#			#
#			THE callback => callback value;
#			NULL         => (); 
#		    esac;
#		fi;
#
#		if (string::is_prefix  "KEY_CALLBACK"  callback_line)
#		    #
#    # fil::write (session.subsession.logstream, "src/lib/src/ogl.pkg: maybe_run_callback: itsa KEY_CALLBACK line.\n");  fil::flush session.subsession.logstream;
#		    callback_id =  get_int_suffix ("KEY_CALLBACK", callback_line); 
#
#		    # callback_line should look like
#		    #
#		    #     "KEY_CALLBACK17 8 15 12819 0"
#		    #
#		    # where '17' is the callback to invoke;
#		    #       '8'  is key;
#		    #      '15'  is keycode;
#		    #   '12819'  is millisecond time;
#		    #       '0'  is modifiers.
#		    #
#		    value = case (string::tokens  char::is_space  callback_line)
#				#
#				_ ! key ! keycode ! time ! modifiers ! NIL
#				    =>
#				    { key       =>        the (int::from_string  key       ),
#				      keycode   =>        the (int::from_string  keycode   ),
#				      time      =>        the (int::from_string  time      ),
#				      modifiers =>  mods (the (int::from_string  modifiers ))
#				    };
#				_          =>  raise exception OGL_ERROR "bad KEY_CALLBACK arg";
#			    esac
#			    where
#				mods = int_to_modifier_list;
#			    end;
#
#		    case (int_map::get (*session.key_event_callback_map, callback_id))
#			#
#			THE callback => callback value;
#			NULL         => (); 
#		    esac;
#		fi;
#	    };
#
#	#
#	fun widget_to_string  widget
#	    =
#	    "WIDGET"  +  (int::to_string  widget);
#
#	#
#	fun string_to_string   string
#	    =
#	    sprintf "\"%d\"%s\"" (string::length string) string;
#
#	#
#	fun string_to_widget widget
#	    =
#	    {    if (not (string::is_prefix "WIDGET" widget))  raise exception FAIL ("Invalid string_to_widget arg: " + widget); fi;
#
#		 suffix = get_suffix ("WIDGET", widget);
#
#		 the (int::from_string suffix);
#	    };
#
#	#
#	fun bool_to_string bool
#	    =
#	    case bool
#		#
#		TRUE  => "TRUE";
#		FALSE => "FALSE";
#	    esac;

	# Read a line from mythryl-ogl-server,
	# then execute any callback
	# it requests.
	# Return Void:
	#
#	fun handle_line_from_server  (session:   Session)
#	    =
#	    case (fil::read_line  session.from_stream)
#		#
#		THE line
#		    =>
#		    {   line = string::chomp  line;
#   fil::write (session.logstream, "    read: " + line + "\n");  fil::flush session.logstream;
#			maybe_run_callback (session, line);
#		    };
#		#
#		NULL =>   raise exception FAIL "EOF from mythryl-ogl-server subprocess.";
#	    esac;

	# Read lines from mythryl-ogl-server until
	# we get a line (say "FOO187"),
	# starting with given prefix ("FOO").
	# After finding it, execute any callbacks
	# encountered along the way, then return
	# the target line ("FOO187"):
	#
# 	fun handle_line_from_server'
# 	      ( session:         Session,
# 		result_prefix:   String
# 	      )
# 	    =
# {
# log::note_in_ramlog .{ "handle_line_from_server'/AAA  -- ogl-via-pipe-driver.pkg"; };
# result =
# 	    read_lines [];
# log::note_in_ramlog .{ "handle_line_from_server'/ZZZ  -- ogl-via-pipe-driver.pkg"; };
# result;
# }
# 	    where
# 		# Voice of Experience:  We need to read everything
# 		# up to our target line before running any callbacks,
# 		# because otherwise the callbacks may make recursive
# 		# calls to our server process which will eat our remaining
# 		# input out from under us before we can get to it.
# 		#
# 		fun read_lines  lines_read
# 		    =
# {
# log::note_in_ramlog .{ "read_lines calling fil::read_line  -- ogl-via-pipe-driver.pkg"; };
# 		    case (fil::read_line  session.from_stream)
# 			#
# 			THE line
# 			    =>
# 			    {
# 				line = string::chomp  line;
# log::note_in_ramlog .{ sprintf "read_lines chomped line s='%s' (result_prefix s='%s') -- ogl-via-pipe-driver.pkg" line result_prefix; };
# #   fil::write (session.logstream, "    READ: " + line + "\n");  fil::flush session.logstream;
# 
# 				if (string::is_prefix  result_prefix  line)
# 				     #	
# 				     # NOW it is safe to run our callbacks:
# 				     #
# log::note_in_ramlog .{ "read_lines running callbacks... -- ogl-via-pipe-driver.pkg"; };
# 				     apply
# #					 .{ maybe_run_callback (session, #line); }
# 					 (fn linex = {
# log::note_in_ramlog .{ sprintf "read_lines calling maybe_run_callback on '%s' -- ogl-via-pipe-driver.pkg" linex; };
# 						     }	
# 					 )
# 					 (reverse lines_read);
# 
# log::note_in_ramlog .{ sprintf "read_lines returning '%s'... -- ogl-via-pipe-driver.pkg" line; };
# 				     line;
# 				else
# 
# log::note_in_ramlog .{ sprintf "read_lines saving '%s' and reading another line recursively... -- ogl-via-pipe-driver.pkg" line; };
# 				     read_lines  (line ! lines_read);
# 				fi;
# 			    };
# 			#
# 			NULL => {
# log::note_in_ramlog .{ sprintf "read_lines EOF from server subprocess. -- ogl-via-pipe-driver.pkg"; };
# 				    raise exception FAIL "EOF from mythryl-ogl-server subprocess.";	
# 			};
# 		    esac;
# };
# 	    end;

	# Send given command to mythryl-ogl-server subprocess,
	# return Void:
	#
# 	fun do_void_command
# 	    (
# 	      session: Session,
# 	      command
# 	    )
# 	    =
# 	    {   fil::write (session.to_stream, (sprintf "%d" (string::length command + 1)) + "\n");	# Write length of next line.
# 		fil::write (session.to_stream, command+"\n");
# 		fil::flush session.to_stream;
#     fil::write (session.logstream, "    sent: do_void_command: " + command + "\n");     fil::flush session.logstream;
# 	    };

	# Send given command to mythryl-ogl-server subprocess,
	# read result marked by 'result_prefix' ,
	# return integer result:
	#
# 	fun do_int_command
# 	    ( session,
# 	      result_prefix,
# 	      command
# 	    )
# 	    =
# 	    {
# log::note_in_ramlog .{ sprintf "do_int_command(%s)/AAA" command; }; 
# 		fil::write (session.to_stream, (sprintf "%d" (string::length command + 1)) + "\n");	# Write length of next line.
# 
# log::note_in_ramlog .{ sprintf "do_int_command(%s)/BBB" command; }; 
# 		fil::write (session.to_stream, command+"\n");		fil::flush session.to_stream;
# 
# log::note_in_ramlog .{ sprintf "do_int_command(%s)/CCC" command; }; 
#     fil::write (session.logstream, "    Sent: " + command + "\n");     fil::flush session.logstream;
# 
# log::note_in_ramlog .{ sprintf "do_int_command(%s)/DDD" command; }; 
# 		result =  handle_line_from_server' (session, result_prefix);
# 
# log::note_in_ramlog .{ sprintf "do_int_command(%s)/EEE" command; }; 
#     fil::write (session.logstream, "    Rslt: " + result + "\n");    fil::flush session.logstream;
# 
# log::note_in_ramlog .{ sprintf "do_int_command(%s)/FFF" command; }; 
# result =
# 		get_int_suffix (result_prefix, result);  
# log::note_in_ramlog .{ sprintf "do_int_command(%s)/ZZZ" command; }; 
# result;
# 	    };


	# Send given command to mythryl-ogl-server subprocess,
	# read result marked by 'result_prefix' ,
	# return string result:
	#
# 	fun do_string_command
# 	    ( session,
# 	      result_prefix,
# 	      command
# 	    )
# 	    =
# 	    {   fil::write (session.to_stream, (sprintf "%d" (string::length command + 1)) + "\n");	# Write length of next line.
# 
# 		fil::write (session.to_stream, command+"\n");		fil::flush session.to_stream;
# 
#     fil::write (session.logstream, "    SENT: " + command + "\n");     fil::flush session.logstream;
# 
# 		result =  handle_line_from_server' (session, result_prefix);
# 
# 		get_suffix (result_prefix, result);  
# 	    };
# 
# 
# 	#
# 	fun get_widget_allocation (session, widget)
# 	    =
# 	    {   result
# 		    = 
# 		    do_string_command
# 		      (
# 			session,
# 			"get_widget_allocation",
# 			string::join " " [ "get_widget_allocation",  widget_to_string  widget ]
# 		      );
# 
# 		case (string::tokens char::is_space result)
# 
# 		     x ! y ! wide ! high ! NIL
# 			=>
# 			( /* x    => */  the (int::from_string  x),
# 			  /* y    => */  the (int::from_string  y),
# 			  /* wide => */  the (int::from_string  wide),
# 			  /* high => */  the (int::from_string  high)
# 			);
# 
# 		     _  => raise exception FAIL ("get_widget_allocation: invalid result from child: " + result);
# 		esac;
# 	    };
# 
# 
# 	#
# 	fun make_dialog session
# 	    =
# 	    {   result
# 		    = 
# 		    do_string_command
# 		      (
# 			session,
# 			"make_dialog",
# 			"make_dialog"
# 		      );
# 
# 		case (string::tokens char::is_space result)
# 
# 		     dialog ! vbox ! action_area ! NIL
# 			=>
# 			( string_to_widget  dialog,
# 			  string_to_widget  vbox,
# 			  string_to_widget  action_area
# 			);
# 
# 		     _  => raise exception FAIL ("make_dialog: invalid result from child: " + result);
# 		esac;
# 	    };
# 
# 	#
# 	fun unref_object (session, widget)
# 	    =
# 	    do_void_command (session, "unref_object " + widget_to_string widget);
# 
# 	#
# 	fun quit_eventloop  session
# 	    =
# 	    do_void_command (session, "quit_eventloop");
# 
# 	#
# 	fun run_eventloop_indefinitely  session
# 	    =
# 	    {   do_void_command (session, "run_eventloop_indefinitely");
# 
# 		loop ()
# 		where
# 		    fun loop ()
# 			=
# 			{   handle_line_from_server  session;
# 			    loop ();
# 			};
# 		end; 
# 	    };
# 
# 	#
# 	fun run_eventloop_once  (session: Session, block_until_event: Bool)
# 	    =
# 	    if (0 == do_int_command (session, "make_window", "make_window" + " " + bool_to_string block_until_event))
# 		FALSE;
# 	    else
# 		TRUE;
# 	    fi;

# Do not edit this or following lines -- they are autogenerated by make-ogl-glue.
# Do not edit this or preceding lines -- they are autogenerated by make-ogl-glue.
    };
end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################

