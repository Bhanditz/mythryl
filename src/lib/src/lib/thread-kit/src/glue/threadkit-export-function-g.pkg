## threadkit-export-function-g.pkg

# Compiled by:
#     src/lib/std/standard.lib


stipulate
    package ci  =  unsafe::mythryl_callable_c_library_interface;	# unsafe				is from   src/lib/std/src/unsafe/unsafe.pkg
    #									# mythryl_callable_c_library_interface	is from   src/lib/std/src/unsafe/mythryl-callable-c-library-interface.pkg
    package cu  =  threadkit_startup_and_shutdown_hooks;		# threadkit_startup_and_shutdown_hooks	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit-startup-and-shutdown-hooks.pkg
    package fat =  fate;						# fate					is from   src/lib/std/src/nj/fate.pkg
    package thr =  thread;						# thread				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread.pkg
    package tq  =  threadkit_queue;					# threadkit_queue			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit-queue.pkg
    package ri  =  runtime_internals;					# runtime_internals			is from   src/lib/std/src/nj/runtime-internals.pkg
    package tim =  time;						# time					is from   src/lib/std/time.pkg
    package ts  =  thread_scheduler;					# thread_scheduler			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler.pkg
    package wnx =  winix;						# winix					is from   src/lib/std/winix.pkg
    #
    fun cfun  fun_name
	=
	ci::find_c_function  { lib_name => "heap",  fun_name };		# heap					is from   src/c/lib/heap/libmythryl-heap.c

herein

    # This generic is invoked (only) by:
    #
    #     src/lib/src/lib/thread-kit/src/glue/thread-scheduler-control-g.pkg
    #
    generic package   threadkit_export_function_g  (
	#								# threadkit_driver_for_posix		is from   src/lib/src/lib/thread-kit/src/posix/threadkit-driver-for-posix.pkg
	drv:  Threadkit_Driver_For_Os					# Threadkit_Driver_For_Os		is from   src/lib/src/lib/thread-kit/src/posix/threadkit-driver-for-os.api
    )
    : (weak)
		api {
		    poll_fate:   fat::Fate( Void );
		    pause_fate:  fat::Fate( Void );

		    Pair (X, Y) =   PAIR (X, Y);

		    wrap_for_export
			:
			((String, List(String)) -> wnx::process::Status,  Null_Or( tim::Time ))
			->  Pair( String, List(String) )
			->  wnx::process::Status;
		}
    {
	poll_fate							# This winds up as the value for   scheduler_hook   in   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler.pkg
	    =
	    fat::make_isolated_fate
		(fn _
		    =
		    {   ts::disable_thread_switching ();
			#
			drv::wake_sleeping_threads_and_schedule_fd_io_and_harvest_dead_children ();
			#
			ts::reenable_thread_switching_and_dispatch_next_thread ();
		    }
		)
	    :  fat::Fate( Void );

	pause_fate							# This winds up as the value for   pause_hook   in   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler.pkg
	    =
	    fat::make_isolated_fate
		(fn _
		    =
		    {   ts::disable_thread_switching();
			#
			drv::wake_sleeping_threads_and_schedule_fd_io_and_harvest_dead_children ();

			# Check for ready threads or pause:
			#
			if (not (tq::is_empty  ts::foreground_run_queue) or drv::pause())
			    #
			    ts::reenable_thread_switching_and_dispatch_next_thread ();
			else
			    ts::reenable_thread_switching ();

			    fat::switch_to_fate   *ts::shutdown_hook   (TRUE, wnx::process::failure);		# 
			fi;
		    }
		)
	    : fat::Fate( Void );


	Pair (X, Y) =   PAIR (X, Y);

							# "Cmdt" might be "command_type"?
	Cmdt =  Pair (String, List(String) )
		->
		wnx::process::Status;


	spawn_to_disk' =   cfun "spawn_to_disk" :   (String, Cmdt) -> Void;


	fun wrap_for_export (f, tq) (PAIR args)
	    =
	    {   ri::initialize_posix_interprocess_signal_handler_table  ();
		#
		thr::reset  TRUE;

		drv::start_threadkit_driver  ();

		ts::scheduler_hook :=  poll_fate;
		ts::pause_hook     :=  pause_fate;

		fun initial_proc ()
		    =
		    wnx::process::exit
			(   f args
			    except
				_ = wnx::process::failure
			);

		my  (clean_up, status)
		    =
		    fat::call_with_current_fate
			(
			 fn done_fate
			    =
			    {   ts::shutdown_hook :=   done_fate;
				#
				case tq
				    #
				    THE tq =>     ts::start_thread_scheduler_timer  tq;
				     _     =>   ts::restart_thread_scheduler_timer  ();
				esac;

				cu::do_actions_for  cu::APP_STARTUP;

				thr::make_thread  "export_function_g"  initial_proc;

				thr::thread_done ();
			    }
			);

		cu::do_actions_for  cu::SHUTDOWN;

		drv::stop_threadkit_driver   ();
		ts::stop_thread_scheduler_timer ();
		thr::reset  FALSE;

		status;
	    };
    };
end;

## COPYRIGHT (c) 1989-1991 John H. Reppy
## COPYRIGHT (c) 1997 Bell Labs, Lucent Technologies.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
