## internal-threadkit-types.pkg
#
# These are the concrete representations of the various threadkit types.
# These types are abstract (or not even visible) outside this library.

# Compiled by:
#     src/lib/std/standard.lib


###	       "The programmer who is not in love with lisp by age twenty has no spirit of adventure.
###		The programmer who is still in love with lisp by age thirty has no common sense."
###
###							-- Walt Filmore


stipulate
    package fat =  fate;					# fate		is from   src/lib/std/src/nj/fate.pkg
herein

    package internal_threadkit_types {

	# Thread IDs --- see
	#
	#     src/lib/src/lib/thread-kit/src/core-thread-kit/thread.pkg
	#
	Thread_State
	    =
	    THREAD_STATE
	      { thread_id:		Int,				# A unique ID. 
		name:			String,				# Purely for display to humans.
		didmail:		Ref( Bool ),			# We set this whenever the thread does some concurrency operation; thread-scheduler favors mail-performing threads.
		#
		exception_handler:	Ref( Exception -> Void ),	# Root-level exception handler hook.
		properties:	        Ref(  List(  Exception ) ),	# Holds thread-local properties.

		dead:			Condition_Variable		# Set when the thread dies. 
	      }


	# One run of the 'select' fn from
	#
	#     src/lib/src/lib/thread-kit/src/core-thread-kit/mailop.pkg
	#
	# will pick and fire exactly one mailop from the given
	# list of mailops (unless that list is empty).  If no
	# mailops on the list are ready to fire, it will block
	# until one is.
	#
	# We use 'selectrun' to designate one such invocation
	# of the 'select' fn, and we use Ref(Selectrun_Status)
	# values to track the status of a selectrun. We set
	# a Ref(Selectrun_Status) to SELECTRUN_IS_COMPLETE
	# when the selectrun is complete, in the sense that
	# no mailop in it is a candidate to fire.
	#
	also
	Selectrun_Status
	  #
	  = SELECTRUN_IS_COMPLETE
	  | SELECTRUN_IS_BLOCKED  Thread_State


	# Condition variables --- see
	#     src/lib/src/lib/thread-kit/src/core-thread-kit/mailop.pkg
	# These are essentially Void-valued oneshot_maildrop instances,
	# and are used for various internal synchronization
	# conditions, e.g., nack mail_ops, I/O synchronization,
	# and thread termination:
	#
	also
	Condition_Variable
	    =
	    CONDITION_VARIABLE  Ref( Condvar_State )

	also
	Condvar_State									# "condvar" == "condition variable".
	  #
	  = CONDVAR_IS_NOT_SET  List							# Unset condvar together with the list of selectruns waiting for it to be set.
				  { selectrun_status:	Ref( Selectrun_Status ),
				    finish_selectrun:	Void -> Void,			# Do any required end-of-selectrun work such as  selectrun_status := SELECTRUN_IS_COMPLETE;  and sending nacks as appropriate.
				    fate:		fate::Fate( Void )
				  }
	  | CONDVAR_IS_SET   Int							# Condvar which has been set.  The int value is a priority counting the number of times that
	  ;										# the condvar has been waited on without firint -- see wait_on_condvar__mailop()   
											# in   src/lib/src/lib/thread-kit/src/core-thread-kit/mailop.pkg

	# When a mailop is not ready to fire, we call a function of this type
	# to put it to sleep (i.e., enter it into appropriate thread wait queues):
	#
	Start_Watching_For_Mailop_Ready_To_Fire__Fn(X)
	  =
	  { selectrun_status:	Ref( Selectrun_Status ),				# This refcell is set to SELECTRUN_IS_COMPLETE when the selectrun is no longer a candidate to fire a mailop. (Either completed or aborted.)
	    finish_selectrun:	Void -> Void,						# Do any required end-of-selectrun work such as  selectrun_status := SELECTRUN_IS_COMPLETE;  and sending nacks as appropriate.
	    next:		Void -> Void
	  }
	  ->
	  X;



	#################################################################
	# Mailops -- see
	#     src/lib/src/lib/thread-kit/src/core-thread-kit/mailop.pkg


	Mailop_Readiness(X)
	  #
	  = MAILOP_IS_READY_TO_FIRE							# MAILOP_IS_READY_TO_FIRE means this select[...] mailop is ready to fire. (select[...] can fire at most one rule per invocation.)
	      {
		priority:	Int,
		fire_mailop:	Void -> X						# We fire a mailop by calling fire_mailop().	Reppy refers to 'fire_mailop' as 'doFn'.
	      }

	  | MAILOP_IS_NOT_READY_TO_FIRE							# MAILOP_IS_NOT_READY_TO_FIRE means this select[...] mailop is not ready to fire.
	      #	
	      Start_Watching_For_Mailop_Ready_To_Fire__Fn(X)
	  ;

	Isready_Mailop(X)								# When 'select' needs to know if a given select rule is ready to fire, it calls a fn of this type.
	    =
	    Void -> Mailop_Readiness(X);

	Mailop(X)
	  = ISREADY_MAILOPS		List( Isready_Mailop(X) )			# This is the meat-and-potatoes usual case.
	  | CHOOSE_MAILOP		List(           Mailop(X) )
	  | DYNAMIC_MAILOP		Void         -> Mailop(X)
	  | DYNAMIC_MAILOP_WITH_NACK	Mailop(Void) -> Mailop(X)
	  ;

	# Useful when debugging threadkit internals:
	#
	fun thread_to_string (THREAD_STATE { thread_id, ... } )
	    =
	    cat [ "[",
		   number_string::pad_left '0' 6 (int::to_string thread_id),
		  "]"
		];

    };
end;

## COPYRIGHT (c) 1989-1991 John H. Reppy
## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
