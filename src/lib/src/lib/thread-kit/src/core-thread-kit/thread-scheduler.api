## thread-scheduler.api
## COPYRIGHT (c) 1989-1991 John H. Reppy

# Compiled by:
#     src/lib/std/standard.lib

# This api is implemented in:
#
#     src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler.pkg

stipulate
    package fat =  fate;						# fate				is from   src/lib/std/src/nj/fate.pkg
    package itt =  internal_threadkit_types;				# internal_threadkit_types	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/internal-threadkit-types.pkg
    package tim =  time;						# time				is from   src/lib/std/time.pkg
    package wnx =  winix;						# winix				is from   src/lib/src/lib/thread-kit/src/win32/winix.pkg
    #
    Fate(X) =  fat::Fate(X);
    Thread  =  itt::Thread;
herein

    api Thread_Scheduler {
	#
	Thread;

	foreground_run_queue:   itt::Threadkit_Queue( (Thread,  Fate( Void)) );

	get_current_thread:  Void -> Thread;
	set_current_thread:  Thread -> Void;

	enqueue_thread:  (Thread, Fate(Void)) -> Void;

	enqueue_and_switch_current_thread:  (Fate(Void), Thread) -> Void;
	    #
	    # Enqueue the given fate with the
	    # current thread ID, and make the
	    # given thread ID be the current one.


	enqueue_tmp_thread:  (Void -> Void) -> Void;
	    #
	    # Create a temporary thread (with dummy ID) to run the given
	    # function and then exit.  The thread is placed on the front
	    # of the scheduling queue.


	Thread_Scheduler_State = MULTI_THREAD | MONO_THREAD | SIGNAL_PENDING;

	thread_scheduler_state:  Ref(  Thread_Scheduler_State );

	disable_thread_switching:  Void -> Void;
	reenable_thread_switching:  Void -> Void;
	    #
	    # Enter/leave a critical section.
	    # These do NOT nest!

	reenable_thread_switching_and_dispatch_next_thread:  Void -> X;
	    #
	    # Leave the critical section
	    # and dispatch the next thread.

	dispatch_next_thread:  Void -> X;
	    #
	    # Dispatch the next thread.
	    #
	    # This should NOT be called
	    # while in a critical section.
	    # In a critical section use:
	    #     reenable_thread_switching_and_dispatch_next_thread ();


	reenable_thread_switching_and_switch_to_thread:  (Thread, Fate(X), X) -> Void;
	    #
	    # Switch to the given thread
	    # while leaving a critical section.

	reenable_thread_switching_and_yield_to_next_thread:  Fate(Void) -> X;
	    #
	    # Yield control to the next thread
	    # while leaving the critical section.


	scheduler_hook:  Ref(  Fate(  Void ) );
	    #
	    # This hook points to a fate that
	    # gets dispatched when a preemption
	    # is received or when a thread exits
	    # a critical section and there is a
	    # signal pending.
	    #
	    # It is invoked after re-enabling
	    # thread scheduling -- that is,
	    # after exiting the critical section.


	pause_hook:  Ref(  Fate(  Void ) );
	    #
	    # This hook points to a fate that gets invoked when
	    # when the scheduler has nothing else to do.


	shutdown_hook:    Ref( Fate ((Bool, wnx::process::Status)) );
	    #
	    # This hook points to a fate that
	    # gets invoked when the system is
	    # otherwise deadlocked.  It is
	    # also invoked by  run_threadkit::shutdown.
	    #
	    # It takes two arguments:
	    #  o A boolean flag that says whether to do clean-up.
	    #  o The exit status.


	get_approximate_time:  Void -> tim::Time;
	    #
	    # Get an approximation of the current time of day.
	    #
	    # The value returned was obtained from the operating
	    # system via
	    #     tim::get_time ();
	    # during the current timeslice, so it is off
	    # by at most the length of that timeslice.


	reset_thread_scheduler:  Bool -> Void;

	# Control over the preemptive timer 
	#
	start_timer:    tim::Time -> Void;
	stop_timer:     Void -> Void;
	restart_timer:  Void -> Void;

	# A tracelog kludge of no general interest:
	#
	trace_backpatchfn: Ref( (Void -> String) -> Void );


	Do_Echo = { what:  String,						# 'what' will be passed to 'reply'.
		    reply: String -> Void
		  };
        echo:  Do_Echo -> Void;							# To be called from other pthreads.
    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
