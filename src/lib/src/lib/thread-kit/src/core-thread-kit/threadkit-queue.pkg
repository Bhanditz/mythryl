## threadkit-queue.pkg
#
# See comments in    src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit-queue.api

# Compiled by:
#     src/lib/std/standard.lib

stipulate
    package itt =  internal_threadkit_types;						# internal_threadkit_types	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/internal-threadkit-types.pkg
herein

    package   threadkit_queue	
    : (weak)  Threadkit_Queue								# Threadkit_Queue		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit-queue.api
    {
	Threadkit_Queue == itt::Threadkit_Queue;

	fun reverse (x,       [], rl) =>  (x, rl);
	    reverse (x, y ! rest, rl) =>  reverse (y, rest, x ! rl);
	end;

	fun reverse_and_prepend (      [], l) =>  l;
	    reverse_and_prepend (x ! rest, l) =>  reverse_and_prepend (rest, x ! l);
	end;

	fun make_threadkit_queue ()
	    =
	    THREADKIT_QUEUE
	      {
		output_list =>  REF [],
		input_list  =>  REF []
	      };

	fun same_queue ( THREADKIT_QUEUE { output_list=>f1, ... },
			 THREADKIT_QUEUE { output_list=>f2, ... }
		       )
	    =
	    f1 == f2;									# Taking advantage of the fact that refcells are equal only to themselves and thus uniquely identify a queue.

	fun queue_is_empty (THREADKIT_QUEUE { output_list => REF [],
                                               input_list => REF []
                                            }
                           )
				=>   TRUE;
	    queue_is_empty _	=>   FALSE;
	end;


	fun push_item_onto_back_of_queue (THREADKIT_QUEUE { input_list, ... }, item)
	    =
	    input_list :=  item  !  *input_list;


	fun pull_item_off_front_of_queue_or_raise_exception (THREADKIT_QUEUE { output_list, input_list } )
	    =
	    case *output_list
		#
		(x ! rest)
		    =>
		    {   output_list := rest;
			x;
		    };

		[] =>   case *input_list
			    #
			    (x ! rest)
				=>
				{   (reverse (x, rest, [])) ->   (y, rr);
				    #	
				    output_list := rr;
				    input_list  := [];
				    y;
				    #	
				};

			    [] =>  raise exception  FAIL "queue is empty";
			esac;

	    esac;


	fun pull_item_off_front_of_queue (THREADKIT_QUEUE { output_list, input_list } )
	    =
	    case *output_list
		#
		(x ! rest)
		    =>
		    {   output_list := rest;
			#
			THE x;
		    };

		[]  =>  case *input_list
			    #
			    (x ! rest)
				=>
				{   (reverse (x, rest, []))
					->
					(y, rr);

				    output_list := rr;
				    input_list  := [];
				    # 
				    THE y;
				};

			    [] => NULL;
			esac;
	    esac;


	fun clear_queue_to_empty (THREADKIT_QUEUE { output_list, input_list } )
	    =
	    {   output_list := [];
		input_list  := [];
	    };

	fun find_first_matching_item_and_remove_from_queue
	      (
		THREADKIT_QUEUE { output_list, input_list },
		predicate
	      )
	    =
	    remove_from_output_list (*output_list, [])
	    where
		fun remove_from_output_list ([], l)
			=>
			remove_from_input_list (*input_list, []);

		    remove_from_output_list (x ! rest, l)
			=>
			if (predicate x)	{   output_list := reverse_and_prepend (l, rest);
						    THE x;
						};	
			else			remove_from_output_list (rest, x ! l);
			fi;
		end 

		also
		fun remove_from_input_list ([], _) =>   NULL;
		    #
		    remove_from_input_list (x ! rest, l)
			=>
			if (predicate x)	{   input_list := reverse_and_prepend (l, rest);
						    THE x;
						};
			else			remove_from_input_list (rest, x ! l);
			fi;
		end;
	    end;
    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1989-1991 John H. Reppy
## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
