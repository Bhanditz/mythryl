## threadkit-io-queen.pkg
#
# See comments in   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit-io-queen.api

# Compiled by:
#     src/lib/std/standard.lib


stipulate
    package fat =  fate;							# fate				is from   src/lib/std/src/nj/fate.pkg
    package itt =  internal_threadkit_types;					# internal_threadkit_types	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/internal-threadkit-types.pkg
    package tim =  time;							# time				is from   src/lib/std/time.pkg
    package ts  =  thread_scheduler;						# thread_scheduler		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler.pkg
    package wnx =  winix;							# winix				is from   src/lib/std/winix.pkg
    package wio =  winix::io;							# winix_io			is from   src/lib/std/src/posix/winix-io.pkg
herein
    # This package gets referenced in:
    #
    #     src/lib/std/src/threadkit/posix/threadkit-winix-io.pkg
    #     src/lib/std/src/socket/threadkit-proto-socket.pkg
    #     src/lib/std/src/posix/threadkit-winix-data-file-io-driver-for-posix.pkg
    #     src/lib/src/lib/thread-kit/src/posix/threadkit-driver-for-posix.pkg
    #
    package  threadkit_io_queen
    : (weak) Threadkit_Io_Queen							# Threadkit_Io_Queen		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit-io-queen.api
    {
	Ioplea_Item
	    =
	    { ioplea:		wio::Ioplea,					# Ioplea =  { io_descriptor: Iod, readable: Bool, writable: Bool, oobdable: Bool };
	      mailop_done:	Ref( itt::Mailop_Done ),			# Mailop_Done = MAILOP_DONE | MAILOP_PENDING_FOR  Thread;
	      #									# We mark an Ioplea_Item as cancelled when some alternate mailop is selected instead.
	      clean_up:         Void -> Void,
	      fate:		fat::Fate( wio::Ioplea_Result )
	    };

	waiting_queue__local =   REF ([]: List( Ioplea_Item ));			# Icky thread-hostile mutable global state...? XXX SUCKO FIXME

	#
	fun check_for_io_opportunities  wait_requests
	    =
	    wio::wait_for_io_opportunity					# In some OSs (e.g., Linux) this may raise an EINTR error even though it is non-blocking.
	      {
		wait_requests,
		timeout => THE tim::zero_time
	      }
	    except
		_ = [];

										# NOTE:  As in the case of condition variables -- see 
										#     src/lib/src/lib/thread-kit/src/core-thread-kit/mailop.pkg
										# -- we need to do the clean_up routine when we enable the
										# io_mailop (instead of in the wait_for fate).
	#
	fun make_io_mailop  ioplea						# This fn is called (only) from   src/lib/std/src/threadkit/posix/threadkit-winix-io.pkg
	    =									#				  src/lib/std/src/socket/threadkit-proto-socket.pkg
	    itt::ISREADY_MAILOPS [is_ready]					#				  src/lib/std/src/posix/threadkit-winix-data-file-io-driver-for-posix.pkg
	    where

		fun wait_for { mailop_done, clean_up, next }							# Reppy calls this fn blockFn
		    =
		    an_ioplea							
		    where
			an_ioplea  =   fat::call_with_current_fate
				    (
				     fn fate
					=
					{   item =  { ioplea, mailop_done, clean_up, fate };
					    #
					    waiting_queue__local :=  item  !  *waiting_queue__local;
					    #
					    next ();
					    raise exception FAIL "make_io_mailop -- next() returned";		# next() should never return.
					}
				    );
		    end;

		fun is_ready ()											# Reppy calls this fn pollFn: If it returns MAILOP_READY   then the rule is     a candidate to fire in the select [] call;
		    =												#                             If it returns MAILOP_UNREADY then the rule is not a candidate to fire in the select [] call.
		    case (check_for_io_opportunities  [ioplea])
			#
			[an_ioplea]
			    =>
				itt::MAILOP_READY
				  {
				    priority		=>   -1,
				    #
				    fire_select_rule    => .{   ts::reenable_thread_switching ();		# Reppy refers to 'fire_select_rule' as 'doFn'.
								an_ioplea;
							    }
				  };

			_   =>  itt::MAILOP_UNREADY  wait_for;
		    esac;
	    end;


	fun same_ioplea (an_ioplea, ioplea)									# This is an internal fn, not exported to clients.
	    =
	    an_ioplea == ioplea;


	fun drop_cancelled_mailops  wait_queue
	    =
	    # We return the thinned I/O waiting queue
	    # along with the list of wait_requests in it.
	    #
	    # NB: Both will be in reverse order relative
	    # to wait_queue arg:
	    #
	    drop_cancelled_mailops' (wait_queue, [], [])
	    where
		fun drop_cancelled_mailops' ([] : List( Ioplea_Item ),   wait_requests,   wait_queue)
			=>
			(wait_requests, wait_queue);		    											# Done.

		    drop_cancelled_mailops' ({ mailop_done => REF itt::MAILOP_DONE, ... } ! rest,   wait_requests,   wait_queue)
			=>
			drop_cancelled_mailops' (rest, wait_requests, wait_queue);									# Drop completed/cancelled mailop.

		    drop_cancelled_mailops' ((item as { ioplea, ... } ) ! rest,   wait_requests,   wait_queue)
			=>
			drop_cancelled_mailops'														# Pass everything else through.
			  ( rest,
			    ioplea  !  wait_requests,
			    item          !  wait_queue
			  );
		end;
	    end;


	fun push_io_onto_run_queue								# Private to this file.
		( { mailop_done as REF (itt::MAILOP_PENDING_FOR thread),				# The wait_queue entry corresponding to 'an_ioplea'.
		    clean_up,
		    fate,
		    ioplea
		  },
		  an_ioplea										# The I/O opportunity now open.
		)
		=>
		# Enqueue a thread that is polling on the ready queue.
		#
		# We need two call_with_current_fate calls here:
		#
		#  o One to capture current fate, so we can continue
		#    with it when we are done.
		#
		#  o One to construct the fate we are going to enter
		#    into the run queue.  This mainly consists of
		#    combining our 'fate' arg with our 'an_ioplea' arg to
		#    produce a new fate implicitly wrapping both.
		#
		# We also must catch the case where the mailop
		# has been canceled, since a single thread might be
		# polling on multiple descriptors.
		#
		{   fate_ioplea = fat::call_with_current_fate						# 'fate_ioplea' is essentially 'fate ioplea'.  It has type  Fate(Void).
				(
				 fn main_fate								# 'main_fate' represents the vanilla computation starting below with   mailop_done := ...
				    =
				    {   fat::call_with_current_fate
					    (fn fate_ioplea							# 'fate_ioplea' represents the computation  'fat::switch_to_fate fate ioplea'.
					        =							# (Since switch_to_fate never returns, that is the whole of 'fate_ioplea'.)
						fat::switch_to_fate  main_fate  fate_ioplea);		# This arranges for the main fate to execute as expected.  Without this line
					#								# we'd immediately run off and do  'switch_to_fate fate ioplea' and the mailop_done := ... ; ... stuff would never execute.
					fat::switch_to_fate  fate  an_ioplea;
				    }
				);

		    mailop_done :=  itt::MAILOP_DONE;

		    clean_up ();

		    ts::push_into_run_queue (thread, fate_ioplea);
		};

	    push_io_onto_run_queue ( { mailop_done => REF itt::MAILOP_DONE, ... }, _)
		=>
		();
	end;


	fun add_any_new_fd_io_opportunities_to_run_queue ()						# This is an external entrypoint into this file.
	    =												# This fn is called (only) from:	src/lib/src/lib/thread-kit/src/posix/threadkit-driver-for-posix.pkg
	    case (drop_cancelled_mailops  *waiting_queue__local)
		#	  
		([], _) =>    waiting_queue__local :=   [];
		#
		(wait_requests, wait_queue)								# NB: wait_requests and wait_queue are both reverse-order relative to  *waiting_queue__local.
		    =>
		    case (check_for_io_opportunities  wait_requests)
			#
			[] =>  waiting_queue__local :=   reverse  wait_queue;				# The 'reverse' restores original *waiting_queue__local ordering.
			#
			l  => filter (l, wait_queue, [])
			      where
				  fun filter ([], r, result_wait_queue)
					  =>
					  waiting_queue__local
					      :=
					      list::reverse_and_prepend (r, result_wait_queue);		# Reverse 'r' and prepend it to (already-re-reversed) result_wait_queue.

				      filter
					  ( an_ioplea ! iopleas,					# (Remaining) list of I/O opportunities identified by check_for_io_opportunities.
					    (item:  Ioplea_Item) ! items,				# (Remaining) reversed wait_queue.
					    result_wait_queue						# 
					  )
					  =>
					  if (same_ioplea (an_ioplea, item.ioplea))			# We're searching down our wait_queue for the item matching 'an_ioplea'.
					      #								# Aha -- found the wait_queue item matching 'an_ioplea'.
					      push_io_onto_run_queue (item, an_ioplea);			# Schedule the I/O corresponding to 'an_ioplea'.
					      filter (iopleas, items, result_wait_queue);		# Drop I/O opportunity from wait list.
					  else
					      filter (an_ioplea ! iopleas,  items,  item ! result_wait_queue);	# Not the right item -- move it to result_wait_queue and keep searching down wait_queue.
					  fi;

				      filter _ =>   raise exception  FAIL "Compiler bug: Unsupported case in add_any_new_fd_io_opportunities_to_run_queue/filter.";
				  end;
			      end;
		    esac;

	    esac;


	fun have_fds_on_io_watch ()
	    =
	    case *waiting_queue__local
		#
		[] => FALSE;
		 _ => TRUE;
	    esac;

    };
end;



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1989-1991 John H. Reppy
## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
