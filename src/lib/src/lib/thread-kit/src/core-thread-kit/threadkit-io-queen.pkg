## threadkit-io-queen.pkg
#
# See comments in   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit-io-queen.api

# Compiled by:
#     src/lib/std/standard.lib


stipulate
    package fat =  fate;							# fate				is from   src/lib/std/src/nj/fate.pkg
    package itt =  internal_threadkit_types;					# internal_threadkit_types	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/internal-threadkit-types.pkg
    package tim =  time;							# time				is from   src/lib/std/time.pkg
    package ts  =  thread_scheduler;						# thread_scheduler		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler.pkg
    package wnx =  winix;							# winix				is from   src/lib/std/winix.pkg
    package wio =  winix::io;							# winix_io			is from   src/lib/std/src/posix/winix-io.pkg
herein
    # This package gets referenced in:
    #
    #     src/lib/std/src/threadkit/posix/threadkit-winix-io.pkg
    #     src/lib/std/src/socket/threadkit-pre-socket.pkg
    #     src/lib/std/src/posix/threadkit-winix-data-file-io-driver-for-posix.pkg
    #     src/lib/src/lib/thread-kit/src/posix/threadkit-driver-for-posix.pkg
    #
    package  threadkit_io_queen
    : (weak) Threadkit_Io_Queen							# Threadkit_Io_Queen		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit-io-queen.api
    {
	Io_Wait_Item
	    =
	    { wait_request:     wio::Wait_Request,				# Wait_Request =  { io_descriptor: Iod, readable: Bool, writable: Bool, oobdable: Bool };
	      mailop_state:   Ref( itt::Mailop_State ),				# Mailop_State = MAILOP_DONE | MAILOP_THREAD  Thread;
	      #									# We mark an Io_Wait_Item as cancelled when some alternate mailop is selected instead.
	      clean_up:         Void -> Void,
	      fate:		fat::Fate( wio::Wait_Result )
	    };

	waiting_queue__local =   REF ([]: List( Io_Wait_Item ));		# Icky thread-hostile mutable global state...? XXX SUCKO FIXME

	# In some OSs (e.g., Linux)
	# this may raise an EINTR error,
	# even though it is non-blocking.
	#
	fun check_for_io_opportunities  wait_requests
	    =
	    wio::wait_for_io_opportunity  { wait_requests,  timeout => THE tim::zero_time }
	    except
		_ = [];

	# NOTE:  As in the case of condition variables -- see 
	#     src/lib/src/lib/thread-kit/src/core-thread-kit/mailop.pkg
	# -- we need to do the clean_up routine when we enable the
	# io_mailop (instead of in the wait_for fate).
	#
	fun io_mailop  wait_request
	    =
	    itt::BASE_MAILOPS [is_ready]
	    where

		fun wait_for { mailop_state, clean_up, next }					# Reppy calls this fn blockFn
		    =
		    pi										# "pi" seems to be a Reppy abbreviation for "poll info" == "wait request"
		    where
			pi  =   fat::call_with_current_fate
				    (
				     fn fate
					=
					{   item =  { wait_request, mailop_state, clean_up, fate };
					    #
					    waiting_queue__local :=  item  !  *waiting_queue__local;
					    #
					    next ();
					    raise exception FAIL "impossible: io_mailop";
					}
				    );
		    end;

		fun is_ready ()									# Reppy calls this fn pollFn
		    =
		    case (check_for_io_opportunities  [wait_request])
			#
			[pi] =>  itt::MAILOP_READY
				   { priority  =>  -1,
				     do_it     =>  .{  ts::reenable_thread_switching ();   pi;  }	# Reppy calls this field doFn
				   };

			_    =>  itt::MAILOP_UNREADY wait_for;
		    esac;
	    end;


	fun same_descriptor (pi, wait_request)
	    =
	    pi == wait_request;


	fun drop_cancelled_mailops  wait_queue
	    =
	    # We return the thinned I/O waiting queue
	    # along with the list of wait_requests in it.
	    #
	    # NB: Both will be in reverse order relative
	    # to wait_queue arg:
	    #
	    drop_cancelled_mailops' (wait_queue, [], [])
	    where
		fun drop_cancelled_mailops' ([] : List( Io_Wait_Item ),   wait_requests,   wait_queue)
			=>
			(wait_requests, wait_queue);		    											# Done.

		    drop_cancelled_mailops' ({ mailop_state => REF itt::MAILOP_DONE, ... } ! rest,   wait_requests,   wait_queue)
			=>
			drop_cancelled_mailops' (rest, wait_requests, wait_queue);									# Drop completed/cancelled mailop.

		    drop_cancelled_mailops' ((item as { wait_request, ... } ) ! rest,   wait_requests,   wait_queue)
			=>
			drop_cancelled_mailops'													# Pass everything else through.
			  ( rest,
			    wait_request  !  wait_requests,
			    item          !  wait_queue
			  );
		end;
	    end;


	fun put_io_opportunity_in_run_queue								# Private to this file.
		( { mailop_state as REF (itt::MAILOP_THREAD thread),					# The wait_queue entry corresponding to 'pi'.
		    clean_up,
		    fate,
		    wait_request
		  },
		  pi											# The I/O opportunity now open.  ("pi" is reppy-ese for "poll info" (== wait request).) 
		)
		=>
		# Enqueue a thread that is polling on the ready queue.
		#
		# We have to do some fate hacking to pass the
		# poll info to the thread.
		#
		# We also must catch the case where the mailop
		# has been canceled, since a single thread might be
		# polling on multiple descriptors.
		#
		{   fate_pi = fat::call_with_current_fate						# 'fate_pi' is essentially 'fate pi'.  It has type  Fate(Void).
				(
				 fn main_fate								# 'main_fate' represents the vanilla computation starting below with   mailop_state := ...
				    =
				    {   fat::call_with_current_fate
					    (fn fate_pi							# 'fate_pi' represents the computation  'fat::run_fate fate pi'.
					        =							# (Since run_fate never returns, that is the whole of 'fate_pi'.)
						fat::run_fate  main_fate  fate_pi);			# This arranges for the main fate to execute as expected.  Without this line
					#								# we'd immediately run off and do  'run_fate fate pi' and the mailop_state := ... ; ... stuff would never execute.
					fat::run_fate  fate  pi;
				    }
				);

		    mailop_state :=  itt::MAILOP_DONE;

		    clean_up ();

		    ts::add_to_run_queue (thread, fate_pi);
		};

	    put_io_opportunity_in_run_queue ( { mailop_state => REF itt::MAILOP_DONE, ... }, _)
		=>
		();
	end;


	fun add_any_new_fd_io_opportunities_to_run_queue ()						# This is an external entrypoint into this file.
	    =												# This fn is called (only) from:	src/lib/src/lib/thread-kit/src/posix/threadkit-driver-for-posix.pkg
	    case (drop_cancelled_mailops  *waiting_queue__local)
		#	  
		([], _) =>    waiting_queue__local :=   [];
		#
		(wait_requests, wait_queue)								# NB: wait_requests and wait_queue are both reverse-order relative to  *waiting_queue__local.
		    =>
		    case (check_for_io_opportunities  wait_requests)
			#
			[] =>  waiting_queue__local :=   reverse  wait_queue;				# The 'reverse' restores original *waiting_queue__local ordering.
			#
			l  => filter (l, wait_queue, [])
			      where
				  fun filter ([], r, result_wait_queue)
					  =>
					  waiting_queue__local
					      :=
					      list::reverse_and_prepend (r, result_wait_queue);		# Reverse 'r' and prepend it to (already-re-reversed) result_wait_queue.

				      filter
					  ( pi ! pis,							# (Remaining) list of I/O opportunities identified by check_for_io_opportunities.
					    (item:  Io_Wait_Item) ! items,				# (Remaining) reversed wait_queue.
					    result_wait_queue						# 
					  )
					  =>
					  if (same_descriptor (pi, item.wait_request))			# We're searching down our wait_queue for the item matching 'pi'.
					      #								# Aha -- found the wait_queue item matching 'pi'.
					      put_io_opportunity_in_run_queue (item, pi);		# Schedule the I/O corresponding to 'pi'.
					      filter (pis, items, result_wait_queue);			# Drop I/O opportunity from wait list.
					  else
					      filter (pi ! pis,  items,  item ! result_wait_queue);	# Not the right item -- move it to result_wait_queue and keep searching down wait_queue.
					  fi;

				      filter _ =>   raise exception  FAIL "Compiler bug: Unsupported case in add_any_new_fd_io_opportunities_to_run_queue/filter.";
				  end;
			      end;
		    esac;

	    esac;


	fun have_fds_on_io_watch ()
	    =
	    case *waiting_queue__local
		#
		[] => FALSE;
		 _ => TRUE;
	    esac;

    };
end;



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1989-1991 John H. Reppy
## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
