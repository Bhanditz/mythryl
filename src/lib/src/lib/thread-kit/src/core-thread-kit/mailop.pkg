## mailop.pkg

# Compiled by:
#     src/lib/std/standard.lib



# Implementation of mailop values and the mailop combinators.
#
# Some important requirements on the implementation
# of base mailop values:
#
#  1)  An is_ready, do_it or wait_for function
#      is always called from inside an atomic region.
#
#  2)  An is_ready returns an integer priority.
#      This is   0 when not enabled,
#	        -1 for fixed priority and
#               >0 for dynamic priority.
#      The standard scheme is to associate a counter
#      with the underlying synchronization value and
#      to increase it by one for each synchronization attempt.
#
#  3)  A wait_for is responsible for exiting the atomic region.
#      A do_it should NOT leave the atomic region.
#
#  4)  Each wait_for is responsible for executing the
#      "clean_up" action prior to leaving the atomic region.


stipulate
    package fat =  fate;							# fate				is from   src/lib/std/src/nj/fate.pkg
    package itt =  internal_threadkit_types;					# internal_threadkit_types	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/internal-threadkit-types.pkg
    package rwq =  rw_queue;							# rw_queue			is from   src/lib/src/rw-queue.pkg
    package ts  =  thread_scheduler;						# thread_scheduler		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler.pkg
herein

    package mailop: (weak)
			    api {
				include Mailop;					# Mailop			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/mailop.api
				#
				atomic_cvar_set:   itt::Condition_Variable -> Void;
				cvar_get_mailop:   itt::Condition_Variable -> Mailop( Void );
			    }
    {
	call_with_current_control_fate	=  fat::call_with_current_control_fate;
	switch_to_control_fate		=  fat::switch_to_control_fate;
	call_with_current_fate		=  fat::call_with_current_fate;
#	switch_to_fate			=  fat::switch_to_fate;

	# Some inline functions
	# to improve performance:

	fun map f
	    =
	    map'
	    where
		fun map' [] => [];
		    map' [a] => [f a];
		    map' [a, b] => [f a, f b];
		    map' [a, b, c] => [f a, f b, f c];
		    map' (a ! b ! c ! d ! r) => (f a) ! (f b) ! (f c) ! (f d) ! (map' r);
		end;
	    end;

	fun apply f
	    =
	    apply'
	    where
		fun apply' [] => ();
		    apply' (x ! r) => { f x; apply' r;};
		end;
	    end;

	fun fold_left f init l
	    =
	    foldf (l, init)
	    where
		fun foldf ([], accum) => accum;
		    foldf (x ! r, accum) => foldf (r, f (x, accum));
		end;
	    end;

	fun error msg
	    =
	    raise exception FAIL msg;

	Mailop_Status ==  itt::Mailop_Status;
	Mailop        ==  itt::Mailop;
	Base_Mailop(X) =  itt::Base_Mailop(X);


	# Condition variables.
	#
	# Because these variables are set inside
	# atomic regions we have to use different
	# conventions for clean-up, etc.  Instead
	# of requiring the wait_for fate
	# to call the clean_up action and to leave
	# the atomic region, we call the clean_up
	# function when setting the condition variable
	# (in atomic_cvar_set), and have the invariant
	# that the wait_for fate is dispatched
	# outside the atomic region.


	# Set a condition variable.
	# We assume that this function is always
	# executed in an atomic region.
	#
	fun atomic_cvar_set (itt::CONDITION_VARIABLE state)
	    =
	    case *state
		#
		itt::CVAR_UNSET  waiting
		    =>
		    {   ts::foreground_run_queue ->  rwq::RW_QUEUE { back, ... };
			#
			state :=    itt::CVAR_SET  1;
			#
			back
			    :=
			    add  waiting
			    where
				fun add [] =>   *back;
				    #
				    add ( { mailop_state=>REF itt::MAILOP_DONE, ... } ! rest)
					=>
					add rest;									# Drop cancelled transaction.

				    add ( { mailop_state as REF (itt::MAILOP_THREAD tid), clean_up, fate } ! rest)
					=>
					{   mailop_state :=   itt::MAILOP_DONE;
					    #
					    clean_up ();

					    (tid, fate)  !  (add rest);
					};
				end;
			    end;
		    };

		 _ => error "cvar already set";
	    esac;


	# The mailop constructor for
	# waiting on a condition variable:
	#
	fun cvar_get_mailop (itt::CONDITION_VARIABLE  state)
	    =
	    BASE_MAILOPS [is_ready]
	    where 
		fun wait_for { mailop_state, clean_up, next }				# Reppy calls this fn blockFn
		    =
		    call_with_current_fate
			(fn fate
			    =
			    {   waiting =   case *state    itt::CVAR_UNSET waiting =>	waiting;
						 /* */     _                       =>	raise exception FAIL "Library bug: Unsupported case in cvar_get_mailop";
					    esac;					# Above case is impossible because is_ready only queues us up if *state is not CVAR_SET.
				#
				item =  { mailop_state,  clean_up,  fate };

				state :=  itt::CVAR_UNSET (item ! waiting);

				next ();
			    }
			);

		fun is_ready ()									# Reppy calls this fn pollFn
		    =
		    case *state
			#
			itt::CVAR_SET n
			    =>
			    {   state := itt::CVAR_SET (n+1);
				#
				MAILOP_READY { priority => n, do_it }
				where
				    fun do_it ()						# Reppy calls this fn doFn
					=
					{   state :=  itt::CVAR_SET  1;
					    #
					    ts::reenable_thread_switching ();
					};
				end;
			    };

			_ => MAILOP_UNREADY wait_for;
		    esac;
	    end;


	# A mailop which is always ready
	# and produces given result:
	#
	fun always_mailop  result
	    =
	    BASE_MAILOPS
	      [
		fn () = itt::MAILOP_READY
			  { priority  =>  -1,
			    do_it =>  fn () = {   ts::reenable_thread_switching ();		# Reppy calls this field doFn
						  result;
					      }
			  }
	      ];

	never = BASE_MAILOPS [];								# A mailop which is never ready:

	guard = GUARD;

	with_nack = WITH_NACK;
												# "bevt" == "base event"
	fun choose (el:  List(  Mailop(X) ))
	    =
	    gather_bevts (reverse el, [])
	    where
		fun gather_bevts ([], l) => BASE_MAILOPS l;
		    gather_bevts (BASE_MAILOPS [] ! r, l) => gather_bevts (r, l);
		    gather_bevts (BASE_MAILOPS [bev] ! r, base_mailops') => gather_bevts (r, bev ! base_mailops');
		    gather_bevts (BASE_MAILOPS base_mailops ! r, base_mailops') => gather_bevts (r, base_mailops @ base_mailops');
		    gather_bevts (mailops, []) => gather (mailops, []);
		    gather_bevts (mailops, l) => gather (mailops, [BASE_MAILOPS l]);
		end 

		also
		fun gather ([], [mailop]) => mailop;
		    gather ([], mailops) => CHOOSE mailops;
		    gather (CHOOSE mailops ! r, mailops') => gather (r, mailops @ mailops');
		    gather (BASE_MAILOPS base_mailops ! r, BASE_MAILOPS base_mailops' ! r') => gather (r, BASE_MAILOPS (base_mailops @ base_mailops') ! r');
		    gather (mailop ! r, mailops') => gather (r, mailop ! mailops');
		end;
	    end;

	fun wrap (mailop, wfn)				# ==>  op.
	    =
	    wrap' mailop
	    where
		fun wrap_base_mailop  is_ready  ()
		    =
		    case (is_ready ())
			#
			MAILOP_READY { priority, do_it } =>  MAILOP_READY { priority, do_it => wfn o do_it };
			MAILOP_UNREADY wait_for          =>  MAILOP_UNREADY (wfn o wait_for);
		    esac;

		fun wrap' (BASE_MAILOPS base_mailops)    =>  BASE_MAILOPS (map  wrap_base_mailop  base_mailops);
		    #
		    wrap' (CHOOSE mailops)               =>  CHOOSE (map wrap' mailops);
		    wrap' (GUARD g)                      =>  GUARD (fn () = wrap (g(), wfn));
		    wrap' (WITH_NACK f)                  =>  WITH_NACK (fn mailop = wrap (f mailop, wfn));
		end;
	    end;

	(==>) = wrap;					# Infix synonym for readability.

	fun wrap_handler (mailop, hfn)
	    =
	    wrap' mailop
	    where
		fun wrap f x
		    =
		    f x
		    except
			exn = hfn exn;

		fun wrap_base_mailop  is_ready ()
		    =
		    case (is_ready ())
			#
			MAILOP_READY { priority, do_it } =>  MAILOP_READY { priority, do_it => wrap do_it };
			MAILOP_UNREADY wait_for          =>  MAILOP_UNREADY (wrap wait_for);
		    esac;

		fun wrap' (BASE_MAILOPS base_mailops)	=>  BASE_MAILOPS (map wrap_base_mailop base_mailops);
		    #
		    wrap' (CHOOSE mailops)		=>  CHOOSE (map wrap' mailops);
		    wrap' (GUARD g)			=>  GUARD  (fn ()  = wrap_handler (g(), hfn));
		    wrap' (WITH_NACK f)			=>  WITH_NACK (fn mailop = wrap_handler (f mailop, hfn));
		end;
	    end;

	Mailop_Group(X)
	  = BASE_GROUP  List( Base_Mailop(X) )
	  | GROUP       List( Mailop_Group(X) )
	  | NACK_GROUP  (itt::Condition_Variable, Mailop_Group(X))
	  ;

    /* +DEBUG
    fun sayGroup (msg, eg) = let
	  fun f (BASE_GROUP l, sl) = "BASE_GROUP(" ! int::to_string (list::length l) ::()) ! sl
	    | f (GROUP l, sl) = "GROUP(" ! g (l, ")" ! sl)
	    | f (NACK_GROUP l, sl) = "NACK_GROUP(" ! f(#2 l, ")" ! sl)
	  also g ([], sl) = sl
	    | g ([x], sl) = f (x, sl)
	    | g (x ! r, sl) = f (x, ", " ! g (r, sl))
	  in
	    Debug::sayDebugId (string::cat (msg ! ": " ! f (eg, ["\n"])))
	  end
    -DEBUG*/

	# Prepare mailop expression to run.
        # In particular, this evaluates all
        # guards in the expression:
	#
	fun prepare (BASE_MAILOPS l) =>   BASE_GROUP l;
	    #
	    prepare mailop
		=>
		prepare' mailop
		where
		    fun prepare' (GUARD g)
			    =>
			    prepare' (g ());

			prepare' (WITH_NACK f)
			    =>
			    {   cvar = itt::CONDITION_VARIABLE (REF (itt::CVAR_UNSET []));
				#
				NACK_GROUP (cvar, prepare' (f (cvar_get_mailop cvar)));
			    };

			prepare' (BASE_MAILOPS  baseops)
			    =>
			    BASE_GROUP  baseops;

			prepare' (CHOOSE mailops)
			    =>
			    prepare_baseops (mailops, [])				# Optimistically assume baseops-only; we'll fall back to general prepare_mailops() routine if we're wrong.
			    where
				fun prepare_baseops ([], baseops)
					=>
					BASE_GROUP baseops;

				    prepare_baseops (mailop ! rest, baseops')
					=>
					case (prepare' mailop)
					    #
					    BASE_GROUP baseops =>  prepare_baseops (rest,  baseops @             baseops' );
					    GROUP      mailops =>  prepare_mailops (rest,  mailops @ [BASE_GROUP baseops']);
					               mailops =>  prepare_mailops (rest, [mailops,   BASE_GROUP baseops']);
					esac;
				end

				also
				fun prepare_mailops ([], [group]) =>  group;		# This fn handles the general case vs prepare_baseops above handling the nice simple (and common) case.
				    prepare_mailops ([], l)       =>  GROUP l;

				    prepare_mailops (mailop ! rest, l)
					=>
					case (prepare' mailop, l)
					    #				      
					    (BASE_GROUP baseops, BASE_GROUP baseops' ! rest')
						=>
						prepare_mailops (rest, BASE_GROUP (baseops @ baseops') ! rest');

					    (GROUP mailops, l) =>   prepare_mailops (rest, mailops @ l);
					    (      mailops, l) =>   prepare_mailops (rest, mailops ! l);		# Here 'mailops' can be BASE_GROUP or NACK_GROUP.
				       esac;
	end;    end;  end;  end;end;


	stipulate
	    #
	    count =  REF 0;					# Runs circularly around range 0..999,999
	    #
	    fun pick_fairly i					# The point here is just to pick fairly among 'i' alternative ready mailops,
		=						# so that we don't consistently pass over any one ready mailop.
		{   j =  *count;
		    #
		    if (j == 1000000)   count := 0;
		    else                count := j+1;
		    fi;

		    int::rem (j, i);
		};
	herein

	    fun select_do_fn ([(_, do_it)], _)
		    =>
		    do_it;

		select_do_fn (l, n)
		    =>
		    max (l, 0, 0, [])
		    where

			fun priority -1 =>  n;
			    priority  p =>  p;
			end;

			fun max ((p, do_it) ! rest,  max_p,  k,  do_its)
				=>
				{   p =  priority p;
				    #
				    if    (p >  max_p)   max (rest,     p, 1,          [do_it]);
				    elif  (p == max_p)   max (rest, max_p, k+1, do_it ! do_its);
				    else                 max (rest, max_p, k,           do_its);
				    fi;
				};

			    max ([], _, k, [do_it])
				=>
				do_it;

			    max ([], _, k, do_its)
				=>
				list::nth (do_its, pick_fairly k);
			end;
		    end;
	     end;
	end;

	fun make_flag ()
	    =
	    {   flag =  REF (itt::MAILOP_THREAD (ts::get_current_thread()));
		#
		(flag,  fn () =  flag := itt::MAILOP_DONE);
	    };


	stipulate
	    fun run_one_mailop  (is_ready:  Base_Mailop(X))
		=
		{   ts::disable_thread_switching ();
		    #
		    case (is_ready ())
			#	      
			MAILOP_READY { do_it, ... }					# Reppy calls this field doFn
			    =>
			    do_it ();

			MAILOP_UNREADY wait_for
			    =>
			    {   (make_flag ()) ->   (flag, set_flag);
				#
				wait_for  { mailop_state =>  flag,
					    clean_up     =>  set_flag,
					    next         =>  ts::reenable_thread_switching_and_dispatch_next_thread
					  };
			    };
		    esac;
		};
	herein

	    # This function handles the case of
	    # synchronizing on a list of base mailops
	    # (w/o any negative acknowledgements).
	    #
	    # It also handles the case of synchronizing
	    # on NEVER.
	    #
	    fun run_prepared_baseops []    =>  ts::dispatch_next_thread ();
		run_prepared_baseops [bev] =>  run_one_mailop  bev;
		#
		run_prepared_baseops  baseops
		    =>
		    {   ts::disable_thread_switching ();
			#
			run_baseops (baseops, []);
		    }
		    where
			fun run_baseops (is_ready ! rest,  wait_fors)								# In this loop we have not yet found any baseops ready to fire.
				=>
				case (is_ready ())
				    #
				    MAILOP_UNREADY wait_for          =>  run_baseops       (rest, wait_for ! wait_fors);
				    MAILOP_READY { priority, do_it } =>  run_ready_baseops (rest, [(priority, do_it)], 1);
				esac;

			    run_baseops ([], wait_fors)										# Done -- no ready-to-fire baseops found and no candidates left to check.
				=>
				call_with_current_control_fate
				    (fn fate
					=
					{   switch_to_control_fate =  switch_to_control_fate  fate;
					    #
					    (make_flag ()) ->   (mailop_state, set_flag);

					    fun log [] =>   ts::reenable_thread_switching_and_dispatch_next_thread ();
						#
						log (wait_for ! r)
						    =>
						    switch_to_control_fate
							(wait_for
							  { mailop_state,
							    clean_up =>  set_flag,
							    next     =>  fn () = log r
							  }
							);
					    end;

					    log  wait_fors;

					    error "[log]";
					}
				    );
			end

			# NOTE: Maybe we should just keep
			#       track of the max priority?
			#       What about fairness to fixed
			#       priority mailops (e::g., always, timeout?)

			also
			fun run_ready_baseops (is_ready ! r,  do_its,  n)								# In this loop we have found at least one baseop ready to fire.
				=>
				case (is_ready ())
				    #
				    MAILOP_READY { priority, do_it } =>  run_ready_baseops (r, (priority, do_it) ! do_its, n+1);
				    _                                =>  run_ready_baseops (r, do_its, n);
				esac;

			    run_ready_baseops ([],  do_its,  n)
				=>
				select_do_fn  (do_its, n)  ();										# Select a base mailop to fire and then fire it.
			end;
		    end;
	    end;
	end;

	# Walk the mailop group tree,
	# collecting the base mailops
	# (with associated ack flags),
	# also a list of flagsets.
	#
	# A flag set is a
	#     (cCar, List(Flag(Ack)))
	# pair, where the flags are
	# those associated with the
	# mailops covered by the nack
	# cvar.
	#
	fun collect_baseops_and_flagsets_from_mailops  mailops
	    =
	    case mailops
		#
		GROUP _ =>
		    gather (mailops, [], [])
		    where 
			un_wrapped_flag =  REF FALSE;

			fun append (bev ! rest, results) =>  append (rest, (bev, un_wrapped_flag) ! results);
			    append ([],         results) =>  results;
			end;

			fun gather (BASE_GROUP baseops, bl, flg_sets)
				=>
				(append (baseops, bl), flg_sets);

			    gather (GROUP group, bl, flg_sets)
				=>
				fold_left  f  (bl, flg_sets)  group
				where
				    fun f (group', (bl', flg_sets'))
					=
					gather (group', bl', flg_sets');
				end;

			    gather (group as NACK_GROUP _, bl, flg_sets)
				=>
				gather_wrapped (group, bl, flg_sets);
			end;
		    end;

		group =>   gather_wrapped (group, [], []);
	    esac
	    where
	        un_wrapped_flag =   REF FALSE;
		#
		fun gather_wrapped (group, bl, flg_sets)
			=
			{    (gather (group, bl, [], flg_sets))
				->
				(bl, _, flg_sets);

			    (bl, flg_sets);
			}
			where
			    fun gather (BASE_GROUP baseops, bl, all_flgs, flg_sets)
				    =>
				    {	(append (baseops, bl, all_flgs))
					    ->
					    (bl', all_flgs');

					(bl', all_flgs', flg_sets);
				    }
				    where
				        fun append ([], bl, all_flgs)
						=>
						(bl, all_flgs);

					    append (bev ! r, bl, all_flgs)
						=>
						{   flag = REF FALSE;
						    #
						    append (r, (bev, flag) ! bl, flag ! all_flgs);
						};
					end;
				    end;


				gather (GROUP group, bl, all_flgs, flg_sets)
				    =>
				    fold_left  f  (bl, all_flgs, flg_sets)  group
				    where
				        fun f (group', (bl', all_flgs', flg_sets'))
					    =
					    gather (group', bl', all_flgs', flg_sets');
				    end;

				gather (NACK_GROUP (cvar, group), bl, all_flgs, flg_sets)
				    =>
				    {   (gather (group, bl, [], flg_sets))
					    ->
					    (bl', all_flgs', flg_sets');

					(bl', all_flgs' @ all_flgs, (cvar, all_flgs') ! flg_sets');
				    };
			    end;									# fun gather
			end;										# where
	    end;											# where

	# This function handles the more
	# complicated case of running a
	# mailop expression where negative
	# acknowledgements are involved.
	#
	fun run_prepared_mailops  group
	    =
	    {	ts::disable_thread_switching ();
		#
		run_mailops (bl, []);
	    }
	    where
	        (collect_baseops_and_flagsets_from_mailops  group)
		    ->
		    (bl, flg_sets);

		fun check_cvars ()
		    =
		    apply check_cvar flg_sets
		    where
			# check_cvar checks the flags of a flag set.
			# If they are all FALSE then the
			# corresponding cvar is set to signal
			# the negative ack.
			#
			fun check_cvar (cvar, flgs)
			    =
			    check_flgs flgs
			    where
				fun check_flgs []
					=>
					atomic_cvar_set cvar;

				    check_flgs ((REF TRUE) ! _)
					=>
					();

				    check_flgs (_ ! r)
					=>
					check_flgs r;
				end;
			    end;
		    end;

		fun run_mailops ((is_ready, flag) ! rest, wait_fors)								# In this loop we have not yet found a mailop ready to fire.
			=>
			case (is_ready ())
			    #
			    MAILOP_READY { priority, do_it } =>  run_ready_mailops (rest, [(priority, (do_it, flag))], 1);
			    MAILOP_UNREADY wait_for          =>  run_mailops       (rest, (wait_for, flag) ! wait_fors);
			esac;

		    run_mailops ([], wait_fors)											# End of the line -- no ready-to-fire mailops found and none left to check.
			=>
			call_with_current_control_fate
			    (fn fate
				=
				{   switch_to_control_fate =  switch_to_control_fate  fate;
				    #
				    mailop_state =   REF (itt::MAILOP_THREAD (ts::get_current_thread ()));

				    fun set_flag flag ()
					=
					{   mailop_state := itt::MAILOP_DONE;
					    flag := TRUE;
					    check_cvars ();
					};

				    fun log [] =>   ts::reenable_thread_switching_and_dispatch_next_thread ();
					#
					log ((wait_for, flag) ! r)
					    =>
					    switch_to_control_fate
						(wait_for { mailop_state,
							    clean_up =>  set_flag flag,
							    next     =>  fn () = log r
							  }
						);
				    end;

				    log  wait_fors;

				    error "[log]";
				 }
			    );
		end

		# NOTE: maybe we should just
		# keep track of the max priority?
		# What about fairness to fixed
		# priority mailops (e::g., always, timeout?)
		#
		also
		fun run_ready_mailops ((is_ready, flag) ! rest, do_its, n)							# In this loop we have found at least one mailop ready to fire.
			=>
			case (is_ready ())
			    #
			    MAILOP_READY { priority, do_it }
				=>
				run_ready_mailops (rest, (priority, (do_it, flag)) ! do_its, n+1);

			    _   =>   run_ready_mailops (rest, do_its, n);
			esac;

		    run_ready_mailops ([], do_its, n)										# End of line -- select one mailop to fire and then fire it.
			=>
			{   (select_do_fn (do_its, n))
				->
				(do_it, flag);

			    flag := TRUE;
			    check_cvars ();
			    do_it();
			};
		end;
	    end;							# fun run_prepared_mailops


	fun do_mailop  mailop
	    =
	    case (prepare mailop)
		#
		BASE_GROUP baseops =>  run_prepared_baseops  baseops;
		           mailops =>  run_prepared_mailops  mailops;
	    esac;


	fun select mailops
	    =
	    case (prepare_baseops (mailops, []))									# Start by optimistically assuming baseops-only case; we'll fall back to general prepare_mailops() if proved wrong.
		#
		BASE_GROUP baseops  =>   run_prepared_baseops  baseops;							# This is special-case handling for baseops-only case.
		           mailops  =>   run_prepared_mailops  mailops;							# This is the general case.
	    esac
	    where
	        fun prepare_baseops  (mailop ! rest,  baseops')							# prepare_baseops handles the nice simple baseop-only cases, prepare_mailops handles the remaining messier cases.
			=>
			case (prepare_one_mailop  mailop)
			    #
			    BASE_GROUP baseops =>  prepare_baseops (rest,        baseops @ baseops' );
			    GROUP      group        =>  prepare_mailops  (rest,  group @ [BASE_GROUP baseops']);
			    nackg as NACK_GROUP _   =>  prepare_mailops  (rest, [nackg,   BASE_GROUP baseops']);
			esac;

		    prepare_baseops ([], baseops)	    =>	BASE_GROUP  baseops;
		end

		also
		fun prepare_mailops ([], [group]) =>  group;
		    prepare_mailops ([], l)       =>  GROUP l;
		    #
		    prepare_mailops (mailop ! rest, l)
			=>
			case (prepare_one_mailop mailop, l)
			    #
			    (BASE_GROUP baseops, BASE_GROUP baseops' ! rest')
				=>
				prepare_mailops (rest, BASE_GROUP (baseops @ baseops') ! rest');

			    (GROUP group, l) =>   prepare_mailops  (rest,  group @ l);
			    (other,       l) =>   prepare_mailops  (rest,  other ! l);						# 'other' can be (BASE_GROUP _) or (NACK_GROUP _).
			esac;
		end

		also
		fun prepare_one_mailop (GUARD g)            =>   prepare_one_mailop (g ());
		    prepare_one_mailop (BASE_MAILOPS group) =>   BASE_GROUP group;
		    prepare_one_mailop (CHOOSE mailops)     =>   prepare_baseops (mailops, []);
		    #
		    prepare_one_mailop (WITH_NACK f)
			=>
			{   cvar =  itt::CONDITION_VARIABLE  (REF  (itt::CVAR_UNSET []));
			    #
			    NACK_GROUP (cvar, prepare_one_mailop (f (cvar_get_mailop cvar)));
			};

		end;
	    end;			# fun select
    };					# package mailop
end;

## COPYRIGHT (c) 1989-1991 John H. Reppy
## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


