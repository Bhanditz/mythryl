## mailop.pkg
#
# Implementation of mailop values and the mailop combinators.
#
# Some important requirements on the implementation
# of base mailop values:
#
#  1)  An is_ready, fire_mailop or unready_mailop function
#      is always called from inside an uninterruptible_scope.			# "uninterruptible_scope" == "critical section" == "atomic region" == ...
#
#  2)  An is_ready returns an integer priority.
#      This is   0 when not enabled,
#	        -1 for fixed priority and
#               >0 for dynamic priority.
#      The standard scheme is to associate a counter
#      with the underlying synchronization value and
#      to increase it by one for each synchronization attempt.
#
#  3)  A unready_mailop is responsible for exiting the atomic region.
#      A fire_mailop should NOT leave the atomic region.
#
#  4)  Each unready_mailop is responsible for executing the
#      "clean_up" action prior to leaving the atomic region.

# Compiled by:
#     src/lib/std/standard.lib





stipulate
    package fat =  fate;							# fate				is from   src/lib/std/src/nj/fate.pkg
    package itt =  internal_threadkit_types;					# internal_threadkit_types	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/internal-threadkit-types.pkg
    package rwq =  rw_queue;							# rw_queue			is from   src/lib/src/rw-queue.pkg
    package ts  =  thread_scheduler;						# thread_scheduler		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler.pkg
herein

    package mailop: (weak)
			    api {
				include Mailop;					# Mailop			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/mailop.api
				#
				set_condvar_in_uninterruptible_scope:   itt::Condition_Variable -> Void;
				wait_on_condvar__mailop:   itt::Condition_Variable -> Mailop( Void );
			    }
    {
	call_with_current_control_fate	=  fat::call_with_current_control_fate;
	switch_to_control_fate		=  fat::switch_to_control_fate;
	call_with_current_fate		=  fat::call_with_current_fate;
#	switch_to_fate			=  fat::switch_to_fate;

	# Some inline functions
	# to improve performance:
	#
	fun map f
	    =
	    map'
	    where
		fun map' [] => [];
		    map' [a] => [f a];
		    map' [a, b] => [f a, f b];
		    map' [a, b, c] => [f a, f b, f c];
		    map' (a ! b ! c ! d ! r) => (f a) ! (f b) ! (f c) ! (f d) ! (map' r);
		end;
	    end;
	#
	fun apply f
	    =
	    apply'
	    where
		fun apply' [] => ();
		    apply' (x ! r) => { f x; apply' r;};
		end;
	    end;
	#
	fun fold_left f init l
	    =
	    foldf (l, init)
	    where
		fun foldf ([], accum) => accum;
		    foldf (x ! r, accum) => foldf (r, f (x, accum));
		end;
	    end;
	#
	fun error msg
	    =
	    raise exception FAIL msg;

	Mailop_Readiness   ==  itt::Mailop_Readiness;
	Mailop             ==  itt::Mailop;
	Isready_Mailop(X) =  itt::Isready_Mailop(X);


	# Condition variables.
	#
	# Because these variables are set inside
	# atomic regions we have to use different
	# conventions for clean-up, etc.  Instead
	# of requiring the unready_mailop fate
	# to call the clean_up action and to leave
	# the atomic region, we call the clean_up
	# function when setting the condition variable
	# (in set_condvar_in_uninterruptible_scope), and have the invariant
	# that the unready_mailop fate is dispatched
	# outside the atomic region.


									# Nomenclature: What I'm calling "uninterruptible_scope" is usually called "critical section" or "atomic region"
									# in the literature.  I dislike "critical" because it is vague. ("critical" in what sense? Who knows?)
									# "atomic" is literally correct ("a-tomic" == "not cuttable" -- indivisible) but the modern reader is not
									# likely to take it in that sense at first blush.  And neither "section" nor "region" are as apropos as "scope".
	# Set a condition variable.
	# We assume that this function is always
	# executed in an uninterruptible scope.
	#
	fun set_condvar_in_uninterruptible_scope (itt::CONDITION_VARIABLE state)
	    =
	    case *state
		#
		itt::CONDVAR_UNSET  waiting_threads										# waiting_threads is the list of threads sitting
		    =>														# blocked waiting for this condvar to be set.
		    {   ts::foreground_run_queue ->  rwq::RW_QUEUE { back, ... };
			#
			state :=    itt::CONDVAR_VALUE  1;									# Set the condition variable.
			#
			back :=     run  waiting_threads									# Add to foreground run queue all threads that were waiting for condvar to be set.
				    where
					fun run [] =>   *back;
					    #
					    run ( { mailop_done=>REF itt::MAILOP_DONE, ... } ! rest)
						=>
						run rest;									# Drop completed/cancelled transaction.

					    run ( { mailop_done as REF (itt::MAILOP_PENDING_FOR tid), clean_up, fate } ! rest)
						=>
						{   mailop_done :=   itt::MAILOP_DONE;
						    #
						    clean_up ();

						    (tid, fate)  !  (run rest);
						};
					end;
				    end;
		    };

		 _ => error "condvar already set";
	    esac;


	# The mailop constructor for
	# waiting on a condition variable:
	#
	fun wait_on_condvar__mailop (itt::CONDITION_VARIABLE  condvar_state)
	    =
	    ISREADY_MAILOPS [is_ready]
	    where 
		fun unready_mailop { mailop_done, clean_up, next }									# Reppy's name for 'unready_mailop' is 'blockFn'.
		    =
		    call_with_current_fate
			#
			(fn fate
			    =
			    {   waiting_threads											# The list of threads waiting for the condvar to be set.
				    =
				    case *condvar_state
					#
					itt::CONDVAR_UNSET waiting_threads =>   waiting_threads;
					_                                  =>   raise exception FAIL "Bug in wait_on_condvar__mailop";
				    esac;					# This exception is impossible -- is_ready() only queues us up if *condvar_state is not CONDVAR_VALUE.
				#
				waiting_thread =  { mailop_done,  clean_up,  fate };

				condvar_state :=  itt::CONDVAR_UNSET (waiting_thread ! waiting_threads);			# Add ourself to list of threads waiting for condvar to be set.

				next ();											# Does not return.
			    }
			);
		#
		fun is_ready ()													# Reppy calls this fn pollFn
		    =
		    case *condvar_state
			#
			itt::CONDVAR_VALUE n
			    =>
			    {   condvar_state :=  itt::CONDVAR_VALUE (n+1);
				#
				MAILOP_READY {  priority => n,  fire_mailop  }
				where
				    fun fire_mailop ()										# Reppy refers to fire_mailop as 'doFn'.
					=
					{   condvar_state :=  itt::CONDVAR_VALUE  1;
					    #
					    ts::reenable_thread_switching ();
					};
				end;
			    };

			itt::CONDVAR_UNSET _
			    =>
			    MAILOP_UNREADY  unready_mailop;
		    esac;
	    end;


	# A mailop which is always ready
	# and produces given result:
	#
	fun always_mailop  result
	    =
	    ISREADY_MAILOPS
	      [
		fn () = itt::MAILOP_READY
			  { priority	=> -1,
			    fire_mailop	=> fn () =  {   ts::reenable_thread_switching ();					# Reppy refers to fire_mailop as 'doFn'.
							result;
						    }
			  }
	      ];

	never = ISREADY_MAILOPS [];												# A mailop which is never ready:

	dynamic_mailop = DYNAMIC_MAILOP;

	with_nack = WITH_NACK;
	#
	fun choose (mailops:  List(  Mailop(X) ))										# 'gather_mailops' handles the general case.
	    =															# 'gather_baseops' assumes common special case of only base mailops;
	    gather_baseops (reverse mailops, [])										#  We optimistically start with gather_baseops; we'll fall back to gather_mailops if necessary.
	    where
		fun gather_baseops ([],                           baseops') =>  ISREADY_MAILOPS baseops';				# Done, return result.
		    #
		    gather_baseops (ISREADY_MAILOPS []       ! rest, baseops') =>  gather_baseops (rest,           baseops');
		    gather_baseops (ISREADY_MAILOPS [baseop] ! rest, baseops') =>  gather_baseops (rest, baseop  ! baseops');
		    gather_baseops (ISREADY_MAILOPS  baseops ! rest, baseops') =>  gather_baseops (rest, baseops @ baseops');
		    #
		    gather_baseops (mailops, []) =>  gather_mailops (mailops, []);
		    gather_baseops (mailops, l ) =>  gather_mailops (mailops, [ISREADY_MAILOPS l]);
		end 

		also
		fun gather_mailops ([], [mailop]) => mailop;
		    gather_mailops ([], mailops)  => CHOOSE mailops;
		    #
		    gather_mailops (CHOOSE mailops ! rest, mailops')
			=>
			gather_mailops (rest, mailops @ mailops');

		    gather_mailops (ISREADY_MAILOPS base_mailops ! rest, ISREADY_MAILOPS base_mailops' ! rest')
			=>
			gather_mailops (rest, ISREADY_MAILOPS (base_mailops @ base_mailops') ! rest');

		    gather_mailops (mailop ! rest, mailops')
			=>
			gather_mailops (rest, mailop ! mailops');
		end;
	    end;
	#
	fun make_select_rule (mailop, wfn)				# This is the "==>" op used in select[...] rules.
	    =
	    wrap' mailop
	    where
		fun wrap_base_mailop  is_ready  ()
		    =
		    case (is_ready ())
			#
			MAILOP_READY { priority, fire_mailop }	=>  MAILOP_READY { priority, fire_mailop => wfn o fire_mailop };
			MAILOP_UNREADY unready_mailop		=>  MAILOP_UNREADY (wfn o unready_mailop);
		    esac;
		#
		fun wrap' (ISREADY_MAILOPS base_mailops)	=>  ISREADY_MAILOPS (map  wrap_base_mailop  base_mailops);		# Curried application yields thunklist that will do  case (is_ready() )... esac  when later invoked.
		    #
		    wrap' (CHOOSE mailops)			=>  CHOOSE (map wrap' mailops);
		    wrap' (DYNAMIC_MAILOP make_mailop)		=>  DYNAMIC_MAILOP (fn () =  make_select_rule (make_mailop(), wfn));
		    wrap' (WITH_NACK f)				=>  WITH_NACK (fn mailop  =  make_select_rule (f mailop,      wfn));
		end;
	    end;

	(==>) =  make_select_rule;			# Infix synonym for readability.
	#
	fun make_exception_handling_mailop (mailop, exception_handler_fn)
	    =
	    wrap' mailop
	    where
		fun wrap f x
		    =
		    f x
		    except
			exn = exception_handler_fn exn;
		#
		fun wrap_base_mailop  is_ready ()
		    =
		    case (is_ready ())
			#
			MAILOP_READY { priority, fire_mailop }	=>  MAILOP_READY { priority, fire_mailop => wrap fire_mailop };
			MAILOP_UNREADY unready_mailop		=>  MAILOP_UNREADY (wrap unready_mailop);
		    esac;
		#
		fun wrap' (ISREADY_MAILOPS  base_mailops) =>  ISREADY_MAILOPS  (map  wrap_base_mailop  base_mailops);
		    #
		    wrap' (CHOOSE mailops)		=>  CHOOSE (map  wrap'  mailops);
		    wrap' (DYNAMIC_MAILOP make_mailop)	=>  DYNAMIC_MAILOP  (fn () =  make_exception_handling_mailop (make_mailop(), exception_handler_fn));
		    wrap' (WITH_NACK f)			=>  WITH_NACK (fn mailop   =  make_exception_handling_mailop (f mailop,      exception_handler_fn));
		end;
	    end;

	Prepared_Mailops(X)
	  = NACKFREE_MAILOPS  List( Isready_Mailop(X) )
	  | NACKFULL_MAILOPS  List( Prepared_Mailops(X) )
	  | WITHNACK_MAILOP  (itt::Condition_Variable, Prepared_Mailops(X))
	  ;

    /* +DEBUG
    fun sayGroup (msg, eg) = let
	  fun f (NACKFREE_MAILOPS l, sl) = "NACKFREE_MAILOPS(" ! int::to_string (list::length l) ::()) ! sl
	    | f (NACKFULL_MAILOPS l, sl) = "NACKFULL_MAILOPS(" ! g (l, ")" ! sl)
	    | f (WITHNACK_MAILOP  l, sl) = "WITHNACK_MAILOP(" ! f(#2 l, ")" ! sl)
	  also g ([], sl) = sl
	    | g ([x], sl) = f (x, sl)
	    | g (x ! r, sl) = f (x, ", " ! g (r, sl))
	  in
	    Debug::sayDebugId (string::cat (msg ! ": " ! f (eg, ["\n"])))
	  end
    -DEBUG*/

	# Prepare mailop expression to run.
        # In particular, this evaluates all
        # dynamic rules to generate the actual
	# final rules to select between:
	#
	fun prepare (ISREADY_MAILOPS l)
		=>
		NACKFREE_MAILOPS l;

	    prepare mailop
		=>
		prepare' mailop
		where
		    fun prepare' (DYNAMIC_MAILOP  make_mailop)
			    =>
			    prepare' (make_mailop ());

			prepare' (WITH_NACK f)
			    =>
			    {   condvar = itt::CONDITION_VARIABLE (REF (itt::CONDVAR_UNSET []));
				#
				WITHNACK_MAILOP  (condvar,  prepare' (f (wait_on_condvar__mailop  condvar)));
			    };

			prepare' (ISREADY_MAILOPS  baseops)
			    =>
			    NACKFREE_MAILOPS  baseops;

			prepare' (CHOOSE mailops)
			    =>
			    prepare_nackfree_mailops (mailops, [])								# Optimistically assume nackfree; we'll fall back toprepare_nackfull_mailops() routine if we're wrong.
			    where
				fun prepare_nackfree_mailops ([], baseops)
					=>
					NACKFREE_MAILOPS baseops;

				    prepare_nackfree_mailops (mailop ! rest, baseops')
					=>
					case (prepare' mailop)
					    #
					    NACKFREE_MAILOPS baseops =>  prepare_nackfree_mailops (rest,  baseops @             baseops' );
					    NACKFULL_MAILOPS mailops =>  prepare_nackfull_mailops (rest,  mailops @ [NACKFREE_MAILOPS baseops']);
					    /*        */ mailops =>  prepare_nackfull_mailops (rest, [mailops,   NACKFREE_MAILOPS baseops']);
					esac;
				end

				also
				fun prepare_nackfull_mailops ([], [group]) =>  group;						# The general case vs prepare_nackfree_mailops above handling the nice simple (and common) case.
				    prepare_nackfull_mailops ([], l)       =>  NACKFULL_MAILOPS l;
				    #
				    prepare_nackfull_mailops (mailop ! rest, l)
					=>
					case (prepare' mailop, l)
					    #				      
					    (NACKFREE_MAILOPS baseops, NACKFREE_MAILOPS baseops' ! rest')
						=>
						prepare_nackfull_mailops (rest, NACKFREE_MAILOPS (baseops @ baseops') ! rest');

					    (NACKFULL_MAILOPS mailops, l) =>   prepare_nackfull_mailops (rest, mailops @ l);
					    (             mailops, l) =>   prepare_nackfull_mailops (rest, mailops ! l);		# Here 'mailops' can be NACKFREE_MAILOPS or WITHNACK_MAILOP.
				       esac;
	end;    end;  end;  end;end;


	stipulate
	    #
	    count =  REF 0;					# Runs circularly around range 0..999,999
	    #
	    fun pick_fairly i					# The point here is just to pick fairly among 'i' alternative ready mailops,
		=						# so that we don't consistently pass over any one ready mailop.
		{   j =  *count;
		    #
		    if (j == 1000000)   count := 0;
		    else                count := j+1;
		    fi;

		    int::rem (j, i);
		};
	herein
	    #
	    fun select_do_fn ([(_, fire_mailop)], _)
		    =>
		    fire_mailop;

		select_do_fn (l, n)
		    =>
		    max (l, 0, 0, [])
		    where
			#
			fun priority -1 =>  n;
			    priority  p =>  p;
			end;
			#
			fun max ((p, fire_mailop) ! rest,  max_p,  k,  fire_mailop_fns)
				=>
				{   p =  priority p;
				    #
				    if    (p >  max_p)   max (rest,     p, 1,  [fire_mailop]                 );
				    elif  (p == max_p)   max (rest, max_p, k+1, fire_mailop ! fire_mailop_fns);
				    else                 max (rest, max_p, k,                 fire_mailop_fns);
				    fi;
				};

			    max ([], _, k, [fire_mailop])
				=>
				fire_mailop;

			    max ([], _, k, fire_mailop_fns)
				=>
				list::nth (fire_mailop_fns, pick_fairly k);
			end;
		    end;
	     end;
	end;
	#
	fun make__mailop_done__and__clean_up ()
	    =
	    {   mailop_done =    REF (itt::MAILOP_PENDING_FOR (ts::get_current_thread()));
		#
		clean_up    =    .{   mailop_done :=  itt::MAILOP_DONE;  };

		{ mailop_done, clean_up };
	    };


	stipulate
	    # When we have exactly one mailop in the select[...] we can use simple logic:
	    #
	    fun do_one_mailop  (is_ready:  Isready_Mailop(X))
		=
		{   ts::disable_thread_switching ();
		    #
		    case (is_ready ())
			#	      
			MAILOP_READY { fire_mailop, ... }					# Reppy refers to 'fire_mailop' as 'doFn'.
			    =>
			    fire_mailop ();

			MAILOP_UNREADY unready_mailop
			    =>
			    {   (make__mailop_done__and__clean_up ())
				    ->
				    { mailop_done, clean_up };
				#
				unready_mailop  { mailop_done,
					    clean_up,
					    next        =>  ts::reenable_thread_switching_and_dispatch_next_thread
					  };
			    };
		    esac;
		};
	herein

	    # This function handles the case of picking
	    # and firing one of a list of mailops thunks
	    # (w/o any negative acknowledgements).
	    #
	    # It also handles NEVER.
	    #
	    fun do_nackfree_mailops []    =>  ts::dispatch_next_thread ();							# 'select' with empty rule list -- nothing to do.
		do_nackfree_mailops [bev] =>  do_one_mailop  bev;								# This is the only call to   do_one_mailop().
		#
		do_nackfree_mailops  baseops
		    =>
		    {   ts::disable_thread_switching ();
			#
			do_baseops (baseops, []);
		    }
		    where
#			Collect_Ready_Mailops_Result
#			    #
#			    = NO_READY_MAILOPS { unready_mailops: List(Unready_Mailop) }
#			    |    READY_MAILOPS
#			    ;

			fun do_baseops (is_ready ! rest,  unready_mailops)								# In this loop we have not yet found any baseops ready to fire.
				=>
				case (is_ready ())
				    #
				    MAILOP_UNREADY unready_mailop          =>  do_baseops       (rest, unready_mailop ! unready_mailops);
				    MAILOP_READY { priority, fire_mailop } =>  do_ready_baseops (rest, [(priority, fire_mailop)], 1);
				esac;

			    do_baseops ([], unready_mailops)										# Done -- no ready-to-fire baseops found and no candidates left to check.
				=>
				call_with_current_control_fate
				    (fn fate
					=
					{   switch_to_control_fate =  switch_to_control_fate  fate;
					    #
					    (make__mailop_done__and__clean_up ())
						->
						{ mailop_done, clean_up };
					    #
					    fun log [] =>   ts::reenable_thread_switching_and_dispatch_next_thread ();
						#
						log (unready_mailop ! rest)
						    =>
						    switch_to_control_fate
							(unready_mailop
							  { mailop_done,
							    clean_up,
							    next     =>  fn () = log rest
							  }
							);
					    end;

					    log  unready_mailops;

					    error "[log]";
					}
				    );
			end

			# NOTE: Maybe we should just keep
			#       track of the max priority?
			#       What about fairness to fixed
			#       priority mailops (e::g., always, timeout?)

			also
			fun do_ready_baseops (is_ready ! rest,  fire_mailop_fns,  n)						# In this loop we have found at least one select[...] rule which is ready to fire.
				=>
				case (is_ready ())
				    #
				    MAILOP_READY { priority, fire_mailop } =>  do_ready_baseops (rest, (priority, fire_mailop) ! fire_mailop_fns, n+1);
				    _                                      =>  do_ready_baseops (rest,                           fire_mailop_fns, n  );
				esac;

			    do_ready_baseops ([],  fire_mailop_fns,  n)
				=>
				select_do_fn  (fire_mailop_fns, n)  ();								# Pick a select[....] rule to fire and then fire it.
			end;														# fun do_ready_baseops
		    end;														# where
	    end;															# fun do_nackfree_mailops
	end;																# stipulate

	# Walk the mailop group tree,
	# collecting the base mailops
	# (with associated ack flags),
	# also a list of nackstates.
	#
	# A nackstate is a
	#     (Condvar, List(Flag(Ack)))
	# pair, where the flags are
	# those associated with the
	# mailops covered by the nack
	# condvar.
	#
	fun collect_baseops_and_nackstates_from_mailops  mailops
	    =
	    case mailops
		#
		NACKFULL_MAILOPS _
		    =>
		    gather_mailops (mailops, [], [])
		    where 
			un_wrapped_flag =  REF FALSE;
			#
			fun append_baseops  (baseop ! rest,  results) =>  append_baseops  (rest,  (baseop, un_wrapped_flag) ! results);
			    append_baseops  (           [],  results) =>  results;
			end;
			#
			fun gather_mailops (NACKFREE_MAILOPS baseops, bl, nackstates)
				=>
				(append_baseops (baseops, bl), nackstates);

			    gather_mailops (NACKFULL_MAILOPS group, bl, nackstates)
				=>
				fold_left  f  (bl, nackstates)  group
				where
				    fun f (group', (bl', nackstates'))
					=
					gather_mailops (group', bl', nackstates');
				end;

			    gather_mailops (group as WITHNACK_MAILOP _, bl, nackstates)
				=>
				gather_wrapped (group, bl, nackstates);
			end;
		    end;

		group =>   gather_wrapped (group, [], []);
	    esac
	    where
	        un_wrapped_flag =   REF FALSE;
		#
		fun gather_wrapped (group, bl, nackstates)
			=
			{    (gather (group, bl, [], nackstates))
				->
				(bl, _, nackstates);

			    (bl, nackstates);
			}
			where
			    fun gather (NACKFREE_MAILOPS baseops, bl, all_flags, nackstates)
				    =>
				    {	(append_baseops (baseops, bl, all_flags))
					    ->
					    (bl', all_flags');

					(bl', all_flags', nackstates);
				    }
				    where
				        fun append_baseops ([],  bl,  all_flags)
						=>
						(bl, all_flags);

					    append_baseops (baseop ! rest,  bl,  all_flags)
						=>
						{   flag = REF FALSE;
						    #
						    append_baseops  (rest,  (baseop, flag) ! bl,  flag ! all_flags);
						};
					end;
				    end;


				gather (NACKFULL_MAILOPS group, bl, all_flags, nackstates)
				    =>
				    fold_left  f  (bl, all_flags, nackstates)  group
				    where
				        fun f (group', (bl', all_flags', nackstates'))
					    =
					    gather (group', bl', all_flags', nackstates');
				    end;

				gather (WITHNACK_MAILOP (condvar, group), bl, all_flags, nackstates)
				    =>
				    {   (gather (group, bl, [], nackstates))
					    ->
					    (bl', all_flags', nackstates');

					(bl', all_flags' @ all_flags, (condvar, all_flags') ! nackstates');
				    };
			    end;									# fun gather
			end;										# where
	    end;											# where

	# This function handles the more
	# complicated case of running a
	# mailop expression where negative
	# acknowledgements are involved.
	#
	fun do_nackfull_mailops  group
	    =
	    {	ts::disable_thread_switching ();
		#
		do_mailops (bl, []);
	    }
	    where
	        (collect_baseops_and_nackstates_from_mailops  group)
		    ->
		    (bl, nackstates);
		#
		fun check_condvars ()
		    =
		    apply  check_condvar  nackstates
		    where
			# check_cvar checks the flags of a nackstate.
			# If they are all FALSE then the
			# corresponding cvar is set to signal
			# the negative ack.
			#
			fun check_condvar (condvar, flgs)
			    =
			    check_flgs flgs
			    where
				fun check_flgs ((REF TRUE) ! _) =>	();
				    check_flgs (_ ! rest)	=>	check_flgs rest;
				    check_flgs []		=>	set_condvar_in_uninterruptible_scope  condvar;
				end;
			    end;
		    end;
		#
		fun do_mailops ((is_ready, flag) ! rest, unready_mailops)								# In this loop we have not yet found a mailop ready to fire.
			=>
			case (is_ready ())
			    #
			    MAILOP_READY { priority, fire_mailop } =>  do_ready_mailops (rest, [(priority, (fire_mailop, flag))], 1);
			    MAILOP_UNREADY unready_mailop          =>  do_mailops       (rest, (unready_mailop, flag) ! unready_mailops);
			esac;

		    do_mailops ([], unready_mailops)											# End of the line -- no ready-to-fire mailops found and none left to check.
			=>
			call_with_current_control_fate
			    (fn fate
				=
				{   switch_to_control_fate =  switch_to_control_fate  fate;
				    #
				    mailop_done =   REF (itt::MAILOP_PENDING_FOR (ts::get_current_thread ()));
				    #
				    fun cleanup_fn  flag  ()
					=
					{   mailop_done := itt::MAILOP_DONE;
					    flag := TRUE;
					    check_condvars ();
					};
				    #
				    fun log [] =>   ts::reenable_thread_switching_and_dispatch_next_thread ();
					#
					log ((unready_mailop, flag) ! r)
					    =>
					    switch_to_control_fate
						(unready_mailop { mailop_done,
							    clean_up =>  cleanup_fn flag,
							    next     =>  fn () = log r
							  }
						);
				    end;

				    log  unready_mailops;

				    error "[log]";
				 }
			    );
		end

		# NOTE: maybe we should just
		# keep track of the max priority?
		# What about fairness to fixed
		# priority mailops (e::g., always, timeout?)
		#
		also
		fun do_ready_mailops ((is_ready, flag) ! rest, fire_mailop_fns, n)						# In this loop we have found at least one select[...] rule ready to fire.
			=>
			case (is_ready ())
			    #
			    MAILOP_READY { priority, fire_mailop }
				=>
				do_ready_mailops  (rest,  (priority,  (fire_mailop, flag)) ! fire_mailop_fns,  n+1);

			    _   =>   do_ready_mailops  (rest,  fire_mailop_fns,  n);
			esac;

		    do_ready_mailops ([], fire_mailop_fns, n)								# End of line -- pick one select[...] mailop to fire and then fire it.
			=>
			{   (select_do_fn (fire_mailop_fns, n))
				->
				(fire_mailop, flag);

			    flag := TRUE;

			    check_condvars ();

			    fire_mailop();
			};
		end;
	    end;													# fun do_nackfull_mailops

	#
	fun do_mailop  mailop												# External entrypoint.
	    =
	    case (prepare mailop)
		#
		NACKFREE_MAILOPS mailops =>  do_nackfree_mailops  mailops;
		/*            */ mailops =>  do_nackfull_mailops  mailops;
	    esac;


															# 'select' is our core entrypoint, the 'select' used by clients
															# to do style handle-multiple-mail-sources thread I/O via
															# statements looking like
															#
															#     select [
															#	  foo' ==> .{ do_this (); },
															#	  bar' ==> .{ do_that (); },
															#         ...
															#     ];
															#
															#
	fun select mailops
	    =
	    case (prepare_nackfree_mailops (mailops, []))									# Start by optimistically assuming nackfree case; we'll fall back to general nackfull if proved wrong.
		#
		NACKFREE_MAILOPS mailops  =>   do_nackfree_mailops  mailops;						# This is special-case handling for simple special case of no WITH_NACK mailops.
		/*            */ mailops  =>   do_nackfull_mailops  mailops;						# This is the general case.
	    esac
	    where
 		# Preparation.  During this phase we need to:
		#
		#  o Expand DYNAMIC_MAILOP clauses.  These are essentially a hack
		#    to allow generating select rules on the fly at runtime,
		#    i.e., while the select [...] call is actually running.
		#
		#  o Figure out whether we have any WITH_NACK clauses,
		#    which complicate things.
		#
                #  In the common case of no WITH_NACK mailops
		#  we return NACKFREE_MAILOPS _, otherwise    
		#  we return NACKFULL_MAILOPS _ or WITHNACK_MAILOP _.
		# 
	        fun prepare_nackfree_mailops  (mailop ! rest,  baseops')								# prepare_nackfree_mailops handles the nice simple baseop-only cases;
			=>												# prepare_nackfull_mailops handles the remaining messier cases.
			case (prepare_one_mailop  mailop)
			    #
			    /* */ NACKFREE_MAILOPS baseops =>  prepare_nackfree_mailops  (rest,  baseops @                   baseops' );
			    /* */ NACKFULL_MAILOPS mailops =>  prepare_nackfull_mailops  (rest,  mailops @ [NACKFREE_MAILOPS baseops']);
			    ng as WITHNACK_MAILOP   _      =>  prepare_nackfull_mailops  (rest, [ng,        NACKFREE_MAILOPS baseops']);
			esac;

		    prepare_nackfree_mailops ([], baseops)	    =>	NACKFREE_MAILOPS  baseops;
		end

		also
		fun prepare_nackfull_mailops ([], [group]) =>  group;
		    prepare_nackfull_mailops ([], l)       =>  NACKFULL_MAILOPS l;
		    #
		    prepare_nackfull_mailops (mailop ! rest, l)
			=>
			case (prepare_one_mailop  mailop,  l)
			    #
			    (NACKFREE_MAILOPS baseops,  NACKFREE_MAILOPS baseops' ! rest')
				=>
				prepare_nackfull_mailops (rest, NACKFREE_MAILOPS (baseops @ baseops') ! rest');

			    (NACKFULL_MAILOPS group, l) =>   prepare_nackfull_mailops  (rest,  group @ l);
			    (other,                  l) =>   prepare_nackfull_mailops  (rest,  other ! l);				# 'other' can be (NACKFREE_MAILOPS _) or (WITHNACK_MAILOP _).
			esac;
		end

		also
		fun prepare_one_mailop (DYNAMIC_MAILOP   make_mailop) =>   prepare_one_mailop (make_mailop ());				# Generate a select[...] rule on the fly, then recursively prepare it.
		    prepare_one_mailop (ISREADY_MAILOPS mailops)     =>   NACKFREE_MAILOPS mailops;
		    prepare_one_mailop (CHOOSE           mailops)     =>   prepare_nackfree_mailops (mailops, []);
		    #
		    prepare_one_mailop (WITH_NACK f)
			=>
			{   condvar =  itt::CONDITION_VARIABLE  (REF  (itt::CONDVAR_UNSET []));
			    #
			    WITHNACK_MAILOP  (condvar,  prepare_one_mailop  (f  (wait_on_condvar__mailop  condvar)));
			};

		end;
	    end;			# fun select
    };					# package mailop
end;

## COPYRIGHT (c) 1989-1991 John H. Reppy
## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


