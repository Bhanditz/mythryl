## mailop.pkg

# Compiled by:
#     src/lib/std/standard.lib



# Implementation of mailop values and the mailop combinators.
#
# Some important requirements on the implementation
# of base mailop values:
#
#  1)  An is_ready, do_it or wait_for function
#      is always called from inside an atomic region.
#
#  2)  An is_ready returns an integer priority.
#      This is   0 when not enabled,
#	        -1 for fixed priority and
#               >0 for dynamic priority.
#      The standard scheme is to associate a counter
#      with the underlying synchronization value and
#      to increase it by one for each synchronization attempt.
#
#  3)  A wait_for is responsible for exiting the atomic region.
#      A do_it should NOT leave the atomic region.
#
#  4)  Each wait_for is responsible for executing the
#      "clean_up" action prior to leaving the atomic region.


stipulate
    package fat =  fate;							# fate				is from   src/lib/std/src/nj/fate.pkg
    package itt =  internal_threadkit_types;					# internal_threadkit_types	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/internal-threadkit-types.pkg
    package rwq =  rw_queue;							# rw_queue			is from   src/lib/src/rw-queue.pkg
    package ts  =  thread_scheduler;						# thread_scheduler		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler.pkg
herein

    package mailop: (weak)
			    api {
				include Mailop;					# Mailop			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/mailop.api
				#
				set_condvar_in_indivisible_scope:   itt::Condition_Variable -> Void;
				wait_on_condvar__mailop:   itt::Condition_Variable -> Mailop( Void );
			    }
    {
	call_with_current_control_fate	=  fat::call_with_current_control_fate;
	switch_to_control_fate		=  fat::switch_to_control_fate;
	call_with_current_fate		=  fat::call_with_current_fate;
#	switch_to_fate			=  fat::switch_to_fate;

	# Some inline functions
	# to improve performance:

	fun map f
	    =
	    map'
	    where
		fun map' [] => [];
		    map' [a] => [f a];
		    map' [a, b] => [f a, f b];
		    map' [a, b, c] => [f a, f b, f c];
		    map' (a ! b ! c ! d ! r) => (f a) ! (f b) ! (f c) ! (f d) ! (map' r);
		end;
	    end;

	fun apply f
	    =
	    apply'
	    where
		fun apply' [] => ();
		    apply' (x ! r) => { f x; apply' r;};
		end;
	    end;

	fun fold_left f init l
	    =
	    foldf (l, init)
	    where
		fun foldf ([], accum) => accum;
		    foldf (x ! r, accum) => foldf (r, f (x, accum));
		end;
	    end;

	fun error msg
	    =
	    raise exception FAIL msg;

	Mailop_Readiness ==  itt::Mailop_Readiness;
	Mailop           ==  itt::Mailop;
	Base_Mailop(X)   =  itt::Base_Mailop(X);


	# Condition variables.
	#
	# Because these variables are set inside
	# atomic regions we have to use different
	# conventions for clean-up, etc.  Instead
	# of requiring the wait_for fate
	# to call the clean_up action and to leave
	# the atomic region, we call the clean_up
	# function when setting the condition variable
	# (in set_condvar_in_indivisible_scope), and have the invariant
	# that the wait_for fate is dispatched
	# outside the atomic region.


									# Nomenclature: What I'm calling "indivisible scope" is usually called "critical section" or "atomic region"
									# in the literature.  I dislike "critical" because it is vague. ("critical" in what sense? Who knows?)
									# "atomic" is literally correct ("a-tomic" == "not cuttable" -- indivisible) but the modern reader is not
									# likely to take it in that sense at first blush.  And neither "section" nor "region" are as apropos as "scope".
									# (If we were going to use the term a lot I might favor "unit scope", but I do not expect we will.)
	# Set a condition variable.
	# We assume that this function is always
	# executed in an indivisible scope.
	#
	fun set_condvar_in_indivisible_scope (itt::CONDITION_VARIABLE state)
	    =
	    case *state
		#
		itt::CVAR_UNSET  waiting
		    =>
		    {   ts::foreground_run_queue ->  rwq::RW_QUEUE { back, ... };
			#
			state :=    itt::CVAR_SET  1;
			#
			back
			    :=
			    add  waiting
			    where
				fun add [] =>   *back;
				    #
				    add ( { mailop_done=>REF itt::MAILOP_DONE, ... } ! rest)
					=>
					add rest;									# Drop cancelled transaction.

				    add ( { mailop_done as REF (itt::MAILOP_PENDING_FOR tid), clean_up, fate } ! rest)
					=>
					{   mailop_done :=   itt::MAILOP_DONE;
					    #
					    clean_up ();

					    (tid, fate)  !  (add rest);
					};
				end;
			    end;
		    };

		 _ => error "cvar already set";
	    esac;


	# The mailop constructor for
	# waiting on a condition variable:
	#
	fun wait_on_condvar__mailop (itt::CONDITION_VARIABLE  state)
	    =
	    BASE_MAILOPS [is_ready]
	    where 
		fun wait_for { mailop_done, clean_up, next }									# Reppy calls this fn blockFn
		    =
		    call_with_current_fate
			(fn fate
			    =
			    {   waiting =   case *state
						#
						itt::CVAR_UNSET waiting =>   waiting;
						_                       =>   raise exception FAIL "Bug in wait_on_condvar__mailop";	# Impossible -- is_ready only queues us up if *state is not CVAR_SET.
					    esac;
				#
				item =  { mailop_done,  clean_up,  fate };

				state :=  itt::CVAR_UNSET (item ! waiting);

				next ();
			    }
			);

		fun is_ready ()													# Reppy calls this fn pollFn
		    =
		    case *state
			#
			itt::CVAR_SET n
			    =>
			    {   state := itt::CVAR_SET (n+1);
				#
				MAILOP_READY { priority => n, do_it }
				where
				    fun do_it ()										# Reppy calls this fn doFn
					=
					{   state :=  itt::CVAR_SET  1;
					    #
					    ts::reenable_thread_switching ();
					};
				end;
			    };

			itt::CVAR_UNSET _
			    =>
			    MAILOP_UNREADY  wait_for;
		    esac;
	    end;


	# A mailop which is always ready
	# and produces given result:
	#
	fun always_mailop  result
	    =
	    BASE_MAILOPS
	      [
		fn () = itt::MAILOP_READY
			  { priority  =>  -1,
			    do_it =>  fn () = {   ts::reenable_thread_switching ();						# Reppy calls this field doFn
						  result;
					      }
			  }
	      ];

	never = BASE_MAILOPS [];												# A mailop which is never ready:

	guard = GUARD;

	with_nack = WITH_NACK;

	fun choose (mailops:  List(  Mailop(X) ))										# 'gather_mailops' handles the general case.
	    =															# 'gather_baseops' assumes common special case of only base mailops;
	    gather_baseops (reverse mailops, [])										#  We optimistically start with gather_baseops; we'll fall back to gather_mailops if necessary.
	    where
		fun gather_baseops ([],                           baseops') =>  BASE_MAILOPS baseops';				# Done, return result.
		    #
		    gather_baseops (BASE_MAILOPS []       ! rest, baseops') =>  gather_baseops (rest,           baseops');
		    gather_baseops (BASE_MAILOPS [baseop] ! rest, baseops') =>  gather_baseops (rest, baseop  ! baseops');
		    gather_baseops (BASE_MAILOPS  baseops ! rest, baseops') =>  gather_baseops (rest, baseops @ baseops');
		    #
		    gather_baseops (mailops, []) =>  gather_mailops (mailops, []);
		    gather_baseops (mailops, l ) =>  gather_mailops (mailops, [BASE_MAILOPS l]);
		end 

		also
		fun gather_mailops ([], [mailop]) => mailop;
		    gather_mailops ([], mailops) => CHOOSE mailops;
		    gather_mailops (CHOOSE mailops ! r, mailops') => gather_mailops (r, mailops @ mailops');
		    gather_mailops (BASE_MAILOPS base_mailops ! r, BASE_MAILOPS base_mailops' ! r') => gather_mailops (r, BASE_MAILOPS (base_mailops @ base_mailops') ! r');
		    gather_mailops (mailop ! r, mailops') => gather_mailops (r, mailop ! mailops');
		end;
	    end;

	fun wrap (mailop, wfn)				# ==>  op.
	    =
	    wrap' mailop
	    where
		fun wrap_base_mailop  is_ready  ()
		    =
		    case (is_ready ())
			#
			MAILOP_READY { priority, do_it } =>  MAILOP_READY { priority, do_it => wfn o do_it };
			MAILOP_UNREADY wait_for          =>  MAILOP_UNREADY (wfn o wait_for);
		    esac;

		fun wrap' (BASE_MAILOPS base_mailops)    =>  BASE_MAILOPS (map  wrap_base_mailop  base_mailops);
		    #
		    wrap' (CHOOSE mailops)               =>  CHOOSE (map wrap' mailops);
		    wrap' (GUARD g)                      =>  GUARD (fn () = wrap (g(), wfn));
		    wrap' (WITH_NACK f)                  =>  WITH_NACK (fn mailop = wrap (f mailop, wfn));
		end;
	    end;

	(==>) = wrap;					# Infix synonym for readability.

	fun wrap_handler (mailop, hfn)
	    =
	    wrap' mailop
	    where
		fun wrap f x
		    =
		    f x
		    except
			exn = hfn exn;

		fun wrap_base_mailop  is_ready ()
		    =
		    case (is_ready ())
			#
			MAILOP_READY { priority, do_it } =>  MAILOP_READY { priority, do_it => wrap do_it };
			MAILOP_UNREADY wait_for          =>  MAILOP_UNREADY (wrap wait_for);
		    esac;

		fun wrap' (BASE_MAILOPS base_mailops)	=>  BASE_MAILOPS (map wrap_base_mailop base_mailops);
		    #
		    wrap' (CHOOSE mailops)		=>  CHOOSE (map wrap' mailops);
		    wrap' (GUARD g)			=>  GUARD  (fn ()  = wrap_handler (g(), hfn));
		    wrap' (WITH_NACK f)			=>  WITH_NACK (fn mailop = wrap_handler (f mailop, hfn));
		end;
	    end;

	Mailop_Group(X)
	  = BASE_GROUP  List( Base_Mailop(X) )
	  | GROUP       List( Mailop_Group(X) )
	  | NACK_GROUP  (itt::Condition_Variable, Mailop_Group(X))
	  ;

    /* +DEBUG
    fun sayGroup (msg, eg) = let
	  fun f (BASE_GROUP l, sl) = "BASE_GROUP(" ! int::to_string (list::length l) ::()) ! sl
	    | f (GROUP l, sl) = "GROUP(" ! g (l, ")" ! sl)
	    | f (NACK_GROUP l, sl) = "NACK_GROUP(" ! f(#2 l, ")" ! sl)
	  also g ([], sl) = sl
	    | g ([x], sl) = f (x, sl)
	    | g (x ! r, sl) = f (x, ", " ! g (r, sl))
	  in
	    Debug::sayDebugId (string::cat (msg ! ": " ! f (eg, ["\n"])))
	  end
    -DEBUG*/

	# Prepare mailop expression to run.
        # In particular, this evaluates all
        # guards in the expression:
	#
	fun prepare (BASE_MAILOPS l) =>   BASE_GROUP l;
	    #
	    prepare mailop
		=>
		prepare' mailop
		where
		    fun prepare' (GUARD g)
			    =>
			    prepare' (g ());

			prepare' (WITH_NACK f)
			    =>
			    {   cvar = itt::CONDITION_VARIABLE (REF (itt::CVAR_UNSET []));
				#
				NACK_GROUP (cvar, prepare' (f (wait_on_condvar__mailop cvar)));
			    };

			prepare' (BASE_MAILOPS  baseops)
			    =>
			    BASE_GROUP  baseops;

			prepare' (CHOOSE mailops)
			    =>
			    prepare_baseops (mailops, [])								# Optimistically assume baseops-only; we'll fall back to general prepare_mailops() routine if we're wrong.
			    where
				fun prepare_baseops ([], baseops)
					=>
					BASE_GROUP baseops;

				    prepare_baseops (mailop ! rest, baseops')
					=>
					case (prepare' mailop)
					    #
					    BASE_GROUP baseops =>  prepare_baseops (rest,  baseops @             baseops' );
					    GROUP      mailops =>  prepare_mailops (rest,  mailops @ [BASE_GROUP baseops']);
					               mailops =>  prepare_mailops (rest, [mailops,   BASE_GROUP baseops']);
					esac;
				end

				also
				fun prepare_mailops ([], [group]) =>  group;						# This fn handles the general case vs prepare_baseops above handling the nice simple (and common) case.
				    prepare_mailops ([], l)       =>  GROUP l;

				    prepare_mailops (mailop ! rest, l)
					=>
					case (prepare' mailop, l)
					    #				      
					    (BASE_GROUP baseops, BASE_GROUP baseops' ! rest')
						=>
						prepare_mailops (rest, BASE_GROUP (baseops @ baseops') ! rest');

					    (GROUP mailops, l) =>   prepare_mailops (rest, mailops @ l);
					    (      mailops, l) =>   prepare_mailops (rest, mailops ! l);		# Here 'mailops' can be BASE_GROUP or NACK_GROUP.
				       esac;
	end;    end;  end;  end;end;


	stipulate
	    #
	    count =  REF 0;					# Runs circularly around range 0..999,999
	    #
	    fun pick_fairly i					# The point here is just to pick fairly among 'i' alternative ready mailops,
		=						# so that we don't consistently pass over any one ready mailop.
		{   j =  *count;
		    #
		    if (j == 1000000)   count := 0;
		    else                count := j+1;
		    fi;

		    int::rem (j, i);
		};
	herein

	    fun select_do_fn ([(_, do_it)], _)
		    =>
		    do_it;

		select_do_fn (l, n)
		    =>
		    max (l, 0, 0, [])
		    where

			fun priority -1 =>  n;
			    priority  p =>  p;
			end;

			fun max ((p, do_it) ! rest,  max_p,  k,  do_its)
				=>
				{   p =  priority p;
				    #
				    if    (p >  max_p)   max (rest,     p, 1,          [do_it]);
				    elif  (p == max_p)   max (rest, max_p, k+1, do_it ! do_its);
				    else                 max (rest, max_p, k,           do_its);
				    fi;
				};

			    max ([], _, k, [do_it])
				=>
				do_it;

			    max ([], _, k, do_its)
				=>
				list::nth (do_its, pick_fairly k);
			end;
		    end;
	     end;
	end;

	fun make_flag ()
	    =
	    {   flag =  REF (itt::MAILOP_PENDING_FOR (ts::get_current_thread()));
		#
		(flag,  fn () =  flag := itt::MAILOP_DONE);
	    };


	stipulate
	    fun do_one_mailop  (is_ready:  Base_Mailop(X))
		=
		{   ts::disable_thread_switching ();
		    #
		    case (is_ready ())
			#	      
			MAILOP_READY { do_it, ... }					# Reppy calls this field doFn
			    =>
			    do_it ();

			MAILOP_UNREADY wait_for
			    =>
			    {   (make_flag ()) ->   (flag, set_flag);
				#
				wait_for  { mailop_done =>  flag,
					    clean_up     =>  set_flag,
					    next         =>  ts::reenable_thread_switching_and_dispatch_next_thread
					  };
			    };
		    esac;
		};
	herein

	    # This function handles the case of
	    # synchronizing on a list of base mailops
	    # (w/o any negative acknowledgements).
	    #
	    # It also handles the case of synchronizing
	    # on NEVER.
	    #
	    fun do_prepared_baseops []    =>  ts::dispatch_next_thread ();
		do_prepared_baseops [bev] =>  do_one_mailop  bev;
		#
		do_prepared_baseops  baseops
		    =>
		    {   ts::disable_thread_switching ();
			#
			do_baseops (baseops, []);
		    }
		    where
			fun do_baseops (is_ready ! rest,  wait_fors)								# In this loop we have not yet found any baseops ready to fire.
				=>
				case (is_ready ())
				    #
				    MAILOP_UNREADY wait_for          =>  do_baseops       (rest, wait_for ! wait_fors);
				    MAILOP_READY { priority, do_it } =>  do_ready_baseops (rest, [(priority, do_it)], 1);
				esac;

			    do_baseops ([], wait_fors)										# Done -- no ready-to-fire baseops found and no candidates left to check.
				=>
				call_with_current_control_fate
				    (fn fate
					=
					{   switch_to_control_fate =  switch_to_control_fate  fate;
					    #
					    (make_flag ()) ->   (mailop_done, set_flag);

					    fun log [] =>   ts::reenable_thread_switching_and_dispatch_next_thread ();
						#
						log (wait_for ! r)
						    =>
						    switch_to_control_fate
							(wait_for
							  { mailop_done,
							    clean_up =>  set_flag,
							    next     =>  fn () = log r
							  }
							);
					    end;

					    log  wait_fors;

					    error "[log]";
					}
				    );
			end

			# NOTE: Maybe we should just keep
			#       track of the max priority?
			#       What about fairness to fixed
			#       priority mailops (e::g., always, timeout?)

			also
			fun do_ready_baseops (is_ready ! r,  do_its,  n)								# In this loop we have found at least one baseop ready to fire.
				=>
				case (is_ready ())
				    #
				    MAILOP_READY { priority, do_it } =>  do_ready_baseops (r, (priority, do_it) ! do_its, n+1);
				    _                                =>  do_ready_baseops (r, do_its, n);
				esac;

			    do_ready_baseops ([],  do_its,  n)
				=>
				select_do_fn  (do_its, n)  ();										# Select a base mailop to fire and then fire it.
			end;
		    end;
	    end;
	end;

	# Walk the mailop group tree,
	# collecting the base mailops
	# (with associated ack flags),
	# also a list of flagsets.
	#
	# A flagset is a
	#     (Condvar, List(Flag(Ack)))
	# pair, where the flags are
	# those associated with the
	# mailops covered by the nack
	# cvar.
	#
	fun collect_baseops_and_flagsets_from_mailops  mailops
	    =
	    case mailops
		#
		GROUP _ =>  gather_mailops (mailops, [], [])
			    where 
				un_wrapped_flag =  REF FALSE;

				fun append_baseops  (baseop ! rest,  results) =>  append_baseops  (rest,  (baseop, un_wrapped_flag) ! results);
				    append_baseops  (           [],  results) =>  results;
				end;

				fun gather_mailops (BASE_GROUP baseops, bl, flagsets)
					=>
					(append_baseops (baseops, bl), flagsets);

				    gather_mailops (GROUP group, bl, flagsets)
					=>
					fold_left  f  (bl, flagsets)  group
					where
					    fun f (group', (bl', flagsets'))
						=
						gather_mailops (group', bl', flagsets');
					end;

				    gather_mailops (group as NACK_GROUP _, bl, flagsets)
					=>
					gather_wrapped (group, bl, flagsets);
				end;
			    end;

		group =>   gather_wrapped (group, [], []);
	    esac
	    where
	        un_wrapped_flag =   REF FALSE;
		#
		fun gather_wrapped (group, bl, flagsets)
			=
			{    (gather (group, bl, [], flagsets))
				->
				(bl, _, flagsets);

			    (bl, flagsets);
			}
			where
			    fun gather (BASE_GROUP baseops, bl, all_flags, flagsets)
				    =>
				    {	(append_baseops (baseops, bl, all_flags))
					    ->
					    (bl', all_flags');

					(bl', all_flags', flagsets);
				    }
				    where
				        fun append_baseops ([],  bl,  all_flags)
						=>
						(bl, all_flags);

					    append_baseops (baseop ! rest,  bl,  all_flags)
						=>
						{   flag = REF FALSE;
						    #
						    append_baseops  (rest,  (baseop, flag) ! bl,  flag ! all_flags);
						};
					end;
				    end;


				gather (GROUP group, bl, all_flags, flagsets)
				    =>
				    fold_left  f  (bl, all_flags, flagsets)  group
				    where
				        fun f (group', (bl', all_flags', flagsets'))
					    =
					    gather (group', bl', all_flags', flagsets');
				    end;

				gather (NACK_GROUP (condvar, group), bl, all_flags, flagsets)
				    =>
				    {   (gather (group, bl, [], flagsets))
					    ->
					    (bl', all_flags', flagsets');

					(bl', all_flags' @ all_flags, (condvar, all_flags') ! flagsets');
				    };
			    end;									# fun gather
			end;										# where
	    end;											# where

	# This function handles the more
	# complicated case of running a
	# mailop expression where negative
	# acknowledgements are involved.
	#
	fun do_prepared_mailops  group
	    =
	    {	ts::disable_thread_switching ();
		#
		do_mailops (bl, []);
	    }
	    where
	        (collect_baseops_and_flagsets_from_mailops  group)
		    ->
		    (bl, flagsets);

		fun check_condvars ()
		    =
		    apply check_condvar flagsets
		    where
			# check_cvar checks the flags of a flag set.
			# If they are all FALSE then the
			# corresponding cvar is set to signal
			# the negative ack.
			#
			fun check_condvar (condvar, flgs)
			    =
			    check_flgs flgs
			    where
				fun check_flgs ((REF TRUE) ! _) =>	();
				    check_flgs (_ ! rest)	=>	check_flgs rest;
				    check_flgs []		=>	set_condvar_in_indivisible_scope  condvar;
				end;
			    end;
		    end;

		fun do_mailops ((is_ready, flag) ! rest, wait_fors)								# In this loop we have not yet found a mailop ready to fire.
			=>
			case (is_ready ())
			    #
			    MAILOP_READY { priority, do_it } =>  do_ready_mailops (rest, [(priority, (do_it, flag))], 1);
			    MAILOP_UNREADY wait_for          =>  do_mailops       (rest, (wait_for, flag) ! wait_fors);
			esac;

		    do_mailops ([], wait_fors)											# End of the line -- no ready-to-fire mailops found and none left to check.
			=>
			call_with_current_control_fate
			    (fn fate
				=
				{   switch_to_control_fate =  switch_to_control_fate  fate;
				    #
				    mailop_done =   REF (itt::MAILOP_PENDING_FOR (ts::get_current_thread ()));

				    fun cleanup_fn flag ()
					=
					{   mailop_done := itt::MAILOP_DONE;
					    flag := TRUE;
					    check_condvars ();
					};

				    fun log [] =>   ts::reenable_thread_switching_and_dispatch_next_thread ();
					#
					log ((wait_for, flag) ! r)
					    =>
					    switch_to_control_fate
						(wait_for { mailop_done,
							    clean_up =>  cleanup_fn flag,
							    next     =>  fn () = log r
							  }
						);
				    end;

				    log  wait_fors;

				    error "[log]";
				 }
			    );
		end

		# NOTE: maybe we should just
		# keep track of the max priority?
		# What about fairness to fixed
		# priority mailops (e::g., always, timeout?)
		#
		also
		fun do_ready_mailops ((is_ready, flag) ! rest, do_its, n)						# In this loop we have found at least one mailop ready to fire.
			=>
			case (is_ready ())
			    #
			    MAILOP_READY { priority, do_it }
				=>
				do_ready_mailops (rest, (priority, (do_it, flag)) ! do_its, n+1);

			    _   =>   do_ready_mailops (rest, do_its, n);
			esac;

		    do_ready_mailops ([], do_its, n)									# End of line -- select one mailop to fire and then fire it.
			=>
			{   (select_do_fn (do_its, n))
				->
				(do_it, flag);

			    flag := TRUE;
			    check_condvars ();
			    do_it();
			};
		end;
	    end;													# fun do_prepared_mailops


	fun do_mailop  mailop
	    =
	    case (prepare mailop)
		#
		BASE_GROUP baseops =>  do_prepared_baseops  baseops;
		           mailops =>  do_prepared_mailops  mailops;
	    esac;


	fun select mailops
	    =
	    case (prepare_baseops (mailops, []))									# Start by optimistically assuming baseops-only case; we'll fall back to general prepare_mailops() if proved wrong.
		#
		BASE_GROUP baseops  =>   do_prepared_baseops  baseops;							# This is special-case handling for baseops-only case.
		           mailops  =>   do_prepared_mailops  mailops;							# This is the general case.
	    esac
	    where
	        fun prepare_baseops  (mailop ! rest,  baseops')								# prepare_baseops handles the nice simple baseop-only cases, prepare_mailops handles the remaining messier cases.
			=>
			case (prepare_one_mailop  mailop)
			    #
			    BASE_GROUP baseops =>  prepare_baseops (rest,        baseops @ baseops' );
			    GROUP      group        =>  prepare_mailops  (rest,  group @ [BASE_GROUP baseops']);
			    nackg as NACK_GROUP _   =>  prepare_mailops  (rest, [nackg,   BASE_GROUP baseops']);
			esac;

		    prepare_baseops ([], baseops)	    =>	BASE_GROUP  baseops;
		end

		also
		fun prepare_mailops ([], [group]) =>  group;
		    prepare_mailops ([], l)       =>  GROUP l;
		    #
		    prepare_mailops (mailop ! rest, l)
			=>
			case (prepare_one_mailop mailop, l)
			    #
			    (BASE_GROUP baseops, BASE_GROUP baseops' ! rest')
				=>
				prepare_mailops (rest, BASE_GROUP (baseops @ baseops') ! rest');

			    (GROUP group, l) =>   prepare_mailops  (rest,  group @ l);
			    (other,       l) =>   prepare_mailops  (rest,  other ! l);					# 'other' can be (BASE_GROUP _) or (NACK_GROUP _).
			esac;
		end

		also
		fun prepare_one_mailop (GUARD g)            =>   prepare_one_mailop (g ());
		    prepare_one_mailop (BASE_MAILOPS group) =>   BASE_GROUP group;
		    prepare_one_mailop (CHOOSE mailops)     =>   prepare_baseops (mailops, []);
		    #
		    prepare_one_mailop (WITH_NACK f)
			=>
			{   cvar =  itt::CONDITION_VARIABLE  (REF  (itt::CVAR_UNSET []));
			    #
			    NACK_GROUP (cvar, prepare_one_mailop (f (wait_on_condvar__mailop cvar)));
			};

		end;
	    end;			# fun select
    };					# package mailop
end;

## COPYRIGHT (c) 1989-1991 John H. Reppy
## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


