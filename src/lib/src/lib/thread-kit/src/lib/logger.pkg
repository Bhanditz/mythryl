# logger.pkg

# Compiled by:
#     src/lib/std/standard.lib


# See the overview comments in
#
#     src/lib/src/lib/thread-kit/src/lib/logger.api
#
# This version of this package is adapted from
# Cliff Krumvieda's utility for logging from
# threadkit programs.
#
# This package is heavily used by:
#     src/lib/x-kit/xclient/pkg/stuff/xlogger.pkg
#
# See also:
#     src/lib/src/lib/thread-kit/src/lib/thread-deathwatch.pkg
#     src/lib/src/lib/thread-kit/src/lib/threadkit-uncaught-exception-reporting.pkg


###            "Einstein argued that there must be
###             simplified explanations of nature,
###             because God is not capricious or arbitrary.
###
###            "No such faith comforts the software engineer."
###
###                         -- Fred Brooks, Jr.



stipulate
    include threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package tc = thread_scheduler_control;	# thread_scheduler_control	is from   src/lib/src/lib/thread-kit/src/posix/thread-scheduler-control.pkg
herein

    package   logger
    : (weak)  Logger				# Logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.api
    {
	# Where log output goes:
	#
	Log_To
	  #
	  = LOG_TO_STDOUT
	  | LOG_TO_STDERR
	  | LOG_TO_NULL
	  | LOG_TO_FILE    String
	  | LOG_TO_STREAM  file::Output_Stream
	  ;

	exception NO_SUCH_NODE;

	# Default to printing log messages to stdout:
	#
	log_to      =  REF LOG_TO_STDOUT;
	logger_cleanup =  REF (fn () = ());

	# Set output for log messsages:
	#
	fun set_logger_to'  t
	    =
	    log_to := t;

	fun logger_is_set_to ()
	    =
	    *log_to;

	Logtree_Node
	    =
	    LOGTREE_NODE
	      {
		parent:     Null_Or (Logtree_Node),		# NULL only on root node of tree.
		name:       String,
		#
		logging:    Ref( Bool ),
		children:   Ref(  List(  Logtree_Node ) )
	      };

	all_logging
	    =
	    LOGTREE_NODE
	      {
		parent    => NULL,
		name      => "logger::all_logging",
		#
		logging   => REF FALSE,
		children  => REF []
	      };

	fun for_all f
	    =
	    for'
	    where
		fun for' (tm as LOGTREE_NODE { children, ... } )
		    =
		    {   f tm;

			for_children *children;
		    }

		also
		fun for_children []
			=>
			();

		    for_children (tm ! r)
			=>
			{   for' tm;
			    for_children r;
			};
		end;
	    end;


	fun node_by_name search_name
	    =
	    case (find [ all_logging ])
		#
		THE node =>  node;
		NULL     =>  raise exception NO_SUCH_NODE;
	    esac 
	    where
		fun find []
			=>
			NULL;

		    find ((node as LOGTREE_NODE { name, children, ... }) ! rest)
			=>
			if (name == search_name)
			    #
			    THE node;
			else
			    case (find *children)
				#
				THE node => THE node;
				NULL     => find rest;
			    esac;
			fi;
		end;
	    end;

	fun make_logtree_leaf'
	    { parent => parent_node as LOGTREE_NODE parent,
	      name
	    }
	    =
	    {   avoid_duplicate_children *parent.children;

		new_node
		    =
		    LOGTREE_NODE
		      {
			name,
			parent    => THE parent_node,
			logging   =>  REF *parent.logging,
			children  =>  REF []
		      };

		parent.children
		    :=
		    new_node ! *parent.children;

		new_node;
	    }
	    where

		fun avoid_duplicate_children []
			=>
			();

		   avoid_duplicate_children ((child_node as LOGTREE_NODE { name => name', ... } ) ! rest)
		       =>
		       if (name == name')
			   #
			   raise exception FAIL (sprintf "logger::make_logtree_leaf: Already have a child '%s' of node '%s'!" name parent.name);
		       else
			   avoid_duplicate_children  rest;
		       fi;
		end;
	    end;

	# Return the name of the node
	#
	fun name (LOGTREE_NODE { name => node_name, ... } )
	    =
	    node_name;

	# Return the parent of the node
	#
	fun parent (LOGTREE_NODE { parent => node_parent, ... } )
	    =
	    node_parent;

	# Return all ancestors of node.
	# First element of list (if nonempty)
	# will always be the root node, all_logging:
	#
	fun ancestors node
	    =
	    ancestors' (node, [])
	    where
		fun ancestors' (LOGTREE_NODE { parent => NULL, ... }, resultlist)
			=>
			resultlist;

		    ancestors' (LOGTREE_NODE { parent => THE parent, name, ... }, resultlist)
			=>
			ancestors' (parent, name ! resultlist);
		end;
	    end;


	# Turn logging on for a logtree node and its descendents:
	#
	enable'
	    =
	    for_all
		(fn (LOGTREE_NODE { logging, ... } )
		    =
		    logging := TRUE);


	# Turn logging off for a logtree node and its descendents:
	#
	disable'
	    =
	    for_all
		(fn (LOGTREE_NODE { logging, ... } )
		    =
		    logging := FALSE);


	# Turn logging on for a node (but not for its descendents):
	#
	fun enable_node' (LOGTREE_NODE { logging, ... } )
	    =
	    logging := TRUE;


	# Return TRUE if this node is being logged
	#
	fun am_logging (LOGTREE_NODE { logging, ... } )
	    =
	    *logging;


	# Return a list of the registered
	# nodes dominated by the given
	# module, and their status.
	#
	fun subtree_nodes_and_log_flags' root
	    =
	    reverse (list (root, []))
	    where
		fun list (tm as LOGTREE_NODE { logging, children, ... }, l)
		    =
		    list_children (*children, (tm, *logging) ! l)

		also
		fun list_children ([], l) => l;
		    list_children (c ! r, l) => list_children (r, list (c, l));
		end;
	    end;

	# As an interactive convenience,
	# print complete logtree indented:
	#
	fun print_logtree ()
	    =
	    print_logtree' ([all_logging], 0)
	    where
		fun print_indent 0 => ();
		    print_indent i => { print "    "; print_indent (i - 1); };
		end;

		fun print_logtree' ((LOGTREE_NODE { name, logging, children, ... }) ! rest, indent)
			=>
			{   print_indent indent;

			    print (*logging ?? "TRUE   " :: "FALSE  ");
			    print name;
			    print "\n";

			    print_logtree' (*children, indent+1);

			    print_logtree' (rest, indent);
			};

		    print_logtree' ([], _)
			=>
			();
		end;
	    end;



	# NOTE: There are bookkeeping bugs when
	# changing the log destination from
	# LOG_TO_STREAM to something else
	# (where the original destination 
	# was LOG_TO_FILE).        XXX BUGGO FIXME
	#
	stipulate

	    lines_printed = REF 0;

	    # Extract the unix Int file descriptor
	    # from a file::Output_Stream -- this is
	    # a bit like pulling teeth:
	    #
	    fun outstream_to_fd  stream						# file			is from   src/lib/std/src/posix/file.pkg
		=								# text_base_io	is from   src/lib/std/src/io/text-base-io.pkg
		{   purestream =  file::get_outstream  stream;

		    my (writer, _)
			=
			file::pure_io::get_writer  purestream;

		    my fd: Int
			=
			case writer
			    #
			    text_base_io::WRITER { io_descriptor => THE iod, ... } =>  iod;
			    _ => raise exception FAIL "logger.pkg: No iod in stream?!";
			esac;	

		    fd;
		};		

	herein

	    fun logprint  message
		=
		{   fun write stream
			=
			{    # Leave every fourth line blank for readability:
			     #
			     if (*lines_printed & 3 == 0)
				 #
				 file::write (stream, "\n");
			     fi;
			     lines_printed := 1 + *lines_printed;

			     file::write (stream, message);

			     file::flush stream;
			};

										    # date		is from   src/lib/std/src/date.pkg
										    # time		is from   src/lib/std/time.pkg
		    case *log_to
			#
			LOG_TO_NULL    =>   ();
			#
			LOG_TO_STDOUT        =>  write  file::stdout;
			LOG_TO_STDERR        =>  write  file::stderr;
			LOG_TO_STREAM stream =>  write  stream;
			#
			LOG_TO_FILE filename
			    =>
			    {   to  = {   stream = file::open_for_write filename;

					  fd =  outstream_to_fd  stream;

					  internet_socket::set_printif_fd  fd;	# Enable C-level log_if()s to this log.

					  file::write (stream, sprintf "# (fd==%d) This is a log created by %s by:\n" fd (date::strftime "%Y-%m-%d:%H:%M:%S" (date::from_time_local (time::get_current_time_utc()))));
					  file::write (stream, "# \n");
					  file::write (stream, "#     src/lib/src/lib/thread-kit/src/lib/logger.pkg\n");
					  file::write (stream, "# \n");
					  file::write (stream, "# log_if line fields are:\n");
					  file::write (stream, "# \n");
					  file::write (stream, "#     timestamp in seconds:   thread id:   thread name:   message   (foo::logging)\n");
					  file::write (stream, "# \n");
					  file::write (stream, "# You can suppress such a message via:   logger::disable foo::logging\n");
					  file::write (stream, "# You can reenable such a message via:   logger::enable foo::logging\n");
					  file::write (stream, "# You can enable all the messages via:   logger::enable logger::all_logging\n");
					  file::write (stream, "# See also:  Comments in src/lib/src/lib/thread-kit/src/lib/logger.api\n");

					  # Closing the logfile at shutdown seems
					  # at first blush like the tidy and proper thing
					  # to do, but in practice it seems a dubious idea:
					  #	
					  #   o The exact order of events such as cleanup calls
					  #     during shutdown is not well-defined, so we may
					  #     easily wind up trying to log stuff after
					  #     the log has already been closed.
					  #	
					  #   o Unix will close all open files at program exit()
					  #     anyhow, and since we're doing unbuffered I/O on
					  #     the log fd, there is not even any buffer
					  #     flushing needing to be done.
					  #	
					  # In short, there seems to be a significant downside to
					  # closing the stream at SHUTDOWN but no upside to speak
					  # of, so	I've commented it out.  Note that caller can
					  # always close the log manually if desired by calling
					  # 
					  #     set_logger_to LOG_TO_STDERR
					  #
					  # or such, thus implicitly closing the file.	
					  #
					  #                              -- 2010-02-26 CrT
					  #	
					  # logger_cleanup
					  #	  :=
					  #	  (fn () = file::close_output  stream);

					  LOG_TO_STREAM stream;
				      }
				      except					# threakit_debug	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit-debug.pkg
					 _ =  {   threadkit_debug::say_debug (
						      cat [
							  "logging: Unable to open \"", filename,
							  "\", redirecting to stdout"
						      ]
						  );

						  LOG_TO_STDOUT;
					      };

				set_logger_to' to;

				logprint  message;
			    };
		     esac;

		};
	end;			# stipulate


	#############################################################################################3
	# Log server

	# All log printing (i.e., calls to log_if)
	# ultimately goes through this mailslot:
	#
	my print_if_slot:  Mailslot( String )
	    =
	    make_mailslot ();


	my plea_slot:  Mailslot (Void -> Void)
	    =
	    make_mailslot ();


												    # Threadkit_Startup_And_Shutdown_Hooks	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit-startup-and-shutdown-hooks.api
												    # Thread_Scheduler_Control			is from   src/lib/src/lib/thread-kit/src/glue/thread-scheduler-control.api
												    # thread_scheduler_control			is from   src/lib/src/lib/thread-kit/src/posix/thread-scheduler-control.pkg
												    # thread_scheduler_control_g		is from   src/lib/src/lib/thread-kit/src/glue/thread-scheduler-control-g.pkg

	my _ =  {   tc::note_mailslot    ("logging: log_if", print_if_slot);
		    tc::note_mailslot    ("logging: request",  plea_slot);

		    tc::note_imp
		      {
			name => "logging: log-imp",
			#
			at_startup  =>  start_log_imp,
			at_shutdown =>  log_imp_shutdown
		      };
		}
		where
		    # 
		    fun log_imp ()
			=
			for (;;) {	
			    #
			    select [

				take'  print_if_slot
				    ==>
				    (fn message = logprint message),

				take'  plea_slot
				    ==>
				    (fn f = f())
			    ];
			};


		    fun start_log_imp ()
			=
			{   make_thread  "logging imp"  log_imp;
			    ();
			};


		    fun log_imp_shutdown  ()
			=
			{   *logger_cleanup ();

			    logger_cleanup
				:=
				(fn () = ());
			};
		end;

	stipulate

	    fun carefully f
		=
		if (tc::thread_scheduler_is_running ())
		    #
		    give (plea_slot, f);
		else
		    f ();
		fi;

	    fun carefully' f
		=
		if (tc::thread_scheduler_is_running ())

		    reply_drop = make_oneshot_maildrop ();

		    give (plea_slot, .{  set (reply_drop, f());  });

		    get reply_drop;

		else
		    f ();
		fi;
	herein

	    fun make_logtree_leaf arg		= carefully' (fn () =  make_logtree_leaf' arg);

	    fun enable tm				= carefully  (fn () =  enable' tm);				# Enable  logging per log subtree.
	    fun disable tm				= carefully  (fn () =  disable' tm);				# Disable logging per log subtree.
	    fun enable_node tm				= carefully  (fn () =  enable_node' tm);			# Enable  logging per logtree node.

	    fun set_logger_to f				= carefully  (fn () =  set_logger_to' f);			# Select destination file/whatever.
	    fun subtree_nodes_and_log_flags root	= carefully' (fn () =  subtree_nodes_and_log_flags' root);

	end;

	fun make_logstring (LOGTREE_NODE { name, ... },  make_message_string_fn)
	    =	
	    {
		# Construct the 'log_if' string to print,
		# and then pass it to the log imp.
		#
		# The point of constructing the string here,
		# rather than in the  log_if  call, is that
		# this way we avoid the work of creating it
		# if we're not going to print it (i.e., if
		# logging is disabled for that call).

#               time_string  =  date::strftime "%Y-%m-%d:%H:%M:%S" (date::from_time_local (time::get_current_time_utc()));	# "2010-01-05:14:17:23" or such.
		time_string  =  time::format 6 (time::get_current_time_utc());							# "1262722876.273621"   or such.
		    #
		    # NB: If you change the time_string content/format you
		    #     should probably make corresponding changes in
		    #
		    #          src/c/lib/socket/print-if.c

		logstring =  time_string + ":  "
			     +  (sprintf "%8d:  %-26s " (thread::get_current_thread's_id())  (thread::get_current_thread's_name() + ": "))
			     + make_message_string_fn()
			     + "    \t(" + name
			     + ")\n";

		logstring;
	    };

	fun log_if (logtree_node as LOGTREE_NODE { logging, name, ... })  make_message_string_fn
	    =
	    if (*logging)
		if (not (tc::thread_scheduler_is_running ()))
		    #
		    logstring = make_logstring  (logtree_node, make_message_string_fn);
		    logprint  logstring;
		    ();
		else
		    #
		    # Originally here we always did
		    #
		    #     logprint (make_logstring  (logtree_node, make_message_string_fn));
		    #
		    # thus doing the print via our thread for mutual exclusion
		    # in standard concurrent-programming style.  Unfortunately,
		    # this produces problems when trying to log through oddball
		    # code like the thread_scheduler itself, where thread-scheduling
		    # is off or SIGARLM is disabled or such.
		    #
		    # Since we're mostly just doing a single unbuffered write to a
		    # unix file descriptor on these calls, which unix semantics
		    # guarantees to be atomic anyhow, there is actually vanishingly
		    # little need for mutual exclusion except when we're actually
		    # opening the file (LOG_TO_FILE case).
		    #	
		    # Consequently, we currently avoid going through print_if_slot
		    # and the log_if thread in all cases except LOG_TO_FILE:
		    #
		    #
		    logstring = make_logstring  (logtree_node, make_message_string_fn);
		    #
 		    case *log_to
 			#
 			LOG_TO_NULL   =>  ();
 			LOG_TO_FILE _ =>  give (print_if_slot, logstring);
 			_             =>  logprint          logstring;
 		    esac;
		fi;
	    fi;

#    	    if (*logging)
#    
#    
#    		if (tc::thread_scheduler_is_running ())
#    		    #
#    		    logstring =  make_logstring  (logtree_node, make_message_string_fn);
#    		    give (print_if_slot, logstring);
#    		fi;
#    
#    # 		if (not (tc::thread_scheduler_is_running ()))
#    # 		    #
#    # #		    logprint  logstring;
#    # 		    ();
#    # 		else
#    # 		    case *log_to
#    # 			#
#    # 			LOG_TO_NULL   =>  ();
#    # 			LOG_TO_FILE _ =>  give (print_if_slot, logstring);
#    # 			_             =>  logprint          logstring;
#    # 		    esac;
#    # 		fi;
#    	    fi;

	# This is an ugly little hack to solve a package cycle problem in
	#     src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler.pkg
	#
	stipulate
	    # This is going to be called at weird places
	    # within the thread scheduler, so we COMPLETELY
	    # skip going through the print_if_slot and our
	    # log_if thread:
	    #
	    fun log_if (logtree_node as LOGTREE_NODE { logging, name, ... })  make_message_string_fn
		=
		if *logging
		    #
		    logstring = make_logstring  (logtree_node, make_message_string_fn);
		    #
		    logprint  logstring;
		fi;

	    thread_scheduler_logging =   make_logtree_leaf { parent => all_logging, name => "thread_scheduler_logging" };
	    to_log                   =   log_if  thread_scheduler_logging;
	herein
	    my _ =   (thread_scheduler::trace_backpatchfn  :=  to_log);
	end;
    };							# package logging

end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


# COPYRIGHT (c) 1992 AT&T Bell Laboratories
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
