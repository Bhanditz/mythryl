## queue.pkg
#
# Immutable, fully persistent queues.
#
# For mutable queues see:
#
#     src/lib/src/rw-queue.pkg

# Compiled by:
#     src/lib/std/standard.lib



###            "I don't know anything about music.
###             In my line you don't have to."
###
###                          -- Elvis Presley



package   queue
: (weak)  Queue						# Queue		is from   src/lib/src/queue.api
{
    Queue(X) = QUEUE { front: List(X),
                       rear:  List(X)
                     };

    exception DEQUEUE;


    empty = QUEUE { front => [],
                   rear  => []
                 };


    fun is_empty (QUEUE { front => [], rear => [] } ) =>  TRUE;
        is_empty _                                   =>  FALSE;
     end;


    fun enqueue (QUEUE { front, rear }, x)
        =
        QUEUE { front, rear=>(x ! rear) };


    fun dequeue (QUEUE { front=>(head ! tail), rear } ) =>  (QUEUE { front=>tail, rear }, head);
	dequeue (QUEUE { rear => [], ...            } ) =>  raise exception DEQUEUE;
	dequeue (QUEUE { rear,       ...            } ) =>  dequeue (QUEUE { front=>reverse rear, rear => [] } );
    end;


    # Drop all queue elements for which
    # 'predicate' returns TRUE:
    #
    fun delete (QUEUE { front, rear }, predicate)
        =
	QUEUE (do_front front)
        where
	    fun do_front []
                    =>
                    { front => do_rear (reverse rear), rear => [] };

	        do_front (this ! rest)
                    =>
                    if (predicate this)
			#
                        { front => rest, rear };
		    else
                        my { front, rear } =  do_front rest;

		        { front =>  this ! front, rear };
                    fi;
            end 

	    also
	    fun do_rear []            =>  [];
	        do_rear (this ! rest) =>  if (predicate this)   rest;
                                          else                  this ! (do_rear rest);
                                          fi;
            end;
	end;


    fun peek (QUEUE { front => (head ! _), ... } ) =>  THE head;
        peek (QUEUE { rear  => [],         ... } ) =>  NULL;
        peek (QUEUE { rear,                ... } ) =>  THE (head (reverse rear));
    end;


    fun head (QUEUE { front => (head ! _), ... } ) =>  head;
        head (QUEUE { rear  => [],         ... } ) =>  raise exception DEQUEUE;
        head (QUEUE { rear,                ... } ) =>  list::head (reverse rear);
    end;


    fun length (QUEUE { rear, front } )
        =
        (list::length rear) + (list::length front);


    fun contents (QUEUE { rear, front } )
        =
        (front @ (reverse rear));


    fun apply f (QUEUE { front, rear } )
        =
        {   list::apply f front;
            list::apply f (list::reverse rear);
        };


    fun map f (QUEUE { front, rear } )
        = 
        QUEUE { front => list::map f front, rear => reverse (list::map f (reverse rear)) };


    fun fold_left  f b (QUEUE { front, rear } ) =  list::fold_right f (list::fold_left f b front) rear;
    fun fold_right f b (QUEUE { front, rear } ) =  list::fold_right f (list::fold_left f b rear) front;
};



## COPYRIGHT (c) 1993 by AT&T Bell Laboratories.  See COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
