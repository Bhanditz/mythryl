# ogl-g.pkg
#
# Here we handle the low-level Ogl-binding functionality
# common to our Ogl-in-main-process and Ogl-in-subprocess
# implementations;  the functionality specific to those two
# is handled by ogl_driver and ogl_via_pipe_driver.				# ogl_driver		is from   src/lib/src/ogl-driver.pkg
#										# ogl_via_pipe_driver	is from   src/lib/src/ogl-via-pipe-driver.pkg

# Compiled by:
#     src/lib/std/standard.lib

# Autogeneration of parts of this file done by:
#
#     src/lib/src/make-ogl-glue
# per src/lib/src/ogl-glue.config

# Unit tests in:
#     src/lib/src/ogl-via-pipe-unit-test.pkg

# Compare with:
#     src/lib/src/easy-ogl.pkg

# The other end of the pipe is implemented in:
#     src/c/ogl/mythryl-ogl-server.c
#
# See the comments in that file for a description
# of the pipe protocol used.



###		"Each design decision constrains all subsequent
###              design decisions, making each successive design
###              problem harder to solve.  Tackle the hardest
###              design problems first, when you have the greatest
###              freedom to maneuver."


# This generic is invoked once each for
# our Ogl-in-main-processs
# and Ogl-in-subprocess
# implementations:
#
#     src/lib/src/ogl.pkg
#     src/lib/src/ogl-via-pipe.pkg
#
#
generic package   ogl_g   (
    #             ===== 
    drv: Ogl_Driver								# Ogl_Driver		is from   src/lib/src/ogl-driver.api
	#
	# When called by ogl.pkg             drv == ogl_driver			# ogl_driver		is from   src/lib/src/ogl-driver.pkg
	# When called by ogl-vira-pipe.pkg   drv == ogl_via_pipe_driver		# ogl_via_pipe_driver	is from   src/lib/src/ogl-via-pipe-driver.pkg
)
:
Ogl										# Ogl			is from   src/lib/src/ogl.api
{
    include ogl_event;								# ogl_event		is from   src/lib/src/ogl-event.pkg

# Do not edit this or following lines -- they are autogenerated by make-ogl-glue.

   #  
# Do not edit this or preceding lines -- they are autogenerated by make-ogl-glue.

    package int_map
        =
        int_red_black_map;

#    Session
#        =
#        { subsession:             drv::Session,
#
#	  # The callback maps let us find the appropriate
#          # Mythryl callback function to run when our OGL
#	  # server process says to run callback #127 or such.
#	  #
#	  # To keep the typechecker happy we need a separate
#	  # map for each callback type:
#	  #
#	  void_callback_map:            Ref( int_map::Map( Void            -> Void )),
#	  bool_callback_map:            Ref( int_map::Map( Bool            -> Void )),
#	  float_callback_map:           Ref( int_map::Map( Float           -> Void )),
#	  button_event_callback_map:    Ref( int_map::Map( Button_Event    -> Void )),
#	  motion_event_callback_map:    Ref( int_map::Map( Motion_Event    -> Void )),
#	  key_event_callback_map:       Ref( int_map::Map( Key_Event       -> Void )),
#	  expose_event_callback_map:    Ref( int_map::Map( Expose_Event    -> Void )),
#	  configure_event_callback_map: Ref( int_map::Map( Configure_Event -> Void )),
#
#          widget_tree:         Ref( Widget ),
#
#	  # The "easy_id" map is support for easy-ogl.{api,pkg},
#	  # where widgets are constructed from tree structured
#	  # specifications and thus lack natural names; assigning
#	  # a widget a text "easy_id" name allows it to be retrieved
#	  # later by name if needed:
#	  #
#          widgets_by_easy_id:  Ref( string_map::Map( Widget ) )
#        };

    #
#    fun set_easy_id (session: Session, id, widget)
#        =
#        session.widgets_by_easy_id
#            :=
#            string_map::set( *session.widgets_by_easy_id, id, widget );

    #
#    fun drop_easy_id (session: Session, id)
#        =
#        session.widgets_by_easy_id
#            :=
#            #1 (string_map::drop (*session.widgets_by_easy_id, id ) );

    #
#    fun get_by_easy_id (session: Session, id)
#        =
#        the (string_map::get( *session.widgets_by_easy_id, id ) );
#


    stipulate


    herein




	#
#	fun run_eventloop_indefinitely (session: Session)
#            =
#            drv::run_eventloop_indefinitely session.subsession;
#
	#
#	fun run_eventloop_once { session: Session, block_until_event: Bool }
#            =
#            drv::run_eventloop_once (session.subsession, block_until_event);
#

# Do not edit this or following lines -- they are autogenerated by make-ogl-glue.

        #
 
 
    # Handlers for X events :		http://library.gnome.org/devel/gtk-tutorial/stable/x182.html
    #
 
    # Callbacks taking a boolean argument:
    #
# Do not edit this or preceding lines -- they are autogenerated by make-ogl-glue.

	#
#	fun get_widget_allocation (session: Session, widget)
#	    =
#	    {   my (x, y, wide, high)
#		    =
#		    drv::get_widget_allocation (session.subsession, widget);
#
#		{ x, y, wide, high };
#	    };

	#
#        fun make_dialog (session: Session)
#            =
#	    {   my (dialog, vbox, action_area)
#		    = 
#                    drv::make_dialog  session.subsession;
#
#		{ dialog, vbox, action_area };
#            };

	#
#        fun set_widget_tree  (session: Session,  widget)
#            =
#            session.widget_tree := widget;

	#
#        fun quit_eventloop  (session: Session)
#            =
#            drv::quit_eventloop  session.subsession;
#
#	fun unref_object (session: Session, widget)
#            =
#            drv::unref_object (session.subsession, widget);
#
    end;

#    stipulate
#	include eight_byte_float;
#    herein
#	fun clamp { min, max, value }
#	    =
#	    if   (value < min)   min;
#	    elif (value > max)   max;
#	    else                 value;
#    	    fi;
#    end;
};




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
