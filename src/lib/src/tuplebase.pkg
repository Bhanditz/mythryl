## tuplebase.pkg
#
# First-cut simple fully-persistent tuplebase.
# This version supports only duples and triples.

# Compiled by:
#     src/lib/std/standard.lib


stipulate
    package im  =  int_red_black_map;						# int_red_black_map				is from   src/lib/src/int-red-black-map.pkg
herein

    package tuplebase
    :       Tuplebase								# Tuplebase					is from   src/lib/src/tuplebase.api
    {

	Other = Exception;

	Atom_Datum = NONE
		   | FLOAT  Float
		   | STRING String
		   | OTHER  Other
		   | TBASE  Exception						# Making Atom_Datum and Tuplebase mutually recursive would be messy, so we use the exception hack instead.
		   ;

	Atom = { id:	Int,
		 datum:	Atom_Datum
	       };

	Duple  = (Atom, Atom);
	Triple = (Atom, Atom, Atom);

	package i1m
	    =
	    red_black_map_with_implicit_keys_g (				# red_black_map_wit_implicit_keys_g		is from   src/lib/src/red-black-map-with-implicit-keys-g.pkg
		package {
		    Key = int::Int;
		    compare = int::compare;
		}
	    );


	package ds								# Sets of Duples
	    =
	    red_black_set_g (							# red_black_set_g				is from   src/lib/src/red-black-set-g.pkg
		#
		package {
		    Key = Duple;
		    #
		    fun compare
			  ( ( { id => id1a, ... },
			      { id => id1b, ... }
			    ):				Duple,
			    ( { id => id2a, ... },
			      { id => id2b, ... }
			    ):				Duple
			  )
			=
			case (int::compare (id1a, id2a))
			    #
			    GREATER =>  GREATER;
			    LESS    =>  LESS;
			    EQUAL   =>  (int::compare (id1b, id2b));
			esac;
		}
	    );

	package ts								# Sets of Triples
	    =
	    red_black_set_g (							# red_black_set_g				is from   src/lib/src/red-black-set-g.pkg
		#
		package {
		    Key = Triple;
		    #
		    fun compare
			  ( ( { id => id1a, ... },
			      { id => id1b, ... },
			      { id => id1c, ... }
			    ):				Triple,
			    ( { id => id2a, ... },
			      { id => id2b, ... },
			      { id => id2c, ... }
			    ):				Triple
			  )
			=
			case (int::compare (id1a, id2a))
			    #
			    GREATER =>  GREATER;
			    LESS    =>  LESS;
			    EQUAL   =>  case (int::compare (id1b, id2b))
					    GREATER =>  GREATER;
					    LESS    =>  LESS;
					    EQUAL   =>  int::compare (id1c, id2c);
					esac;
			esac;
		}
	    );


	Tuplebase
	  =
	  { index_1of2:		im::Map( ds::Set ),
	    index_2of2:		im::Map( ds::Set ),
	    #
	    index_1of3:		im::Map( ts::Set ),
	    index_2of3:		im::Map( ts::Set ),
	    index_3of3:		im::Map( ts::Set )
	  };


	empty_tuplebase
	  =
	  { index_1of2 =>	im::empty:	im::Map( ds::Set ),
	    index_2of2 =>	im::empty:	im::Map( ds::Set ),
	    #
	    index_1of3 =>	im::empty:	im::Map( ts::Set ),
	    index_2of3 =>	im::empty:	im::Map( ts::Set ),
	    index_3of3 =>	im::empty:	im::Map( ts::Set )
	  };

	fun  put_duple
	      (
		{ index_1of2,
		  index_2of2,
		  #
		  index_1of3,
		  index_2of3,
		  index_3of3
		}:							Tuplebase,
		duple as
		( atom1 as { id => id1, ... },
		  atom2 as { id => id2, ... }
		):							Duple
	      )
	    =
	    {   index_1of2
		    =
		    case (im::get (index_1of2, id1))
			#
			THE set =>  im::set (index_1of2, id1, ds::add (set, duple));
			NULL    =>  im::set (index_1of2, id1, ds::singleton(duple));
		    esac;

		index_2of2
		    =
		    case (im::get (index_2of2, id2))
			#
			THE set =>  im::set (index_2of2, id2, ds::add (set, duple));
			NULL    =>  im::set (index_2of2, id2, ds::singleton(duple));
		    esac;

		{ index_1of2,
		  index_2of2,
		  #
		  index_1of3,
		  index_2of3,
		  index_3of3
		}:							Tuplebase;
	    };

	fun  put_triple
	      (
		{ index_1of2,
		  index_2of2,
		  #
		  index_1of3,
		  index_2of3,
		  index_3of3
		}:							Tuplebase,
		triple as
		( atom1 as { id => id1, ... },
		  atom2 as { id => id2, ... },
		  atom3 as { id => id3, ... }
		):							Triple
	      )
	    =
	    {   index_1of3
		    =
		    case (im::get (index_1of3, id1))
			#
			THE set =>  im::set (index_1of3, id1, ts::add (set, triple));
			NULL    =>  im::set (index_1of3, id1, ts::singleton(triple));
		    esac;

		index_2of3
		    =
		    case (im::get (index_2of3, id2))
			#
			THE set =>  im::set (index_2of3, id2, ts::add (set, triple));
			NULL    =>  im::set (index_2of3, id2, ts::singleton(triple));
		    esac;

		index_3of3
		    =
		    case (im::get (index_3of3, id3))
			#
			THE set =>  im::set (index_3of3, id3, ts::add (set, triple));
			NULL    =>  im::set (index_3of3, id3, ts::singleton(triple));
		    esac;

		{ index_1of2,
		  index_2of2,
		  #
		  index_1of3,
		  index_2of3,
		  index_3of3
		}:							Tuplebase;
	    };


	fun get_duples1  ({ index_1of2, ... }: Tuplebase, { id, ... }: Atom) =  im::get (index_1of2, id);
	fun get_duples2  ({ index_2of2, ... }: Tuplebase, { id, ... }: Atom) =  im::get (index_2of2, id);

	fun get_triples1 ({ index_1of3, ... }: Tuplebase, { id, ... }: Atom) =  im::get (index_1of3, id);
	fun get_triples2 ({ index_2of3, ... }: Tuplebase, { id, ... }: Atom) =  im::get (index_2of3, id);
	fun get_triples3 ({ index_3of3, ... }: Tuplebase, { id, ... }: Atom) =  im::get (index_3of3, id);


	fun make_atom ()
	    =
	    { id    =>  id_to_int (issue_unique_id ()),
	      datum =>  NONE
	    };

	fun make_string_atom (s: String)
	    =
	    { id    =>  id_to_int (issue_unique_id ()),
	      datum =>  STRING s
	    };

	fun make_float_atom (f: Float)
	    =
	    { id    =>  id_to_int (issue_unique_id ()),
	      datum =>  FLOAT f
	    };

	fun make_other_atom (x: Other)
	    =
	    { id    =>  id_to_int (issue_unique_id ()),
	      datum =>  OTHER x
	    };

	exception TUPLEBASE Tuplebase;						# Making Atom_Datum and Tuplebase mutually recursive would be messy, so we use the exception hack instead.

	fun make_tuplebase_atom (tuplebase: Tuplebase)
	    =
	    { id    =>  id_to_int (issue_unique_id ()),
	      datum =>  TBASE (TUPLEBASE tuplebase)
	    };


	fun string_of ({ id, datum => STRING s }: Atom) =>  THE s;
	    string_of _					=>  NULL;
	end;

	fun float_of  ({ id, datum => FLOAT  f }: Atom) =>  THE f;
	    float_of  _					=>  NULL;
	end;

	fun other_of  ({ id, datum => OTHER  x }: Atom) =>  THE x;
	    other_of  _					=>  NULL;
	end;

	fun tuplebase_of  ({ id, datum => TBASE (TUPLEBASE tuplebase) }: Atom) =>  THE tuplebase;
	    tuplebase_of  _					               =>  NULL;
	end;

    };
end;










##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
