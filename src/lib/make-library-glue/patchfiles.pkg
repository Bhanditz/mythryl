## patchfiles.pkg
#
# Adding content to files in spots
# marked by linepairs like
#
#    # Do not edit this or following lines -- they are autobuilt.
#    ...
#    # Do not edit this or preceding lines -- they are autobuilt.

# Compiled by:
#     src/lib/std/standard.lib

stipulate
    package deq =  queue;										# queue				is from   src/lib/src/queue.pkg
    package fil =  file__premicrothread;								# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package pf  =  patchfile;										# patchfile			is from   src/lib/make-library-glue/patchfile.pkg
    package sm  =  string_map;										# string_map			is from   src/lib/src/string-map.pkg
    #
    exit_x =  winix__premicrothread::process::exit_x;
    =~     =  regex::(=~);
herein

    # This package is invoked in:
    #
    #     src/lib/make-library-glue/make-library-glue.pkg

    package  patchfiles:
	     Patchfiles											# Patchfiles			is from   src/lib/make-library-glue/patchfiles.api
    {
	Patch =   { filename:  String,
		    patchname: String,
		    lines:     List(String)
		  };

	Patchfiles =   sm::Map( pf::Patchfile );							# Patchfile instances, indexed by filename.


	fun load_patchfile  patchfiles  filename
	    =
	    case (sm::get (patchfiles, filename))
		#
		THE _ =>  patchfiles;
		#
		NULL  =>  sm::set  (patchfiles,  filename,  pf::read_patchfile filename );
	    esac;

	fun get_filenames  patchfiles
	    =
	    sm::keys_list  patchfiles;


	fun write_patchfiles  patchfiles
	    =
	    sm::apply
		(fn patchfile =  pf::write_patchfile  patchfile)
		patchfiles;


	fun get_patch { patchfiles, filename, patchname }
	    =
	    case (sm::get (patchfiles, filename))
		#
		THE patchfile =>    {   (pf::get_patch (patchfile, patchname))
					    ->
					    { patchname, lines };

					{ filename, patchname, lines };
				    };
		#
		NULL	      => raise exception FAIL (sprintf "No such patchable file loaded: %s" filename);
	    esac;


	fun apply_patch  patchfiles  { filename, patchname, lines }
	    =	
	    case (sm::get (patchfiles, filename))
		#
		THE patchfile =>    {   (pf::apply_patch  patchfile  { patchname, lines })
					    ->
					    patchfile;

					sm::set (patchfiles, filename, patchfile);
				    };
		#
		NULL	      => raise exception FAIL (sprintf "No such patchable file loaded: %s" filename);
	    esac;


#	apply_patches:		Patchfiles -> List(Patch)  -> Patchfiles;				# 

#	fun apply_patches  patchfiles  patches
#	    =
#	    apply'  patches
#		    (fn { filename, patchname, lines }
#			=
#			{    case (sm::get (patchfiles, filename))
#				#
#				THE patchfile =>    {   patchfile =  pf::apply_patch  patchfile  { patchname, lines };
#							#
#							sm::set (patchfiles, filename, patchfile);
#				#
#				NULL	      => raise exception FAIL (sprintf "No such patchable file loaded: %s" filename);
#			};
#		    ); 

#	append_to_patch:	Patchfiles -> Patch -> Patchfiles;					# Append  given lines to named patch.
#	prepend_to_patch:	Patchfiles -> Patch -> Patchfiles;					# Prepend given lines to named patch.
#
#	empty_all_patches:	Patchfiles -> Patchfiles;						# Set every patch to contain the empty list.
#
#	map_patches:		Patchfiles -> (Patch -> List(String)) -> Patchfiles;			# Set contents of each patch to some function of that patch.
#
#	patch_apply:		Patchfile	-> (Patch -> Void) -> Void;					# Call user_fn on every patch in file.



    };
end;


## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
