## planfile.api
#

# Compiled by:
#     src/lib/std/standard.lib


stipulate
    package sm  =  string_map;											# string_map		is from   src/lib/src/string-map.pkg
herein

    # This api is implemented in:
    #
    #     src/lib/make-library-glue/planfile.pkg
    #
    api  Planfile
    {
	# Field is a contiguous sequence of lines
	# all with the same linetype field:
	#
	#    foo:  this
	#    foo:  that
	#
	# Most fields will be single-line, but this format
	# supports conveniently including blocks of code,
	# such as complete function definitions.
	#
	Field     =   { name:    String,				# Label appearing before the colon, trimmed of whitespace.
			lines:   List(String),				# Line(s) for this field, stripped of initial label and colon.
			file:    String,				# Name of file from which field was read.
			line_1:  Int,					# First line number in file for field.
			line_n:  Int					# Last  line number in file for field.
		      };


	Fields =  sm::Map( Null_Or( Field ));				# Stored indexed by field name. All mandatory fields will have THE values;
									# optional fields may have NULL values. All mandatory and all optional fields
									# for the paragraph type will have entries in the map.

	Paragraph =   { do_it:	Fields -> Void,				# Does all required work to implement the paragraph type.
			fields:	Fields					# Stored indexed by field name. All mandatory fields will have THE values;
		      };						# optional fields may have NULL values.
	
	Paragraph_Definition
	  =
	  { name:			String,				# The 'build-a' line value.
	    do_it:			Fields -> Void,			# Does all required work to implement the paragraph type.
	    #
	    mandatory_plain_fields:	List( String ),
	    mandatory_raw_fields:	List( String ),
	    #
	    optional_plain_fields:	List( String ),
	    optional_raw_fields:	List( String )
	  };

	Field_Summary =   { optional:		Bool,			# TRUE if this file may be omitted from paragraph.
			    trim_whitespace:	Bool			# TRUE if leading and trailing whitespace should be trimmed from lines for this fieldtype.
			  };

	Digested_Paragraph_Definition
	  =
	  { name:			String,
	    do_it:			Fields -> Void,
	    fields:			sm::Map( Field_Summary )
	  };

	Digested_Paragraph_Definitions
	    =
	    sm::Map( Digested_Paragraph_Definition );			# Stored indexed by name.

	digest_paragraph_definitions:
	    Digested_Paragraph_Definitions				# Previously digested definitions.  sm::empty will do.
	    -> String							# Name of file holding paragraph definitions.
	    -> List(Paragraph_Definition)				# New paragraph definitions to digest.
	    -> Digested_Paragraph_Definitions
	    ;

	read_planfiles:
	    Digested_Paragraph_Definitions				# Supported paragraph types. Used to validate input paragraphs.
	    -> List( String )						# The filenames to read.
	    -> List( Paragraph )					# The validated paragraphs from the planfiles.
	    ;
    };
end;

