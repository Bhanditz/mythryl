## patchable-file.pkg
#
# Adding content to files in spots
# marked by linepairs like
#
#    # Do not edit this or following lines -- they are autobuilt.
#    ...
#    # Do not edit this or preceding lines -- they are autobuilt.

# Compiled by:
#     src/lib/std/standard.lib

api  Patchable_File
{
    Patch = { patchname: String,
              contents:  List(String)
	    };

    File_Part = TEXT  List(String)
	      | PATCH List(String)
	      ;

    Patchable_File
	=
	PATCHABLE_FILE {
	    filename:  String,
	    contents:  List(File_Part)
	};

    print_patchable_file: Patchable_File -> Void;

    read_patchable_file:  String -> Patchable_File;

    write_patchable_file:   Patchable_File -> Void;
    write_patchable_file':  Patchable_File -> List(File_Part) -> Void;

    patch_count:  Patchable_File -> Int;
    text_count:   Patchable_File -> Int;

    get_patch:    Patchable_File -> List(String);							# Patchable_File must contain exactly one patch.
    get_patches:  Patchable_File -> List(List(String));							# 

    set_patch:    Patchable_File -> List(String) -> Patchable_File;					# Patchable_File must contain exactly one patch.
    set_patches:  Patchable_File -> List(List(String)) -> Patchable_File;				# Patchable_File must contain matching number of patches.
    set_patches': Patchable_File -> List(File_Part) -> Patchable_File;					# Patchable_File must contain matching number of patches.
};

stipulate
    package fil =  file__premicrothread;								# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    #
    exit_x =  winix__premicrothread::process::exit_x;
    =~     =  regex::(=~);
herein

    # This package is invoked in:
    #
    #     src/lib/make-library-glue/make-library-glue.pkg

    package  patchable_file:
	     Patchable_File
    {
	# We divide the files we patch into texts and patches
	# according to the scheme
	#
	#        text
	#        # Do not edit this or following lines -- they are autobuilt.
	#        patch
	#        # Do not edit this or preceding lines -- they are autobuilt.
	#        text
	#        
	# where the texts are literal program text provided by the
	# programmer whereas the patches are literal program text
	# which we synthesize.  (The shown 'do not edit' lines are
	# considered part of the texts.)
	#
	# We represent such a file in memory as a list of file
	# segments (that is, texts and patches) where each segment
	# is in turn a list of lines represented as strings:
	#
	File_Part = TEXT   List(String)
		     | PATCH List(String)
		     ;

	Patchable_File
	    =
	    PATCHABLE_FILE {
		filename:  String,
		contents:  List(File_Part)
	    };


	fun print_patchable_file (PATCHABLE_FILE { filename, contents })
	    =
	    {   printf "PATCHABLE_FILE filename = '%s'\n" filename;
		printf "PATCHABLE_FILE contents follow:\n";
		print_patchable_file_contents contents;
	    }
	    where
		fun print_strings [] => ();
		    print_strings (string ! rest)
			=>
			{   print string;
			    print_strings rest;
			};	
		end;

		fun print_patchable_file_contents []
			=>
			();

		    print_patchable_file_contents (TEXT strings ! rest)
			=>
			{   print "TEXT:\n";
			    print_strings strings;
			    print_patchable_file_contents  rest;
			};

		    print_patchable_file_contents (PATCH strings ! rest)
			=>
			{   print "PATCH:\n";
			    print_strings strings;
			    print_patchable_file_contents  rest;
			};
		end;
	    end;

	fun patch_count (PATCHABLE_FILE { contents, ... })
	    =
	    patch_count' (contents, 0)
	    where
		fun patch_count' ([],              n) =>  n;
		    patch_count' (  TEXT _ ! rest, n) =>  patch_count' (rest, n    );
		    patch_count' (PATCH _ ! rest, n) =>  patch_count' (rest, n + 1);
		end;
	    end;

	fun text_count (PATCHABLE_FILE { contents, ... })
	    =
	    text_count' (contents, 0)
	    where
		fun text_count' ([],              n) =>  n;
		    text_count' (  TEXT _ ! rest, n) =>  text_count' (rest, n + 1);
		    text_count' (PATCH _ ! rest, n) =>  text_count' (rest, n    );
		end;
	    end;

	fun get_patch (pf as PATCHABLE_FILE { contents, ... })
	    =
	    case (patch_count pf)
		#
		1 =>    get_patch' contents
			where
			    fun get_patch' []			=>  raise exception FAIL "impossible";
				get_patch' (  TEXT _      ! rest)	=>  get_patch'  rest;
				get_patch' (PATCH patch ! _   )	=>  patch;
			    end;
			end;

		n =>    raise exception FAIL (sprintf "get_patch: Patch has %d patches instead of 1" n);
	    esac;

	fun get_patches (PATCHABLE_FILE { contents, ... })
	    =
	    get_patches' (contents, [])
	    where
		fun get_patches' ([], 			result) =>	reverse result;
		    get_patches' (  TEXT      _ ! rest,	result) =>	get_patches' (rest,          result);
		    get_patches' (PATCH patch ! rest,	result) =>	get_patches' (rest, patch ! result);
		end;
	    end;

	fun set_patch (pf as PATCHABLE_FILE { contents, filename })  patch
	    =
	    case (patch_count pf)
		#
		1 =>    PATCHABLE_FILE { filename, contents => set_patch' contents }
			where
			    fun set_patch' []				=>  raise exception FAIL "impossible";
				#
				set_patch' ((x as TEXT _) ! rest)	=>               x   !   set_patch' rest;
				set_patch' (    PATCH _  ! rest)	=>  (PATCH patch)  !                   rest;
			    end;
			end;

		n =>    raise exception FAIL (sprintf "set_patch: patch has %d patches instead of 1" n);
	    esac;

	fun set_patches (pf as PATCHABLE_FILE { contents, filename })  replacement_patches
	    =
	    PATCHABLE_FILE  { filename,  contents => set_it (contents, replacement_patches) }
	    where
		fun set_it ([], [])					=>  [];
		    #
		    set_it ([], _)					=>  raise exception FAIL (sprintf "set_patches: Too many patches (%d) provided for %s." (list::length replacement_patches) filename);
		    #
		    set_it ((x as TEXT   _) ! rest,            patches)	=>                x   !   set_it (rest, patches);
		    set_it ((     PATCH _) ! rest,   patch ! patches)	=>  (PATCH patch)   !   set_it (rest, patches);
		    #
		    set_it (_, [])					=>  raise exception FAIL (sprintf "set_patches: Too few patches (%d) provided for %s."  (list::length replacement_patches) filename);
		end;
	    end;

	fun set_patches' (pf as PATCHABLE_FILE { contents, filename })  replacement_patches
	    =
	    PATCHABLE_FILE  { filename,  contents => set_it (contents, replacement_patches) }
	    where
		fun set_it ([], [])								=>  [];
		    #
		    set_it (_, TEXT _ ! _)							=>  raise exception FAIL  sprintf "set_patches': TEXT in provided PATCH list!";
		    set_it ([], _)								=>  raise exception FAIL (sprintf "set_patches': Too many patches (%d) provided for %s." (list::length replacement_patches) filename);
		    #
		    set_it ((text as TEXT   _) ! rest,                          patches)	=>    text   !   set_it (rest, patches);
		    set_it ((        PATCH _) ! rest,   (patch as PATCH _) ! patches)	=>  patch   !   set_it (rest, patches);
		    #
		    set_it (_, [])								=>  { print_patchable_file pf; raise exception FAIL (sprintf "set_patches': Too few patches (%d) provided for %s."  (list::length replacement_patches) filename); };
		end;
	    end;


	# Read and return a Patchable_File:
	#
	fun read_patchable_file  filename
	    =
	    {   fd = fil::open_for_read filename
		     except
			io_exceptions::IO _
			    =
			    {   fprintf fil::stderr "Fatal: Unable to open input file '%s'" filename;
				exit_x(1);
			    };
		contents
		    =
		    read_text ([], [])
		    where
			fun read_text (segments, lines)
			    =
			    case (fil::read_line  fd)
				#
				NULL => reverse ((TEXT (reverse lines)) ! segments);

				THE line
				    =>
				    if (line =~ ./ Do not edit this or following lines -- they are autobuilt./)
					#
					read_patch ((TEXT (reverse (line ! lines))) ! segments, []);
				    else
					read_text (segments, line ! lines);
				    fi;	
			    esac

			also
			fun read_patch (segments, lines)
			    =
			    case (fil::read_line  fd)
				#
				NULL =>
				    {   fprintf fil::stderr "Fatal: Missing 'Do not edit this or preceding lines' line in %s" filename;
					exit_x(1);
				    };

				THE line
				    =>
				    if (line =~ ./ Do not edit this or preceding lines -- they are autobuilt./)
					#
					read_text ((PATCH (reverse lines)) ! segments, [ line ]);
				    else
					read_patch (segments, line ! lines);
				    fi;	
			    esac;
		    end;

		fil::close_input  fd;

		PATCHABLE_FILE { filename, contents };
	    };

	# Write a patchable file back into the filesystem.
	#
	fun write_patchable_file  (PATCHABLE_FILE { filename, contents })
	    =
	    {   patch_lines_written =  REF 0;
		#
		tmp_filename = filename + "~";

		fd = fil::open_for_write  tmp_filename
		     except
			io_exceptions::IO _
			    =
			    {   fprintf fil::stderr "Fatal: Unable to open output file '%s'" tmp_filename;
				exit_x(1);
			    };


		fun write_text_lines  (line ! rest)
			=>
			{   fil::write (fd, line);
			    #
			    write_text_lines  rest;
			};

		    write_text_lines [] =>  ();
		end;


		fun write_patch_lines  (line ! rest)					# Actually 'line' may be just a string (i.e., line fragment).
			=>
			{   fil::write (fd, line);
			    patch_lines_written := *patch_lines_written + 1;		# This is the only difference between us and write_text_lines.
			    write_patch_lines rest;
			};

		    write_patch_lines  [] =>  ();
		end;


		write_text  contents
		where
		    fun write_text ((TEXT lines) ! rest)
			    =>
			    {
				write_text_lines lines;
				write_patch rest;
			    };

			write_text []
			    =>
			    ();

			write_text _
			    =>
			    raise exception FAIL (sprintf "Internal bug detected in write_text in write_patchable_file while processing %s" filename);
		    end

		    also
		    fun write_patch ((PATCH lines) ! rest)
			    =>
			    {
				write_patch_lines lines;
				write_text rest;
			    };

			write_patch []
			    =>
			    ();

			write_patch _
			    =>
			    raise exception FAIL (sprintf "Internal bug detected in write_patch in write_patchable_file while processing %s" filename);
		    end;
		end;	

		fil::close_output fd;   

		winix__premicrothread::file::remove_file  filename;

		winix__premicrothread::file::rename_file { from => tmp_filename, to => filename };

		printf "Successfully patched %4d lines in %s\n"  *patch_lines_written  filename;
	    };


	# Write a patchable file back into the filesystem.
	#
	fun write_patchable_file'  patchable_file  patches
	    =
	    {   patchable_file =  set_patches'  patchable_file  patches;
		#
		write_patchable_file  patchable_file;
	    };



    };
end;


## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
