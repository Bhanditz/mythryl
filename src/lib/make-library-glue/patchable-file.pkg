## patchable-file.pkg
#
# Adding content to files in spots
# marked by linepairs like
#
#    # Do not edit this or following lines -- they are autobuilt.
#    ...
#    # Do not edit this or preceding lines -- they are autobuilt.

# Compiled by:
#     src/lib/std/standard.lib

api  Patchable_File
{
    File_Segment = EXON   List(String)
		 | INTRON List(String)
		 ;

    Patchable_File
	=
	PATCHABLE_FILE {
	    filename:  String,
	    contents:  List(File_Segment)
	};

    read_patchable_file:  String -> Patchable_File;

    write_patchable_file:   Patchable_File -> List(File_Segment) -> Void;

    intron_count: Patchable_File -> Int;
    exon_count:   Patchable_File -> Int;

    get_intron:  Patchable_File -> List(String);							# Patchable_File must contain exactly one intron.
    get_introns: Patchable_File -> List(List(String));							# 

    set_intron:  Patchable_File -> List(String) -> Patchable_File;					# Patchable_File must contain exactly one intron.
    set_introns: Patchable_File -> List(List(String)) -> Patchable_File;				# Patchable_File must contain matching number of introns.
};

stipulate
    package fil =  file__premicrothread;							# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    #
    exit_x =  winix__premicrothread::process::exit_x;
    =~     =  regex::(=~);
herein

    # This package is invoked in:
    #
    #     src/lib/make-library-glue/make-library-glue.pkg

    package  patchable_file:
	     Patchable_File
    {
	# We divide the files we patch into exons and introns
	# according to the scheme
	#
	#        exon
	#        # Do not edit this or following lines -- they are autobuilt.
	#        intron
	#        # Do not edit this or preceding lines -- they are autobuilt.
	#        exon
	#        
	# where the exons are literal program text provided by the
	# programmer whereas the introns are literal program text
	# which we synthesize.  (The shown 'do not edit' lines are
	# considered part of the exons.)
	#
	# We represent such a file in memory as a list of file
	# segments (that is, exons and introns) where each segment
	# is in turn a list of lines represented as strings:
	#
	File_Segment = EXON   List(String)
		     | INTRON List(String)
		     ;

	Patchable_File
	    =
	    PATCHABLE_FILE {
		filename:  String,
		contents:  List(File_Segment)
	    };


	# Read and return a Patchable_File:
	#
	fun read_patchable_file  filename
	    =
	    {   fd = fil::open_for_read filename
		     except
			io_exceptions::IO _
			    =
			    {   fprintf fil::stderr "Fatal: Unable to open input file '%s'" filename;
				exit_x(1);
			    };
		contents
		    =
		    read_exon ([], [])
		    where
			fun read_exon (segments, lines)
			    =
			    case (fil::read_line  fd)
				#
				NULL => reverse ((EXON (reverse lines)) ! segments);

				THE line
				    =>
				    if (line =~ ./ Do not edit this or following lines -- they are autobuilt./)
					#
					read_intron ((EXON (reverse (line ! lines))) ! segments, []);
				    else
					read_exon (segments, line ! lines);
				    fi;	
			    esac

			also
			fun read_intron (segments, lines)
			    =
			    case (fil::read_line  fd)
				#
				NULL =>
				    {   fprintf fil::stderr "Fatal: Missing 'Do not edit this or preceding lines' line in %s" filename;
					exit_x(1);
				    };

				THE line
				    =>
				    if (line =~ ./ Do not edit this or preceding lines -- they are autobuilt./)
					#
					read_exon ((INTRON (reverse lines)) ! segments, [ line ]);
				    else
					read_intron (segments, line ! lines);
				    fi;	
			    esac;
		    end;

		fil::close_input  fd;

		PATCHABLE_FILE { filename, contents };
	    };

	# Write a patchable file back into the filesystem.
	#
	fun write_patchable_file
	    (PATCHABLE_FILE { filename, contents })
	    introns
	    =
	    {   intron_lines_written =  REF 0;
		#
		tmp_filename = filename + "~";

		fd = fil::open_for_write  tmp_filename
		     except
			io_exceptions::IO _
			    =
			    {   fprintf fil::stderr "Fatal: Unable to open output file '%s'" tmp_filename;
				exit_x(1);
			    };


		fun write_exon_lines  (line ! rest)
			=>
			{   fil::write (fd, line);
			    #
			    write_exon_lines  rest;
			};

		    write_exon_lines [] =>  ();
		end;


		fun write_intron_lines  (line ! rest)					# Actually 'line' may be just a string (i.e., line fragment).
			=>
			{   fil::write (fd, line);
			    intron_lines_written := *intron_lines_written + 1;		# This is the only difference between us and write_exon_lines.
			    write_intron_lines rest;
			};

		    write_intron_lines  [] =>  ();
		end;


		write_exon (contents, introns)
		where
		    fun write_exon (((EXON lines) ! rest), introns)
			    =>
			    {
				write_exon_lines lines;
				write_intron (rest, introns);
			    };

			write_exon _
			    =>
			    raise exception FAIL (sprintf "Internal bug in write_exon in write_patchable_file while processing %s" filename);
		    end

		    also
		    fun write_intron ((INTRON _) ! exons, (INTRON lines) ! introns)
			    =>
			    {
				write_intron_lines lines;
				write_exon (exons, introns);
			    };

			write_intron ([], [])
			    =>
			    ();

			write_intron _
			    =>
			    raise exception FAIL (sprintf "Internal bug in write_intron in write_patchable_file while processing %s" filename);
		    end;
		end;	

		fil::close_output fd;   

		winix__premicrothread::file::remove_file  filename;

		winix__premicrothread::file::rename_file { from => tmp_filename, to => filename };

		printf "Successfully patched %4d lines in %s\n"  *intron_lines_written  filename;
	    };


    fun intron_count (PATCHABLE_FILE { contents, ... })
	=
	intron_count' (contents, 0)
	where
	    fun intron_count' ([],              n) =>  n;
		intron_count' (  EXON _ ! rest, n) =>  intron_count' (rest, n    );
		intron_count' (INTRON _ ! rest, n) =>  intron_count' (rest, n + 1);
	    end;
	end;

    fun exon_count (PATCHABLE_FILE { contents, ... })
	=
	exon_count' (contents, 0)
	where
	    fun exon_count' ([],              n) =>  n;
		exon_count' (  EXON _ ! rest, n) =>  exon_count' (rest, n + 1);
		exon_count' (INTRON _ ! rest, n) =>  exon_count' (rest, n    );
	    end;
	end;

    fun get_intron (pf as PATCHABLE_FILE { contents, ... })
	=
	case (intron_count pf)
	    #
	    1 =>    get_intron' contents
		    where
			fun get_intron' []			=>  raise exception FAIL "impossible";
			    get_intron' (  EXON _      ! rest)	=>  get_intron'  rest;
			    get_intron' (INTRON intron ! _   )	=>  intron;
			end;
		    end;

	    n =>    raise exception FAIL (sprintf "get_intron: Intron has %d introns instead of 1" n);
	esac;

    fun get_introns (PATCHABLE_FILE { contents, ... })
	=
	get_introns' (contents, [])
	where
	    fun get_introns' ([], 			result) =>	reverse result;
		get_introns' (  EXON      _ ! rest,	result) =>	get_introns' (rest,          result);
		get_introns' (INTRON intron ! rest,	result) =>	get_introns' (rest, intron ! result);
	    end;
	end;

    fun set_intron (pf as PATCHABLE_FILE { contents, filename })  intron
	=
	case (intron_count pf)
	    #
	    1 =>    PATCHABLE_FILE { filename, contents => set_intron' contents }
		    where
			fun set_intron' []				=>  raise exception FAIL "impossible";
			    #
			    set_intron' ((x as EXON _) ! rest)	=>               x   !   set_intron' rest;
			    set_intron' (    INTRON _  ! rest)	=>  (INTRON intron)  !                   rest;
			end;
		    end;

	    n =>    raise exception FAIL (sprintf "set_intron: intron has %d introns instead of 1" n);
	esac;
	
    fun set_introns (pf as PATCHABLE_FILE { contents, filename })  replacement_introns
	=
	PATCHABLE_FILE  { filename,  contents => set_introns' (contents, replacement_introns) }
	where
	    fun set_introns' ([], _)					=>  raise exception FAIL "set_introns: Too many introns provided.";
		set_introns' (_, [])					=>  raise exception FAIL "set_introns: Too few introns provided.";
		#
		set_introns' ((x as EXON   _) ! rest,            introns)	=>                x   !   set_introns' (rest, introns);
		set_introns' ((     INTRON _) ! rest,   intron ! introns)	=>  (INTRON intron)   !   set_introns' (rest, introns);
	    end;
	end;

    };
end;


## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
