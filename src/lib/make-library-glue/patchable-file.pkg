## patchable-file.pkg
#
# Adding content to files in spots
# marked by linepairs like
#
#    # Do not edit this or following lines -- they are autobuilt.
#    ...
#    # Do not edit this or preceding lines -- they are autobuilt.

# Compiled by:
#     src/lib/std/standard.lib

stipulate
    package fil =  file__premicrothread;								# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package sm  =  string_map;										# string_map			is from   src/lib/src/string-map.pkg
    #
    exit_x =  winix__premicrothread::process::exit_x;
    =~     =  regex::(=~);
herein

    # This package is invoked in:
    #
    #     src/lib/make-library-glue/make-library-glue.pkg

    package  patchable_file:
	     Patchable_File										# Patchable_File		is from   src/lib/make-library-glue/patchable-file.api
    {
	# We divide the files we patch into texts and patches
	# according to the scheme
	#
	#        text
	#        # Do not edit this or following lines -- they are autobuilt.
	#        patch
	#        # Do not edit this or preceding lines -- they are autobuilt.
	#        text
	#        
	# where the texts are literal program text provided by the
	# programmer whereas the patches are literal program text
	# which we synthesize.  (The shown 'do not edit' lines are
	# considered part of the texts.)
	#
	# We represent such a file in memory as a list of file
	# parts (that is, texts and patches) where each part
	# is in turn a list of lines represented as strings:
	#

	Patch = { patchname: String,									# This is the externally visible representation of a patch,
		  lines:     List(String)								# mostly used for arguments and results for exported functions.
		};

	File_Part = TEXT  List(String)									# Static part contents as a list of lines.
		  | PATCH String									# Name of patch.
		  ;

	Patchable_File
	    =
	    PATCHABLE_FILE {
		filename:   String,
		parts:	    List(File_Part),								# This preserves the order of the file parts and the contents of the TEXT parts.
		patches:    sm::Map(Patch)								# This preserves the contents of the patches, indexed by name.
	    };


	fun print_patchable_file (PATCHABLE_FILE { filename, parts, patches })
	    =
	    {   printf "PATCHABLE_FILE filename = '%s'\n" filename;
		printf "PATCHABLE_FILE parts follow:\n";
		print_patchable_file_parts parts;
	    }
	    where
		fun print_strings [] => ();
		    print_strings (string ! rest)
			=>
			{   print string;
			    print_strings rest;
			};	
		end;

		fun print_patchable_file_parts []
			=>
			();

		    print_patchable_file_parts (TEXT strings ! rest)
			=>
			{   print "TEXT:\n";
			    print_strings strings;
			    print_patchable_file_parts  rest;
			};

		    print_patchable_file_parts (PATCH patchname ! rest)
			=>
			case (sm::get (patches, patchname))
			    #
			    THE { patchname, lines }
				=>
				{   printf "PATCH '%s':\n" patchname;
 				    print_strings lines;
				    print_patchable_file_parts  rest;
				};

			    NULL => raise exception FAIL "impossible";
			esac;
		end;
	    end;

	fun patch_count (PATCHABLE_FILE { parts, ... })
	    =
	    patch_count' (parts, 0)
	    where
		fun patch_count' ([],             n) =>  n;
		    patch_count' ( TEXT _ ! rest, n) =>  patch_count' (rest, n    );
		    patch_count' (PATCH _ ! rest, n) =>  patch_count' (rest, n + 1);
		end;
	    end;

	fun text_count (PATCHABLE_FILE { parts, ... })
	    =
	    text_count' (parts, 0)
	    where
		fun text_count' ([],             n) =>  n;
		    text_count' ( TEXT _ ! rest, n) =>  text_count' (rest, n + 1);
		    text_count' (PATCH _ ! rest, n) =>  text_count' (rest, n    );
		end;
	    end;

	fun get_patch_names (PATCHABLE_FILE { patches, ... })
	    =
	    sm::keys_list patches;


	fun get_patch  (PATCHABLE_FILE { filename, patches, ... },  patchname)
	    =
	    case (sm::get (patches, patchname))
		#
		THE patch =>  patch;
		NULL	  =>  raise exception FAIL (sprintf "No patch %s in file %s" patchname filename);
	    esac;


	fun set_patch  (PATCHABLE_FILE { filename, parts, patches },  patchname,  patch)
	    =
	    case (sm::get (patches, patchname))
		#
		THE _ =>    PATCHABLE_FILE  { filename,  parts,  patches => sm::set (patches, patchname, patch) };
		#
		NULL  =>    raise exception FAIL (sprintf "No patch %s in file %s" patchname filename);
	    esac;


	fun get_only_patch (pf as PATCHABLE_FILE { filename, parts, patches })
	    =
	    case (patch_count pf)
		#
		1 =>    get_patch' parts
			where
			    fun get_patch' []			    =>  raise exception FAIL "impossible";
				get_patch' ( TEXT _         ! rest) =>  get_patch'  rest;
				get_patch' (PATCH patchname ! _   ) =>  case (sm::get (patches, patchname))
									    #
									    THE { patchname, lines } => lines;
									    NULL => raise exception FAIL "impossible";
									esac;
			    end;
			end;

		n =>    raise exception FAIL (sprintf "get_only_patch: Patchable file %s has %d patches instead of 1" filename n);
	    esac;

	fun get_patches (PATCHABLE_FILE { patches, ... })
	    =
	    patches;	

	fun set_only_patch (pf as PATCHABLE_FILE { filename, parts, patches })  lines
	    =
	    case (patch_count pf)
		#
		1 =>    PATCHABLE_FILE { filename, parts, patches => set_patch' parts }
			where
			    fun set_patch' []			  =>  raise exception FAIL "impossible";
				#
				set_patch' (TEXT _  ! rest)	  =>  set_patch' rest;
				set_patch' (PATCH patchname ! _)  =>  sm::set (patches, patchname, { patchname, lines } );
			    end;
			end;

		n =>    raise exception FAIL (sprintf "set_only_patch: patchable file %s has %d patches instead of 1" filename n);
	    esac;

	fun set_patches (pf as PATCHABLE_FILE { filename, parts, patches })  replacement_patches
	    =
	    PATCHABLE_FILE  { filename,  parts, patches => set_it (replacement_patches, patches) }
	    where
		fun set_it ([], patches)				=>  patches;
		    #
		    set_it ((patch as { patchname, lines }) ! rest,  patches)
			=>
			case (sm::get (patches, patchname))
			    #
			    THE _  =>  set_it (rest, sm::set (patches, patchname, patch));
			    NULL   =>  raise exception FAIL "impossible";
			esac;
		end;
	    end;



	# Read and return a Patchable_File:
	#
	fun read_patchable_file  filename
	    =
	    {   fd = fil::open_for_read filename
		     except
			io_exceptions::IO _
			    =
			    {   fprintf fil::stderr "Fatal: Unable to open input file '%s'" filename;
				exit_x(1);
			    };

		my (parts, patches)
		    =
		    read_text ([], sm::empty, [])
		    where
			fun read_text (parts, patches, lines)
			    =
			    case (fil::read_line  fd)
				#
				NULL =>  (reverse ((TEXT (reverse lines)) ! parts),  patches);

				THE line
				    =>
				    if (line =~ ./ Do not edit this or following lines -- they are autobuilt.  \(patchname="[A-Za-z0-9_\-]+"\)/)
					#
					patchname =  (regex::find_first_group 1 ./patchname="([A-Za-z0-9_\-]+)"/  line);	# Removing the \ from the pattern yields a useless 'unable to parse' error message.  XXX SUCKO FIXME.
					#
					read_patch ((TEXT (reverse (line ! lines))) ! parts, patches, patchname, []);
				    else
					read_text (parts, patches, line ! lines);
				    fi;	
			    esac

			also
			fun read_patch (parts, patches, patchname, lines)
			    =
			    case (fil::read_line  fd)
				#
				THE line
				    =>
				    if (line =~ ./ Do not edit this or preceding lines -- they are autobuilt./)
					#
					patches = sm::set (patches, patchname, { patchname, lines => reverse (line ! lines) } );

					read_text  ((PATCH patchname) ! parts,  patches,  [ line ]);
				    else
					read_patch (parts, patches, patchname, line ! lines);
				    fi;	

				NULL =>     {   fprintf fil::stderr "Fatal: Missing 'Do not edit this or preceding lines' line in %s" filename;
						exit_x(1);
					    };
			    esac;
		    end;

		fil::close_input  fd;

		PATCHABLE_FILE { filename, parts, patches };
	    };

	# Write a patchable file back into the filesystem.
	#
	fun write_patchable_file  (PATCHABLE_FILE { filename, parts, patches })
	    =
	    {   patch_lines_written =  REF 0;
		#
		tmp_filename = filename + "~";

		fd = fil::open_for_write  tmp_filename
		     except
			io_exceptions::IO _
			    =
			    {   fprintf fil::stderr "Fatal: Unable to open output file '%s'" tmp_filename;
				exit_x(1);
			    };


		fun write_text_lines  (line ! rest)
			=>
			{   fil::write (fd, line);
			    #
			    write_text_lines  rest;
			};

		    write_text_lines [] =>  ();
		end;


		fun write_patch_lines  (line ! rest)					# Actually 'line' may be just a string (i.e., line fragment).
			=>
			{   fil::write (fd, line);
			    patch_lines_written := *patch_lines_written + 1;		# This is the only difference between us and write_text_lines.
			    write_patch_lines rest;
			};

		    write_patch_lines  [] =>  ();
		end;


		write_text  parts
		where
		    fun write_text ((TEXT lines) ! rest)
			    =>
			    {
				write_text_lines lines;
				write_patch rest;
			    };

			write_text []
			    =>
			    ();

			write_text _
			    =>
			    raise exception FAIL (sprintf "Internal bug detected in write_text in write_patchable_file while processing %s" filename);
		    end

		    also
		    fun write_patch ((PATCH patchname) ! rest)
			    =>
			    {
				case (sm::get (patches, patchname))
				    #
				    THE { patchname, lines } =>  write_patch_lines  lines;
				    NULL		     =>  raise exception FAIL "impossible";
				esac;
				
				write_text rest;
			    };

			write_patch []
			    =>
			    ();

			write_patch _
			    =>
			    raise exception FAIL (sprintf "Internal bug detected in write_patch in write_patchable_file while processing %s" filename);
		    end;
		end;	

		fil::close_output fd;   

		winix__premicrothread::file::remove_file  filename;

		winix__premicrothread::file::rename_file { from => tmp_filename, to => filename };

		printf "Successfully patched %4d lines in %s\n"  *patch_lines_written  filename;
	    };


	# Write a patchable file back into the filesystem.
	#
	fun write_patchable_file'  patchable_file  patches
	    =
	    {   patchable_file =  set_patches  patchable_file  patches;
		#
		write_patchable_file  patchable_file;
	    };
    };
end;


## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
