## planfile-unit-test.pkg

# Compiled by:
#     src/lib/test/unit-tests.lib

# Run by:
#     src/lib/test/all-unit-tests.pkg

stipulate
    package pf  =  planfile;						# planfile			is from   src/lib/make-library-glue/planfile.pkg
    package sm  =  string_map;						# string_map			is from   src/lib/src/string-map.pkg
herein

    package planfile_unit_test {
	#
	include unit_test;						# unit_test			is from   src/lib/src/unit-test.pkg
	include makelib::scripting_globals;

	name =  "src/lib/make-library-glue/planfile-unit-test.pkg";

	fun print_strings         [] =>   printf "[]\n";
	    print_strings      [ s ] =>   printf "[ \"%s\" ]\n" s;
	    print_strings (s ! rest)
		=>
		{   printf "[ \"%s\"" s;
		    apply (fn s = printf ", \"%s\"" s) rest;
		    printf "]\n";
		};
	end;

	fun test_duplicate_paragraph_names ()
	    =
	    {	paragraph_definitions
		    =
		    [ { name => "foo",
			process_paragraph => (fn _ = ()),
			fields => [ { fieldname => "foo1",  traits => [] },
				    { fieldname => "foo2",  traits => [ pf::OPTIONAL, pf::DO_NOT_TRIM_WHITESPACE, pf::ALLOW_MULTIPLE_LINES ] }
				  ]
		      },

		      { name => "foo",
			process_paragraph => (fn _ = ()),
			fields => [ { fieldname => "bar1",  traits => [ pf::OPTIONAL ] },
				    { fieldname => "bar2",  traits => [ pf::DO_NOT_TRIM_WHITESPACE, pf::ALLOW_MULTIPLE_LINES ] }
				  ]
		      }
		    ];

		{   digested_defs =  pf::digest_paragraph_definitions  sm::empty  "planfile-unit-test.pkg"  paragraph_definitions;
		    #	
		    assert FALSE;					# Oops, duplicate paragraph names not detected.
		}
		except _ = assert TRUE;					# Indigestion is expected.
	    };

	fun test_duplicate_field_names ()
	    =
	    {	paragraph_definitions
		    =
		    [ { name => "foo",
			process_paragraph => (fn _ = ()),
			fields => [ { fieldname => "foo1",  traits => [] },
				    { fieldname => "foo1",  traits => [ pf::OPTIONAL, pf::DO_NOT_TRIM_WHITESPACE, pf::ALLOW_MULTIPLE_LINES ] }
				  ]
		      },

		      { name => "bar",
			process_paragraph => (fn _ = ()),
			fields => [ { fieldname => "bar1",  traits => [ pf::OPTIONAL ] },
				    { fieldname => "bar2",  traits => [ pf::DO_NOT_TRIM_WHITESPACE, pf::ALLOW_MULTIPLE_LINES ] }
				  ]
		      }
		    ];

		{   digested_defs =  pf::digest_paragraph_definitions  sm::empty  "planfile-unit-test.pkg"  paragraph_definitions;
		    #	
		    assert FALSE;					# Oops, duplicate fieldnames not detected.
		}
		except _ = assert TRUE;					# Indigestion is expected.
	    };

	fun test_bogus_field_names ()
	    =
	    {	paragraph_definitions
		    =
		    [ { name => "foo",
			process_paragraph => (fn _ = ()),
			fields => [ { fieldname => "foo1",  traits => [] },
				    { fieldname => "foo?",  traits => [ pf::OPTIONAL, pf::DO_NOT_TRIM_WHITESPACE, pf::ALLOW_MULTIPLE_LINES ] }
				  ]
		      },

		      { name => "bar",
			process_paragraph => (fn _ = ()),
			fields => [ { fieldname => "bar1",  traits => [ pf::OPTIONAL ] },
				    { fieldname => "bar2",  traits => [ pf::DO_NOT_TRIM_WHITESPACE, pf::ALLOW_MULTIPLE_LINES ] }
				  ]
		      }
		    ];

		{   digested_defs =  pf::digest_paragraph_definitions  sm::empty  "planfile-unit-test.pkg"  paragraph_definitions;
		    #	
		    assert FALSE;					# Oops, bogus fieldname not detected.
		}
		except _ = assert TRUE;					# Indigestion is expected.
	    };

	fun test_basic_paragraph_digestion ()
	    =
	    {	paragraph_definitions
		    =
		    [ { name => "bar",
			process_paragraph => (fn _ = ()),
			fields => [ { fieldname => "foo1",  traits => [ pf::OPTIONAL               ] },
				    { fieldname => "bar2",  traits => [ pf::DO_NOT_TRIM_WHITESPACE ] },
				    { fieldname => "zot3",  traits => [ pf::ALLOW_MULTIPLE_LINES   ] }
				  ]
		      },

		      { name => "foo",
			process_paragraph => (fn _ = ()),
			fields => [ { fieldname => "foo1",  traits => [] },
				    { fieldname => "foo2",  traits => [ pf::OPTIONAL, pf::DO_NOT_TRIM_WHITESPACE, pf::ALLOW_MULTIPLE_LINES ] }
				  ]
		      }

		    ];

		{   digested_defs =  pf::digest_paragraph_definitions  sm::empty  "planfile-unit-test.pkg"  paragraph_definitions;
		    #	
		    assert TRUE;											# We digested without throwing an exception, at least.

		    assert  (length  paragraph_definitions   ==   length  (sm::keys_list  digested_defs));		# We expect as many digested paragraphs as raw paragraphs.

		    assert  (map (fn p = p.name) paragraph_definitions   ==   sm::keys_list  digested_defs);		# We expect digested paragraphs to have same names as raw paragraphs.

		    bar =  the (sm::get (digested_defs, "bar"));
		    foo =  the (sm::get (digested_defs, "foo"));

		    assert (bar.name == "bar");
		    assert (foo.name == "foo");
	
		    assert (length (sm::keys_list  bar.fields) == 3);
		    assert (length (sm::keys_list  foo.fields) == 2);

		    fun assert_exists (map, key)
			=
			case (sm::get (map, key))
			    THE _ => assert TRUE;
			    NULL  => assert FALSE;
			esac;

		    assert_exists (bar.fields, "foo1");
		    assert_exists (bar.fields, "bar2");
		    assert_exists (bar.fields, "zot3");

		    assert_exists (foo.fields, "foo1");
		    assert_exists (foo.fields, "foo2");

		    bar_foo1 =  the (sm::get (bar.fields, "foo1"));
		    bar_bar2 =  the (sm::get (bar.fields, "bar2"));
		    bar_zot3 =  the (sm::get (bar.fields, "zot3"));

		    foo_foo1 =  the (sm::get (foo.fields, "foo1"));
		    foo_foo2 =  the (sm::get (foo.fields, "foo2"));

		    assert (    bar_foo1.optional);	    assert (    bar_foo1.trim_whitespace);	assert (not bar_foo1.allow_multiple_lines);
		    assert (not bar_bar2.optional);	    assert (not bar_bar2.trim_whitespace);	assert (not bar_bar2.allow_multiple_lines);
		    assert (not bar_zot3.optional);	    assert (    bar_zot3.trim_whitespace);	assert (    bar_zot3.allow_multiple_lines);

		    assert (not foo_foo1.optional);	    assert (    foo_foo1.trim_whitespace);	assert (not foo_foo1.allow_multiple_lines);
		    assert (    foo_foo2.optional);	    assert (not foo_foo2.trim_whitespace);	assert (    foo_foo2.allow_multiple_lines);
		}
		except _ = assert FALSE;				# Indigestion.
	    };

	fun run ()
	    =
	    {   printf "\nDoing %s:\n" name;   
		#
		test_duplicate_paragraph_names ();
		test_duplicate_field_names     ();
printf "Testing bogus field names...\n";
		test_bogus_field_names         ();
printf "Tested  bogus field names.\n";
		test_basic_paragraph_digestion ();

		assert TRUE;

		summarize_unit_tests  name;
	    };
    };
end;
