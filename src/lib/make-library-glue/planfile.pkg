## planfile.pkg
#
# Read one or more  .plan files like src/glu/gtk/etc/construction.plan,
# parse and validate the contents, and return as a list of paragraphs.

# Compiled by:
#     src/lib/std/standard.lib

stipulate
    package fil =  file__premicrothread;								# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package deq =  queue;										# queue				is from   src/lib/src/queue.pkg
    package sm  =  string_map;										# string_map			is from   src/lib/src/string-map.pkg
    #
    exit_x =  winix__premicrothread::process::exit_x;
    =~     =  regex::(=~);
    chomp	=  string::chomp;

    #
    fun die_x message
	=
	{   print message;
	    exit_x 1;
	};

    # Drop leading and trailing
    # whitespace from a string.
    #
    fun trim string
	=
	{   if (string =~ ./^\s*$/)

		"";

	    else
		# Drop trailing whitespace:
		#
		string
		    =
		    (regex::find_first_group 1 ./^(.*\S)\s*$/ string)
		    except
			NOT_FOUND = string;

		# Drop leading whitespace:
		#
		string
		    =
		    (regex::find_first_group 1 ./^\s*(\S.*)$/ string)
		    except
			NOT_FOUND = string;

		string;
	    fi;
	};
herein

    # This package is invoked in:
    #
    #     src/lib/make-library-glue/make-library-glue.pkg

    package  planfile:
	     Planfile											# Planfile			is from   src/lib/make-library-glue/planfile.api
    {
	# Field is a contiguous sequence of lines
	# all with the same linetype field:
	#
	#    foo:  this
	#    foo:  that
	#
	# Most fields will be single-line, but this format
	# supports conveniently including blocks of code,
	# such as complete function definitions.
	#
	Field     =   { name:    String,				# Label appearing before the colon, trimmed of whitespace.
			lines:   List(String),				# Line(s) for this field, stripped of initial label and colon.
			file:    String,				# Name of file from which field was read.
			line_1:  Int,					# First line number in file for field.
			line_n:  Int					# Last  line number in file for field.
		      };


	Paragraph =   { do_it:	sm::Map( Null_Or( Field )) -> Void,	# Does all required work to implement the paragraph type.
			fields:	sm::Map( Null_Or( Field ))		# Stored indexed by field name. All mandatory fields will have THE values;
		      };						# optional fields may have NULL values.
	
	Paragraph_Definition
	  =
	  { name:		String,					# The 'build-a' line value.
	    do_it:		sm::Map( Null_Or( Field )) -> Void,	# Does all required work to implement the paragraph type.
	    mandatory_fields:	List( String ),
	    optional_fields:	List( String )
	  };

	Paragraph_Definitions
	    =
	    sm::Map( Paragraph_Definition );				# Stored indexed by name.




	State = { line_number:  Ref(Int),							# Exported as an opaque type.

		  fd:           fil::Input_Stream,

		  fields:       Ref( string_map::Map( Field ))
		};


#		fun maybe_get_field (state: State, field_name)
#		    =
#		    case (string_map::get (*state.fields, field_name))
#			#
#			THE field => { field.used := TRUE;  THE *field.string; };
#			NULL      => NULL;
#		    esac;
#
#		#
#		fun get_field (state: State, field_name)
#		    =
#		    case (string_map::get (*state.fields, field_name))
#			#
#			THE field => { *field.string;
#				     };
#
#			NULL      => die_x (sprintf "Required field %s missing at line %d\n"  field_name  *state.line_number);
#		    esac;

	#
	fun handle_fieldset (state: State)
	    =
	    {
		if (not  (string_map::is_empty  *state.fields))
		    #
#		    case (trim (get_field (state, "build-a")))
#			#
#			"plain-fn"     =>  [];
#			"fn-doc"       =>  [];
#			"mythryl-type" =>  [];
#			"mythryl-code" =>  [];
#			#
#			other_field_name => [];
#		    esac;

		    ();
		fi;
	    };    

	# Scan src/glu/xxx/etc/construction.plan
	# digesting the blank-line-delimited
	# config info paragraphs, then
	# build code accordingly:
	# 
	fun process_library_binding_specification_file  planfile_name
	    =
	    {	planfile_in =  fil::open_for_read  planfile_name;
		#
		loop { line_number =>  REF 0,
		       fd          =>  planfile_in,
		       fields      =>  REF (string_map::empty: string_map::Map( Field ))
		     };

		fil::close_input  planfile_in;
	    }
	    where
		#
		#
#
#		fun update_field (state: State, field_name, field_line)
#		    =
#		    {
#			case (string_map::get (*state.fields, field_name))
#			    #
#			    THE field
#				=>
#				{   field.string := *field.string + field_line;
#				    field.line_n := *state.line_number;
#
#				    string_map::set (*state.fields, field_name, field);
#
#				    ();
#				};
#
#			    NULL =>
#				{   field = { string =>  REF field_line,
#					      line_1 =>  REF *state.line_number,
#					      line_n =>  REF *state.line_number,
#					      used   =>  REF FALSE
#					    };
#
#				    state.fields
#					:=
#					string_map::set (*state.fields, field_name, field);
#
#				    ();
#				};
#			esac;

		fun loop  (state: State)
		    =
		    case (fil::read_line  state.fd)
			#
			NULL => handle_fieldset  state;			# Done.
			#
			THE input_line
			    =>
			    {   state.line_number :=  *state.line_number + 1;
				#
				if (input_line =~ ./^\s*#/)			# If it is a comment line,
				    #
				    loop  state;				# ignore it.

				elif (input_line =~ ./^\s*$/)			# If it is a blank line, it marks the end of a field cluster,
				    #
				    handle_fieldset  state;			# so process any fields we have in hand:

				else

				    # Line format should be  "line-type: rest".
				    # Split it into two strings at the ':' and
				    # dispatch on the line type:
				    #
				    case (regex::find_first_groups_all ./^([^:]+):(.*\n)$/ input_line)
					#
					[ line_type, line_contents ]
					    =>
					    {   # Drop leading and trailing whitespace:
						#
						line_type =  trim  line_type;

						line_contents
						    =
						    case line_type
							"cg-typs"   =>       line_contents;	# Contains raw indented code, so leave whitespace in place and restore dropped newline.
							"cg-funs"   =>       line_contents;	# Contains raw indented code, so leave whitespace in place and restore dropped newline.
							"libcal+"   =>       line_contents;	# Contains raw indented code, so leave whitespace in place and restore dropped newline.
							_           => trim  line_contents;	# Drop leading and trailing whitespace.
						    esac;

#						update_field (state,  line_type,  line_contents);
					    };

					_   =>   die_x ("UNRecognized construction.plan line: '" + (chomp input_line) + "'  -- make-library-glue.pkg\n");
				    esac
				    except
					NOT_FOUND =  die_x (sprintf "Unrecognized construction.plan line %d: '%s'    -- make-library-glue.pkg\n" *state.line_number (chomp input_line));

				fi;

				loop  state;				# Scan rest of file.
			    };
		    esac;

	    end;

	fun read_planfiles  paragraph_definitions  planfiles
	    =
	    [];
    };
end;


## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
