## planfile.pkg
#
# Read one or more  .plan files like src/glu/gtk/etc/construction.plan,
# parse and validate the contents, and return as a list of paragraphs.

# Compiled by:
#     src/lib/std/standard.lib

stipulate
    package deq =  queue;										# queue				is from   src/lib/src/queue.pkg
    package fil =  file__premicrothread;								# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package lms =  list_mergesort;									# list_mergesort		is from   src/lib/src/list-mergesort.pkg
    package sm  =  string_map;										# string_map			is from   src/lib/src/string-map.pkg
    #
    exit_x =  winix__premicrothread::process::exit_x;
    =~     =  regex::(=~);
    chomp	=  string::chomp;

    #
    fun die_x message
	=
	{   print message;
	    exit_x 1;
	};

    # Drop leading and trailing
    # whitespace from a string.
    #
    fun trim string
	=
	{   if (string =~ ./^\s*$/)

		"";

	    else
		# Drop trailing whitespace:
		#
		string
		    =
		    (regex::find_first_group 1 ./^(.*\S)\s*$/ string)
		    except
			NOT_FOUND = string;

		# Drop leading whitespace:
		#
		string
		    =
		    (regex::find_first_group 1 ./^\s*(\S.*)$/ string)
		    except
			NOT_FOUND = string;

		string;
	    fi;
	};
herein

    # This package is invoked in:
    #
    #     src/lib/make-library-glue/make-library-glue.pkg

    package  planfile:
	     Planfile											# Planfile			is from   src/lib/make-library-glue/planfile.api
    {
	# Field is a contiguous sequence of lines
	# all with the same linetype field:
	#
	#    foo:  this
	#    foo:  that
	#
	# Most fields will be single-line, but this format
	# supports conveniently including blocks of code,
	# such as complete function definitions.
	#
	Field     =   { name:    String,				# Label appearing before the colon, trimmed of whitespace.
			lines:   List(String),				# Line(s) for this field, stripped of initial label and colon.
			file:    String,				# Name of file from which field was read.
			line_1:  Int,					# First line number in file for field.
			line_n:  Int					# Last  line number in file for field.
		      };


	Fields =  sm::Map( Null_Or( Field ));				# Stored indexed by field name. All mandatory fields will have THE values;
									# optional fields may have NULL values. All mandatory and all optional fields
									# for the paragraph type will have entries in the map.

	Field_Summary =   { optional:		Bool,
			    trim_whitespace:	Bool
			  };

	Paragraph =   { do_it:	Fields -> Void,	# Does all required work to implement the paragraph type.
			fields:	Fields		
		      };
	
	Paragraph_Definition
	  =
	  { name:			String,				# The 'build-a' line value.
	    do_it:			Fields -> Void,			# Does all required work to implement the paragraph type.
	    #
	    mandatory_plain_fields:	List( String ),
	    mandatory_raw_fields:	List( String ),
	    #
	    optional_plain_fields:	List( String ),
	    optional_raw_fields:	List( String )
	  };

	Digested_Paragraph_Definition
	  =
	  { name:			String,
	    do_it:			Fields -> Void,
	    fields:			sm::Map( Field_Summary )
	  };

	Paragraph_Definitions
	    =
	    sm::Map( Paragraph_Definition );				# Stored indexed by name.


	fun digest_paragraph_definitions  filename  (defs: List(Paragraph_Definition))
	    =
	    list::fold_right  digest_def  sm::empty  defs
	    where
		fun digest_def  (def: Paragraph_Definition,  result)
		    =
		    case (sm::get (result, def.name))
			#
			THE _ =>    die_x (sprintf "Fatal error: Multiple definitions of paragraph type %s" def.name);
			#
			NULL  =>    {   validate_paragraph_definition  def;
					#
					fields =  fold_right  (fn (fieldname, result) = sm::set (result, fieldname, { optional => FALSE, trim_whitespace => TRUE  }))  sm::empty  def.mandatory_plain_fields;
					fields =  fold_right  (fn (fieldname, result) = sm::set (result, fieldname, { optional => FALSE, trim_whitespace => FALSE }))  fields     def.mandatory_raw_fields;
					fields =  fold_right  (fn (fieldname, result) = sm::set (result, fieldname, { optional => TRUE,  trim_whitespace => TRUE  }))  fields     def.optional_plain_fields;
					fields =  fold_right  (fn (fieldname, result) = sm::set (result, fieldname, { optional => TRUE,  trim_whitespace => FALSE }))  fields     def.optional_raw_fields;

					sm::set (result, def.name, { name   =>  def.name,
								     do_it  =>  def.do_it,
								     fields
								   }
						);
				    };
		    esac
		    where
			fun validate_paragraph_definition  (def: Paragraph_Definition)
			    =
			    # Check that fieldnames are unique and match [A-Za-z0-9_\-]+
			    #
			    {   all_fields =   list::cat  [ def.mandatory_plain_fields,
							    def.mandatory_raw_fields,
							    def.optional_plain_fields,
							    def.optional_raw_fields
							  ];

				case (lms::sort_list_and_find_duplicates  string::compare  all_fields)
				    [] 		=>  ();
				    duplicates  =>  {   printf "Paragraph definition %s in planfile %s contains duplicate definitions of:\n"  def.name  filename;
							apply (fn d = printf "    %s\n" d)  duplicates;
							die_x "Fatal error, exiting.";
						    };
				esac;

				sorted_fields =  lms::sort_list  string::(>)  all_fields;

				apply  validate_fieldname  sorted_fields;
			    }
			    where
				fun validate_fieldname  fieldname
				    =
				    if (not (fieldname =~ ./^[A-Za-z0-9_\-]+/))
					#
					die_x (sprintf "File %s paragraph definition %s: %s is not a valid fieldname\n"  filename  def.name  fieldname);
				    fi;
			    end;
		    end;	
	    end;


	State = { line_number:  Ref(Int),							# Exported as an opaque type.

		  fd:           fil::Input_Stream,

		  fields:       Ref( string_map::Map( Field ))
		};


#		fun maybe_get_field (state: State, field_name)
#		    =
#		    case (string_map::get (*state.fields, field_name))
#			#
#			THE field => { field.used := TRUE;  THE *field.string; };
#			NULL      => NULL;
#		    esac;
#
#		#
#		fun get_field (state: State, field_name)
#		    =
#		    case (string_map::get (*state.fields, field_name))
#			#
#			THE field => { *field.string;
#				     };
#
#			NULL      => die_x (sprintf "Required field %s missing at line %d\n"  field_name  *state.line_number);
#		    esac;

	#
	fun handle_fieldset (state: State)
	    =
	    {
		if (not  (string_map::is_empty  *state.fields))
		    #
#		    case (trim (get_field (state, "build-a")))
#			#
#			"plain-fn"     =>  [];
#			"fn-doc"       =>  [];
#			"mythryl-type" =>  [];
#			"mythryl-code" =>  [];
#			#
#			other_field_name => [];
#		    esac;

		    ();
		fi;
	    };    

	# Scan src/glu/xxx/etc/construction.plan
	# digesting the blank-line-delimited
	# config info paragraphs, then
	# build code accordingly:
	# 
	fun process_library_binding_specification_file  planfile_name
	    =
	    {	planfile_in =  fil::open_for_read  planfile_name;
		#
		loop (  { line_number =>  REF 0,
			  fd          =>  planfile_in,
			  fields      =>  REF (string_map::empty: string_map::Map( Field ))
			},
			[]
		     );

		fil::close_input  planfile_in;
	    }
	    where
		#
		#
#
#		fun update_field (state: State, field_name, field_line)
#		    =
#		    {
#			case (string_map::get (*state.fields, field_name))
#			    #
#			    THE field
#				=>
#				{   field.string := *field.string + field_line;
#				    field.line_n := *state.line_number;
#
#				    string_map::set (*state.fields, field_name, field);
#
#				    ();
#				};
#
#			    NULL =>
#				{   field = { string =>  REF field_line,
#					      line_1 =>  REF *state.line_number,
#					      line_n =>  REF *state.line_number,
#					      used   =>  REF FALSE
#					    };
#
#				    state.fields
#					:=
#					string_map::set (*state.fields, field_name, field);
#
#				    ();
#				};
#			esac;

		fun loop  (state: State, results)
		    =
		    case (fil::read_line  state.fd)
			#
			NULL => handle_fieldset  state;			# Done.
			#
			THE input_line
			    =>
			    {   state.line_number :=  *state.line_number + 1;
				#
				if (input_line =~ ./^\s*#/)			# If it is a comment line,
				    #
				    loop  (state, results);			# ignore it.

				elif (input_line =~ ./^\s*$/)			# If it is a blank line, it marks the end of a paragraph (fieldset),
				    #
				    handle_fieldset  state;			# so process any fields we have in hand:

				else

				    # Line format should be  "line-type: rest".
				    # Split it into two strings at the ':' and
				    # dispatch on the line type:
				    #
				    case (regex::find_first_groups_all ./^([^:]+):(.*\n)$/ input_line)
					#
					[ line_type, line_contents ]
					    =>
					    {   # Drop leading and trailing whitespace:
						#
						line_type =  trim  line_type;

						line_contents
						    =
						    case line_type
							"cg-typs"   =>       line_contents;	# Contains raw indented code, so leave whitespace in place and restore dropped newline.
							"cg-funs"   =>       line_contents;	# Contains raw indented code, so leave whitespace in place and restore dropped newline.
							"libcal+"   =>       line_contents;	# Contains raw indented code, so leave whitespace in place and restore dropped newline.
							_           => trim  line_contents;	# Drop leading and trailing whitespace.
						    esac;

#						update_field (state,  line_type,  line_contents);
					    };

					_   =>   die_x ("UNRecognized construction.plan line: '" + (chomp input_line) + "'  -- make-library-glue.pkg\n");
				    esac
				    except
					NOT_FOUND =  die_x (sprintf "Unrecognized construction.plan line %d: '%s'    -- make-library-glue.pkg\n" *state.line_number (chomp input_line));

				fi;

				loop  (state, results);				# Scan rest of file.
			    };
		    esac;

	    end;

	fun read_planfiles  paragraph_definitions  planfiles
	    =
	    [];
    };
end;


## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
