## planfiles.pkg
#
# Adding content to files in spots
# marked by linepairs like
#
#    # Do not edit this or following lines -- they are autobuilt.
#    ...
#    # Do not edit this or preceding lines -- they are autobuilt.

# Compiled by:
#     src/lib/std/standard.lib

stipulate
    package deq =  queue;										# queue				is from   src/lib/src/queue.pkg
    package fil =  file__premicrothread;								# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package pf  =  planfile;										# planfile			is from   src/lib/make-library-glue/planfile.pkg
    package sm  =  string_map;										# string_map			is from   src/lib/src/string-map.pkg
    #
    exit_x =  winix__premicrothread::process::exit_x;
    =~     =  regex::(=~);
herein

    # This package is invoked in:
    #
    #     src/lib/make-library-glue/make-library-glue.pkg

    package  planfiles:
	     Planfiles											# Planfiles			is from   src/lib/make-library-glue/planfiles.api
    {
	Plan =   { filename:  String,
		    planname: String,
		    lines:     List(String)
		  };

	Planfiles =   sm::Map( pf::Planfile );							# Planfile instances, indexed by filename.


	fun load_planfile  planfiles  filename
	    =
	    case (sm::get (planfiles, filename))
		#
		THE _ =>  planfiles;
		#
		NULL  =>  sm::set  (planfiles,  filename,  pf::read_planfile filename );
	    esac;

	fun get_filenames  planfiles
	    =
	    sm::keys_list  planfiles;


	fun write_planfiles  planfiles
	    =
	    sm::apply
		(fn planfile =  pf::write_planfile  planfile)
		planfiles;


	fun get_plan { planfiles, filename, planname }
	    =
	    case (sm::get (planfiles, filename))
		#
		THE planfile =>    {   (pf::get_plan (planfile, planname))
					    ->
					    { planname, lines };

					{ filename, planname, lines };
				    };
		#
		NULL	      => raise exception FAIL (sprintf "No such planable file loaded: %s" filename);
	    esac;


	fun apply_plan  planfiles  { filename, planname, lines }
	    =	
	    case (sm::get (planfiles, filename))
		#
		THE planfile =>    {   (pf::apply_plan  planfile  { planname, lines })
					    ->
					    planfile;

					sm::set (planfiles, filename, planfile);
				    };
		#
		NULL	      => raise exception FAIL (sprintf "No such planable file loaded: %s" filename);
	    esac;


#	apply_plans:		Planfiles -> List(Plan)  -> Planfiles;				# 

#	fun apply_plans  planfiles  plans
#	    =
#	    apply'  plans
#		    (fn { filename, planname, lines }
#			=
#			{    case (sm::get (planfiles, filename))
#				#
#				THE planfile =>    {   planfile =  pf::apply_plan  planfile  { planname, lines };
#							#
#							sm::set (planfiles, filename, planfile);
#				#
#				NULL	      => raise exception FAIL (sprintf "No such planable file loaded: %s" filename);
#			};
#		    ); 

#	append_to_plan:	Planfiles -> Plan -> Planfiles;					# Append  given lines to named plan.
#	prepend_to_plan:	Planfiles -> Plan -> Planfiles;					# Prepend given lines to named plan.
#
#	empty_all_plans:	Planfiles -> Planfiles;						# Set every plan to contain the empty list.
#
#	map_plans:		Planfiles -> (Plan -> List(String)) -> Planfiles;			# Set contents of each plan to some function of that plan.
#
#	plan_apply:		Planfile	-> (Plan -> Void) -> Void;					# Call user_fn on every plan in file.



    };
end;


## Code by Jeff Prothero: Copyright (c) 2010-2012,
## released under Gnu Public Licence version 3.
