## ansi-terminal-markup-buffer.pkg
#
# Prettyprinting to ANSI terminals.
# This device supports the standard ANSI output attributes.

# Compiled by:
#     src/lib/prettyprint/big/devices/prettyprint-devices.sublib





###                 "We should give society not what
###                  it asks for, but what it needs."
###
###                                 -- E.J. Dijkstra



stipulate
    package at  =  ansi_terminal;								# ansi_terminal			is from   src/lib/src/make-ansi-terminal-escape-sequence.pkg
    package fil =  file__premicrothread;							# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package ns  =  number_string;								# number_string			is from   src/lib/std/src/number-string.pkg
    package wnx =  winix__premicrothread;							# winix__premicrothread		is from   src/lib/std/winix--premicrothread.pkg
herein

    api Ansi_Terminal_Markup_Buffer {
	#
	include Markup_Buffer									# Markup_Buffer		is from   src/lib/prettyprint/big/src/markup-buffer.api
		where
		    Textstyle == List( at::Textstyle );

	# Create an output device; if the underlying stream is connected to a TTY,
	# then styled output is enabled, otherwise it will be disabled.

	make_markup_buffer
	    :
	    { dst:  fil::Output_Stream,
	      wid:  Int
	    }
	    ->
	    Markup_Buffer;



	# enable/disable/query styled output.
	#
	#	styleMode (dev, NULL)	-- query current mode
	#	styleMode (dev, THE TRUE)	-- enable styled output
	#	styleMode (dev, THE FALSE)	-- disable styled output
	#
	# This function returns the previous state of the markup_buffer.
	# NOTE: this function raises FAIL if called while a style is active.

	textstyle_mode:  (Markup_Buffer, Null_Or(Bool)) -> Bool;
    };

    package  ansi_terminal_markup_buffer
    : (weak) Ansi_Terminal_Markup_Buffer
    {
	State
	    =
	    { fg:       Null_Or( at::Color ),	#  NULL is default color for terminal 
	      bg:       Null_Or( at::Color ),	#  NULL is default color for terminal 
	      bold:     Bool,
	      blink:    Bool,
	      ul:       Bool,
	      reverse:  Bool,
	      invis:    Bool
	    };

	init_state
	    =
	    { fg      => NULL,
	      bg      => NULL,
	      bold    => FALSE,
	      blink   => FALSE,
	      ul      => FALSE,
	      reverse => FALSE,
	      invis   => FALSE
	    };

	#  Compute the commands to transition from one state to another 
	fun transition (s1:  State, s2:  State)
	    =
	    {   fun needs_color_reset proj
		    =
		    case (proj s1, proj s2)

			 (THE _, NULL) =>  TRUE;
			 _             =>  FALSE;
		     esac;


		fun needs_reset proj
		    =
		    case (proj s1, proj s2)

			 (TRUE, FALSE) =>  TRUE;
			 _             =>  FALSE;
		    esac;


		#  Does the state transition require resetting the attributes first? 
		reset =  needs_color_reset .fg
		      or needs_color_reset .bg
		      or needs_reset .bold
		      or needs_reset .blink
		      or needs_reset .ul
		      or needs_reset .reverse
		      or needs_reset .invis;


		#  Compute the commands to set the foreground color 
		mv  =
		    case (reset, s1.fg, s2.fg)

			 (FALSE,  THE c1,  THE c2)
			     =>
			     if (c1 == c2 ) []; else [at::FG c2];fi;

			 (_, _, THE c) =>  [at::FG c];
			 (_, _, NULL)  =>  [];
		    esac;


		#  Compute the commands to set the background color 
		#
		mv  =
		    case (reset, s1.bg, s2.bg)
			#
			(FALSE, THE c1, THE c2)
			    =>
			    if (c1 == c2 ) mv; else at::FG c2 ! mv;fi;

			(_, _, THE c) =>  at::BG c ! mv;
			(_, _, NULL)  =>  mv;
		    esac;


		# Compute the commands to set the other display attributes:
		#
		fun add (proj, cmd, mv)
		    =
		    if ((reset or not (proj s1))   and   proj s2)     cmd ! mv;
		    else					            mv;
		    fi;

		mv = add (.bold, at::BF, mv);
		mv = add (.blink, at::BLINK, mv);
		mv = add (.ul, at::UL, mv);
		mv = add (.reverse, at::REV, mv);
		mv = add (.invis, at::INVIS, mv);

		case (reset, mv)
		    #
		    (FALSE, []) =>  "";
		    (TRUE,  []) =>  at::to_string [];
		    (TRUE,  mv) =>  at::to_string [] + at::to_string mv;
		    (FALSE, mv) =>  at::to_string mv;
		esac;

	    };

	# Apply a command to a state:
	#
	fun update_state1 (cmd, { fg, bg, bold, blink, ul, reverse, invis } )
	    =
	    case cmd
		#
		at::FG c  =>	{ fg=>THE c,  bg,      bold, blink, ul,   reverse,  invis };
		at::BG c  =>	{ fg,     bg=>THE c,   bold, blink, ul,   reverse,  invis };
		at::BF    =>	{ fg,     bg,      bold=>TRUE, blink, ul,   reverse,  invis };
		at::BLINK =>	{ fg,     bg,      bold, blink=>TRUE,  ul,   reverse,  invis };
		at::UL    =>	{ fg,     bg,      bold, blink, ul=>TRUE, reverse,  invis };
		at::REV   =>	{ fg,     bg,      bold, blink, ul,   reverse=>TRUE,     invis };
		at::INVIS =>	{ fg,     bg,      bold, blink, ul,   reverse,  invis=>TRUE };
	    esac;


	# Apply a sequence of commands to a state:
	#
	fun update_state (     [], st) =>  st;
	    update_state (cmd ! r, st) =>  update_state (r, update_state1 (cmd, st));
	end;

	Textstyle =   List( at::Textstyle );

	Markup_Buffer =    MARKUP_BUFFER  {
		      mode:  Ref( Bool ),
		      dst:  fil::Output_Stream,
		      wid:  Int,
		      stk:  Ref(  List(  State ) )
		    };


	fun top []       =>  init_state;
	    top (st ! r) =>  st;
	end;


	fun same_textstyle (s1:  Textstyle, s2)
	    =
	    s1 == s2;


	fun push_textstyle (MARKUP_BUFFER { mode, dst, wid, stk }, sty)
	    =
	    if *mode
		#
		cur_st = top *stk;
		new_st = update_state (sty, cur_st);

		fil::write (dst, transition (cur_st, new_st));
		stk := new_st ! *stk;
	    fi;


	fun pop_textstyle (MARKUP_BUFFER { mode, dst, wid, stk } )
	    =
	    if  *mode
		#
		case *stk
		    #
		    [] => ();

		    cur_st ! r
			=>
			{   new_st = top r;
			    #
			    fil::write (dst, transition (cur_st, new_st));

			    stk := r;
			};
		esac;
	    fi;


	fun default_textstyle _
	    =
	    [];


	fun is_tty out_s					# Return TRUE iff an output_stream is a TTY.
	    =
	    {   (fil::pur::get_writer  (fil::get_outstream  out_s))
		    ->
		    (winix_base_text_file_io_driver_for_posix__premicrothread::FILEWRITER { io_descriptor, ... }, _);

		case io_descriptor
		    #
		    THE iod =>   (wnx::io::iod_to_iodkind iod  ==  wnx::io::CHAR_DEVICE);
		    _       =>   FALSE;
		esac;
	    };


	fun make_markup_buffer { dst, wid } 
	    =
	    MARKUP_BUFFER {
		dst,
		wid,
		mode => REF (is_tty dst),
		stk  => REF []
	      };


	fun depth _						# Maximum printing depth (in terms of boxes) 
	    =
	    NULL;


	fun line_width (MARKUP_BUFFER { wid, ... } )		# The width of the markup_buffer.
	    =
	    THE wid;


	fun text_width _					# The suggested maximum width of text on a line.
	    =
	    NULL;


	fun space (MARKUP_BUFFER { dst, ... }, n)		# Append given number of spaces to the markup_buffer.
	    =
	    fil::write (dst, ns::pad_left ' ' n "");


	fun newline (MARKUP_BUFFER { dst, ... } )		# Append a newline to the markup_buffer.
	    =
	    fil::write_one (dst, '\n');



	# Write a string/character in the current textstyle to the markup_buffer:
	fun string (MARKUP_BUFFER { dst, ... }, s) =  fil::write (dst, s);
	fun char   (MARKUP_BUFFER { dst, ... }, c) =  fil::write_one (dst, c);


	fun flush (MARKUP_BUFFER { dst, ... } )			# Flush any buffered output.
	    =
	    fil::flush dst;


	# Enable styled output by passing TRUE to this function.
	# Return the previous state of the markup_buffer:

	fun textstyle_mode (MARKUP_BUFFER { stk => REF(_ ! _), ... }, _)
		=>
		raise exception FAIL "attempt to change mode inside scope of textstyle";

	    textstyle_mode (MARKUP_BUFFER { mode, ... }, NULL)
		=>
		*mode;

	    textstyle_mode (MARKUP_BUFFER { mode as REF m, ... }, THE flag)
		=>
		{   mode := flag;
		    m;
		};
	end;
    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 2005 John Reppy (http://www.cs.uchicago.edu/~jhr)
## All rights reserved.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
