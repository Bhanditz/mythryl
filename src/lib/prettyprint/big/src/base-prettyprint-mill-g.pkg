## base-prettyprint-mill-g.pkg
#
# The core prettyprint mill code is located in
# 
#     src/lib/prettyprint/big/src/core-prettyprint-mill-g.pkg
#
# Our job in this file is to wrap the core prettyprint mill up
# in an API more convenient for code clients, thus allowing the
# core prettyprint mill to stay focussed on task.
#
# Our most important code client (by far) is
#
#     src/lib/prettyprint/big/src/standard-prettyprint-mill-g.pkg
# +   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
#
# which is the prettyprint mill used pervasively throughout the
# Mythryl compiler and associated support code.
#
# For historical reasons we also have a number of other code
# clients, which mostly should be phased out over time in favor
# of standard-prettyprint-mill.pkg:
#
#     src/lib/prettyprint/big/src/old-prettyprint-mill.pkg
#     src/lib/prettyprint/big/src/plain-file-prettyprint-mill.pkg
#     src/lib/prettyprint/big/src/ansi-terminal-prettyprint-mill.pkg
#     src/lib/prettyprint/big/src/plain-file-prettyprint-mill-avoiding-pointless-file-rewrites.pkg

# Compiled by:
#     src/lib/prettyprint/big/prettyprint-mill.lib


###            "The gods too are fond of a joke."
###
###                            -- Aristotle



stipulate
    package fil =  file__premicrothread;					# file__premicrothread	is from   src/lib/std/src/posix/file--premicrothread.pkg
herein

    # This generic is invoked most importantly from from
    #
    #     src/lib/prettyprint/big/src/standard-prettyprint-mill-g.pkg
    #
    # but (currently -- these should mostly go away) also
    #
    #    src/lib/prettyprint/big/src/base-prettyprint-mill.pkg
    #    src/lib/prettyprint/big/src/old-prettyprint-mill.pkg
    #    src/lib/prettyprint/big/src/plain-file-prettyprint-mill.pkg
    #    src/lib/prettyprint/big/src/ansi-terminal-prettyprint-mill.pkg
    #    src/lib/prettyprint/big/src/plain-file-prettyprint-mill-avoiding-pointless-file-rewrites.pkg
    #
    generic package   base_prettyprint_mill_g   (
	#             ======================= 
	#
	package tt:	Traitful_Text;						# Traitful_Text								is from   src/lib/prettyprint/big/src/traitful-text.api
	package out:	Prettyprint_Output_Stream;				# Prettyprint_Output_Stream						is from   src/lib/prettyprint/big/src/out/prettyprint-output-stream.api
										# out will be something like html_prettyprint_output_stream		   from   src/lib/prettyprint/big/src/out/html-prettyprint-output-stream.pkg
	sharing tt::Texttraits == out::Texttraits;
    )
    : (weak)  Base_Prettyprint_Mill
    {
	package pp
	    =
	    core_prettyprint_mill_g (						# core_prettyprint_mill_g	is from   src/lib/prettyprint/big/src/core-prettyprint-mill-g.pkg
		#
		package tt  =  tt;						# traitless_text		is from   src/lib/prettyprint/big/src/traitless-text.pkg
		package out =  out;
	    );

	include pp;

	fun end_box				pp		=  finalize_and_pop_current_box   pp;

	fun text   pp s =  add_text   (pp, s, size s);
	fun endtxt pp s =  add_endtxt (pp, s, size s);

	stipulate
	    indent4 = { spaces => 1, tab_to => 0, tabstops_are_every => 4 };
	    indent0 = { spaces => 0, tab_to => 0, tabstops_are_every => 4 };
	herein

	    fun begin_horizontal_4box		pp		=  prettyprint_open_box (pp,  pmt::BOX_RELATIVE    indent4,	horizontal	);
	    fun begin_vertical_4box		pp		=  prettyprint_open_box (pp, (pmt::BOX_RELATIVE    indent4),	vertical	);
	    fun begin_align_4box		pp		=  prettyprint_open_box (pp, (pmt::BOX_RELATIVE    indent4),	normal		);
	    fun begin_wrap_4box			pp		=  prettyprint_open_box (pp, (pmt::BOX_RELATIVE    indent4),	ragged_right	);

	    fun begin_horizontal_0box		pp		=  prettyprint_open_box (pp,  pmt::BOX_RELATIVE    indent0,	horizontal	);
	    fun begin_vertical_0box		pp		=  prettyprint_open_box (pp, (pmt::BOX_RELATIVE    indent0),	vertical	);
	    fun begin_align_0box		pp		=  prettyprint_open_box (pp, (pmt::BOX_RELATIVE    indent0),	normal		);
	    fun begin_wrap_0box			pp		=  prettyprint_open_box (pp, (pmt::BOX_RELATIVE    indent0),	ragged_right	);

	    fun begin_horizontal_cbox		pp		=  prettyprint_open_box (pp,  pmt::CURSOR_RELATIVE indent4,	horizontal	);
	    fun begin_vertical_cbox		pp		=  prettyprint_open_box (pp, (pmt::CURSOR_RELATIVE indent4),	vertical	);
	    fun begin_align_cbox		pp		=  prettyprint_open_box (pp, (pmt::CURSOR_RELATIVE indent4),	normal		);
	    fun begin_wrap_cbox			pp		=  prettyprint_open_box (pp, (pmt::CURSOR_RELATIVE indent4),	ragged_right	);

	    fun begin_indented_horizontal_box	pp indent	=  prettyprint_open_box (pp, indent, 				horizontal	);
	    fun begin_indented_vertical_box	pp indent	=  prettyprint_open_box (pp, indent, 				vertical	);
	    fun begin_indented_align_box	pp indent	=  prettyprint_open_box (pp, indent, 				normal		);
	    fun begin_indented_wrap_box		pp indent	=  prettyprint_open_box (pp, indent, 				ragged_right	);

	    fun horizontal_4box			pp thunk	=   { begin_horizontal_4box	pp;   thunk();   end_box pp; };
	    fun vertical_4box    		pp thunk	=   { begin_vertical_4box	pp;   thunk();   end_box pp; };
	    fun align_4box			pp thunk	=   { begin_align_4box		pp;   thunk();   end_box pp; };
	    fun wrap_4box			pp thunk	=   { begin_wrap_4box		pp;   thunk();   end_box pp; };

	    fun horizontal_0box			pp thunk	=   { begin_horizontal_0box	pp;   thunk();   end_box pp; };
	    fun vertical_0box    		pp thunk	=   { begin_vertical_0box	pp;   thunk();   end_box pp; };
	    fun align_0box			pp thunk	=   { begin_align_0box		pp;   thunk();   end_box pp; };
	    fun wrap_0box			pp thunk	=   { begin_wrap_0box		pp;   thunk();   end_box pp; };

	    fun horizontal_cbox			pp thunk	=   { begin_horizontal_cbox	pp;   thunk();   end_box pp; };
	    fun vertical_cbox    		pp thunk	=   { begin_vertical_cbox	pp;   thunk();   end_box pp; };
	    fun align_cbox			pp thunk	=   { begin_align_cbox		pp;   thunk();   end_box pp; };
	    fun wrap_cbox			pp thunk	=   { begin_wrap_cbox		pp;   thunk();   end_box pp; };

	    fun break				pp arg		=  prettyprint_break (pp, arg);
	    fun space				pp n		=  break pp { spaces => n, indent_on_wrap => 0 };
	    fun cut				pp		=  break pp { spaces => 0, indent_on_wrap => 0 };
	    fun newline				pp		=  prettyprint_newline pp;
	    fun nonbreakable_spaces		pp n		=  text pp (nblanks n);
	    fun tab				pp n		=  add_token (pp, pmt::TAB { spaces => 1, tab_to => n, tabstops_are_every => 4 });
	    fun tab0				pp n		=  add_token (pp, pmt::TAB { spaces => 0, tab_to => n, tabstops_are_every => 4 });

	    fun control				pp control_fn	=  add_token (pp, pmt::CONTROL control_fn);
	end;


    };																	# generic package base_prettyprint_mill_g
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 2003 The SML/NJ Fellowship
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
