## standard-prettyprinter.pkg
#
# Apparently this is actually in use in:
#     src/lib/compiler/back/low/mcg/print-machcode-controlflow-graph-g.pkg
#     src/lib/compiler/front/typer/types/resolve-overloaded-variables.pkg

# Compiled by:
#     src/lib/prettyprint/big/prettyprinting.lib


stipulate
    package fil =  file__premicrothread;				# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
    package pp  =  core_prettyprinter;					# core_prettyprinter		is from   src/lib/prettyprint/big/src/core-prettyprinter.pkg
herein

    package   standard_prettyprinter
    : (weak)  Standard_Prettyprinter					# Standard_Prettyprinter			is from   src/lib/prettyprint/big/src/standard-prettyprinter.api
    {
	# I find the original prettyprinter interface ugly and clumsy;
	# this is an attempt to provide something simpler and cleaner.
	#
	# The idea is to do
	#
	#     pp.align_box .{
	#         pp.out "Various\rstuff\rof consequence.\n";
	#     };
	#
	# or
	#
	#     pp.align_box .{
	#         pp.put "Various stuff of consequence.\n";
	#     };
	#
	# instead of
	#
	#     pp::begin_align_box buf;
	#     pp::string        buf "Various";
	#     pp::break         buf { spaces=>1; indent_on_wrap=>4 };
	#     pp::string        buf "stuff";
	#     pp::break         buf { spaces=>1; indent_on_wrap=>4 };
	#     pp::string        buf "of consequence.";
	#     pp::newline       buf;
	#     pp::end_box       buf;
	#
	# approximately.  In particular, I see the former as:
	#  o  Inherently keeping block open/close pairs matched.
	#     (The original code had at least one such bug.)
	#  o  Reducing clutter by making the 'buf' arguments implicit.
	#  o  Reducing clutter by allowing newlines to be included in strings
	#     instead of having to be separate calls.
	# Currently unused, probably needs tuning.
	#
	#    
	# TO DO:                                   XXX BUGGO FIXME
	#    Drop wrap'_box and wrap'_box'
	#    Change align_box and align_box' to align  and align'
	#    Change wrap_box and wrap_box' to wrap   and wrap' 
	#    Maybe change '\r' to '\ ' (or to \{  } so we can specify the
	#       number of blanks in a break naturally)? Or maybe out/put distinction handles this ok?

	Prettyprinter
	  =
	  { pp:      pp::Prettyprinter,
	    #
	    align:   (Void -> Void) -> Void,
	    wrap:    (Void -> Void) -> Void,

	    align':  Int -> (Void -> Void) -> Void,
	    wrap':   Int -> (Void -> Void) -> Void,

	    flush:      Void -> Void,
	    close:      Void -> Void,

	    lit:        String -> Void,
	    out:        String -> Void,
	    put:        String -> Void
	  };  
	Pp = Prettyprinter;




	fun make_prettyprinter  prettyprinter_output_stream
	    =
	    {   pp =   pp::make_prettyprinter  prettyprinter_output_stream;

		fun align     thunk =   { pp::begin_align_box   pp;    thunk();   pp::end_box pp;   };
		fun wrap      thunk =   { pp::begin_wrap_box    pp;    thunk();   pp::end_box pp;   };

		fun align'    i thunk =   { pp::begin_indented_align_box    pp (pp::BOX_RELATIVE i);   thunk();   pp::end_box pp; };
		fun wrap'     i thunk =   { pp::begin_indented_wrap_box    pp (pp::BOX_RELATIVE i);   thunk();   pp::end_box pp; };

		fun flush ()           =   { pp::flush_prettyprinter  pp;    prettyprinter_output_stream.flush (); };
		fun close ()           =   { pp::close_prettyprinter  pp;    prettyprinter_output_stream.close (); };



		##############################################################################
		#                       lit / out / put
		#
		# The idea with out/put is to replace
		# explicit calls to pp::break and pp::newline
		# with embedded ' '  '\r'  '\n'  chars:
		#
		#   lit:   Entire string output literally with no special character treatments.
		#   out:   '\n'                 treated as pp::newline
		#          '\r'                 treated as pp::break { spaces => 3, indent_on_wrap => 0 }
		#          N blanks             treated as pp::break { spaces => n, indent_on_wrap => 0 }
		#   put:   Same, except indent_on_wrap for blanks is 4.
		# 
		# The expectation is that:
		#   out:   Will typically be used to format short statements in a line box.
		#   put:   Will typically be used to wrap individual words in a wrap box.
		# In the former case, one usually wants wrapped lines to be aligned,  hence the 'indent_on_wrap => 0'
		# In the latter case, one usually wants wrapped lines to be indented, hence the 'indent_on_wrap => 4'
		# 
		# (I don't expect \r to appear in 'put' strings, in general,
		# but there seems no reason not to support it.)
		##############################################################################


		fun lit string
		    = 
		    pp::string pp string;

		fun output indent string
		    = 
		    next 0
		    where
			len =   size string;

			fun next i
			    =
			    if (i < len)
				#
				c =  string::get (string, i);

				case c
				    '\n' =>  do_newline i;
				    '\r' =>  do_cr      i;
				    ' '  =>  do_spaces (i, i+1);
				     _   =>  do_other  (i, i+1);
				esac;
			    fi

			also
			fun do_newline  i						# Treat each \n in 'string' as a call to pp:newline.
			    =
			    {    pp::newline pp;
				 next (i+1);
			    }

			also
			fun do_cr  i							# Treat each \r in 'string' as a call to pp:break { spaces => 3, indent_on_wrap => 0 }.
			    =
			    {    pp::break  pp  { spaces => 1,  indent_on_wrap => 0 };
				 next (i+1);
			    }

			also
			fun do_spaces  (i, j)						# Treat a run of 'n' blanks in 'string' as a call to pp:break { spaces => n, indent_on_wrap => 4 }.
			    =
			    {
				if (j >= len)
				    #
				    pp::break  pp  { spaces => j-i,  indent_on_wrap => indent };
				else
				    c =  string::get (string, j);

				    if (c == ' ')
					#
					do_spaces (i, j+1);				# Scan to end of string of blanks.
				    else
					pp::break  pp  { spaces => j-i,  indent_on_wrap => 4 };
					next j;
				    fi;
				fi;
			    }

			also 								# Treat literally a run of non-\n, non-\r, non-blank chars in 'string'.
			fun do_other (i, j)
			    =
			    if (j >= len)
				#
				pp::string pp (string::substring (string, i, j-i));
			    else
				c =  string::get (string, j);

				if  (c != ' '
				and  c != '\r'
				and  c != '\n'
				)
				     do_other (i, j+1);					# Scan to end of string of vanilla characters.
				else
				     substring =  string::substring (string, i, j-i);
				     pp::string pp substring;
				     next j;
				fi;
			    fi;
		    end;								# fun output

		fun out string =   output 0 string;
		fun put string =   output 4 string;


		{ pp,

		  align,
		  wrap,

		  align',
		  wrap',

		  flush,
		  close,

		  lit,
		  out,
		  put
		};  
	    };

	fun make_cynbe_prettyprinter  prettyprint_filename
	    =
	    {   text_stream =  fil::open_for_write  prettyprint_filename; 
		#
		prettyprinter_output_stream
		    =
		    {   consumer  =>  (fn string =  fil::write  (text_stream,  string)),
			linewidth =>  2000,							# Arbitrary large number.
			flush     =>  .{ fil::flush        text_stream; },
			close     =>  .{ fil::close_output text_stream; }
		    };

		make_prettyprinter  prettyprinter_output_stream;
	    };


	##################################################################################################
	# Backward compatibility stuff to make standard_prettyprinter a 100% drop-in replacement for core_prettyprinter:

	Prettyprinter_Output_Stream	=  pp::Prettyprinter_Output_Stream;
	Styled_String			=  pp::Styled_String;
	Textstyle			=  pp::Textstyle;
	Indent				== pp::Indent;

	fun flush_prettyprinter		(pp:Pp)		=  pp::flush_prettyprinter		pp.pp;
	fun close_prettyprinter		(pp:Pp)		=  pp::close_prettyprinter		pp.pp;
	fun begin_horizontal_box	(pp:Pp)		=  pp::begin_horizontal_box		pp.pp;

	fun begin_vertical_box		(pp:Pp)		=  pp::begin_vertical_box		pp.pp;
	fun begin_align_box		(pp:Pp)		=  pp::begin_align_box			pp.pp;
	fun begin_wrap_box		(pp:Pp)		=  pp::begin_wrap_box			pp.pp;
	fun begin_wrap'_box		(pp:Pp)		=  pp::begin_wrap'_box			pp.pp;

	fun begin_indented_vertical_box	(pp:Pp) i	=  pp::begin_indented_vertical_box	pp.pp i;
	fun begin_indented_align_box	(pp:Pp) i	=  pp::begin_indented_align_box		pp.pp i;
	fun begin_indented_wrap_box	(pp:Pp) i	=  pp::begin_indented_wrap_box		pp.pp i;
	fun begin_indented_wrap'_box	(pp:Pp) i	=  pp::begin_indented_wrap'_box		pp.pp i;

	fun horizontal_box		(pp:Pp) f	=  pp::horizontal_box			pp.pp f;
	fun vertical_box		(pp:Pp) f	=  pp::vertical_box			pp.pp f;
	fun align_box			(pp:Pp) f	=  pp::align_box			pp.pp f;
	fun wrap_box			(pp:Pp) f	=  pp::wrap_box				pp.pp f;
	fun wrap'_box			(pp:Pp) f	=  pp::wrap'_box			pp.pp f;

	fun end_box			(pp:Pp)		=  pp::end_box				pp.pp;

	fun styled_string		(pp:Pp) s	=  pp::styled_string			pp.pp s; 
	fun string			(pp:Pp) s	=  pp::string				pp.pp s; 

	fun push_textstyle	       (pp:Pp,ts)	=  pp::push_textstyle		       (pp.pp,ts);		
	fun pop_textstyle	       (pp:Pp)		=  pp::pop_textstyle		        pp.pp;

	fun break			(pp:Pp) a	=  pp::break				pp.pp a;
	fun space			(pp:Pp) i	=  pp::space				pp.pp i;
	fun cut				(pp:Pp)		=  pp::cut				pp.pp;
	fun newline			(pp:Pp)		=  pp::newline				pp.pp;
	fun nonbreakable_spaces		(pp:Pp) i	=  pp::nonbreakable_spaces		pp.pp i;
	fun control			(pp:Pp) f	=  pp::control				pp.pp f;

	fun get_output_stream		(pp:Pp)		=  pp::get_output_stream		pp.pp;

	fun with_standard_prettyprinter  output_stream  (f: Prettyprinter -> Void)	# Compared to the make_standard_prettyprinter() approach, this
	    =										# approach makes it harder to forget to flush+close the prettyprinter.
	    {   pp =   make_prettyprinter  output_stream;
		#
		f pp;

		close_prettyprinter  pp;
	    };

	fun prettyprint_to_string   linewidth   prettyprint_fn   chunk
	    =
	    {   l =   REF ([] : List( String ));
		#
		fun attach s =    l :=  s ! *l;

		output_stream
		    =
		    { consumer => attach,
		      linewidth,
		      flush =>  fn()=(),
		      close =>  fn()=()
		    };

		with_standard_prettyprinter
		    output_stream
		    (fn pp =  prettyprint_fn  pp  chunk);

		string::cat (list::reverse *l);
	    };

	# End of backward compatibility stuff.
	##################################################################################################

    };											# package standard_prettyprinter
end;



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Code by Jeff Prothero: Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
