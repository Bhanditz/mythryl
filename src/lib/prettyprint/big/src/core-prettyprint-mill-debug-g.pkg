## core-prettyprint-mill-debug-g.pkg
#

# Compiled by:
#     src/lib/prettyprint/big/prettyprint-mill.lib

stipulate
    package fil =  file__premicrothread;					# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package l2s =  list_to_string;						# list_to_string		is from   src/lib/src/list-to-string.pkg
    package ptf = sfprintf;							# sfprintf			is from   src/lib/src/sfprintf.pkg
herein

    # This generic is invoked (only) from
    #
    #     src/lib/prettyprint/big/src/core-prettyprint-mill-g.pkg
    #
    generic package   core_prettyprint_mill_debug_g   (				# 
	#             =============================
	#									# "tt" == "traitful text"
	package typ:	Core_Prettyprint_Mill_Types;				# Core_Prettyprint_Mill_Types	is from   src/lib/prettyprint/big/src/core-prettyprint-mill-types.api
										# core_prettyprint_mill_types_g	is form   src/lib/prettyprint/big/src/core-prettyprint-mill-types-g.pkg
    )
    : (weak)
api {
#	break_policy_to_string:		typ::Break_Policy -> String;
	left_margin_is_to_string:	typ::Left_Margin_Is -> String;
	phase1_token_to_string:		typ::Phase1_Token -> String;
	phase1_tokens_to_string:	List(typ::Phase1_Token) -> String;

	prettyprint_prettyprint_mill: (fil::Output_Stream, typ::Prettyprint_Mill) -> Void;
    }

#    Core_Prettyprint_Mill_Debug
#		    where Break_Policy        == typ::Break_Policy
#		    also  Left_Margin       == typ::Left_Margin_Is
#		    also  Phase1_Token == typ::Phase1_Token
#		    also  Prettyprint_Mill  == typ::Prettyprint_Mill
    {
	Pp = typ::Prettyprint_Mill;


	# *** DEBUGGING FUNCTIONS ***


#	fun break_policy_to_string typ::NONE        =>  "NONE";
#	    break_policy_to_string typ::ALL         =>  "ALL";
#	    break_policy_to_string typ::ALL_OR_NONE =>  "ALL_OR_NONE";
#	    break_policy_to_string typ::AS_NEEDED   =>  "AS_NEEDED";
#	end;


	fun left_margin_is_to_string (typ::BOX_RELATIVE    { spaces, tab_to, tabstops_are_every }) =>  sprintf    "(BOX_RELATIVE { spaces=>%d, tab_to=>%d, tabstops_are_every=>%d })" spaces tab_to tabstops_are_every;
	    left_margin_is_to_string (typ::CURSOR_RELATIVE { spaces, tab_to, tabstops_are_every }) =>  sprintf "(CURSOR_RELATIVE { spaces=>%d, tab_to=>%d, tabstops_are_every=>%d })" spaces tab_to tabstops_are_every;
	end;


	fun phase1_token_to_string token
	    =
	    case token
		typ::SPACES i		=>	sprintf "SPACES \"%d\"" i;
		typ::LIT    s		=>	sprintf "LIT \"%s\""    s;
		typ::ENDLIT s		=>	sprintf "ENDLIT \"%s\"" s;
		typ::TAB    t		=>	sprintf "TAB { tab_to => %d, tabstops_are_every %d }" t.tab_to t.tabstops_are_every;
		typ::PUSH_TEXTTRAITS _	=>	"PUSH_TEXTTRAITS";
		typ::POP_TEXTTRAITS	=>	"POP_TEXTTRAITS";
		typ::CONTROL _		=>	"CONTROL";
		typ::NEWLINE		=>	"NEWLINE";
		typ::BREAK b		=>	sprintf "BREAK { ifnotwrap => { spaces=>%d, tab_to=>%d, tabstops_are_every=>%d }, ifwrap => { tab_to=>%d, tabstops_are_every=>%d }, wrap=>%B }"
                                                        b.ifnotwrap.spaces b.ifnotwrap.tab_to b.ifnotwrap.tabstops_are_every b.ifwrap.tab_to b.ifwrap.tabstops_are_every *b.wrap;
		typ::BOX box 		=>      sprintf "BOX#%d{%d%s}" box.id *box.actual_width (*box.is_multiline ?? "M" :: "");
	    esac;

	fun phase1_tokens_to_string tokens
	    =
	    string::join'   "[ "   ", "   " ]"   (map  phase1_token_to_string  tokens);


	fun prettyprint_prettyprint_mill   (out_stream, pp:  typ::Prettyprint_Mill)		# Prettyprint pp contents for debugging.
	    =
	    {   print  "BEGIN\n";
		#
		printf' (
		    "box_nesting = %3d\n",
		    [   ptf::INT *pp.box_nesting
		    ]
		);

		print   "Expression:\n";

		case *pp.nested_boxes
		    #
		    [] => print_box *pp.box "";
		    x  => case (reverse x)
			      #
			      bot ! rest => print_box bot "";
			      _          => raise exception FAIL "impossible";
			  esac;
		esac;

		print "\n";

		print  "END\n";
	    }
	    where
		fun print string
		    =
		    fil::write (out_stream, string);


		fun printf' (format, items)
		    =
		    print (ptf::sprintf' format items);


    #	    fun format_box_stack_element_to_string (format, box_indent, target_width)
    #		=
    #		ptf::sprintf'   "(%s, %d, %d)"   [ptf::STR (break_policy_to_string  format), ptf::INT box_indent, ptf::INT target_width];


		fun print_list format_element []
			=>
			print "[]";

		    print_list format_element my_list
			=>
			print (
			    l2s::list_to_string'
				#
				{ first     => "[\n    ",
				  last      => "]",
				  between   => "\n    ",
				  to_string => format_element
				}
				#
				my_list
			);
		end;

		fun print_box   (box: typ::Box)   prefix
		    =
		    {   print (prefix + "Box");
			print ("   id = "			+ (int::to_string           box.id));
			print ("   left_margin_is = "		+ (left_margin_is_to_string box.left_margin_is));
			print ("   target_width = "		+ (int::to_string           box.target_width));
			print ("   actual_width = "		+ (int::to_string          *box.actual_width));
			print ("   is_multiline = "		+ (bool::to_string         *box.is_multiline));
			print ("   format = "			+  box.format.name);
			#
			print ("   reversed_contents len = "	+ (int::to_string (list::length *box.reversed_contents)));
			print ("   contents len = "		+ (int::to_string (list::length *box.contents)));
			print  ":\n";

			print_tokens  *box.contents  (prefix + "    ")
			where
			    fun print_tokens [] _
				    =>
				    ();

				print_tokens  (token ! rest)  prefix
				    =>
				    {   case token
					    #
					    typ::SPACES n
						=>
						print (prefix + "SPACES " + (int::to_string n) + "\n");

					    typ::LIT string
						=>
						print (prefix + "LIT '" + string + "'\n");

					    typ::ENDLIT string
						=>
						print (prefix + "ENDLIT '" + string + "'\n");

					    typ::TAB  t
						=>
						printf "%sTAB { tab_to=>%d, tabstops_are_every=>%d }\n"  prefix t.tab_to  t.tabstops_are_every;

					    typ::BREAK b
						=>
						{   print  (prefix + "BREAK {");
						    print  (" wrap="  + (bool::to_string *b.wrap));
						    printf  " ifnotwrap => { spaces => %d, tab_to => %d, tabstops_are_every => %d },"  b.ifnotwrap.spaces  b.ifnotwrap.tab_to  b.ifnotwrap.tabstops_are_every;
						    printf  " ifwrap    => { tab_to => %d, tabstops_are_every => %d }"                                     b.ifwrap.tab_to     b.ifwrap.tabstops_are_every;
						    print  " }\n";
						};

					    typ::PUSH_TEXTTRAITS _ => print (prefix + "PUSH_TEXTTRAITS ...\n");
					    typ::POP_TEXTTRAITS    => print (prefix + "POP_TEXTTRAITS\n");

					    typ::NEWLINE      => print (prefix + "NEWLINE\n");
					    typ::CONTROL _    => print (prefix + "CONTROL ...\n");

					    typ::BOX box      => {   print (prefix + "BOX:\n");
								print_box  box  (prefix + "    "); 
							    };
					esac;

					print_tokens  rest  prefix;
				    };
			    end;				# fun print_tokens
			end;					# where
		    };

	    end;
    };
end;

## COPYRIGHT (c) 2005 John Reppy (http://www.cs.uchicago.edu/~jhr)
## All rights reserved.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
