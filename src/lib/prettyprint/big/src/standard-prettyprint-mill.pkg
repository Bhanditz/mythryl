## standard-prettyprint-mill.pkg
#
# Apparently this is actually in use in:
#     src/lib/compiler/back/low/mcg/print-machcode-controlflow-graph-g.pkg
#     src/lib/compiler/front/typer/types/resolve-overloaded-variables.pkg

# Compiled by:
#     src/lib/prettyprint/big/prettyprint-mill.lib


stipulate
    package fil =  file__premicrothread;				# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
    package pp  =  core_prettyprint_mill;				# core_prettyprint_mill		is from   src/lib/prettyprint/big/src/core-prettyprint-mill.pkg
herein

    package   standard_prettyprint_mill
    : (weak)  Standard_Prettyprint_Mill					# Standard_Prettyprint_Mill			is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.api
    {
	Prettyprinter_Args	== pp::Prettyprinter_Args;	

	Prettyprint_Mill
	  =
	  { pp:      pp::Prettyprint_Mill,
	    #
	    box:		Int -> (Void -> Void) -> Void,
	    wrap:		Int -> (Void -> Void) -> Void,
	    horizontal:		Int -> (Void -> Void) -> Void,
	    vertical:		Int -> (Void -> Void) -> Void,

	    cbox:		(Void -> Void) -> Void,
	    cwrap:		(Void -> Void) -> Void,
	    chorizontal:	(Void -> Void) -> Void,
	    cvertical:		(Void -> Void) -> Void,

	    flush:		Void -> Void,
	    close:		Void -> Void,

	    cut:		Int    -> Void,
	    tab:		Int    -> Void,

	    lit:		String -> Void,
	    txt:	Int ->	String -> Void,
	    endtxt:	Int ->  String -> Void
	  };  
	Pp = Prettyprint_Mill;




	fun make_prettyprinter  prettyprinter_output_stream   args
	    =
	    {   pp =   pp::make_prettyprinter  prettyprinter_output_stream  args;

		fun box        i thunk =   { pp::begin_indented_align_box      pp (pp::BOX_RELATIVE i);   thunk();   pp::end_box pp; };
		fun wrap       i thunk =   { pp::begin_indented_wrap_box       pp (pp::BOX_RELATIVE i);   thunk();   pp::end_box pp; };
		fun horizontal i thunk =   { pp::begin_indented_horizontal_box pp (pp::BOX_RELATIVE i);   thunk();   pp::end_box pp; };
		fun vertical   i thunk =   { pp::begin_indented_vertical_box   pp (pp::BOX_RELATIVE i);   thunk();   pp::end_box pp; };

		fun cbox         thunk =   { pp::begin_align_cbox              pp;    thunk();   pp::end_box pp;   };
		fun cwrap        thunk =   { pp::begin_wrap_cbox               pp;    thunk();   pp::end_box pp;   };
		fun chorizontal  thunk =   { pp::begin_horizontal_cbox         pp;    thunk();   pp::end_box pp;   };
		fun cvertical    thunk =   { pp::begin_vertical_cbox           pp;    thunk();   pp::end_box pp;   };

		fun flush ()           =   { pp::flush_prettyprinter  pp;    prettyprinter_output_stream.flush (); };
		fun close ()           =   { pp::close_prettyprinter  pp;    prettyprinter_output_stream.close (); };

		fun cut   i            =   { pp::break  pp  { spaces => 0,  indent_on_wrap => i };		   };
		fun tab   i            =   { pp::tab  pp i;							   };



		##############################################################################
		#                       lit / put / pu4
		#
		# The idea with put/pu4 is to replace
		# explicit calls to pp::break, pp::tab and pp::newline
		# with embedded ' '  '\t'  '\n'  chars:
		#
		#   lit:   Entire string output literally with no special character treatments.
		#   txt0:  '\t'                 treated as pp::tab 4
		#	   '\n'                 treated as pp::newline
		#          n blanks             treated as pp::break { spaces => n, indent_on_wrap => 0 }
		#   txt4:  Same, except indent_on_wrap for blanks is 4.
		# 
		# The expectation is that:
		#   txt0:  Will typically be used to format short statements in a line box.
		#   txt4:   Will typically be used to wrap individual words in a wrap box.
		# In the former case, one usually wants wrapped lines to be aligned,  hence the 'indent_on_wrap => 0'
		# In the latter case, one usually wants wrapped lines to be indented, hence the 'indent_on_wrap => 4'
		##############################################################################


		fun lit string
		    = 
		    pp::string pp string;

		fun txt' pp_string indent string
		    = 
		    next 0
		    where
			len =   size string;

			fun next i
			    =
			    if (i < len)
				#
				c =  string::get (string, i);

				case c
				    '\t' =>  do_tab     i;
				    '\n' =>  do_newline i;
				    '\r' =>  do_cr      i;
				    ' '  =>  do_spaces (i, i+1);
				     _   =>  do_other  (i, i+1);
				esac;
			    fi

			also
			fun do_tab  i							# Treat each \t in 'string' as a call to pp:tab 4.
			    =
			    {    pp::tab pp 4;
				 next (i+1);
			    }

			also
			fun do_newline  i						# Treat each \n in 'string' as a call to pp:newline.
			    =
			    {    pp::newline pp;
				 next (i+1);
			    }

			also
			fun do_cr  i							# Treat each \r in 'string' as a call to pp:break { spaces => 3, indent_on_wrap => 0 }.
			    =
			    {    pp::break  pp  { spaces => 1,  indent_on_wrap => 0 };
				 next (i+1);
			    }

			also
			fun do_spaces  (i, j)						# Treat a run of 'n' blanks in 'string' as a call to pp:break { spaces => n, indent_on_wrap => 4 }.
			    =
			    {
				if (j >= len)
				    #
				    pp::break  pp  { spaces => j-i,  indent_on_wrap => indent };
				else
				    c =  string::get (string, j);

				    if (c == ' ')
					#
					do_spaces (i, j+1);				# Scan to end of string of blanks.
				    else
					pp::break  pp  { spaces => j-i,  indent_on_wrap => 4 };
					next j;
				    fi;
				fi;
			    }

			also 								# Treat literally a run of non-\n, non-\r, non-blank chars in 'string'.
			fun do_other (i, j)
			    =
			    if (j >= len)
				#
				pp_string pp (string::substring (string, i, j-i));
			    else
				c =  string::get (string, j);

				if  (c != ' '
				and  c != '\r'
				and  c != '\n'
				)
				     do_other (i, j+1);					# Scan to end of string of vanilla characters.
				else
				     substring =  string::substring (string, i, j-i);
				     pp_string pp substring;
				     next j;
				fi;
			    fi;
		    end;								# fun output

		txt    = txt' pp::string;
		endtxt = txt' pp::endtxt;


		{ pp,
		   box,   wrap, horizontal,  vertical,
		  cbox, cwrap, chorizontal, cvertical,
		  flush, close,
		  cut, tab,
		  lit, txt, endtxt
		};  
	    };

	fun make_standard_prettyprinter  prettyprint_filename  pp_args
	    =
	    {   text_stream =  fil::open_for_write  prettyprint_filename; 
		#
		consumer    =   (fn string =  fil::write  (text_stream,  string));

		flush       =   .{ fil::flush        text_stream; };

		close	    =   case  prettyprint_filename
				    #
				    "/dev/stdout"	=>  (fn () = ());				# Trying to close stdout is probably not a good idea.
				    "/dev/stderr"	=>  (fn () = ());				# Trying to close stderr is probably not a good idea either.
				    _			=>  .{ fil::close_output text_stream; };
				esac;

		make_prettyprinter   { consumer, flush, close }   pp_args;
	    };


	##################################################################################################
	# Backward compatibility stuff to make standard_prettyprint_mill a 100% drop-in replacement for core_prettyprint_mill:

	Prettyprint_Output_Stream	=  pp::Prettyprint_Output_Stream;
	Traitful_Text			=  pp::Traitful_Text;
	Texttraits			=  pp::Texttraits;
	Left_Margin_Is			== pp::Left_Margin_Is;

	fun flush_prettyprinter			(pp:Pp)		=  pp::flush_prettyprinter		pp.pp;
	fun close_prettyprinter			(pp:Pp)		=  pp::close_prettyprinter		pp.pp;

	fun begin_horizontal_4box		(pp:Pp)		=  pp::begin_horizontal_4box		pp.pp;
	fun begin_vertical_4box			(pp:Pp)		=  pp::begin_vertical_4box		pp.pp;
	fun begin_align_4box			(pp:Pp)		=  pp::begin_align_4box			pp.pp;
	fun begin_wrap_4box			(pp:Pp)		=  pp::begin_wrap_4box			pp.pp;

	fun begin_horizontal_0box		(pp:Pp)		=  pp::begin_horizontal_0box		pp.pp;
	fun begin_vertical_0box			(pp:Pp)		=  pp::begin_vertical_0box		pp.pp;
	fun begin_align_0box			(pp:Pp)		=  pp::begin_align_0box			pp.pp;
	fun begin_wrap_0box			(pp:Pp)		=  pp::begin_wrap_0box			pp.pp;

	fun begin_horizontal_cbox		(pp:Pp)		=  pp::begin_horizontal_cbox		pp.pp;
	fun begin_vertical_cbox			(pp:Pp)		=  pp::begin_vertical_cbox		pp.pp;
	fun begin_align_cbox			(pp:Pp)		=  pp::begin_align_cbox			pp.pp;
	fun begin_wrap_cbox			(pp:Pp)		=  pp::begin_wrap_cbox			pp.pp;

	fun begin_indented_horizontal_box	(pp:Pp) i	=  pp::begin_indented_vertical_box	pp.pp i;
	fun begin_indented_vertical_box		(pp:Pp) i	=  pp::begin_indented_vertical_box	pp.pp i;
	fun begin_indented_align_box		(pp:Pp) i	=  pp::begin_indented_align_box		pp.pp i;
	fun begin_indented_wrap_box		(pp:Pp) i	=  pp::begin_indented_wrap_box		pp.pp i;

	fun horizontal_4box			(pp:Pp) f	=  pp::horizontal_4box			pp.pp f;
	fun vertical_4box			(pp:Pp) f	=  pp::vertical_4box			pp.pp f;
	fun align_4box				(pp:Pp) f	=  pp::align_4box			pp.pp f;
	fun wrap_4box				(pp:Pp) f	=  pp::wrap_4box			pp.pp f;

	fun horizontal_0box			(pp:Pp) f	=  pp::horizontal_0box			pp.pp f;
	fun vertical_0box			(pp:Pp) f	=  pp::vertical_0box			pp.pp f;
	fun align_0box				(pp:Pp) f	=  pp::align_0box			pp.pp f;
	fun wrap_0box				(pp:Pp) f	=  pp::wrap_0box			pp.pp f;

	fun horizontal_cbox			(pp:Pp) f	=  pp::horizontal_cbox			pp.pp f;
	fun vertical_cbox			(pp:Pp) f	=  pp::vertical_cbox			pp.pp f;
	fun align_cbox				(pp:Pp) f	=  pp::align_cbox			pp.pp f;
	fun wrap_cbox				(pp:Pp) f	=  pp::wrap_cbox			pp.pp f;

	fun end_box				(pp:Pp)		=  pp::end_box				pp.pp;

	fun styled_string			(pp:Pp) s	=  pp::styled_string			pp.pp s; 
	fun string				(pp:Pp) s	=  pp::string				pp.pp s; 
	fun endtxt				(pp:Pp) s	=  pp::endtxt				pp.pp s; 

	fun push_texttraits			(pp:Pp,ts)	=  pp::push_texttraits		       (pp.pp,ts);		
	fun pop_texttraits			(pp:Pp)		=  pp::pop_texttraits		        pp.pp;

	fun break				(pp:Pp) a	=  pp::break				pp.pp a;
	fun space				(pp:Pp) i	=  pp::space				pp.pp i;
	fun cut					(pp:Pp)		=  pp::cut				pp.pp;
	fun newline				(pp:Pp)		=  pp::newline				pp.pp;
	fun nonbreakable_spaces			(pp:Pp) i	=  pp::nonbreakable_spaces		pp.pp i;
	fun tab					(pp:Pp) i	=  pp::tab				pp.pp i;
	fun control				(pp:Pp) f	=  pp::control				pp.pp f;

	fun get_output_stream			(pp:Pp)		=  pp::get_output_stream		pp.pp;

	fun with_standard_prettyprinter  output_stream  pp_args  (f: Prettyprint_Mill -> Void)			# Compared to the make_standard_prettyprinter() approach, this
	    =													# approach makes it harder to forget to flush+close the prettyprinter.
	    {   pp =   make_prettyprinter  output_stream  pp_args;
		#
		f pp;

		close_prettyprinter  pp;
	    };

	fun prettyprint_to_string   pp_args   prettyprint_fn
	    =
	    {   l =   REF ([] : List( String ));
		#
		fun attach s =    l :=  s ! *l;

		output_stream
		    =
		    { consumer => attach,
		      flush =>  fn()=(),
		      close =>  fn()=()
		    };

		with_standard_prettyprinter
		    output_stream  pp_args
		    prettyprint_fn;

		string::cat (list::reverse *l);
	    };

	fun seq elements print_element separator
	    =
	    print_elements  elements
	    where
		fun print_elements [element]
			=>
			print_element element;

		    print_elements (element ! rest)
			=>
			{   print_element  element;
			    separator ();
			    print_elements rest;
			};

		    print_elements [] =>   ();
		end;
	    end;





	# End of backward compatibility stuff.
	##################################################################################################

    };											# package standard_prettyprint_mill
end;



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Code by Jeff Prothero: Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
