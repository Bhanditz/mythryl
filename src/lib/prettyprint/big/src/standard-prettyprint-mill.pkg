## standard-prettyprint-mill.pkg
#

# Compiled by:
#     src/lib/prettyprint/big/prettyprint-mill.lib


stipulate
    package fil =  file__premicrothread;					# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
    nb = log::note_on_stderr;							# log					is from   src/lib/std/src/log.pkg
herein

    package   standard_prettyprint_mill
    : (weak)  Standard_Prettyprint_Mill						# Standard_Prettyprint_Mill		is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.api
    {
	Prettyprint_Output_Stream
	    =
	    { consumer:   String -> Void,
	      flush:      Void -> Void,
	      close:      Void -> Void
	    };

	package out {
	    #
	    Prettyprint_Output_Stream = Prettyprint_Output_Stream;
	    Texttraits = Void;

	    fun same_texttraits _    = TRUE;
	    fun push_texttraits _    = ();
	    fun pop_texttraits _     = ();
	    fun default_texttraits _ = ();

	    fun put_string ( { consumer, flush, close }, s) =  consumer s;

	    fun flush        { consumer, flush, close }     =  flush();
	    fun close        { consumer, flush, close }     =  close();
	};

	package pp
	    =
	    standard_prettyprint_mill_g   (					# standard_prettyprint_mill_g		is from   src/lib/prettyprint/big/src/standard-prettyprint-mill-g.pkg
	    #									# "tt" == "traitful text"
		package tt  =  traitless_text;					# traitless_text			is from   src/lib/prettyprint/big/src/traitless-text.pkg
		package out =  out;
	    );

	include package   pp;

	# The following cannot go into standard_prettyprint_mill_g
	# because they depend on our particular definition of
	# Prettyprint_Output_Stream, which it is agnostic about:

	fun make_standard_prettyprint_mill_into_file  prettyprint_filename  pp_args
	    =
	    {   text_stream =  fil::open_for_write  prettyprint_filename; 
		#
		consumer    =   (\\ string =  fil::write  (text_stream,  string));

		flush       =   {. fil::flush        text_stream; };

		close	    =   case  prettyprint_filename
				    #
				    "/dev/stdout"	=>  (\\ () = ());				# Trying to close stdout is probably not a good idea.
				    "/dev/stderr"	=>  (\\ () = ());				# Trying to close stderr is probably not a good idea either.
				    _			=>  {. fil::close_output text_stream; };
				esac;

		make_standard_prettyprint_mill   { consumer, flush, close }   pp_args;
	    };

	fun make_standard_prettyprint_mill_into_buffer  pp_args
	    =
	    {   l =   REF ([] : List( String ));
		#
#		fun attach s =    l :=  s ! *l;
		fun attach s
		    =
		    {
nb {. sprintf "Noting s=<<<%s>>>,  list::length(*l) was %d    --make_standard_prettyprint_mill_into_buffer/attach in src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg" s (list::length *l); };
			l :=  s ! *l;
		    };

		output_stream
		    =
		    { consumer => attach,
		      flush =>  \\()=(),
		      close =>  \\()=()
		    };

		pp	    = make_standard_prettyprint_mill  output_stream   pp_args;

		fun get_buffer_contents_and_clear_buffer ()
		    =
		    {
nb {. sprintf "list::length(*l) was %d    --make_standard_prettyprint_mill_into_buffer/get_buffer_contents_and_clear_buffer  in  src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg" (list::length *l); };
nb {. sprintf "int::sum (list::map string::length_in_bytes *l) was %d    --make_standard_prettyprint_mill_into_buffer/get_buffer_contents_and_clear_buffer  in  src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg" (int::sum (list::map string::length_in_bytes *l)); };
			result = string::cat (list::reverse *l);
nb {. sprintf "string::length_in_bytes(result) = %d  --make_standard_prettyprint_mill_into_buffer/get_buffer_contents_and_clear_buffer  in  src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg" (string::length_in_bytes result); };
nb {. sprintf "searching for NUL chars  --make_standard_prettyprint_mill_into_buffer/get_buffer_contents_and_clear_buffer  in  src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg"; };
nb {. sprintf "string::length_in_bytes (sprintf \"%%s\" result) = %d  --make_standard_prettyprint_mill_into_buffer/get_buffer_contents_and_clear_buffer  in  src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg" (string::length_in_bytes (sprintf "%s" result)); };
printf "\nbleah:result s='%s'  --make_standard_prettyprint_mill_into_buffer/get_buffer_contents_and_clear_buffer\n" result;
foreach (0..(string::length_in_bytes(result) - 1))
   {. i=#i; printf "%d: %x/%c\n" i (string::get_byte(result, i)) (string::get_byte_as_char(result, i)); };
nb {. sprintf "result = $$$ %s $$$  --make_standard_prettyprint_mill_into_buffer/get_buffer_contents_and_clear_buffer  in  src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg" result; };
			l     := [];
			result;
		    };	

		{ pp, get_buffer_contents_and_clear_buffer };
	    };

	fun prettyprint_to_string   pp_args  prettyprint_fn
	    =
	    {   l =   REF ([] : List( String ));
		#
		fun attach s =    l :=  s ! *l;

		output_stream
		    =
		    { consumer => attach,
		      flush =>  \\()=(),
		      close =>  \\()=()
		    };

		with_standard_prettyprint_mill
		    output_stream  pp_args
		    prettyprint_fn;

		string::cat (list::reverse *l);
	    };


    };											# package standard_prettyprint_mill
end;



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Code by Jeff Prothero: Copyright (c) 2010-2015,
## released per terms of SMLNJ-COPYRIGHT.
