## prettyprint-mill-g.pkg
#
#############################################################################################
# Ok, this whole prettyprinter thing is coming into focus.
#
#     ##########################################################
#     It is all about boxes and squibs which do different things
#     depending on whether the box is monoline or multiline.
#     ##########################################################
#
# The generic box record should maybe include
#
#     .enter_box_stuff_when_monoline:   Prettyprint_Mill -> Void,		# Or maybe these should be Ref(List(Prettyprint_Mill -> Void)) to allow easy incremental updates?
#     .enter_box_stuff_when_multiline:  Prettyprint_Mill -> Void,
#
#     .exit_box_stuff_when_monoline:    Prettyprint_Mill -> Void,
#     .exit_box_stuff_when_multiline:   Prettyprint_Mill -> Void
#
# to allow arbitrary enter-box 
# and we should have a generic squib
#
#     pp.custom:   { monoline:  Void -> { tab:    Int, text: String },			# We don't provide 'column' because we want tabbing behavior abstract.
#                    multiline: Void -> { indent: Int, text: String }			# 
#		   }
#
# to do one   set of commands when the box is monoline
# and another set of commands when the box is multiline.
#
# On the specific command front, I think we need a
#
#     pp.pad n
#
# command which emits 'n' blanks when the box is MULTI-line
# and does nothing when it is monoline.
#
# We also want I think more prettyprinter defaults governing
# weird hacks like newline/indent collapsing, and a
#
#     pp.box' -> List( Default_Overrides ) -> ...
#
# which allows setting all the box behaviors explicitly on a
# box-by-box basis.
#
#     ##########################################################
#     Tabs are a global coherency issue;  they should be set once
#     globally in the prettyprinter and squibs should work in
#     terms of tabs.
#     For my standard layout:
#        tabstops should be every '2'
#        .tab 1    should move one tabstop.
#        .tab 2    should move to an even-number tabstop -- NOT JUST TWO TABS.
#
#        .indent i should be just like .tab except relative to left margin not cursor.
#                  It will ultimately do a newline iff column > target location.
#     .tab and .indent should both just set a virtual location,
#     NOT actually output newlines and blanks.
#     ##########################################################
#
#
#############################################################################################
#
#
# The core engine for the system prettyprinter.
#
# See ../README.
#
# Concise overview:
#
# -> The only purpose of the prettyprinter is to decide where
#    to put newlines, whitespace and indentation.
#
# -> The prettyprinter views its input stream as consisting
#    of known-width 'styled_strings' containing the useful text to be
#    printed, and of 'breaks', which mark places where it is
#    allowed to insert a newline.
#
# -> The desired structure is represented as a set of nested
#    'boxes', where a box essentially indicates the newline
#    insertion policy to be followed for some stretch of text.
#      Each box also has some default indentation for each line,
#    which will typically increase with box nesting level.
#
# -> The simplest box type is 'h' (horizontal)', in which
#    breaks are -never- converted to newlines.
#
# -> The next simplest box type is 'v' (vertical)', in which
#    breaks are -always- converted to newlines.
#
# -> The 'line' box type is slightly more sophisticated:  It
#    behaves as an 'h' box if the result will fit on a line,
#    else as a v box:  In simple cases, this results in the
#    styled_strings in the box all being placed in a line, either
#    horizontal or vertical.  In an line box, either all the
#    breaks produce newlines, or else none do.
#
# -> The 'wrap' box type is the most commonly used, and implements
#    the familiar word-wrap algorithm:  A break produces a newline
#    iff this is required to keep the line length within width limits.
#
## 2007-09-10 CrT: Completely rewritten.  Twice. ;-)
#
# Design goals:
#
# I)   For simplicity and consistency, layout of a box should depend
#      only on its contents, not on anything outside of it, such as
#      how far it is indented.
#
# II)  For readability, the inked part of a line (i.e., the part left
#      after stripping leading and trailing whitespace) should be about
#      10-100 chars long.  For example, we don't want to degenerate
#      to vertical columns of short words against the right margin.
#
# III) We are willing to have output extend arbitrarily far to the
#      right (everyone has scrollbars these days) if necessary,
#      but we want to minimize rightward drift due to indentation
#      where reasonably possible.
#
# Implementation decisions driven by above design goals:
#
# 1)   
#
# See also:
#     src/lib/prettyprint/big/src/prettyprint-stream-g.pkg

# Compiled by:
#     src/lib/prettyprint/big/prettyprint-mill.lib



# This generic does not currently appear to be invoked anywhere. <---



#               "The difference between the true hacker
#                and the mere power user is that the
#                limits of what a power user can achieve
#                are set by his tools, but the hacker is
#                master of his tools, and lives in a
#                world without limits.
#
#               "Every true hacker is necessarily a compiler
#                hacker at need, as well as an editor hacker,
#                kernel hacker, and so forth.
#
#               "True hackers are a rare breed.  For every
#                one of them, you will find a thousand
#                power users posing as hackers, more often
#                than not without even realizing the difference."
#
#					-- Willy Simons



stipulate
    package fil =  file__premicrothread;					# file__premicrothread	is from   src/lib/std/src/posix/file--premicrothread.pkg
    package l2s =  list_to_string;						# list_to_string							is from   src/lib/src/list-to-string.pkg
herein

    generic package   prettyprint_mill_g   (					# 
	#             ===============
	#									# "ss" == "styled string"
	package ss:	Traitful_Text;						# Traitful_Text								is from   src/lib/prettyprint/big/src/traitful-text.api
	package out:    Prettyprint_Output_Stream;				# Prettyprint_Output_Stream						is from   src/lib/prettyprint/big/src/out/prettyprint-output-stream.api
										# out will be something like html_prettyprint_output_stream		   from   src/lib/prettyprint/big/src/out/html-prettyprint-output-stream.pkg
	sharing ss::Texttraits == out::Texttraits;
    )
    : (weak)
    api {
	include Prettyprint_Mill;						# Prettyprint_Mill							is from   src/lib/prettyprint/big/src/prettyprint-mill.api

	dump:  (fil::Output_Stream, Prettyprint_Mill)
		  ->
		  Void;
    }
    {
	default_target_box_width =  100;					# This can be overridden via DEFAULT_TARGET_BOX_WIDTH.
	max_box_nesting          = 1000;					# Purely to catch prettyprint infinite recursions. 

	Prettyprint_Output_Stream  =  out::Prettyprint_Output_Stream;	# Handles device-specific aspects (e.g. selecting bold/bright/green/... text) of writing to ansi terminal, plain ascii stream, html stream or whatever.
	Texttraits      =  ss::Texttraits;					# Text attributes like color, underline, blink etc.
	Traitful_Text  =  ss::Traitful_Text;					# A Traitful_Text contains a String plus whatever Textstyle information is required to render it in HTML or on an ansi terminal or whatever.

	Left_Margin_Is								# How should we compute the left margin for a box?
	  = BOX_RELATIVE     Int						# Indent left margin relative to left margin of containing box.
	  | CURSOR_RELATIVE  Int						# Set left margin by tabbing from cursor, where tabstops are every 'Int' chars.
	  ;

	default_left_margin_is =  BOX_RELATIVE 4;	# I don't think this is actually ever used...

	Prettyprinter_Args							# Futureproofing -- args which code clients can pass to us to customize the prettyprinter.
	  #									# We can add more cases here in future as needed, without breaking backward compatibility.
	  =	DEFAULT_TARGET_BOX_WIDTH	Int
	  |	DEFAULT_LEFT_MARGIN_IS	Left_Margin_Is
	  ;

	Prettyprint_Token
	    #
	    = NONBREAKABLE_SPACES  Int						#  Some number of non-breakable spaces 
	    | PUSH_TEXTTRAITS  Texttraits
	    | POP_TEXTTRAITS
	    | NEWLINE
	    | CONTROL  (Prettyprint_Output_Stream -> Void)			# Device control operation. This provides an escape for ejecting a page or selecting a pen or any other unanticipated stuff.
	    | BOX Box
	    | TAB Int

	    | BREAK   { wrap:		Ref Bool,
			spaces:		Int,
			indent_on_wrap:	Int
		      }

	    | TEXT    { string: String,						#  Raw text.  This includes styled_strings.  The 
			length: Int						#  width and texttraits information is taken 
		      }								#  care of when they are inserted in queue. 

	    | ENDTXT  { string: String,						#  Basically a special hack so semicolons can appear
			length: Int						#  at the end of a preceding box instead of getting
		      }								#  a line of their own, which usually we don't want.

				
			


	also
	Wrap_Policy
	    #
	    = NONE								# All on one line -- break never rendered as newline.
	    | ALL								# One line each -- every break rendered as newline.
	    | ALL_OR_NONE							# NONE if it fits, else ALL.
	    | AS_NEEDED								# Normal wordwrap:  break rendered as newline only when necessary.

	withtype
	Box = { left_margin_is:		Left_Margin_Is,				# The left margin for the box is computed by adding an int to either the cursor or the previous left margin.
		target_width:		Int,					# We try to fit box contents into this width. We can break only where allowed (possibly nowhere), so we cannot guarantee success.
		actual_width:		Ref Int,				# Length of contents if newline free, else length of first line.
		wrap_policy:		Wrap_Policy,
		id:			Int,					# Unique id number per box.  Only used for debugging/display.
		#
		is_multiline:		Ref Bool,				# TRUE iff there's a NEWLINE somewhere inside.
		contents:		Ref List Prettyprint_Token,		# This is empty until box is closed, after that it == reverse (*reversed_contents).
		reversed_contents:	Ref List Prettyprint_Token		# We accumulate tokens in this while constructing box, by successively prepending them.
	      };



										# We build up a prettyprint expression as a tree
										# of nested_boxes until we are flushed, at which
										# point we actually format and print it.
										#
										# At any given time, the currently open box is 'box',
										# the one enclosing it is first in the nested_boxes
										# list, and the root of the box tree is last in the
										# nested_boxes list.  (Keeping the top of the stack
										# in a separate variable lets us communicate to the
										# type system that we always have at least one box
										# on the stack, and thus avoid a lot of spurious
										# checks for stack-empty.)
										#
										# We don't actually use the texttraits_stack
										# for anything in this module -- it is
										# purely an opaque-to-us customer
										# convenience:


	Prettyprint_Mill
	  =
	  {
	    output_stream:		Prettyprint_Output_Stream,		# Where to send formatted output.
	    output_stream_is_closed:	Ref( Bool ),				# TRUE iff the stream is closed. 

	    box:			Ref Box,
	    nested_boxes:		Ref (List(Box)),
	    box_nesting:		Ref Int,				# Current depth of 'nested_boxes'. Used only to catch infinite loops.

	    next_box_id:		Ref Int,

	    texttraits_stack:		Ref( List(Texttraits) ),

	    default_target_box_width:	Int,
	    default_left_margin_is:	Left_Margin_Is,
	    do_delayed_newline_indent:	Ref(Bool)				# Multiple nested boxes closing tends to produce lots of newline-indentblanks sequences in a row, which manifest as a
	};									# sequence of unexpected blank lines. Ugly! This var lets us collapse each such sequence into a single newline-indentblanks.
	Pp = Prettyprint_Mill;							# For when the brevity bug bites.



	exception  PRETTYPRINT_MAX_DEPTH_EXCEEDED;				# Raised when above is exceeded;



	# *** DEBUGGING FUNCTIONS ***

	package f = sfprintf;							# sfprintf	is from   src/lib/src/sfprintf.pkg

	fun wrap_policy_to_string NONE        =>  "NONE";
	    wrap_policy_to_string ALL         =>  "ALL";
	    wrap_policy_to_string ALL_OR_NONE =>  "ALL_OR_NONE";
	    wrap_policy_to_string AS_NEEDED   =>  "AS_NEEDED";
	end;


	fun left_margin_is_to_string (BOX_RELATIVE    n) =>  cat ["(BOX_RELATIVE ",    int::to_string n, ")"];
	    left_margin_is_to_string (CURSOR_RELATIVE n) =>  cat ["(CURSOR_RELATIVE ", int::to_string n, ")"];
	end;




	fun dump (out_stream, pp:Pp)						# Prettyprint out_stream contents for debugging.
	    =
	    {   print  "BEGIN\n";
		#
		printf' (
		    "box_nesting = %3d\n",
		    [   f::INT *pp.box_nesting
		    ]
		);

		print   "Expression:\n";

		case *pp.nested_boxes
		    #
		    [] => print_box *pp.box "";
		    x  => case (reverse x)
			      #
			      bot ! rest => print_box bot "";
			      _          => raise exception FAIL "impossible";
			  esac;
		esac;

		print "\n";

		print  ("END\n");
	    }
	    where
		fun print string
		    =
		    fil::write (out_stream, string);


		fun printf' (format, items)
		    =
		    print (f::sprintf' format items);


    #	    fun format_box_stack_element_to_string (wrap_policy, box_indent, target_width)
    #		=
    #		f::sprintf'   "(%s, %d, %d)"   [f::STR (wrap_policy_to_string  wrap_policy), f::INT box_indent, f::INT target_width];


		fun print_list format_element []
			=>
			print "[]";

		    print_list format_element my_list
			=>
			print (
			    l2s::list_to_string'
				#
				{ first     => "[\n    ",
				  last      => "]",
				  between   => "\n    ",
				  to_string => format_element
				}
				#
				my_list
			);
		end;

		fun print_box   (box: Box)   prefix
		    =
		    {   print (prefix + "Box");
			print ("   id = "			+ (int::to_string           box.id));
			print ("   left_margin_is = "		+ (left_margin_is_to_string box.left_margin_is));
			print ("   target_width = "		+ (int::to_string           box.target_width));
			print ("   actual_width = "		+ (int::to_string          *box.actual_width));
			print ("   is_multiline = "		+ (bool::to_string         *box.is_multiline));
			print ("   wrap_policy = "		+ (wrap_policy_to_string    box.wrap_policy));
			#
			print ("   reversed_contents len = "	+ (int::to_string (list::length *box.reversed_contents)));
			print ("   contents len = "		+ (int::to_string (list::length *box.contents)));
			print  ":\n";

			print_tokens  *box.contents  (prefix + "    ")
			where
			    fun print_tokens [] _
				    =>
				    ();

				print_tokens  (token ! rest)  prefix
				    =>
				    {   case token
					    #
					    TEXT { string, length }
						=>
						print (prefix + "TEXT (" + (int::to_string length) + ") '" + string + "'\n");

					    ENDTXT { string, length }
						=>
						print (prefix + "ENDTXT (" + (int::to_string length) + ") '" + string + "'\n");

					    NONBREAKABLE_SPACES  int
						=>
						print (prefix + "NONBREAKABLE_SPACES " + (int::to_string int) + "\n");

					    TAB  int
						=>
						print (prefix + "TAB" + (int::to_string int) + "\n");

					    BREAK break
						=>
						{   print (prefix + "BREAK");
						    print (" wrap="  + (bool::to_string *break.wrap));
						    print (" spaces="  + (int::to_string   break.spaces));
						    print (" indent_on_wrap="  + (int::to_string   break.indent_on_wrap));
						    print  "\n";
						};

					    PUSH_TEXTTRAITS _ => print (prefix + "PUSH_TEXTTRAITS ...\n");
					    POP_TEXTTRAITS    => print (prefix + "POP_TEXTTRAITS\n");

					    NEWLINE      => print (prefix + "NEWLINE\n");
					    CONTROL _    => print (prefix + "CONTROL ...\n");

					    BOX box      => {   print (prefix + "BOX:\n");
								print_box  box  (prefix + "    "); 
							    };
					esac;

					print_tokens  rest  prefix;
				    };
			    end;				# fun print_tokens
			end;					# where
		    };

	    end;



	# *** UTILITY FUNCTIONS ***

	too_long =  8888;   # A box-length value picked to be large
			    # enough to not fit in any plausible box,
			    # but small enough that adding a few
			    # together won't produce integer overflow.


	fun current_texttraits (pp:Pp as { texttraits_stack => REF (texttraits ! _),    ... } ) =>  texttraits;						# Current texttraits are the top entry on the textstyle stack,
	    current_texttraits (pp:Pp as { texttraits_stack => REF [], output_stream,  ... } ) =>  out::default_texttraits output_stream;		# or else the default texttraits if the stack is empty:
	end;

	fun tab1 (column, tabstop)			# We are at (zero-based) 'column' and tabstops are set
	    =						# every 'tabstop' chars. To move to the next tabstop, 
	    if (tabstop > 0)				# how many blanks (1 .. tabstop) do we need to emit?
		tabstop - (column % tabstop);
	    else
		msg = "Distance between tabstops must be > 0.";
		log::fatal msg;
		raise exception FAIL msg;
	    fi;

	fun tab0 (column, tabstop)			# We are at (zero-based) 'column' and tabstops are set
	    =						# every 'tabstop' chars. To leave cursor at a tabstop, 
	    {   blanks = tab1 (column, tabstop);	# how many blanks (0 .. tabstop-1) do we need to emit?
		#
		if (blanks==tabstop)   0;
		else		       blanks;
		fi;
	    };

fun token_to_string t
    =
    case t
	TEXT t			=>	sprintf "TEXT \"%s\"" t.string;
	ENDTXT t		=>	sprintf "ENDTXT \"%s\"" t.string;
	NONBREAKABLE_SPACES n	=>	sprintf "NONBREAKABLE_SPACES %d" n;
	TAB n			=>	sprintf "TAB %d" n;
	PUSH_TEXTTRAITS _	=>	"PUSH_TEXTTRAITS";
	POP_TEXTTRAITS		=>	"POP_TEXTTRAITS";
	CONTROL _		=>	"CONTROL";
	NEWLINE			=>	"NEWLINE";
	BREAK break		=>	sprintf "BREAK { spaces=>%d, indent_on_wrap=>%d wrap=>%B }" break.spaces break.indent_on_wrap *break.wrap;
	BOX box 		=>      sprintf "BOX#%d{%d%s}" box.id *box.actual_width (*box.is_multiline ?? "M" :: "");
    esac;

fun tokens_to_string ts
    =
    string::join'   "[ "   ", "   " ]"   (map token_to_string ts);


	fun count_breaks []               =>  0;
	    count_breaks (BREAK _ ! rest) =>  1  +  count_breaks rest;
	    count_breaks (      _ ! rest) =>  0  +  count_breaks rest;
	end;
	

	# Given the list of tokens in a BOX,
	# wrap either all BREAKs or none of them.
	#
	# Any embedded boxes have already been
	# wrap_box()'d, so they have valid values
	# for actual_width and is_multiline.
	#
	fun wrap_box_contents_all_or_none  (
		target_width,				# Target width for this box.
		tokens,					# List of tokens in this box.
		wrap_policy				# Which BREAKs should we wrap?  One of ALL, NONE, ALL_OR_NONE.
	    )
	    =
	    {
if *log::debugging
printf "target_width d=%d, %d tokens: %s    -- wrap_box_contents_all_or_none/TOP in prettyprint-mill-g.pkg\n" target_width (list::length tokens) (tokens_to_string tokens);
fi;
		box_is_multiline    =  REF FALSE;
		actual_width	    =  REF 0;
		column		    =  0;		# Current column, relative to box left margin
		#
		wrap_them				# Should we change all BREAKs to newlines, or none or them?
		    =
		    case wrap_policy
			#
			ALL  =>  TRUE;
			NONE =>  FALSE;

			ALL_OR_NONE
			    =>
			    {   unwrapped_length
				    =
				    total_length (tokens, 0)
				    where
					fun total_length ([], result) => result;
					    total_length (((TEXT                { length, ... }) ! rest), result) =>   total_length (rest, result +  length		);
					    total_length (((ENDTXT              { length, ... }) ! rest), result) =>   total_length (rest, result +  length		);
					    total_length (((TAB                   i            ) ! rest), result) =>   total_length (rest, result +  tab1(result,i)	);
					    total_length (((NONBREAKABLE_SPACES   n            ) ! rest), result) =>   total_length (rest, result +  n     		);
					    total_length (((BREAK               { spaces, ... }) ! rest), result) =>   total_length (rest, result +  spaces		);

					    total_length ([ BOX box ], result)
						=>
						case box.left_margin_is
						    #
						    CURSOR_RELATIVE _ =>   result + *box.actual_width;		# Multiline is potentially OK when it is last in line and a cbox.
						    BOX_RELATIVE    _ =>   too_long;
						esac;

					    total_length (((BOX box) ! rest), result)
						=>
						if *box.is_multiline too_long;
						else		     total_length (rest, result + *box.actual_width);
						fi;

					    total_length ((_ ! rest), result)
						=>
						total_length (rest, result);
					end;
				    end;

if *log::debugging
if (unwrapped_length  >  target_width)
printf "target_width d=%d, %d tokens: %s: WE WILL WRAP YOU!    -- wrap_box_contents_all_or_none/TOP in prettyprint-mill-g.pkg\n" target_width (list::length tokens) (tokens_to_string tokens);
fi;
fi;
				unwrapped_length  >  target_width;
			    };

			AS_NEEDED => raise exception FAIL "wrap_box_contents_all_or_none: wrap_policy == AS_NEEDED!?";
		    esac;


		fun per_token ([], column) =>   column;
		    #
		    per_token (tokens as token ! rest, column)
			=>
			case token
			    #
			    BREAK break
				=>
				if (column <= break.indent_on_wrap  and  count_breaks tokens == 1)
				    #
				    per_token  (rest, column + break.spaces);

				elif wrap_them
				    #
if *log::debugging
printf "WRAPPING at column %d indent-on-wrap d=%d -- wrap_box_contents_all_or_none in prettyprint-mill-g.pkg\n" column break.indent_on_wrap;
fi;
				    if (*actual_width < column)   actual_width := column;   fi;
				    break.wrap := TRUE;
				    box_is_multiline := TRUE;
				    per_token  (rest, break.indent_on_wrap);
				else
				    per_token  (rest, column + break.spaces);
				fi;

			    NEWLINE =>  {   if (*actual_width < column)   actual_width := column;   fi;
					    box_is_multiline := TRUE;
					    per_token  (rest, 0);
					};

			    TEXT   text		  =>   per_token  (rest, column + text.length   );
			    ENDTXT text		  =>   per_token  (rest, column + text.length   );
			    TAB                 n =>   per_token  (rest, column + tab1(column,n));
			    NONBREAKABLE_SPACES n =>   per_token  (rest, column + n             );
			    PUSH_TEXTTRAITS _      =>   per_token  (rest, column                 );
			    POP_TEXTTRAITS         =>   per_token  (rest, column                 );
			    CONTROL _             =>   per_token  (rest, column                 );

			    BOX box     =>  {   if(*actual_width <  column + *box.actual_width)
						    actual_width := column + *box.actual_width;
						fi;
						if *box.is_multiline
						    box_is_multiline :=  TRUE;
						    per_token( rest, 0 );
						else
						    per_token (rest, column + *box.actual_width);
						fi;
					    };
			esac;
		end;							# fun per_token

		column =   per_token (tokens, column);

		if (*actual_width < column)   actual_width := column;   fi;

		(*actual_width, *box_is_multiline);
	    }								# fun wrap_box_contents_all_or_none


	# Here we implement a conventional word-wrap
	# style algorithm where we wrap a line at
	# a BREAK iff it is our last chance to avoid
	# exceeding our assigned box width.

	also
	fun wrap_box_contents_as_needed  (target_width, tokens)
	    =
	    {	column =   per_token (tokens, /*column=*/0);
		#
		if (*actual_width < column)   actual_width := column;   fi;

		(*actual_width, *box_is_multiline);
	    }
	    where
if *log::debugging
printf "target_width d=%d, %d tokens    -- wrap_box_contents_as_needed in prettyprint-mill-g.pkg\n" target_width (list::length tokens);
fi;
		box_is_multiline = REF FALSE;
		actual_width	 = REF 0;

		fun forced_followon_fits_in' (tokens, space_left_on_line)				# Decide if tokens from here to next break/newline will fit in remaining space on line.
		    =
		    fits_in'  (tokens, 0)
		    where 
			fun fits_in' (tokens, column)							# Early-out check: Stop iterating as soon as we know we don't fit.
			    =
{
if *log::debugging
printf "forced_followon_fits_in (column=%d, %d tokens: %s\n" column (list::length tokens) (tokens_to_string tokens);
fi;
			    if (column > space_left_on_line)   FALSE;
			    else                               fits_in (tokens, column);
			    fi
;}
			also
			fun fits_in  ([], column) =>   (column <= space_left_on_line);
			    #
			    fits_in  ([ BOX { left_margin_is => CURSOR_RELATIVE _, is_multiline => REF TRUE, actual_width => REF width, ... } ],  column)
				=>
				(column + width) <= space_left_on_line;								# Multiline box is ok when CURSOR_RELATIVE and last in line.

			    fits_in  (token ! rest,  column)
				=>
				case token
				    TEXT   text			=>	fits_in'  (rest, column + text.length	);
				    ENDTXT text			=>	fits_in'  (rest, column + text.length	);
				    TAB n			=>	fits_in'  (rest, column + tab1(column,n));
				    NONBREAKABLE_SPACES n	=>	fits_in'  (rest, column + n		);
				    PUSH_TEXTTRAITS _		=>	fits_in'  (rest, column			);
				    POP_TEXTTRAITS		=>	fits_in'  (rest, column			);
				    CONTROL _			=>	fits_in'  (rest, column			);
				   (NEWLINE | BREAK _ )		=>	column <= space_left_on_line;

				    BOX box =>  if *box.is_multiline	FALSE;							# Multiline boxes by definition don't fit on one line. :-)
						else			fits_in'  (rest,  column + *box.actual_width);		# Monoline box, so first line == whole box.
						fi;
				esac;
			end;			# fun fits_in
		end;				# fun forced_followon_fits_in
fun forced_followon_fits_in (tokens, space_left_on_line)
=
{
if *log::debugging
    printf "\nforced_followon_fits_in (space_left_on_line %d, %d tokens: %s)/TOP\n" space_left_on_line  (list::length tokens) (tokens_to_string tokens);
fi;
    result = forced_followon_fits_in' (tokens, space_left_on_line);
if *log::debugging
    printf "forced_followon_fits_in (space_left_on_line %d, %d tokens: %s) returning %B\n\n"  space_left_on_line (list::length tokens) (tokens_to_string tokens) result;
fi;
    result;
};


		fun per_token  ([], column) =>   column;									# Scan the tokens in a LINE setting BREAKs to wrap as appropriate.
		    #
		    per_token  (token ! rest,   column)
			=>
{
if *log::debugging
printf "per_token/TOP column d=%d   %d tokens = %s)   -- wrap_box_contents_as_needed() in prettyprint-mill-g.pkg\n" column (list::length (token ! rest)) (tokens_to_string (token ! rest));
fi;
			case token
			    PUSH_TEXTTRAITS _	  =>   per_token (rest,   column			);
			    POP_TEXTTRAITS	  =>   per_token (rest,   column			);
			    CONTROL _		  =>   per_token (rest,   column			);
			    TEXT   text           =>   per_token (rest,   column + text.length		);
			    ENDTXT text           =>   per_token (rest,   column + text.length		);
			    NONBREAKABLE_SPACES n =>   per_token (rest,   column + n			);
			    TAB n		  =>   per_token (rest,   column + tab1(column,n)	);			# This isn't quite right because 'column' is box-relative but tabstops should be absolute.
																# We format boxes innermost first, so at present there's no way to know our absolute column at this point.
																# We mostly keep boxes tab-aligned, which should hide this problem most of the time.
																# Should we be pessimistic and do 	per_token (rest,   column + n	);    ?
			    NEWLINE     =>  {   if (*actual_width < column)   actual_width := column;   fi;
						box_is_multiline :=  TRUE;
						per_token( rest, /*column=*/ 0 );
					    };

			    BREAK break =>  {   space_left_on_line =  target_width - (column  +  break.spaces);
						#													
						if (column <= break.indent_on_wrap)
						    #
						    per_token (rest,   column + break.spaces);					# Wrapping won't move us left anyhow, so no point in considering it.

						elif (forced_followon_fits_in (rest, space_left_on_line))			# Is next BREAK or NEWLINE beyond right margin of box?
						    #
						    per_token (rest,   column + break.spaces);					# No, treat BREAK as spaces.
						else
if *log::debugging
printf "WRAPPING at column %d indent-on-wrap d=%d   target_width %d break.spaces %d space_left_on_line %d -- wrap_box_contents_as_needed in prettyprint-mill-g.pkg\n" column break.indent_on_wrap target_width break.spaces space_left_on_line;
fi;
						    if (*actual_width < column)   actual_width := column;   fi;			# Yes, treat BREAK as newline.
						    break.wrap := TRUE;
						    box_is_multiline :=  TRUE;
						    per_token (rest, /*column=*/ break.indent_on_wrap);
						fi;
					    };

			    BOX box     =>  {   if(*actual_width <  column + *box.actual_width)
						    actual_width := column + *box.actual_width;
						fi;
						if *box.is_multiline
						    box_is_multiline :=  TRUE;
						    per_token( rest, 0 );							# Return to left margin after each multiline box.  This does the best job of decoupling
						else										# events inside and outside a box, making for simple predictable behavior.
						    per_token (rest, column + *box.actual_width);
						fi;
					    };
			esac;
};
		end;		# fun per_token
	    end			# fun wrap_box_contents_as_needed


	also
	fun wrap_box   (box: Box)
	    =
	    {   # Start by recursively wrapping all sub-boxes
		# of this box.  When this is done, we know for
		# each subbox its width and whether it is multiline.
		#
		apply per_token *box.contents
		where
		    fun per_token  (BOX box) =>   wrap_box box;
			per_token _          =>   ();
		    end;
		end;

		# With the wrap decisions for our sub-boxes all
		# made, we now have enough information in hand
		# to make those decisions for our own box:

		case box.wrap_policy
		    #
		    AS_NEEDED  =>  wrap_box_contents_as_needed   (box.target_width, *box.contents );
		    _          =>  wrap_box_contents_all_or_none (box.target_width, *box.contents, box.wrap_policy );
		esac
		    ->
		    (actual_box_width, is_multiline);

		box.actual_width	 :=  actual_box_width;
		box.is_multiline	 :=  (*box.is_multiline or is_multiline);
	    }															# fun wrap_box


	also
	fun print_box (
		box,
		column',	# 0-based column relative to absolute (not box!) left margin
		left_margin',	# Left margin of box containing 'box'.
		pp:Pp
	    )
	    =
	    {   column =  per_token (*box.contents, column);
		#
		my (left_margin, column)
		    =
		    if *box.is_multiline											# This is a hack so that when we can multiple multi-line boxes without emitting multiple newline-indent sequences.
			#													# The idea is to delay doing the newline-indent until we actually print something, and then do just one.
			pp.do_delayed_newline_indent := TRUE;
			(left_margin', left_margin');
		    else
			(left_margin', column);
		    fi;
																
#		my (left_margin, column)
#		    =
#		    move_to_left_margin_if_box_is_multiline (left_margin', column);						# If we are a multi-line box, leave cursor on left margin of our containing box when done.

if *log::debugging
printf "print_box: box#%d done, returning column d=%d  (left_margin' d=%d)\n"  box.id  column  left_margin';
fi;
		column;
	    }
	    where
		fun move_to_left_margin (left_margin, column)
		    =
		    {   if (left_margin < column)
			    #
			    out::newline pp.output_stream;
			    out::spaces (pp.output_stream, left_margin);
			    #
			elif (left_margin > column)
			    #
			    out::spaces (pp.output_stream, left_margin - column);
			fi;

			(left_margin, left_margin);
		    };

		fun move_to_left_margin_if_box_is_multiline (left_margin, column)
		    =
		    if (not *box.is_multiline)			     (left_margin, column);					# We do nothing for monoline boxes.
		    else 			 move_to_left_margin (left_margin, column);
		    fi;

		
		fun maybe_do_delayed_newline_ident column
		    =
		    if *pp.do_delayed_newline_indent
			pp.do_delayed_newline_indent := FALSE;
			#
			out::newline pp.output_stream;
			out::spaces (pp.output_stream, column);
		    fi;

		my (left_margin, column)											# Compute left_margin of our box, move to it if we are a multi-line box.
		    =
		    case (box.left_margin_is, *box.is_multiline)
			#
			(_		 ,   FALSE) =>	(left_margin', column');						# We're not a multiline box, leave left margin unchanged.
			(BOX_RELATIVE    i,  TRUE ) =>  move_to_left_margin (left_margin' + i,          column');		# We're a multiline box, set new left margin relative to left margin of enclosing box.
			(CURSOR_RELATIVE i,  TRUE ) =>	move_to_left_margin (column' + tab0(column',i), column');		# We're a multiline box, set new left margin relative to cursor, tabbing over for consistent positioning on page.
		    esac;

		
		fun per_token  (token ! rest, column)
			=>
{
if *log::debugging
printf "print_box: per_token (column %d  tokens %s)\n"  column  (tokens_to_string (token ! rest));
fi;
			case token
			    #
			    TEXT text
				=>
				{
				    maybe_do_delayed_newline_ident column;
				    out::string (pp.output_stream, text.string);
				    per_token( rest, column + text.length );
				};

			    ENDTXT text
				=>
				{
#				    maybe_do_delayed_newline_ident column;	# The lack of this is the only distinction between TEXT and ENDTXT.
				    out::string (pp.output_stream, text.string);
				    per_token( rest, column + text.length );
				};

			    TAB n
				=>
				{
				    maybe_do_delayed_newline_ident column;
				    i = tab1 (column, n);
				    out::spaces (pp.output_stream, i);
				    per_token (rest, column + i);
				};

			    NONBREAKABLE_SPACES n
				=>
				{
				    maybe_do_delayed_newline_ident column;
				    out::spaces (pp.output_stream, n);
				    per_token (rest, column + n);
				};

			    BREAK break
				=>
				{
				    if *break.wrap
					#
					column = left_margin + break.indent_on_wrap;
					pp.do_delayed_newline_indent := TRUE;
					per_token (rest, column);
					#
				    elif *pp.do_delayed_newline_indent
					#
					maybe_do_delayed_newline_ident column;
					per_token (rest, left_margin);
				    else
					out::spaces (pp.output_stream, break.spaces);
					per_token (rest, column + break.spaces);
				    fi;
				};

			    NEWLINE
				=>
				{
				    maybe_do_delayed_newline_ident column;
				    column = left_margin;
				    out::newline pp.output_stream;
				    out::spaces (pp.output_stream, column);
				    per_token (rest, column);
				};

			    BOX box
				=>
				{
				    maybe_do_delayed_newline_ident column;
				    column =  print_box (box, column, left_margin, pp);
				    per_token (rest, column);
				};

			    PUSH_TEXTTRAITS texttraits
				=>
				{   out::push_texttraits (pp.output_stream, texttraits);
				    per_token (rest, column);
				};

			    POP_TEXTTRAITS
				=>
				{   out::pop_texttraits  pp.output_stream;
				    per_token (rest, column);
				};

			    CONTROL control_fn
				=>
				{   control_fn  pp.output_stream;
				    per_token (rest, column);
				};

			esac;
};
		    per_token ([], column) =>   column;
		end;													# fun per_token
	    end;




	# Here's the heart of the module.
	# We prettyprint in three passes:
	# 1) Build up the box tree -- complete by the time we get here.
	# 2) Decide which breaks to wrap (change to newlines):      wrap_box
	# 3) Print the result out:                                  print_box

	fun prettyprint_box (pp:Pp, box)
	    =
	    {   wrap_box            box;
		print_box          (box,   /*column=*/ 0,   /*left_margin=*/    0,   pp);
	    };





	fun add_token (pp:Pp as { box => REF box, ... }, token)									# Add a token to the reversed_contents of currently-open box.
	    =
	    box.reversed_contents :=   token ! *box.reversed_contents;


	fun add_text (pp:Pp, string, length)
	    =
	    add_token (pp, TEXT { string, length } );

	fun add_endtxt (pp:Pp, string, length)
	    =
	    add_token (pp, ENDTXT { string, length } );



	fun prettyprint_open_box (pp:Pp, left_margin_is, wrap_policy)
	    =
	    {   id = *pp.next_box_id;
		#
		pp.next_box_id := id + 1;

		new_box														# Set up empty record for new box.
		    =
		    { left_margin_is,
		      wrap_policy,
		      target_width         =>  pp.default_target_box_width,
		      id,

		      is_multiline         =>  REF FALSE,
		      actual_width	   =>  REF 0,
		      contents             =>  REF [],
		      reversed_contents    =>  REF []
		    };


		# Add new child box to reversed_contents
		# of previously open box: 
		{   (*pp.box) ->   { reversed_contents, ... }; 
		    #
		    reversed_contents	:=   BOX new_box  !  *reversed_contents;
		}; 

		pp.nested_boxes	:=   *pp.box ! *pp.nested_boxes;		# Push currently open box on stack.
		pp.box_nesting	:=   *pp.box_nesting + 1;			# Remember new stack depth.
		pp.box		:=   new_box;					# Establish new (empty) currently-open box. 


		if (*pp.box_nesting > max_box_nesting)				# Catch prettyprint infinite loops.
		     raise exception     PRETTYPRINT_MAX_DEPTH_EXCEEDED;
		fi;
	    };



	fun finalize_and_pop_current_box  (pp:Pp  as  { box => REF box,  nested_boxes as REF (topbox ! rest), ... })
		=>
		{   box.contents :=   reverse *box.reversed_contents;		# We've accumulated the box contents in reverse order; this produces the contents in their proper order.
		    #
		    pp.box          :=   topbox;				# These three pop the box stack.
		    nested_boxes    :=   rest;
		    pp.box_nesting  :=   *pp.box_nesting - 1;
		};

	    finalize_and_pop_current_box (pp:Pp as {  nested_boxes as REF [], ... } )
		=>
		{   /*raise exception FAIL*/ print "User error: Attempted to close nonexistent box!";
		    ();
		};
	end;


	fun prettyprint_break  (pp:Pp as { box => REF { reversed_contents, ... }, ... },  { spaces, indent_on_wrap } )
	    =
	    reversed_contents :=  (BREAK { spaces,  indent_on_wrap,  wrap => REF FALSE } )
				  !
				  *reversed_contents;


	fun prettyprint_newline (pp:Pp as { box => REF { reversed_contents, ... }, ... })
	    =
	    reversed_contents :=   NEWLINE ! *reversed_contents;


	fun prettyprint_flush (pp:Pp as { box, nested_boxes, output_stream, next_box_id, ... }, with_newline)
	    =
	    {   end_boxes ()
		where
		    fun end_boxes ()
			=
			case *nested_boxes
			    #
			    [] =>						# NB: To avoid special cases, we always leave one box on the stack.
				{
				    (*box) ->    { contents, reversed_contents, actual_width, is_multiline, ... };

				    contents :=   reverse *reversed_contents;	# Box contents accumulate in reverse order.
										# Normally we correct for this by reversing
										# the contents list when we close a box, but
										# the root box never gets closed, so we have
										# to reverse the contents here, right before
										# prettyprinting them.

if *log::debugging
    printf "\nStart of call to prettyprint_box on outermost box -- prettyprint_flush in prettyprint-mill-g.pkg\n";
    printf "Printing state of prettyprinter -- prettyprint_flush in prettyprint-mill-g.pkg\n";
    dump(fil::stdout, pp);
    printf "Calling prettyprint_box on outermost box -- prettyprint_flush in prettyprint-mill-g.pkg\n";
fi;
				    prettyprint_box (pp, *box);			# Prettyprint outermost box.
										# This is where all the actual formatting work gets done.
if *log::debugging
    printf "Back from calling prettyprint_box on outermost box -- prettyprint_flush in prettyprint-mill-g.pkg\n";
fi;

				    contents		 :=  [];		# Clear out the prettyprint stuff so
				    reversed_contents	 :=  [];		# we don't wind up printing it again. 
				    actual_width	 :=  0;			# 
				    is_multiline	 :=  FALSE;
				    next_box_id		 :=  1;
				};

			    topbox ! rest
				=>
				{   finalize_and_pop_current_box  pp;
				    end_boxes ();
				};
			esac; 
		end;

		if with_newline      out::newline pp.output_stream;   fi;

		out::flush output_stream;
	    };


	# *** USER FUNCTIONS ***

	fun make_prettyprinter d args
	    =
	    {	# Set up default values of all optional parameters:
		#
		default_target_box_width =  REF default_target_box_width;
		default_left_margin_is   =  REF default_left_margin_is;

		# Let any supplied optional arguments override the above defaults:
		#
		apply note_optional_arg args
		where
		    fun note_optional_arg (DEFAULT_TARGET_BOX_WIDTH i) =>  default_target_box_width := i;
			note_optional_arg (DEFAULT_LEFT_MARGIN_IS   i) =>  default_left_margin_is   := i;
		    end;
		end;

		# Construct actual prettyprinter record to return:
		#
		  { output_stream            =>  d,
		    output_stream_is_closed  =>  REF FALSE,
		    do_delayed_newline_indent =>  REF FALSE,
		    #
		    default_target_box_width =>  *default_target_box_width,
		    default_left_margin_is   =>  *default_left_margin_is,
		    texttraits_stack	     =>  REF [],
		    box_nesting		     =>  REF 0,
		    next_box_id		     =>  REF 1,
		    nested_boxes	     =>  REF [],
		    box			     =>  REF  { left_margin_is		=>   BOX_RELATIVE 0,
							target_width		=>  *default_target_box_width,
							wrap_policy		=>   AS_NEEDED,
							id			=>       0,
							actual_width		=>   REF 0,
							is_multiline		=>   REF FALSE,
							contents		=>   REF [],
							reversed_contents	=>   REF []
						      }
		  };	

	    };



	fun flush_prettyprinter  prettyprinter
	    =
	    prettyprint_flush (prettyprinter, FALSE);


	fun close_prettyprinter (pp:Pp)
	    =
	    {   flush_prettyprinter  pp;
		#
		pp.output_stream_is_closed :=  TRUE;
	    };


	fun get_output_stream (pp:Pp)
	    =
	    pp.output_stream;


	fun begin_horizontal_4box			prettyprinter		=  prettyprint_open_box (prettyprinter,  BOX_RELATIVE 4,  NONE);
	fun begin_vertical_4box				prettyprinter		=  prettyprint_open_box (prettyprinter, (BOX_RELATIVE 4), ALL);
	fun begin_align_4box				prettyprinter		=  prettyprint_open_box (prettyprinter, (BOX_RELATIVE 4), ALL_OR_NONE);
	fun begin_wrap_4box				prettyprinter		=  prettyprint_open_box (prettyprinter, (BOX_RELATIVE 4), AS_NEEDED);

	fun begin_horizontal_0box			prettyprinter		=  prettyprint_open_box (prettyprinter,  BOX_RELATIVE 0,  NONE);
	fun begin_vertical_0box				prettyprinter		=  prettyprint_open_box (prettyprinter, (BOX_RELATIVE 0), ALL);
	fun begin_align_0box				prettyprinter		=  prettyprint_open_box (prettyprinter, (BOX_RELATIVE 0), ALL_OR_NONE);
	fun begin_wrap_0box				prettyprinter		=  prettyprint_open_box (prettyprinter, (BOX_RELATIVE 0), AS_NEEDED);

	fun begin_horizontal_cbox			prettyprinter		=  prettyprint_open_box (prettyprinter,  CURSOR_RELATIVE 4,  NONE);
	fun begin_vertical_cbox				prettyprinter		=  prettyprint_open_box (prettyprinter, (CURSOR_RELATIVE 4), ALL);
	fun begin_align_cbox				prettyprinter		=  prettyprint_open_box (prettyprinter, (CURSOR_RELATIVE 4), ALL_OR_NONE);
	fun begin_wrap_cbox				prettyprinter		=  prettyprint_open_box (prettyprinter, (CURSOR_RELATIVE 4), AS_NEEDED);

	fun begin_indented_horizontal_box		prettyprinter indent	=  prettyprint_open_box (prettyprinter, indent, NONE);
	fun begin_indented_vertical_box			prettyprinter indent	=  prettyprint_open_box (prettyprinter, indent, ALL);
	fun begin_indented_align_box			prettyprinter indent	=  prettyprint_open_box (prettyprinter, indent, ALL_OR_NONE);
	fun begin_indented_wrap_box			prettyprinter indent	=  prettyprint_open_box (prettyprinter, indent, AS_NEEDED);

	fun end_box   prettyprinter 
	    =
	    finalize_and_pop_current_box   prettyprinter;

	fun horizontal_4box			prettyprinter thunk =   { begin_horizontal_4box			prettyprinter;   thunk();   end_box prettyprinter; };
	fun vertical_4box    			prettyprinter thunk =   { begin_vertical_4box			prettyprinter;   thunk();   end_box prettyprinter; };
	fun align_4box				prettyprinter thunk =   { begin_align_4box			prettyprinter;   thunk();   end_box prettyprinter; };
	fun wrap_4box				prettyprinter thunk =   { begin_wrap_4box			prettyprinter;   thunk();   end_box prettyprinter; };

	fun horizontal_0box			prettyprinter thunk =   { begin_horizontal_0box			prettyprinter;   thunk();   end_box prettyprinter; };
	fun vertical_0box    			prettyprinter thunk =   { begin_vertical_0box			prettyprinter;   thunk();   end_box prettyprinter; };
	fun align_0box				prettyprinter thunk =   { begin_align_0box			prettyprinter;   thunk();   end_box prettyprinter; };
	fun wrap_0box				prettyprinter thunk =   { begin_wrap_0box			prettyprinter;   thunk();   end_box prettyprinter; };

	fun horizontal_cbox			prettyprinter thunk =   { begin_horizontal_cbox			prettyprinter;   thunk();   end_box prettyprinter; };
	fun vertical_cbox    			prettyprinter thunk =   { begin_vertical_cbox			prettyprinter;   thunk();   end_box prettyprinter; };
	fun align_cbox				prettyprinter thunk =   { begin_align_cbox			prettyprinter;   thunk();   end_box prettyprinter; };
	fun wrap_cbox				prettyprinter thunk =   { begin_wrap_cbox			prettyprinter;   thunk();   end_box prettyprinter; };


	fun styled_string (pp:Pp) styled_string
	    =
	    {   styled_string_texttraits =  ss::texttraits styled_string;
		#
		if (out::same_texttraits (current_texttraits pp, styled_string_texttraits))
		    #
		    add_text  (pp, ss::string styled_string, ss::size styled_string);
		else
		    add_token (pp, PUSH_TEXTTRAITS styled_string_texttraits);
		    add_text  (pp, ss::string styled_string, ss::size styled_string);
		    add_token (pp, POP_TEXTTRAITS);
		fi;
	    };


	fun string prettyprinter s
	    =
	    add_text (prettyprinter, s, size s);


	fun endtxt prettyprinter s
	    =
	    add_endtxt (prettyprinter, s, size s);


	fun push_texttraits (pp:Pp, sty)
	    =
	    {   if (not (out::same_texttraits (current_texttraits pp, sty)))
		    #
		    add_token (pp, PUSH_TEXTTRAITS sty);
		fi;

		pp.texttraits_stack :=   sty ! *pp.texttraits_stack;
	    };


	fun pop_texttraits (pp:Pp)
	    =
	    case *pp.texttraits_stack
		#
		[] => {  /*raise exception FAIL*/ print "User error: pp: unmatched pop_texttraits\n";
		      };

		(sty ! rest)
		    =>
		    {   pp.texttraits_stack := rest;
			#
			if (not (out::same_texttraits (current_texttraits pp, sty)))
			    #
			    add_token (pp, POP_TEXTTRAITS);
			fi;
		    };
	    esac;


	fun break               prettyprinter arg =  prettyprint_break (prettyprinter, arg);
	fun space               prettyprinter n   =  break prettyprinter { spaces => n, indent_on_wrap => 0 };
	fun cut                 prettyprinter     =  break prettyprinter { spaces => 0, indent_on_wrap => 0 };
	fun newline             prettyprinter     =  prettyprint_newline prettyprinter;
	fun nonbreakable_spaces prettyprinter n   =  add_token (prettyprinter, NONBREAKABLE_SPACES n );
	fun tab                 prettyprinter n   =  add_token (prettyprinter, TAB                 n );

	fun control prettyprinter control_fn
	    =
	    add_token (prettyprinter, CONTROL control_fn);
    };
end;

## COPYRIGHT (c) 2005 John Reppy (http://www.cs.uchicago.edu/~jhr)
## All rights reserved.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
