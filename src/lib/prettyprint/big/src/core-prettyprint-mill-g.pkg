## prettyprint-mill-g.pkg
#
# This file is intended to contain just the core prettyprint mill code.
# Convenience code for the benefit of code clients belongs in wapper pkg
# 
#     src/lib/prettyprint/big/src/base-prettyprint-mill-g.pkg
#
# For a general motivation and overview see Note[1] at bottom of:
#
#     src/lib/prettyprint/big/src/core-prettyprint-mill.api
#
# Our only code client is the wrapper which makes us more palatable to client code:
#
#     src/lib/prettyprint/big/src/base-prettyprint-mill-g.pkg
#
#############################################################################################
# Ok, this whole prettyprinter thing is coming into focus.
#
#     ##########################################################
#     It is all about boxes and squibs which do different things
#     depending on whether the box is monoline or multiline.
#     ##########################################################
#
# The generic box record should maybe include
#
#     .enter_box_stuff_when_monoline:   Prettyprint_Mill -> Void,		# Or maybe these should be Ref(List(Prettyprint_Mill -> Void)) to allow easy incremental updates?
#     .enter_box_stuff_when_multiline:  Prettyprint_Mill -> Void,
#
#     .exit_box_stuff_when_monoline:    Prettyprint_Mill -> Void,
#     .exit_box_stuff_when_multiline:   Prettyprint_Mill -> Void
#
# to allow arbitrary enter-box 
# and we should have a generic squib
#
#     pp.custom:   { monoline:  Void -> { tab:    Int, text: String },			# We don't provide 'column' because we want tabbing behavior abstract.
#                    multiline: Void -> { indent: Int, text: String }			# 
#		   }
#
# to do one   set of commands when the box is monoline
# and another set of commands when the box is multiline.
#
# On the specific command front, I think we need a
#
#     pp.pad n
#
# command which emits 'n' blanks when the box is MULTI-line
# and does nothing when it is monoline.
#
# We also want I think more prettyprinter defaults governing
# weird hacks like newline/indent collapsing, and a
#
#     pp.box' -> List( Default_Overrides ) -> ...
#
# which allows setting all the box behaviors explicitly on a
# box-by-box basis.
#
#     ##########################################################
#     Tabs are a global coherency issue;  they should be set once
#     globally in the prettyprinter and squibs should work in
#     terms of tabs.
#     For my standard layout:
#        tabstops should be every '2'
#        .tab 1    should move one tabstop.
#        .tab 2    should move to an even-number tabstop -- NOT JUST TWO TABS.
#
#        .indent i should be just like .tab except relative to left margin not cursor.
#                  It will ultimately do a newline iff column > target location.
#     .tab and .indent should both just set a virtual location,
#     NOT actually output newlines and blanks.
#     ##########################################################
#
#
#############################################################################################
#
#
# The core engine for the system prettyprinter.
#
# See ../README.
#
# Concise overview:
#
# -> The only purpose of the prettyprinter is to decide where
#    to put newlines, whitespace and indentation.
#
# -> The prettyprinter views its input stream as consisting
#    of known-width 'styled_strings' containing the useful text to be
#    printed, and of 'breaks', which mark places where it is
#    allowed to insert a newline.
#
# -> The desired structure is represented as a set of nested
#    'boxes', where a box essentially indicates the newline
#    insertion policy to be followed for some stretch of text.
#      Each box also has some default indentation for each line,
#    which will typically increase with box nesting level.
#
# -> The simplest box type is 'h' (horizontal)', in which
#    breaks are -never- converted to newlines.
#
# -> The next simplest box type is 'v' (vertical)', in which
#    breaks are -always- converted to newlines.
#
# -> The 'line' box type is slightly more sophisticated:  It
#    behaves as an 'h' box if the result will fit on a line,
#    else as a v box:  In simple cases, this results in the
#    styled_strings in the box all being placed in a line, either
#    horizontal or vertical.  In an line box, either all the
#    breaks produce newlines, or else none do.
#
# -> The 'wrap' box type is the most commonly used, and implements
#    the familiar word-wrap algorithm:  A break produces a newline
#    iff this is required to keep the line length within width limits.
#
## 2007-09-10 CrT: Completely rewritten.  Twice. ;-)
#
# Design goals:
#
# I)   For simplicity and consistency, layout of a box should depend
#      only on its contents, not on anything outside of it, such as
#      how far it is indented.
#
# II)  For readability, the inked part of a line (i.e., the part left
#      after stripping leading and trailing whitespace) should be about
#      10-100 chars long.  For example, we don't want to degenerate
#      to vertical columns of short words against the right margin.
#
# III) We are willing to have output extend arbitrarily far to the
#      right (everyone has scrollbars these days) if necessary,
#      but we want to minimize rightward drift due to indentation
#      where reasonably possible.
#
# Implementation decisions driven by above design goals:
#
# 1)   
#
# See also:
#     src/lib/prettyprint/big/src/prettyprint-stream-g.pkg

# Compiled by:
#     src/lib/prettyprint/big/prettyprint-mill.lib


###		"This task was appointed to you, Frodo of the Shire.
###              If you do not find a way, no one will."
###                                                  --Galadriel





stipulate
    package fil =  file__premicrothread;					# file__premicrothread							is from   src/lib/std/src/posix/file--premicrothread.pkg
    package l2s =  list_to_string;						# list_to_string							is from   src/lib/src/list-to-string.pkg
#   package pmt =  prettyprint_mill_types;					# prettyprint-mill_types						is from   src/lib/prettyprint/big/src/prettyprint-mill-types.pkg
herein

    # This generic is invoked (only) from
    #
    #     src/lib/prettyprint/big/src/base-prettyprint-mill-g.pkg
    #
    generic package   core_prettyprint_mill_g   (				# 
	#             =======================
	#									# "tt" == "traitful text"
	package tt:	Traitful_Text;						# Traitful_Text								is from   src/lib/prettyprint/big/src/traitful-text.api
	package out:    Prettyprint_Output_Stream;				# Prettyprint_Output_Stream						is from   src/lib/prettyprint/big/src/out/prettyprint-output-stream.api
										# out will be something like html_prettyprint_output_stream		   from   src/lib/prettyprint/big/src/out/html-prettyprint-output-stream.pkg
	sharing tt::Texttraits == out::Texttraits;
    )
#    : (weak)
#    api {
#	include Core_Prettyprint_Mill;						# Core_Prettyprint_Mill							is from   src/lib/prettyprint/big/src/core-prettyprint-mill.api
#
#	prettyprint_prettyprint_mill
#	    :
#	    (fil::Output_Stream,  Prettyprint_Mill)
#	    ->
#	    Void;
#										# This api is commented out because at the moment I don't see a way
#	prettyprint_open_box							# to use it export prettyprint_open_box, since it depends on
#	    (Prettyprint_Mill, :Pp, left_margin_is, format)			# Left_Margin_Is and Break_Policy which come from pmt.  (Yes, we could move them out of pmt.)
#    }
    {
	too_long =  8888;   # A box-length value picked to be large
			    # enough to not fit in any plausible box,
			    # but small enough that adding a few
			    # together won't produce integer overflow.

	package pmt								# Our core datastructures are parameterized over 'out' and 'tt',	
	    =									#
	    core_prettyprint_mill_types_g (					# core_prettyprint_mill_types_g	is from   src/lib/prettyprint/big/src/core-prettyprint-mill-types-g.pkg
		#
		package out = out;						# package out			is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
		package tt  = tt;						# traitless_text		is from   src/lib/prettyprint/big/src/traitless-text.pkg
	    );

	package dbg								# Our datastructure prettyprinter depends on our datastructures. 
	    =
	    core_prettyprint_mill_debug_g (					# core_prettyprint_mill_debug_g	is from   src/lib/prettyprint/big/src/core-prettyprint-mill-types-g.pkg
		#
		package pmt = pmt;
	    );

	package box								# 
	    =
	    core_prettyprint_mill_box_formatting_policies_g (			# core_prettyprint_mill_box_formatting_policies_g	is from   src/lib/prettyprint/big/src/core-prettyprint-mill-box-formatting-policies-g.pkg
		#
		package pmt = pmt;
		package dbg = dbg;
		too_long = too_long;
	    );

	prettyprint_prettyprint_mill =  dbg::prettyprint_prettyprint_mill;

	default_tabstops_are_every =    2;					# This can be overridden via TABSTOPS_ARE_EVERY.
	default_target_box_width   =  100;					# This can be overridden via DEFAULT_TARGET_BOX_WIDTH.
	max_box_nesting            = 1000;					# Purely to catch prettyprint infinite recursions. 

	Prettyprint_Output_Stream  =  out::Prettyprint_Output_Stream;		# Handles device-specific aspects (e.g. selecting bold/bright/green/... text) of writing to ansi terminal, plain ascii stream, html stream or whatever.
	Texttraits     =  tt::Texttraits;					# Text attributes like color, underline, blink etc.
	Traitful_Text  =  tt::Traitful_Text;					# A Traitful_Text contains a String plus whatever Textstyle information is required to render it in HTML or on an ansi terminal or whatever.

	default_left_margin_is
	    =
	    pmt::BOX_RELATIVE {
		spaces => 0,
		tab_to => 0,
		tabstops_are_every => 4
	    };
										# I don't think this is actually ever used...

										# We build up a prettyprint expression as a tree
										# of nested_boxes until we are flushed, at which
										# point we actually format and print it.
										#
										# At any given time, the currently open box is 'box',
										# the one enclosing it is first in the nested_boxes
										# list, and the root of the box tree is last in the
										# nested_boxes list.  (Keeping the top of the stack
										# in a separate variable lets us communicate to the
										# type system that we always have at least one box
										# on the stack, and thus avoid a lot of spurious
										# checks for stack-empty.)
										#
										# We don't actually use the texttraits_stack
										# for anything in this module -- it is
										# purely an opaque-to-us customer
										# convenience:


	Prettyprint_Mill = pmt::Prettyprint_Mill;				# Export for code clients.
	Pp               = pmt::Prettyprint_Mill;				# For when the brevity bug bites.






	# *** UTILITY FUNCTIONS ***


	fun current_texttraits (pp:Pp as { texttraits_stack => REF (texttraits ! _),    ... } ) =>  texttraits;						# Current texttraits are the top entry on the textstyle stack,
	    current_texttraits (pp:Pp as { texttraits_stack => REF [], output_stream,  ... } ) =>  out::default_texttraits output_stream;		# or else the default texttraits if the stack is empty:
	end;

	nblanks  =  box::nblanks;
	tablen   =  box::tablen;
	breaklen =  box::breaklen;

	my     wrap_box_contents_all_or_none
        = box::wrap_box_contents_all_or_none;

	my     wrap_box_contents_as_needed
        = box::wrap_box_contents_as_needed;

	horizontal   =  { name => "vertical",     code => wrap_box_contents_all_or_none	pmt::NONE		}:  pmt::Box_Format;
	vertical     =  { name => "horizontal",   code => wrap_box_contents_all_or_none	pmt::ALL		}:  pmt::Box_Format;
	normal       =  { name => "normal",       code => wrap_box_contents_all_or_none	pmt::ALL_OR_NONE	}:  pmt::Box_Format;
	ragged_right =  { name => "ragged_right", code => wrap_box_contents_as_needed				}:  pmt::Box_Format;

	fun wrap_box   (box: pmt::Box, pp:Pp)
	    =
	    {   # Start by recursively wrapping all sub-boxes
		# of this box.  When this is done, we know for
		# each subbox its width and whether it is multiline.
		#
		apply per_token *box.contents
		where
		    fun per_token  (pmt::BOX box) =>   wrap_box (box,pp);
			per_token _               =>   ();
		    end;
		end;

		# With the wrap decisions for our sub-boxes all
		# made, we now have enough information in hand
		# to make those decisions for our own box:

		stipulate
		    target_width	=   box.target_width;
		    box_contents	=  *box.contents;
		    tabstops_are_every	=   pp.tabstops_are_every;
		herein
		    (box.format.code { target_width, box_contents, tabstops_are_every })
			->
			{ actual_box_width, is_multiline };
		end;

		box.actual_width	 :=  actual_box_width;
		box.is_multiline	 :=  (*box.is_multiline or is_multiline);
	    }															# fun wrap_box


	also
	fun print_box (
		box,
		column',	# 0-based column relative to absolute (not box!) left margin
		left_margin',	# Left margin of box containing 'box'.
		pp:Pp
	    )
	    =
	    {   column =  print_tokens (*box.contents, column);
		#
		my (left_margin, column)
		    =
		    if *box.is_multiline											# This is a hack so that when we can multiple multi-line boxes without emitting multiple newline-indent sequences.
			#													# The idea is to delay doing the newline-indent until we actually print something, and then do just one.
			pp.do_delayed_newline_indent := TRUE;
			(left_margin', left_margin');
		    else
			(left_margin', column);
		    fi;
																
#		my (left_margin, column)
#		    =
#		    move_to_left_margin_if_box_is_multiline (left_margin', column);						# If we are a multi-line box, leave cursor on left margin of our containing box when done.

if *log::debugging
printf "print_box: box#%d done, returning column d=%d  (left_margin' d=%d)\n"  box.id  column  left_margin';
fi;
		column;
	    }
	    where
		fun move_to_left_margin (left_margin, column)
		    =
		    {   if (left_margin < column)
			    #
			    out::newline pp.output_stream;
			    out::spaces (pp.output_stream, left_margin);
			    #
			elif (left_margin > column)
			    #
			    out::spaces (pp.output_stream, left_margin - column);
			fi;

			(left_margin, left_margin);
		    };

		fun move_to_left_margin_if_box_is_multiline (left_margin, column)
		    =
		    if (not *box.is_multiline)			     (left_margin, column);							# We do nothing for monoline boxes.
		    else 			 move_to_left_margin (left_margin, column);
		    fi;

		
		fun maybe_do_delayed_newline_ident column
		    =
		    if *pp.do_delayed_newline_indent
			pp.do_delayed_newline_indent := FALSE;
			#
			out::newline pp.output_stream;
			out::spaces (pp.output_stream, column);
		    fi;

		my (left_margin, column)													# Compute left_margin of our box, move to it if we are a multi-line box.
		    =
		    case (box.left_margin_is, *box.is_multiline)
			#
			(_		       ,  FALSE) =>	(left_margin', column');							# We're not a multiline box, leave left margin unchanged.
			(pmt::BOX_RELATIVE    r,  TRUE ) =>     move_to_left_margin (left_margin' + breaklen(left_margin', r), column');	# We're a multiline box, set new left margin relative to left margin of enclosing box.
			(pmt::CURSOR_RELATIVE r,  TRUE ) =>	move_to_left_margin (column'      + breaklen(column',      r), column');	# We're a multiline box, set new left margin relative to cursor, tabbing over for consistent positioning on page.
		    esac;

		
		fun print_tokens  (token ! rest, column)
			=>
{
if *log::debugging
printf "print_box: print_tokens (column %d  tokens %s)\n"  column  (dbg::tokens_to_string (token ! rest));
fi;
			case token
			    #
			    pmt::TEXT text
				=>
				{
				    maybe_do_delayed_newline_ident column;
				    out::text (pp.output_stream, text.string);
				    print_tokens( rest, column + text.length );
				};

			    pmt::ENDTXT text
				=>
				{
#				    maybe_do_delayed_newline_ident column;	# The lack of this is the only distinction between TEXT and ENDTXT.
				    out::text (pp.output_stream, text.string);
				    print_tokens( rest, column + text.length );
				};

			    pmt::TAB t
				=>
				{
				    maybe_do_delayed_newline_ident column;
				    i = tablen (column, t);
				    out::spaces (pp.output_stream, i);
				    print_tokens (rest, column + i);
				};

			    pmt::BREAK b
				=>
				{
				    if *b.wrap
					#
					column = left_margin + tablen (left_margin, b.ifwrap);
					pp.do_delayed_newline_indent := TRUE;
					print_tokens (rest, column);
					#
				    elif *pp.do_delayed_newline_indent
					#
					maybe_do_delayed_newline_ident column;
					print_tokens (rest, left_margin);
				    else
					t  = breaklen (column, b.ifnotwrap);   if (t  > 0)   out::text (pp.output_stream, nblanks t);   fi;   column = column + t;
					#
					print_tokens (rest, column + t);
				    fi;
				};

			    pmt::NEWLINE
				=>
				{
				    maybe_do_delayed_newline_ident column;
				    column = left_margin;
				    out::newline pp.output_stream;
				    out::spaces (pp.output_stream, column);
				    print_tokens (rest, column);
				};

			    pmt::BOX box
				=>
				{
				    maybe_do_delayed_newline_ident column;
				    column =  print_box (box, column, left_margin, pp);
				    print_tokens (rest, column);
				};

			    pmt::PUSH_TEXTTRAITS texttraits
				=>
				{   out::push_texttraits (pp.output_stream, texttraits);
				    print_tokens (rest, column);
				};

			    pmt::POP_TEXTTRAITS
				=>
				{   out::pop_texttraits  pp.output_stream;
				    print_tokens (rest, column);
				};

			    pmt::CONTROL control_fn
				=>
				{   control_fn  pp.output_stream;
				    print_tokens (rest, column);
				};

			esac;
};
		    print_tokens ([], column) =>   column;
		end;													# fun print_tokens
	    end;




	# Here's the heart of the module.
	# We prettyprint in three passes:
	# 1) Build up the box tree -- complete by the time we get here.
	# 2) Decide which breaks to wrap (change to newlines):      wrap_box
	# 3) Print the result out:                                  print_box

	fun prettyprint_box (pp:Pp, box)
	    =
	    {   wrap_box            (box, pp);
		print_box           (box,   /*column=*/ 0,   /*left_margin=*/    0,   pp);
	    };





	fun add_token (pp:Pp as { box => REF box, ... }, token)									# Add a token to the reversed_contents of currently-open box.
	    =
	    box.reversed_contents :=   token ! *box.reversed_contents;


	fun add_text (pp:Pp, string, length)
	    =
	    add_token (pp, pmt::TEXT { string, length } );

	fun add_endtxt (pp:Pp, string, length)
	    =
	    add_token (pp, pmt::ENDTXT { string, length } );



	fun prettyprint_open_box (pp:Pp, left_margin_is, format)								# This is a main entrypoint for   src/lib/prettyprint/big/src/base-core-prettyprint-mill-g.pkg
	    =
	    {   id = *pp.next_box_id;
		#
		pp.next_box_id := id + 1;

		new_box														# Set up empty record for new box.
		    =
		    { left_margin_is,
		      target_width         =>   pp.default_target_box_width,
		      id,

		      is_multiline         =>   REF FALSE,
		      actual_width	   =>   REF 0,
		      contents             =>   REF [],
		      reversed_contents    =>   REF [],

		      format	   =>   case format
						    #
						    pmt::NONE		=>  horizontal;
						    pmt::ALL		=>  vertical;
						    pmt::ALL_OR_NONE	=>  normal;
						    pmt::AS_NEEDED	=>  ragged_right;
						esac
		    };


		# Add new child box to reversed_contents
		# of previously open box: 
		{   (*pp.box) ->   { reversed_contents, ... }; 
		    #
		    reversed_contents	:=   pmt::BOX new_box  !  *reversed_contents;
		}; 

		pp.nested_boxes	:=   *pp.box ! *pp.nested_boxes;		# Push currently open box on stack.
		pp.box_nesting	:=   *pp.box_nesting + 1;			# Remember new stack depth.
		pp.box		:=   new_box;					# Establish new (empty) currently-open box. 


		if (*pp.box_nesting > max_box_nesting)				# Catch prettyprint infinite loops.
		     raise exception FAIL "max box nesting depth exceeded -- core-prettyprint-mill-g.pkg";
		fi;
	    };



	fun finalize_and_pop_current_box  (pp:Pp  as  { box => REF box,  nested_boxes as REF (topbox ! rest), ... })
		=>
		{   box.contents :=   reverse *box.reversed_contents;		# We've accumulated the box contents in reverse order; this produces the contents in their proper order.
		    #
		    pp.box          :=   topbox;				# These three pop the box stack.
		    nested_boxes    :=   rest;
		    pp.box_nesting  :=   *pp.box_nesting - 1;
		};

	    finalize_and_pop_current_box (pp:Pp as {  nested_boxes as REF [], ... } )
		=>
		{   /*raise exception FAIL*/ print "User error: Attempted to close nonexistent box!";
		    ();
		};
	end;


	fun prettyprint_break  (pp:Pp as { box => REF { reversed_contents, ... }, ... },  { spaces, indent_on_wrap } )
	    =
	    reversed_contents :=  (pmt::BREAK { wrap      =>  REF FALSE,
						ifnotwrap =>  { spaces, tab_to => 0,              tabstops_are_every => 0 },
						ifwrap    =>  {         tab_to => indent_on_wrap, tabstops_are_every => 4 }
					      }
                                  )
				  !
				  *reversed_contents;


	fun prettyprint_newline (pp:Pp as { box => REF { reversed_contents, ... }, ... })
	    =
	    reversed_contents :=   pmt::NEWLINE ! *reversed_contents;


	fun prettyprint_flush (pp:Pp as { box, nested_boxes, output_stream, next_box_id, ... }, with_newline)	# with_newline is currently always FALSE -- only call to prettyprint_flush() is below in  flush_prettyprint_mill()
	    =
	    {   end_boxes ()
		where
		    fun end_boxes ()
			=
			case *nested_boxes
			    #
			    [] =>						# NB: To avoid special cases, we always leave one box on the stack.
				{
				    (*box) ->    { contents, reversed_contents, actual_width, is_multiline, ... };

				    contents :=   reverse *reversed_contents;	# Box contents accumulate in reverse order.
										# Normally we correct for this by reversing
										# the contents list when we close a box, but
										# the root box never gets closed, so we have
										# to reverse the contents here, right before
										# prettyprinting them.

if *log::debugging
    printf "\nStart of call to prettyprint_box on outermost box -- prettyprint_flush in prettyprint-mill-g.pkg\n";
    printf "Printing state of prettyprinter -- prettyprint_flush in prettyprint-mill-g.pkg\n";
    dbg::prettyprint_prettyprint_mill (fil::stdout, pp);
    printf "Calling prettyprint_box on outermost box -- prettyprint_flush in prettyprint-mill-g.pkg\n";
fi;
				    prettyprint_box (pp, *box);			# Prettyprint outermost box.
										# This is where all the actual formatting work gets done.
if *log::debugging
    printf "Back from calling prettyprint_box on outermost box -- prettyprint_flush in prettyprint-mill-g.pkg\n";
fi;

				    contents		 :=  [];		# Clear out the prettyprint stuff so
				    reversed_contents	 :=  [];		# we don't wind up printing it again. 
				    actual_width	 :=  0;			# 
				    is_multiline	 :=  FALSE;
				    next_box_id		 :=  1;
				};

			    topbox ! rest
				=>
				{   finalize_and_pop_current_box  pp;
				    end_boxes ();
				};
			esac; 
		end;

		if with_newline      out::newline pp.output_stream;   fi;

		out::flush output_stream;
	    };


	# *** EXPORTED FUNCTIONS ***

	fun make_prettyprint_mill  prettyprint_output_stream  args
	    =
	    {	# Set up default values of all optional parameters:
		#
		default_target_box_width =  REF default_target_box_width;
		default_left_margin_is   =  REF default_left_margin_is;
		tabstops_are_every       =  REF default_tabstops_are_every;

		# Let any supplied optional arguments override the above defaults:
		#
		apply note_optional_arg args
		where
		    fun note_optional_arg (pmt::DEFAULT_TARGET_BOX_WIDTH i) =>  default_target_box_width := i;
			note_optional_arg (pmt::DEFAULT_LEFT_MARGIN_IS   i) =>  default_left_margin_is   := i;
			note_optional_arg (pmt::TABSTOPS_ARE_EVERY       i) =>  tabstops_are_every       := i;
		    end;
		end;

		# Construct actual prettyprinter record to return:
		#
		  { output_stream            =>  prettyprint_output_stream,
		    output_stream_is_closed  =>  REF FALSE,
		    do_delayed_newline_indent =>  REF FALSE,
		    #
		    default_target_box_width =>  *default_target_box_width,
		    default_left_margin_is   =>  *default_left_margin_is,
		    tabstops_are_every       =>  *tabstops_are_every,
		    #
		    texttraits_stack	     =>  REF [],
		    box_nesting		     =>  REF 0,
		    next_box_id		     =>  REF 1,
		    nested_boxes	     =>  REF [],
		    box			     =>  REF  { left_margin_is		=>   pmt::BOX_RELATIVE { spaces => 0, tab_to => 0, tabstops_are_every => 4 },
							target_width		=>  *default_target_box_width,
							id			=>       0,
							actual_width		=>   REF 0,
							is_multiline		=>   REF FALSE,
							contents		=>   REF [],
							reversed_contents	=>   REF [],
							format			=>   normal
						      }
		  };
	    };



	fun flush_prettyprint_mill  prettyprinter
	    =
	    prettyprint_flush (prettyprinter, FALSE);


	fun close_prettyprint_mill (pp:Pp)
	    =
	    {   flush_prettyprint_mill  pp;
		#
		pp.output_stream_is_closed :=  TRUE;
	    };


	fun get_prettyprint_output_stream (pp:Pp)
	    =
	    pp.output_stream;


	fun traitful_text (pp:Pp) traitful_text
	    =
	    {   traitful_text_texttraits =  tt::texttraits traitful_text;
		#
		if (out::same_texttraits (current_texttraits pp, traitful_text_texttraits))
		    #
		    add_text  (pp, tt::string traitful_text, tt::size traitful_text);
		else
		    add_token (pp, pmt::PUSH_TEXTTRAITS traitful_text_texttraits);
		    add_text  (pp, tt::string traitful_text, tt::size traitful_text);
		    add_token (pp, pmt::POP_TEXTTRAITS);
		fi;
	    };



	fun push_texttraits (pp:Pp, texttraits)
	    =
	    {   if (not (out::same_texttraits (current_texttraits pp, texttraits)))
		    #
		    add_token (pp, pmt::PUSH_TEXTTRAITS texttraits);
		fi;

		pp.texttraits_stack :=   texttraits ! *pp.texttraits_stack;
	    };


	fun pop_texttraits (pp:Pp)
	    =
	    case *pp.texttraits_stack
		#
		[] => {  /*raise exception FAIL*/ print "User error: pp: unmatched pop_texttraits\n";
		      };

		(sty ! rest)
		    =>
		    {   pp.texttraits_stack := rest;
			#
			if (not (out::same_texttraits (current_texttraits pp, sty)))
			    #
			    add_token (pp, pmt::POP_TEXTTRAITS);
			fi;
		    };
	    esac;


    };
end;

## COPYRIGHT (c) 2005 John Reppy (http://www.cs.uchicago.edu/~jhr)
## All rights reserved.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
