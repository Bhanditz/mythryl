## core-prettyprint-mill-types-g.pkg
#
# Define the core datastructures used by
#
#     src/lib/prettyprint/big/src/core-prettyprint-mill-g.pkg
#
# and related packages.  We need to externalize these public so
# that we can reduce clutter in core-prettyprint-mill-g.pkg by
# moving debug stuff etc to support packages.

# Compiled by:
#     src/lib/prettyprint/big/prettyprint-mill.lib


stipulate
herein

    # This generic is invoked (only) from
    #
    #     src/lib/prettyprint/big/src/core-prettyprint-mill-g.pkg
    #
    generic package  core_prettyprint_mill_types_g    (
	#            =============================
	#
	package out:    Prettyprint_Output_Stream;			# Prettyprint_Output_Stream						is from   src/lib/prettyprint/big/src/out/prettyprint-output-stream.api
	package tt:	Traitful_Text;					# Traitful_Text								is from   src/lib/prettyprint/big/src/traitful-text.api
    )
    : (weak)	Core_Prettyprint_Mill_Types				# Core_Prettyprint_Mill_Types						is from   src/lib/prettyprint/big/src/core-prettyprint-mill-types.api
    {
	package out = out;
	package tt  = tt;

	Left_Margin_Is							# How should we compute the left margin for a box?
	  = BOX_RELATIVE     Int					# Indent left margin relative to left margin of containing box.
	  | CURSOR_RELATIVE  Int					# Set left margin by tabbing from cursor, where tabstops are every 'Int' chars.
	  ;

	Prettyprint_Mill_Configuration_Args				# Futureproofing -- args which code clients can pass to us to customize the prettyprinter.
	  #								# We can add more cases here in future as needed, without breaking backward compatibility.
	  = DEFAULT_TARGET_BOX_WIDTH	Int
	  | DEFAULT_LEFT_MARGIN_IS	Left_Margin_Is
	  | TABSTOPS_ARE_EVERY		Int				# Usually 2.  Effectively 4 because we mostly work in units of two tabstops.
	  ;

	Break_Policy
	  #
	  = NONE							# All on one line -- break never rendered as newline.
	  | ALL								# One line each -- every break rendered as newline.
	  | ALL_OR_NONE							# NONE if it fits, else ALL.
	  | AS_NEEDED							# Normal wordwrap:  break rendered as newline only when necessary.
	  ;

	Prettyprint_Token
	    #
	    = NEWLINE
	    | BOX Box
	    | TAB Int

	    | BREAK Break


	    | TEXT    { string: String,					#  Raw text.  This includes styled_strings.  The 
			length: Int					#  width and texttraits information is taken 
		      }							#  care of when they are inserted in queue. 

	    | ENDTXT  { string: String,					#  Basically a special hack so semicolons can appear
			length: Int					#  at the end of a preceding box instead of getting
		      }							#  a line of their own, which usually we don't want.

	    | PUSH_TEXTTRAITS  out::Texttraits
	    | POP_TEXTTRAITS
	    | CONTROL      (out::Prettyprint_Output_Stream -> Void)	# Device control operation. This provides an escape for ejecting a page or selecting a pen or any other unanticipated stuff.





	withtype
	Break =   { wrap:	Ref Bool,
		    ifnotwrap:	{ tab0:			Int,		# 0 == nop, 1 == move to next tabstop (maybe no motion  ), 2 == move to next even-numbered tabstop (still maybe no motion).   NB: tab0 2 is NOT equivalent to { tab0 1; tab0 1;} !
				  tab:			Int,		# 0 == nop, 1 == move to next tabstop (at least one char), 2 == move to next even-numbered tabstop (at least one char).       NB: tab  2 is NOT equivalent to { tab  1; tab  1;} !
				  text:			String		# Literal text to output. In practice, almost always blanks.
				},	
		    ifwrap:	{ tab0:			Int,			# As above, except cursor starts at left margin.
				  tab:			Int,		# As above, except cursor starts at left margin.
				  text:			String		# Literal text to output. In practice, almost always blanks.
				}
		  }
    # This needs to look something like

    #	    | BREAK   { wrap:		Ref Bool,
    #			ifnotwrap:	{ tab0:		Int,			# Indent i tabstops (no minimum), relative to cursor.
    #					  tab:		Int,			# Indent i tabstops (each at least a space), relative to cursor.
    #					  text:		String			# Maybe print some text.
    #					}
    #			ifwrap: 	{ tab:		Int,			# Indent i tabstops (at least a space), relative to left margin.
    #					  tab0:		Int,			# Indent i tabstops (no minimum), relative to left margin.
    #					  text:		String,			# Maybe print some text.
    #					},
    #		      }

	also
	Box_Format = { name:	String,
			  code:	{ target_width:		Int,
						  box_contents:		List Prettyprint_Token,
						  tabstops_are_every:	Int
						}
						->
						{ actual_box_width:	Int,
						  is_multiline:		Bool
						}
			}

	also
	Box = { left_margin_is:		Left_Margin_Is,				# The left margin for the box is computed by adding an int to either the cursor or the previous left margin.
		target_width:		Int,					# We try to fit box contents into this width. We can break only where allowed (possibly nowhere), so we cannot guarantee success.
		actual_width:		Ref Int,				# Length of contents if newline free, else length of first line.
		id:			Int,					# Unique id number per box.  Only used for debugging/display.
		#
		is_multiline:		Ref Bool,				# TRUE iff there's a NEWLINE somewhere inside.
		contents:		Ref List Prettyprint_Token,		# This is empty until box is closed, after that it == reverse (*reversed_contents).
		reversed_contents:	Ref List Prettyprint_Token,		# We accumulate tokens in this while constructing box, by successively prepending them.
		#
		format:		Box_Format
	      };

	Prettyprint_Mill
	  =
	  {
	    output_stream:		out::Prettyprint_Output_Stream,		# Where to send formatted output.
	    output_stream_is_closed:	Ref( Bool ),				# TRUE iff the stream is closed. 

	    box:			Ref Box,
	    nested_boxes:		Ref (List(Box)),
	    box_nesting:		Ref Int,				# Current depth of 'nested_boxes'. Used only to catch infinite loops.

	    next_box_id:		Ref Int,

	    texttraits_stack:		Ref( List(tt::Texttraits) ),

	    tabstops_are_every:		Int,					# Usually 2 chars, set in multiples of 2 for a mostly tab-every-four system with occasional 'half-tab' settings.
	    default_target_box_width:	Int,
	    default_left_margin_is:	Left_Margin_Is,
	    do_delayed_newline_indent:	Ref(Bool)				# Multiple nested boxes closing tends to produce lots of newline-indentblanks sequences in a row, which manifest as a
	};									# sequence of unexpected blank lines. Ugly! This var lets us collapse each such sequence into a single newline-indentblanks.
    };
end;

## COPYRIGHT (c) 2005 John Reppy (http://www.cs.uchicago.edu/~jhr)
## All rights reserved.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
