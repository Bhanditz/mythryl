## html-prettyprinter-output-stream.pkg
#
# Prettyprinting using HTML markup to control layout.
# Supplying this package as an argument to
#
#     src/lib/prettyprint/big/src/prettyprinter-g.pkg
#
# yields a prettyprinter specialized to format HTML text.
#
# For an overview of prettyprinter output stream functionality see
#
#     src/lib/prettyprint/big/src/out/prettyprinter-output-stream.api
#
# Compare to:
#
#     src/lib/prettyprint/big/src/out/plain-prettyprinter-output-stream.pkg
#     src/lib/prettyprint/big/src/out/ansi-terminal-prettyprinter-output-stream.pkg
#
# This file is current referenced only by 
#     src/lib/prettyprint/big/tests/test-html.pkg
# which is not even compiling.

# Compiled by:
#     src/lib/prettyprint/big/prettyprinting.lib

stipulate
    package has =  html_abstract_syntax;				# html_abstract_syntax				is from   src/lib/html/html-abstract-syntax.pkg
herein

    api Html_Prettyprinter_Output_Stream {
	#
	include Prettyprinter_Output_Stream;				# Prettyprinter_Output_Stream			is from   src/lib/prettyprint/big/src/out/prettyprinter-output-stream.api

	combine_textstyles:  (Textstyle, Textstyle) -> Textstyle;	# Combine two textstyles into one.

	textstyle_none:  Textstyle;					# Unstyled text.

	# Standard HTML text styles:
	#
	textstyle_tt:      Textstyle;
	textstyle_i:       Textstyle;
	textstyle_b:       Textstyle;
	textstyle_u:       Textstyle;
	textstyle_strike:  Textstyle;
	textstyle_em:      Textstyle;
	textstyle_strong:  Textstyle;
	textstyle_dfn:     Textstyle;
	textstyle_code:    Textstyle;
	textstyle_samp:    Textstyle;
	textstyle_kbd:     Textstyle;
	textstyle_var:     Textstyle;
	textstyle_cite:    Textstyle;

	color:  String -> Textstyle;					# Color text (using FONT element).

	# Hyper-text links and anchors:
	#
	link:    String -> Textstyle;
	anchor:  String -> Textstyle;
	link_anchor:  { name:  String, href:  String } -> Textstyle;

	make_markup_buffer:  { wid:  Int, text_wide:  Null_Or( Int ) } -> Prettyprinter_Output_Stream;

	done:  Prettyprinter_Output_Stream -> has::Text;
    };


    package   html_prettyprinter_output_stream
    : (weak)  Html_Prettyprinter_Output_Stream
    {
	Textstyle
	  = NOEMPH
	  | TT
	  | II
	  | BB
	  | UU
	  | STRIKE
	  | EM
	  | STRONG
	  | DFN
	  | CODE
	  | SAMP
	  | KBD
	  | VAR
	  | CITE
	  | COLOR  String
	  | AA  { href:  Null_Or(String),
		  name:  Null_Or(String)
		}
	  | STYS  List(Textstyle)
	  ;

	Prettyprinter_Output_Stream = PRETTYPRINTER_OUTPUT_STREAM
			  { line_wid:		 Int,
			    text_wide:	Null_Or( Int ),
			    emph_stk:	Ref( List( (List(has::Text), Textstyle) ) ) ,
			    txt:		Ref( List(  has::Text ) )
			  };

	fun cur_emph (PRETTYPRINTER_OUTPUT_STREAM { emph_stk, ... } )						# Return the current emphasis.
	    =
	    case *emph_stk
		  []           => NOEMPH;
		 ((_, em) ! r) => em;
	    esac;


	fun pcdata (PRETTYPRINTER_OUTPUT_STREAM { txt, ... }, s)						# Add PCDATA to the text list.
	    =
	    txt := has::PCDATA s ! *txt;

	fun join_txt (PRETTYPRINTER_OUTPUT_STREAM { txt, ... } )						# Replace the sequence of PCDATA elements at the head of the txt list with its concatenation.
	    =
	    f (*txt, [])
	    where
		fun f ([], []) => [];
		    f (has::PCDATA s ! r, l) => f (r, s ! l);
		    f (r, l) => has::PCDATA (string::cat l) ! r;
		end;
	    end;

	fun same_textstyle (s1:  Textstyle, s2)							# Are two textstyles the same? 
	    =
	    s1 == s2;


	fun wrap_textstyle (sty, [], tl')
		=>
		tl';

	    wrap_textstyle (sty, tl, tl')
		=>
		wrap (sty, t) ! tl'
		where
		    fun wrap (NOEMPH,  t) => t;
			wrap (TT,      t) => has::TT t;
			wrap (II,      t) => has::IX t;
			wrap (BB,      t) => has::BX t;
			wrap (UU,      t) => has::UX t;
			wrap (STRIKE,  t) => has::STRIKE t;
			wrap (EM,      t) => has::EM t;
			wrap (STRONG,  t) => has::STRONG t;
			wrap (DFN,     t) => has::DFN t;
			wrap (CODE,    t) => has::CODE t;
			wrap (SAMP,    t) => has::SAMP t;
			wrap (KBD,     t) => has::KBD t;
			wrap (VAR,     t) => has::VAR t;
			wrap (CITE,    t) => has::CITE t;
			wrap (COLOR c, t) => has::FONT { color=>THE c, size=>NULL, content=>t };
			#	
			wrap (AA { name, href }, t)
			    =>
			    has::AX {
			     name, href,
			     rel => NULL, reverse => NULL, title => NULL,
			     content => t
			   };

			wrap (STYS l, t) => list::fold_backward wrap t l;
		    end;

		    t =   case tl
			      [t] => t;
			      _   => has::TEXT_LIST (list::reverse tl);
			  esac;
		end;
	end;

	fun push_textstyle (dev as PRETTYPRINTER_OUTPUT_STREAM { emph_stk, txt, ... }, sty)					# Push a textstyle onto the markup_buffers textstyle stack.
	    =
	    {   emph_stk :=  (join_txt dev, sty) ! *emph_stk;
		txt      :=  [];
	    };

	fun pop_textstyle (PRETTYPRINTER_OUTPUT_STREAM { emph_stk as REF [], ... } )						# Pop a textstyle off the markup_buffers textstyle stack. A pop on an empty textstyle stack is a no-op.
		=>
		();

	    pop_textstyle (dev as PRETTYPRINTER_OUTPUT_STREAM { emph_stk as REF ((tl, sty) ! r), txt, ... } )
		=>
		{   txt := wrap_textstyle (sty, join_txt dev, tl);
		    emph_stk := r;
		};
	end;


	fun default_textstyle _										# The default textstyle for the markup_buffer. This is the current textstyle if the textstyle stack is empty.
	    =
	    NOEMPH;

	fun depth _											# Maximum printing depth (in terms of boxes) 
	    =
	    NULL;

	fun line_width (PRETTYPRINTER_OUTPUT_STREAM { line_wid, ... } )					# The width of the markup_buffer.
	    =
	    THE line_wid;

	fun text_width (PRETTYPRINTER_OUTPUT_STREAM { text_wide, ... } )				# The suggested maximum width of text on a line.
	    =
	    text_wide;

	fun space (dev, n)										# Append some number of spaces to the markup_buffer.
	    =
	    pcdata (dev, cat (list::from_fn (n, fn _ = "&nbsp;")));

	fun newline (dev as PRETTYPRINTER_OUTPUT_STREAM { txt, ... } )					# Append a newline to the markup_buffer.
	    =
	    txt := has::BR { clear=>NULL } ! (join_txt dev);

	# Write a string/character in the current textstyle to the markup_buffer:

	string = pcdata;

	fun char (dev, c)
	    =
	    pcdata (dev, str c);

	fun flush _ = ();
	fun close _ = ();

	fun combine_textstyles (NOEMPH, sty)      =>  sty;
	    combine_textstyles (sty, NOEMPH)      =>  sty;
	    combine_textstyles (STYS l1, STYS l2) =>  STYS (l1 @ l2);
	    combine_textstyles (sty, STYS l)      =>  STYS (sty ! l);
	    combine_textstyles (sty1, sty2)       =>  STYS [sty1, sty2];
	end;

	textstyle_none = NOEMPH;
	textstyle_tt = TT;
	textstyle_i = II;
	textstyle_b = BB;
	textstyle_u = UU;
	textstyle_strike = STRIKE;
	textstyle_em = EM;
	textstyle_strong = STRONG;
	textstyle_dfn = DFN;
	textstyle_code = CODE;
	textstyle_samp = SAMP;
	textstyle_kbd = KBD;
	textstyle_var = VAR;
	textstyle_cite = CITE;
	color = COLOR;

	fun link   s = AA { href=>THE s, name=>NULL  };
	fun anchor s = AA { href=>NULL,  name=>THE s };

	fun link_anchor { name, href }
	    =
	    AA { href=>THE href, name => THE name };

	fun make_markup_buffer { wid, text_wide }
	    =
	    PRETTYPRINTER_OUTPUT_STREAM
	      { txt      => REF [],
		emph_stk => REF [],
		line_wid => wid,
		text_wide
	      };

	fun done (mb as PRETTYPRINTER_OUTPUT_STREAM { emph_stk => REF [], txt, ... } )
		=>
		case (join_txt mb)
		    #              
		    [t] =>   { txt := [];   t; };
		    l   =>   { txt := [];   has::TEXT_LIST (list::reverse l); };
		esac;

	    done _ =>  raise exception FAIL "Unclosed boxes in markup_buffer -- cannot format it.";
	end;

    };	#  html_prettyprinter_output_stream.pkg 
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1997 Bell Labs, Lucent Technologies.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
