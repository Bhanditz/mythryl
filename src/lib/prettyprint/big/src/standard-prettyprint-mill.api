## standard-prettyprint-mill.api
#
# I find the original prettyprinter interface ugly and clumsy;
# this is an attempt to provide something simpler and cleaner.
#
# My idea here is to do
#
#     pp.box 4 .{
#         pp.txt 4 "Various stuff of consequence.\n";
#     };
#
# instead of
#
#     pp::begin_align_4box pp;
#     pp::text          pp "Various";
#     pp::break         pp { spaces=>1; indent_on_wrap=>4 };
#     pp::text          pp "stuff";
#     pp::break         pp { spaces=>1; indent_on_wrap=>4 };
#     pp::text          pp "of";
#     pp::break         pp { spaces=>1; indent_on_wrap=>4 };
#     pp::text          pp "consequence.";
#     pp::newline       pp;
#     pp::shut_box     pp;
#
# approximately.  In particular, I see the former as:
#
#  o  Inherently keeping block open/close pairs matched.
#     (The original code had at least one such bug.)
#
#  o  Reducing clutter by making the 'pp' arguments implicit.
#
#  o  Reducing clutter by allowing newlines, breaks and tabs to be
#     included in strings instead of having to be separate calls.

# Compiled by:
#     src/lib/prettyprint/big/prettyprint-mill.lib

stipulate
    package fil =  file__premicrothread;				# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
herein

    api Standard_Prettyprint_Mill {
	#
	Private_State;

	Left_Margin_Is									# How should we compute the left margin for a box?
	  = BOX_RELATIVE	{ spaces: Int, tab_to: Int, tabstops_are_every: Int }	# Indent left margin relative to left margin of containing box.
	  | CURSOR_RELATIVE	{ spaces: Int, tab_to: Int, tabstops_are_every: Int }	# Set left margin by tabbing from cursor, where tabstops are every 'Int' chars.
	  ;

	Standard_Prettyprint_Mill
	  =
	  { pp:      Private_State,
	    #
	    tabstops_are_every:		Int,	
	    default_target_box_width:	Int,	
	    default_left_margin_is:	Left_Margin_Is,
	    default_box_format:		String,						# It would be nice to have default_box_format: Box_Format here but I think that will produce nasty circularity issues.
	    
	    box:	Int -> Int -> (Void -> Void) -> Void,				# ==   {   pp::open_box  (pp,  pp::pmt::BOX_RELATIVE    { spaces=>i1, tab_to=>i2, tabstops_are_every },  default_box_format  );  thunk();  pp::shut_box pp;  }
	    wrap:    	Int -> Int -> (Void -> Void) -> Void,				# ==   {   pp::open_box  (pp,  pp::pmt::BOX_RELATIVE    { spaces=>i1, tab_to=>i2, tabstops_are_every },  ragged_right	     );  thunk();  pp::shut_box pp;  }
	    cbox:   	Int -> Int -> (Void -> Void) -> Void,				# ==   {   pp::open_box  (pp,  pp::pmt::CURSOR_RELATIVE { spaces=>i1, tab_to=>i2, tabstops_are_every },  default_box_format  );  thunk();  pp::shut_box pp;  }
	    cwrap:    	Int -> Int -> (Void -> Void) -> Void,				# ==   {   pp::open_box  (pp,  pp::pmt::CURSOR_RELATIVE { spaces=>i1, tab_to=>i2, tabstops_are_every },  ragged_right	     );  thunk();  pp::shut_box pp;  }

	    flush:     Void   -> Void,
	    close:     Void   -> Void,

# NEXT FOUR SHOULD TAKE TWO INTS ON THE box MODEL: spaces tab_to
	    cut:	   Int    -> Void,				# 
	    tab:	   Int    -> Void,				# Space over until   (column % tabstops_are_every) == i   where tabstops_are_every defaults to 4.     Guaranteed to move  at least one char.

	    txt:    Int -> String -> Void,				# n blanks == break { spaces => n, indent_on_wrap => i }

	    lit:           String -> Void,				# Output string literally -- no chars receive special treatment.
	    endlit: 	   String -> Void				# Special hack to let ';'s be at end of preceding box instead of on a new line.  Identical to 'lit' except for end-of-box handling.
	  };  

	include Base_Prettyprint_Mill					# Make standard_prettyprint_mill a 100% drop-in replacement for base_prettyprint_mill.
		where Prettyprint_Mill == Standard_Prettyprint_Mill;

	package box: api {						# Type for optional args for open_box().
	    #
	    Arg = LEFT_MARGIN_IS	pmt::Left_Margin_Is
		| WIDTH			Int
		| FORMAT		pmt::Box_Format
		;
	};
									# pp::box is the fully general call to open a formatting box;   pp.box provides a subset of the functionality but more convenience.
	start_box:	Standard_Prettyprint_Mill			# Prettyprint mill -- effectively the buffer into which we're writing prettyprinted text.
			-> List( box::Arg )				# Box width, format etc.
			-> Void						# Possibly someday we should return the box, so that formatters can do stuff like "if box.multiline ... "...?
			;						# Call   end_box pp;   to terminate the box.

	seq:	List(X) -> (X -> Void) -> (Void -> Void) -> Void;	# elements, print_element, print_separator, 
									# A little convenience fn for prettyprinting lists.
	with_standard_prettyprint_mill:    Prettyprint_Output_Stream
					-> List( pmt::Prettyprint_Mill_Configuration_Args )
					-> (Prettyprint_Mill -> Void)
					-> Void
					;

	prettyprint_to_string:	    List( pmt::Prettyprint_Mill_Configuration_Args )
					-> (Prettyprint_Mill -> Void)
					-> String
					;
	make_standard_prettyprint_mill
	    :
	    String
	    -> List( pmt::Prettyprint_Mill_Configuration_Args )
            -> Standard_Prettyprint_Mill;

    };
end;

## Code by Jeff Prothero: Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
