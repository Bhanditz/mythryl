## standard-prettyprint-mill.api
#
# I find the original prettyprinter interface ugly and clumsy;
# this is an attempt to provide something simpler and cleaner.
#
# My idea here is to do
#
#     pp.box .{
#         pp.txt "Various stuff of consequence.\n";
#     };
#
# instead of
#
#     pp::begin_align_4box pp;
#     pp::lit          pp "Various";
#     pp::break         pp { spaces=>1; indent_on_wrap=>4 };
#     pp::lit          pp "stuff";
#     pp::break         pp { spaces=>1; indent_on_wrap=>4 };
#     pp::lit          pp "of";
#     pp::break         pp { spaces=>1; indent_on_wrap=>4 };
#     pp::lit          pp "consequence.";
#     pp::newline       pp;
#     pp::shut_box     pp;
#
# approximately.  In particular, I see the former as:
#
#  o  Inherently keeping block open/close pairs matched.
#     (The original code had at least one such bug.)
#
#  o  Reducing clutter by making the 'pp' arguments implicit.
#
#  o  Reducing clutter by allowing newlines, breaks and tabs to be
#     included in strings instead of having to be separate calls.
#
####################################################################################3
# Pending work:
#
# We'll probably eventually want s
#
#     pp.parens .{ ... };
#
# so that we can do two optimizations:
#
#     (foo)         ->   foo
#     ((foo, bar))  ->  (foo, bar)
#
# These are inherently contextual -- hard
# to impossible to do in per-rule logic,
# but easy to do in the core pp logic.
#
# If we haven't already done so, we should probably(?) move this
# library into standard.lib so we can use it pervasively for
# error messages and such.  Since error-message.pkg apparently
# uses us, something of the sort must already have been done...?
#
# We should have environment variables
#
#    MYTHRYL_SHOW_PRETTYPRINT_BOXTREE      # If set, we display the boxtree
#    MYTHRYL_SHOW_PRETTYPRINT_OPS          # If set, we show the op-by-op trace
#    MYTHRYL_SHOW_PRETTYPRINT_RULES        # If set, we print rulenames in the output
#
# We will need corresponding flags in core-prettyprint-mill-g.pkg,
# set via its interface.
#
# I've added a 'rulename: Ref(String),' field to boxes, set by a
# new   pp.rulename "T1";   command, initialized to the empty string.
#
# Next up is to add  pp.rulename  calls through the major files.
#
# Then, if MYTHRYL_SHOW_PRETTYPRINT_RULES is set, we should print
#     (sprintf "[%s.%d[ " *box.name box.id) 
#     (sprintf " ]%s.%d]" *box.name box.id) 
# at respectively the start and end of a rule, thus embedding
# rule names in the prettyprint output and allowing sane
# debugging of odd-looking prettyprinter output.
#
#
# In the long run, likely(?) everyone depending on base-prettyprint-mill-g.pkg
# should be eliminated or recoded to use standard-prettyprint-mill-g.pkg,
# and then base-prettyprint-mill-g.pkg eliminated.
#
#
# We should try to find some way to disentangle the circular near-dependencies
# in the prettyprint-mill stuff to allow cleaner code. 
# FOR EXAMPLE, what if we eliminated
# core-prettyprint-mill.api, which isn't used, and
# base-prettyprint-mill.api, which shouldn't really exist, and rewrote
# standard-prettyprint-mill.api as a standalone iterface file...?
#
#
####################################################################################3



# Compiled by:
#     src/lib/prettyprint/big/prettyprint-mill.lib

stipulate
    package fil =  file__premicrothread;				# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
herein

    api Standard_Prettyprint_Mill {
	#
	Private_State;

	Left_Margin_Is									# How should we compute the left margin for a box?
	  = BOX_RELATIVE	{ spaces: Int, tab_to: Int, tabstops_are_every: Int }	# Indent left margin relative to left margin of containing box.
	  | CURSOR_RELATIVE	{ spaces: Int, tab_to: Int, tabstops_are_every: Int }	# Set left margin by tabbing from cursor, where tabstops are every 'Int' chars.
	  ;

	Standard_Prettyprint_Mill
	  =
	  { pp:      Private_State,
	    #
	    tabstops_are_every:		Int,						# This section records the prettyprint mill configuration for client reference.
	    default_target_box_width:	Int,						#
	    default_left_margin_is:	Left_Margin_Is,					#
	    default_box_format:		String,						# It would be nice to have   default_box_format: Box_Format   here but I think that will produce nasty circularity issues.
	    
	    box':	Int -> Int ->	(Void -> Void) -> Void,				# ==   {   pp::open_box  (pp,  pp::pmt::BOX_RELATIVE    { spaces=>i1, tab_to=>i2, tabstops_are_every },  default_box_format  );  thunk();  pp::shut_box pp;  }
	    wrap':    	Int -> Int ->	(Void -> Void) -> Void,				# ==   {   pp::open_box  (pp,  pp::pmt::BOX_RELATIVE    { spaces=>i1, tab_to=>i2, tabstops_are_every },  ragged_right	     );  thunk();  pp::shut_box pp;  }
	    cbox':   	Int -> Int ->	(Void -> Void) -> Void,				# ==   {   pp::open_box  (pp,  pp::pmt::CURSOR_RELATIVE { spaces=>i1, tab_to=>i2, tabstops_are_every },  default_box_format  );  thunk();  pp::shut_box pp;  }
	    cwrap':    	Int -> Int ->	(Void -> Void) -> Void,				# ==   {   pp::open_box  (pp,  pp::pmt::CURSOR_RELATIVE { spaces=>i1, tab_to=>i2, tabstops_are_every },  ragged_right	     );  thunk();  pp::shut_box pp;  }

	    box:			(Void -> Void) -> Void,				# ==   {   pp::open_box  (pp,  pp::pmt::BOX_RELATIVE    { spaces=>i1, tab_to=>i2, tabstops_are_every },  default_box_format  );  thunk();  pp::shut_box pp;  }
	    wrap:    			(Void -> Void) -> Void,				# ==   {   pp::open_box  (pp,  pp::pmt::BOX_RELATIVE    { spaces=>i1, tab_to=>i2, tabstops_are_every },  ragged_right	     );  thunk();  pp::shut_box pp;  }
	    cbox:   			(Void -> Void) -> Void,				# ==   {   pp::open_box  (pp,  pp::pmt::CURSOR_RELATIVE { spaces=>i1, tab_to=>i2, tabstops_are_every },  default_box_format  );  thunk();  pp::shut_box pp;  }
	    cwrap:			(Void -> Void) -> Void,				# ==   {   pp::open_box  (pp,  pp::pmt::CURSOR_RELATIVE { spaces=>i1, tab_to=>i2, tabstops_are_every },  ragged_right	     );  thunk();  pp::shut_box pp;  }

	    flush:     Void   -> Void,
	    close:     Void   -> Void,

# Work remaining:
# 1) start_box
# 2) seq
#
	    tab:    Void		 -> Void,					# 
	    cut:    Void		 -> Void,					# 

	    tab':   Int -> Int		 -> Void,					# Emit 'spaces' blanks, then additional blanks until (column % tabstops_are_every) == tab_to.
	    cut':   Int -> Int		 -> Void,					# If wrapped, emit newline, space to left margin of current box, then do save as above.

	    txt:    		  String -> Void,					# Abbreviation for pp.txt'' 1 0 <string>.
	    txt':   Int -> Int -> String -> Void,					# n blanks == break { spaces => n, indent_on_wrap => i }

	    lit:           String -> Void,						# Output string literally -- no chars receive special treatment.
	    endlit: 	   String -> Void,						# Special hack to let ';'s be at end of preceding box instead of on a new line.  Identical to 'lit' except for end-of-box handling.

	    newline:	   Void -> Void,

	    rulename:	   String -> Void
	  };  

	include Base_Prettyprint_Mill							# Make standard_prettyprint_mill a 100% drop-in replacement for base_prettyprint_mill.
		where Prettyprint_Mill == Standard_Prettyprint_Mill;

	package box: api {								# Type for optional args for open_box().
	    #
	    Arg = LEFT_MARGIN_IS	pmt::Left_Margin_Is
		| WIDTH			Int
		| FORMAT		pmt::Box_Format
		;
	};
											# pp::box is the fully general call to open a formatting box;   pp.box provides a subset of the functionality but more convenience.
	start_box:	Standard_Prettyprint_Mill					# Prettyprint mill -- effectively the buffer into which we're writing prettyprinted text.
			-> List( box::Arg )						# Box width, format etc.
			-> Void								# Possibly someday we should return the box, so that formatters can do stuff like "if box.multiline ... "...?
			;								# Call   end_box pp;   to terminate the box.

	seq:	List(X) -> (X -> Void) -> (Void -> Void) -> Void;			# elements, print_element, print_separator, 
											# A little convenience fn for prettyprinting lists.
	with_standard_prettyprint_mill:    Prettyprint_Output_Stream
					-> List( pmt::Prettyprint_Mill_Configuration_Args )
					-> (Prettyprint_Mill -> Void)
					-> Void
					;

	prettyprint_to_string:	    List( pmt::Prettyprint_Mill_Configuration_Args )
					-> (Prettyprint_Mill -> Void)
					-> String
					;
	make_standard_prettyprint_mill
	    :
	    String
	    -> List( pmt::Prettyprint_Mill_Configuration_Args )
            -> Standard_Prettyprint_Mill;

    };
end;

## Code by Jeff Prothero: Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
