## standard-prettyprint-mill-g.pkg
#

# Compiled by:
#     src/lib/prettyprint/big/prettyprint-mill.lib


stipulate
    package fil =  file__premicrothread;					# file__premicrothread							is from   src/lib/std/src/posix/file--premicrothread.pkg
herein

    generic package   standard_prettyprint_mill_g   (				#
	#             ===========================
	#									# "tt" == "traitful text"
	package tt:	Traitful_Text;						# Traitful_Text								is from   src/lib/prettyprint/big/src/traitful-text.api
	package out:    Prettyprint_Output_Stream;				# Prettyprint_Output_Stream						is from   src/lib/prettyprint/big/src/out/prettyprint-output-stream.api
										# out will be something like html_prettyprint_output_stream		   from   src/lib/prettyprint/big/src/out/html-prettyprint-output-stream.pkg
	sharing tt::Texttraits == out::Texttraits;
    )
#   : (weak)  Standard_Prettyprint_Mill						# Standard_Prettyprint_Mill						is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.api
    {
	package pp
	    =
	    base_prettyprint_mill_g (						# base_prettyprint_mill_g						is from   src/lib/prettyprint/big/src/base-prettyprint-mill-g.pkg
		#
		package tt  =  tt;						# traitless_text							is from   src/lib/prettyprint/big/src/traitless-text.pkg
		package out =  out;
	    );
	package pmt = pp::pmt;

	horizontal		=  pp::horizontal;						# The four precoded box-formatting styles.
	vertical		=  pp::vertical;
	normal			=  pp::normal;
	ragged_right		=  pp::ragged_right;

	Prettyprint_Mill_Configuration_Args ==  pp::pmt::Prettyprint_Mill_Configuration_Args;

	Private_State = pp::Prettyprint_Mill;

	Standard_Prettyprint_Mill
	  =
	  { pp:			Private_State,
	    #
	    box:		Int -> (Void -> Void) -> Void,
	    wrap:		Int -> (Void -> Void) -> Void,
	    horizontal:		Int -> (Void -> Void) -> Void,
	    vertical:		Int -> (Void -> Void) -> Void,

	    cbox:		(Void -> Void) -> Void,
	    cwrap:		(Void -> Void) -> Void,
	    chorizontal:	(Void -> Void) -> Void,
	    cvertical:		(Void -> Void) -> Void,

	    flush:		Void -> Void,
	    close:		Void -> Void,

	    cut:		Int    -> Void,
	    tab:		Int    -> Void,
	    tab0:		Int    -> Void,

	    lit:		String -> Void,
	    endlit:		String -> Void,

	    txt:	Int ->	String -> Void
	  };  
	Prettyprint_Mill = Standard_Prettyprint_Mill;
	Pp               = Standard_Prettyprint_Mill;

	fun prettyprint_open_box (pp:Pp, left_margin_is, box_format)
	    =
	    pp::prettyprint_open_box (pp.pp, left_margin_is, box_format);


	fun make_prettyprint_mill  prettyprint_output_stream   args
	    =
	    {   pp =   pp::make_prettyprint_mill  prettyprint_output_stream  args;
		#
		fun box        i thunk =   { pp::begin_indented_align_box      pp (pp::pmt::BOX_RELATIVE { spaces => 0, tab_to => i, tabstops_are_every => 4 } );   thunk();   pp::end_box pp; };
		fun wrap       i thunk =   { pp::begin_indented_wrap_box       pp (pp::pmt::BOX_RELATIVE { spaces => 0, tab_to => i, tabstops_are_every => 4 } );   thunk();   pp::end_box pp; };
		fun horizontal i thunk =   { pp::begin_indented_horizontal_box pp (pp::pmt::BOX_RELATIVE { spaces => 0, tab_to => i, tabstops_are_every => 4 } );   thunk();   pp::end_box pp; };
		fun vertical   i thunk =   { pp::begin_indented_vertical_box   pp (pp::pmt::BOX_RELATIVE { spaces => 0, tab_to => i, tabstops_are_every => 4 } );   thunk();   pp::end_box pp; };

		fun cbox         thunk =   { pp::begin_align_cbox              pp;    thunk();   pp::end_box pp;   };
		fun cwrap        thunk =   { pp::begin_wrap_cbox               pp;    thunk();   pp::end_box pp;   };
		fun chorizontal  thunk =   { pp::begin_horizontal_cbox         pp;    thunk();   pp::end_box pp;   };
		fun cvertical    thunk =   { pp::begin_vertical_cbox           pp;    thunk();   pp::end_box pp;   };

		fun flush ()           =   { pp::flush_prettyprint_mill  pp;   out::flush prettyprint_output_stream; };
		fun close ()           =   { pp::close_prettyprint_mill  pp;   out::close prettyprint_output_stream; };

		fun cut   i            =   { pp::break  pp  { spaces => 0,  indent_on_wrap => i };		   };
		fun tab   i            =   { pp::tab    pp i;							   };
		fun tab0  i            =   { pp::tab0   pp i;							   };



		##############################################################################
		#                       lit / put / pu4
		#
		# The idea with put/pu4 is to replace
		# explicit calls to pp::break, pp::tab and pp::newline
		# with embedded ' '  '\t'  '\n'  chars:
		#
		#   lit:   Entire string output literally with no special character treatments.
		#   txt0:  '\t'                 treated as pp::tab 4
		#	   '\n'                 treated as pp::newline
		#          n blanks             treated as pp::break { spaces => n, indent_on_wrap => 0 }
		#   txt4:  Same, except indent_on_wrap for blanks is 4.
		# 
		# The expectation is that:
		#   txt0:  Will typically be used to format short statements in a line box.
		#   txt4:   Will typically be used to wrap individual words in a wrap box.
		# In the former case, one usually wants wrapped lines to be aligned,  hence the 'indent_on_wrap => 0'
		# In the latter case, one usually wants wrapped lines to be indented, hence the 'indent_on_wrap => 4'
		##############################################################################


		fun lit    string =  pp::text   pp string;
		fun endlit string =  pp::endtxt pp string;


		fun txt' pp_string indent string
		    = 
		    next 0
		    where
			len =   size string;

			fun next i
			    =
			    if (i < len)
				#
				c =  string::get (string, i);

				case c
				    '\t' =>  do_tab     i;
				    '\n' =>  do_newline i;
				    ' '  =>  do_spaces (i, i+1);
				     _   =>  do_other  (i, i+1);
				esac;
			    fi

			also
			fun do_tab  i							# Treat each \t in 'string' as a call to pp:tab 4.
			    =
			    {    pp::tab pp 4;
				 next (i+1);
			    }

			also
			fun do_newline  i						# Treat each \n in 'string' as a call to pp:newline.
			    =
			    {    pp::newline pp;
				 next (i+1);
			    }

			also
			fun do_spaces  (i, j)						# Treat a run of 'n' blanks in 'string' as a call to pp:break { spaces => n, indent_on_wrap => 4 }.
			    =
			    {
				if (j >= len)
				    #
				    pp::break  pp  { spaces => j-i,  indent_on_wrap => indent };
				else
				    c =  string::get (string, j);

				    if (c == ' ')
					#
					do_spaces (i, j+1);				# Scan to end of string of blanks.
				    else
					pp::break  pp  { spaces => j-i,  indent_on_wrap => 4 };
					next j;
				    fi;
				fi;
			    }

			also 								# Treat literally a run of non-\n, non-\t, non-blank chars in 'string'.
			fun do_other (i, j)
			    =
			    if (j >= len)
				#
				pp_string pp (string::substring (string, i, j-i));
			    else
				c =  string::get (string, j);

				if  (c != ' '
				and  c != '\t'
				and  c != '\n'
				)
				     do_other (i, j+1);					# Scan to end of string of vanilla characters.
				else
				     substring =  string::substring (string, i, j-i);
				     pp_string pp substring;
				     next j;
				fi;
			    fi;
		    end;								# fun output

		txt    = txt' pp::text;


		{ pp,
		   box,   wrap, horizontal,  vertical,					# These six should collapse to just box and box' I think.
		  cbox, cwrap, chorizontal, cvertical,
		  flush, close,
		  cut,
		  tab, tab0,
		  lit, endlit,
		  txt
		};  
	    };


	##################################################################################################
	# Backward compatibility stuff to make standard_prettyprint_mill a 100% drop-in replacement for base_prettyprint_mill:

	Prettyprint_Output_Stream	=  pp::Prettyprint_Output_Stream;
	Traitful_Text			=  pp::Traitful_Text;
	Texttraits			=  pp::Texttraits;
	Left_Margin_Is			== pp::pmt::Left_Margin_Is;

	fun flush_prettyprint_mill		(pp:Pp)		=  pp::flush_prettyprint_mill		pp.pp;
	fun close_prettyprint_mill		(pp:Pp)		=  pp::close_prettyprint_mill		pp.pp;

	fun begin_horizontal_4box		(pp:Pp)		=  pp::begin_horizontal_4box		pp.pp;
	fun begin_vertical_4box			(pp:Pp)		=  pp::begin_vertical_4box		pp.pp;
	fun begin_align_4box			(pp:Pp)		=  pp::begin_align_4box			pp.pp;
	fun begin_wrap_4box			(pp:Pp)		=  pp::begin_wrap_4box			pp.pp;

	fun begin_horizontal_0box		(pp:Pp)		=  pp::begin_horizontal_0box		pp.pp;
	fun begin_vertical_0box			(pp:Pp)		=  pp::begin_vertical_0box		pp.pp;
	fun begin_align_0box			(pp:Pp)		=  pp::begin_align_0box			pp.pp;
	fun begin_wrap_0box			(pp:Pp)		=  pp::begin_wrap_0box			pp.pp;

	fun begin_horizontal_cbox		(pp:Pp)		=  pp::begin_horizontal_cbox		pp.pp;
	fun begin_vertical_cbox			(pp:Pp)		=  pp::begin_vertical_cbox		pp.pp;
	fun begin_align_cbox			(pp:Pp)		=  pp::begin_align_cbox			pp.pp;
	fun begin_wrap_cbox			(pp:Pp)		=  pp::begin_wrap_cbox			pp.pp;

	fun begin_indented_horizontal_box	(pp:Pp) i	=  pp::begin_indented_vertical_box	pp.pp i;
	fun begin_indented_vertical_box		(pp:Pp) i	=  pp::begin_indented_vertical_box	pp.pp i;
	fun begin_indented_align_box		(pp:Pp) i	=  pp::begin_indented_align_box		pp.pp i;
	fun begin_indented_wrap_box		(pp:Pp) i	=  pp::begin_indented_wrap_box		pp.pp i;

	fun horizontal_4box			(pp:Pp) f	=  pp::horizontal_4box			pp.pp f;
	fun vertical_4box			(pp:Pp) f	=  pp::vertical_4box			pp.pp f;
	fun align_4box				(pp:Pp) f	=  pp::align_4box			pp.pp f;
	fun wrap_4box				(pp:Pp) f	=  pp::wrap_4box			pp.pp f;

	fun horizontal_0box			(pp:Pp) f	=  pp::horizontal_0box			pp.pp f;
	fun vertical_0box			(pp:Pp) f	=  pp::vertical_0box			pp.pp f;
	fun align_0box				(pp:Pp) f	=  pp::align_0box			pp.pp f;
	fun wrap_0box				(pp:Pp) f	=  pp::wrap_0box			pp.pp f;

	fun horizontal_cbox			(pp:Pp) f	=  pp::horizontal_cbox			pp.pp f;
	fun vertical_cbox			(pp:Pp) f	=  pp::vertical_cbox			pp.pp f;
	fun align_cbox				(pp:Pp) f	=  pp::align_cbox			pp.pp f;
	fun wrap_cbox				(pp:Pp) f	=  pp::wrap_cbox			pp.pp f;

	fun end_box				(pp:Pp)		=  pp::end_box				pp.pp;

	fun traitful_text			(pp:Pp) s	=  pp::traitful_text			pp.pp s; 
	fun text				(pp:Pp) s	=  pp::text				pp.pp s; 
	fun endtxt				(pp:Pp) s	=  pp::endtxt				pp.pp s; 

	fun push_texttraits			(pp:Pp,ts)	=  pp::push_texttraits		       (pp.pp,ts);		
	fun pop_texttraits			(pp:Pp)		=  pp::pop_texttraits		        pp.pp;

	fun break				(pp:Pp) a	=  pp::break				pp.pp a;
	fun space				(pp:Pp) i	=  pp::space				pp.pp i;
	fun cut					(pp:Pp)		=  pp::cut				pp.pp;
	fun newline				(pp:Pp)		=  pp::newline				pp.pp;
	fun nonbreakable_spaces			(pp:Pp) i	=  pp::nonbreakable_spaces		pp.pp i;
	fun tab					(pp:Pp) i	=  pp::tab				pp.pp i;
	fun tab0				(pp:Pp) i	=  pp::tab0				pp.pp i;
	fun control				(pp:Pp) f	=  pp::control				pp.pp f;

	fun nblanks					i	=  pp::nblanks				      i;

	fun get_prettyprint_output_stream	(pp:Pp)		=  pp::get_prettyprint_output_stream	pp.pp;

	fun with_standard_prettyprint_mill  output_stream  pp_args  (f: Prettyprint_Mill -> Void)		# Compared to the make_standard_prettyprint_mill() approach, this
	    =													# approach makes it harder to forget to flush+close the prettyprinter.
	    {   pp =   make_prettyprint_mill  output_stream  pp_args;
		#
		f pp;

		close_prettyprint_mill  pp;
	    };


	fun seq elements print_element separator
	    =
	    print_elements  elements
	    where
		fun print_elements [element]
			=>
			print_element element;

		    print_elements (element ! rest)
			=>
			{   print_element  element;
			    separator ();
			    print_elements rest;
			};

		    print_elements [] =>   ();
		end;
	    end;





	# End of backward compatibility stuff.
	##################################################################################################

    };											# package standard_prettyprint_mill
end;



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Code by Jeff Prothero: Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
