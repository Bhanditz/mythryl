## prettyprint-mill-lib-unit-test.pkg

# Compiled by:
#     src/lib/test/unit-tests.lib

# Run by:
#     src/lib/test/all-unit-tests.pkg

stipulate
    package pp  =  standard_prettyprint_mill;				# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    Pp = pp::Pp;
herein

    package prettyprint_mill_lib_unit_test {
	#
	include unit_test;						# unit_test			is from   src/lib/src/unit-test.pkg
	include makelib::scripting_globals;

	name =  "src/lib/prettyprint/big/src/test/prettyprint-mill-lib-unit-test.pkg";

	fun prettyprint_to_string pp_args prettyprint_fn
	    = 
	    pp::prettyprint_to_string pp_args prettyprint_fn;

	fun pp_sequence  pp
	      (
		separator:	pp::Prettyprint_Mill -> Void,
		print_one,
		elements
	      )
	    =
	    pr_elements  elements
	    where
		fun pr_elements [el]
			=>
			print_one  pp el;

		    pr_elements (el ! rest)
			=>
			{   print_one  pp  el;
			    separator  pp;
			    pr_elements rest;
			};

		    pr_elements [] =>   ();
		end;
	    end;

	fun pp_closed_sequence
		pp
		{ front:	pp::Prettyprint_Mill -> Void,
		  separator:	pp::Prettyprint_Mill -> Void,
		  back:		pp::Prettyprint_Mill -> Void,
		  print_one:	pp::Prettyprint_Mill -> X -> Void
		}
		(elems: List(X))
	    =
	    {   pp::begin_indented_align_box pp  (pp::pmt::BOX_RELATIVE { spaces => 0, tab_to => 0, tabstops_are_every => 4 });
		front pp;
		pp::begin_align_4box pp;
		pp_sequence pp (separator, print_one, elems); 
		pp::end_box pp;
		back pp;
		pp::end_box pp;
	    };

	fun test_basic_prettyprinter_operation  ()
	    =
	    {
		Expression
		  = VARIABLE    String
		  | INT         Int
		  | BINOP  	Binop
		  | LIST	List( Expression )

		also
		Statement
		  = ASSIGNMENT  { lhs:	    Expression,
				  rhs:	    Expression
				}
		  | BLOCK       List( Statement )

		withtype
		Binop
		  =
		  { op:	     String,
		    left:    Expression,
		    right:   Expression
		  };

		statement_1 =   BLOCK [
				    ASSIGNMENT { lhs => VARIABLE "alpha",
						 rhs => LIST  [ VARIABLE "beta",
								LIST [ INT 123, INT 456, INT 789 ],
								BINOP { op    => "+",
									left  =>  VARIABLE "gamma",
									right =>  INT 131
								      }
							      ]
					       },

				    ASSIGNMENT { lhs => VARIABLE "omega",
						 rhs => LIST  [ VARIABLE "lambda",
								LIST [ INT 987, INT 654, INT 321 ],
								BINOP { op    => "+",
									left  =>  VARIABLE "chi",
									right =>  INT 187
								      }
							      ]
					       }
				];

		fun pp_expression (pp:Pp, x: Expression)
		    =
		    case x
			#
			VARIABLE s			=>  pp.lit s;
			INT      i			=>  pp.lit (sprintf "%d" i);
			#
			BINOP { op, left, right }	=>  {   pp.box 0 .{
								    pp.lit "(";
								    pp_expression (pp, left);
								    pp.txt 0 (sprintf " %s " op);
								    pp_expression (pp, right);
								    pp.endtxt 0 ")";
								};
							    };
			LIST xs				=>  {   pp.box 2 .{
								    pp.box 0 .{
									pp.lit "[ ";
									pp.box 2 .{
									    pp::seq  xs   .{ pp_expression (pp, #x); }   .{ pp.endtxt 0 ", "; };
									    pp.txt 0 " ";
									};
									pp.lit "]";
								    };
								};
							    };
		    esac;

		fun pp_statement (pp:Pp, s: Statement)
		    =
		    case s
			#
			ASSIGNMENT { lhs, rhs } 	=>  {   pp.box 0 .{
								    pp_expression (pp, lhs);
								    pp.txt 4 " = ";
								    pp.cwrap .{
									pp_expression (pp, rhs);
									pp.endtxt 0 ";";
								    };
								};
							    };
			BLOCK xs			=>  {   pp.box 0 .{
								    pp.lit "{ ";
								    pp.box 4 .{
									pp::seq   xs   .{ pp_statement (pp, #x); }   .{ pp.txt 0 "   "; };
								    };
								    pp.lit "}";
								};
							    };
		    esac;


		assert ("test"   ==   (prettyprint_to_string [] (fn pp = { pp::text pp "test"; })));

		fun ps s i
		    =
		    printf "\ns%03d:\nvvvvvvvv\n%s\n^^^^^^^\n" i s;

		saved = *log::debugging;
		log::debugging := TRUE;

		s120 =  prettyprint_to_string  [ pp::pmt::DEFAULT_TARGET_BOX_WIDTH  120 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s120 120;
		s100 =  prettyprint_to_string  [ pp::pmt::DEFAULT_TARGET_BOX_WIDTH  100 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s100 100;
		s060 =  prettyprint_to_string  [ pp::pmt::DEFAULT_TARGET_BOX_WIDTH   60 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s060  60;
		s030 =  prettyprint_to_string  [ pp::pmt::DEFAULT_TARGET_BOX_WIDTH   30 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s030  30;
		s015 =  prettyprint_to_string  [ pp::pmt::DEFAULT_TARGET_BOX_WIDTH   15 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s015  15;
		s007 =  prettyprint_to_string  [ pp::pmt::DEFAULT_TARGET_BOX_WIDTH    7 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s007   7;
		s003 =  prettyprint_to_string  [ pp::pmt::DEFAULT_TARGET_BOX_WIDTH    3 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s003   3;
		s001 =  prettyprint_to_string  [ pp::pmt::DEFAULT_TARGET_BOX_WIDTH    1 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s001   1;

		log::debugging := saved;

		assert TRUE;
	    };


	fun run ()
	    =
	    {   printf "\nDoing %s:\n" name;   
		#
		test_basic_prettyprinter_operation  ();

		summarize_unit_tests  name;
	    };
    };
end;
