## prettyprint-mill-lib-unit-test.pkg

# Compiled by:
#     src/lib/test/unit-tests.lib

# Run by:
#     src/lib/test/all-unit-tests.pkg

stipulate
    package pp  =  standard_prettyprint_mill;				# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    Pp = pp::Pp;
herein

    package prettyprint_mill_lib_unit_test {
	#
	include unit_test;						# unit_test			is from   src/lib/src/unit-test.pkg
	include makelib::scripting_globals;

	name =  "src/lib/prettyprint/big/src/test/prettyprint-mill-lib-unit-test.pkg";

	fun prettyprint_to_string pp_args prettyprint_fn
	    = 
	    pp::prettyprint_to_string pp_args prettyprint_fn;


	fun test_basic_newline_handling  ()
	    =
	    {
		# This is basically whitebox testing.  Getting
		#     group_tokens_into_lines()
		#     flatten_lines_back_to_tokens()
		# to handle newlines correctly took some fiddling.
		# Check that it hasn't gotten broken somehow:

		r = prettyprint_to_string [] .{
		    pp = #pp;
		};
		assert (r == "");

		s = prettyprint_to_string [] .{
		    pp = #pp;

		    pp.lit "abc"; 
		    pp.lit " "; 
		    pp.lit "def"; 
		};
		assert (s == "abc def");

		t = prettyprint_to_string [] .{
		    pp = #pp;

		    pp.lit "abc"; 
		    pp.lit " "; 
		    pp.lit "def"; 
		    pp.newline ();
		};
		assert (t == "abc def\n");


		u = prettyprint_to_string [] .{
		    pp = #pp;

		    pp.lit "abc"; 
		    pp.lit " "; 
		    pp.lit "def"; 
		    pp.newline ();
		    pp.lit "ghi"; 
		    pp.lit " "; 
		    pp.lit "jkl"; 
		};
		assert (u == "abc def\nghi jkl");

		v = prettyprint_to_string [] .{
		    pp = #pp;

		    pp.lit "abc"; 
		    pp.lit " "; 
		    pp.lit "def"; 
		    pp.newline ();
		    pp.lit "ghi"; 
		    pp.lit " "; 
		    pp.lit "jkl"; 
		    pp.newline ();
		};
		assert (v == "abc def\nghi jkl\n");

		w = prettyprint_to_string [] .{
		    pp = #pp;

		    pp.newline ();
		    pp.lit "abc"; 
		    pp.lit " "; 
		    pp.lit "def"; 
		    pp.newline ();
		    pp.lit "ghi"; 
		    pp.lit " "; 
		    pp.lit "jkl"; 
		    pp.newline ();
		};
		assert (w == "\nabc def\nghi jkl\n");

		x = prettyprint_to_string [] .{
		    pp = #pp;

		    pp.newline ();
		    pp.lit "abc"; 
		    pp.lit " "; 
		    pp.lit "def"; 
		    pp.newline ();
		    pp.lit "ghi"; 
		    pp.lit " "; 
		    pp.lit "jkl"; 
		};
		assert (x == "\nabc def\nghi jkl");

		y = prettyprint_to_string [] .{
		    pp = #pp;

		    pp.newline ();
		    pp.lit "abc"; 
		    pp.lit " "; 
		    pp.lit "def"; 
		};
		assert (y == "\nabc def");

		z = prettyprint_to_string [] .{
		    pp = #pp;

		    pp.newline ();
		};
		assert (z == "\n");
	    };


	fun test_basic_prettyprinter_operation  ()
	    =
	    {
		Expression
		  = VARIABLE    String
		  | INT         Int
		  | BINOP  	Binop
		  | LIST	List( Expression )

		also
		Statement
		  = ASSIGNMENT  { lhs:	    Expression,
				  rhs:	    Expression
				}
		  | BLOCK       List( Statement )

		withtype
		Binop
		  =
		  { op:	     String,
		    left:    Expression,
		    right:   Expression
		  };

		statement_1 =   BLOCK [
				    ASSIGNMENT { lhs => VARIABLE "alpha",
						 rhs => LIST  [ VARIABLE "beta",
								LIST [ INT 123, INT 456, INT 789 ],
								BINOP { op    => "+",
									left  =>  VARIABLE "gamma",
									right =>  INT 131
								      }
							      ]
					       },

				    ASSIGNMENT { lhs => VARIABLE "omega",
						 rhs => LIST  [ VARIABLE "lambda",
								LIST [ INT 987, INT 654, INT 321 ],
								BINOP { op    => "+",
									left  =>  VARIABLE "chi",
									right =>  INT 187
								      }
							      ]
					       }
				];

		fun pp_expression (pp:Pp, x: Expression)
		    =
		    case x
			#
			VARIABLE s			=>  pp.lit s;
			INT      i			=>  pp.lit (sprintf "%d" i);
			#
			BINOP { op, left, right }	=>  {   pp.box' 0 0 .{ 										pp.rulename "b2";
								    pp.lit "(";
								    pp_expression (pp, left);
								    pp.txt' 0 -1 (sprintf " %s " op);
								    pp_expression (pp, right);
								    pp.endlit ")";
								};
							    };
			LIST xs				=>  {   pp.box' 0 2 .{ 										pp.rulename "b3";
								    pp.lit "[ ";
								    pp.ind();
								    pp::seq .{ pp.txt ", "; }  .{ pp_expression (pp, #x); }  xs;
#								    pp.txt' 0 -1 " ";
								    pp.exd();
								    pp.lit "]";
								};
							    };
		    esac;

		fun pp_statement (pp:Pp, s: Statement)
		    =
		    case s
			#
			ASSIGNMENT { lhs, rhs } 	=>  {   pp.box' 0 0 .{ 										pp.rulename "b4";
								    pp_expression (pp, lhs);
								    pp.lit " ";
								    pp.ind(); 
								    pp.txt "= ";
								    pp_expression (pp, rhs);
								    pp.endlit ";";
								};
							    };
			BLOCK xs			=>  {   pp.box' 0 0 .{ 										pp.rulename "b5";
								    pp.lit "{ ";
								    pp.box' 4 0 .{ 									pp.rulename "b5b";
									pp::seq  .{ pp.txt' 0 -1 "   "; }  .{ pp_statement (pp, #x); }   xs;
								    };
								    pp.lit "}";
								};
							    };
		    esac;


		assert ("test"   ==   (prettyprint_to_string [] (fn pp = { pp::lit pp "test"; })));

		fun ps s i
		    =
		    printf "\ns%03d:\nvvvvvvvv\n%s\n^^^^^^^\n" i s;

#		saved = *log::debugging;
#		log::debugging := TRUE;

		s120 =  prettyprint_to_string  [ pp::typ::DEFAULT_TARGET_BOX_WIDTH  120 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s120 120;
		s100 =  prettyprint_to_string  [ pp::typ::DEFAULT_TARGET_BOX_WIDTH  100 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s100 100;
		s060 =  prettyprint_to_string  [ pp::typ::DEFAULT_TARGET_BOX_WIDTH   60 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s060  60;
		s050 =  prettyprint_to_string  [ pp::typ::DEFAULT_TARGET_BOX_WIDTH   50 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s050  50;
		s030 =  prettyprint_to_string  [ pp::typ::DEFAULT_TARGET_BOX_WIDTH   30 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s030  30;
		s015 =  prettyprint_to_string  [ pp::typ::DEFAULT_TARGET_BOX_WIDTH   15 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s015  15;
		s007 =  prettyprint_to_string  [ pp::typ::DEFAULT_TARGET_BOX_WIDTH    7 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s007   7;
		s003 =  prettyprint_to_string  [ pp::typ::DEFAULT_TARGET_BOX_WIDTH    3 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s003   3;
		s001 =  prettyprint_to_string  [ pp::typ::DEFAULT_TARGET_BOX_WIDTH    1 ]    (fn pp =  pp_statement  (pp, statement_1));	ps s001   1;

#		log::debugging := saved;

		assert TRUE;
	    };


	fun run ()
	    =
	    {   printf "\nDoing %s:\n" name;   
		#
		test_basic_newline_handling  ();
		test_basic_prettyprinter_operation  ();

		summarize_unit_tests  name;
	    };
    };
end;
