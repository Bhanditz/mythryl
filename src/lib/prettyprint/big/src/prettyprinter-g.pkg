## prettyprinter-g.pkg
#
# The core engine for the system prettyprinter.
#
# See ../README.
#
# Concise overview:
#
# -> The only purpose of the prettyprinter is to decide where
#    to put newlines, whitespace and indentation.
#
# -> The prettyprinter views its input stream as consisting
#    of known-width 'styled_strings' containing the useful text to be
#    printed, and of 'breaks', which mark places where it is
#    allowed to insert a newline.
#
# -> The desired structure is represented as a set of nested
#    'boxes', where a box essentially indicates the newline
#    insertion policy to be followed for some stretch of text.
#      Each box also has some default indentation for each line,
#    which will typically increase with box nesting level.
#
# -> The simplest box type is 'h' (horizontal)', in which
#    breaks are -never- converted to newlines.
#
# -> The next simplest box type is 'v' (vertical)', in which
#    breaks are -always- converted to newlines.
#
# -> The 'line' box type is slightly more sophisticated:  It
#    behaves as an 'h' box if the result will fit on a line,
#    else as a v box:  In simple cases, this results in the
#    styled_strings in the box all being placed in a line, either
#    horizontal or vertical.  In an line box, either all the
#    breaks produce newlines, or else none do.
#
# -> The 'wrap' box type is the most commonly used, and implements
#    the familiar word-wrap algorithm:  A break produces a newline
#    iff this is required to keep the line length within width limits.
#
## 2007-09-10 CrT: Completely rewritten.  Twice. ;-)
#
# See also:
#     src/lib/prettyprint/big/src/prettyprint-stream-g.pkg

# Compiled by:
#     src/lib/prettyprint/big/prettyprint.lib



# This generic does not currently appear to be invoked anywhere. <---



#               "The difference between the true hacker
#                and the mere power user is that the
#                limits of what a power user can achieve
#                are set by his tools, but the hacker is
#                master of his tools, and lives in a
#                world without limits.
#
#               "Every true hacker is necessarily a compiler
#                hacker at need, as well as an editor hacker,
#                kernel hacker, and so forth.
#
#               "True hackers are a rare breed.  For every
#                one of them, you will find a thousand
#                power users posing as hackers, more often
#                than not without even realizing the difference."



stipulate
    package fil =  file__premicrothread;					# file__premicrothread	is from   src/lib/std/src/posix/file--premicrothread.pkg
    package l2s =  list_to_string;						# list_to_string							is from   src/lib/src/list-to-string.pkg
herein

    generic package   prettyprinter_g   (					# 
	#             ===============
	#									# "ss" == "styled string"
	package ss:	Styled_String;						# Styled_String								is from   src/lib/prettyprint/big/src/styled-string.api
	package out:    Prettyprinter_Output_Stream;				# Prettyprinter_Output_Stream						is from   src/lib/prettyprint/big/src/out/prettyprinter-output-stream.api
										# out will be something like html_prettyprinter_output_stream		   from   src/lib/prettyprint/big/src/out/html-prettyprinter-output-stream.pkg
	sharing ss::Textstyle == out::Textstyle;
    )
    : (weak)
    api {
	include Prettyprinter;							# Prettyprinter								is from   src/lib/prettyprint/big/src/prettyprinter.api

	dump:  (fil::Output_Stream, Prettyprinter)
		  ->
		  Void;
    }
    {
	Prettyprinter_Output_Stream  =  out::Prettyprinter_Output_Stream;	# Handles device-specific aspects of writing to ansi terminal, plain ascii stream, html stream or whatever.
	Textstyle      =  ss::Textstyle;					# Text attributes like color, underline, blink etc.
	Styled_String  =  ss::Styled_String;					# A Styled_String contains a String plus whatever Textstyle information is required to render it in HTML or on an ansi terminal or whatever.

	Indent = BOX_RELATIVE     Int						# Indent relative to enclosing box.
	       | CURSOR_RELATIVE  Int						# Indent relative to where box starts on current line.      
	       ;

	Prettyprint_Token
	    #
	    = TEXT { string: String,
		     length: Int
		   }
										#  Raw text.  This includes styled_strings.  The 
										#  width and textstyle information is taken 
										#  care of when they are inserted in queue. 

	    | NONBREAKABLE_SPACES  Int						#  Some number of non-breakable spaces 
	    | PUSH_TEXTSTYLE  Textstyle
	    | POP_TEXTSTYLE
	    | NEWLINE
	    | CONTROL  (Prettyprinter_Output_Stream -> Void)				# Device control operation 
	    | BOX Box
	    | LINE (List Prettyprint_Token)
	    | BREAK   { wrap:		Ref Bool,
			spaces:		Int,
			indent_on_wrap:	Int
		      }


	also
	Wrap_Policy
	    #
	    = NONE							# All on one line -- break never rendered as newline.
	    | ALL							# One line each -- every break rendered as newline.
	    | ALL_OR_NONE						# NONE if it fits, else ALL.
	    | AS_NEEDED							# Normal wordwrap:  break rendered as newline only when necessary.

	withtype
	Box = { indent:			Indent,
		width:			Int,				# We try to fit box contents into this width.
		wrap_policy:		Wrap_Policy,
		id:			Int,				# Unique id number per box.  Only used for debugging/display.
		#
		length_of_first_line:   Ref Int,			# Length of contents if newline free, else length of first line.
		length_of_final_line:   Ref Int,			# Length of contents if newline free, else length of last line (zero if box contents end with newline)
		has_newlines:		Ref Bool,			# TRUE iff there's a NEWLINE somewhere inside.
		contents:		Ref List Prettyprint_Token
	      };



									# We build up a prettyprint expression as a tree
									# of nested_boxes until we are flushed, at which
									# point we actually format and print it.
									#
									# At any given time, the currently open box is 'box',
									# the one enclosing it is first in the nested_boxes
									# list, and the root of the box tree is last in the
									# nested_boxes list.  (Keeping the top of the stack
									# in a separate variable lets us communicate to the
									# type system that we always have at least one box
									# on the stack, and thus avoid a lot of spurious
									# checks for stack-empty.)
									#
									# We don't actually use the textstyle_stack
									# for anything in this module -- it is
									# purely an opaque-to-us customer
									# convenience:


	Prettyprinter
	    =
	    PRETTYPRINTER
	      {
		output_stream:                   Prettyprinter_Output_Stream,		# The underlying device 
		output_stream_is_closed:         Ref( Bool ),		# TRUE iff the stream is closed. 

		box:           Ref Box,
		nested_boxes:  Ref (List Box),
		box_nesting:   Ref Int,				# Current depth of 'nested_boxes'. Used only to catch infinite loops.

		next_box_id:   Ref Int,

		textstyle_stack:   Ref( List(Textstyle) )
	    };



	max_box_nesting =   1000;					# Purely to catch prettyprint infinite recursions. 

	exception  PRETTYPRINT_MAX_DEPTH_EXCEEDED;			# Raised when above is exceeded;

	default_box_width = 60;					# There is currently no way to change box widths.


	# *** DEBUGGING FUNCTIONS ***

	package f = sfprintf;					# sfprintf	is from   src/lib/src/sfprintf.pkg

	fun wrap_policy_to_string NONE        =>  "NONE";
	    wrap_policy_to_string ALL         =>  "ALL";
	    wrap_policy_to_string ALL_OR_NONE =>  "ALL_OR_NONE";
	    wrap_policy_to_string AS_NEEDED   =>  "AS_NEEDED";
	end;


	fun indent_to_string (BOX_RELATIVE    n) =>  cat ["BOX_RELATIVE ",    int::to_string n];
	    indent_to_string (CURSOR_RELATIVE n) =>  cat ["CURSOR_RELATIVE ", int::to_string n];
	end;




	fun dump (out_stream, PRETTYPRINTER stream)		# Prettyprint out_stream contents for debugging.
	    =
	    {   print  "BEGIN\n";
		#
		printf' (
		    "box_nesting = %3d\n",
		    [   f::INT *stream.box_nesting
		    ]
		);

		print   "Expression:\n";

		case *stream.nested_boxes
		    #
		    [] => print_box *stream.box "";
		    x  => case (reverse x)
			      #
			      bot ! rest => print_box bot "";
			      _          => raise exception FAIL "impossible";
			  esac;
		esac;

		print "\n";

		print  ("END\n");
	    }
	    where
		fun print string
		    =
		    fil::write (out_stream, string);


		fun printf' (format, items)
		    =
		    print (f::sprintf' format items);


    #	    fun format_box_stack_element_to_string (wrap_policy, box_indent, box_width)
    #		=
    #		f::sprintf'   "(%s, %d, %d)"   [f::STR (wrap_policy_to_string  wrap_policy), f::INT box_indent, f::INT box_width];


		fun print_list format_element []
			=>
			print "[]";

		    print_list format_element my_list
			=>
			print (
			    l2s::list_to_string'
				#
				{ first     => "[\n    ",
				  last      => "]",
				  between   => "\n    ",
				  to_string => format_element
				}
				#
				my_list
			);
		end;

		fun print_box   (box as { id, indent, width, length_of_first_line, length_of_final_line, has_newlines, wrap_policy, contents })   prefix
		    =
		    {   print (prefix + "Box");
			print ("   id = "			+ (int::to_string id));
			print ("   indent = "		+ (indent_to_string indent));
			print ("   width = "		+ (int::to_string width));
			print ("   length_of_first_line = " + (int::to_string *length_of_first_line));
			print ("   length_of_final_line = " + (int::to_string *length_of_final_line));
			print ("   has_newlines = "		+ (*has_newlines ?? "TRUE" :: "FALSE"));
			print ("   wrap_policy = "		+ (wrap_policy_to_string  wrap_policy));
			print ("   contents len = "		+ (int::to_string (list::length *contents)));
			print  ":\n";

			print_styled_strings  *contents  (prefix + "    ")
			where
			    fun print_styled_strings [] _
				    =>
				    ();

				print_styled_strings  (styled_string ! rest)  prefix
				    =>
				    {   case styled_string
					    #
					    TEXT { string, length }
						=>
						print (prefix + "TEXT (" + (int::to_string length) + ") '" + string + "'\n");

					    NONBREAKABLE_SPACES  int
						=>
						print (prefix + "NONBREAKABLE_SPACES " + (int::to_string int) + "\n");

					    BREAK  { wrap,   spaces,   indent_on_wrap }
						=>
						{   print (prefix + "BREAK");
						    print ("   wrap = "    + (*wrap ?? "TRUE" :: "FALSE"));
						    print ("   spaces = "  + (int::to_string spaces));
						    print ("   indent_on_wrap = "  + (int::to_string indent_on_wrap));
						    print  "\n";
						};

					    PUSH_TEXTSTYLE _ => print (prefix + "PUSH_TEXTSTYLE ...\n");
					    POP_TEXTSTYLE    => print (prefix + "POP_TEXTSTYLE\n");
					    NEWLINE      => print (prefix + "NEWLINE\n");
					    CONTROL _    => print (prefix + "CONTROL ...\n");

					    BOX box      => {   print (prefix + "BOX:\n");
								print_box  box  (prefix + "    "); 
							    };

					    LINE styled_strings  => {   print (prefix + "LINE");
								print ("   length = "  + (int::to_string (list::length styled_strings)));
								print  ":\n";
								print_styled_strings  styled_strings  (prefix + "    "); 
							    };
					esac;

					print_styled_strings  rest  prefix;
				    };
			    end;				# fun print_styled_strings
			end;				# where
		    };

	    end;



	# *** UTILITY FUNCTIONS ***

	too_long =  8888;   # A box-length value picked to be large
			    # enough to not fit in any plausible box,
			    # but small enough that adding a few
			    # together won't produce integer overflow.


	# Output functions 
	fun write_newline (PRETTYPRINTER { output_stream, ... }   ) =  out::newline output_stream;
	fun write         (PRETTYPRINTER { output_stream, ... }, s) =  out::string (output_stream, s);



	fun blanks (_,                      0) =>   ();
	    blanks (PRETTYPRINTER { output_stream, ... }, n) =>   out::space (output_stream, n);
	end;


	fun current_textstyle (PRETTYPRINTER { textstyle_stack => REF (textstyle ! _),    ... } ) =>  textstyle;						# Current textstyle is the top entry on the textstyle stack,
	    current_textstyle (PRETTYPRINTER { textstyle_stack => REF [], output_stream,  ... } ) =>  out::default_textstyle output_stream;		# or else the default textstyle if the stack is empty:
	end;



	# Break up the 'contents' list of styled_strings in a box
	# into LINEs terminated by NEWLINE styled_strings
	# (except perhaps for the last):

	fun make_lines  stream   (box as { contents, id,  wrap_policy, has_newlines, width, indent, length_of_first_line, length_of_final_line })
	    =
	    {   box_lines = make_lines'  (
				*contents,
				[],			# styled_strings
				[]			# lines
			    );
		box.contents :=   box_lines;  
	    }
	    where
		fun make_lines'  ([],  styled_strings,  lines)
			=>
			reverse (LINE (reverse styled_strings) ! lines);

		    make_lines'  (styled_string ! rest,  styled_strings,  lines)
			=>
			case styled_string
			    #
			    NEWLINE =>  {
					    styled_strings =   reverse (styled_string ! styled_strings);
					    make_lines'  (rest,  /*styled_strings=*/ [],   LINE styled_strings ! lines);
					};

			    BOX box =>  {   box_contents
						=
						make_lines'  (
						    *box.contents,
						    [],			# styled_string accumulator
						    []			# line  accumulator
						);

					    box.contents     :=   box_contents;

					    make_lines'  (
						rest,
						styled_string          !  styled_strings,
						lines
					    );
					};

			    LINE _ =>   {   print "Internal error: LINE in make_lines' input?!\n";
					    dump (fil::stdout, stream);
#						raise exception FAIL "Internal error: LINE in make_lines' input";
					    make_lines'  (rest,  styled_strings,  lines);
					};

			    _   =>      {
					    make_lines'  (rest,  styled_string ! styled_strings,  lines);
					};
			esac;
		end; 
	    end



	# Given the list of styled_strings in a LINE,
	# wrap either all BREAKs or none of them.
	#
	# Any embedded boxes have already been
	# wrap_box()'d, so they have valid values
	# of length_of_first_line, length_of_final_line and has_newlines.
	#

	also
	fun wrap_all_or_none  (
		width,		# Current box width
		styled_strings,		# List of styled_strings in current line.
		column,		# Current column, relative to box left margin
		wrap_policy		# One of ALL, NONE, ALL_OR_NONE
	    )
	    =
	    {
		line_has_newlines    =  REF FALSE;
		length_of_first_line =  REF -1;
		#
		wrap_them		# Should we change all BREAKs to newlines, or none or them?
		    =
		    case wrap_policy
			#
			ALL  =>  TRUE;
			NONE =>  FALSE;

			ALL_OR_NONE
			    =>
			    {   unwrapped_length
				    =
				    total_length (styled_strings, 0)
				    where
					fun total_length ([], result) => result;
					    total_length (((TEXT                { length, ... }) ! rest), result) =>   total_length (rest, result +  length);
					    total_length (((NONBREAKABLE_SPACES   n            ) ! rest), result) =>   total_length (rest, result +  n     );
					    total_length (((BREAK               { spaces, ... }) ! rest), result) =>   total_length (rest, result +  spaces);

					    total_length (((BOX { length_of_first_line, has_newlines, ... }) ! rest), result)
						=>
						if *has_newlines	too_long;
						else		total_length (rest, result + *length_of_first_line);
						fi;

					    total_length ((_ ! rest), result)
						=>
						total_length (rest, result);
					end;
				    end;

				if  (unwrapped_length > width   )   TRUE;
							       else   FALSE;   fi;
			    };

			AS_NEEDED => raise exception FAIL "wrap_all_or_none: wrap_policy == AS_NEEDED!?";
		    esac;


		fun per_token ([], column) =>   column;
		    #
		    per_token (styled_string ! rest, column)
			=>
			case styled_string
			    #
			    BREAK  { wrap, spaces, indent_on_wrap, ... }
				=>
				if wrap_them
				    #
				    if   (*length_of_first_line == -1   )   length_of_first_line := column;   fi;
				    wrap := TRUE;
				    line_has_newlines := TRUE;
				    per_token  (rest, indent_on_wrap);
				else
				    per_token  (rest, column + spaces);
				fi;

			    NEWLINE =>  {   if   (*length_of_first_line == -1)   length_of_first_line := column;   fi;
					    line_has_newlines := TRUE;
					    per_token  (rest, 0);
					};

			    TEXT { length, ... }  =>   per_token  (rest, column + length        );
			    NONBREAKABLE_SPACES n =>   per_token  (rest, column + n             );
			    PUSH_TEXTSTYLE _      =>   per_token  (rest, column                 );
			    POP_TEXTSTYLE         =>   per_token  (rest, column                 );
			    CONTROL _             =>   per_token  (rest, column                 );

			    BOX { length_of_final_line, indent, ... }
				=>
				case indent
				    #
				    BOX_RELATIVE    i =>    per_token  (rest, *length_of_final_line + i         );
				    CURSOR_RELATIVE i =>    per_token  (rest, *length_of_final_line + i + column);
				esac;

			    LINE _  =>  raise exception FAIL "per_token: LINE within line?!";
			esac;
		end;							# fun per_token

		column =   per_token (styled_strings, column);

		if (*length_of_first_line == -1)   length_of_first_line := column;   fi;

		(*length_of_first_line, column, *line_has_newlines);
	    }								# fun wrap_all_or_none


	# Here we implement a conventional word-wrap
	# textstyle algorithm where we wrap a line at
	# a BREAK iff it is our last chance to avoid
	# exceeding our assigned box width.

	also
	fun wrap_as_needed  (box_width, styled_strings, column)
	    =
	    {
		line_has_newlines = REF FALSE;
		length_of_first_line = REF -1;



		# To decide whether to wrap a line at a break point,
		# we must compute whether this is our last chance to
		# avoid exceeding our allowed box width, which involves
		# computing the text length from this BREAK to the
		# next BREAK or NEWLINE (or end of styled_string list).
		# That's our job here:

		fun forced_follow_on  styled_strings
		    =
		    forced_follow_on'  (styled_strings, 0)
		    where 
			fun forced_follow_on'  ([], column)
				=>
				column;

			    forced_follow_on'  (styled_string ! rest,  column)
				=>
				case styled_string
				    #
				    TEXT { length, ... }
					=>
					forced_follow_on'  (rest,  column + length);

				    NONBREAKABLE_SPACES n
					=>
					forced_follow_on'  (rest,  column + n);

				    (PUSH_TEXTSTYLE _ | POP_TEXTSTYLE | CONTROL _)
					=>
					forced_follow_on'  (rest,  column);

				    (NEWLINE | BREAK _)
					=>
					column;

				    BOX { length_of_first_line, has_newlines, ... }
					=>
					# If a box contains newlines, then 'length_of_first_line'
					# is the length of its first line, and we've
					# reached the end of our forced follow-on,
					# otherwise 'length_of_first_line' is the total box
					# length, and we need to keep on iterating:

					if *has_newlines
					    #
					    column + *length_of_first_line;
					else
					    forced_follow_on'  (rest,  column + *length_of_first_line);
					fi;

				    LINE _ =>   {   /*raise exception FAIL*/ print "Internal error: forced_follow_on styled_string is a LINE?!\n";
						    column;
						};
				esac;
			end;			# fun forced_follow_on'
		end;				# fun forced_follow_on


		# Scan the tokens in a LINE setting
		# BREAKs to wrap as appropriate.

		fun per_token  ([], column)
			=>
			column;

		    per_token  (styled_string ! rest,   column)
			=>
			case styled_string
			    #
			    (PUSH_TEXTSTYLE _
			    | POP_TEXTSTYLE
			    | CONTROL _)          =>   per_token( rest,   column          );
			    TEXT { length, ... }  =>   per_token( rest,   column + length );
			    NONBREAKABLE_SPACES n =>   per_token( rest,   column + n      );

			    NEWLINE
				=>
				{   line_has_newlines :=  TRUE;
				    per_token( rest, /*column=*/ 0 );
				};

			    BREAK  { wrap, spaces, indent_on_wrap }
				=>
				{
				    # If next BREAK or NEWLINE
				    # would be beyond right margin
				    # of box, then we need to wrap:

				    if   (column  +  spaces  +  forced_follow_on rest  >  box_width)

					 if   (*length_of_first_line == -1   )   length_of_first_line := column;   fi;
					 wrap := TRUE;
					 line_has_newlines :=  TRUE;
					 per_token( rest, /*column=*/ indent_on_wrap);
				    else
					 per_token( rest,   column + spaces );
				    fi;
				};

			    BOX (box as { id, length_of_first_line, indent, length_of_final_line, ... })
				=>
				{   column =    case indent
						    #
						    BOX_RELATIVE    i =>   *length_of_final_line + i;
						    CURSOR_RELATIVE i =>   *length_of_final_line + i + column;
						esac;

				    per_token (rest, column);
				};

			    LINE _ =>   {   /*raise exception FAIL*/ print "Internal error: wrap_all_or_none styled_string is a LINE?!\n";
					    per_token( rest,   column );
					};
			esac;

		end;		# fun per_token

		column =   per_token (styled_strings, column);

		if   (*length_of_first_line == -1)   length_of_first_line := column;   fi;

		(*length_of_first_line, column, *line_has_newlines);
	    }											# fun wrap_as_needed

	also
	fun wrap_line  (width, styled_strings, column, wrap_policy)
	    =
	    case wrap_policy
		#
		AS_NEEDED  =>  wrap_as_needed   (width, styled_strings, column );
		_          =>  wrap_all_or_none (width, styled_strings, column, wrap_policy );
	    esac

	also
	fun wrap_box {
		box as { id, indent, width, length_of_first_line, length_of_final_line, has_newlines, wrap_policy, contents },
		column
	    }
	    =
	    {   # Start by recursively wrapping all sub-boxes
		# of this box.  When this is done, we know for
		# each subbox whether it contains newlines (which
		# may be either NEWLINEs or BREAKs which wrapped)
		# and also the lengths of its first and last lines:
		#
		{	per_line *contents
		    where
			fun per_line  ((LINE styled_strings) ! rest)
				=>
				{    per_token styled_strings;
				     per_line  rest;
				};
			    per_line  (_ ! rest) =>   raise exception FAIL "wrap_subboxes_lines: Non-LINE arg?!";
			    per_line        []   =>   ();
			end

			also
			fun per_token  ((BOX box) ! rest)
				=>
				{   wrap_box { box, column => 0};
				    per_token  rest;
				};
			    per_token (_ ! rest) =>   per_token  rest;
			    per_token       []   =>   ();
			end;
		    end;
		};

		# With the wrap decisions for our sub-boxes all
		# made, we now have enough information in hand
		# to make those decisions for our own box:

		per_line  (*contents, /*column=*/0, /*first_line=*/ TRUE)
		where
		    fun per_line ([], column, first_line)
			    =>
			    ();

			per_line (line ! rest,  column, first_line)
			    =>
			    {   case line
				    #
				    LINE styled_strings
					=>
					{   (wrap_line (width, styled_strings, column, wrap_policy ))
						->
						(initial_line_length, last_line_length, line_has_newlines);

					    if first_line      length_of_first_line :=  initial_line_length;   fi;

					    length_of_final_line :=  last_line_length;		# Gets overwritten unless this -is- the last LINE.
					    has_newlines :=  (*has_newlines or line_has_newlines);
					};

				    _   =>  {   /*raise exception FAIL*/ print "Internal error: per_line arg wasn't a LINE\n";
						();
					    };
				esac;

				per_line (rest,  column, /*first_line=*/ FALSE);
			    };
		    end;
		end;
	    }						# fun wrap_box


	also
	fun print_lines (
		box,
		column,		# 0-based column relative to output_stream (not box!) left margin
		left_margin,	# Left margin of current box.
		stream
	    )
	    =
	    {   box ->   { indent, width, wrap_policy, contents, ... };
		#
		left_margin =   case indent
				    #
				    BOX_RELATIVE    i =>   left_margin + i;
				    CURSOR_RELATIVE i =>   column      + i;
				esac;

		per_line (*contents, column)
		where
		    fun per_token ([], column)
			    =>
			    column;

			per_token  (styled_string ! rest, column)
			    =>
			    case styled_string
				#
				TEXT { length, string }
				    =>
				    {   write (stream, string);
					per_token( rest, column + length );
				    };

				NONBREAKABLE_SPACES n
				    =>
				    {   blanks (stream, n);
					per_token( rest, column + n );
				    };

				BREAK { wrap, spaces, indent_on_wrap }
				    =>
				    if *wrap

					 column = left_margin + indent_on_wrap;
					 write_newline stream;
					 blanks (stream, column);
					 per_token( rest, column );
				    else
					 blanks  (stream, spaces);
					 per_token( rest, column + spaces );
				    fi;

				NEWLINE
				    =>
				    {   column = left_margin;
					write_newline stream;
					blanks (stream, column);
					per_token( rest, column );
				    };


				BOX box
				    =>
				    {   column =  print_lines (box, column, left_margin, stream );
					per_token( rest, column );
				    };


				PUSH_TEXTSTYLE textstyle
				    =>
				    {   stream ->   PRETTYPRINTER { output_stream, ... };
					out::push_textstyle (output_stream, textstyle);
					per_token( rest, column );
				    };


				POP_TEXTSTYLE
				    =>
				    {   stream ->   PRETTYPRINTER { output_stream, ... };
					out::pop_textstyle output_stream;
					per_token( rest, column );
				    };


				CONTROL control_fn
				    =>
				    {   stream ->   PRETTYPRINTER { output_stream, ... };
					control_fn output_stream;
					per_token( rest, column );
				    };

				LINE _ =>   {   /*raise exception FAIL*/ print "Internal error: per_token encountered LINE within LINE styled_string list\n";
						per_token( rest, column );
					    };
			    esac;
		    end;				# fun per_token

		    fun per_line  ([], column)
			    =>
			    column;

			per_line  (line ! rest, column)
			    =>
			    case line
				#
				LINE tokens
				    =>
				    {   column =  per_token  (tokens, column);
					per_line  (rest, column);
				    };

				_   =>
				    {   /*raise exception FAIL*/ print "Internal error: per_line arg wasn't a LINE\n";
					per_line  (rest, column);
				    };
			    esac;
		    end;
		end;
	    };				# fun print_lines




	# Here's the heart of the module.
	# We prettyprint in four passes:
	# 1) Build up the box tree -- complete by the time we get here.
	# 2) Break the contents of each box up into
	#    NEWLINE-delimited lines, and precompute box lengths:   make_lines
	# 3) Decide which breaks to wrap (change to newlines):      wrap_box
	# 4) Print the result out:                                  print_lines

	fun prettyprint_box (stream, box)
	    =
	    {   make_lines   stream   box;
		wrap_box             { box,   column => 0};
		print_lines          (box,   /*column=*/ 0,   /*left_margin=*/    0,   stream    );
	    };




	#  Add a styled_string to the contents of currently-open box:

	fun add_token (PRETTYPRINTER { box => REF box, ... }, styled_string)
	    =
	    {   box -> { contents, ... };
		#
		contents :=   styled_string ! *contents;
	    };


	fun add_string (stream, string, length)
	    =
	    add_token (stream, TEXT { string, length } );



	fun prettyprint_open_box (prettyprinter as PRETTYPRINTER { box, nested_boxes, box_nesting, next_box_id, /*uneeded*/  output_stream, output_stream_is_closed, textstyle_stack }, indent, wrap_policy)
	    =
	    {   id = *next_box_id;
		#
		next_box_id := id + 1;

		new_box							# Set up empty record for new box.
		    =
		    { indent,
		      wrap_policy,
		      width             => default_box_width,
		      id,

		      has_newlines      => REF FALSE,
		      length_of_first_line => REF 0,
		      length_of_final_line => REF 0,
		      contents          => REF []
		    };


		# Add new child box to contents
		# of previously open box: 
		{   (*box) ->   { contents, ... }; 
		    #
		    contents :=   BOX new_box  !  *contents;
		}; 

		nested_boxes :=   *box ! *nested_boxes;			# Push currently open box on stack.
		box_nesting  :=   *box_nesting + 1;			# Remember new stack depth.
		box          :=   new_box;				# Establish new (empty) currently-open box. 


		if (*box_nesting > max_box_nesting)			# Catch prettyprint infinite loops.
		     raise exception     PRETTYPRINT_MAX_DEPTH_EXCEEDED;
		fi;
	    };



	fun prettyprint_end_box (prettyprinter as  PRETTYPRINTER {  nested_boxes as REF [], ... } )
		=>
		{   /*raise exception FAIL*/ print "User error: Attempted to close nonexistent box!";
		    ();
		};

	    prettyprint_end_box (prettyprinter as  PRETTYPRINTER { nested_boxes as REF (topbox ! rest),
						       box as REF { contents, ... },
						       box_nesting,
						       ...
						     }
		)
		=>
		{   # We've accumulated the box contents
		    # in reverse order.  Now that we're
		    # done accumulating stuff for this
		    # box, put the contents in their
		    # proper order:

		    contents     :=   reverse *contents;


		    # Pop box stack:
		    box          :=   topbox;
		    nested_boxes :=   rest;
		    box_nesting  :=   *box_nesting - 1;
		};
	end;


	fun prettyprint_break  (prettyprinter as PRETTYPRINTER { box as REF { contents, ... }, ... },  { spaces, indent_on_wrap } )
	    =
	    contents :=   (BREAK { spaces,  indent_on_wrap,  wrap => REF FALSE } )
			  !
			  *contents;


	fun prettyprint_newline (prettyprinter as PRETTYPRINTER { box as REF { contents, ... }, ... })
	    =
	    contents :=   NEWLINE ! *contents;


	fun prettyprint_flush (prettyprinter as PRETTYPRINTER { box, nested_boxes, output_stream, next_box_id, ... }, with_newline)
	    =
	    {   end_boxes ()
		where
		    fun end_boxes ()
			=
			case *nested_boxes
			    #
			    [] =>						# NB: To avoid special cases, we always leave one box on the stack.
				{
				    (*box) ->    { contents, length_of_first_line, length_of_final_line, has_newlines, ... };

				    contents :=   reverse *contents;		# Box contents accumulate in reverse order.
										# Normally we correct for this by reversing
										# the contents list when we close a box, but
										# the root box never gets closed, so we have
										# to reverse the contents here, right before
										# prettyprinting them.

				    prettyprint_box (prettyprinter, *box);	# Prettyprint outermost box.
										# This is where all the actual formatting work gets done.

				    contents		 :=  [];		# Clear out the prettyprint stuff, so
				    length_of_first_line :=  0;			# we don't wind up printing it again. 
				    length_of_final_line :=  0;
				    has_newlines	 :=  FALSE;
				    next_box_id		 :=  1;
				};

			    topbox ! rest
				=>
				{   prettyprint_end_box  prettyprinter;
				    end_boxes ();
				};
			esac; 
		end;

		if with_newline      write_newline  prettyprinter;   fi;

		out::flush output_stream;
	    };


	# *** USER FUNCTIONS ***

	fun make_prettyprinter d
	    =
	    PRETTYPRINTER
	      {
		output_stream           =>  d,
		output_stream_is_closed =>  REF FALSE,

		textstyle_stack  =>  REF [],
		box_nesting      =>  REF 0,
		next_box_id      =>  REF 1,
		nested_boxes     =>  REF [],
		box              =>  REF  { indent		=>   BOX_RELATIVE 0,
					    width		=>   default_box_width,
					    wrap_policy		=>   AS_NEEDED,
					    id			=>       0,
					    length_of_first_line=>   REF 0,
					    length_of_final_line=>   REF 0,
					    has_newlines	=>   REF FALSE,
					    contents		=>   REF []
					  }
	    };


	fun flush_prettyprinter  prettyprinter
	    =
	    prettyprint_flush (prettyprinter, FALSE);


	fun close_prettyprinter (prettyprinter as PRETTYPRINTER { output_stream_is_closed, output_stream, ... } )
	    =
	    {   flush_prettyprinter  prettyprinter;
		#
		output_stream_is_closed :=  TRUE;
	    };


	fun get_output_stream (PRETTYPRINTER { output_stream, ... } )
	    =
	    output_stream;


	fun begin_horizontal_box			prettyprinter		=  prettyprint_open_box (prettyprinter,  BOX_RELATIVE 4, NONE);
	fun begin_vertical_box				prettyprinter		=  prettyprint_open_box (prettyprinter, (BOX_RELATIVE 4), ALL);
	fun begin_horizontal_else_vertical_box		prettyprinter		=  prettyprint_open_box (prettyprinter, (BOX_RELATIVE 4), ALL_OR_NONE);
	fun begin_wrap_box				prettyprinter		=  prettyprint_open_box (prettyprinter, (BOX_RELATIVE 4), AS_NEEDED);
	fun begin_wrap'_box				prettyprinter		=  prettyprint_open_box (prettyprinter, (BOX_RELATIVE 4), AS_NEEDED);

	fun begin_indented_vertical_box			prettyprinter indent	=  prettyprint_open_box (prettyprinter, indent, ALL);
	fun begin_indented_horizontal_else_vertical_box	prettyprinter indent	=  prettyprint_open_box (prettyprinter, indent, ALL_OR_NONE);
	fun begin_indented_wrap_box			prettyprinter indent	=  prettyprint_open_box (prettyprinter, indent, AS_NEEDED);
	fun begin_indented_wrap'_box			prettyprinter indent	=  prettyprint_open_box (prettyprinter, indent, AS_NEEDED);

	fun end_box   prettyprinter 
	    =
	    prettyprint_end_box   prettyprinter;

	fun horizontal_box			prettyprinter thunk =   { begin_horizontal_box			prettyprinter;   thunk();   end_box prettyprinter; };
	fun vertical_box    			prettyprinter thunk =   { begin_vertical_box			prettyprinter;   thunk();   end_box prettyprinter; };
	fun horizontal_else_vertical_box	prettyprinter thunk =   { begin_horizontal_else_vertical_box	prettyprinter;   thunk();   end_box prettyprinter; };
	fun wrap_box				prettyprinter thunk =   { begin_wrap_box			prettyprinter;   thunk();   end_box prettyprinter; };
	fun wrap'_box				prettyprinter thunk =   { begin_wrap'_box			prettyprinter;   thunk();   end_box prettyprinter; };


	fun styled_string (prettyprinter as PRETTYPRINTER { output_stream, ... } ) styled_string
	    =
	    {   styled_string_textstyle =  ss::textstyle styled_string;
		#
		if (out::same_textstyle (current_textstyle prettyprinter, styled_string_textstyle))
		    #
		    add_string (prettyprinter, ss::string styled_string, ss::size styled_string);
		else
		    add_token  (prettyprinter, PUSH_TEXTSTYLE styled_string_textstyle);
		    add_string (prettyprinter, ss::string styled_string, ss::size styled_string);
		    add_token  (prettyprinter, POP_TEXTSTYLE);
		fi;
	    };


	fun string prettyprinter s
	    =
	    add_string (prettyprinter, s, size s);


	fun push_textstyle (prettyprinter as PRETTYPRINTER { textstyle_stack, ... }, sty)
	    =
	    {   if (not (out::same_textstyle (current_textstyle prettyprinter, sty)))
		    #
		    add_token (prettyprinter, PUSH_TEXTSTYLE sty);
		fi;

		textstyle_stack :=   sty ! *textstyle_stack;
	    };


	fun pop_textstyle (prettyprinter as PRETTYPRINTER { textstyle_stack, ... } )
	    =
	    case *textstyle_stack
		#
		[] => {  /*raise exception FAIL*/ print "User error: pp: unmatched pop_textstyle\n";
		      };

		(sty ! rest)
		    =>
		    {   textstyle_stack := rest;
			#
			if (not (out::same_textstyle (current_textstyle prettyprinter, sty)))
			    #
			    add_token (prettyprinter, POP_TEXTSTYLE);
			fi;
		    };
	    esac;


	fun break               prettyprinter arg =  prettyprint_break (prettyprinter, arg);
	fun space               prettyprinter n   =  break prettyprinter { spaces => n, indent_on_wrap => 0 };
	fun cut                 prettyprinter     =  break prettyprinter { spaces => 0, indent_on_wrap => 0 };
	fun newline             prettyprinter     =  prettyprint_newline prettyprinter;
	fun nonbreakable_spaces prettyprinter n   =  add_token (prettyprinter, NONBREAKABLE_SPACES n );

	fun control prettyprinter control_fn
	    =
	    add_token (prettyprinter, CONTROL control_fn);
    };
end;

## COPYRIGHT (c) 2005 John Reppy (http://www.cs.uchicago.edu/~jhr)
## All rights reserved.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
