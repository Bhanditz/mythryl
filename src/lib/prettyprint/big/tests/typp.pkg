## typp.pkg


# A pretty-printer for ML type expressions.


run "base.pkg";

enum aType
  = TYPEVAR_TYPE of String
  | BaseType of (List( Type ) * String)
  | FnType   of (Type * Type)
  | TUPLE_TYPE  of List( Type )
  | RECORD_TYPE of List( String * Type )

fun prettyprint_type (stream, type) = let
      fun prettyprintComma () = (pp::lit stream ", "; pp::space stream 1)
      fun prettyprintStar () = (pp::space stream 1; pp::lit stream "*"; pp::nonbreakable_spaces stream 1)
      fun prettyprint (TYPEVAR_TYPE s) = pp::lit stream s
	| prettyprint (BaseType([], s) = pp::lit stream s
	| prettyprint (BaseType([type], s) =
	| prettyprint (BaseType (l, s) =
	| prettyprint (FnType (type1, type2)) =
	| prettyprint (TUPLE_TYPE []) = pp::lit stream "()"
	| prettyprint (TUPLE_TYPE [type]) = prettyprint type
	| prettyprint (TUPLE_TYPE l) =
	| prettyprint (RECORD_TYPE []) = pp::lit stream "{}"
	| prettyprint (RECORD_TYPE l) = let
	    fun prettyprintElement (lab, type) = (
		  pp::begin_align_4box stream (pp::Abs 2);
		    pp::lit lab;
		    pp::space stream 1;
		    pp::lit stream ":";
		    pp::nonbreakable_spaces stream;
		    prettyprint type
		  pp::shut_box())
	    in
	      pp::openHBox stream;
	        pp::lit stream "{ ";
	        pp::begin_align_4box (stream, pp::Abs 4);
	          ppl (prettyprintElement, prettyprintComma) l;
		  pp::break stream { spaces=0, offset=2 };
		pp::shut_box stream;
	        pp::lit stream "}";
	      pp::shut_box stream
	    end
      and prettyprintParenType type =
      and ppl (prettyprintElement, prettyprintSep) l = let
	    fun ppl' [] = ()
	      | ppl' [type] = prettyprintElement type
	      | ppl' (type . r) = (prettyprintElement type; prettyprintSep(); ppl' r)
	    in
	      ppl' l
	    end
      in
	pp::begin_wrap_4box (stream, pp::Abs 2);
	prettyprint type;
	pp::shut_box stream
      end;

local
  stringType = BaseType([], "string")
  intType = BaseType([], "Int")
  boolType = BaseType([], "bool")
  unitType = BaseType([], "unit")
  posType = BaseType([], "pos")
  fun optionType arg = BaseType([arg], "Null_Or")
  vecBufType = RECORD_TYPE [
	  ("buf", BaseType([], "Vector")),
	  ("i", intType),
	  ("size", optionType intType)
	]
  arrBufType = RECORD_TYPE [
	  ("buf", BaseType([], "array")),
	  ("i", intType),
	  ("size", optionType intType)
	]
in
wrType = RECORD_TYPE of [
	("name", stringType),
	("chunkSize", intType),
	("writeVec", optionType (FnType (vecBufType, intType))),
	("writeArr", optionType (FnType (arrBufType, intType))),
	("writeVecNB", optionType (FnType (vecBufType, optionType intType))),
	("writeArrNB", optionType (FnType (arrBufType, optionType intType))),
	("block", optionType (FnType (unitType, unitType)),
	("canOutput", optionType (FnType (unitType, boolType)),
	("getPos", optionType (FnType (unitType, posType))),
	("setPos", optionType (FnType (posType, unitType))),
	("endPos", optionType (FnType (unitType, posType))),
	("verifyPos", optionType (FnType (unitType, posType))),
	("close", optionType (FnType (unitType, unitType))),
	("ioDesc", optionType (BaseType([], "winix::io::Iod")))
      ]
end;


## COPYRIGHT (c) 1997 Bell Labs, Lucent Technologies.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
