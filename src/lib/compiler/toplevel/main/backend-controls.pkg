## backend-controls.pkg

# Compiled by:
#     src/lib/compiler/core.sublib



stipulate
    package bc  =  basic_control;		 			# basic_control			is from   src/lib/compiler/front/basics/main/basic-control.pkg
    package ci  =  control_index;					# control_index			is from   src/lib/controls/control-index.pkg
    package cj  =  control_junk;					# control_junk			is from   src/lib/controls/control-junk.pkg
    package ctl =  control;						# control			is from   src/lib/controls/control.pkg
    package tc  =  typer_control;					# typer_control			is from   src/lib/compiler/front/typer/basics/typer-control.pkg
    package tdc =  typer_data_controls;					# typer_data_controls		is from   src/lib/compiler/front/typer-stuff/main/typer-data-controls.pkg
herein

    package   backend_controls
    : (weak)  Backend_Controls						# Backend_Controls		is from   src/lib/compiler/toplevel/main/control-apis.api
    {
	menu_rank =  [10, 11, 2];
	obscurity =  6;							# XXX SUCKO FIXME obscurity values should be given intelligible names like "high" "medium" "low". Who knows what 6 means? 
	prefix    =  "backend";

	registry  =  ci::make { help => "compiler backend controls" };
									    my _ = 
	bc::note_subindex
	    #
	    (prefix, registry, menu_rank);		# XXX BUGGO FIXME more stuff which should be part of a state record, not global mutable state.

	b  =  cj::cvt::bool;
	i  =  cj::cvt::int;
	r  =  cj::cvt::float;
	sl =  cj::cvt::string_list;

	nextpri =  REF 0;

	fun make (control_type, name, help, initial_value)
	    =
	    {   val_ref   =  REF  initial_value;
		menu_rank =  *nextpri;

		control
		    =
		    ctl::make_control {		# control		is from   src/lib/controls/control.pkg
		      name,
		      help,
		      menu_rank =>  [menu_rank],
		      obscurity,
		      control   =>  val_ref
		    };

		nextpri :=  menu_rank + 1;

		ci::note_control
		    #
		    registry
		    #
		    { control         =>  ctl::make_string_control  control_type  control,
		      dictionary_name =>  THE (cj::dn::to_upper "CG_" name)
		    };

		val_ref;
	    };

	tailrecur		= make (b, "tailrecur", "?", TRUE);
	recordopt		= make (b, "recordopt", "?", TRUE);
	tail			= make (b, "tail", "?", TRUE);

	allocprof		= make (b, "allocprof", "?", FALSE);
	closureprint		= make (b, "closureprint", "?", FALSE);
	closure_strategy	= make (i, "closure_strategy", "?", 0);

	lambdaopt		= make (b, "lambdaopt", "?", TRUE);

	optional_nextcode_improvers		= make (sl, "optional_nextcode_improvers", "nextcode optimizer phases", ["zeroexpand", "last_contract"]);

    #    ["first_contract", "eta", "uncurry", "split_known_escaping_functions",
    #	"cycle_expand", "eta", "last_contract" ]

	rounds			= make (i, "rounds", "max # of optional_nextcode_improvers rounds", 10);
	path			= make (b, "path", "?", FALSE);
	beta_contract		= make (b, "beta_contract", "?", TRUE);

	eta			= make (b, "eta", "?", TRUE);
	selectopt		= make (b, "selectopt", "?", TRUE);
	dropargs		= make (b, "dropargs", "?", TRUE);

	deadvars		= make (b, "deadvars", "?", TRUE);
	flattenargs		= make (b, "flattenargs", "?", FALSE);
	extraflatten		= make (b, "extraflatten", "?", FALSE);

	switchopt		= make (b, "switchopt", "?", TRUE);
	handlerfold		= make (b, "handlerfold", "?", TRUE);
	branchfold		= make (b, "branchfold", "?", FALSE);

	arithopt		= make (b, "arithopt", "?", TRUE);
	beta_expand		= make (b, "beta_expand", "?", TRUE);
	unroll			= make (b, "unroll", "?", TRUE);

	knownfiddle		= make (b, "knownfiddle", "?", FALSE);
	invariant		= make (b, "invariant", "?", TRUE);
	targeting		= make (i, "targeting", "?", 0);

	lambdaprop		= make (b, "lambdaprop", "?", FALSE);
	newconreps		= make (b, "newconreps", "?", TRUE);

	boxedconstconreps	= tc::boxedconstconreps;

	unroll_recursion	= make (b, "unroll_recursion", "?", TRUE);
	sharepath		= make (b, "sharepath", "?", TRUE);

	static_closure_size_profiling	=  make (b, "static_closure_size_profiling", "?", FALSE);

	hoistup			= make (b, "hoistup", "?", FALSE);
	hoistdown		= make (b, "hoistdown", "?", FALSE);

	recordcopy		= make (b, "recordcopy", "?", TRUE);
	recordpath		= make (b, "recordpath", "?", TRUE);

	verbose			= make (b, "verbose", "?", FALSE);
	debugnextcode		= make (b, "debugnextcode", "?", FALSE);
	misc4			= make (i, "misc4", "?", 0);

	argrep			= make (b, "argrep", "?", TRUE);
	bodysize		= make (i, "bodysize", "?", 20);
	reducemore		= make (i, "reducemore", "?", 15);

	alphac				= make (b, "alphac", "?", TRUE);
	comment				= make (b, "comment", "?", FALSE);

	known_function			= make (i, "known_function", "?", 0);
	known_cl_function		= make (i, "known_cl_function", "?", 0);

	escape_function			= make (i, "escape_function", "?", 0);
	callee_function			= make (i, "callee_function", "?", 0);

	spill_function			= make (i, "spill_function", "?", 0);
	foldconst			= make (b, "foldconst", "?", TRUE);			# Apparently never used.

	printit				= make (b, "printit", "whether to show nextcode", FALSE);
	printsize			= make (b, "printsize", "?", FALSE);

	scheduling			= make (b, "scheduling", "?", TRUE);
	cse				= make (b, "cse", "?", FALSE);				# "cse" might be "common subexpression elimination"

	split_known_escaping_functions	= make (b, "split_known_escaping_functions", "?", TRUE);
	improve_after_closure		= make (b, "improve_after_closure", "?", FALSE);

	uncurry			= make (b, "uncurry", "?", TRUE);
	if_idiom		= make (b, "if_idiom", "?", TRUE);
	comparefold		= make (b, "comparefold", "?", TRUE);
	csehoist		= make (b, "csehoist", "?", FALSE);
	rangeopt		= make (b, "rangeopt", "?", FALSE);
	icount			= make (b, "icount", "?", FALSE);

	debug_representation	= make (b, "debug_representation", "?", FALSE);

	checklty1		= make (b, "checklty1",      "?", FALSE);
	checklty2		= make (b, "checklty2",      "?", FALSE);
	checklty3		= make (b, "checklty3",      "?", FALSE);
	checknextcode1		= make (b, "checknextcode1", "?", FALSE);
	checknextcode2		= make (b, "checknextcode2", "?", FALSE);
	checknextcode3		= make (b, "checknextcode3", "?", FALSE);
	checknextcode		= make (b, "checknextcode",  "?", FALSE);

	flatfblock		= make (b, "flatfblock", "?", TRUE);
	deadup			= make (b, "deadup", "?", TRUE);

	poll_checks		=  make (b, "poll_checks", "?", FALSE);
	poll_ratio_a_to_i	=  make (r, "poll_ratio_a_to_i", "?", 1.0);

	print_flowgraph_stream = REF file::stdout;

	disambiguate_memory	=  make (b, "disambiguate_memory", "?", FALSE);
	control_dependence	=  make (b, "control_dependence", "?", FALSE);
	highcodeon		=  make (b, "highcodeon", "?", TRUE);

	comp_debugging				= make (b, "comp_debugging", "?", FALSE);

	module_junk_debugging			= tdc::module_junk_debugging;
	translate_to_anormcode_debugging	= tdc::translate_to_anormcode_debugging;
	type_junk_debugging			= tdc::type_junk_debugging;

	types_debugging				= tdc::types_debugging;
	expand_generics_g_debugging		= tdc::expand_generics_g_debugging;
	typerstore_debugging			= tdc::typerstore_debugging;

	generics_expansion_junk_debugging	= tc::generics_expansion_junk_debugging;
	api_match_debugging			= tc::api_match_debugging;
	type_package_language_debugging		= tc::type_package_language_debugging;

	typer_junk_debugging			= tc::typer_junk_debugging;
	type_api_debugging			= tc::type_api_debugging;
	typecheck_type_debugging		= tc::typecheck_type_debugging;

	unify_types_debugging			= tc::unify_types_debugging;
	expand_oop_syntax_debugging		= tc::expand_oop_syntax_debugging;
	translate_types_debugging		= make (b, "translate_types_debugging", "?", FALSE);
    };
end;

## COPYRIGHT (c) 1995 AT&T Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################

