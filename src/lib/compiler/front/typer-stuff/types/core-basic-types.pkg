## core-basic-types.pkg
## (C) 2001 Lucent Technologies, Bell Labs

# THIS FILE APPEARS TO BE UNUSED GARBAGE

# Compiled by:
#     src/lib/compiler/front/typer-stuff/typecheckdata.sublib


# Nomenclature
# ============
#
#     "typ" abbreviates "type constructor",
#
# because (e.g.) 'List(Int)' constructs a new type
# from the input 'Int' type.

# a generic part of type-types.pkg (not Lib7 specific)

package core_type_types: (weak)  api

     arrow_stamp:  stamp::Stamp;
     arrow_type:  types::Type;
     --> : (types::Type, types::Type) -> types::Type;

     ref_stamp:  stamp::Stamp;
     ref_type_symbol:  symbol::Symbol;
     ref_con_symbol:  symbol::Symbol;
     ref_type:  types::Type;
     ref_dcon:  types::Constructor;
     ref_pattern_typoid:  types::Type;

     bool_stamp:  stamp::Stamp;
     bool_symbol:  symbol::Symbol;
     false_symbol:  symbol::Symbol;
     true_symbol:  symbol::Symbol;
     bool_type:  types::Type;
     bool_typoid:  types::Type;
     bool_api:  access::Valcon_Signature;
     false_dcon:  types::Constructor;
     true_dcon:  types::Constructor;

     void_symbol:  symbol::Symbol;
     void_type:  types::Type;
     void_typoid:  types::Type;

     int_type:  types::Type;
     int_typoid:  types::Type;

     string_type:  types::Type;
     string_typoid:  types::Type;

     char_type:  types::Type;
     char_typoid:  types::Type;

     float64_type:  types::Type;
     float64_typoid:  types::Type;

     exception_type:  types::Type;
     exception_typoid:  types::Type;

     tuple_typoid:  List( types::Type ) -> types::Type;

     record_typoid:  List( (types::Label, types::Type) ) -> types::Type;

     rw_vector_type:  types::Type;
     vector_type:  types::Type;

end

{
    package tdt =  type_declaration_types;				# type_declaration-types			is from   src/lib/compiler/front/typer-stuff/types/type-declaration-types.pkg
    package ip  =  inverse_path;					# inverse_path					is from   src/lib/compiler/front/typer-stuff/basics/symbol-path.pkg
    package ptn =  core_basetype_numbers;				# core_basetype_numbers				is from   src/lib/compiler/front/typer-stuff/basics/core-basetype-numbers.pkg

    arrow_stamp =  stamp::special "->";
    ref_stamp   =  stamp::special "REF";
    bool_stamp  =  stamp::special "bool";

    void_symbol =  symbol::make_type_symbol "Void";
    ref_type_symbol =  symbol::make_type_symbol "Ref";
    ref_con_symbol =  symbol::make_value_symbol "REF";

    bool_symbol  = symbol::make_type_symbol "Bool";
    false_symbol = symbol::make_value_symbol "FALSE";
    true_symbol  = symbol::make_value_symbol "TRUE";

    fun tc2t typ
        =
        tdt::TYPCON_TYPOID (typ, []);

    void_type =  tdt::NAMED_TYPE  { stamp       => stamp::special "Void",
				    strict      => [],
				    path        => ip::INVERSE_PATH [void_symbol],
				    type_scheme => tdt::TYPE_SCHEME { arity => 0,
								      body  => tdt::TYPCON_TYPOID (tuples::make_tuple_type 0, [])
								    }
				  };

    void_typoid   =   tc2t void_type;

    fun pt2tc (symbol, arity, equality_property, ptn)
        =
	tdt::BASE_TYP { stamp => stamp::special symbol,
			path  => ip::INVERSE_PATH [symbol::make_type_symbol symbol],
			arity,

			eq    => REF equality_property,
			kind  => tdt::BASE ptn,
			stub  => NULL
		      };

    fun pt2tct args
        =
        {   typ = pt2tc args;
	
	    (typ, tc2t typ);
	};

    # This stuff is duplicated here and   src/lib/compiler/front/typer-stuff/types/core-type-types.pkg
    # -- can't we factor the duplication out somehow?   XXX BUGGO FIXME

    my (      int_type,       int_typoid) =   pt2tct ("Int",       0, tdt::YES, ptn::basetype_number_int   );
    my (   string_type,    string_typoid) =   pt2tct ("String",    0, tdt::YES, ptn::basetype_number_string);
    my (     char_type,      char_typoid) =   pt2tct ("Char",      0, tdt::YES, ptn::basetype_number_int   );
    my (  float64_type,   float64_typoid) =   pt2tct ("Float",     0, tdt::NO,  ptn::basetype_number_float64  );
    my (exception_type, exception_typoid) =   pt2tct ("Exception", 0, tdt::NO,  ptn::basetype_number_exn   );

    rw_vector_type  = pt2tc ("Rw_Vector",  1, tdt::CHUNK, ptn::basetype_number_rw_vector );
    vector_type     = pt2tc ("Vector",     1, tdt::YES,   ptn::basetype_number_vector);

    arrow_type
        =
	tdt::BASE_TYP {
	    #
            stamp => arrow_stamp,
	    path  => ip::INVERSE_PATH [symbol::make_type_symbol "->"],
	    arity => 2,
	    #
	    eq    => REF tdt::NO,
	    kind  => tdt::BASE ptn::basetype_number_arrow,
	    stub  => NULL
        };

    infix -->;

    fun t1 --> t2
        =
        tdt::TYPCON_TYPOID (arrow_type, [t1, t2]);

    fun record_typoid (fields: List( (tdt::Label, tdt::Typoid)) )
        =
	tdt::TYPCON_TYPOID (tuples::make_record_typ (map #1 fields), map #2 fields);

    fun tuple_typoid types
        =
        tdt::TYPCON_TYPOID (tuples::make_tuple_type (length types), types);

    my (ref_type, ref_pattern_typoid, ref_dcon)
        =
        {   eq_ref  =  REF tdt::CHUNK;
	    alpha   =  tdt::TYPE_SCHEME_ARG_I 0;
	    ref_dom =  alpha;
	    refsign =  access::CSIG (1, 0);

	    ref_type = tdt::BASE_TYP {

			       stub  => NULL,
		               stamp => ref_stamp,
			       path  => ip::INVERSE_PATH [ ref_type_symbol ],
			       arity => 1,
			       eq    => eq_ref,
			       kind  => tdt::SUMTYPE {
				           index    => 0,
					   stamps   => #[ref_stamp],
					   free_types => [],
					   root     => NULL,
					   family   => {   properties => property_list::new_holder (),
						          mkey       => ref_stamp,
							  members    => #[   {   type_name => ref_type_symbol,
									        eq         => eq_ref,
									        is_lazy     => FALSE,
									        arity      => 1,
									        an_api => access::CSIG (1, 0),
									        constructor_list => [  {   name           => ref_con_symbol,
													         representation => access::REF_REP,
													         domain         => THE ref_dom
												             }
												          ]
								            }
								        ]

				       
                                                      }
                                       }
                           };

	    ref_tyfun
                =
		tdt::TYPE_SCHEME { arity => 1, body => alpha --> tdt::TYPCON_TYPOID (ref_type, [alpha]) };

	    ref_pattern_typoid
                =
                tdt::TYPE_SCHEME_TYPOID {
                    type_scheme_arg_eq_properties => [FALSE],
                    type_scheme => ref_tyfun
                };

	    ref_dcon = tdt::VALCON { symbol          => ref_con_symbol,
				     const           => FALSE,
				     is_lazy         => FALSE,
				     form            => access::REF_REP,
				     constructortype => ref_pattern_typoid,
				     an_api          => refsign
				   };
	
	    (ref_type, ref_pattern_typoid, ref_dcon);
	};

    bool_api = access::CSIG (0, 2);

    my (bool_type, bool_typoid, false_dcon, true_dcon)
        =
        { booleq = REF tdt::YES;

	    bool_type
                =
		tdt::BASE_TYP {
		    stamp => bool_stamp,
		    path  => ip::INVERSE_PATH [bool_symbol],
		    arity => 0,
		    eq    => booleq,
                    stub  => NULL,
		    kind  => tdt::SUMTYPE {
				index    => 0,
				stamps   => #[bool_stamp],
				free_types => [],
				root     => NULL,
				family   => {   properties => property_list::new_holder (),
                                               mkey       => bool_stamp,
                                               members    => #[   {   type_name => bool_symbol,
								     eq         => booleq,
								     is_lazy     => FALSE,
								     arity      => 0,
								     an_api => bool_api,

								     constructor_list =>   [  { name    => false_symbol,
												form    => access::CONSTANT 0,
												domain  => NULL
											      },
											      { name    => true_symbol,
												form    => access::CONSTANT 1,
												domain  => NULL
											      }
											   ]
								 }
							     ]
				    
				    
                                           }
                            }
                };

	    bool_typoid = tdt::TYPCON_TYPOID (bool_type, []);

	    false_dcon = tdt::VALCON
                          {
			    symbol           => false_symbol,
			    const            => TRUE,
			    is_lazy          => FALSE,
			    form             => access::CONSTANT 0,
			    type => bool_typoid,
			    an_api           => bool_api
			  };

	    true_dcon = tdt::VALCON
                         {
			   symbol          => true_symbol,
			   const           => TRUE,
			   is_lazy         => FALSE,
			   form            => access::CONSTANT 1,
			   constructortype => bool_typoid,
			   an_api          => bool_api
                         };
	
	    (bool_type, bool_typoid, false_dcon, true_dcon);
	};
};


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################
