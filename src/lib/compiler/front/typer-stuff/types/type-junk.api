## type-junk.api 

# Compiled by:
#     src/lib/compiler/front/typer-stuff/typecheckdata.sublib



stipulate
    package ds  =  deep_syntax;						# deep_syntax			is from   src/lib/compiler/front/typer-stuff/deep-syntax/deep-syntax.pkg
    package id  =  inlining_data;					# inlining_data			is from   src/lib/compiler/front/typer-stuff/basics/inlining-data.pkg
    package tdt =  type_declaration_types;				# type_declaration_types	is from   src/lib/compiler/front/typer-stuff/types/type-declaration-types.pkg
    package sy  =  symbol;						# symbol			is from   src/lib/compiler/front/basics/map/symbol.pkg
herein

    api Type_Junk {
	#
	equality_property_to_string:  tdt::eq_type::Data -> String;

	# Operations to build type_variables, VARtys:
	#
    # 2009-04-17 CrT: Following is not actually used outside of defining file:
    #    make_meta_type_variable:       Int -> tdt::Type_Variable;
	make_incomplete_record_type_variable:   (( List ((sy::Symbol, tdt::Type))), Int) -> tdt::Type_Variable;
	make_user_type_variable:  sy::Symbol -> tdt::Type_Variable;

	make_overloaded_literal_type_variable: (tdt::Literal_Kind, line_number_db::Source_Code_Region, List(String)) -> tdt::Type;
	make_overloaded_type_variable_and_type:  List(String) -> tdt::Type;

	make_meta_type_variable_and_type:  (Int, List(String)) -> tdt::Type;

	# Base ops on type constructors:
	#
	typ_name:   tdt::Typ -> sy::Symbol;
	typ_stamp:  tdt::Typ -> stamp::Stamp;
	typ_path:   tdt::Typ -> inverse_path::Inverse_Path;

	typ_stamppath:     tdt::Typ -> stamppath::Stamppath;
	typ_arity:           tdt::Typ -> Int;
	set_typ_path:       (tdt::Typ, inverse_path::Inverse_Path) -> tdt::Typ;
	typs_are_equal:     (tdt::Typ, tdt::Typ) -> Bool;
	make_constructor_type: (tdt::Typ, List( tdt::Type )) -> tdt::Type;

	prune:  tdt::Type -> tdt::Type;

	typevar_refs_are_equal:    (tdt::Typevar_Ref, tdt::Typevar_Ref) -> Bool;

	resolve_type_variables_to_typescheme_slots:       List( tdt::Typevar_Ref ) -> Void;
	resolve_type_variables_to_typescheme_slots_1:     List( tdt::Typevar_Ref ) -> tdt::Type_Scheme_Arg_Eq_Properties;

	exception BAD_TYPE_REDUCTION;

	# Transform every
	#     TYPCON_TYPE.typ
	# in given type:
	#
	map_constructor_type_dot_typ
	    :
	    (tdt::Typ -> tdt::Typ)	# Transform.
	    ->
	    tdt::Type						# Type to transform.
	    ->
	    tdt::Type;

	apply_type_scheme:  (tdt::Type_Scheme, List( tdt::Type )) -> tdt::Type;

	reduce_type:      tdt::Type -> tdt::Type;
	head_reduce_type:  tdt::Type -> tdt::Type;
	types_are_equal:   (tdt::Type, tdt::Type) -> Bool;

	typ_equality:  (tdt::Typ, tdt::Typ) -> Bool;

	# Making a "generic" copy of a type:
	#
    # 2009-04-17 CrT: Following is never actually used:
    #    make_type_args:  Int -> List( tdt::Type );
	make_typeagnostic_api:  Int -> tdt::Type_Scheme_Arg_Eq_Properties;

	datatyp_to_typ:  	tdt::Valcon -> tdt::Typ;
	datatyp_to_type:    (tdt::Typ, Null_Or( tdt::Type )) -> tdt::Type;

	# Matching a scheme against a target type -- used declaring overloadings:
	# 
	match_scheme:  (tdt::Type_Scheme, tdt::Type) -> tdt::Type;

	# Get rid of MACRO_EXPANDED indirections in a type:
	#
	drop_macro_expanded_indirections_from_type:  tdt::Type -> Void;  


	instantiate_if_type_scheme:  tdt::Type -> (tdt::Type, List( tdt::Type ));

	pkg_type_matches_api_type
	    :
	    { type_per_api:  tdt::Type,
	      type_per_pkg:  tdt::Type
	    }
	    ->
	    Bool; 

	type_variable_of_type:  tdt::Type -> tdt::Typevar_Ref;

	# Check if a bound type_variable has occurred in some datatypes, e::g.  List(X). 
	# this is useful for representation analysis; but it should be 
	# obsolete very soon -- zsh. 
	#
	get_recursive_type_variable_map:  (Int, tdt::Type) -> (Int -> Bool);
	label_is_greater_than:  (sy::Symbol, sy::Symbol) -> Bool;

	is_value:  { inlining_info_says_it_is_pure:  id::Inlining_Data -> Bool } -> ds::Deep_Expression -> Bool;
	is_variable_type:  tdt::Type -> Bool;

	sort_fields:   List( (ds::Numbered_Label, X))
		     ->  List( (ds::Numbered_Label, X));

	map_unzip:  (X -> (Y, Z)) -> List(X) -> (List(Y), List(Z));

	Typ_Set;

	make_typ_set:      Void -> Typ_Set;
	insert_typ_into_set:  (tdt::Typ, Typ_Set) -> Typ_Set;
	filter_typ_set:    (tdt::Type, Typ_Set) -> List( tdt::Typ );

	datatype_sibling:    (Int, tdt::Typ) -> tdt::Typ;
	extract_datatyp: tdt::Typ -> List( tdt::Valcon );

	wrap_definition:  (tdt::Typ, stamp::Stamp) -> tdt::Typ;

	   # make a typ into a DEFINED_TYP by "eta-expanding" if necessary

	unwrap_definition_1:     tdt::Typ -> Null_Or( tdt::Typ );
	unwrap_definition_star:  tdt::Typ -> tdt::Typ;

    };  #  Api Type_Junk 
end;

## Copyright 1996 by AT&T Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
