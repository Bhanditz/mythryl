api Nada_Tokens {
    Token (X,Y);
    Semantic_Value;
    zzz: (X, X) -> Token (Semantic_Value,X);
    yyy: (X, X) -> Token (Semantic_Value,X);
    xxx: (X, X) -> Token (Semantic_Value,X);
    with_t: (X, X) -> Token (Semantic_Value,X);
    while_t: (X, X) -> Token (Semantic_Value,X);
    where_t: (X, X) -> Token (Semantic_Value,X);
    use: (X, X) -> Token (Semantic_Value,X);
    underbar: (X, X) -> Token (Semantic_Value,X);
    type_t: (X, X) -> Token (Semantic_Value,X);
    transparent: (X, X) -> Token (Semantic_Value,X);
    tight_infix_dot: (X, X) -> Token (Semantic_Value,X);
    tight_infix_colon: (X, X) -> Token (Semantic_Value,X);
    then_t: (X, X) -> Token (Semantic_Value,X);
    suffix_slash: (X, X) -> Token (Semantic_Value,X);
    suffix_rbracket: (X, X) -> Token (Semantic_Value,X);
    suffix_rbrace: (X, X) -> Token (Semantic_Value,X);
    suffix_rangle: (X, X) -> Token (Semantic_Value,X);
    suffix_semi: (X, X) -> Token (Semantic_Value,X);
    suffix_dot: (X, X) -> Token (Semantic_Value,X);
    suffix_comma: (X, X) -> Token (Semantic_Value,X);
    suffix_colon: (X, X) -> Token (Semantic_Value,X);
    suffix_bar: (X, X) -> Token (Semantic_Value,X);
    sharing_t: (X, X) -> Token (Semantic_Value,X);
    rparen: (X, X) -> Token (Semantic_Value,X);
    rec_t: (X, X) -> Token (Semantic_Value,X);
    raw_whitespace: (X, X) -> Token (Semantic_Value,X);
    raw_comma: (X, X) -> Token (Semantic_Value,X);
    raw_dot: (X, X) -> Token (Semantic_Value,X);
    raw_semi: (X, X) -> Token (Semantic_Value,X);
    raw_backslash: (X, X) -> Token (Semantic_Value,X);
    raw_bar: (X, X) -> Token (Semantic_Value,X);
    raw_caret: (X, X) -> Token (Semantic_Value,X);
    raw_atsign: (X, X) -> Token (Semantic_Value,X);
    raw_question: (X, X) -> Token (Semantic_Value,X);
    raw_equal: (X, X) -> Token (Semantic_Value,X);
    raw_rbracket: (X, X) -> Token (Semantic_Value,X);
    raw_lbracket: (X, X) -> Token (Semantic_Value,X);
    raw_rbrace: (X, X) -> Token (Semantic_Value,X);
    raw_lbrace: (X, X) -> Token (Semantic_Value,X);
    raw_rangle: (X, X) -> Token (Semantic_Value,X);
    raw_langle: (X, X) -> Token (Semantic_Value,X);
    raw_colon: (X, X) -> Token (Semantic_Value,X);
    raw_percent: (X, X) -> Token (Semantic_Value,X);
    raw_slash: (X, X) -> Token (Semantic_Value,X);
    raw_star: (X, X) -> Token (Semantic_Value,X);
    raw_plus: (X, X) -> Token (Semantic_Value,X);
    raw_dash: (X, X) -> Token (Semantic_Value,X);
    raw_tilda: (X, X) -> Token (Semantic_Value,X);
    raw_bang: (X, X) -> Token (Semantic_Value,X);
    raw_sharp: (X, X) -> Token (Semantic_Value,X);
    raw_dollar: (X, X) -> Token (Semantic_Value,X);
    raw_underbar: (X, X) -> Token (Semantic_Value,X);
    raw_ampersand: (X, X) -> Token (Semantic_Value,X);
    raise_t: (X, X) -> Token (Semantic_Value,X);
    prefix_slash: (X, X) -> Token (Semantic_Value,X);
    prefix_lbracket: (X, X) -> Token (Semantic_Value,X);
    prefix_lbrace: (X, X) -> Token (Semantic_Value,X);
    prefix_langle: (X, X) -> Token (Semantic_Value,X);
    prefix_dot: (X, X) -> Token (Semantic_Value,X);
    prefix_bar: (X, X) -> Token (Semantic_Value,X);
    package_t: (X, X) -> Token (Semantic_Value,X);
    or_t: (X, X) -> Token (Semantic_Value,X);
    opaque: (X, X) -> Token (Semantic_Value,X);
    of_t: (X, X) -> Token (Semantic_Value,X);
    my_t: (X, X) -> Token (Semantic_Value,X);
    macro: (X, X) -> Token (Semantic_Value,X);
    lparen: (X, X) -> Token (Semantic_Value,X);
    loose_infix_rbrace: (X, X) -> Token (Semantic_Value,X);
    loose_infix_lbrace: (X, X) -> Token (Semantic_Value,X);
    loose_infix_rbracket: (X, X) -> Token (Semantic_Value,X);
    loose_infix_lbracket: (X, X) -> Token (Semantic_Value,X);
    loose_infix_lvector: (X, X) -> Token (Semantic_Value,X);
    local_t: (X, X) -> Token (Semantic_Value,X);
    let_t: (X, X) -> Token (Semantic_Value,X);
    lazy_t: (X, X) -> Token (Semantic_Value,X);
    infix_qmarkqmark: (X, X) -> Token (Semantic_Value,X);
    infix_equal: (X, X) -> Token (Semantic_Value,X);
    infix_dotdotdot: (X, X) -> Token (Semantic_Value,X);
    infix_darrow: (X, X) -> Token (Semantic_Value,X);
    infix_bangbang: (X, X) -> Token (Semantic_Value,X);
    infix_arrow: (X, X) -> Token (Semantic_Value,X);
    include_t: (X, X) -> Token (Semantic_Value,X);
    in_t: (X, X) -> Token (Semantic_Value,X);
    if_t: (X, X) -> Token (Semantic_Value,X);
    fun_t: (X, X) -> Token (Semantic_Value,X);
    fn_t: (X, X) -> Token (Semantic_Value,X);
    fi_t: (X, X) -> Token (Semantic_Value,X);
    exception_t: (X, X) -> Token (Semantic_Value,X);
    except_t: (X, X) -> Token (Semantic_Value,X);
    eqtype_t: (X, X) -> Token (Semantic_Value,X);
    eof: (X, X) -> Token (Semantic_Value,X);
    enum_t: (X, X) -> Token (Semantic_Value,X);
    end_t: (X, X) -> Token (Semantic_Value,X);
    else_t: (X, X) -> Token (Semantic_Value,X);
    do_t: (X, X) -> Token (Semantic_Value,X);
    case_t: (X, X) -> Token (Semantic_Value,X);
    beginq: (X, X) -> Token (Semantic_Value,X);
    begin_t: (X, X) -> Token (Semantic_Value,X);
    as_t: (X, X) -> Token (Semantic_Value,X);
    api_t: (X, X) -> Token (Semantic_Value,X);
    and_t: (X, X) -> Token (Semantic_Value,X);
    also_t: (X, X) -> Token (Semantic_Value,X);
    suffix_op: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    prefix_op: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    loose_infix_op: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    tight_infix_op: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    unt: ((multiword_int::Int), X, X) -> Token (Semantic_Value,X);
    typevar_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    type_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    string: ((String), X, X) -> Token (Semantic_Value,X);
    shebang: ((String), X, X) -> Token (Semantic_Value,X);
    real: ((String), X, X) -> Token (Semantic_Value,X);
    int0: ((multiword_int::Int), X, X) -> Token (Semantic_Value,X);
    int: ((multiword_int::Int), X, X) -> Token (Semantic_Value,X);
    value_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    endq: ((String), X, X) -> Token (Semantic_Value,X);
    constructor_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    chunkl: ((String), X, X) -> Token (Semantic_Value,X);
    char: ((String), X, X) -> Token (Semantic_Value,X);
    antiquote_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
};
api Nada_Lrvals{
    package tokens:  Nada_Tokens;
    package parser_data: Parser_Data;
    sharing parser_data::token::Token == tokens::Token;
    sharing parser_data::Semantic_Value == tokens::Semantic_Value;
};
