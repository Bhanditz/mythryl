api Mythryl_Tokens {
    Token (X,Y);
    Semantic_Value;
    antiquote_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    chunkl: ((String), X, X) -> Token (Semantic_Value,X);
    endq: ((String), X, X) -> Token (Semantic_Value,X);
    beginq: (X, X) -> Token (Semantic_Value,X);
    vectorstart: (X, X) -> Token (Semantic_Value,X);
    and_t: (X, X) -> Token (Semantic_Value,X);
    or_t: (X, X) -> Token (Semantic_Value,X);
    rparen: (X, X) -> Token (Semantic_Value,X);
    rbracket: (X, X) -> Token (Semantic_Value,X);
    lparen: (X, X) -> Token (Semantic_Value,X);
    lbrace_dot: (X, X) -> Token (Semantic_Value,X);
    comma: (X, X) -> Token (Semantic_Value,X);
    what_colon: (X, X) -> Token (Semantic_Value,X);
    colon_what: (X, X) -> Token (Semantic_Value,X);
    colon_colon: (X, X) -> Token (Semantic_Value,X);
    partial_package_cast: (X, X) -> Token (Semantic_Value,X);
    weak_package_cast: (X, X) -> Token (Semantic_Value,X);
    colon: (X, X) -> Token (Semantic_Value,X);
    withtype_t: (X, X) -> Token (Semantic_Value,X);
    wild: (X, X) -> Token (Semantic_Value,X);
    where_t: (X, X) -> Token (Semantic_Value,X);
    what_what: (X, X) -> Token (Semantic_Value,X);
    tilda_tilda: (X, X) -> Token (Semantic_Value,X);
    stipulate_t: (X, X) -> Token (Semantic_Value,X);
    printf_t: (X, X) -> Token (Semantic_Value,X);
    package_t: (X, X) -> Token (Semantic_Value,X);
    sprintf_t: (X, X) -> Token (Semantic_Value,X);
    sharing_t: (X, X) -> Token (Semantic_Value,X);
    recursive_t: (X, X) -> Token (Semantic_Value,X);
    raise_t: (X, X) -> Token (Semantic_Value,X);
    overloaded_t: (X, X) -> Token (Semantic_Value,X);
    nonfix_t: (X, X) -> Token (Semantic_Value,X);
    my_t: (X, X) -> Token (Semantic_Value,X);
    method_t: (X, X) -> Token (Semantic_Value,X);
    message_t: (X, X) -> Token (Semantic_Value,X);
    lazy_t: (X, X) -> Token (Semantic_Value,X);
    infixr_t: (X, X) -> Token (Semantic_Value,X);
    infix_t: (X, X) -> Token (Semantic_Value,X);
    include_t: (X, X) -> Token (Semantic_Value,X);
    in_t: (X, X) -> Token (Semantic_Value,X);
    if_t: (X, X) -> Token (Semantic_Value,X);
    herein_t: (X, X) -> Token (Semantic_Value,X);
    hash: (X, X) -> Token (Semantic_Value,X);
    generic_t: (X, X) -> Token (Semantic_Value,X);
    postfix_arrow: (X, X) -> Token (Semantic_Value,X);
    fprintf_t: (X, X) -> Token (Semantic_Value,X);
    fun_t: (X, X) -> Token (Semantic_Value,X);
    for_t: (X, X) -> Token (Semantic_Value,X);
    fn_t: (X, X) -> Token (Semantic_Value,X);
    field_t: (X, X) -> Token (Semantic_Value,X);
    fi_t: (X, X) -> Token (Semantic_Value,X);
    except_t: (X, X) -> Token (Semantic_Value,X);
    post_tilda: (X, X) -> Token (Semantic_Value,X);
    tilda_eq: (X, X) -> Token (Semantic_Value,X);
    tilda: (X, X) -> Token (Semantic_Value,X);
    pre_tilda: (X, X) -> Token (Semantic_Value,X);
    post_star: (X, X) -> Token (Semantic_Value,X);
    star_eq: (X, X) -> Token (Semantic_Value,X);
    star: (X, X) -> Token (Semantic_Value,X);
    pre_star: (X, X) -> Token (Semantic_Value,X);
    post_slash: (X, X) -> Token (Semantic_Value,X);
    slash_eq: (X, X) -> Token (Semantic_Value,X);
    slash: (X, X) -> Token (Semantic_Value,X);
    pre_slash: (X, X) -> Token (Semantic_Value,X);
    post_qmark: (X, X) -> Token (Semantic_Value,X);
    qmark_eq: (X, X) -> Token (Semantic_Value,X);
    qmark: (X, X) -> Token (Semantic_Value,X);
    pre_qmark: (X, X) -> Token (Semantic_Value,X);
    post_plus: (X, X) -> Token (Semantic_Value,X);
    plus_eq: (X, X) -> Token (Semantic_Value,X);
    plus: (X, X) -> Token (Semantic_Value,X);
    pre_plus: (X, X) -> Token (Semantic_Value,X);
    post_percnt: (X, X) -> Token (Semantic_Value,X);
    percnt_eq: (X, X) -> Token (Semantic_Value,X);
    percnt: (X, X) -> Token (Semantic_Value,X);
    pre_percnt: (X, X) -> Token (Semantic_Value,X);
    post_dotdot: (X, X) -> Token (Semantic_Value,X);
    dotdot_eq: (X, X) -> Token (Semantic_Value,X);
    dotdot: (X, X) -> Token (Semantic_Value,X);
    pre_dotdot: (X, X) -> Token (Semantic_Value,X);
    dot_eq: (X, X) -> Token (Semantic_Value,X);
    dot: (X, X) -> Token (Semantic_Value,X);
    pre_dot: (X, X) -> Token (Semantic_Value,X);
    post_dash: (X, X) -> Token (Semantic_Value,X);
    dash_eq: (X, X) -> Token (Semantic_Value,X);
    dash: (X, X) -> Token (Semantic_Value,X);
    pre_dash: (X, X) -> Token (Semantic_Value,X);
    post_caret: (X, X) -> Token (Semantic_Value,X);
    caret_eq: (X, X) -> Token (Semantic_Value,X);
    caret: (X, X) -> Token (Semantic_Value,X);
    pre_caret: (X, X) -> Token (Semantic_Value,X);
    post_buck: (X, X) -> Token (Semantic_Value,X);
    buck_eq: (X, X) -> Token (Semantic_Value,X);
    buck: (X, X) -> Token (Semantic_Value,X);
    pre_buck: (X, X) -> Token (Semantic_Value,X);
    post_bang: (X, X) -> Token (Semantic_Value,X);
    bang_eq: (X, X) -> Token (Semantic_Value,X);
    bang: (X, X) -> Token (Semantic_Value,X);
    pre_bang: (X, X) -> Token (Semantic_Value,X);
    post_back: (X, X) -> Token (Semantic_Value,X);
    back_eq: (X, X) -> Token (Semantic_Value,X);
    back: (X, X) -> Token (Semantic_Value,X);
    pre_back: (X, X) -> Token (Semantic_Value,X);
    post_atsign: (X, X) -> Token (Semantic_Value,X);
    atsign_eq: (X, X) -> Token (Semantic_Value,X);
    atsign: (X, X) -> Token (Semantic_Value,X);
    pre_atsign: (X, X) -> Token (Semantic_Value,X);
    post_amper: (X, X) -> Token (Semantic_Value,X);
    amper_eq: (X, X) -> Token (Semantic_Value,X);
    amper: (X, X) -> Token (Semantic_Value,X);
    pre_amper: (X, X) -> Token (Semantic_Value,X);
    post_lbracket: (X, X) -> Token (Semantic_Value,X);
    lbracket: (X, X) -> Token (Semantic_Value,X);
    post_rbrace: (X, X) -> Token (Semantic_Value,X);
    rbrace: (X, X) -> Token (Semantic_Value,X);
    lbrace: (X, X) -> Token (Semantic_Value,X);
    pre_lbrace: (X, X) -> Token (Semantic_Value,X);
    post_rangle: (X, X) -> Token (Semantic_Value,X);
    rangle: (X, X) -> Token (Semantic_Value,X);
    langle: (X, X) -> Token (Semantic_Value,X);
    pre_langle: (X, X) -> Token (Semantic_Value,X);
    post_bar: (X, X) -> Token (Semantic_Value,X);
    bar_eq: (X, X) -> Token (Semantic_Value,X);
    bar: (X, X) -> Token (Semantic_Value,X);
    pre_bar: (X, X) -> Token (Semantic_Value,X);
    post_dashdash: (X, X) -> Token (Semantic_Value,X);
    dashdash_eq: (X, X) -> Token (Semantic_Value,X);
    dash_dash: (X, X) -> Token (Semantic_Value,X);
    pre_dashdash: (X, X) -> Token (Semantic_Value,X);
    post_plusplus: (X, X) -> Token (Semantic_Value,X);
    plusplus_eq: (X, X) -> Token (Semantic_Value,X);
    plus_plus: (X, X) -> Token (Semantic_Value,X);
    pre_plusplus: (X, X) -> Token (Semantic_Value,X);
    darrow: (X, X) -> Token (Semantic_Value,X);
    exception_t: (X, X) -> Token (Semantic_Value,X);
    esac_t: (X, X) -> Token (Semantic_Value,X);
    eqtype_t: (X, X) -> Token (Semantic_Value,X);
    eqeq_op: (X, X) -> Token (Semantic_Value,X);
    equal_op: (X, X) -> Token (Semantic_Value,X);
    end_t: (X, X) -> Token (Semantic_Value,X);
    elif_t: (X, X) -> Token (Semantic_Value,X);
    else_t: (X, X) -> Token (Semantic_Value,X);
    dotdotdot: (X, X) -> Token (Semantic_Value,X);
    class2_t: (X, X) -> Token (Semantic_Value,X);
    class_t: (X, X) -> Token (Semantic_Value,X);
    case_t: (X, X) -> Token (Semantic_Value,X);
    as_t: (X, X) -> Token (Semantic_Value,X);
    arrow: (X, X) -> Token (Semantic_Value,X);
    api_t: (X, X) -> Token (Semantic_Value,X);
    also_t: (X, X) -> Token (Semantic_Value,X);
    char: ((String), X, X) -> Token (Semantic_Value,X);
    string: ((String), X, X) -> Token (Semantic_Value,X);
    pre_compile_code: ((String), X, X) -> Token (Semantic_Value,X);
    dot_hashets: ((String), X, X) -> Token (Semantic_Value,X);
    dot_slashets: ((String), X, X) -> Token (Semantic_Value,X);
    dot_barets: ((String), X, X) -> Token (Semantic_Value,X);
    dot_brokets: ((String), X, X) -> Token (Semantic_Value,X);
    dot_quotes: ((String), X, X) -> Token (Semantic_Value,X);
    dot_qquotes: ((String), X, X) -> Token (Semantic_Value,X);
    dot_backticks: ((String), X, X) -> Token (Semantic_Value,X);
    backticks: ((String), X, X) -> Token (Semantic_Value,X);
    float: ((String), X, X) -> Token (Semantic_Value,X);
    unt: ((multiword_int::Int), X, X) -> Token (Semantic_Value,X);
    int0: ((multiword_int::Int), X, X) -> Token (Semantic_Value,X);
    int: ((multiword_int::Int), X, X) -> Token (Semantic_Value,X);
    tyvar: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    boguscase_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    postfix_op_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    prefix_op_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    passiveop_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    operators_path: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    operators_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    uppercase_path: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    uppercase_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    mixedcase_path: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    mixedcase_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    lowercase_path: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    lowercase_id: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    implicit_thunk_parameter: ((fast_symbol::Raw_Symbol), X, X) -> Token (Semantic_Value,X);
    semi: (X, X) -> Token (Semantic_Value,X);
    eof: (X, X) -> Token (Semantic_Value,X);
};
api Mythryl_Lrvals{
    package tokens:  Mythryl_Tokens;
    package parser_data: Parser_Data;
    sharing parser_data::token::Token == tokens::Token;
    sharing parser_data::Semantic_Value == tokens::Semantic_Value;
};
