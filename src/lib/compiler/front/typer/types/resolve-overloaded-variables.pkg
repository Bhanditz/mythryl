## resolve-overloaded-variables.pkg 
#
# Here we handle resolution of overloaded variables (operators) like
#
#     + - / *
#
# These variables are originally defined by
#
#     overloaded my ...
#
# statements, e.g. as found in   src/lib/core/init/pervasive.pkg
#
# Note that overloading of literals is a separate mechanism, handled in
#
#     src/lib/compiler/front/typer/types/resolve-overloaded-literals.pkg
#
# Overloading of variables is an ad hoc kludge;  it does not
# fit well with the design of the language, but it is needed
# if use of arithmetic operatiors is not to be unbearably clumsy.
# (Although Ocaml manages without overloading.)
#
# At runtime we get invoked (only) from:
#
#     src/lib/compiler/front/typer/types/unify-and-generalize-types-g.pkg
#

# Compiled by:
#     src/lib/compiler/front/typer/typer.sublib

# Our protocol model here is that the client
# first one by one passes us all overloaded
# variables to be resolved, which we hold
# unresolved in an internal list, and then
# calls us to resolve all of them in batch
# mode.   Consequently we need internal state
# to track the accumulating list.
#
# We implement this by exporting a function
#     make_overloaded_variable_resolver
# which returns a pair of functions which internally
# share a fresh, empty list reference cell in which
# to do the required overloaded variable accumulation:
#


stipulate 
    package err =  error_message;							# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    package syx =  symbolmapstack;							# symbolmapstack		is from   src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack.pkg
    package tdt =  type_declaration_types;						# type_declaration_types	is from   src/lib/compiler/front/typer-stuff/types/type-declaration-types.pkg
    package vac =  variables_and_constructors;						# variables_and_constructors	is from   src/lib/compiler/front/typer-stuff/deep-syntax/variables-and-constructors.pkg
herein
    api Resolve_Overloaded_Variables {
	#
	make_overloaded_variable_resolver
	    :
	    Void
	    ->
	    {   note_overloaded_variable:
		    ( Ref( vac::Variable ),
		      err::Plaint_Sink
		    )
		    ->
		    tdt::Typoid,

		resolve_all_overloaded_variables
		    :
		    syx::Symbolmapstack
		    ->
		    Bool								# TRUE iff we resolved at least one overloaded variable.
	    };
    };
end;


stipulate 
    package ed  =  typer_debugging;							# typer_debugging		is from   src/lib/compiler/front/typer/main/typer-debugging.pkg
    package err =  error_message;							# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    package mtt =  more_type_types;							# more_type_types		is from   src/lib/compiler/front/typer/types/more-type-types.pkg
    package pp  =  standard_prettyprinter;							# standard_prettyprinter		is from   src/lib/prettyprint/big/src/standard-prettyprinter.pkg
    package tdt =  type_declaration_types;						# type_declaration_types	is from   src/lib/compiler/front/typer-stuff/types/type-declaration-types.pkg
    package tj  =  type_junk;								# type_junk			is from   src/lib/compiler/front/typer-stuff/types/type-junk.pkg
    package uj  =  unparse_junk;							# unparse_junk			is from   src/lib/compiler/front/typer/print/unparse-junk.pkg
    package ut  =  unparse_type;							# unparse_type			is from   src/lib/compiler/front/typer/print/unparse-type.pkg
    package vac =  variables_and_constructors;						# variables_and_constructors	is from   src/lib/compiler/front/typer-stuff/deep-syntax/variables-and-constructors.pkg

    # Only needed for debug stuff:
    #
#    package syx =  symbolmapstack;							# symbolmapstack		is from   src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack.pkg
#    package ppv =  prettyprint_value;							# prettyprint_value		is from   src/lib/compiler/front/typer/print/prettyprint-value.pkg
herein

    package   resolve_overloaded_variables
    : (weak)  Resolve_Overloaded_Variables
    {
	say = control_print::say;
#	debugging = REF FALSE;
debugging = log::debugging;
	#
	fun if_debugging_say (msg: String)
            =
            if *debugging
                say msg;
                say "\n";
            fi;

	fun bug msg
            =
            err::impossible ("Overload: " + msg);


        # To see if a given overloaded variable can be
        # matched to a given base variable, we check to
        # see if their types can be unified.
        #
        # Since our unification algorithm proceeds by
        # setting reference variables in the relevant
        # types, if the unification fails we need to
        # have a way to back out the changes introduced
        # by the failed attempt.
        #
        # Here we implement the machinery for doing that.
        #
        # We define a 'Substitution' to be a mapping from
        # type variable references to type variables.
        #
        # By recording in a Substitution the pre-existing values
        # of all type variable references which we change
        # during attempted unification, and then implementing
        # a function to restore all modified references to
        # their pre-existing values by applying that Substitution,
        # we can undo the mess created by a failed unification
        # attempt:

	Substitution
            =
            List( (Ref(tdt::Typevar), tdt::Typevar) );

	exception SOFT_UNIFY;

	# Restore the pre-existing values
        # of a set of typevar refs by
        # applying an accumulated substitution.
        #
	fun undo_substitution (((typevar_ref as REF type), oldtype) ! rest)
		=>
		{   typevar_ref := oldtype;
		    undo_substitution  rest;
		};

	    undo_substitution NIL =>  ();
	end;


        # Attempt unification of type1 with type2.
        #
        # If anything goes wrong, roll back all
        # changes made.
        #
        # Return TRUE if the two unified successfully,
        # otherwise FALSE.
        #
	fun soft_unify
            ( typoid1:	tdt::Typoid,
              typoid2:	tdt::Typoid
            )
            : Bool
            =
	    {	{   unify (typoid1, typoid2);
		    TRUE;
		}
		except
		    SOFT_UNIFY
			=
			{   undo_substitution *substitution;
			    FALSE;
			};
	    }
            where
	        # Initialize a Substitution in which to	
                # record all changes made during unification
                # for possible rollback:
                #
		substitution =   REF NIL:   Ref( Substitution );
                    


		# Set given typevar ref to given type,
                # save its pre-existing value in the
                # above substitution for possible rollback.
                #
                # We also perform the standard unification
                # 'occur' check as we do so, and raise
                # 'SOFT_UNIFY' if we fail:
                #
		fun set_typevar_undoably
                    ( tv as { id, ref_typevar as REF typevar }:  tdt::Typevar_Ref,
                      typoid:	tdt::Typoid
                    )
                    : Void
                    =
		    case typevar
			#
			( tdt::OVERLOADED_TYPEVAR eq
			| tdt::META_TYPEVAR { eq, ... }
			)
			    =>
			    {   scan  eq  typoid;
				#
				substitution :=  (ref_typevar, typevar) ! *substitution;
				ref_typevar  :=  tdt::RESOLVED_TYPEVAR typoid;
			    }
			    where
			        fun scan eq (typoid:  tdt::Typoid): Void				# Simple occurrence check 
				    =
				    case typoid
					#
					tdt::TYPEVAR_REF (tv' as { id => id', ref_typevar => ref_typevar' })
					    => 
					    if (tj::typevar_refs_are_equal (tv, tv'))
						#
						raise exception SOFT_UNIFY;
					    else
						case ref_typevar'
						    #
						    REF (tdt::INCOMPLETE_RECORD_TYPEVAR { known_fields, ... } )
							=>
							#  David B MacQueen: can this happen?   XXX QUERO FIXME
							apply   (fn (_, typoid') = scan eq typoid')   known_fields;

						    _   => ();
						esac;
					    fi;

					tdt::TYPCON_TYPOID (type, args)
					    =>
					    # Check equality property if necessary 
					    #
					    if (not eq)
						#
						apply (scan eq) args;
					    else
						case type
						    #
						    tdt::NAMED_TYPE _
							=> 
							scan eq (tj::head_reduce_typoid typoid);

						    tdt::SUM_TYPE gt
							=>
							case *gt.is_eqtype
							    #
							    tdt::e::YES   =>  apply (scan eq) args;
							    tdt::e::CHUNK =>  apply (scan FALSE) args;
							    _             =>  raise exception SOFT_UNIFY;		# Won't happen 
							esac;

						   _ => raise exception SOFT_UNIFY;				# Won't happen?
						esac;

					    fi;

				       typoid => ();     #  propagate error

				   esac;
			    end;

			_ => raise exception SOFT_UNIFY;
		    esac;




		fun unify
                      ( typoid1:	tdt::Typoid,
                        typoid2:	tdt::Typoid
                      )
                      : Void
                    =
		    {   typoid1 =  tj::drop_resolved_typevars  typoid1;
			typoid2 =  tj::drop_resolved_typevars  typoid2;

			case (typoid1, typoid2)
			    #
			    (tdt::WILDCARD_TYPOID, _) => ();		# Wildcards unify with anything.
			    (_, tdt::WILDCARD_TYPOID) => ();		# Wildcards unify with anything.

			    (tdt::TYPEVAR_REF (tv1), tdt::TYPEVAR_REF (tv2))
				=>
				if (not (tj::typevar_refs_are_equal (tv1, tv2)))
				    #
				    set_typevar_undoably (tv1, typoid2);
				fi;

			    (tdt::TYPEVAR_REF (tv1), _) => set_typevar_undoably (tv1, typoid2);

			    (_, tdt::TYPEVAR_REF (tv2)) => set_typevar_undoably (tv2, typoid1);

			    (tdt::TYPCON_TYPOID (type1, args1), tdt::TYPCON_TYPOID (type2, args2))
				=>
				if (tj::types_are_equal (type1, type2) )
				    #
				    unify_lists (args1, args2);
				else
				    unify (tj::reduce_typoid typoid1, typoid2)
				    except
					tj::BAD_TYPE_REDUCTION
					    => 
					    unify (typoid1, tj::reduce_typoid typoid2)
					    except
						tj::BAD_TYPE_REDUCTION
						    =>
						    raise exception SOFT_UNIFY;
					    end;
				    end;
				fi;

			     _ => raise exception SOFT_UNIFY;
			 esac;
		      }

		  also
		  fun unify_lists ([],[])
                          =>
                          ();

		      unify_lists
                          ( type1 ! rest1,
                            type2 ! rest2
                          )
			  => 
			  {   unify (type1, type2);
                              unify_lists (rest1, rest2);
                          };

		      unify_lists  _
                          =>
                          raise exception SOFT_UNIFY;
                  end;
	      end;								# fun soft_unify

	# We get invoked (only) from:
	#
	#     src/lib/compiler/front/typer/types/unify-and-generalize-types-g.pkg
	#
	fun make_overloaded_variable_resolver ()
	    =
	    { note_overloaded_variable,
              resolve_all_overloaded_variables
            }
            where

	        all_overloaded_variables
                    =
                    REF (NIL: List( (Ref( vac::Variable ), err::Plaint_Sink, tdt::Typoid)) );


		fun note_overloaded_variable (refvar as REF (vac::OVERLOADED_IDENTIFIER { alternatives, typescheme, ... } ), err)
			=> 
			{   my (typescheme, type)
                                =
                                copy_typescheme  typescheme
                                where
				    fun copy_typescheme (typescheme as tdt::TYPESCHEME { arity, ... } ):  (tdt::Typoid, tdt::Typoid)
					=
					{   typevars =  make_type_args arity
                                                        where
							    fun make_type_args  n
								=
								n > 0   ??   tj::make_overloaded_typevar_and_type ["copy_typescheme  from  overloader.pkg"] ! make_type_args (n - 1)
									::   [];
                                                        end;

					    ( tj::apply_typescheme (typescheme, typevars),

					      arity > 1
						  ??   mtt::tuple_typoid typevars
						  ::   head              typevars					# We don't make length-one tuples.
					    );
					};
                                end;


			    all_overloaded_variables
                                := 
                                (refvar, err, type)
                                !
                                *all_overloaded_variables;

			    typescheme;
			};

		    note_overloaded_variable _
                        =>
                        bug "note_overloaded_variable.1";
                end;

		# We implement defaulting behavior:
                # if more than one variant matches the
                # context type, the first one matching
		# (which will always be the first variant)
                # is used as the default:
		#
		fun resolve_all_overloaded_variables  symbolmapstack
                    =
		    {														if_debugging_say "resolve_all_overloaded_variables/AAA     --resolve-overloaded-variables.pkg";
			apply
			    resolve_overloaded_variable
			    *all_overloaded_variables;
																if_debugging_say "resolve_all_overloaded_variables/ZZZ     --resolve-overloaded-variables.pkg";
			((list::length *all_overloaded_variables) > 0);
		    }
		    where
		        fun resolve_overloaded_variable
                                ( var_ref as REF (vac::OVERLOADED_IDENTIFIER { name, alternatives, ... } ),
                                  err:		err::Plaint_Sink,
                                  context:	tdt::Typoid
                                )
				=>
				use_first_match  *alternatives
                                where
				    fun use_first_match ( { variant:	vac::Variable,
							    indicator:	tdt::Typoid						# We will use 'variant' if 'indicator' is type-compatible with the setting of 'var_ref'.
							  }
							  ! rest
							)
					    =>
					    {   (tj::instantiate_if_typescheme  indicator)
                                                    ->
                                                    (sum_type, _);

						if (not (soft_unify (sum_type, context)))
						    #
						    use_first_match rest;   							# This variant does not match -- try next variant.
						else
						    case variant
							#
#							vac::ORDINARY_VARIABLE { var_type as REF (tdt::TYPESCHEME_TYPOID { typescheme_eqflags, typescheme => tdt::TYPESCHEME { arity, body                                    } } ), ... }
#							    =>			 var_type :=      tdt::TYPESCHEME_TYPOID { typescheme_eqflags, typescheme => tdt::TYPESCHEME { arity, body => tj::drop_resolved_typevars body } };

							vac::ORDINARY_VARIABLE { var_type as REF (tdt::TYPESCHEME_TYPOID { typescheme_eqflags, typescheme => tdt::TYPESCHEME { arity, body                                    } } ), ... }
							    =>
							    {
if *log::debugging   printf "REWRITE CASE HIT! Calling   drop_resolved_typevars... [resolve-overloaded-variables.pkg]\n";  fi;
								var_type :=      tdt::TYPESCHEME_TYPOID { typescheme_eqflags, typescheme => tdt::TYPESCHEME { arity, body => tj::drop_resolved_typevars body } };
if *log::debugging   printf "REWRITE CASE HIT! Back from drop_resolved_typevars.   [resolve-overloaded-variables.pkg]\n";  fi;
							    };

							vac::ORDINARY_VARIABLE { var_type as REF (tdt::TYPEVAR_REF t), ... }
							    =>
							    {
if *log::debugging 
printf "non-re-write: vac::ORDINARY_VARIABLE var_type as REF (tdt::TYPEVAR_REF _) ... [resolve-overloaded-variables.pkg]\n";
pp = standard_prettyprinter::make_standard_prettyprinter "/dev/stdout" [];
pps = pp.pp;
prettyprint_value::prettyprint_variable	    pp	    (symbolmapstack, variant);
pp.flush ();
pp.close ();
fi;
							    };

							vac::ORDINARY_VARIABLE { var_type as REF (tdt::TYPESCHEME_ARG _), ... }
							    =>
							    {
if *log::debugging   printf "non-re-write: vac::ORDINARY_VARIABLE var_type as REF (tdt::TYPESCHEME_ARG _) ... [resolve-overloaded-variables.pkg]\n";  fi;
							    };

							vac::ORDINARY_VARIABLE { var_type as REF (tdt::UNDEFINED_TYPOID), ... }
							    =>
							    {
if *log::debugging   printf "non-re-write: vac::ORDINARY_VARIABLE var_type as REF (tdt::UNDEFINED_TYPOID) ... [resolve-overloaded-variables.pkg]\n";  fi;
							    };

							vac::ORDINARY_VARIABLE { var_type as REF (tdt::TYPCON_TYPOID _), ... }
							    =>
							    {
if *log::debugging
printf "non-re-write: vac::ORDINARY_VARIABLE var_type as REF (tdt::TYPCON_TYPOID _) ... [resolve-overloaded-variables.pkg]\n";
pp = standard_prettyprinter::make_standard_prettyprinter "/dev/stdout" [];
pps = pp.pp;
prettyprint_value::prettyprint_variable	    pp	    (symbolmapstack, variant);
pp.flush ();
pp.close ();
fi;
							    };

							vac::ORDINARY_VARIABLE _
							    =>
							    {
if *log::debugging   printf "non-re-write: vac::ORDINARY_VARIABLE... [resolve-overloaded-variables.pkg]\n";  fi;
							    };

							_ => ();
						    esac;

						    var_ref :=  variant;								# Overload successfully resolved.
						fi;
					    };

					use_first_match  NIL
					    =>
					    {   err err::ERROR "overloaded variable not defined at type"
						  (fn stream
						      =
						      {   ut::reset_unparse_type ();
							  #
							  pp::newline    stream;
							  pp::string     stream "symbol: "; 

							  uj::unparse_symbol  stream name;
							  pp::newline    stream;
							  pp::string     stream "type: ";

							  ut::unparse_typoid  symbolmapstack  stream  context;
						      }
						  );

						();
					    };
				    end;
				end;

			    resolve_overloaded_variable _
                                =>
                                bug "overload.2";
                        end;
		    end;
	    end;			# fun new 
    };					# package overload 
end;					# stipulate














##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT 1996 AT&T Bell Laboratories. 
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
