## resolve-overloaded-variables.pkg 
#
# Here we handle resolution of overloaded variables (operators) like
#
#     + - / *
#
# These variables are originally defined by
#
#     overloaded my ...
#
# statements, e.g. as found in   src/lib/core/init/pervasive.pkg
#
# Note that overloading of literals is a separate mechanism, handled in
#
#     src/lib/compiler/front/typer/types/resolve-overloaded-literals.pkg
#
# Overloading of variables is an ad hoc kludge;  it does not
# fit well with the design of the language, but it is needed
# if use of arithmetic operatiors is not to be unbearably clumsy.
# (Although Ocaml manages without overloading.)
#
# At runtime we get invoked (only) from:
#
#     src/lib/compiler/front/typer/types/unify-and-generalize-types-g.pkg
#

# Compiled by:
#     src/lib/compiler/front/typer/typer.sublib

# Our protocol model here is that the client
# first one by one passes us all overloaded
# variables to be resolved, which we hold
# unresolved in an internal list, and then
# calls us to resolve all of them in batch
# mode.   Consequently we need internal state
# to track the accumulating list.
#
# We implement this by exporting a function
#     make_overloaded_variable_resolver
# which returns a pair of functions which internally
# share a fresh, empty list reference cell in which
# to do the required overloaded variable accumulation:
#


stipulate 
    package err =  error_message;							# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    package id  =  inlining_data;							# inlining_data			is from   src/lib/compiler/front/typer-stuff/basics/inlining-data.pkg
    package syx =  symbolmapstack;							# symbolmapstack		is from   src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack.pkg
    package tdt =  type_declaration_types;						# type_declaration_types	is from   src/lib/compiler/front/typer-stuff/types/type-declaration-types.pkg
    package vac =  variables_and_constructors;						# variables_and_constructors	is from   src/lib/compiler/front/typer-stuff/deep-syntax/variables-and-constructors.pkg
herein
    api Resolve_Overloaded_Variables {
	#
	make_overloaded_variable_resolver
	    :
	    (id::Inlining_Data -> Null_Or( tdt::Typoid ))				# inlining_data_to_my_type	from   src/lib/compiler/front/semantic/modules/generics-expansion-junk-parameter.pkg
	    ->
	    {   note_overloaded_variable:
		    ( Ref( vac::Variable ),
		      Ref( List(tdt::Typoid) ),
		      err::Plaint_Sink
		    )
		    ->
		    tdt::Typoid,

		resolve_all_overloaded_variables
		    :
		    syx::Symbolmapstack
		    ->
		    Bool								# TRUE iff we resolved at least one overloaded variable.
	    };
    };
end;


stipulate 
    package ed  =  typer_debugging;							# typer_debugging		is from   src/lib/compiler/front/typer/main/typer-debugging.pkg
    package err =  error_message;							# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    package id  =  inlining_data;							# inlining_data			is from   src/lib/compiler/front/typer-stuff/basics/inlining-data.pkg
    package mtt =  more_type_types;							# more_type_types		is from   src/lib/compiler/front/typer/types/more-type-types.pkg
    package pp  =  standard_prettyprint_mill;						# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package ppt =  prettyprint_type;							# prettyprint_type		is from   src/lib/compiler/front/typer/print/prettyprint-type.pkg
    package td  =  typer_debugging;							# typer_debugging		is from   src/lib/compiler/front/typer/main/typer-debugging.pkg
    package tdt =  type_declaration_types;						# type_declaration_types	is from   src/lib/compiler/front/typer-stuff/types/type-declaration-types.pkg
    package tj  =  type_junk;								# type_junk			is from   src/lib/compiler/front/typer-stuff/types/type-junk.pkg
    package uj  =  unparse_junk;							# unparse_junk			is from   src/lib/compiler/front/typer/print/unparse-junk.pkg
    package ut  =  unparse_type;							# unparse_type			is from   src/lib/compiler/front/typer/print/unparse-type.pkg
    package uyt =  unify_types;								# unify_types			is from   src/lib/compiler/front/typer/types/unify-types.pkg
    package vac =  variables_and_constructors;						# variables_and_constructors	is from   src/lib/compiler/front/typer-stuff/deep-syntax/variables-and-constructors.pkg

    Pp = pp::Pp;

    # Only needed for debug stuff:
    #
#    package syx =  symbolmapstack;							# symbolmapstack		is from   src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack.pkg
#    package ppv =  prettyprint_value;							# prettyprint_value		is from   src/lib/compiler/front/typer/print/prettyprint-value.pkg
herein

    package   resolve_overloaded_variables
    : (weak)  Resolve_Overloaded_Variables
    {
	say = control_print::say;
	debugging = REF FALSE;
	#
	fun if_debugging_say (msg: String)
            =
            if *debugging
                say msg;
                say "\n";
            fi;

	fun bug msg
            =
            err::impossible ("Overload: " + msg);


        # To see if a given overloaded variable can be
        # matched to a given base variable, we check to
        # see if their types can be unified.
        #
        # Since our unification algorithm proceeds by
        # setting reference variables in the relevant
        # types, if the unification fails we need to
        # have a way to back out the changes introduced
        # by the failed attempt.
        #
        # Here we implement the machinery for doing that.
        #
        # We define a 'Substitution' to be a mapping from
        # type variable references to type variables.
        #
        # By recording in a Substitution the pre-existing values
        # of all type variable references which we change
        # during attempted unification, and then implementing
        # a function to restore all modified references to
        # their pre-existing values by applying that Substitution,
        # we can undo the mess created by a failed unification
        # attempt:

	Substitution
            =
            List( (Ref(tdt::Typevar), tdt::Typevar) );

	exception SOFT_UNIFY;

	# Restore the pre-existing values
        # of a set of typevar refs by
        # applying an accumulated substitution.
        #
	fun undo_substitution (((typevar_ref as REF type), oldtype) ! rest)
		=>
		{   typevar_ref := oldtype;
		    undo_substitution  rest;
		};

	    undo_substitution NIL =>  ();
	end;


        # Attempt unification of type1 with type2.
        #
        # If anything goes wrong, roll back all
        # changes made.
        #
        # Return TRUE if the two unified successfully,
        # otherwise FALSE.
        #
	fun soft_unify
            ( typoid1:	tdt::Typoid,
              typoid2:	tdt::Typoid
            )
            : Bool
            =
	    {	{   unify (typoid1, typoid2);
		    TRUE;
		}
		except
		    SOFT_UNIFY
			=
			{   undo_substitution *substitution;
			    FALSE;
			};
	    }
            where
	        # Initialize a Substitution in which to	
                # record all changes made during unification
                # for possible rollback:
                #
		substitution =   REF NIL:   Ref( Substitution );
                    


		# Set given typevar ref to given type,
                # save its pre-existing value in the
                # above substitution for possible rollback.
                #
                # We raise SOFT_UNIFY if the standard unification
                # 'occur' check fails -- for background see:
                #
		#     http://en.wikipedia.org/wiki/Occurs_check
                #
		fun set_typevar_undoably
                    ( tv as { id, ref_typevar as REF typevar }:  tdt::Typevar_Ref,
                      typoid:	tdt::Typoid
                    )
                    : Void
                    =
		    case typevar
			#
			( tdt::OVERLOADED_TYPEVAR eq
			| tdt::META_TYPEVAR { eq, ... }
			)
			    =>
			    {   scan  eq  typoid;
				#
				substitution :=  (ref_typevar, typevar) ! *substitution;
				ref_typevar  :=  tdt::RESOLVED_TYPEVAR typoid;
			    }
			    where
			        fun scan eq (typoid:  tdt::Typoid): Void				# Simple occurrence check 
				    =
				    case typoid
					#
					tdt::TYPEVAR_REF (tv' as { id => id', ref_typevar => ref_typevar' })
					    => 
					    if (tj::typevar_refs_are_equal (tv, tv'))
						#
						raise exception SOFT_UNIFY;
					    else
						case ref_typevar'
						    #
						    REF (tdt::INCOMPLETE_RECORD_TYPEVAR { known_fields, ... } )
							=>
							#  David B MacQueen: can this happen?   XXX QUERO FIXME
							apply   (fn (_, typoid') = scan eq typoid')   known_fields;

						    _   => ();
						esac;
					    fi;

					tdt::TYPCON_TYPOID (type, args)
					    =>
					    # Check equality property if necessary 
					    #
					    if (not eq)
						#
						apply (scan eq) args;
					    else
						case type
						    #
						    tdt::NAMED_TYPE _
							=> 
							scan eq (tj::head_reduce_typoid typoid);

						    tdt::SUM_TYPE gt
							=>
							case *gt.is_eqtype
							    #
							    tdt::e::YES   =>  apply (scan eq) args;
							    tdt::e::CHUNK =>  apply (scan FALSE) args;
							    _             =>  raise exception SOFT_UNIFY;		# Won't happen 
							esac;

						   _ => raise exception SOFT_UNIFY;				# Won't happen?
						esac;

					    fi;

				       typoid => ();     #  propagate error

				   esac;
			    end;

			_ => raise exception SOFT_UNIFY;
		    esac;




		fun unify
                      ( typoid1:	tdt::Typoid,
                        typoid2:	tdt::Typoid
                      )
                      : Void
                    =
		    {   typoid1 =  tj::drop_resolved_typevars  typoid1;
			typoid2 =  tj::drop_resolved_typevars  typoid2;

			case (typoid1, typoid2)
			    #
			    (tdt::WILDCARD_TYPOID, _) => ();		# Wildcards unify with anything.
			    (_, tdt::WILDCARD_TYPOID) => ();		# Wildcards unify with anything.

			    (tdt::TYPEVAR_REF (tv1), tdt::TYPEVAR_REF (tv2))
				=>
				if (not (tj::typevar_refs_are_equal (tv1, tv2)))
				    #
				    set_typevar_undoably (tv1, typoid2);
				fi;

			    (tdt::TYPEVAR_REF (tv1), _) => set_typevar_undoably (tv1, typoid2);

			    (_, tdt::TYPEVAR_REF (tv2)) => set_typevar_undoably (tv2, typoid1);

			    (tdt::TYPCON_TYPOID (type1, args1), tdt::TYPCON_TYPOID (type2, args2))
				=>
				if (tj::types_are_equal (type1, type2) )
				    #
				    unify_lists (args1, args2);
				else
				    unify (tj::reduce_typoid typoid1, typoid2)
				    except
					tj::BAD_TYPE_REDUCTION
					    => 
					    unify (typoid1, tj::reduce_typoid typoid2)
					    except
						tj::BAD_TYPE_REDUCTION
						    =>
						    raise exception SOFT_UNIFY;
					    end;
				    end;
				fi;

			     _ => raise exception SOFT_UNIFY;
			 esac;
		      }

		  also
		  fun unify_lists ([],[])
                          =>
                          ();

		      unify_lists
                          ( type1 ! rest1,
                            type2 ! rest2
                          )
			  => 
			  {   unify (type1, type2);
                              unify_lists (rest1, rest2);
                          };

		      unify_lists  _
                          =>
                          raise exception SOFT_UNIFY;
                  end;
	      end;								# fun soft_unify

	# We get invoked (only) from:
	#
	#     src/lib/compiler/front/typer/types/unify-and-generalize-types-g.pkg
	#
	fun make_overloaded_variable_resolver
		(inlining_data_to_my_type:  id::Inlining_Data -> Null_Or( tdt::Typoid ))
	    =
	    { note_overloaded_variable,
              resolve_all_overloaded_variables
            }
            where

	        all_overloaded_variables
                    =
                    REF (NIL: List( (Ref( vac::Variable ), Ref(List(tdt::Typoid)), err::Plaint_Sink, tdt::Typoid)) );


		fun note_overloaded_variable
			( refvar        as  REF (vac::OVERLOADED_VARIABLE { alternatives, typescheme, ... } ),
			  typescheme_args:  Ref (List(tdt::Typoid)),
			  err
			)
			=> 
			{   my (typescheme, type)
                                =
                                copy_typescheme  typescheme
                                where
				    fun copy_typescheme (typescheme as tdt::TYPESCHEME { arity, ... } ):  (tdt::Typoid, tdt::Typoid)
					=
					{   typevars =  make_type_args arity
                                                        where
							    fun make_type_args  n
								=
								n > 0   ??   tj::make_overloaded_typevar_and_type ["copy_typescheme  from  overloader.pkg"] ! make_type_args (n - 1)
									::   [];
                                                        end;

					    ( tj::apply_typescheme (typescheme, typevars),
					      #
					      arity > 1
						  ??   mtt::tuple_typoid typevars
						  ::   head              typevars					# We don't make length-one tuples.
					    );
					};
                                end;


			    all_overloaded_variables
                                := 
                                (refvar, typescheme_args, err, type)
                                !
                                *all_overloaded_variables;

			    typescheme;
			};

		    note_overloaded_variable _
                        =>
                        bug "note_overloaded_variable.1";
                end;

		# We implement defaulting behavior:
                # if more than one variant matches the
                # context type, the first one matching
		# (which will always be the first variant)
                # is used as the default:
		#
		fun resolve_all_overloaded_variables  symbolmapstack
                    =
		    {														if_debugging_say "resolve_all_overloaded_variables/AAA     --resolve-overloaded-variables.pkg";
			apply
			    resolve_overloaded_variable
			    *all_overloaded_variables;
																if_debugging_say "resolve_all_overloaded_variables/ZZZ     --resolve-overloaded-variables.pkg";
			list::length *all_overloaded_variables  >  0;
		    }
		    where
		        fun resolve_overloaded_variable
                                ( var_ref      as	REF (vac::OVERLOADED_VARIABLE { name, alternatives, ... } ),
				  typescheme_args:	Ref (List(tdt::Typoid)),
                                  err:			err::Plaint_Sink,
                                  context:		tdt::Typoid
                                )
				=>
				use_first_match  *alternatives
                                where
				    fun use_first_match ( { variant:	vac::Variable,
							    indicator:	tdt::Typoid						# We will use 'variant' if 'indicator' is type-compatible with the setting of 'var_ref'.
							  }
							  ! rest
							)
					    =>
					    {
						(tj::instantiate_if_typescheme  indicator)
                                                    ->
                                                    (sum_type, fresh_meta_typevars);						# Ignored arg is fresh_meta_typevars.

																if *debugging
																    pp = standard_prettyprint_mill::make_standard_prettyprint_mill "/dev/stdout" [];
																    prettyprint_typoid =  ppt::prettyprint_typoid  symbolmapstack  pp;

																    pp.lit "resolve_overloaded_variable/use_first_match: variant = ";
																    prettyprint_value::prettyprint_variable  pp (symbolmapstack, variant);
																    pp.lit " -- use_first_match/top in [resolve-overloaded-variables.pkg]\n";

																    pp.lit "resolve_overloaded_variable/use_first_match: indicator = ";
																    prettyprint_typoid  indicator;
																    pp.lit " -- use_first_match/top in [resolve-overloaded-variables.pkg]\n";

																    len =  list::length  fresh_meta_typevars;
																    printf "\nprprinting %d fresh_meta_typevars:   -- use_first_match/top in [resolve-overloaded-variables.pkg]\n"  len;
																    apply prettyprint_typoid  fresh_meta_typevars;
																    printf "\nprprinted  %d fresh_meta_typevars.   -- use_first_match/top in [resolve-overloaded-variables.pkg]\n"  len;

																    pp.lit "Attempting to soft-unify 'sum_type' with 'context' where\n";

																    pp.lit "   sum_type = ";
																    prettyprint_type::prettyprint_typoid  symbolmapstack  pp  sum_type;
																    pp.newline ();

																    pp.lit "   context = ";
																    prettyprint_type::prettyprint_typoid  symbolmapstack  pp  context;
																    pp.newline ();

																    pp.flush();	
																fi;
						if (not (soft_unify (sum_type, context)))
						    #
																if *debugging    printf "soft-unify attempt FAILED  -- use_first_match in [resolve-overloaded-variables.pkg]\n";  fi;
						    use_first_match rest;   							# This variant does not match -- try next variant.
						else
																prettyprint_typoid =  ppt::prettyprint_typoid  symbolmapstack;
																if *debugging
																    printf "soft-unify attempt WORKED  -- use_first_match in [resolve-overloaded-variables.pkg]\n";
																    pp = standard_prettyprint_mill::make_standard_prettyprint_mill "/dev/stdout" [];
																    prettyprint_typoid =  ppt::prettyprint_typoid  symbolmapstack  pp;
																    len =  list::length  fresh_meta_typevars;
																    printf "\nprprinting %d fresh_meta_typevars:   -- use_first_match/WORKED in [resolve-overloaded-variables.pkg]\n"  len;
																    apply prettyprint_typoid  fresh_meta_typevars;
																    printf "\nprprinted  %d fresh_meta_typevars.   -- use_first_match/WORKED in [resolve-overloaded-variables.pkg]\n"  len;
																fi;

						    var_ref		:=  variant;								# Overload successfully resolved.

						    case variant								# This logic added 2013-11-18 CrT -- see Note[1].
							#
							vac::PLAIN_VARIABLE { var_type, inlining_data, ... }
							    =>
							    case (inlining_data_to_my_type  inlining_data)
								#
								THE st =>   {							if *debugging
																    printf "I know why the caged bird sings!\n";
																fi;
																fun if_debugging_prprint_typoid (msg, type)
																    =
																    if *debugging
																	td::with_internals (fn () =  td::debug_print debugging (msg, prettyprint_typoid, type));
																    fi;
		    #

										(tj::instantiate_if_typescheme  st       ) ->  (sty, fresh_meta_typevars);
										(tj::instantiate_if_typescheme  *var_type) ->  (nty, _);
/* */																fun prettyprint_typoid typoid =   if_debugging_prprint_typoid ("", typoid);
																len =  list::length  fresh_meta_typevars;
																if_debugging_say "\nresolve_overloaded_variablevac::PLAIN_VARIABLE/THE st.   [resolve-overloaded-variables.pkg]";

#																if_debugging_unparse_typoid ("\nresolve_overloaded_variable/vac::PLAIN_VARIABLE/THE st   [resolve-overloaded-variables.pkg]: unparse_typoid st  == ", st);
																if_debugging_prprint_typoid ("\nresolve_overloaded_variable/vac::PLAIN_VARIABLE/THE st   [resolve-overloaded-variables.pkg]: prprint_typoid st  == ", st);

#																if_debugging_unparse_typoid ("\nresolve_overloaded_variable/vac::PLAIN_VARIABLE/THE st   [resolve-overloaded-variables.pkg]: unparse_typoid sty == ", sty);
																if_debugging_prprint_typoid ("\nresolve_overloaded_variable/vac::PLAIN_VARIABLE/THE st   [resolve-overloaded-variables.pkg]: prprint_typoid sty == ", sty);

#																if_debugging_unparse_typoid ("\nresolve_overloaded_variable/vac::PLAIN_VARIABLE/THE st   [resolve-overloaded-variables.pkg]: unparse_typoid nty == ", nty);
																if_debugging_prprint_typoid ("\nresolve_overloaded_variable/vac::PLAIN_VARIABLE/THE st   [resolve-overloaded-variables.pkg]: prprint_typoid nty == ", nty);

																if_debugging_say (sprintf "\nprprinting %d fresh_meta_typevars:  resolve_overloaded_variable/vac::PLAIN_VARIABLE [resolve-overloaded-variables.pkg]"  len);
																apply prettyprint_typoid  fresh_meta_typevars;
																if_debugging_say (sprintf "\nprprinted %d fresh_meta_typevars.   resolve_overloaded_variable/vac::PLAIN_VARIABLE [resolve-overloaded-variables.pkg]"  len);

																if_debugging_say "\nresolve_overloaded_variable/vac::PLAIN_VARIABLE II calling unify_types.  [resolve-overloaded-variables.pkg]";

																

										uyt::unify_types
										  ( "sty", "nty", sty, nty,
										    ["resolve_overloaded_variable/vac::PLAIN_VARIABLE"]
										  )
										except
										    _ = {   if *debugging   printf "The bird died. :-(\n";  fi;
											    ();	  #  ??? XXX BUGGO FIXME 
											};
																len =  list::length  fresh_meta_typevars;
																if_debugging_say (sprintf "\nresolve_overloaded_variable/vac::PLAIN_VARIABLE II done calling unify_types%s. [resolve-overloaded-variables.pkg]"
																		  (len > 0 ?? " -- NOW SETTING VARIABLE_IN_EXPRESSION.typescheme_args" :: ""));
																if_debugging_say (sprintf "\npprinting %d fresh_meta_typevars post-unify  resolve_overloaded_variable/vac::PLAIN_VARIABLE [resolve-overloaded-variables.pkg]" len);
																apply prettyprint_typoid  fresh_meta_typevars;
																if_debugging_say (sprintf "\nprprinted %d fresh_meta_typevars post-unify.  resolve_overloaded_variable/vac::PLAIN_VARIABLE [resolve-overloaded-variables.pkg]" len);

										typescheme_args	:=  fresh_meta_typevars;
									    };
								_ =>	    {							if *debugging
																    printf "In a hidden garden a solitary bird sings.\n";
																fi;
									    };
							    esac;

							_   =>		    {							if *debugging
																    printf "Ask not for whom the caged bird sings.\n";
																fi;
									    };
						    esac;
						fi;
					    };

					use_first_match  NIL
					    =>
					    {   err err::ERROR "overloaded variable not defined at type"
						  (fn (pp:Pp)
						      =
						      {   ut::reset_unparse_type ();
							  #
							  pp.newline ();
							  pp.lit "symbol: "; 

							  uj::unparse_symbol  pp name;
							  pp.newline ();
							  pp.lit "type: ";

							  ut::unparse_typoid  symbolmapstack  pp  context;
						      }
						  );

						();
					    };
				    end;
				end;

			    resolve_overloaded_variable _
                                =>
                                bug "overload.2";
                        end;
		    end;
	    end;			# fun new 
    };					# package overload 
end;					# stipulate



###########################################################################################
# Note[1]
# We had a problem in that
#
#     v = "abc";
#     string::get (v,1);
#
# would work as expected but
#
#     v = "abc";
#     overloaded my bar: ((X, Y) -> Z) =  (string::get);
#     bar(v,1);
#
# would die with
#
#     Unexpected type for hbo::GET_VECSLOT_NUMERIC_CONTENTS -- list::length(uniqtypes) == 0, expected 2
#     Error: Compiler bug: translate_deep_syntax_to_lambdacode: unexpected type for hbo::GET_VECSLOT_NUMERIC_CONTENTS
#
# This appeared to be due to ds::VARIABLE_IN_EXPRESSION.typescheme_args
# not getting set as expected.  Specifically, in
#
#     src/lib/compiler/front/typer/types/unify-and-generalize-types-g.pkg
#
# we had 
#					case (inlining_data_to_my_type  inlining_data)						# For builtins like string::get, inlining_data was set up from   all_primops   in   src/lib/compiler/front/semantic/symbolmapstack/base-types-and-ops.pkg
#					    #
#					    THE st =>   {   (tj::instantiate_if_typescheme  st       ) ->  (sty, fresh_meta_typevars);
#							    [...]
#								  typescheme_args =>  REF fresh_meta_typevars
#
# which results in typescheme_args remembering the types to which
# string::get (== numsubscript8cv) gets applied, but nothing like
# that was happening in this file during overloading resolution.









##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT 1996 AT&T Bell Laboratories. 
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
