## type-type.pkg -- typecheck a type.

# Compiled by:
#     src/lib/compiler/front/typer/typer.sublib

# The center of the typer is
#
#      src/lib/compiler/front/typer/main/type-package-language-g.pkg
# 
#  -- see it for a higher-level overview.
#  It calls us to do specialized typechecking
#  of types.
#



###           "The future just ain't what it use to be
###             -- and what's more it never was."
###
###                             -- Lee Hays



stipulate
    package bt  =  type_types;							# type_types			is from   src/lib/compiler/front/typer/types/type-types.pkg
    package ds  =  deep_syntax;							# deep_syntax			is from   src/lib/compiler/front/typer-stuff/deep-syntax/deep-syntax.pkg
    package err =  error_message;						# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    package fst =  find_in_symbolmapstack;					# find_in_symbolmapstack	is from   src/lib/compiler/front/typer-stuff/symbolmapstack/find-in-symbolmapstack.pkg
    package ip  =  inverse_path;						# inverse_path			is from   src/lib/compiler/front/typer-stuff/basics/symbol-path.pkg
    package raw =  raw_syntax; 							# raw_syntax			is from   src/lib/compiler/front/parser/raw-syntax/raw-syntax.pkg
    package sta =  stamp;							# stamp				is from   src/lib/compiler/front/typer-stuff/basics/stamp.pkg
    package sxe =  symbolmapstack_entry;					# symbolmapstack_entry		is from   src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack-entry.pkg
    package sy  =  symbol;							# symbol			is from   src/lib/compiler/front/basics/map/symbol.pkg
    package syp =  symbol_path;							# symbol_path			is from   src/lib/compiler/front/typer-stuff/basics/symbol-path.pkg
    package syx =  symbolmapstack;						# symbolmapstack		is from   src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack.pkg
    package trs =  typer_junk;							# typer_junk			is from   src/lib/compiler/front/typer/main/typer-junk.pkg
    package ts  =  type_junk;							# type_junk			is from   src/lib/compiler/front/typer-stuff/types/type-junk.pkg
    package tvs =  type_variable_set;						# type_variable_set		is from   src/lib/compiler/front/typer/main/type-variable-set.pkg
    package tdt =  type_declaration_types;					# type_declaration_types	is from   src/lib/compiler/front/typer-stuff/types/type-declaration-types.pkg
herein


    package   type_type
    : (weak)  Type_Type								# Type_Type		is from   src/lib/compiler/front/typer/main/type-type.api
    {
#	debugging   =   typer_control::typecheck_type_debugging;		# eval:  set_control "typechecker::typecheck_type_debugging" "TRUE";
debugging = log::debugging;
	say         =   control_print::say;
	#
	fun if_debugging_say (msg: String)
	    =
	    if   *debugging
                say msg;
                say "\n";
	    fi;
	#
	fun bug msg
	    =
	    error_message::impossible ("type_type: " + msg);
	#
        fun unparse_typoid
            (
              msg:		String,
              typoid:		tdt::Typoid,
              symbolmapstack:	syx::Symbolmapstack
            )
            =
            if *debugging
		print "\n";
                print msg;
                pp = prettyprinter::make_file_prettyprinter "/dev/stdout";

                pps = pp.stream;

                unparse_type::unparse_typoid  symbolmapstack  pps  typoid;

                pp.flush ();
                pp.close ();
		print "\n";
            fi;



	##### TYPES #####

	my --> =  bt::(-->);

	infix my  --> ;
	#
	fun typecheck_type_variable (
                type_variable:       raw::Type_Variable,
                error_function,
                source_code_region:  ds::Source_Code_Region
            )
	    =
	    case type_variable

	         raw::TYPE_VARIABLE  type_variable_symbol		# X
		     =>
		     tdt::make_type_variable_ref
                       (
                         ts::make_user_type_variable  type_variable_symbol,
                         ["typecheck_type_variable  from  type-type.pkg"]
                       );

	         raw::SOURCE_CODE_REGION_FOR_TYPE_VARIABLE (type_variable, source_code_region)
		     =>
		     typecheck_type_variable (type_variable, error_function, source_code_region);
            esac;
	#
	fun type_typevar_list (type_variables, error_function, source_code_region)
            =
            type_variables
            where 

	        type_variables
                    =
                    map (fn type_variable =  typecheck_type_variable (type_variable, error_function, source_code_region))
                         type_variables;

		names = map (   fn { id, ref_typevar => REF (tdt::USER_TYPE_VARIABLE { name, ... } ) }
					=>
					name;

				    _   =>   bug "type_typevar_list";
                                end 
                            )
                            type_variables;

		trs::forbid_duplicates_in_list (
                    (error_function source_code_region),
                    "duplicate type variable name",
                    names
                );
	    end;



	# We get invoked from various places in
	#     src/lib/compiler/front/typer/main/type-core-language.pkg
        #
	fun type_type
            (
	      raw_syntax_tree:     raw::Any_Type,
	      symbolmapstack:         syx::Symbolmapstack,
	      error_function:      error_message::Error_Function,
	      source_code_region:  ds::Source_Code_Region
	    )
	    :
            ( tdt::Typoid,
              tvs::Type_Variable_Set
            )
	    =
	    case raw_syntax_tree   

		raw::TYPE_VARIABLE_TYPE type_variable
		    => 
		    {   type_variable
                            =
                            typecheck_type_variable
                                (type_variable, error_function, source_code_region);

			( tdt::TYPE_VARIABLE_REF  type_variable,
			  tvs::singleton         type_variable
			);
		    };

		raw::TYPE_TYPE (constructor_list, types)
		    => 
		    {   constructor1
			    = 
			    if ((sy::name (head constructor_list)) == "->")
				#
				bt::arrow_typ;
			    else
				fst::find_typ_via_symbol_path_and_check_arity
                                  (
				    symbolmapstack,
				    syp::SYMBOL_PATH constructor_list,
				    length types,
				    error_function  source_code_region
				  );
			    fi;

			(typecheck_type_list (types, symbolmapstack, error_function, source_code_region))
			    ->
			    (lambda_types1, lambda_variable_type1);

			( ts::make_constructor_typoid (constructor1, lambda_types1),
			  lambda_variable_type1
			);
		    };

		raw::RECORD_TYPE labels         #  (symbol*Any_Type) List 
		    => 
		    {   (typecheck_tlabel (labels, symbolmapstack, error_function, source_code_region))
			    ->
			    (lbs1, lvt1);

			( bt::record_typoid (trs::sort_record (lbs1, error_function source_code_region)),
			  lvt1
			);
		    };

		raw::TUPLE_TYPE types
		    =>
		    {   (typecheck_type_list (types, symbolmapstack, error_function, source_code_region))
			    ->
			    (lts1, lvt1);

			( bt::tuple_typoid lts1,
			  lvt1
			);
		    };

		raw::SOURCE_CODE_REGION_FOR_TYPE (type, source_code_region)
		    =>
		    type_type
                        (type, symbolmapstack, error_function, source_code_region);
            esac



	also
	fun typecheck_tlabel (labels, symbolmapstack, error_function, source_code_region:  ds::Source_Code_Region)
	    =
	    fold_backward 
	      (   fn (   ( lb2, t2),
                         (lts2, lvt2)
                     )
                     =
		     {   (type_type (t2, symbolmapstack, error_function, source_code_region))
			     ->
			     (t3, lvt3);

			 ( (lb2, t3) ! lts2,
			   tvs::union (lvt3, lvt2, error_function source_code_region)
			 );
		     }
              )
	      ([], tvs::empty)
              labels

	also
	fun typecheck_type_list (ts, symbolmapstack, error_function, source_code_region:  ds::Source_Code_Region)
	    =
	    fold_backward 
	      (   fn (t2, (lts2, lvt2))
                     =
		     {   (type_type (t2, symbolmapstack, error_function, source_code_region))
			     ->
			     (t3, lvt3);

                         ( t3 ! lts2,
                           tvs::union (lvt3, lvt2, error_function source_code_region)
                         );
		     }
              )
	      ([], tvs::empty)
              ts;


	# *** VALCON DECLARATIONS ***

	exception ISREC;
	#
	fun typecheck_named_constructor (
                (typ, args, name, def, source_code_region, is_lazy),
                symbolmapstack,
                inverse_path: ip::Inverse_Path,
                error_function
            )
	    =
	    {   rhs = ts::make_constructor_typoid   (typ,   map tdt::TYPE_VARIABLE_REF args);
		#
		unparse_typoid ("typecheck_named_constructor processing: ", rhs, symbolmapstack );

		#
		fun checkrec (_, NULL)
                        =>
                        ();

		    checkrec (_, THE type)
			=> 
		        findname type
                        where
			    fun findname (raw::TYPE_VARIABLE_TYPE _)
                                    =>
                                    ();

				findname (raw::TYPE_TYPE ([co], ts))
				    => 
				    if (not (symbol::eq (co, name)))
					#				         
					apply findname ts;
				    else
					(raise exception ISREC); 
				    fi;

				findname (raw::TYPE_TYPE (_, ts))    => apply findname ts;
				findname (raw::RECORD_TYPE  lbs)    => apply   (fn (_, t) =  findname t)   lbs;
				findname (raw::TUPLE_TYPE  ts)	    => apply findname ts;

				findname (raw::SOURCE_CODE_REGION_FOR_TYPE (t, _)) => findname t;
			    end;
			end;
		end;
		#
		fun typecheck_constr (name,  THE type)
			=>
			{   (type_type (type, symbolmapstack, error_function, source_code_region))
				->
				(t, type_variable);

			    ( (name, FALSE, (t --> rhs)),
			      type_variable
			    );
			};

		    typecheck_constr (name, NULL)
			=>
			( (name, TRUE, rhs),
			  tvs::empty
			);
		end;

		arity   =   length args;

		is_recursive
		    =
		    {   apply checkrec def;
			FALSE;
		    }
		    except
			ISREC = TRUE;

		my (dcl, type_variables)
		    = 
		    fold_backward
		        (   fn (d, (dcl1, type_variables1))
				=
				{   (typecheck_constr d)
					->
					(dc2, type_variable2);

				    ( dc2 ! dcl1,
				      tvs::union (type_variable2, type_variables1, error_function source_code_region)
				    );
				}
		        )
		        ([], tvs::empty)
		        def;

		trs::check_bound_type_variables (type_variables, args, error_function source_code_region);
		ts::resolve_type_variables_to_typescheme_slots args;

		sdcl   =   trs::sort3 dcl;

		(pick_valcon_form::infer is_recursive  sdcl)
		    ->
		    (reps, signature);

		#
		fun bind_dcons ((name, is_constant, typoid), form)
		    =
		    {   ts::drop_macro_expanded_indirections_from_type  typoid;
			#
		        typoid =    if (arity <= 0)
					#	
					typoid;
				    else
					tdt::TYPE_SCHEME_TYPOID
					  {
					    type_scheme_arg_eq_properties
						=>
						ts::make_typeagnostic_api  arity,

					    type_scheme
						=>
						tdt::TYPE_SCHEME
						  { arity,
						    body  => typoid
						  }
					  };
				    fi;

		       tdt::VALCON
			 {
			   typoid,
			   is_lazy,
			   name,
			   is_constant,
			   #	
			   form,
			   signature
			 };
		    };
		#
		fun bind_dconslist
			( (r1 as (name, _, _))  !  l1,
			   r2                   !  l2
			)
			=>
			{   dcon =   bind_dcons (r1, r2);
			    #
			    (bind_dconslist (l1, l2))
				->
				(dcl, e2);

			    (   dcon ! dcl,
				syx::bind (
				    name,
				    sxe::NAMED_CONSTRUCTOR dcon,
				    e2
				)
			    );
			};

		    bind_dconslist ([],[]) =>   ([], syx::empty);
		    bind_dconslist _       =>   bug "typecheckDB::bindDconslist";
		end;


		if (length sdcl < length dcl)    #  Duplicate constructor names 
		    #	
		    fun member (x: String,   []) =>   FALSE;
			member (x,        y ! r) =>   (x == y)   or   member (x, r);
		    end;
		    #
		    fun dups (  [], l)
			    =>
			    l;

			dups (x ! r, l)
			    =>
			    if   (member (x, r)   and   not (member (x, l)))
				 dups (r, x ! l);
			    else dups (r,     l);
			    fi;
		    end;
		    #
		    fun add_commas []          =>   [];
			add_commas (y as [_])  =>   y;
			add_commas (s ! r)      =>   s ! ", " ! add_commas (r);
		    end;

		    duplicates
			=
			dups (map (fn (n, _, _) => sy::name n; end ) dcl,[]);


		    error_function
			source_code_region
			err::ERROR
			(   cat [
				"sumtype ",
				sy::name name,
				" has duplicate constructor name (s): ",
				cat (add_commas (duplicates))
			    ]
			)
			err::null_error_body;
		fi;

		bind_dconslist (sdcl, reps);
	    };


	# *** TYPE DECLARATIONS ***
		    #
	fun typecheck_named_types (
		named_types:     List( raw::Named_Type ),
		notwith: Bool,
		symbolmapstack0,
                inverse_path,
		source_code_region,
		{ make_fresh_stamp, error_fn, ... }: trs::Per_Compile_Info
	    )
	    :
            ( List( tdt::Type ),
              List( sy::Symbol ),
              syx::Symbolmapstack
            )
	    =
	    {   fun typecheck_named_type (
                        tb: raw::Named_Type,
                        symbolmapstack,
                        source_code_region
                    )
                    : (tdt::Type, sy::Symbol)
		    =
		    case tb
			#
			raw::NAMED_TYPE   { name_symbol,   definition,   type_variables }
			    =>
			    {   type_variables =   type_typevar_list  (type_variables, error_fn, source_code_region);
				#
				(type_type  (definition, symbolmapstack, error_fn, source_code_region))
				    ->
				    (type, type_variable);

				arity   =   length type_variables;

				trs::check_bound_type_variables (type_variable, type_variables, error_fn source_code_region);

				ts::resolve_type_variables_to_typescheme_slots  type_variables;

				ts::drop_macro_expanded_indirections_from_type  type;
																if_debugging_say "typecheck_named_type() introducing DEFINED_TYP  -- type-type.pkg\n";
				typ =   tdt::NAMED_TYPE  { stamp  =>  make_fresh_stamp (),
							    path   =>  ip::extend (inverse_path, name_symbol),
							    strict =>  trs::calculate_strictness (arity, type),
							    #
							    type_scheme => tdt::TYPE_SCHEME { arity, body=>type }
							  };

				(typ, name_symbol);
			    };

			raw::SOURCE_CODE_REGION_FOR_NAMED_TYPE (tb', source_code_region')
			    =>
			    typecheck_named_type (tb', symbolmapstack, source_code_region');
                    esac;

                loop (named_types, NIL, NIL, syx::empty)
                where
		    fun loop (NIL, typs, names, symbolmapstack)
			    =>
			    ( reverse typs,
			      reverse names,
			      symbolmapstack
			    );

			loop (named_type ! rest, typs, names, symbolmapstack)
			    =>
			    {  symbolmapstack'
				    =
				    if notwith      symbolmapstack0;
				    else            syx::atop (symbolmapstack, symbolmapstack0);
                                    fi;

				(typecheck_named_type (named_type, symbolmapstack', source_code_region))
				    ->
				    (typ, name);

				loop (
				    rest,
				    typ ! typs,
				    name ! names,
				    syx::bind (name, sxe::NAMED_TYPE typ, symbolmapstack)
				);
			    };
		    end;
		end;
	    };
	#
	fun type_type_declaration (
                named_types: List( raw::Named_Type ),
                symbolmapstack,
                inverse_path,
                source_code_region,
		per_compile_info as { error_fn, make_fresh_stamp, ... }: trs::Per_Compile_Info
            )
	    : (ds::Declaration, syx::Symbolmapstack)
	    =
	    {															if_debugging_say ">>type_type_declaration";
		my (typs, names, symbolmapstack')
                    =
		    typecheck_named_types (
                        named_types,
                        TRUE,
                        symbolmapstack,
                        inverse_path,
                        source_code_region,
                        per_compile_info
                    );
																if_debugging_say "--type_type_declaration: typecheck_named_types done";
                trs::forbid_duplicates_in_list   (error_fn source_code_region,   "duplicate type definition",   names);
																if_debugging_say "<<type_type_declaration";
		(ds::TYPE_DECLARATIONS typs,   symbolmapstack');
	    };
	#
	fun type_sumtype_declaration
              (
                { union_types, with_typs },
                symbolmapstack0,
                api_context, 
	        api_typerstore,
                is_free,
                inverse_path,
                source_code_region, 
	        per_compile_info as { make_fresh_stamp, error_fn, ... }:   trs::Per_Compile_Info
              )
	    =
	    {   #  predefine sumtypes 
																if_debugging_say ">>type_sumtype_declaration";
		#
		fun preprocess
                        source_code_region
                        (   raw::UNION_TYPE {
                                name_symbol       =>  name,
                                right_hand_side   =>  raw::VALCONS  definition,
                                type_variables,
                                is_lazy
                            }
                        )
			=> 
			{   type_variables
				=
				type_typevar_list
				    (type_variables, error_fn, source_code_region);

			    strict_name
				=
				if is_lazy     sy::make_type_symbol (sy::name name + "!");
				else           name;
                                fi;

			    typ =    tdt::UNION_TYPE
					  {
					    path  =>  ip::extend (inverse_path, strict_name),
					    arity =>  length type_variables,
					    stamp =>  make_fresh_stamp(),
					    eqtype_info =>  REF tdt::eq_type::DATA,
					    kind  =>  tdt::TEMP,
					    stub  =>  NULL
					  };

			    binddef =   if (not  is_lazy)
					    #	
					    typ;
					else
					    tdt::NAMED_TYPE
					      {
						stamp  => make_fresh_stamp(),
						#
						path   => ip::extend (inverse_path, name),
						#
						strict => map   (fn _ = TRUE)   type_variables,
						#
						type_scheme => tdt::TYPE_SCHEME {
								   arity => length type_variables,
								   body  => tdt::TYPCON_TYPOID (
									       bt::suspension_typ,
									       [   tdt::TYPCON_TYPOID (
										       typ,
										       map tdt::TYPE_VARIABLE_REF type_variables
										   )
									       ]
									   )
							       }
					     };
					fi;

			    THE {
				type_variables,
				name,
				definition,

				binddef,
				is_lazy,

				source_code_region,
				typ,
				strict_name
			    };
			};

		    preprocess source_code_region (raw::UNION_TYPE { name_symbol     =>  name,
                                                                     right_hand_side =>  raw::REPLICAS _,
                                                                     ...
                                                                   }
                                                  )
			=> 
			{   error_fn
				source_code_region
				err::ERROR
				("sumtype replication mixed with regular sumtypes:" + sy::name name)
				err::null_error_body;

			    NULL;
			};

		    preprocess _ (raw::SOURCE_CODE_REGION_FOR_UNION_TYPE (db', source_code_region'))
			=>
			preprocess source_code_region' db';
                end;

		dbs = list::map_partial_fn
                          (preprocess source_code_region)
                          union_types;
																if_debugging_say "--type_sumtype_declaration: preprocessing done";
		env_dtyps         #  symbolmapstack containing preliminary union_types 
                    =
		    fold_forward
                        (fn ( { name, binddef, ... }, symbolmapstack)
                            =
			    syx::bind (name, sxe::NAMED_TYPE binddef, symbolmapstack)
                        )
			syx::empty
                        dbs;
																if_debugging_say "--type_sumtype_declaration: envDTyps defined";


		#  Typecheck associated with_typs: 

		my (with_typs, withtyc_names, env_wtyps)
                    = 
		    typecheck_named_types (
                        with_typs,
                        FALSE,
                        syx::atop (env_dtyps, symbolmapstack0),
			inverse_path,
                        source_code_region,
                        per_compile_info
                    );
																if_debugging_say "--type_sumtype_declaration: with_typs elaborated";


		#  Check for duplicate typ names: 

                trs::forbid_duplicates_in_list (
                    error_fn source_code_region,
		    "duplicate type names in type declaration",
	            map .name dbs @ withtyc_names
                    );
																if_debugging_say "--type_sumtype_declaration: uniqueness checked";

		#  Add lazy auxiliary with_typs if any: 

		with_typs
                    =
                    map .binddef
                       (list::filter .is_lazy dbs) @ with_typs;



		# symbolmapstack containing only new
                # union_types and with_typs:

		env_typs   =   syx::atop (env_wtyps, env_dtyps);



		# symbolmapstack for evaluating the
                # Constructor types:

		full_symbolmapstack   =   syx::atop (env_typs, symbolmapstack0);
																if_debugging_say "--type_sumtype_declaration: envTyps, fullSymbolmapstack defined";
		prelim_dtyps   =   map .typ dbs;



		# Nomenclature:  "Definition of SML" calls typcons from apis "flexible" an all others "rigid".
		#
		# The following functions pull out all the flexible components
		# inside the domains of the sumtypes, and put them into the
		# free_types field in the SUMTYPE kind; this way, future 
		# re-instantiations of the sumtypes only need to modify the
		# free_types list, rather than all the domains (ZHONG)


		free_typs_ref
                    =
                    REF  ([]:  List( tdt::Type ),   0);
		#
		fun reg_free typ
                    = 
                    h (ss, n)
                    where
		        (*free_typs_ref) ->  (ss, n);
                            
			#
			fun h (x ! rest, i)
				=> 
				if (ts::typs_are_equal (typ, x))
				    #				    
				    tdt::FREE_TYPE (i - 1);
				else
				    h (rest, i - 1);
				fi;

			    h ([], _)
				=> 
				{   (free_typs_ref := (typ ! ss, n+1));
				    #
				    tdt::FREE_TYPE n;
				};
                        end;
		    end;
		#
		fun translate_typ (typ as tdt::UNION_TYPE { kind => tdt::TEMP, ... } )
			=>
			g (typ, 0, prelim_dtyps)
                        where
			    fun g (typ, i, x ! rest)
				    =>
				    if (ts::typs_are_equal (typ, x))
					#				        
					tdt::RECURSIVE_TYPE i;
				    else
					g (typ, i+1, rest);
				    fi;

			        g (typ, _, NIL)
                                    =>
                                    typ;
                            end;
			end;

		   translate_typ (typ as tdt::UNION_TYPE _)
			=> 
			if (is_free typ   )   reg_free typ;
			else                              typ;
                        fi;

		   translate_typ (typ as (tdt::NAMED_TYPE _ | tdt::TYPE_BY_STAMPPATH _))
			=> 
			if (is_free typ)   reg_free typ;
			else                        typ;
                        fi;

		   translate_typ typ
			=>
			typ;
                end;

		#
		fun translate_typoid type
                    = 
		    case (ts::head_reduce_typoid  type)
			#
		        tdt::TYPCON_TYPOID (typ, args)
			    =>
			    tdt::TYPCON_TYPOID (translate_typ typ, map translate_typoid args);

		        tdt::TYPE_SCHEME_TYPOID { type_scheme_arg_eq_properties, type_scheme => tdt::TYPE_SCHEME { arity, body } }
			    =>
			    tdt::TYPE_SCHEME_TYPOID {
				type_scheme_arg_eq_properties,
				type_scheme => tdt::TYPE_SCHEME {
						   arity,
						   body  => translate_typoid body
					       }
			    };

		        type => type;
                    esac;



		#  Typecheck the definition of a sumtype: 
		#
		fun typecheck_right_hand_side (
                        {   type_variables,
                            name,
                            definition,
                            source_code_region,
                            typ,
                            is_lazy,
                            binddef,
                            strict_name
                        },
			(i, done)
                    )
                    = 
		    {   my (valcons, _)
                            = 
			    typecheck_named_constructor (
                                (   typ,
                                    type_variables,
                                    name,
                                    definition,
                                    source_code_region,
                                    is_lazy
                                ),
                                full_symbolmapstack,
                                inverse_path,
                                error_fn
                            );
			#
			fun make_dcon_desc (tdt::VALCON { name, is_constant, form, signature, typoid, is_lazy } )
                            = 
			    {   name,
                                form,
			        domain         =>   if is_constant
							#
							NULL;
						    else
							case (translate_typoid  typoid)
							    #
							    tdt::TYPCON_TYPOID (_, [dom, _])
								=>
								THE dom;

							    tdt::TYPE_SCHEME_TYPOID
								{
								  type_scheme =>  tdt::TYPE_SCHEME {
								  body        =>  tdt::TYPCON_TYPOID (_, [dom, _]), ... },
								  ...
								}
								=>
								THE dom;

							   _ => bug "typecheck_right_hand_side";
						       esac;
						    fi
                            };

                        (   i+1,
			    {   index       =>  i,

				is_lazy,
			        name,
				typ,
				strict_name,

				dcon_names  =>  map   (fn tdt::VALCON { name, ... } = name)   valcons,
				dcons       =>  valcons,
				dcon_descs  =>  map  make_dcon_desc  valcons

                            } ! done
                        );
		    };

		my (_, dbs')
                    =
                    fold_forward
                         typecheck_right_hand_side
                         (0, NIL)
                         dbs;

		dbs'   =   reverse dbs';

																if_debugging_say "--type_sumtype_declaration: RHS elaborated";
		#
		fun make_member
			{
			  name,
			  dcon_descs,
			  dcon_names,
			  index,
			  is_lazy,
			  strict_name,
			  dcons  =>  tdt::VALCON { signature, ... } ! _,
			  typ =>  tdt::UNION_TYPE { stamp, arity, eqtype_info, ... }
			}
			=>
			#  Extract common signature from first Constructor 

			( stamp,
			  { constructor_list => dcon_descs,
			     arity,
			     eqtype_info,
			     is_lazy,
			     type_name => strict_name,
			     an_api        => signature
			  }
			);

		    make_member _   =>   bug "makeMember";
                end;

		(paired_lists::unzip (map make_member dbs'))
		    ->
		    (mstamps, members);

		nstamps =   vector::from_list  mstamps;

		nfamily
                    =
                    { members       => vector::from_list members,
		      property_list => property_list::make_property_list (),
		      mkey          => make_fresh_stamp()
                    };

		nfreetyps
                    = 
		    {   (*free_typs_ref) ->   (x, n);
			#
                        if (length x != n)   #  Sanity check 
			    bug "unexpected nfreetyps in type_sumtype_declaration";
                        fi;

                        reverse x; 
		    };

																if_debugging_say "--type_sumtype_declaration: members defined";
		#
		fun fix_dtyc {
                        name,
                        index,
		        typ as tdt::UNION_TYPE { path, arity, stamp, eqtype_info, kind, stub },
			dcon_names,
                        dcons,
                        dcon_descs,
                        is_lazy,
                        strict_name
                    }
                    =>
		      { old  => typ,
			name => strict_name,
			#
		        new  => tdt::UNION_TYPE
				  {
			           stub  => NULL,
                                   path,
                                   arity,
				   # 
                                   stamp,
                                   eqtype_info,
				   # 
				   kind  => tdt::SUMTYPE
                                              {
						index,
						stamps       =>  nstamps,
						family       =>  nfamily,
						#
						free_types =>  nfreetyps,
						root         =>  NULL
                                              }
                               }
                      };

		   fix_dtyc _ => bug "fixDtyc"; end;

		dtycmap =   map fix_dtyc dbs';											# Map preliminary to final union_types 

																if_debugging_say "--type_sumtype_declaration: fixDtyps done";
		final_dtyps   =   map .new dtycmap;
																if_debugging_say "--type_sumtype_declaration: finalDtyps defined";
                eq_types::define_eq_props (final_dtyps, api_context, api_typerstore);
																if_debugging_say "--type_sumtype_declaration: defineEqProps done";
		#
		fun apply_map m
                    =
                    f
                    where
		        fun same_type_identifier
				( tdt::UNION_TYPE g1,
				  tdt::UNION_TYPE g2
				)
				=>
				sta::same_stamp
                                  ( g1.stamp,
				    g2.stamp
				  );

			    same_type_identifier
                                ( typ1 as tdt::NAMED_TYPE _,
                                  typ2 as tdt::NAMED_TYPE _
                                )
				=>
				ts::typ_equality (typ1, typ2);  

			    same_type_identifier _
                                =>
                                FALSE;
                        end;
			#
			fun f (tdt::TYPCON_TYPOID (typ, args))
				=>
				tdt::TYPCON_TYPOID
				  ( get m,
				    map  (apply_map m)  args
				  )
				where
				    fun get ( { old, new, name } ! rest)
					    => 
					    if (same_type_identifier (old, typ))
						 new;
					    else
						 get rest;
					    fi;

					get NIL
					    =>
					    typ;
				    end;
				end;

			    f (   tdt::TYPE_SCHEME_TYPOID
                                    {
                                      type_scheme_arg_eq_properties,
                                      type_scheme => tdt::TYPE_SCHEME { arity, body }
                                    }
                              )
				=>
				tdt::TYPE_SCHEME_TYPOID {
				    type_scheme_arg_eq_properties,

				    type_scheme => tdt::TYPE_SCHEME { arity,
								 body  => f body
							       }
				};

			    f t   =>   t;
                        end;
		    end;
		#
		fun aug_tycmap
			( typ as
			      tdt::NAMED_TYPE {
				  stamp,
				  strict,
				  path,
				  type_scheme => tdt::TYPE_SCHEME { arity, body }
			      },
			  tycmap
			)
			=>
			{ old  => typ,

			  name => ip::last path,

			  new  => tdt::NAMED_TYPE
				    {
				      strict,
				      stamp,
				      path,
				      #
				      type_scheme => tdt::TYPE_SCHEME
                                                       {
							 arity,
							 body  => apply_map tycmap body
						       }
				    }
			}
			! tycmap;

		    aug_tycmap _
			=>
			bug "aug_tycmap";
                end;

		# Use fold_forward to process the
                # with_typs in their
                # original order:
                # 
		alltycmap
                    =
                    fold_forward
                        aug_tycmap
                        dtycmap
                        with_typs;

																if_debugging_say "--type_sumtype_declaration: alltycmap defined";
		#
		fun header (_,     0, z)  =>  z;
		    header (a ! r, n, z)  =>  header (r, n - 1, a ! z);
		    header (  [],  _, _)  =>  bug "header2 in type_sumtype_declaration";
                end;

		final_withtyps =   map .new (header (alltycmap, length with_typs, []));
																if_debugging_say "--type_sumtype_declaration: finalWithtyps defined";
		#
		fun fix_dcon (tdt::VALCON { name, is_constant, form, signature, typoid, is_lazy } )
                    = 
		    tdt::VALCON
                      {
			typoid =>   apply_map  alltycmap  typoid,
			#
                        name,
                        is_constant,
                        form,
                        signature,
                        is_lazy
                      };

		final_dcons =   list::cat (map (map fix_dcon) (map .dcons dbs'));
																if_debugging_say "--type_sumtype_declaration: finalDcons defined";
		env_dcons   =   fold_forward
				    (fn (d as tdt::VALCON { name, ... },   e)
					=
					syx::bind   (name,   sxe::NAMED_CONSTRUCTOR d,   e)
				    )
				    syx::empty 
				    final_dcons;

		final_symbolmapstack
                    =
                    fold_backward
                        (fn ( { old, name, new },   e)
                            =
			    syx::bind   (name,   sxe::NAMED_TYPE new,   e)
                        ) 
			env_dcons
                        alltycmap;
																if_debugging_say "--type_sumtype_declaration: envDcons, finalSymbolmapstack defined";
		trs::forbid_duplicates_in_list
		  ( error_fn source_code_region,
                    "duplicate Constructor names in sumtype declaration",
		    list::cat (map .dcon_names dbs')
                  );
																if_debugging_say "<<type_sumtype_declaration";

		(final_dtyps, final_withtyps, final_dcons, final_symbolmapstack);

	    };			# fun type_sumtype_declaration 
    };				# package type_type
end;				# stipulate


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1998 Bell Laboratories
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
