## print-type-as-nada.pkg 

# Compiled by:
#     src/lib/compiler/front/typer/typer.sublib

#  modified to use Lib7 Lib pp. [dbm, 7/30/03]) 

stipulate 
    package pp  =  standard_prettyprint_mill;	# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package tdt =  type_declaration_types;	# type_declaration_types	is from   src/lib/compiler/front/typer-stuff/types/type-declaration-types.pkg
    package syx =  symbolmapstack;		# symbolmapstack		is from   src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack.pkg
herein

    api Print_Type_As_Lib7 {
	#
	type_formals:  Int
		      -> List( String );

	tyvar_printname_as_nada:  tdt::Typevar_Ref
			 -> String;

	print_type_as_nada:  syx::Symbolmapstack
			   -> pp::Prettyprint_Mill 
			   -> tdt::Type
			   -> Void;

	print_tyfun_as_nada:  syx::Symbolmapstack
			   -> pp::Prettyprint_Mill 
			   -> tdt::Typescheme
			   -> Void; 

	print_typoid_as_nada:   syx::Symbolmapstack
			   -> pp::Prettyprint_Mill 
			   -> tdt::Typoid
			   -> Void;

	print_valcon_domain_as_nada:  ((Vector( tdt::Sumtype_Member ), List( tdt::Type )) ) 
				-> syx::Symbolmapstack 
				-> pp::Prettyprint_Mill
				-> tdt::Typoid
				-> Void;

	print_valcon_types_as_nada:  syx::Symbolmapstack
				  -> pp::Prettyprint_Mill 
				  -> tdt::Type
				  -> Void;

	reset_prettyprint_type:  Void
		      -> Void;

	print_formals_as_nada:  pp::Prettyprint_Mill
			     -> Int
			     -> Void;

	debugging: Ref( Bool );
	unalias:   Ref( Bool );

    }; #  Api Print_Type_As_Lib7 
end;


stipulate 
    package ip  =  inverse_path;		# inverse_path			is from   src/lib/compiler/front/typer-stuff/basics/symbol-path.pkg
    package mtt =  more_type_types;		# more_type_types		is from   src/lib/compiler/front/typer/types/more-type-types.pkg
    package pp  =  standard_prettyprint_mill;	# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package sp  =  symbol_path;			# symbol_path			is from   src/lib/compiler/front/typer-stuff/basics/symbol-path.pkg
    package syx =  symbolmapstack;		# symbolmapstack		is from   src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack.pkg
    package tdt =  type_declaration_types;	# type_declaration_types	is from   src/lib/compiler/front/typer-stuff/types/type-declaration-types.pkg
    package tu  =  type_junk;			# type_junk			is from   src/lib/compiler/front/typer-stuff/types/type-junk.pkg

    include type_declaration_types;
    include print_as_nada_junk; 
herein

    package   print_typoid_as_nada
    : (weak)  Print_Type_As_Lib7		# Print_Type_As_Lib7	is from   src/lib/compiler/front/typer/print/print-type-as-nada.pkg
    {

	debugging = REF FALSE;
	unalias = REF TRUE;

	fun bug s = error_message::impossible ("print_typoid_as_nada: " + s);

	pps = pp::text;

	fun by f x y
	    =
	    f y x;

#	internals =   typer_control::internals;
internals = log::internals;

	unit_path = ip::extend (ip::empty, symbol::make_type_symbol "Void");

	fun bound_typevar_name k
	    =
	    { a = char::to_int 'a';
	    
		if   (k < 26)
		    
		     string::from_char (char::from_int (k+a));
		else
		      implode [ char::from_int (int::(/) (k, 26) + a), 
				char::from_int (int::(%) (k, 26) + a)
			      ];fi;
	    };

	fun meta_tyvar_name' k
	    =
	    {   a = char::to_int 'Z'; #  use reverse order for meta vars 
	    
		if   (k < 26)
		    
		     string::from_char (char::from_int (a - k));
		else 
		     implode [ char::from_int (a - (int::(/) (k, 26))), 
			       char::from_int (a - (int::(%) (k, 26)))
			     ];
                fi;
	    };

	fun type_formals n
	    =
	    { fun loop i
		=
		if   (i>=n)

		     [];
		else 
		     (bound_typevar_name i)  !  loop (i + 1);
                fi;
	    
		loop 0;
	    };

	fun literal_kind_printname (lk: tdt::Literal_Kind)
	    =
	    case lk
	        tdt::INT    => "Int";	#  or "INT" 
	        tdt::UNT    => "Unt";	#  or "WORD" 
	        tdt::FLOAT  => "Float";	#  or "REAL" 
	        tdt::CHAR   => "Char";	#  or "CHAR" 
	        tdt::STRING => "String";	#  or "STRING" 
            esac;

	stipulate  #  WARNING -- compiler global variables 
	    count = REF(-1);  
	    meta_tyvars = REF([]:List( Typevar_Ref ));
	herein
	    fun meta_tyvar_name (tv: Typevar_Ref)
		=
		{ fun find ([], _)
			=>
			{ meta_tyvars := tv ! *meta_tyvars;
			  count := *count+1;
			 *count;
                        };

		       find (tv' ! rest, k)
			   =>
			   if   (tv == tv')
			        *count - k;
			   else find (rest, k+1);fi;
                  end;
		
		    meta_tyvar_name' (find (*meta_tyvars, 0));
		};

	    fun reset_prettyprint_type ()
		=
		{   count := -1;
		    meta_tyvars := []
		;};
	end;

	fun tv_head (eq, base)
	    =
	    (if   eq      "''";  
		       else   "'";fi
	    )
	    +
	    base;

	fun annotate (name, annotation, maybe_fn_nesting)
	    =
	    if *internals

		 cat (  name
			 ! "."
			 ! annotation
			 ! case maybe_fn_nesting
				THE fn_nesting =>  ["[fn_nesting == ", (int::to_string fn_nesting), "]"];
				NULL           =>  NIL;
			   esac
			);
	    else
		 name;
            fi;

	fun tyvar_printname_as_nada (tv as { id => _, ref_typevar })
	    =
	    pr_kind  *ref_typevar
            where
	        fun pr_kind info
		    =
		    case info
		      
		         RESOLVED_TYPEVAR (TYPEVAR_REF  (tv as { id, ref_typevar => _ }))
                             =>
                             (tyvar_printname_as_nada  tv)
                             +
                             (sprintf "[id%d]" id);

		         RESOLVED_TYPEVAR _
                             =>
                             "<RESOLVED_TYPEVAR ?>";

			 META_TYPEVAR { fn_nesting, eq }
			     =>
			     tv_head (eq, annotate (meta_tyvar_name tv,
                                                  "META",
						 THE fn_nesting));

			 INCOMPLETE_RECORD_TYPEVAR { fn_nesting, eq, known_fields }
			     =>
			     tv_head (eq, annotate (meta_tyvar_name tv,
                                                    "F",
						 THE fn_nesting));

			 USER_TYPEVAR { name, fn_nesting, eq }
			     =>
			     tv_head (eq, annotate (symbol::name name, "USER", THE fn_nesting));

			 LITERAL_TYPEVAR { kind, ... }
			     =>
			     annotate (literal_kind_printname kind, "LITERAL", NULL);

			 OVERLOADED_TYPEVAR eq
			  =>
			  tv_head (eq, annotate (meta_tyvar_name  tv, "OVERLOAD", NULL));

			 TYPEVAR_MARK _ => "<TYPEVAR_MARK ?>";
                    esac;
	    
	    end;

	/*
	fun ppkind stream kind =
	    pps stream
	      (case kind
		 of BASE _ => "BASE" | FORMAL => "FORMAL"
		  | FLEXIBLE_TYPE _ => "FLEXIBLE_TYPE" | ABSTRACT _ => "ABSTYC"
		  | SUMTYPE _ => "SUMTYPE" | TEMP => "TEMP")
	*/

	fun ppkind stream kind
	    =
	    pps stream
	       case kind
		   BASE _            => "P";
		   FORMAL            => "F";
		   FLEXIBLE_TYPE _ => "X";
		   ABSTRACT _        => "A";
		   SUMTYPE _        => "D";
		   TEMP              => "T";
               esac;

	fun effective_path (path, type, dictionary) : String
	    =
	    {   fun namepath_of_type (tdt::SUM_TYPE { namepath, ... } | tdt::NAMED_TYPE { namepath, ... } | TYPE_BY_STAMPPATH { namepath, ... } )
			=>
			THE namepath;

		    namepath_of_type _
			=>
			NULL;
                end;

		fun find (path, type)
		    =
		    (find_path (path,
			(fn type' = tu::type_equality (type', type)),
			(fn x = find_in_symbolmapstack::find_type_via_symbol_path (dictionary, x,
						(fn _ =  raise exception syx::UNBOUND)))));

		fun search (path, type)
		    =
		    {   (find (path, type))
			    ->
			    (suffix, found);
		    
			if (found)
			    #
			    (suffix, TRUE);
			else
			    if (not *unalias)
				#
				(suffix, FALSE);
			    else
				case (tu::unwrap_definition_1 type)
				    #
				    THE type' => case (namepath_of_type type')
						    #
						    THE path'
							=>
							{   (search (path', type'))
								->
								x as (suffix', found');

							    if found'      x;
							    else           (suffix, FALSE);
							    fi;
							};

						    NULL => (suffix, FALSE);
						esac;


				    NULL => (suffix, FALSE);
			        esac;
			    fi;
                        fi;
		    };

		(search (path, type)) ->   (suffix, found);

		name =  sp::to_string (sp::SYMBOL_PATH suffix);
	    
		if   found      name;
			     else   "?." + name;fi;
	    };

	arrow_stamp =  mtt::arrow_stamp;

	fun strength  type
	    =
	    case type
		#
		TYPEVAR_REF { id, ref_typevar => (REF (RESOLVED_TYPEVAR type')) }
		    =>
		    strength  type';

		TYPCON_TYPOID (type, args)
		    =>
		    case type
			#
			tdt::SUM_TYPE { stamp, kind => BASE _, ... }
			    =>
			    if (stamp::same_stamp (stamp, arrow_stamp))    0;
			    else                                           2;
			    fi;

			RECORD_TYPE (_ ! _)	  #  excepting type unit 
			    =>
			    if (tuples::is_tuple_type type)  1;
			    else			     2;
			    fi;

			_ => 2;
		    esac;

	        _ => 2;
            esac;

	fun print_eq_prop_as_nada stream p
	    =
	    {   a = case p
			e::NO            => "NO";
			e::YES           => "YES";
			e::INDETERMINATE => "INDETERMINATE";
			e::CHUNK         => "CHUNK";
			e::DATA          => "DATA";
			e::EQ_ABSTRACT   => "EQ_ABSTRACT";
			e::UNDEF         => "UNDEF";
                    esac;
	    
		pps stream a;
	    };

	fun print_inverse_path_as_nada ppstream (inverse_path::INVERSE_PATH inverse_path: inverse_path::Inverse_Path)
	    = 
	    pp::text ppstream (symbol_path::to_string (symbol_path::SYMBOL_PATH (reverse inverse_path)));

	fun print_type1_as_nada  dictionary  stream  members_op
	    =
	    {   (en_pp stream)
		    ->
		    { begin_align_box, begin_wrap_box, end_box, pps, break, ... };

		fun print_type_as_nada (type as tdt::SUM_TYPE { namepath, stamp, is_eqtype, kind, ... } )
			=>
			if *internals
			    #
			    begin_wrap_box 1;
			    print_inverse_path_as_nada stream  namepath;
			    pps "[";
			    pps "G"; ppkind stream kind; pps ";"; 
			    pps (stamp::to_short_string stamp);
			    pps ";";
			    print_eq_prop_as_nada stream  *is_eqtype;
			    pps "]";
			    end_box();
			else
			    pps (effective_path (namepath, type, dictionary));
			fi;

		    print_type_as_nada (type as tdt::NAMED_TYPE { namepath, typescheme => TYPESCHEME { body, ... }, ... } )
			=>
			if *internals
			    #
			    begin_wrap_box 1;
			    print_inverse_path_as_nada stream  namepath;
			    pps "["; pps "D;"; 
			    print_typoid_as_nada dictionary stream body;
			    pps "]";
			    end_box();
			else
			    pps (effective_path (namepath, type, dictionary));
			fi;

		    print_type_as_nada (RECORD_TYPE labels)
			=>
			print_closed_sequence_as_nada stream 
			    { front=>by pp::text "{",
			     sep=>fn stream => { pp::text stream ", "; 
					       pp::break stream { spaces=>0, indent_on_wrap=>0 } ;}; end ,
			     back=>by pp::text "}",
			     style=>INCONSISTENT,
			     pr=>print_symbol_as_nada
                            }
                            labels;

		    print_type_as_nada (RECURSIVE_TYPE n)
			=>
			case members_op
			    #
			    THE (members, _)
				=> 
				{   (vector::get (members, n)) ->  { name_symbol, valcons, ... };
				    #
				    print_symbol_as_nada stream  name_symbol;
				};

			    NULL => pps (string::cat ["<RECURSIVE_TYPE ", int::to_string n, ">"]);
			esac;

		    print_type_as_nada (FREE_TYPE n)
		        =>
		        case members_op
			    #
			    THE (_, free_types)
				=> 
				{   type =  (   list::nth (free_types, n)
						except
						    _ = bug "unexpected free_types in print_type_as_nada"
					    );

				     print_type_as_nada  type;
				 };

			    NULL =>   pps (string::cat ["<FREE_TYPE ", int::to_string n, ">"]);
                        esac;

		    print_type_as_nada (type as TYPE_BY_STAMPPATH { arity, stamppath, namepath } )
			=>
			if *internals
			    #
			    begin_wrap_box 1;
			    print_inverse_path_as_nada stream  namepath;	pps "[P;"; 
			    pps (stamppath::stamppath_to_string stamppath);
			    pps "]";
			    end_box();
			else
                            print_inverse_path_as_nada stream  namepath;
                        fi;

		    print_type_as_nada ERRONEOUS_TYPE
                        =>
                        pps "[E]";
                end;

	    
		print_type_as_nada;
	    }


	also
	fun print_type1_as_mythryl7 dictionary stream ( type:	     Typoid,
							an_api:      tdt::Typescheme_Eqflags, 
							members_op:  Null_Or( (Vector( tdt::Sumtype_Member ), List( tdt::Type )) )
					              )
					              : Void
	    =
	    {   (en_pp  stream)
		    ->
		    { begin_align_box, begin_wrap_box, end_box, pps, break, newline };

		fun prty type
		    =
		    case type

		         TYPEVAR_REF { id, ref_typevar => REF (RESOLVED_TYPEVAR  type') }
                             =>
                             prty  type';

		         TYPEVAR_REF  tv
                             =>
                             print_typevar_as_nada  tv;

		         TYPESCHEME_ARG n
			     =>
			     { eq = list::nth (an_api, n) 
					    except INDEX_OUT_OF_BOUNDS = FALSE;

				 pps (tv_head (eq, (bound_typevar_name n)));
			     };

		         TYPCON_TYPOID (type, args)
			     =>
			     {
				 fun otherwise ()
				     =
				     { begin_wrap_box 2;
				       print_type_args_as_nada args; 
				       break { spaces=>0, indent_on_wrap=>0 };
				       print_type1_as_nada dictionary stream members_op type;
				       end_box();
				     };

				 case type
				     #
				     tdt::SUM_TYPE { stamp, kind, ... }
					 =>
					 case kind
					     #
					     BASE _ 
						 =>
						 if (stamp::same_stamp (stamp, arrow_stamp))
						     #
						     case args
						         #
							 [domain, range]
							     =>
							     {   begin_align_box 0;

								 if (strength domain == 0)
								       begin_align_box 1;
								       pps "(";
								       prty domain;
								       pps ")";
								       end_box();
								 else
								       prty domain;
								 fi;
								 break { spaces=>1, indent_on_wrap=>0 };
								 pps "-> ";
								 prty range;
								 end_box();
							      };

							  _ => bug "TYPCON_TYPE: arity";
						      esac;
						 else
						     begin_wrap_box 2;
						     print_type_args_as_nada args;
						     break { spaces=>0, indent_on_wrap=>0 };
						     print_type1_as_nada  dictionary  stream  members_op  type;
						     end_box();
						fi;

					   _ => otherwise ();
				       esac;

				      RECORD_TYPE labels
					  =>
					  if (tuples::is_tuple_type  type)   print_tuple_ty_as_nada args;
					  else                               print_record_ty_as_nada (labels, args);
                                          fi;

				      _ => otherwise ();
				 esac;
			     };

		         TYPESCHEME_TYPOID   { typescheme_eqflags => an_api,
						typescheme => TYPESCHEME { arity, body }
					      }
			     => 
			     print_type1_as_mythryl7 dictionary stream (body, an_api, members_op);

		         WILDCARD_TYPOID  => pps "_";
		         UNDEFINED_TYPOID => pps "undef";
                    esac

		also
		fun print_type_args_as_nada []
                        =>
                        ();

		    print_type_args_as_nada [type]
			=> 
			{  if (strength type <= 1)
			        begin_wrap_box 1;
				pps "("; 
				prty type; 
				pps ")";
				end_box();
			   else
				 prty type;
			   fi;
			   break { spaces=>1, indent_on_wrap=>0 } ;
                        };

		    print_type_args_as_nada tys
			=>
			print_closed_sequence_as_nada
			    stream 
			    {   front => by pp::text "(",
				sep   => fn stream => { pp::text stream ", ";
					     pp::break stream { spaces=>0, indent_on_wrap=>0 } ;}; end ,
				back  => by pp::text ") ",
				style => INCONSISTENT, 
				pr    => fn _ => fn type => prty type; end;  end 
			    }
			    tys;
                    end 

		also
		fun print_tuple_ty_as_nada [] => pps (effective_path (unit_path, RECORD_TYPE [], dictionary));

		   print_tuple_ty_as_nada tys
		    => 
		    print_sequence_as_nada
                       stream
		       {   sep   => fn stream => { pp::break stream { spaces=>1, indent_on_wrap=>0 };
					  pp::text stream "* ";}; end ,
			   style => INCONSISTENT,
			   pr    => (fn _ =  fn type = if (strength type <= 1)
							       begin_wrap_box 1;
							       pps "("; 
							       prty type; 
							       pps ")";
							       end_box();
							 else 
                                                               prty type;
                                                         fi
                                   )
                       }
		       tys; end 

		also
		fun print_field_as_nada (lab, type)
		    =
		    {   begin_align_box 0;
			print_symbol_as_nada stream lab; 
			pps ":";
			prty type;
			end_box()
		    ;}

		also
		fun print_record_ty_as_nada ([],[])
		    =>
		    pps (effective_path (unit_path, RECORD_TYPE [], dictionary));
		      #  this case should not occur 

		   print_record_ty_as_nada (lab ! labels, arg ! args)
		    =>
		    {   begin_wrap_box 1;
		        pps "{";
		        print_field_as_nada (lab, arg);
		        paired_lists::apply 
			  (fn field' = { pps ", "; break { spaces=>1, indent_on_wrap=>0 }; print_field_as_nada field';})
			  (labels, args);
		        pps "}";
		        end_box()
                    ;};

		   print_record_ty_as_nada _
		    =>
		    bug "print_typoid_as_nada::print_record_ty_as_nada"; end 

		also
		fun print_typevar_as_nada (tv as { id, ref_typevar => (ref_info as REF info) }:Typevar_Ref) :Void
		    =
		    {   printname = tyvar_printname_as_nada tv;
		    
			case info

			     INCOMPLETE_RECORD_TYPEVAR { fn_nesting, eq, known_fields }
			         =>
				 case known_fields

				      [] => { pps "{"; pps printname; pps "}";};

				      field' ! fields
					  =>
					  {   begin_wrap_box 1;
					      pps "{";
					      print_field_as_nada field';
					      apply (fn x => { pps ", ";
							    break { spaces=>1, indent_on_wrap=>0 };
							    print_field_as_nada x;}; end )
						   fields;
					      pps ";";
					      break { spaces=>1, indent_on_wrap=>0 };
					      pps printname;
					      pps "}";
					      end_box();
					  };
				  esac;

			    _ => pps printname;

                        esac;
		    };
	    
		prty type;
	    }  #  print_type1_as_mythryl7 


	also
	fun print_typoid_as_nada (dictionary: syx::Symbolmapstack) stream (typoid:  Typoid) : Void
	    = 
	    {   pp::begin_indented_wrap_box stream (pp::pmt::CURSOR_RELATIVE { spaces => 1, tab_to => 0, tabstops_are_every => 4 });
		print_type1_as_mythryl7 dictionary stream (typoid,[], NULL);
		pp::end_box stream;
	    };


	fun print_valcon_domain_as_nada members (dictionary: syx::Symbolmapstack) stream (typoid:  Typoid)
	    : Void
	    = 
	    {   pp::begin_indented_wrap_box stream (pp::pmt::CURSOR_RELATIVE { spaces => 1, tab_to => 0, tabstops_are_every => 4 });
		print_type1_as_mythryl7 dictionary stream (typoid,[], THE members);
		pp::end_box stream;
	    };


	fun print_type_as_nada  dictionary stream      type
	    =
	    print_type1_as_nada  dictionary  stream  NULL  type;


	fun print_tyfun_as_nada dictionary stream (TYPESCHEME { arity, body } )
	    =
	    {   (en_pp  stream)
		    ->
		    { begin_align_box, begin_wrap_box, end_box, pps, break, ... };
	    
		begin_wrap_box 2;
		pps "TYPESCHEME( { arity="; 
		print_int_as_nada stream arity; print_comma_as_nada stream;
		break { spaces=>0, indent_on_wrap=>0 };
		pps "body="; 
		print_typoid_as_nada dictionary stream body; 
		pps "} )";
		end_box();
	    };

	fun print_formals_as_nada stream
	    =
	    print_formals_as_nada'
            where
	        fun print_formals_as_nada' 0 => ();
		    print_formals_as_nada' 1 => pps stream " 'a";
		    print_formals_as_nada' n => { pps stream " ";
			     print_tuple_as_mythrl7 stream (fn stream =  fn s =  pps stream ("'" + s))
					    (type_formals n);};
                end;
	    end;

	fun print_valcon_types_as_nada dictionary stream (tdt::SUM_TYPE { kind => SUMTYPE dt, ... } )
	    =>
	    {   dt -> { index, free_types, family=> { members, ... }, ... };
		#
		(en_pp stream) ->   { begin_align_box, begin_wrap_box, end_box, pps, break, ... };

		my { valcons, ... } = vector::get (members, index);
	    
		begin_align_box 0;

		apply
                    (fn { name, domain, ... }
                        =
			{   pps (symbol::name name);
                            pps ":";

			    case domain
			      
			         THE type
                                     =>
				     print_type1_as_mythryl7 dictionary stream (type,[], THE (members, free_types));

			         NULL
                                     =>
                                     pps "CONST";
                            esac;

			    break { spaces=>1, indent_on_wrap=>0 };
                        }
                    )
		    valcons;

		end_box();
	    };

	   print_valcon_types_as_nada dictionary stream _
            =>
            bug "print_valcon_types_as_nada";
        end;
    };									# package print_typoid_as_nada 
end;									# toplevel stipulate 



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Copyright 1991 by AT&T Bell Laboratories 
## Copyright 2003 by The SML/NJ Fellowship 
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
