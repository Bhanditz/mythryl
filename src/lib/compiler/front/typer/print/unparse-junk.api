## unparse-junk.api

# Compiled by:
#     src/lib/compiler/front/typer/typer.sublib

stipulate
    package pp  =  prettyprint;				# prettyprint		is from   src/lib/prettyprint/big/src/prettyprint.pkg
    package sy  =  symbol;				# symbol		is from   src/lib/compiler/front/basics/map/symbol.pkg
    package syp =  symbol_path;				# symbol_path		is from   src/lib/compiler/front/typer-stuff/basics/symbol-path.pkg
    package ip  =  inverse_path;			# inverse_path		is from   src/lib/compiler/front/typer-stuff/basics/symbol-path.pkg
herein
    api Unparse_Junk {
	#
	Break_Style =  HORIZONTAL_ELSE_VERTICAL
		    |  WRAP
		    ;


	open_style_box:  Break_Style
			-> pp::Stream
			-> pp::Indent
			-> Void;

	unparse_sequence:  pp::Stream
			       ->
				{   separator:	pp::Stream -> Void, 
				    print_one:	pp::Stream -> X -> Void,
				    breakstyle:	Break_Style
				}
			       -> List(X)
			       -> Void;

	unparse_closed_sequence:  pp::Stream
				     -> { front:	pp::Stream -> Void, 
					  separator:	pp::Stream -> Void,
					  back:		pp::Stream -> Void,
					  print_one:	pp::Stream -> X -> Void,
					  breakstyle:	Break_Style
					}
				     -> List(X)
				     -> Void;

	unparse_symbol:  pp::Stream
			     -> sy::Symbol
			     -> Void;

	heap_string:  String -> String;

	unparse_mlstring:  pp::Stream
			       -> String
			       -> Void;

	unparse_mlstring':  pp::Stream
			       -> String
			       -> Void;

	unparse_integer:  pp::Stream
		     -> multiword_int::Int
		     -> Void;

	 ppvseq:  pp::Stream
		  -> Int
		  -> String
		  -> (pp::Stream -> X -> Void)
		  -> List(X) -> Void;

	ppvlist:  pp::Stream
		   -> (String,
		      String,
		      (pp::Stream -> X -> Void),
		      List(X))
		   -> Void;

	ppvlist' : pp::Stream
		    -> (String,
		       String,
		       (pp::Stream -> String -> X -> Void),
		       List(X))
		    -> Void;

	unparse_int_path:      pp::Stream -> List( Int )	-> Void;
	unparse_symbol_path:   pp::Stream -> syp::Symbol_Path	-> Void;
	unparse_inverse_path:  pp::Stream -> ip::Inverse_Path	-> Void;
	newline_indent:        pp::Stream -> Int		-> Void;

	#  needed in PPTypes, unparse_package_language 

	find_path:  (ip::Inverse_Path, (X -> Bool), (syp::Symbol_Path -> X))
		    ->
		    (List(sy::Symbol), Bool);

	unparse_tuple:  pp::Stream
			    -> (pp::Stream -> X -> Void)
			    -> List(X)
			    -> Void;

	unparse_int:           pp::Stream -> Int -> Void;
	unparse_comma:         pp::Stream -> Void;
	unparse_comma_newline:  pp::Stream -> Void;

	newline_apply:  pp::Stream
			-> (pp::Stream -> X -> Void)
			-> List(X)
			-> Void; 

	break_apply:  pp::Stream
		      -> (pp::Stream -> X -> Void)
		      -> List(X)
		      -> Void; 

	en_pp:  pp::Stream
		-> {   break:       { spaces: Int,   indent_on_wrap: Int } -> Void, 
		       newline:     Void -> Void,
		       begin_horizontal_else_vertical_box:   Int -> Void,
		       begin_wrap_box:  Int -> Void,
		       end_box:    Void -> Void, 
		       pps:         String -> Void
		   };

	unparse_array:  pp::Stream
			    -> ((pp::Stream -> X -> Void),  Rw_Vector(X))
			    -> Void;

    }; #  Api Unparse_Junk 
end;

## Copyright 1989 by AT&T Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
