## literal-to-num.pkg

# Compiled by:
#     src/lib/compiler/core.sublib



# Conversions from int/unt literals (which are represented as
# arbitrary precision Integers) to fixed size.
#
# This package is a hack, which should be replaced by parameterized
# numeric types.            XXX BUGGO FIXME

api Literal_To_Num {
    #
     int:	    integer::Int -> Int;
     int1:	    integer::Int -> int1::Int;
     int64:	    integer::Int -> (unt32::Unt, unt32::Unt);
     unt:	    integer::Int -> Unt;
     unt8:	    integer::Int -> Unt;
     unt32:	    integer::Int -> unt32::Unt;
     unt64:	    integer::Int -> (unt32::Unt, unt32::Unt);
     is_negative:   integer::Int -> Bool;
     rep_digits:    integer::Int -> List( Unt );  #  expose representation 
     low_val:	    integer::Int -> Null_Or( Int );
};



package   literal_to_num
: (weak)  Literal_To_Num					# Literal_To_Num	is from   src/lib/compiler/src/stuff/literal-to-num.pkg
{								# inline_t		is from   src/lib/core/init/built-in.pkg

    my two_8:      integer::Int =               0x100;
    my two_31:     integer::Int =          0x80000000;
    my two_32:     integer::Int =         0x100000000;
    my two_64:     integer::Int = 0x10000000000000000;
    my int64_min:  integer::Int = -0x8000000000000000;
    my int64_max:  integer::Int =  0x7fffffffffffffff;

    fun twowords i
        =
	(   inline_t::integer::trunc_unt32 (i / two_32),
	    inline_t::integer::trunc_unt32 i
        );

    fun negtwowords (x, y)
        =
	{   x' =   unt32::bitwise_not x;
	    y' =   unt32::bitwise_not y;

	    y'' = y' + 0u1;

	    x'' =   if (y'' == 0u0)   x' + 0u1;
                    else              x';
                    fi;
	
            (x'', y'');
	};

    int    = int::from_large;
    int1  = int1::from_large;

    fun int64 i
        =
	if   (i < int64_min or i > int64_max)  raise exception OVERFLOW;
	elif (i < 0)                           negtwowords (twowords (-i));
	else                                      twowords i;
        fi;

    fun unt8 i
        =
	{   if (i < 0 or i >= two_8)   raise exception OVERFLOW;   fi;
	    #
	    unt::from_large_unt (unt8::to_large_unt (inline_t::integer::trunc_unt8 i));
        };

    fun unt i
        =
	{   if (i < 0 or i >= two_31)    raise exception OVERFLOW;	fi;
	    #
	    inline_t::integer::trunc_tagged_unt  i;
	};

    fun unt32 i
	=
	{   if (i < 0 or i >= two_32)   raise exception OVERFLOW;   fi;
	    #
	    inline_t::integer::trunc_unt32  i;
	};

    fun unt64 i
        =
	{   if (i < 0 or i >= two_64)   raise exception OVERFLOW;   fi;
	    #
	    twowords i;
	};

    stipulate
	fun un_bi (core_integer::BI x)
            =
            x;
    herein
	is_negative   =   .negative o un_bi o core_integer::concrete;
	rep_digits    =   .digits   o un_bi o core_integer::concrete;

	fun low_val i
            =
            { l = core_integer::low_value i;
	    
		if   (l == core_integer::neg_base_as_int)
                     
                     NULL; 
                else
                     THE l;fi;
	    };
    end;
};


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1995 AT&T Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
