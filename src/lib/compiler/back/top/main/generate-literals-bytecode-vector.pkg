## generate-literals-bytecode-vector.pkg

# Compiled by:
#     src/lib/compiler/core.sublib



# This file implements one of the fatecode transforms.
# For context, see the comments in
#
#     src/lib/compiler/back/top/highcode/highcode-form.api



###                "There is no such thing as group
###                 originality or group creativity."
###
###                                 -- Edwin Land



stipulate
    package fcf =  fatecode_form;			# fatecode_form				is from   src/lib/compiler/back/top/fatecode/fatecode-form.pkg
herein

    api Generate_Literals_Bytecode_Vector {
	#
	Literal_Expression;

	split_off_fatecode_literals
	    :
	    fcf::Function -> (fcf::Function, Literal_Expression);


	generate_literals_bytecode_vector
	    :
	    Literal_Expression -> unt8_vector::Vector;
    };
end;



stipulate
    package em  =  error_message;			# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    package fcf =  fatecode_form;			# fatecode_form				is from   src/lib/compiler/back/top/fatecode/fatecode-form.pkg
    package hv  =  highcode_var;			# highcode_var				is from   src/lib/compiler/back/top/highcode/highcode-var.pkg
    package iht =  int_hashtable;			# int_hashtable				is from   src/lib/src/int-hashtable.pkg
    package w8v =  unt8_vector;				# unt8_vector				is from   src/lib/std/src/unt8-vector.pkg

    package intset {

	Intset = Ref( int_red_black_set::Set );

	fun new () = REF int_red_black_set::empty;

	fun add set i = set := int_red_black_set::add(*set, i);
	fun mem set i =  int_red_black_set::member(*set, i);
	fun rmv set i = set := int_red_black_set::delete(*set, i);
    };
herein

    package   generate_literals_bytecode_vector
    : (weak)  Generate_Literals_Bytecode_Vector		# Generate_Literals_Bytecode_Vector		is from   src/lib/compiler/back/top/main/generate-literals-bytecode-vector.pkg
    {

	fun bug  msg
	    =
	    em::impossible ("Literals: " + msg); 


	ident =   fn x = x;


	fun make_var _
	    =
	    hv::make_highcode_variable ();



	# **************************************************************************
	#                         A MINI-LITERAL LANGUAGE                          *
	# **************************************************************************



	Literal_Value
	  = LI_INT  Unt
	  | LI_STRING  String
	  | LI_VAR  fcf::Variable
	  ;

	Block_Kind
	  = LI_RECORD		# Record of tagged Mythryl values.
	  | LI_VECTOR		# Vector of tagged Mythryl values.
	  ;

	Literal_Expression
	  = LI_TOP        List( Literal_Value )
	  | LI_BLOCK     (Block_Kind, List( Literal_Value ), fcf::Variable, Literal_Expression)
	  | LI_F64BLOCK  (List( String ), fcf::Variable, Literal_Expression)
	  | LI_I32BLOCK  (List( unt32::Unt ), fcf::Variable, Literal_Expression)
	  ;

	fun rk2bk fcf::rk::VECTOR	=> LI_VECTOR;
	    rk2bk fcf::rk::RECORD	=> LI_RECORD;
	    rk2bk _		=> bug "rk2bk: unexpected block kind";
	end;

	fun val2lit (fcf::VAR v) => LI_VAR v;
	    val2lit (fcf::INT i) => LI_INT (unt::from_int i);
	    val2lit (fcf::STRING s) => LI_STRING s;
	    val2lit _ => bug "unexpected case in val2lit";
	end;



	# **************************************************************************
	#                 TRANSLATING THE LITERAL EXP TO BYTES                     *
	# **************************************************************************



	# Literals are encoded as instructions for a bytecoded "literal machine,"
	# implemented in
	#
	#     src/c/cleaner/make-package-literals-via-bytecode-interpreter.c
	#
	# Consequently the bytecode definitions here MUST be kept in sync with the
	# bytecode definitions there!
	#
	# The supported instructions are:
	#
	#	INT (i)			-- Push the int31 literal i on the stack.
	#
	#	RAW32[i1, ..., in]	-- Form a 32-bit raw data record from the
	#				   i1..in and push a pointer to it.
	#
	#	RAW64[r1, ..., rn]	-- Form a 64-bit raw data record from the
	#				   r1..rn and push a pointer to it.
	#
	#	STR[c1, ..., cn]	-- Form a string from the characters c1..cn
	#				   and push it on the stack.
	#
	#	LIT (k)			-- Push the contents of the stack element
	#				   that is k slots from the top of the stack.
	#
	#	VECTOR (n)		-- Pop n elements from the stack, make a vector
	#				   from them and push a pointer to the vector.
	#
	#	RECORD (n)		-- Pop n elements from the stack, make a record
	#				   from them and push a pointer.
	#
	#	RETURN			-- Return the top-of-stack literal.


	fun w32to_bytes' (w, l)
	    =
	    unt8::from_large_unt   (unt32::(>>) (w, 0u24))
	    ! unt8::from_large_unt (unt32::(>>) (w, 0u16))
	    ! unt8::from_large_unt (unt32::(>>) (w, 0u08))
	    ! unt8::from_large_unt w
	    ! l;

	fun w32to_bytes w = w32to_bytes' (w, []);
	fun w31to_bytes w = w32to_bytes (unt31::to_large_unt_x w);

	fun int_to_bytes i       = w32to_bytes (unt32::from_int i);
	fun int_to_bytes' (i, l) = w32to_bytes'(unt32::from_int i, l);

	fun string_to_bytes s
	    =
	    map byte::char_to_byte (explode s);



	###                      "A Thaum is the basic unit of magical strength.
	###                       It has been universally established as the amount
	###                       of magic needed to create one small white pigeon
	###                       or three normal-sized billiard balls."
	###
	###                                               -- Terry Pratchett



	emit_magic =   w8v::from_list [ 0ux19, 0ux98, 0ux10, 0ux22 ];					# V1_MAGIC	in    src/c/cleaner/make-package-literals-via-bytecode-interpreter.c

	fun emit_depth n = w8v::from_list (int_to_bytes n);
	fun emit_int i   = w8v::from_list (0ux01 ! w31to_bytes i);						# I_INT		in    src/c/cleaner/make-package-literals-via-bytecode-interpreter.c

	fun emit_raw32 [i] => w8v::from_list (0ux02 ! w32to_bytes i);					# I_RAW32	in    src/c/cleaner/make-package-literals-via-bytecode-interpreter.c
	    emit_raw32 l =>
	      w8v::from_list (0ux03 ! (int_to_bytes'(length l, list::fold_right w32to_bytes' [] l)));	# I_RAW32L	in    src/c/cleaner/make-package-literals-via-bytecode-interpreter.c
	end;

	fun emit_raw64 [r] => w8v::from_list (0ux04 ! string_to_bytes r);					# I_RAW64	in    src/c/cleaner/make-package-literals-via-bytecode-interpreter.c
	    emit_raw64 l => w8v::cat(
	      w8v::from_list (0ux05 ! int_to_bytes (length l)) ! map byte::string_to_bytes l);		# I_RAW64L	in    src/c/cleaner/make-package-literals-via-bytecode-interpreter.c
	end;

	fun emit_string s
	    =
	    w8v::cat [
		w8v::from_list (0ux06 ! int_to_bytes (size s)),						# I_STR		in    src/c/cleaner/make-package-literals-via-bytecode-interpreter.c
		byte::string_to_bytes s
	      ];

	fun emit_lit    k = w8v::from_list (0ux07 ! int_to_bytes k);
	fun emit_vector n = w8v::from_list (0ux08 ! int_to_bytes n);
	fun emit_record n = w8v::from_list (0ux09 ! int_to_bytes n);

	emit_return = w8v::from_list [0uxff];



	# This is where we generate the literals bytecode
	# program which will eventually be interpreted by
	#
	#     src/c/cleaner/make-package-literals-via-bytecode-interpreter.c
	#	
	fun generate_literals_bytecode_vector (LI_TOP [])
		=>
		w8v::from_list [];

	    generate_literals_bytecode_vector  lit_expression
		=>
		{	max_depth = depth (lit_expression, 0, 1);

		    code = emit_magic
			 ! emit_depth max_depth
			 ! list::reverse (emit_lit_expression([], lit_expression, []));

		    w8v::cat code;
		}
		where
		    fun depth (LI_TOP ls, d, max_depth)
			    =>
			    int::max (max_depth, d+length ls);

			depth (LI_BLOCK(_, ls, _, rest), d, max_depth)
			    =>
			    depth (rest, d+1, int::max (max_depth, d+length ls));

			depth (LI_F64BLOCK (ls, _, rest), d, max_depth)
			    =>
			    depth (rest, d+1, int::max (max_depth, d+length ls));

			depth (LI_I32BLOCK (ls, _, rest), d, max_depth)
			    =>
			    depth (rest, d+1, int::max (max_depth, d+length ls));
		    end;

		    fun emit_lit_expression (dictionary, expression, code)
			=
			case expression
			    #
			    (LI_TOP ls) 		     =>   emit_return ! emitablock (LI_RECORD, ls, code);
			    #
			    (LI_BLOCK (bk, ls, v, rest)) =>   emit_lit_expression (v ! dictionary, rest, emitablock (bk, ls, code));
			    (LI_F64BLOCK  (ls, v, rest)) =>   emit_lit_expression (v ! dictionary, rest, emit_f64block  (ls, code));
			    (LI_I32BLOCK  (ls, v, rest)) =>   emit_lit_expression (v ! dictionary, rest, emit_i32block  (ls, code));
			esac
			where
			    fun emit_lit_vals ([], _, code)
				    =>
				    code;

				emit_lit_vals (lit ! r, d, code)
				    =>
				    {
					instruction
					    =
					    case lit
						(LI_INT i) => emit_int i;
						(LI_STRING s) => emit_string s;

						(LI_VAR v)
						    =>
						    emit_lit (f (dictionary, d))
						    where
							fun f ([], _) => bug "unbound fcf::Variable";
							    f (v' ! r, d) => if (v == v')  d; else f (r, d+1);fi;
							end;
						    end;
					    esac;


					emit_lit_vals (r, d+1, instruction ! code);
				    };
			    end;

			    fun emitablock (LI_RECORD, ls, code)
				    =>
				    emit_record (length ls) ! emit_lit_vals (ls, 0, code);

				emitablock (LI_VECTOR, ls, code)
				    =>
				    emit_vector (length ls) ! emit_lit_vals (ls, 0, code);
			    end;

			    fun emit_f64block (ls, code)
				=
				emit_raw64 (map ieee_float_constants::realconst ls) ! code;

			    fun emit_i32block (ls, code)
				=
				emit_raw32 ls ! code;

			end;					# fun emit_lit_expression

	      end;
	end;


	############################################################################
	#                    Lifting literals on highcode
	############################################################################


	#  fun liftlits body = bug "highcode version currently not implemented yet"
	#  
	#  fun split_off_fatecode_literals (FK_FCT, f, [(v, t)], body) = 
	#        if lt::uniqtype_is_package t then
	#          let my (nbody, lit, llt) = liftlits body
	#              nt = lt::make_package_uniqtype ((lt::unpack_package_uniqtype t)@[llt])
	#           in ((FK_FCT, f, [(v, nt)], body), lit)
	#          end
	#        else bug "unexpected highcode header in split_off_fatecode_literals (case 1)"
	#    | split_off_fatecode_literals _ = bug "unexpected highcode header in split_off_fatecode_literals (case 2)"



	############################################################################
	#                    Lifting literal on fatecode
	############################################################################

	Info 
	  = ZZ_STR  String
	  | ZZ_FLT  String
	  | ZZ_RCD  (fcf::Record_Kind, List( fcf::Value ))
	  ;

	exception LITERAL_INFO;

	Rlit = RLIT  (String, Unt);


	fun to_rlit s
	    =
	    RLIT (s, hash_string::hash_string s);


	fun from_rlit (RLIT (s, _))
	    =
	    s;


	fun rlitcmp (RLIT (s1, i1), RLIT (s2, i2))
	    = 
	    if   (i1 < i2)  LESS;
	    elif (i1 > i2)  GREATER;
	    else            string::compare (s1, s2);
	    fi;


	package rlit_dictionary
	    =
	    red_black_map_g (
		Key = Rlit;
		compare = rlitcmp;
	    );

	# Lifting all literals from a fatecode program:
	#
	fun liftlits (body, root, offset)
	    = 
	    {   # The list of record, string, or real constants 
		#
		my m:  iht::Hashtable(Info) = iht::make_hashtable  { size_hint => 32,  not_found_exception => LITERAL_INFO };
		my freevars:    Ref( List( fcf::Variable ) ) = REF [];

		fun addv x = (freevars := (x ! *freevars));

		# Check if a fcf::Variable is used by the main program 
		#	
		my refset:   intset::Intset          =   intset::new();
		my used:     fcf::Variable -> Void   =   intset::add refset; 
		my is_used:  fcf::Variable -> Bool   =   intset::mem refset;

		#  memoize the information on which corresponds to what 

		fun enter (v, i)
		    =
		    {   iht::set m (v, i);
			addv v;
		    };

		fun const (fcf::VAR v)                                  =>  ({ iht::get  m  v; TRUE;} except _ = FALSE);
		    const (fcf::INT _ | fcf::INT32 _ | fcf::FLOAT64 _ | fcf::STRING _) =>  TRUE;
		    const _                                        =>  bug "unexpected case in const";
		end;

		fun cstlit (fcf::VAR v)                =>  ({ iht::get  m  v; TRUE;} except _ = FALSE);
		    cstlit (fcf::FLOAT64 _ | fcf::STRING _) =>  TRUE;
		    cstlit _                      =>  FALSE;
		end;

		# Register a string literal:
		#
		stipulate

		    my strs:   Ref( List( String ) )
			=
			REF [];

		    my strs_n:   Ref( Int )
			=
			REF 0;

		    sdict  =   REF (rlit_dictionary::empty);
		    srtv   =   make_var();
		    srtval =   fcf::VAR srtv;

		herein

		    fun typechecked_package_string  s
			= 
			{   v = make_var();		# Should hash to remove duplicates	XXX BUGGO FIXME
			    sd = *sdict;
			    rlit = to_rlit s;

			    n = 
			        case (rlit_dictionary::get (sd, rlit))
				    #
				    THE k => k;
				    #
				    _ => { (strs := (s ! *strs));
					    k = *strs_n;
					    (strs_n := (k+1)); 
					    (sdict := (rlit_dictionary::set (sd, rlit, k)));
					  k;
					};
			        esac;

			    ( fcf::VAR v,
                              fn fate =  fcf::GET_FIELD_I { i      =>  n,
							    record =>  srtval,
							    name   =>  v,
							    type   =>  fcf::bogus_pointer_type,
							    fate
                                                          }
                            );
			};

	      /* old definition of typechecked_package_string

		      let sd = *sdict
			  rlit = toRlit s
		       in (case RlitDict::peek (sd, rlit)
			    of THE v => (fcf::VAR v, ident)
			     | _ => let v = make_var()
					(enter (v, ZZ_STR s); used v)
					(sdict := RlitDict::set (sd, rlit, v))
				     in (fcf::VAR v, ident)
				    end)
		      end
	      */

		    fun apply_package ()
			=
			{   fun g (a ! r, z) =>  g (r, (fcf::STRING a) ! z);  
				g ([],    z) =>  z;			 # Reverse to get correct order.
			    end;

			    all_strs = *strs;

			    case *strs

				 [] => ();
				 xs => {   enter (srtv, ZZ_RCD (fcf::rk::RECORD, g (xs,[])));
					   used srtv;
				       };
			    esac;
		      };
		end;			# stipulate

		# * a special treatment of real constants 
		stipulate

		      my reals:   Ref( List( String ) ) = REF [];
		      my reals_n:  Ref( Int ) = REF 0;

		      rdict  =  REF (rlit_dictionary::empty);
		      rrtv   =  make_var();
		      rrtval =  fcf::VAR rrtv;

		herein				       

		    fun typechecked_package_real s
			= 
			{   v    = make_var();		# Should hash to remove duplicates XXX BUGGO FIXME
			    rd   = *rdict;

			    rlit = to_rlit s;

			    n    = case (rlit_dictionary::get (rd, rlit))
					 THE k => k;
					 _     => {   reals := (s ! *reals);
						      k = *reals_n;
						      reals_n := (k+1);
						      rdict := (rlit_dictionary::set (rd, rlit, k));
						      k;
						  };
				   esac;


			    ( fcf::VAR v,
			      fn fate = fcf::GET_FIELD_I  { i	   =>  n,
							    record =>  rrtval,
							    name   =>  v,
							    type   =>  fcf::type::FLOAT64,
							    fate
							  }
			    );
			};

		    fun apply_real ()
			= 
			{   fun g (a ! r, z) => g (r, (fcf::FLOAT64 a) ! z);  
				g (   [], z) => z;		 		#  reverse to reflecting the correct order 
			    end;

			    all_reals = *reals;

			    case *reals 
				[] => ();
				xs => {   enter (rrtv, ZZ_RCD (fcf::rk::FBLOCK, g (xs,[])));
					  used rrtv;
				      };
			    esac;
			};

		end;				# stipulate of special treatment of real constants 

		# Translation on the fatecode values:
		#
		fun lpsv u
		   = 
		   case u
		       #
		       fcf::FLOAT64 s =>   typechecked_package_real    s;
		       fcf::STRING  s =>   typechecked_package_string  s;
		       #
		       fcf::VAR     v =>   { used v; (u, ident);};
		       _              =>   (u, ident);
		   esac;

		fun lpvs vs
		    = 
		    fold_right g ([], ident) vs
		    where
			fun g (u, (xs, hh))
			    = 
			    { my (nu, nh) = lpsv u; 
			      (nu ! xs, nh o hh); 
			    };
		    end;

		#  If all fields of a record are "constant", then we lift it:
		# 
		fun field' ul
		    = 
		    h (ul, [], FALSE)
		    where
			fun h ((x, fcf::SLOT 0) ! r, z, rsflag)
				=> 
				if (const x ) h (r, x ! z, rsflag or (cstlit x)); else NULL;fi;

			    h ([], z, rsflag) => if rsflag  THE (reverse z); else NULL;fi;
			    h _ => bug "unexpected case in field";
			end;
		    end;

		#  Register a constant record:
		# 
		fun record (kind, ul, name)
		    =
		    case (field' ul)

			THE xl
			    =>
			    {   enter (name, ZZ_RCD (kind, xl));
				ident;
			    };

			NULL =>
			    {   fun g ((u, p as fcf::SLOT 0), (r, hh))
				    => 
				    {   my (nu, nh) = lpsv u;
					((nu, p) ! r, nh o hh);
				    };

				    g _ => bug "unexpected non-zero fcf::SLOT in record";
				end;

				(fold_right g ([], ident) ul) ->   (fields, header);

				fn fate = header (fcf::DEFINE_RECORD { kind, fields, name, fate });
			    };
		    esac;

		# Register a wrapped float literal:
		#
		fun wrapfloat (u, name, type)
		    = 
		    if (const u)
			#
			enter (name, ZZ_RCD (fcf::rk::FBLOCK, [u]));
			ident;
		    else 
			(lpsv u) ->   (nu, hh);
			#
			fn fate = hh (fcf::PURE { op   =>  fcf::p::FWRAP,
						  args =>  [nu],
						  name,
						  type,
						  fate
						}
                                   );
		    fi;

		# Fetch literal information:
		#
		fun get_info ()
		    = 
		    {   apply_real();   #  register all Reals as a record 
			apply_package();   #  register all Strings as a record 
			allvars = *freevars;
			exports = list::filter is_used allvars;

			toplit
			    = 
			    g (exports, [])
			    where
				fun g ([], z)
					=>
					LI_TOP z;

				    g (x ! r, z)
					=> 
					case (iht::get  m  x)
					     ZZ_STR s => g (r, (LI_STRING s) ! z);
					    _ => g (r, (LI_VAR x) ! z);
					esac;
			       end;
			    end;

			fun make_literal (v, lit)
			    =
			    {   fun un_real (fcf::FLOAT64 s) =>  s;
				    un_real _                     =>  bug "unREAL";
				end;

				fun un_int32 (fcf::INT32 w) => w;
				    un_int32 _ => bug "unINT32";
				end;

				case (iht::get  m  v)
				    #
				    (ZZ_FLT _)		# Float is wrapped.
					=> 
					bug "currently we don't expect ZZ_FLT in make_literal";

				    #  LI_F64BLOCK([s], v, lit) 
				    (ZZ_STR s)
					=> 
					bug "currently we don't expect ZZ_STR in make_literal";

				    # Lit   --- or we could inline string:
				    # 
				    (ZZ_RCD (fcf::rk::FBLOCK, vs))
					=>
					LI_F64BLOCK (map un_real vs, v, lit);

				    (ZZ_RCD (fcf::rk::I32BLOCK, vs))
					=>
					LI_I32BLOCK (map un_int32 vs, v, lit);

				    (ZZ_RCD (rk, vs))
					=> 
					LI_BLOCK (rk2bk rk, map val2lit vs, v, lit);
				esac;
			    };

			# Build up the literal package:
			#
			lit = fold_left make_literal toplit allvars;

			n = length exports;

			header
			    = 
			    if (n == 0)
				#
				ident;
			    else
				rv   =   make_var();
				rval =   fcf::VAR rv;
				rhdr =   fn fate =  fcf::GET_FIELD_I  { i      =>  offset,
									record =>  root,
									name   =>  rv,
									type   =>  fcf::type::POINTER (fcf::RPT n),
									fate
								      };

				fun make_header (v, (i, hh))
				    = 
				    {   nh = case (iht::get  m  v)
						 #
						 (ZZ_FLT _) => bug "ZZ_FLT in make_header";
						    /* (fn fate => 
							 (fcf::GET_FIELD_I { i => i, record => rval,       name => w, type => fcf::type::POINTER (FPT 1), fate =>
							  fcf::GET_FIELD_I { i => 0, record => fcf::VAR w, name => v, type => FLTT, fate } } ) ) */

						 (ZZ_STR s) => bug "ZZ_STR in make_header";
						    /* (fn fate => 
							  fcf::GET_FIELD_I { i, record => rval, name => v, type => fcf::bogus_pointer_type, fate } ) */

						 (ZZ_RCD (rk, vs))
						     =>
						     {   n = length vs;

							 type =  case rk 
								     #
								     fcf::rk::FBLOCK =>  fcf::type::POINTER (fcf::FPT n);
								     fcf::rk::VECTOR =>  fcf::bogus_pointer_type;
								     _               =>  fcf::type::POINTER (fcf::RPT n);
								 esac;

							 fn fate = fcf::GET_FIELD_I { i, record => rval, name => v, type, fate };
						     };
					     esac;

					(i+1, hh o nh);
				    };

				#2 (fold_right make_header (0, rhdr) exports);
			    fi;

			(lit, header);
		    };					# fun get_info 

		fun lpfn (fk, f, vl, cl, e)		# "lpfn" may be "loop_fn"...?
		    =
		    (fk, f, vl, cl, loop e)

		also
		fun loop ce
		    =
		    case  ce
			#
			fcf::DEFINE_RECORD { kind, fields, name, fate }
			    =>	  record ( kind, fields, name) (loop fate);

			fcf::GET_FIELD_I { i, record, name, type, fate }
			    => 
			    {   (lpsv record) ->   (record, hh);
				#
			        hh (fcf::GET_FIELD_I { i, record, name, type, fate => loop fate });
			    };

			fcf::GET_ADDRESS_OF_FIELD_I _ => bug "unexpected fcf::GET_ADDRESS_OF_FIELD_I in loop";

			fcf::TAIL_CALL { func, args }
			    => 
			    {   (lpsv func) ->   (func, h1);
				(lpvs args) ->   (args, h2);
				#
				h1 (h2 (fcf::TAIL_CALL { func, args }));
			    };

			fcf::DEFINE_FUNS { funs, fate }
			    =>
			    fcf::DEFINE_FUNS  { funs =>  map lpfn funs,
						fate =>  loop fate
					      };

			fcf::JUMPTABLE { i, xvar, fates }
			    => 
			    {   (lpsv i) ->   (i, hh);
				hh (fcf::JUMPTABLE { i, xvar, fates => map loop fates });
			    };

			fcf::IF_THEN_ELSE { op, args, xvar, thenfate, elsefate }
			    => 
			    {   (lpvs args) ->   (args, hh);
				#
				hh (fcf::IF_THEN_ELSE { op, args, xvar, thenfate => loop thenfate, elsefate => loop elsefate });
			    };

			fcf::STORE_TO_RAM { op, args, fate }
			    => 
			    {   (lpvs args) ->   (args, hh);
				#
				hh (fcf::STORE_TO_RAM { op, args, fate => loop fate });
			    };

			fcf::FETCH_FROM_RAM { op, args, name, type, fate }
			    =>
			    {   (lpvs args) ->   (args, hh);
				#
				hh (fcf::FETCH_FROM_RAM { op, args, name, type, fate => loop fate });
			    };

			fcf::MATH { op, args, name, type, fate }
			    =>
			    {   (lpvs args) ->   (args, hh);
				#
				hh (fcf::MATH { op, args, name, type,  fate => loop fate  });
			    };

			fcf::PURE { op   =>  fcf::p::FWRAP,
                                    args =>  [arg],
                                    name,
                                    type,
                                    fate
                                  }
			    =>
			    wrapfloat  (arg, name, type)  (loop fate);


			fcf::PURE { op, args, name, type, fate }
			    => 
			    {   (lpvs args) ->   (args, hh);
				#
				hh (fcf::PURE { op, args, name, type,  fate => loop fate  });
			    };

			fcf::RAW_C_CALL { kind, cfun_name, cfun_type, args, results, fate }
			    =>
			    {   (lpvs args) ->   (args, hh);
				#
				hh (fcf::RAW_C_CALL { kind, cfun_name, cfun_type, args, results,  fate => loop fate });
			    };
		    esac;

		    newbody = loop body;

		    my (lit, header) = get_info ();

		    (header newbody, lit);
	  };


	# Main function:
	#
	fun split_off_fatecode_literals (fk, f, vl as [_, x], [cntt, t as fcf::type::POINTER (fcf::RPT n)], body)
		=> 
		{   nt =   fcf::type::POINTER (fcf::RPT (n+1));

		    (liftlits (body, fcf::VAR x, n))
			->
			(nbody, lit);

		    ((fk, f, vl, [cntt, nt], nbody), lit);
		};

	    split_off_fatecode_literals _
		=>
		bug "unexpected fatecode header in split_off_fatecode_literals";
	end;

    };								# package generate_literals_bytecode_vector
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1998 YALE FLINT PROJECT.
## COPYRIGHT (c) 1998 Bell Labs, Lucent Technologies.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
