## prettyprint-fatecode.pkg 

# Compiled by:
#     src/lib/compiler/core.sublib


stipulate
    package fcf =  fatecode_form;				# fatecode_form			is from   src/lib/compiler/back/top/fatecode/fatecode-form.pkg
    package hut =  highcode_uniq_types;				# highcode_uniq_types		is from   src/lib/compiler/back/top/highcode/highcode-uniq-types.pkg
    package iht =  int_hashtable;				# int_hashtable		is from   src/lib/src/int-hashtable.pkg
    package ppr =  prettyprinter;				# prettyprinter			is from   src/lib/prettyprint/big/src/prettyprinter.pkg
herein

    api Prettyprint_Fatecode {
       #
       prettyprint_fatecode		# This entrypoint is not currently called from outside this file.
	   :
	   (fcf::Function, iht::Hashtable( hut::Uniqtype) )
	   ->
	   Void;

       print_fatecode_expression:  fcf::Expression     -> Void;
       print_fatecode_function:    fcf::Function -> Void;

       prettyprint_fatecode_function
	   :
	   ppr::Prettyprinter 
	   ->
	   fcf::Function
	   ->
	   Void;

    };
end;


stipulate
    package fcf =  fatecode_form;				# fatecode_form			is from   src/lib/compiler/back/top/fatecode/fatecode-form.pkg
    package hcv =  highcode_var;				# highcode_var			is from   src/lib/compiler/back/top/highcode/highcode-var.pkg
    package hcf =  highcode_form;				# highcode_form			is from   src/lib/compiler/back/top/highcode/highcode-form.pkg
    package hut =  highcode_uniq_types;				# highcode_uniq_types		is from   src/lib/compiler/back/top/highcode/highcode-uniq-types.pkg
    package iht =  int_hashtable;				# int_hashtable		is from   src/lib/src/int-hashtable.pkg
    package pp  =  prettyprint;					# prettyprint			is from   src/lib/prettyprint/big/src/prettyprint.pkg
herein

    package   prettyprint_fatecode
    : (weak)  Prettyprint_Fatecode
    {

	say = controls::print::say;

	fun numkind_name (fcf::p::INT   bits) =>  "i" + int::to_string bits;
	    numkind_name (fcf::p::UNT  bits) =>  "u" + int::to_string bits;
	    numkind_name (fcf::p::FLOAT bits) =>  "f" + int::to_string bits;
	end;

	fun looker_name  fcf::p::BANG                           =>  "bang";
	    looker_name  fcf::p::GET_EXCEPTION_HANDLER          =>  "gethandler";
	    looker_name  fcf::p::SUBSCRIPT                      =>  "subscript";
	    looker_name (fcf::p::NUMSUBSCRIPT { kindbits } )    =>  ("numsubscript" + numkind_name kindbits);
	    looker_name  fcf::p::GET_RUNTIME_ASM_PACKAGE_RECORD =>  "getrunvec";
	    looker_name  fcf::p::GET_CURRENT_THREAD_REGISTER    =>  "get_current_thread_register";
	    looker_name  fcf::p::DEFLVAR                        =>  "deflvar";
	    looker_name  fcf::p::GET_STATE_OF_SPECIAL           =>  "getspecial";
	    looker_name  fcf::p::PSEUDOREG_GET                  =>  "getpseudo";
	    looker_name (fcf::p::RAWLOAD { kindbits } )         =>  ("rawload" + numkind_name kindbits);
	end;

	fun branch_name  fcf::p::BOXED   => "boxed";
	    branch_name  fcf::p::UNBOXED => "unboxed";
	    branch_name (fcf::p::CMP { op, kindbits } )
		=>
		numkind_name kindbits
                +
		case op
		    #                  
		    fcf::p::GT  =>  ">";  
		    fcf::p::LT  =>  "<";
		    fcf::p::GE  =>  ">="; 
		    fcf::p::LE  =>  "<=";
		    fcf::p::EQL =>  "=";
		    fcf::p::NEQ =>  "!=";
		esac; 

	    branch_name (fcf::p::FCMP { op, size } )
		=> 
		numkind_name (fcf::p::FLOAT size)
                +
		case op
		    #                  
		    fcf::p::f::EQ   => "=";
		    fcf::p::f::ULG  => "?<>";
		    fcf::p::f::GT   => ">";
		    fcf::p::f::GE   => ">=";
		    fcf::p::f::LT   => "<";
		    fcf::p::f::LE   => "<=";
		    fcf::p::f::LG   => "<>";
		    fcf::p::f::LEG  => "<=>";
		    fcf::p::f::UGT  => "?>";
		    fcf::p::f::UGE  => "?>=";
		    fcf::p::f::ULT  => "?<";
		    fcf::p::f::ULE  => "?<=";
		    fcf::p::f::UE   => "?=";
		    fcf::p::f::UN   => "?";
		esac;

	    branch_name fcf::p::PNEQ   =>  "pneq";
	    branch_name fcf::p::PEQL   =>  "peql";
	    branch_name fcf::p::STREQ  =>  "streq";
	    branch_name fcf::p::STRNEQ =>  "strneq";
        end;

	fun setter_name  fcf::p::UNBOXED_SET                 =>  "unboxed_set";
	    setter_name  fcf::p::BOXED_SET                   =>  "boxedupdate";
	    setter_name  fcf::p::UPDATE                      =>  "update";
	    setter_name (fcf::p::NUMUPDATE { kindbits } )    =>  ("numupdate" + numkind_name kindbits);
	    setter_name  fcf::p::SET_INT_REFCELL             =>  "unboxedassign";
	    setter_name  fcf::p::ASSIGN                      =>  "assign";
	    setter_name  fcf::p::SET_EXCEPTION_HANDLER       =>  "sethandler";
	    setter_name  fcf::p::SET_CURRENT_THREAD_REGISTER =>  "set_current_thread_register";
	    setter_name  fcf::p::USELVAR                     =>  "uselvar";
	    setter_name  fcf::p::FREE                        =>  "free";
	    setter_name  fcf::p::SET_STATE_OF_SPECIAL        =>  "setspecial";
	    setter_name  fcf::p::PSEUDOREG_SET               =>  "setpseudo";
	    setter_name  fcf::p::SETMARK                     =>  "setmark";
	    setter_name  fcf::p::ACCLINK                     =>  "acclink";
	    setter_name (fcf::p::RAWSTORE { kindbits } )     =>  ("rawstore" + numkind_name kindbits);
	    setter_name (fcf::p::RAWUPDATE cty)              =>  ("rawupdate" + fcf::cty_to_string cty);
        end;

	cvt_param =  int::to_string;

	fun cvt_params (from, to)
	    =
	    cat [cvt_param from, "_", cvt_param to];

	fun arith_name (fcf::p::MATH { op, kindbits } )
		=>
		case op
		    #                  
		    fcf::p::ADD       =>  "+";
		    fcf::p::SUBTRACT  =>  "-"; 
		    fcf::p::MULTIPLY  =>  "*";
		    fcf::p::DIVIDE    =>  "/";
		    fcf::p::NEGATE    =>  "-_";
		    fcf::p::ABS       =>  "abs"; 
		    fcf::p::FSQRT     =>  "fsqrt"; 
		    fcf::p::FSIN      =>  "sin";
		    fcf::p::FCOS      =>  "cos";
		    fcf::p::FTAN      =>  "tan";
		    fcf::p::RSHIFT    =>  "rshift";
		    fcf::p::RSHIFTL   =>  "rshiftl";
		    fcf::p::LSHIFT    =>  "lshift";
		    fcf::p::BITWISE_AND      =>  "bitwise_and";
		    fcf::p::BITWISE_OR       =>  "bitwise_or";
		    fcf::p::BITWISE_XOR      =>  "bitwise_xor";
		    fcf::p::BITWISE_NOT      =>  "bitwise_not";
		    fcf::p::REM       =>  "rem";
		    fcf::p::DIV       =>  "div";
		    fcf::p::MOD       =>  "mod";
		 esac
		 +
                 numkind_name  kindbits;

	    arith_name (fcf::p::SHRINK_INT arg)   => "test_"     +  cvt_params arg;
	    arith_name (fcf::p::SHRINK_UNT arg)  => "testu_"    +  cvt_params arg;
	    arith_name (fcf::p::SHRINK_INTEGER i) => "test_inf_" +  cvt_param i;

	    arith_name (fcf::p::ROUND { floor=>TRUE, from=>fcf::p::FLOAT 64, to=>fcf::p::INT 31 } )
                =>
	        "floor";

	    arith_name (fcf::p::ROUND { floor=>FALSE, from=>fcf::p::FLOAT 64, to=>fcf::p::INT 31 } )
                =>
	        "round";

	    arith_name (fcf::p::ROUND { floor, from, to } )
                =>
	        if floor  "floor"; else "round"; fi
		+
                numkind_name from
                +
                "_"
                +
                numkind_name to;
	end;

	fun pure_name  fcf::p::LENGTH         =>  "length";
	    pure_name (fcf::p::PURE_ARITH x)  =>  arith_name (fcf::p::MATH x);
	    pure_name  fcf::p::CHUNK_LENGTH    =>  "chunklength";
	    pure_name  fcf::p::MAKE_REFCELL        =>  "makeref";
	    pure_name (fcf::p::STRETCH arg)    =>  "extend_" + cvt_params arg;
	    pure_name (fcf::p::COPY arg)      =>  "copy_" + cvt_params arg;
	    pure_name (fcf::p::CHOP arg)     =>  "trunc_" + cvt_params arg;
	    pure_name (fcf::p::CHOP_INTEGER  i)  =>  "trunc_inf_" + cvt_param i;
	    pure_name (fcf::p::COPY_TO_INTEGER   i)  =>  cat ["copy_", cvt_param i, "_inf"];
	    pure_name (fcf::p::STRETCH_TO_INTEGER i)  =>  cat ["extend_", cvt_param i, "_inf"];

	    pure_name  fcf::p::SUBSCRIPTV     => "subscriptv";
	    pure_name  fcf::p::GET_BTAG_FROM_TAGWORD         => "gettag";
	    pure_name  fcf::p::MAKE_SPECIAL   => "make_special";
	    pure_name  fcf::p::WRAP           => "wrap";
	    pure_name  fcf::p::UNWRAP         => "unwrap";
	    pure_name  fcf::p::CAST           => "cast";
	    pure_name  fcf::p::GETCON         => "getcon";
	    pure_name  fcf::p::GETEXN         => "getexn";
	    pure_name  fcf::p::FWRAP          => "fwrap";
	    pure_name  fcf::p::FUNWRAP        => "funwrap";
	    pure_name  fcf::p::IWRAP          => "iwrap";
	    pure_name  fcf::p::IUNWRAP        => "iunwrap";
	    pure_name  fcf::p::I32WRAP        => "i32wrap";
	    pure_name  fcf::p::I32UNWRAP      => "i32unwrap";
	    pure_name  fcf::p::GETSEQDATA     => "getseqdata";
	    pure_name  fcf::p::RECSUBSCRIPT   => "recsubscript";
	    pure_name  fcf::p::RAW64SUBSCRIPT => "raw64subscript";
	    pure_name  fcf::p::NEWARRAY0      => "newarray0";
	    pure_name (fcf::p::RAWRECORD rk)  => "rawrecord_" + the_else (null_or::map rkstring rk, "notag");
	    pure_name (fcf::p::CONDMOVE b)    => "condmove " + branch_name b;

	    pure_name (fcf::p::PURE_NUMSUBSCRIPT { kindbits } )
                =>
                ("numsubscriptv" + numkind_name kindbits);

	    pure_name (fcf::p::CONVERT_FLOAT { from=>fcf::p::FLOAT 64, to=>fcf::p::INT 31 } )
                => "convert_float";

	    pure_name (fcf::p::CONVERT_FLOAT { from, to } )
                =>
	        ( "convert_float"
                + numkind_name  from
                + "_"
                + numkind_name  to
                );
	end 

	also
        fun rkstring rk
            =
            case rk 
		#	      
		fcf::rk::VECTOR	  =>  "fcf::rk::VECTOR";
		fcf::rk::RECORD    =>  "fcf::rk::RECORD";
		fcf::rk::SPILL     =>  "fcf::rk::SPILL";
		fcf::rk::ESCAPE    =>  "fcf::rk::ESCAPE";
		fcf::rk::CONT      =>  "fcf::rk::CONT";
		fcf::rk::FCONT     =>  "fcf::rk::FCONT";
		fcf::rk::KNOWN     =>  "fcf::rk::KNOWN";
		fcf::rk::BLOCK     =>  "fcf::rk::BLOCK";
		fcf::rk::FBLOCK    =>  "fcf::rk::FBLOCK";
		fcf::rk::I32BLOCK  =>  "fcf::rk::I32BLOCK";
            esac;


	fun show0 say
            =
	    {   fun sayc ('\n') =>  say "\\n";
		    sayc c      =>  say (string::from_char c);
                end;

		fun sayv (fcf::VAR     v) =>  say (hcv::name_of_highcode_variable v);
		    sayv (fcf::LABEL   v) =>  say ("(L)" + hcv::name_of_highcode_variable v);
		    sayv (fcf::INT     i) =>  say ("(I)" + int::to_string i);
		    sayv (fcf::INT32   i) =>  say ("(I32)" + unt32::to_string i);
		    sayv (fcf::FLOAT64 r) =>  say r;
		    sayv (fcf::STRING  s) =>  { say "\"";   apply sayc (explode s);   say "\""; };
		    sayv (fcf::CHUNK   _) =>  say ("(chunk)");
		    sayv (fcf::TRUEVOID ) =>  say ("(truevoid)");
		end;

		fun sayvlist [v]      =>  sayv v;
		    sayvlist NIL      =>  ();
		    sayvlist (v ! vl) =>  { sayv v;   say ", ";   sayvlist vl; };
		end;


		fun sayrk (fcf::rk::RECORD, n) => ();
		    sayrk (fcf::rk::VECTOR, n) => ();
		    sayrk (k, n:  Int)
			=>
			{    say (rkstring k);
			     say " ";
			     say (int::to_string n);
			     say ", ";
			};
		end;

	        sayt = say o fcf::cty_to_string;

		fun sayparam ([v],[ct])        =>  { sayv v;   sayt ct; };
		    sayparam (NIL, NIL)        =>  ();
		    sayparam (v ! vl, ct ! cl) =>  { sayv v;   sayt ct;   say ", ";   sayparam (vl, cl); };
		    sayparam _                 =>  error_message::impossible "sayparam in prettyprint-fatecode.pkg";
		end;

		fun saypath (fcf::SLOT 0) => ();
		    saypath (fcf::SLOT i) => { say "+"; say (int::to_string i);};
		    #
		    saypath (fcf::VIA_SLOT (j, p))
			=>
			{   say ".";
			    say (int::to_string j);
			    saypath p;
			};
		end;

		fun sayvp (v, path)
                    =
                    {   sayv v;
                        saypath path;
                    };

		fun saylist f [x]     =>   f x;
                    saylist f NIL     => (); 
		    saylist f (x ! r) =>  { f x;  say ", ";  saylist f r;};
		end;

		fun indent n
		    =
		    f
                    where
		        fun space 0 => ();
                            space k => { say " ";  space (k - 1); };
                        end;

			fun nl () = say "\n";

			recursive val f
			    =
			    fn  fcf::DEFINE_RECORD { kind, fields, name, fate }
                                    =>
                                    {   space n;

					case kind
                                            #
                                            fcf::rk::VECTOR =>  say "#{ ";
                                            _               =>  say  "{ ";
                                        esac;

					sayrk (kind, length fields);
					saylist sayvp fields;
                                        say "} -> ";
					sayv (fcf::VAR name);
					nl();
                                        f fate;
                                    };

				fcf::GET_FIELD_I { i, record, name, type, fate }
                                    =>
				    {   space n;
                                        sayv record;
                                        say ".";
                                        say (int::to_string i);
                                        say " -> ";
				        sayv (fcf::VAR name);
                                        sayt type;
                                        nl();
                                        f fate;
                                    };

				fcf::GET_ADDRESS_OF_FIELD_I { i, record, name, fate }
                                    =>
				    {   space n;
                                        sayv record;
                                        say "+";
                                        say (int::to_string i);
                                        say " -> ";
				        sayv (fcf::VAR name);
                                        nl();
                                        f fate;
                                    };

				fcf::TAIL_CALL { func, args }
                                    =>
				    {   space n;
                                        sayv func;
                                        say "(";
                                        sayvlist args;
                                        say ")\n";
                                    };

				fcf::DEFINE_FUNS { funs, fate }
                                    =>
				    {   apply g funs;
                                        f fate;
                                    }
                                    where
				        fun g (_, v, wl, cl, d)
					    = 
					    {   space n;
						sayv (fcf::VAR v);
						say "("; 
						sayparam (map fcf::VAR wl, cl);
						say ") =\n"; 
						indent (n+3) d;
					    };
				    end;

				fcf::JUMPTABLE { i, xvar, fates }
                                    =>
				    {   fun g (i, c ! cl)
                                                =>
					        {   space (n+1);
                                                    say (int::to_string (i: Int));
					            say " =>\n";
                                                    indent (n+3) c;
                                                    g (i+1, cl);
                                                };
					    g (_, NIL)
                                                =>
                                                ();
                                        end;

				        space n;
                                        say "case ";
                                        sayv i;
                                        say "  ["; 
					say (int::to_string xvar);
					say "] of\n"; 
					g (0, fates);
				    };

				fcf::FETCH_FROM_RAM { op, args, name, type, fate }
                                    =>
				    {   space n;
                                        say (looker_name op);
                                        say "(";
                                        sayvlist args;
				        say ") -> ";
                                        sayv (fcf::VAR name);
                                        sayt type;
                                        nl();
                                        f fate;
                                    };

				fcf::MATH { op, args, name, type, fate }
                                    =>
				    {   space n;
                                        say (arith_name op);
                                        say "(";
                                        sayvlist args;
				        say ") -> ";
                                        sayv (fcf::VAR name);
                                        sayt type;
                                        nl();
                                        f fate;
                                    };

				fcf::PURE { op, args, name, type, fate }
                                    =>
				    {   space n;
                                        say (pure_name op);
                                        say "(";
                                        sayvlist args;
				        say ") -> ";
                                        sayv (fcf::VAR name);
                                        sayt type;
                                        nl();
                                        f fate;
                                    };

				fcf::STORE_TO_RAM { op, args, fate }
                                    =>
				    {   space n;
                                        say (setter_name op);
                                        say "(";
                                        sayvlist args;
				        say ")";
                                        nl();
                                        f fate;
                                    };

				fcf::IF_THEN_ELSE { op, args, xvar, thenfate, elsefate }
                                    =>
				    {   space n;
                                        say "if ";
                                        say (branch_name op);
					say "("; sayvlist args;
                                        say ") ["; 
					sayv (fcf::VAR xvar);
                                        say "] then\n";
				        indent (n+3) thenfate;
				        space n; say "else\n";
				        indent (n+3) elsefate;
                                    };

				fcf::RAW_C_CALL { kind, cfun_name, cfun_type, args, results, fate }
                                    =>
				    {   space n; 
				        if   (kind == fcf::REENTRANT_RCC)   say "reentrant ";  fi;
				        if   (cfun_name != "")  say cfun_name; say " ";  fi;
				        say "rcc(";
                                        sayvlist args;
                                        say ") -> ";
				        apply (fn (w, t) =  { sayv (fcf::VAR w);   sayt t; })
                                              results;
				        nl();
                                        f fate;
                                    };
                            end;
		    end;
	     indent;
	 };

	fun prettyprint_fatecode ((_, f, vl, cl, e), m)
	    =
	    {

		if *controls::cg::debug_representation
		    #
		    fun ptv (v, t)
			=
			{   say (hcv::name_of_highcode_variable v);
			    say " type ===>>>";
			    say (hcf::uniqtype_to_string t);
			    say "\n";
			};

		    say "************************************************\n";
		    iht::keyed_apply ptv m;
		    say "************************************************\n";
		fi;

		fun sayv (v)
                    =
                    say (hcv::name_of_highcode_variable v);

	        sayt = say o fcf::cty_to_string;

		fun sayparam ([v],[ct]) => { sayv v;   sayt ct; };
		    sayparam (NIL, NIL) => ();
		    sayparam (v ! vl, ct ! cl) => { sayv v;   sayt ct;   say ", ";   sayparam (vl, cl); };
		    sayparam _ => error_message::impossible "sayparam in prettyprint-fatecode.pkg 3435";
                end;

		say (hcv::name_of_highcode_variable f);
		say "(";
		sayparam (vl, cl);
		say ") =\n";  
		show0 say 3 e;
	    };


	exception NULLTABLE;


	my  nulltable:  iht::Hashtable( hut::Uniqtype )
            =
	    iht::make_hashtable  { size_hint => 8,  not_found_exception => NULLTABLE };


	fun print_fatecode_expression (ce)
            =
            show0 (controls::print::say) 1 ce;


	fun print_fatecode_function f
            =
            prettyprint_fatecode (f, nulltable);


	# This function takes MINUTES on mythryl.lex.pkg when called from
	# maybe_prettyprint_fatecode in src/lib/compiler/back/top/main/backend-tophalf-g.pkg
	# -- I think there must be an O(N**2) performance bug.  2010-09-08 CrT
	#
	fun prettyprint_fatecode_function  (pp: prettyprinter::Prettyprinter)  f
            =
            prettyprint_fatecode' (f, nulltable)
            where

		fun prettyprint_fatecode' ((_, f, vl, cl, e), m)
		    =
		    {
			if *controls::cg::debug_representation
			    #
			    fun ptv (v, t)
				=
				{   pp.put (hcv::name_of_highcode_variable v);
				    pp.put " type ===>>>";
				    pp.put (hcf::uniqtype_to_string t);
				    pp.put "\n";
				};

			    pp.put "************************************************\n";
			    iht::keyed_apply ptv m;
			    pp.put "************************************************\n";
			fi;

                        say =  pp.put;

			fun sayv v
			    =
			    pp.put (hcv::name_of_highcode_variable v);

	                sayt = say o fcf::cty_to_string;

			fun sayparam ([v],[ct]) => { sayv v;   sayt ct; };
			    sayparam (NIL, NIL) => ();
			    sayparam (v ! vl, ct ! cl) => { sayv v;   sayt ct;   say ", ";   sayparam (vl, cl); };
			    sayparam _ => error_message::impossible "sayparam in prettyprint-fatecode.pkg 3435";
			end;


			{   pp.put (hcv::name_of_highcode_variable f);
			    pp.put "(";
			    sayparam (vl, cl);
			    pp.put ") =\n";  
			    show0 pp.put 3 e;
			};
		    };
            end;


    };		#  package prettyprint_fatecode 
end;		#  toplevel stipulate 



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Copyright 1996 by Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
