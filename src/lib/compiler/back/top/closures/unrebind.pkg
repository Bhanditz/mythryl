## unrebind.pkg 

# Compiled by:
#     src/lib/compiler/core.sublib

# **************************************************************************
#                                                                          *
# "Alpha conversion": the closure converter introduces duplicate namings  *
# at function arguments (the free variables of known functions) and at     *
# SELECT's and OFFSET's from closures.  This function restores unique      *
# namings, and also eliminates OFFSET's of 0 (which are introduced as     *
# a side effect of trying to improve lazy display).  It assumes that a     *
# FIX has no free variables.                                               *
#                                                                          *
# **************************************************************************



###                         "Never try and teach a pig to sing:
###                          it's a waste of time,
###                          and it annoys the pig."
###
###                                      -- Robert A. Heinlein
###                                         Time Enough for Love



stipulate
    package fcf =  nextcode_form;		# nextcode_form		is from   src/lib/compiler/back/top/nextcode/nextcode-form.pkg
herein

    api Un_Rebind {
	#
	unrebind:  fcf::Function  ->  fcf::Function;
    };
end;



stipulate 
    package fcf =  nextcode_form;		# nextcode_form		is from   src/lib/compiler/back/top/nextcode/nextcode-form.pkg
    package hcv =  highcode_var;		# highcode_var		is from   src/lib/compiler/back/top/highcode/highcode-var.pkg
herein

    package   un_rebind
    : (weak)  Un_Rebind				# Un_Rebind		is from   src/lib/compiler/back/top/closures/unrebind.pkg
    {

	fun bug s
            =
            error_message::impossible ("UnRebind: " + s);


	fun unrebind (fk, v, args, cl, ce)
            =
	    {   fun rename rebind (fcf::VAR v)
			  =>
			  f rebind
                          where
			      fun f NIL
                                      =>
                                      fcf::VAR v;

				  f ((w: Int, v') ! t)
				      =>
				      v == w   ??   v'
				               ::   f t;
                              end;
			  end;

		    rename _ x
			=>
			x;
                end;


		fun f (kind, l, args, cl, b)
                    =
		    {   my (args', rebind')
                            = 
			    fold_right
                                (   fn (v, (args', rebind'))
                                       =
				       { v' = hcv::copy_highcode_variable v;
				       
                                           (   v' ! args',
                                               (v, fcf::VAR v') ! rebind'
                                           );
				       }
                                )

				(NIL, NIL)

                                args;
		    
                        (   kind,
                            l,
                            args',
                            cl,
                            g rebind' b
                        );
		    }

		also
		fun g (rebind: List( (fcf::Variable, fcf::Value) ) )
                    =
                    h
                    where
		        rename = rename rebind;

			recursive val h
                            =
			    fn fcf::DEFINE_RECORD { kind, fields, name, next }
				   =>
				   {   name' = hcv::copy_highcode_variable  name;

				       fcf::DEFINE_RECORD
				         {	
					   kind,
					   fields =>  map (fn (v, p) = (rename v, p)) fields,
					   name   =>  name',
					   next   =>  g  ((name, fcf::VAR name') ! rebind)   next
				         };
				   };

			      fcf::GET_ADDRESS_OF_FIELD_I { i => 0, record, name, next } =>   g ((name, rename record) ! rebind) next;
			      fcf::GET_ADDRESS_OF_FIELD_I { i,      record, name, next } =>   bug "unexpected non-zero FIELD_POINTER";
	     /*
				 let w' = hcv::copy_highcode_variable w
				  in fcf::GET_ADDRESS_OF_FIELD_I (i, rename v, w', g ((w, fcf::VAR w') ! rebind) e)
				 end
	     */
			      fcf::GET_FIELD_I { i, record, name, type, next }
				  =>
				  {   name' =  hcv::copy_highcode_variable  name;

				      fcf::GET_FIELD_I {
					  i,
					  record =>  rename record,
					  name   =>  name',
					  type,
					  next   =>  g ((name, fcf::VAR name') ! rebind) next
				      };
				  };

			      fcf::TAIL_CALL   { func, args }    =>  fcf::TAIL_CALL {   func => rename func,   args => map rename args  };
			      fcf::DEFINE_FUNS { funs, next }    =>  fcf::DEFINE_FUNS {  funs => map f funs,  next => h next  };

			      fcf::JUMPTABLE { i, xvar, nexts }	 =>  fcf::JUMPTABLE { i => rename i, xvar, nexts => map h nexts };
			      fcf::IF_THEN_ELSE { op, args, xvar, then_next, else_next }     =>  fcf::IF_THEN_ELSE { op, args => map rename args, xvar, then_next => h then_next, else_next => h else_next };

			      fcf::STORE_TO_RAM   { op, args,             next } =>  fcf::STORE_TO_RAM   { op, args => map rename args,             next => h next };
			      fcf::FETCH_FROM_RAM { op, args, name, type, next } =>  fcf::FETCH_FROM_RAM { op, args => map rename args, name, type, next => h next };

			      fcf::MATH { op, args, name, type, next }         =>  fcf::MATH { op,  args => map rename args,  name, type,  next => h next  };
			      fcf::PURE { op, args, name, type, next }         =>  fcf::PURE { op,  args => map rename args,  name, type,  next => h next  };

			      fcf::RAW_C_CALL { kind, cfun_name, cfun_type, args, results, next }
				  =>
				  fcf::RAW_C_CALL { kind, cfun_name, cfun_type,  args => map rename args,  results,  next => h next  };
			end;
		    
		    end;		# fun g

	    
                (fk, v, args, cl, g NIL ce);

	    };  # fun unrebind 
    };		# package un_rebind 
end;		# stipulate




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Copyright 1996 by Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
