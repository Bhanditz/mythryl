## clean-nextcode-g.pkg 

# Compiled by:
#     src/lib/compiler/core.sublib



# This file implements one of the nextcode transforms.
# For context, see the comments in
#
#     src/lib/compiler/back/top/highcode/highcode-form.api



# 'clean-nextcode' is called after almost every other
# optimization pass, to tidy up.  It implements
# a variety of clean-up stuff including dead code
# elimination, constant propagation, constant folding,
# and inlining of functions only called from a single spot.
#
# For background on the latter optimization, see:
#
#     Shrinking Lambda Expressions in Linear Time
#     Andrew W Appel, Trevor Jim
#     1993, 26p, J. Functional Programming
#     http://akpublic.research.att.com/~trevor/papers/shrinking.ps.gz
  


# Transformations performed by the contracter:
# 
# TRANSFORMATION:                       Click:   compiler::control::CG flag:
# ------------------------------------------------------------------------
# Inlining functions that are used once   e      beta_contract
# Cascaded inlining of functions          q
# The IF-idiom                            E      if_idiom
# Unify BRANCHs                           z      branchfold
# Constant folding:
#  SELECTs from known RECORDs             d
#  Handler operations                    ijk     handlerfold
#  SWITCH expressions                     h      switchopt
#  MATH expressions              FGHIJKLMNOPQX  arithopt
#  PURE expressions          RSTUVWYZ0123456789  arithopt
#  BRANCH expressions                   nopvw    comparefold
# 
# Dead variable elimination:         [down, up]           [down, up]
#  RECORDs                              [b, B]        [deadvars, deadup]
#  SELECTs                              [c, s]        [deadvars, deadup]
#  Functions                            [g, f]
#  LOOKERs                              [m,*]        [deadvars, deadup]
#  PUREs                                [m,*]        [deadvars, deadup]
#  Arguments                            [D, ]        [dropargs, ]
# 
# Conversion Primops:
#  testu					U (n)	
#  test					T (n)
#  copy					C (n)
#  extend					X (n)
#  trunc					R (n)



###       "Bringing computers into the
###        home won't change either one,
###        but may revitalize the corner
###        saloon."
###
###                  -- Alan Perlis



stipulate
    package fcf =  nextcode_form;						# nextcode_form			is from   src/lib/compiler/back/top/nextcode/nextcode-form.pkg
    package hct =  highcode_type;						# highcode_type			is from   src/lib/compiler/back/top/highcode/highcode-type.pkg
    package hut =  highcode_uniq_types;						# highcode_uniq_types		is from   src/lib/compiler/back/top/highcode/highcode-uniq-types.pkg
    package iht =  int_hashtable;						# int_hashtable		is from   src/lib/src/int-hashtable.pkg
herein

    api Clean_Nextcode {
	#
	clean_nextcode
	  :
          { function:	fcf::Function,
	    table:	iht::Hashtable( hut::Uniqtype ),
	    click:	String -> Void,
	    last:	Bool,
	    size:	Ref(Int)
	  }
	  ->
	  fcf::Function;
    };
end;



										# Machine_Properties		is from   src/lib/compiler/back/low/main/main/machine-properties.api
stipulate
    package fcf =  nextcode_form;						# nextcode_form			is from   src/lib/compiler/back/top/nextcode/nextcode-form.pkg
    package hcf =  highcode_form;						# highcode_form			is from   src/lib/compiler/back/top/highcode/highcode-form.pkg
    package hcv =  highcode_var;						# highcode_var			is from   src/lib/compiler/back/top/highcode/highcode-var.pkg
    package iht =  int_hashtable;						# int_hashtable			is from   src/lib/src/int-hashtable.pkg
    #
    package cg  =  controls::cg;						# controls			is from   src/lib/compiler/toplevel/main/controls.pkg
herein


    # We are invoked from:
    #
    #     src/lib/compiler/back/top/improve-nextcode/run-optional-nextcode-improvers-g.pkg
    #
    generic package   clean_nextcode_g   (
	#             ================
	#
	machine_properties:  Machine_Properties					# Typically 				  src/lib/compiler/back/low/main/intel32/machine-properties-intel32.pkg
    )
    : (weak) Clean_Nextcode							# Clean_Nextcode		is from   src/lib/compiler/back/top/improve-nextcode/clean-nextcode-g.pkg
    {
	fun inc (ri as REF i) = (ri := i + 1);
	fun dec (ri as REF i) = (ri := i - 1);

	wtoi = unt::to_int_x;
	itow = unt::from_int;

	say = controls::print::say;

	fun bug s
            =
            error_message::impossible ("Contract: " + s);

	exception CONSTANT_FOLD;

	fun sublist prior NIL => NIL;
	    sublist prior (hd ! tl) => if (prior hd)  hd ! (sublist prior tl);
				      else sublist prior tl;fi;
	end;

	fun map1 f (a, b)
            =
            (f a, b);

	fun app2 (f, NIL, NIL)       =>  ();
	    app2 (f, a ! al, b ! bl) =>  { f (a, b);   app2 (f, al, bl); };
	    app2 (f, _, _)           =>  bug "NContract app2 783";
	end;

	fun share_name (x, fcf::VAR   y) =>  hcv::share_name (x, y); 
	    share_name (x, fcf::LABEL y) =>  hcv::share_name (x, y); 
	    share_name _            =>  ();
	end;

	fun complain (t1, t2, s)
	    = 
	    {   say (s + "  ____ Type conflicting while contractions =====> \n    ");
	        say (hcf::uniqtype_to_string t1); say "\n and   \n    "; say (hcf::uniqtype_to_string t2);
	        say "\n \n";
	        say "_____________________________________________________ \n";
            };

	fun checklty s (t1, t2)
            =
            ();

	#  let fun g (hcf::INT,    hcf::INT) = ()
	#        | g (hcf::INT32,  hcf::INT32) = ()
	#        | g (hcf::BOOL,   hcf::BOOL) = ()
	#        | g (hcf::INT,    hcf::BOOL) = ()
	#        | g (hcf::BOOL,   hcf::INT) = ()
	#        | g (hcf::FLOAT64,hcf::FLOAT64) = ()
	#        | g (hcf::SRCONT, hcf::SRCONT) = ()
	#        | g (hcf::BOXED,  hcf::BOXED) = ()
	#        | g (hcf::RBOXED, hcf::RBOXED) = ()
	#        | g (hcf::INT,    hcf::RECORD NIL) = ()
	#        | g (hcf::RECORD NIL, hcf::INT) = ()
	#        | g (hcf::BOXED,  hcf::RBOXED) = ()         #  this is temporary 
	#        | g (hcf::RBOXED, hcf::BOXED) = ()         #  this is temporary 
	#        | g (hcf::ARROW (t1, t2), hcf::ARROW (t1', t2')) =
	#             (g (hcf::out t1, hcf::out t1'); g (hcf::out t2, hcf::out t2'))
	#        | g (hcf::RECORD l1, hcf::RECORD l2) = 
	#             app2 (g, map hcf::out l1, map hcf::out l2)
	#        | g (hcf::CONT t1, hcf::CONT t2) = g (hcf::out t1, hcf::out t2) 
	#        | g (t1, t2) = complain (hcf::inj t1, hcf::inj t2, "CTR *** " + s)
	#  in  g (hcf::out t1, hcf::out t2) 
	#  end

	is_cont
            =
            hcf::lt_is_fate; 

	fun equal_upto_alpha (ce1, ce2)
	    =
	    equ NIL (ce1, ce2)
            where
	        fun equ pairs
		    =
		    sameexp
		    where
			fun same (fcf::VAR a, fcf::VAR b)
				=> 
				{   fun get ((x, y) ! rest)
					    =>
					    a == x  and  b == y  or get rest;

					get NIL
					    =>
					    FALSE;
				    end;

				    a == b   or   get pairs;
				};

			    same (fcf::LABEL   a, fcf::LABEL   b) =>  same (fcf::VAR a, fcf::VAR b);
			    same (fcf::INT     i, fcf::INT     j) =>  i == j;
			    same (fcf::FLOAT64 a, fcf::FLOAT64 b) =>  a == b;
			    same (fcf::STRING  a, fcf::STRING  b) =>  a == b;
			    same (a, b)                           =>  FALSE;
			end;

			fun samefields ((a, ap) ! ar, (b, bp) ! br)
				=>
				ap==bp and same (a, b) and samefields (ar, br);

			    samefields (NIL, NIL) =>  TRUE;
			    samefields _          =>  FALSE;
			end;

			fun samewith p
			    =
			    equ (p ! pairs);

			fun samewith' args
			    =
			    equ (paired_lists::fold_right (fn ((w, _), (w', _), l) = (w, w') ! l)
						pairs args);

			fun all2 f (e ! r, e' ! r') =>  f (e, e') and all2 f (r, r');
			    all2 f (NIL, NIL)       =>  TRUE;
			    all2 f _                =>  FALSE;
			end;

			recursive val sameexp
			    = 
			    fn  ( fcf::GET_FIELD_I { i => i,  record => v,  name => w,  next => e,  ... },
				  fcf::GET_FIELD_I { i => i', record => v', name => w', next => e', ... }
				)
				    =>
				    i==i' and same (v, v') and samewith (w, w') (e, e');

				( fcf::DEFINE_RECORD { kind => k,  fields => vl,  name => w,  next => e  },
				  fcf::DEFINE_RECORD { kind => k', fields => vl', name => w', next => e' }
				)
				    =>
				    (k == k') and samefields (vl, vl') 
				    and samewith (w, w') (e, e');

				( fcf::GET_ADDRESS_OF_FIELD_I { i => i,  record => v,  name => w,  next => e  },
				  fcf::GET_ADDRESS_OF_FIELD_I { i => i', record => v', name => w', next => e' }
				)
				    =>
				    i==i' and same (v, v') and samewith (w, w') (e, e');

				( fcf::JUMPTABLE { i => i,  xvar => xvar,  nexts => nexts  },
				  fcf::JUMPTABLE { i => i', xvar => xvar', nexts => nexts' }
				)
				    =>
				    same (i, i') and all2 (samewith (xvar, xvar')) (nexts, nexts');

				( fcf::TAIL_CALL { func => f,  args => vl  },
				  fcf::TAIL_CALL { func => f', args => vl' }
				)
				    => 
				    same (f, f') and all2 same (vl, vl');

				( fcf::DEFINE_FUNS { funs => l,  next => e  },
				  fcf::DEFINE_FUNS { funs => l', next => e' }
				)
				    =>
				    FALSE;		# Punt!

				( fcf::IF_THEN_ELSE { op => op,  args => args,  xvar => xvar,  then_next => then_next,  else_next => else_next  },
				  fcf::IF_THEN_ELSE { op => op', args => args', xvar => xvar', then_next => then_next', else_next => else_next' }
				)
				    =>
				    op==op' and all2 same (args, args') 
				    and samewith (xvar, xvar') (then_next, then_next')
				    and samewith (xvar, xvar') (else_next, else_next');

				( fcf::FETCH_FROM_RAM { op => op,  args => args,  name => name,  next => next,  ... },
				  fcf::FETCH_FROM_RAM { op => op', args => args', name => name', next => next', ... }
				)
				    =>
				    op==op' and all2 same (args, args') and samewith (name, name')(next, next');

				( fcf::STORE_TO_RAM { op => op,  args => args,  next => next  },
				  fcf::STORE_TO_RAM { op => op', args => args', next => next' }
				)
				    =>
				    op==op' and all2 same (args, args') and sameexp (next, next');

				( fcf::MATH { op => op,  args => args,  name => name,  next => next,  ... },
				  fcf::MATH { op => op', args => args', name => name', next => next', ... }
				)
				    =>
				    op==op' and all2 same (args, args') and samewith (name, name')(next, next');

				( fcf::PURE { op => op,  args => args,  name => name,  next => next,  ... },
				  fcf::PURE { op => op', args => args', name => name', next => next', ... }
				)
				    =>
				    op==op' and all2 same (args, args') and samewith (name, name')(next, next');

				( fcf::RAW_C_CALL { kind => k,  cfun_name => l,  cfun_type => p,  args => vl,  results => wtl,  next => e  },
				  fcf::RAW_C_CALL { kind => k', cfun_name => l', cfun_type => p', args => vl', results => wtl', next => e' }
				)
				    =>
				    # We don't need to compare cfun_type info:  The cfun_types are
				    # the same iff the functions and arguments are the same:
				    #
				    k == k' and l == l' and
				    all2 same (vl, vl') and samewith'(wtl, wtl')(e, e');

			        _   => FALSE;
			  end;
		    end;
	    end;

	Info = RECINFO  List( (fcf::Value, fcf::Fieldpath) )
	     | SELINFO  (Int, fcf::Value, fcf::Type)
	     | OFFINFO  (Int, fcf::Value)
	     | WRPINFO  (fcf::p::Pure, fcf::Value)
	     | IF_IDIOM_INFO  { body:   Ref( Null_Or( (fcf::Variable, fcf::Instruction, fcf::Instruction) ) ) }
	     | MISCINFO  fcf::Type
	     | FNINFO  { args:         List( fcf::Variable ),
			 body:         Ref( Null_Or(  fcf::Instruction ) ),
			 special_use:  Ref( Null_Or( Ref( Int ) ) ),
			 live_args:    Ref( Null_Or( List( Bool ) ) )
		       };

	fun clean_nextcode
              {
                function => (fkind, fvar, fargs, ctyl, cexp), 
		table,
		click,
		last,			#  NOTE: the "last" argument is currently ignored. 
		size => nextcode_size
	      }
	    =
	    (fkind, fvar, fargs, ctyl, cexp')
            where

	        deadup          =  *controls::cg::deadup;
		cgbeta_contract =  *controls::cg::beta_contract;
		debug           =  *controls::cg::debugnextcode;		#  FALSE 

		fun debugprint s =  if debug  controls::print::say (s); fi;
		fun debugflush () =  if debug  controls::print::flush(); fi;

		rep_flag  =  machine_properties::representations;
		type_flag =  *cg::checknextcode1  and  *cg::checknextcode2  and  rep_flag;


		# It would be nice to get rid
                # of this type stuff one day. 
		#
		stipulate

		    exception NCONTRACT; 

		    fun value_name (fcf::VAR     v) =>  hcv::name_of_highcode_variable v;
			value_name (fcf::INT     i) =>  "Int" + int::to_string (i);
			value_name (fcf::FLOAT64 r) =>  "Float" + r;
			value_name (fcf::STRING  s) =>  "<" + s + ">";
			#
			value_name _ => "<others>";
                    end;

		    fun arg_lty []
                            =>
                            hcf::int_uniqtype;

		        arg_lty [t]
			    => 
			    hcf::if_uniqtype_is_tuple_type (
                              t, 
			      fn xs as (_ ! _) =>  length (xs) < machine_properties::max_rep_regs
					               ??  hcf::make_tuple_uniqtype [t]
                                                       ::  t;
				  _            =>  t;
                              end,

			      fn t =  hcf::if_uniqtype_is_package (
                                        t, 
					( fn xs as (_ ! _)
                                                =>
                                                if   (length xs  <  machine_properties::max_rep_regs)
						    
                                                     hcf::make_tuple_uniqtype [t];
                                                else
                                                     t;
                                                fi;

					     _  => t;
                                          end
                                        ),

					fn t =  t
                                      )
                            );

		        arg_lty r
                            =>
                            hcf::make_package_uniqtype r;	# This is INCORRECT !!!!!!!   XXX BUGGO FIXME
                    end;

		    addty
                        =
                        if type_flag
			    #
                            iht::set table;
                        else
                            fn _ = ();
                        fi;

		herein

		    # Only used when dropping args in
                    # reduce (MUTUALLY_RECURSIVE_FNS) case.
                    #
		    fun getty v
			= 
			if type_flag

			     (iht::get  table  v)
                             except
                                 _ =  {   controls::print::say ("NCONTRACT: Can't find the variable "  + 
					  (int::to_string v) + " in the table ***** \n");
				          raise exception NCONTRACT;
                                      };
			else
                             hcf::truevoid_uniqtype;
                        fi;

		    fun grabty u
			=
			{   fun g (fcf::VAR     v) =>  getty v;
				g (fcf::LABEL   v) =>  getty v;
				g (fcf::INT     _) =>  hcf::int_uniqtype;
				g (fcf::FLOAT64 _) =>  hcf::float64_uniqtype;
				g (fcf::STRING  _) =>  hcf::truevoid_uniqtype;
				g _                =>  hcf::truevoid_uniqtype;
                            end;

			    type_flag   ??   g u
			                ::   hcf::truevoid_uniqtype;
			};

		    fun newty (f, t)
                        =
                        if type_flag

			     ignore (iht::remove table f)
                             except
                                 _ = ();

			     addty (f, t);
			fi;

		    fun make_var (t)
                        =
			v
                        where
                            v =  hcv::make_highcode_variable();
			    addty (v, t);
			end;

		    fun ltc_fun (x, y)
			= 
			(hcf::uniqtype_is_typ x   and   hcf::uniqtype_is_typ y)
                            ??   hcf::make_lambdacode_arrow_uniqtype (x, y)
			    ::   hcf::make_lambdacode_generic_package_uniqtype   (x, y);


		    fun make_fn_lty (_, _, NIL)
                            =>
                            bug "make_fn_lty in nflatten";

		        make_fn_lty (k, cntt ! _, x ! r)
                            => 
			    hcf::ltw_is_fate
                              (
                                x,

                                fn [t2] => (k, ltc_fun (arg_lty r, t2));
				    _   => bug "unexpected make_fn_lty";
                                end, 

				fn [t2] => (k, ltc_fun (arg_lty r, hcf::make_typ_uniqtype t2));
				    _   => bug "unexpected make_fn_lty";
                                end, 

				fn x =  (k, ltc_fun (arg_lty r, x))
                              );

		        make_fn_lty (k, _, r)
                            =>
                            (k, hcf::make_uniqtype_fate([arg_lty r]));
                    end;

		    # Only used in newname:
		    #
		    fun same_lty (x, u)
			= 
			{   s =  (hcv::name_of_highcode_variable (x)) + (" *and* " + value_name (u));

			    if type_flag
                                 checklty s (getty x, grabty u);
			    fi;
			};  

		end;			# stipulate




		stipulate

                    exception USAGE_MAP;

		herein

                    my m:  iht::Hashtable { info: Info, used:  Ref( Int ), called:  Ref( Int ) }
			=  iht::make_hashtable  { size_hint => 128,  not_found_exception => USAGE_MAP };

		    get =  fn i =  iht::get  m  i 
				   except
                                       USAGE_MAP =  bug ("USAGE_MAP on " + int::to_string i);

		    enter =  iht::set m;

		    fun rmv i
                        =
                        ignore (iht::remove m i)
                        except
                            _ = ();
		end;

		fun use (fcf::VAR   v) =>  inc (.used (get v));
		    use (fcf::LABEL v) =>  inc (.used (get v));
		    use _              =>  ();
                end;

		fun use_less (fcf::VAR   v) =>  if  deadup     dec (.used (get v));  fi;
		    use_less (fcf::LABEL v) =>  if  deadup     dec (.used (get v));  fi;
		    use_less _              =>  ();
                end;

		fun used_once v
		    =
		    *(.used (get v)) == 1;

		fun used v
		    =
		    *(.used (get v)) > 0;

		fun call (fcf::VAR v)
			=> 
			{   (get v) ->  { called, used, ... };

			    inc called;
                            inc used;
			};

		    call (fcf::LABEL v) =>  call (fcf::VAR v);
		    call _              =>  ();
                end;

		fun call_less (fcf::VAR v)
			=>
			if deadup
			    #
			    (get v) ->  { called, used, ... };

			    dec called;
			    dec used;
			fi;

		    call_less (fcf::LABEL v) =>  call_less (fcf::VAR v);
		    call_less _         =>  ();
                end;

		fun call_and_clobber (fcf::VAR v)
			=> 
			{   (get v) ->  { called, used, info };

			    inc called;
                            inc used;

			    case info
                                #
			        FNINFO { body, ... } =>  body := NULL;
			        _                    =>  ();
			    esac;
			};

		    call_and_clobber (fcf::LABEL v) =>  call (fcf::VAR v);
		    call_and_clobber _              =>  ();
		end;

		fun enter_rec  (w, vl) =  enter (w,{ info=>RECINFO  vl, called=>REF 0, used=>REF 0 } );
		fun enter_misc (w, ct) =  enter (w,{ info=>MISCINFO ct, called=>REF 0, used=>REF 0 } );

		misc_bog = MISCINFO fcf::bogus_pointer_type;

		fun enter_misc0 w
                    =
                    enter (w,{ info=>misc_bog, called=>REF 0, used=>REF 0 } );

		fun enter_wrp (w, p, u)
                    = 
		    enter (w,{ info=>WRPINFO (p, u), called=>REF 0, used=>REF 0 } );

		fun enter_fn (_, f, vl, cl, cexp)
                    =
		    {   enter
                          (
                              f,
                              { called => REF 0,
                                used   => REF 0,
				info   => FNINFO { args        => vl, 
					           body        => REF (cgbeta_contract ?? THE cexp :: NULL),

					           special_use => REF NULL,
					           live_args   => REF NULL
                                                 }
                              }
                          );

		        app2 (enter_misc, vl, cl);
                    };

		# *********************************************************************
		#  checkFunction: used by pass1 (MUTUALLY_RECURSIVE_FNS ...) to decide
		#  (1) whether a function will be inlined for the if idiom;
		#  (2) whether a function will drop some arguments.
		#  ********************************************************************

		fun check_function (_, f, vl, _, _)
		    = 
		    case (get f)
			#
			{ called=>REF 2, used=>REF 2,
			  info=>FNINFO { special_use=>REF (THE (REF 1)),
					 body as REF (THE (fcf::IF_THEN_ELSE { xvar, then_next, else_next, ... })),
                                         ...
				       },
			  ...
			} 
			    =>
			    if (not *cg::if_idiom)
				#
				body := NULL;
			    else
				# NOTE: remapping f 
				#
				enter
				  ( f,
				    { info   => IF_IDIOM_INFO { body => REF (THE (xvar, then_next, else_next)) },
				      called => REF 2,
				      used   => REF 2
				    }
				  );
			    fi;

			{ called=>REF c, used=>REF u, info=>FNINFO { live_args, ... }}
			    =>
			    if ( u == c			#  escaping function 
				 and *cg::dropargs
			    )
				 live_args := THE (map used vl);
			    fi;

			_  => ();
                    esac;


		# ************************************************************************
		#  pass1: Gather usage information on the variables in a nextcode expression,  
		#         and make a few decisions about whether to inline functions:            
		#         (1) If Idiom                                                    
		#         (2) NO_INLINE_INTO                                              
		# ************************************************************************
		recursive val pass1
                    =
                    fn cexp =  p1 FALSE cexp

		also
                p1  =
                    fn no_inline
                        =
			g1
                        where
			    recursive val g1
                                =
			        fn fcf::DEFINE_RECORD { fields, name, next, ... }
                                       =>
                                       {   enter_rec (name, fields);
                                           apply (use o #1) fields;
                                           g1 next;
                                       };

				   fcf::GET_FIELD_I { i, record, name, type, next }
                                       => 
				       {   enter (name, { info=>SELINFO (i, record, type), called=>REF 0, used=>REF 0 } );
				           use record;
                                           g1 next;
                                       };

				   fcf::GET_ADDRESS_OF_FIELD_I { i, record, name, next }
                                       => 
				       {   enter (name, { info=>OFFINFO (i, record), called=>REF 0, used=>REF 0 } );
				           use record;
                                           g1 next;
                                       };

				   fcf::TAIL_CALL { func, args }
                                       =>
                                       {   if   no_inline      call_and_clobber func;
					   else                call             func;
                                           fi;

					   apply use args;
                                       };

				   fcf::DEFINE_FUNS { funs, next }
                                       =>
                                       {   apply  enter_fn  funs;

					   apply
					       fn (fcf::NO_INLINE_INTO, _, _, _, body) =>  p1 (not last) body;
						  (_,                   _, _, _, body) =>  g1 body;
					       end

                                               funs;

					   g1  next;

					   apply  check_function  funs;
                                       };

				   fcf::JUMPTABLE { i, xvar, nexts }
                                       =>
                                       {   use  i;
                                           enter_misc0  xvar;
                                           apply  g1  nexts;
                                       };

				   fcf::IF_THEN_ELSE { op => _,
						       args,
						       xvar,
						       then_next as fcf::TAIL_CALL { func => fcf::VAR f1, args => [fcf::INT 1] },
						       else_next as fcf::TAIL_CALL { func => fcf::VAR f2, args => [fcf::INT 0] }
						     }
					=>
					{    case (get f1)
                                                 #
						 { info => FNINFO { special_use,
							            args => [w1],
                                                                    body => REF (THE (fcf::IF_THEN_ELSE { op   => fcf::p::CMP { op=>fcf::p::NEQ, ... },
                                                                                                    args => [  fcf::INT 0,
                                                                                                               fcf::VAR w2
                                                                                                            ],
                                                                                                    ...
                                                                                                  }
                                                                                )    ),
                                                                    ...
                                                                  },
                                                   ...
                                                 }
						     => 
						     #  Handle IF IDIOM 
						     if (f1==f2 and w1==w2) 
						            my { used, ... } = get w1;
							    special_use := THE used;
						     fi;
						 _ => ();
					     esac;

					     apply use args;
					     enter_misc (xvar, fcf::bogus_pointer_type);
					     g1 then_next;
					     g1 else_next;
					};

				   fcf::IF_THEN_ELSE { op, args, xvar, then_next, else_next }
					=>
					{   apply use args;
					    enter_misc0 xvar;
					    g1 then_next;
					    g1 else_next;
					};

				   fcf::STORE_TO_RAM   { args,       next, ... }            => { apply use args;                    g1 next; };
				   fcf::FETCH_FROM_RAM { args, name, next, ... }            => { apply use args; enter_misc0 name;  g1 next; };
				   fcf::MATH           { args, name, next, ... }            => { apply use args; enter_misc0 name;  g1 next; };

				   fcf::PURE { op as fcf::p::IWRAP,     args =>[u], name, next, ... } =>   {  use u;  enter_wrp (name, op, u);  g1 next;  };
				   fcf::PURE { op as fcf::p::IUNWRAP,   args =>[u], name, next, ... } =>   {  use u;  enter_wrp (name, op, u);  g1 next;  };
				   fcf::PURE { op as fcf::p::I32WRAP,   args =>[u], name, next, ... } =>   {  use u;  enter_wrp (name, op, u);  g1 next;  };
				   fcf::PURE { op as fcf::p::I32UNWRAP, args =>[u], name, next, ... } =>   {  use u;  enter_wrp (name, op, u);  g1 next;  };
				   fcf::PURE { op as fcf::p::FWRAP,     args =>[u], name, next, ... } =>   {  use u;  enter_wrp (name, op, u);  g1 next;  };
				   fcf::PURE { op as fcf::p::FUNWRAP,   args =>[u], name, next, ... } =>   {  use u;  enter_wrp (name, op, u);  g1 next;  };

				   fcf::PURE { args, name, next, ... }
					=>
					{   apply  use  args;
					    enter_misc0  name;
					    g1  next;
					};

				   fcf::RAW_C_CALL { args, results, next, ... }
					=>
					{   apply  use  args;
					    apply  (enter_misc0 o #1)  results;
					    g1  next;
					};

                                end;	# fn
			end;		# p1


		stipulate

		    exception BETA;

		    my m2:  iht::Hashtable( fcf::Value )
			=   iht::make_hashtable  { size_hint => 32,  not_found_exception => BETA };

		    mapm2 =  iht::get  m2;

		herein

		    fun ren (v0 as fcf::VAR   v) =>   (ren (mapm2 v)  except BETA = v0);
			ren (v0 as fcf::LABEL v) =>   (ren (mapm2 v)  except BETA = v0);
			ren x => x;
		    end;

		    fun newname (vw as (v, w))
			= 
			{   (get v) -> { used   => REF u,
                                         called => REF c,
                                         ...
                                       };

			    fun f (fcf::VAR w')
                                    =>
				    {   (get w') -> { used, called, ... };
					#
					used   := *used   + u;
                                        called := *called + c;
				    };

			        f (fcf::LABEL w') => f (fcf::VAR w');
			        f _ => ();
			    end;

			    if deadup    f (ren w);   fi;

			    rmv v;
			    same_lty vw;
			    share_name vw;
			    iht::set m2 vw;
			};

		end;

		fun newnames (v ! vl, w ! wl) =>   { newname (v, w);   newnames (vl, wl); };
		    newnames _                =>   ();
		end;


		# *******************************************************************
		#  Drop_body: used when dropping a function to adjust the usage      
		#  Counts of the free variables of the function.                     
		#  This should match up closely with pass1 above.                    
		# *******************************************************************
		stipulate

                    use_less  =   use_less o ren;
		    call_less =  call_less o ren;

		herein

		    fun drop_body (fcf::TAIL_CALL		{ func, args })		=>  { call_less func; apply use_less args; };
			#
			drop_body (fcf::GET_FIELD_I		{ record, next, ... })	=>  { use_less record;  drop_body next;  };
			drop_body (fcf::GET_ADDRESS_OF_FIELD_I	{ record, next, ... })	=>  { use_less record;  drop_body next;  };
			#
			drop_body (fcf::JUMPTABLE		{ i, nexts, ... })	=>  { use_less i; apply drop_body nexts; };
			#
			drop_body (fcf::DEFINE_FUNS		{ funs, next })		=>  { apply (drop_body o #5) funs;	drop_body next;  };
			drop_body (fcf::DEFINE_RECORD		{ fields, next, ... })	=>  { apply (use_less o #1) fields;	drop_body next;  };
			drop_body (fcf::IF_THEN_ELSE { args, then_next, else_next, ... }) =>  { apply use_less args;		drop_body then_next;  drop_body else_next;    };
			#
			drop_body (fcf::STORE_TO_RAM		{ args, next, ... })	=>  { apply use_less args;  drop_body next;};
			drop_body (fcf::FETCH_FROM_RAM		{ args, next, ... })	=>  { apply use_less args;  drop_body next;};
			#
			drop_body (fcf::MATH			{ args, next, ... })	=>  { apply use_less args;  drop_body next; };
			drop_body (fcf::PURE			{ args, next, ... })	=>  { apply use_less args;  drop_body next; };
			drop_body (fcf::RAW_C_CALL		{ args, next, ... })	=>  { apply use_less args;  drop_body next; };
		    end;
		end;


		fun setter (fcf::p::UPDATE, [_, _, fcf::INT     _]) =>   fcf::p::UNBOXED_SET;
		    setter (fcf::p::UPDATE, [_, _, fcf::FLOAT64 _]) =>   fcf::p::BOXED_SET;
		    setter (fcf::p::UPDATE, [_, _, fcf::STRING  _]) =>   fcf::p::BOXED_SET;

		    setter (fcf::p::UPDATE, [_, _, fcf::VAR v])
			=> 
			case (.info (get v))
			    #                          
			    FNINFO  _ =>  fcf::p::BOXED_SET;
			    RECINFO _ =>  fcf::p::BOXED_SET;
			    OFFINFO _ =>  fcf::p::BOXED_SET;
			     _        =>  fcf::p::UPDATE;
			esac;

		    setter (fcf::p::ASSIGN, [_, fcf::INT _]) => fcf::p::SET_INT_REFCELL;
		    setter (i, _) => i;
		end;

		fun same_lvar (highcode_variable, fcf::VAR lv)   =>   lv == highcode_variable;
		    same_lvar _ => FALSE;
		end;

		fun cvt_pre_condition (n: Int, n2, x, v2)
		    =
		    n == n2 and used_once (x) and same_lvar (x, ren v2); 

		fun cvt_pre_condition_inf (x, v2)
		    =
		    used_once (x) and same_lvar (x, ren v2); 

		recursive val reduce
                    =
                    fn cexp =  g NULL cexp

		also
                g   =
                    fn handler
                        =
			g'
                        where
			    recursive val g'
                                =
				fn fcf::DEFINE_RECORD { kind => k, fields => vl, name => w, next => e }
				    =>
				    {   (get w) ->   { used, ... };

					vl' = map (map1 ren) vl;

					if (*used==0 and *cg::deadvars)
					    #    
					    click "b";
					    apply (use_less o #1) vl';
					    g' e;
					else
					    fun chunklen (fcf::VAR z)
						    =>
						    case (.info (get z))
							#
							SELINFO(_, _, fcf::type::POINTER (fcf::RPT k)) => k;
							SELINFO(_, _, fcf::type::POINTER (fcf::FPT k)) => k;

							MISCINFO (fcf::type::POINTER (fcf::RPT k)) => k;
							MISCINFO (fcf::type::POINTER (fcf::FPT k)) => k;

							RECINFO l => length l;
							_ => -1;
						    esac;

						chunklen _ => -1;
					    end;

					    fun samevar (fcf::VAR x, fcf::VAR y)   =>   x == y;
						samevar _                          =>   FALSE;
					    end;

					    fun check1 ((fcf::VAR z) ! r, k, a)
						    => 
						    case (get z)
							#
							{ info=>SELINFO (i, b, _), ... }
							    => 
							    if  (i==k   and   samevar (ren b, a))   check1 (r, k+1, a);
							    else                                    NULL;
							    fi;

							_ => NULL;
						    esac;

						check1(_ ! r, k, _)
						    =>
						    NULL; 

						check1([], k, a)
						    => 
						    chunklen a  ==  k
							??   THE a
							::   NULL;
					    end;

					    fun check ((fcf::VAR z) ! r)
						    => 
						    case (get z)

							 { info=>SELINFO (0, a, _), ... }
							     => 
							     check1 (r, 1, ren a);

							 _   => NULL;
						    esac;

						check _ => NULL;
					    end;

					    vl'' = map #1 vl';

					    case (check (vl''))
						#
						NULL => 
						     {   e' = g' e;

							 if (*used==0 and deadup)
							     #
							     click "B";
							     apply use_less vl'';
							     e';
							 else
							     fcf::DEFINE_RECORD { kind => k, fields => vl', name => w, next => e' };
							 fi;
						     };

						THE z => 
						     {   newname (w, z);
							 click "B";		 # ** ? **   XXX BUGGO FIXME
							 apply use_less vl'';
							 g' e;
						     };
					    esac;

					  fi;
				    };

				fcf::GET_FIELD_I { i, record, name, type, next }
				    =>
				    {   (get name) ->   { used, ... };

					record' = ren record;

					if (*used==0 and *cg::deadvars)
					    #
					    click "c"; #  Could rmv name here 
					    use_less record';
					    g' next;
					else
					    z = case record'
						    #
						    fcf::VAR v''
							=>
							case (get v'')

							     { info=>RECINFO vl, ... }
								 =>
								 ( {   z  =  #1 (list::nth (vl, i));
								       z' =  ren z;

								       case z'
									   fcf::FLOAT64 _ =>  NULL; 
									    _             =>  THE z';
								       esac;
								   }
								   except
								       (SUBSCRIPT|INDEX_OUT_OF_BOUNDS) = NULL
								 );

							     _ => NULL;
							esac;

						    _ => NULL;
						esac;

					    z =   if *cg::selectopt   z;
						  else                NULL;
						  fi;

					    case z
						#
						NULL   => {   next' = g' next;

							      if (*used==0 and deadup)
								  #
								  click "s";
								  use_less record';
								  next';
							      else
								  fcf::GET_FIELD_I { i, record => record', name, type, next => next' };
							      fi;
							  };

						THE z' => {   newname (name, z');
							      click "d";			#  Could rmv name here 
							      use_less record';
							      g' next;
							  };
					    esac;
					fi;
				    };

				fcf::GET_ADDRESS_OF_FIELD_I { i, record, name, next }
				    =>
				    fcf::GET_ADDRESS_OF_FIELD_I { i, record => ren record, name, next => g' next };

				fcf::TAIL_CALL { func, args }
				    =>
				    {   args =  map ren args;
					func =  ren func;

					fun newvl NULL
						=>
						args;

					    newvl (THE live)
						=>
						{   fun z (a ! al, FALSE ! bl) =>  z (al, bl);
							z (a ! al, TRUE  ! bl) =>  a ! z (al, bl);
							z _                    =>  NIL;
						    end;

						    # This code may be obsolete.
						    # See the comment in the
						    # MUTUALLY_RECURSIVE_FNS
						    # case below.

						    case (z (args, live))
							#
							NIL  => [fcf::INT 0];

							[u]  => hcf::ltw_is_fate (
								   grabty u, 
								   fn _ = [u, fcf::INT 0],
								   fn _ = [u, fcf::INT 0],
								   fn _ = [u]
								);

							vl'' => vl'';
						    esac;
						};
					end;

					fun trybeta fv
					    =
					    {   my { used=>REF u, called=>REF c, info }
						    =
						    get fv;

						case info
						    #
						    FNINFO { args => args', body, live_args, ... }
							=>
							if (c!=1 or u!=1)
							    #
							    fcf::TAIL_CALL { func, args => newvl *live_args };
							else
							    case body
								#
								REF (THE b)
								    =>
								    {   newnames (args', args);
									call_less func;
									apply use_less args;
									body:=NULL;
									g' b;
								    };

								_   =>   fcf::TAIL_CALL { func, args => newvl *live_args };
							    esac;
							fi;

						    _   =>   fcf::TAIL_CALL { func, args };
						esac;
					    };

					case func
					    #
					    fcf::VAR   fv =>  trybeta fv;
					    fcf::LABEL fv =>  trybeta fv;
					    _             =>  fcf::TAIL_CALL { func, args };
					esac;
				   };

				fcf::DEFINE_FUNS { funs, next }
				    =>
				    {
					funs =  map getinfo funs;
					funs =  sublist keep funs;
					next =  g' next;
					funs =  sublist keep2 funs;
					funs =  map reduce_body funs;

					case (sublist keep3 funs)
					    #
					    NIL  =>  next;
					    funs =>  fcf::DEFINE_FUNS { funs => map #1 funs,  next };
					esac;
				    }
				    where
				        fun getinfo (x as (fk, f, vl, cl, b))
					    =
					    {   (get f) ->   { used, called, info, ... };

						case info
						    #
						    FNINFO { live_args=>REF (THE live), ... }
							=>
							{   fun z (a ! al, FALSE ! bl) => z (al, bl);
								z (a ! al, TRUE ! bl) => a ! z (al, bl);
								z _ => NIL;
							    end;

							    vl' = z (vl, live);
							    cl' = z (cl, live);

							    drop =  fold_right  (fn (a, b) =  a ?? b :: b+1)
										0
										live;

							    fun dropclicks (n)
								=
								if (n > 0)
								    #
								    click "D";
								    dropclicks (n - 1);
								fi;


							    # The code below may be obsolete.  I think that
							    # we used to distinguish between user functions
							    # and fates in the closure phase by
							    # the number of arguments, and also we might
							    # not have been able to handle functions with
							    # no arguments.  Possibly we can now remove
							    # these special cases.     XXX BUGGO FIXME

							    tt' = map getty vl';

							    my (vl'', cl'', tt'')
								=
								case tt'
								    #
								    NIL =>
									{   x = make_var (hcf::int_uniqtype);
									    dropclicks (drop - 1);
									    enter_misc0 x;
									    ([x],[fcf::type::INT],[hcf::int_uniqtype]);
									};

								    [x] =>
									if (is_cont x)
									    #									        
									    x = make_var (hcf::int_uniqtype);
									    dropclicks (drop - 1);
									    enter_misc0 x;
									    (vl' @ [x], cl' @ [fcf::type::INT], 
									    tt' @ [hcf::int_uniqtype]);
									else 
									    dropclicks drop;
									    (vl', cl', tt');
									fi;

								    _   =>
									{   dropclicks (drop);
									    (vl', cl', tt');
									};
								esac;

							    my (fk', lt)
								=
								make_fn_lty (fk, cl'', tt'');

							    newty (f, lt);

							    ((fk', f, vl'', cl'', b), used, called, info);
							};

						    _ => (x, used, called, info);
						esac;
					    };

					fun keep (_, used, called, info)
					    =
					    case (*called, *used, info)

						 (_, 0, FNINFO { body as REF (THE b), ... } )
						     =>
						     {   click "g";
							 body:=NULL;
							 drop_body b;
							 FALSE;
						     };

						 (_, 0, FNINFO { body=>REF NULL, ... } )
						     =>
						     {   click "g";
							 FALSE;
						     };

						 (1, 1, FNINFO { body=>REF (THE _), ... } )
						     =>
						     # NOTE: This is an optimistic click.
						     # The call could disappear before we
						     # get there; then the body would
						     # not be cleared out, dangerous.	XXX BUGGO FIXME
						     {   click "e";
							 FALSE;
						     };

						 (_, _, IF_IDIOM_INFO { body=>REF b, ... } )
						     =>
						     {   click "E";
							 FALSE;
						     };

						 _   => TRUE;
					    esac;

					fun keep2 (_, used, _, info)
					    =
					    case (*used, info)

						 (0, FNINFO { body as REF (THE b), ... } )
						     =>
						     # All occurrences were lost:
						     #	
						     {   click "f";
							 body:=NULL;
							 drop_body b;
							 FALSE;
						     };

						 (0, FNINFO { body=>REF NULL, ... } )
						     =>
						     # We performed a cascaded inlining:
						     #
						     {   click "q";
							 FALSE;
						     };

						 (_, FNINFO { body, ... } )
						     =>
						     {   body := NULL;
							 TRUE;
						     };

						 _   => TRUE;

					    esac;

					fun keep3 ((_, _, _, _, b), used, _, info)
					    =
					    case (*used, info)

						 (0, FNINFO _)
						     =>
						     # All occurrences were lost:
						     #
						     {   click "f";
							 drop_body b;
							 FALSE;
						     };

						 _   => TRUE;
					    esac;

					fun reduce_body ((fk, f, vl, cl, body), used, called, info)
					    =
					    ((fk, f, vl, cl, reduce body), used, called, info);

				    end;

				fcf::JUMPTABLE { i, xvar, nexts }
				    => 
				    case (ren i)
					#
					i as fcf::INT k							# We're switching on a constant, so drop all code branches but the relevant one.
					    => 
					    if (not *cg::switchopt)
						#
						fcf::JUMPTABLE { i, xvar, nexts => map g' nexts };
					    else
						fun f (e ! el, j)
							=>
							{   if (j != k)   drop_body e;   fi;

							    f (el, j+1);
							};

						    f (NIL, _) =>  ();
						end;

						click "h";
						f (nexts, 0);
						newname (xvar, fcf::INT 0); 
						g' (list::nth (nexts, k));
					    fi;

					i  =>  fcf::JUMPTABLE { i, xvar, nexts => map g' nexts };
				    esac;

				fcf::FETCH_FROM_RAM { op => fcf::p::GET_EXCEPTION_HANDLER, name, type, next, ... }
				    =>
				    if  *cg::handlerfold
					#
					case handler
					    #						     
					    NULL
						=>
						if (used name) 
						    #
						    fcf::FETCH_FROM_RAM { op   =>  fcf::p::GET_EXCEPTION_HANDLER,
                                                                          args =>  [],
                                                                          name,
                                                                          type,
                                                                          next =>  g (THE (fcf::VAR name)) next
                                                                        };
						else
						    click "i";
						    g' next;
						fi;

					    THE name'
						=>
						{   click "j";
						    newname (name, name');
						    g' next;
						};
					esac;
				    else
					fcf::FETCH_FROM_RAM { op   =>  fcf::p::GET_EXCEPTION_HANDLER,
                                                              args =>  [],
                                                              name,
                                                              type,
                                                              next =>  g (THE (fcf::VAR name)) next
                                                            };
				    fi;

				fcf::STORE_TO_RAM { op => fcf::p::SET_EXCEPTION_HANDLER, args => [v], next }
				    =>
				    {   v' = ren v;
					next = g (THE v') next;

					fun same_variable (fcf::VAR x, fcf::VAR y) =>   x == y;
					    same_variable _			   =>   FALSE;
					end;

					if (not *cg::handlerfold)
					    #
					    fcf::STORE_TO_RAM { op => fcf::p::SET_EXCEPTION_HANDLER, args => [v'], next };
					else
					    case handler 
						#
						THE v''
						    => 
						    if (same_variable (v', v''))
							#
							click "k";
							use_less v'';
							next;
						    else
							fcf::STORE_TO_RAM { op => fcf::p::SET_EXCEPTION_HANDLER, args => [v'], next };
						    fi;

						_ => fcf::STORE_TO_RAM { op => fcf::p::SET_EXCEPTION_HANDLER, args => [v'], next };
					    esac;
					fi;
				    };

			    #   fcf::STORE_TO_RAM { op, args, next } => fcf::STORE_TO_RAM { op, args => map ren args, next => g' next } 

				fcf::STORE_TO_RAM { op, args, next }
				    => 
				    {   args = map ren args;
					fcf::STORE_TO_RAM { op => setter (op, args),
                                                            args,
                                                            next => g' next
                                                          };
				    };

				fcf::FETCH_FROM_RAM { op, args, name, type, next }
				    => 
				    {   args = map ren args;

					(get name) ->   { used, ... };

					if (*used==0 and *cg::deadvars)
					    #
					    click "m";
					    apply use_less args;
					    g' next;
					else
					    next = g' next;

					    if (*used==0 and deadup)
						#
						click "*";
						apply use_less args;
						next;
					    else
						fcf::FETCH_FROM_RAM { op, args, name, type, next };
					    fi;
					fi;
				    };

				fcf::MATH { op   => fcf::p::SHRINK_INT (p, n),
                                            args => [v],
                                            name => x,
                                            type => t,
                                            next => e as fcf::PURE { op   =>  fcf::p::COPY (n2, m),
                                                                     args =>  [v2],
                                                                     name =>  x2,
                                                                     type =>  t2,
                                                                     next =>  e2
                                                                   }
                                          }
				    =>
				    if (cvt_pre_condition (n, n2, x, v2) and n == m)   click "T (1)";   fcf::MATH { op => fcf::p::SHRINK_INT (p, m), args => [ren v], name => x2, type => t2, next => g' e2 };
				    else                                                                fcf::MATH { op => fcf::p::SHRINK_INT (p, n), args => [ren v], name => x,  type => t,  next => g' e  };
				    fi;

				fcf::MATH { op   =>  fcf::p::SHRINK_INTEGER n,
                                            args =>  [v, f],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::PURE { op   =>  fcf::p::COPY (n2, m),
                                                                      args =>  [v2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    if (cvt_pre_condition (n, n2, x, v2) and n == m)   click "T (1)";   fcf::MATH { op => fcf::p::SHRINK_INTEGER m, args => [ren v, ren f], name => x2, type => t2, next => g' e2 };
				    else                                                                fcf::MATH { op => fcf::p::SHRINK_INTEGER n, args => [ren v, ren f], name => x,  type => t,  next => g' e  };
				    fi;

				fcf::MATH { op   =>  fcf::p::SHRINK_INT (p, n),
                                            args =>  [v],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::MATH { op   =>  fcf::p::SHRINK_INT (n2, m),
                                                                      args =>  [v2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    => 
				    if (cvt_pre_condition (n, n2, x, v2))              click "T (2)";   fcf::MATH { op => fcf::p::SHRINK_INT (p, m), args => [ren v], name => x2, type => t2, next => g' e2 };
				    else                                                                fcf::MATH { op => fcf::p::SHRINK_INT (p, n), args => [ren v], name => x,  type => t,  next => g' e  };
				    fi;

				fcf::MATH { op   =>  fcf::p::SHRINK_INTEGER n,
                                            args =>  [v, f],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::MATH { op   =>  fcf::p::SHRINK_INT (n2, m),
                                                                      args =>  [v2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    => 
				    if (cvt_pre_condition (n, n2, x, v2) )             click "T (2)";   fcf::MATH { op => fcf::p::SHRINK_INTEGER m, args => [ren v, ren f], name => x2, type => t2, next => g' e2 };
				    else                                                                fcf::MATH { op => fcf::p::SHRINK_INTEGER n, args => [ren v, ren f], name => x,  type => t,  next => g' e  };
				    fi;

				fcf::MATH { op   =>  fcf::p::SHRINK_UNT (p, n),
                                            args =>  [v],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::PURE { op   =>  fcf::p::COPY (n2, m),
                                                                      args =>  [v2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    if (cvt_pre_condition (n, n2, x, v2) and n == m )  click "U (1)";   fcf::MATH { op => fcf::p::SHRINK_UNT (p, m), args => [ren v], name => x2, type => t2, next => g' e2 };
				    else                                                                fcf::MATH { op => fcf::p::SHRINK_UNT (p, n), args => [ren v], name => x,  type => t,  next => g' e  };
				    fi;

				fcf::MATH { op   =>  fcf::p::SHRINK_UNT (p, n),
                                            args =>  [v],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::MATH { op   =>  fcf::p::SHRINK_UNT (n2, m),
                                                                      args =>  [v2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    => 
				    if (cvt_pre_condition (n, n2, x, v2))              click "U (2)";   fcf::MATH { op => fcf::p::SHRINK_UNT (p, m), args => [ren v], name => x2, type => t2, next => g' e2 };
				    else                                                                fcf::MATH { op => fcf::p::SHRINK_UNT (p, n), args => [ren v], name => x,  type => t,  next => g' e  };
				    fi;

				fcf::MATH { op, args, name, type, next }
				    =>
				    {   args =  map  ren  args;

					if *cg::arithopt
					    #
					    newname (name, arith (op, args));
					    apply use_less  args;
					    g' next;
					else
					    raise exception CONSTANT_FOLD;
					fi
					except
					    CONSTANT_FOLD =>  fcf::MATH { op, args, name, type, next => g' next };
					    OVERFLOW      =>  fcf::MATH { op, args, name, type, next => g' next };
					end;
				    };

				fcf::PURE { op   =>  fcf::p::CHOP (p, n),
                                            args =>  [v],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::PURE { op   =>  pure,
                                                                      args =>  [v2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    {   fun skip ()
					    =
					    fcf::PURE { op   =>  fcf::p::CHOP (p, n),
                                                        args =>  [ren v],
                                                        name =>  x,
                                                        type =>  t,
                                                        next =>  g' e
                                                      };


					fun check_clicked (tok, n2, m, pure_op)
					    = 
					    if (cvt_pre_condition (n, n2, x, v2))
						#
						click tok; 
						fcf::PURE { op   =>  pure_op (p, m),
                                                            args =>  [ren v],
                                                            name =>  x2,
                                                            type =>  t2,
                                                            next =>  g' e2
                                                          };
					    else
						skip ();
					    fi;


					case pure
					    #
					    fcf::p::CHOP (n2, m)
						=>
						check_clicked("R (1)", n2, m, fcf::p::CHOP);

					    fcf::p::COPY (n2, m)
						=> 
						if (n2 == m)   check_clicked("R (2)", n2, m, fcf::p::CHOP);
						else	       skip ();
						fi;

					    _  => skip();
					esac;
				    };

				fcf::PURE { op   =>  fcf::p::CHOP_INTEGER n,
                                            args =>  [v, f],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::PURE { op   =>  pure,
                                                                      args =>  [v2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    {   fun skip ()
					    =
					    fcf::PURE { op   =>  fcf::p::CHOP_INTEGER n,
                                                        args =>  [ren v, ren f],
                                                        name =>  x,
                                                        type =>  t,
                                                        next =>  g' e
                                                      };

					fun check_clicked (tok, n2, m)
					    = 
					    if (cvt_pre_condition (n, n2, x, v2))
						#  
						click tok; 
						fcf::PURE { op   =>  fcf::p::CHOP_INTEGER m,
                                                            args =>  [ren v, ren f],
                                                            name =>  x2,
                                                            type =>  t2,
                                                            next =>  g' e2
                                                          };
					    else
						skip();
					    fi;

					case pure
					    #
					    fcf::p::CHOP (n2, m)
						=>
						check_clicked("R (1)", n2, m);

					    fcf::p::COPY (n2, m)
						=> 
						if (n2 == m)    check_clicked ("R (2)", n2, m);
						else		skip ();
						fi;

					    _   => skip ();
					esac;
				    };

				fcf::PURE { op   =>  fcf::p::STRETCH (p, n),
                                            args =>  [v],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::PURE { op   =>  fcf::p::STRETCH_TO_INTEGER n2,
                                                                      args =>  [v2, f],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				     =>
				     if (cvt_pre_condition (n, n2, x, v2))
					 # 
					 click "X (1')";
					 fcf::PURE { op => fcf::p::STRETCH_TO_INTEGER p, args => [ren v, ren f], name => x2, type => t2, next => g' e2 };
				     else
					 fcf::PURE { op => fcf::p::STRETCH (p, n),       args => [ren v],        name => x,  type => t,  next => g' e  };
				     fi;

				fcf::PURE { op   =>  fcf::p::STRETCH (p, n),
                                            args =>  [v],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::PURE { op   =>  pure,
                                                                      args =>  [v2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    {   fun skip ()
					    =
					    fcf::PURE { op   =>  fcf::p::STRETCH (p, n),
                                                        args =>  [ren v],
                                                        name =>  x,
                                                        type =>  t,
                                                        next =>  g' e
                                                      };

					fun check_clicked (tok, n2, pure_op)
					    = 
					    if (cvt_pre_condition (n, n2, x, v2))
						#  
						click tok;
						fcf::PURE { op   =>  pure_op,
                                                            args =>  [ren v],
                                                            name =>  x2,
                                                            type =>  t2,
                                                            next =>  g' e2
                                                          };
					    else
						skip ();
					    fi;

					case pure
					    #
					    fcf::p::STRETCH (n2, m)
						=>
						check_clicked("X (1)", n2, fcf::p::STRETCH (p, m));

					    fcf::p::COPY (n2, m)
						=> 
						if (n2 == m)   check_clicked("X (2)", n2, fcf::p::STRETCH (p, m));
						else	       skip ();
						fi;

					    fcf::p::CHOP (n2, m)
						=> 
						m >= p   ??   check_clicked("X (3)", n2, fcf::p::STRETCH (p, m))
							 ::   check_clicked("X (4)", n2, fcf::p::CHOP    (p, m));

					    _ => skip();
					esac;
				    };

				fcf::PURE { op   =>  fcf::p::STRETCH_TO_INTEGER p,
                                            args =>  [v, f],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::PURE { op   =>  fcf::p::CHOP_INTEGER m,
                                                                      args =>  [v2, f2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    {   fun check_clicked (tok, pure_op)
					    =
					    if (cvt_pre_condition_inf (x, v2))
						#
						click tok;
						use_less f; use_less f2;
						fcf::PURE { op => pure_op,                      args => [ren v],        name => x2, type => t2, next => g' e2 };
					    else
						fcf::PURE { op => fcf::p::STRETCH_TO_INTEGER p, args => [ren v, ren f], name => x,  type => t,  next => g' e  };
					    fi;

					m >= p   ??   check_clicked("X (3')", fcf::p::STRETCH (p, m))
						 ::   check_clicked("X (4')", fcf::p::CHOP  (p, m));
				    };

				fcf::PURE { op   =>  fcf::p::STRETCH (p, n),
                                            args =>  [v],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::MATH { op   =>  a,
                                                                      args =>  [v2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    {   v' = [ren v];

					fun skip ()
					    =
					    fcf::PURE { op   =>  fcf::p::STRETCH (p, n),
                                                        args =>  v',
                                                        name =>  x,
                                                        type =>  t,
                                                        next =>  g' e
                                                      };

					fun check_clicked (tok, n2, m, arith_op)
					    =
					    if (cvt_pre_condition (n, n2, x, v2))
						#
						if (m >= p)   click tok;   fcf::PURE { op => fcf::p::STRETCH (p, m), args => v', name => x2, type => t2, next => g' e2 };
						else			   fcf::MATH { op => arith_op        (p, m), args => v', name => x2, type => t2, next => g' e2 };
						fi;
					    else
						skip();
					    fi;

					case a
					    #
					    fcf::p::SHRINK_INT (n2, m) =>  check_clicked("X (5)", n2, m, fcf::p::SHRINK_INT);
					    fcf::p::SHRINK_UNT (n2, m) =>  check_clicked("X (6)", n2, m, fcf::p::SHRINK_UNT);
					    _                          =>  skip();
					esac;
				    };


				fcf::PURE { op   =>  fcf::p::STRETCH_TO_INTEGER p,
                                            args =>  [v, f],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::MATH { op   =>  fcf::p::SHRINK_INTEGER m,
                                                                      args =>  [v2, f2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    if (cvt_pre_condition_inf (x, v2))
					#
					if (m >= p)
					    #
					    click "X9";
					    use_less f;
					    use_less f2;
					    fcf::PURE { op => fcf::p::STRETCH    (p, m), args => [ren v], name => x2, type => t2, next => g' e2 };
					else
					    fcf::MATH { op => fcf::p::SHRINK_INT (p, m), args => [ren v], name => x2, type => t2, next => g' e2 };
					fi;
				    else
					fcf::PURE { op => fcf::p::STRETCH_TO_INTEGER p, args => [ren v, ren f], name => x, type => t, next => g' e };
				    fi;


				fcf::PURE { op   =>  fcf::p::COPY (p, n),
                                            args =>  [v],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::PURE { op   =>  fcf::p::COPY_TO_INTEGER n2,
                                                                      args =>  [v2, f2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    if (cvt_pre_condition (n, n2, x, v2))
					#
					click "C (2)";
					fcf::PURE { op => fcf::p::COPY_TO_INTEGER p, args => [ren v, ren f2], name => x2, type => t2, next => g' e2 };
				    else
					fcf::PURE { op => fcf::p::COPY (p, n),       args => [ren v],         name => x,  type => t,  next => g' e };
				    fi;


				fcf::PURE { op   =>  fcf::p::COPY (p, n),
                                            args =>  [v],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::PURE { op   =>  fcf::p::STRETCH_TO_INTEGER n2,
                                                                      args =>  [v2, f2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    {   fun skip ()
					    =
					    fcf::PURE { op   =>  fcf::p::COPY (p, n),
                                                        args =>  [ren v],
                                                        name =>  x,
                                                        type =>  t,
                                                        next =>  g' e
                                                      };

					fun check_clicked (tok, pure_op)
					    =
					    if (cvt_pre_condition (n, n2, x, v2))
						#    
						click tok;
						fcf::PURE { op   =>  pure_op,
                                                            args =>  [ren v, ren f2],
                                                            name =>  x2,
                                                            type =>  t2,
                                                            next =>  g' e2
                                                          };
					    else
						skip ();
					    fi;

					if (n > p)
					    #    
					    check_clicked("C (2')", fcf::p::COPY_TO_INTEGER p);
					else
					    if (n == p)   check_clicked("C (2')", fcf::p::STRETCH_TO_INTEGER p);
					     else         skip ();
					     fi;
					fi;
				    };

				fcf::PURE { op   =>  fcf::p::COPY (p, n),
                                            args =>  [v],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::PURE { op   =>  pure,
                                                                      args =>  [v2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    {   v' = [ren v];

					fun skip ()
					    =
					    fcf::PURE { op   =>  fcf::p::COPY (p, n),
                                                        args =>  v',
                                                        name =>  x,
                                                        type =>  t,
                                                        next =>  g' e
                                                      };

					fun check_clicked (tok, n2, pure_op)
					    = 
					    if (cvt_pre_condition (n, n2, x, v2))
						#  
						click tok;
						fcf::PURE { op   =>  pure_op,
                                                            args =>  v',
                                                            name =>  x2,
                                                            type =>  t2,
                                                            next =>  g' e2
                                                          };
					    else
						skip();
					    fi;

					case pure
					    #
					    fcf::p::COPY (n2, m)
						=>
						check_clicked("C (1)", n2, fcf::p::COPY (p, m));

					    fcf::p::STRETCH (n2, m)
						=> 
						if   (n >  p)   check_clicked("C (2)", n2, fcf::p::COPY (p, m));
						elif (n == p)   check_clicked("C (2)", n2, fcf::p::STRETCH (p, m));
						else            skip();
						fi;

					    fcf::p::CHOP (n2, m)
						=> 
						if   (m >= p)   check_clicked("C (3)", n2, fcf::p::COPY (p, m));
						elif (m <  p)   check_clicked("C (4)", n2, fcf::p::CHOP (p, m));
						else            skip();
						fi;

					    _ => skip();
					esac;
				    };


				fcf::PURE { op   =>  fcf::p::COPY_TO_INTEGER p,
                                            args =>  [v, f],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::PURE { op   =>  fcf::p::CHOP_INTEGER m,
                                                                      args =>  [v2, f2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    {   fun skip ()
					    =
					    fcf::PURE { op   =>  fcf::p::COPY_TO_INTEGER p,
                                                        args =>  [ren v, ren f],
                                                        name =>  x,
                                                        type =>  t,
                                                        next =>  g' e
                                                      };

					fun check_clicked (tok, pure_op)
					    =
					    if (cvt_pre_condition_inf (x, v2) )
						#
						click tok;

						use_less f;
                                                use_less f2;

						fcf::PURE { op   =>  pure_op,
                                                            args =>  [ren v],
                                                            name =>  x2,
                                                            type =>  t2,
                                                            next =>  g' e2
                                                          };
					    else
						skip ();
					    fi;

					if   (m >= p)   check_clicked ("C (3)", fcf::p::COPY (p, m));
					elif (m <  p)   check_clicked ("C (4)", fcf::p::CHOP (p, m));
					else            skip ();
					fi;
				    };

				fcf::PURE { op   =>  fcf::p::COPY (p, n),
                                            args =>  [v],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::MATH { op   =>  a,
                                                                      args =>  [v2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    {
					v' = [ren v];

					fun skip ()
					    =
					    fcf::PURE { op   =>  fcf::p::COPY (p, n),
                                                        args =>  v',
                                                        name =>  x,
                                                        type =>  t,
                                                        next =>  g' e
                                                      };

					fun check_clicked (tok, n2, ilk, arith_op)
					    = 
					    if (cvt_pre_condition (n, n2, x, v2) )
						click tok; ilk { op => arith_op, args => v', name => x2, type => t2, next => g' e2 };
					    else
						skip();
					    fi;

					case a
					    fcf::p::SHRINK_INT (n2, m)
						=>
						m >= p   ??   check_clicked("C5", n2, fcf::PURE,  fcf::p::COPY       (p, m))
							 ::   check_clicked("C6", n2, fcf::MATH,  fcf::p::SHRINK_INT (p, m));

					    fcf::p::SHRINK_UNT (n2, m)
						=> 
						m > p   ??   check_clicked("C7", n2, fcf::PURE,   fcf::p::COPY       (p, m))
							::   check_clicked("C8", n2, fcf::MATH,   fcf::p::SHRINK_UNT (p, m));

					   _ => skip();
					esac;
				    };

				fcf::PURE { op   =>  fcf::p::COPY_TO_INTEGER p,
                                            args =>  [v, f],
                                            name =>  x,
                                            type =>  t,
                                            next =>  e as fcf::MATH { op   =>  fcf::p::SHRINK_INTEGER m,
                                                                      args =>  [v2, f2],
                                                                      name =>  x2,
                                                                      type =>  t2,
                                                                      next =>  e2
                                                                    }
                                          }
				    =>
				    {

					fun check_clicked (tok, ilk, op)
					    =
					    if (cvt_pre_condition_inf (x, v2) )
						#
						click tok;
						#
						use_less f;
						use_less f2;
						#
						ilk { op,
                                                      args =>  [ren v],
                                                      name =>  x2,
                                                      type =>  t2,
                                                      next =>  g' e2
                                                    };
					    else
						fcf::PURE { op   =>  fcf::p::COPY_TO_INTEGER p,
                                                            args =>  [ren v, ren f],
                                                            name =>  x,
                                                            type =>  t,
                                                            next =>  g' e
                                                          };
					    fi;

					m >= p   ??   check_clicked ("C5", fcf::PURE, fcf::p::COPY       (p, m))
						 ::   check_clicked ("C6", fcf::MATH, fcf::p::SHRINK_INT (p, m));
				    };

				fcf::PURE { op, args, name, type, next }
				    =>
				    {   args =  map  ren  args;

					(get name) ->   { used, ... };

					if (*used==0 and *cg::deadvars)
					    #
					    click "m";
					    apply  use_less  args;
					    g' next;
					else 
					    if (*cg::arithopt)
					        #
						newname (name, pure (op, args));
						g' next;
					    else
                                                raise exception CONSTANT_FOLD;
					    fi
					    except
						CONSTANT_FOLD
						    =
						    {   next =  g' next;

							if (*used==0 and deadup)
							    #
							    apply use_less args;
							    click "*";
							    next;
							else
							    fcf::PURE { op, args, name, type, next };
							fi;
						    };
					 fi;
				    };

				fcf::RAW_C_CALL { kind, cfun_name, cfun_type,  args,                  results,  next            }
			     => fcf::RAW_C_CALL { kind, cfun_name, cfun_type,  args => map ren args,  results,  next => g' next };		# Leave raw C calls alone.


				fcf::IF_THEN_ELSE { op,  args,  xvar, then_next, else_next }
				    =>
				    {   args =  map  ren  args;

					# Maximum number of speculatively
					# executed conditional moves:
					#
					max_condmove_hoist = 3;

					# This function creates conditional moves
					# from  statements of the form:
					#
					#    fcf::IF_THEN_ELSE { op, args, xvar, then_next => fcf::TAIL_CALL { func, args=>[x1] },
                                        #                                        else_next => fcf::TAIL_CALL { func, args=>[x2] }
					#                      }
					#
					fun conditional_move ()
					    = 
					    {   # Hoist conditional moves up from branches 
						# This will make them run speculatively.
						# We limit this number to max_condmove_hoist so
						# that we don't speculatively execute everything.
						#
						fun hoist (e, 0)
							=>
							(fn k = k, e);

						    hoist (fcf::PURE { op as fcf::p::CONDMOVE _, args, name, type, next }, n)
							=> 
							{   (hoist (next, n - 1)) ->   (k, next);
							    #
							    fun new_k  next
								=
								fcf::PURE { op, args, name, type, next => k next };

							    (new_k, next);
							}; 

						    hoist (e, _)
							=>
							(fn k = k, e);
						end;

						my (k1, then_next) = hoist (g' then_next, max_condmove_hoist);
						my (k2, else_next) = hoist (g' else_next, max_condmove_hoist);

						fun default ()                      #  The default does nothing 
						    =
						    fcf::IF_THEN_ELSE { op, args, xvar, then_next => k1 then_next,
                                                                                        else_next => k2 else_next };

						# Determine the type of
						# conditional move:
						# 
						fun find_type (f, x, y)
						    = 
						    {   fun get_type (x, again)
							    =
							    case x
								#
								fcf::STRING  _ =>  THE fcf::bogus_pointer_type;
								fcf::LABEL   _ =>  THE fcf::bogus_pointer_type;
								fcf::FLOAT64 _ =>  THE fcf::type::FLOAT64;
								fcf::INT32   _ =>  THE fcf::type::INT32;
								fcf::INT     _ =>  THE fcf::bogus_pointer_type;
								#
								_              =>  again ();
							    esac;

							fun find_type ()
							    =
							    get_type (x, fn _ = get_type (y, fn _ = NULL));

							case (.info (get f))
							    #
							    FNINFO { args => [f_arg], ... }
								=>
								case ((get f_arg).info)
								    #
								    MISCINFO t =>  THE t;		# Found type.
								    _          =>  find_type ();
								esac; 

							     _ => find_type();
							esac; 
						    }; 

					      case (op, then_next, else_next)
						  #                                                  
						  ((fcf::p::STREQ | fcf::p::STRNEQ), _, _)
						      =>
						      default();                    #  String compares are complex, so we punt on them 

						  ( _,
                                                    fcf::TAIL_CALL { func => fcf::VAR f,  args => [x] },
                                                    fcf::TAIL_CALL { func => fcf::VAR f', args => [y] }
						  )
						      =>
						      if (f == f')
							  #
							  case (find_type (f, x, y))   
							      #
							      THE t
								  =>
								  {   r = hcv::make_highcode_variable ();
								      say "COND MOVE\n";
								      k1 (
									  k2 (
									      fcf::PURE
                                                                                { op =>    fcf::p::CONDMOVE op,
                                                                                  args =>  args @ [x, y],
                                                                                  name =>  r,
                                                                                  type =>  t,
                                                                                  next =>  fcf::TAIL_CALL { func =>  fcf::VAR f,
													    args => [fcf::VAR r]
												          }
                                                                                 }
                                                                             )
                                                                         );
								  };

							      _ =>
								  {   say "COND MOVE failed\n";
								      default();
								  };
							  esac;

						      else

							  default();
						      fi;

						  _ => default();
					      esac; 
					    };

					fun no_conditional_move ()
					    =
					    fcf::IF_THEN_ELSE { op, args, xvar, then_next => g' then_next, else_next => g' else_next };

					fun h ()
					    =
					    (   if (*cg::branchfold and equal_upto_alpha (then_next, else_next))
						    #
						    click "z";
						    apply  use_less  args;
						    newname (xvar, fcf::INT 0);
						    drop_body else_next;
						    g' then_next;
						    #
						elif (*cg::comparefold)
						    #
						    if (branch (op, args))
							#
							newname (xvar, fcf::INT 0); 
							apply  use_less  args;
							drop_body else_next; 
							g' then_next;
						    else
							newname (xvar, fcf::INT 0); 
							apply  use_less  args;
							drop_body then_next; 
							g' else_next;
						    fi;
						else
						    raise exception CONSTANT_FOLD;
						fi
					    )
					    except
						CONSTANT_FOLD =  no_conditional_move ();

					fun get_if_idiom f
					    =
					    {   f' = ren f;

						case f'
						    #
						    fcf::VAR v
							=>
							case (get v)
							    #
							    { info=>IF_IDIOM_INFO { body }, ... } =>  THE body;
							    _                                     =>  NULL;
							esac;

						    _ => NULL;
						esac;
					    };

					case (then_next, else_next)
					    #
					    ( fcf::TAIL_CALL { func => fcf::VAR f,  args => [fcf::INT 1] },
                                              fcf::TAIL_CALL { func => fcf::VAR f', args => [fcf::INT 0] }
                                            )
						=>
						case (f==f', get_if_idiom (fcf::VAR f))
						    #
						    (TRUE, THE (body as REF (THE (c', a, b))))
							=>							  #  Handle IF IDIOM.
							{   newname (c', fcf::VAR xvar);
							    body := NULL;
							    g' (fcf::IF_THEN_ELSE { op, args, xvar, then_next => a, else_next => b });			  #  NOTE: could use vl' here instead of vl. 
							};

						    _ => h();
						esac;

					     _ => h();
					esac;
				    };
			end;					# fun handler
                end 

		also
		branch
		    =
		    fn  (fcf::p::UNBOXED, vl           ) =>  not (branch (fcf::p::BOXED, vl));
			(fcf::p::BOXED, [fcf::INT _]   ) =>  { click "n"; FALSE;};
			(fcf::p::BOXED, [fcf::STRING s]) =>  { click "o"; TRUE;};

			(fcf::p::BOXED, [fcf::VAR v])
			    => 
			    case (get v)
				#
				{ info=>RECINFO _, ... } =>  { click "p";  TRUE; };
				_                        =>  raise exception CONSTANT_FOLD;
			    esac;

			(fcf::p::CMP { op=>fcf::p::LT, kindbits }, [fcf::VAR v, fcf::VAR w])
			    => 
			    if (v == w)
				#  
				click "v";
				FALSE;
			    else
				raise exception CONSTANT_FOLD;
			    fi;

			(fcf::p::CMP { op=>fcf::p::LT, kindbits=>fcf::p::INT 31 }, [fcf::INT i, fcf::INT j])
			    =>
			    {   click "w";
				i < j;
			    };

			(fcf::p::CMP { op=>fcf::p::GT, kindbits }, [w, v])
			    =>
			    branch (fcf::p::CMP { op=>fcf::p::LT, kindbits },[v, w]);

			(fcf::p::CMP { op=>fcf::p::LE, kindbits }, [w, v])
			    =>
			    branch (fcf::p::CMP { op=>fcf::p::GE, kindbits },[v, w]);

			(fcf::p::CMP { op=>fcf::p::GE, kindbits }, vl)
			    =>
			    not (branch (fcf::p::CMP { op=>fcf::p::LT, kindbits }, vl));

			(fcf::p::CMP { op=>fcf::p::LT, kindbits=>fcf::p::UNT 31 }, [fcf::INT i, fcf::INT j])
			    => 
			    {   click "w";

				if (j < 0 )
				    i >= 0 or  i < j;
				else
				    i >= 0 and i < j;
				fi;
			    }; 

			(fcf::p::CMP { op=>fcf::p::EQL, kindbits }, [fcf::VAR v, fcf::VAR w])
			    => 
			    case kindbits
				#
				fcf::p::FLOAT _ =>   raise exception CONSTANT_FOLD;			# In case of NaN's.
				_          =>   if (v==w )  click "v";   TRUE;
						else        raise exception CONSTANT_FOLD;
						fi;
			    esac;

			(fcf::p::CMP { op=>fcf::p::EQL, ... }, [fcf::INT i, fcf::INT j])
			    =>
			    {   click "w";
				i == j;
			    };

			(fcf::p::CMP { op=>fcf::p::NEQ, kindbits }, vl)
			    => 
			    not (branch (fcf::p::CMP { op=>fcf::p::EQL, kindbits }, vl));

			(fcf::p::PEQL, [fcf::INT i, fcf::INT j])
			    =>
			    {   click "w";
				i == j;
			    };

			(fcf::p::PNEQ, [v, w])
			    =>
			    not (branch (fcf::p::PEQL,[w, v]));

			_   =>
			    raise exception CONSTANT_FOLD;
                  end 

		  also
                  arith
                      =
		      fn (fcf::p::MATH { op=>fcf::p::MULTIPLY, ... }, [fcf::INT 1, v]) =>  { click "F"; v;};
			 (fcf::p::MATH { op=>fcf::p::MULTIPLY, ... }, [v, fcf::INT 1]) =>  { click "G"; v;};
			 (fcf::p::MATH { op=>fcf::p::MULTIPLY, ... }, [fcf::INT 0, _]) =>  { click "H"; fcf::INT 0;};
			 (fcf::p::MATH { op=>fcf::p::MULTIPLY, ... }, [_, fcf::INT 0]) =>  { click "I"; fcf::INT 0;};

			 (fcf::p::MATH { op=>fcf::p::MULTIPLY, kindbits=>fcf::p::INT 31 }, [fcf::INT i, fcf::INT j])
                             =>
			     {   x = i*j;
                                 x+x+2;		# XXX BUGGO FIXME What is this supposed to do?  Should it be 'x = x+2;' ? Is this an overflow test? Notice these are pervasive in this section so typo is not likely.
                                 click "J";
                                 fcf::INT x;
                             };

			 (fcf::p::MATH { op=>fcf::p::DIVIDE, ... }, [v, fcf::INT 1]) => { click "K"; v;};
			 (fcf::p::MATH { op=>fcf::p::DIVIDE, ... }, [fcf::INT i, fcf::INT 0]) => raise exception CONSTANT_FOLD;

			 (fcf::p::MATH { op=>fcf::p::DIVIDE, kindbits=>fcf::p::INT 31 }, [fcf::INT i, fcf::INT j])
                             =>
				   { x = int::quot (i, j);  x+x; click "L"; fcf::INT x; };

			 (fcf::p::MATH { op=>fcf::p::DIV, ... }, [v, fcf::INT 1]) => { click "K"; v;};
			 (fcf::p::MATH { op=>fcf::p::DIV, ... }, [fcf::INT i, fcf::INT 0]) => raise exception CONSTANT_FOLD;

			 (fcf::p::MATH { op=>fcf::p::DIV, kindbits=>fcf::p::INT 31 }, [fcf::INT i, fcf::INT j])
                             =>
				   { x = int::(/) (i, j);  x+x; click "L"; fcf::INT x; };

			 # XXX BUGGO FIXME: should we do anything for mod or rem here? 

			 (fcf::p::MATH { op=>fcf::p::ADD, ... }, [fcf::INT 0, v]) => { click "M"; v;};
			 (fcf::p::MATH { op=>fcf::p::ADD, ... }, [v, fcf::INT 0]) => { click "N"; v;};

			 (fcf::p::MATH { op=>fcf::p::ADD, kindbits=>fcf::p::INT 31 }, [fcf::INT i, fcf::INT j])
                             =>
				  { x = i+j;  x+x+2; click "O"; fcf::INT x; };

			 (fcf::p::MATH { op=>fcf::p::SUBTRACT, ... }, [v, fcf::INT 0]) => { click "P"; v;};

			 (fcf::p::MATH { op=>fcf::p::SUBTRACT, kindbits=>fcf::p::INT 31 }, [fcf::INT i, fcf::INT j]) =>
				  { x = i-j;  x+x+2; click "Q"; fcf::INT x; };

			 (fcf::p::MATH { op=>fcf::p::NEGATE, kindbits=>fcf::p::INT 31, ... }, [fcf::INT i]) =>
				     { x = -i;  x+x+2; click "X"; fcf::INT x; };
			 _ => raise exception CONSTANT_FOLD;
                      end 

		  also
                  pure
                      =
		      fn (fcf::p::PURE_ARITH { op=>fcf::p::RSHIFT, kindbits=>fcf::p::INT 31 }, [fcf::INT i, fcf::INT j])
                             =>
			     {   click "R";
                                 fcf::INT (wtoi (unt::(>>>)(itow i, itow j)));
                             };

		         (fcf::p::PURE_ARITH { op=>fcf::p::RSHIFT, kindbits=>fcf::p::INT 31 }, [fcf::INT 0, _])
                             =>
			     {   click "S"; fcf::INT 0;};

			 (fcf::p::PURE_ARITH { op=>fcf::p::RSHIFT, kindbits=>fcf::p::INT 31 }, [v, fcf::INT 0])
                             =>
			     {   click "T"; v;};

			 (fcf::p::LENGTH, [fcf::STRING s])
                             =>
                             {   click "V"; fcf::INT (size s);};

		   #     (fcf::p::ORDOF, [STRING s, fcf::INT i])
                   #         =>
                   #	     {   click "W"; fcf::INT (ordof (s, i))};

			 (fcf::p::PURE_ARITH { op=>fcf::p::LSHIFT, kindbits=>fcf::p::INT 31 }, [fcf::INT i, fcf::INT j])
                             =>
			     ( { x = wtoi (unt::(<<) (itow i, itow j));
			         x+x;
                                 click "Y";
                                 fcf::INT x;
			       }
                               except
                                   OVERFLOW = raise exception CONSTANT_FOLD
                             );

			 (fcf::p::PURE_ARITH { op=>fcf::p::LSHIFT, kindbits=>fcf::p::INT 31 }, [fcf::INT 0, _])
                             =>
			     { click "Z"; fcf::INT 0;};

			 (fcf::p::PURE_ARITH { op=>fcf::p::LSHIFT, kindbits=>fcf::p::INT 31 }, [v, fcf::INT 0])
                             =>
			     { click "1"; v;};

			 (fcf::p::PURE_ARITH { op=>fcf::p::BITWISE_OR, kindbits=>fcf::p::INT 31 }, [fcf::INT i, fcf::INT j])
                             =>
			     { click "2"; fcf::INT (wtoi (unt::bitwise_or (itow i, itow j)));};

			 (fcf::p::PURE_ARITH { op=>fcf::p::BITWISE_OR, kindbits=>fcf::p::INT 31 }, [fcf::INT 0, v])
                             =>
                             { click "3"; v;};

			 (fcf::p::PURE_ARITH { op=>fcf::p::BITWISE_OR, kindbits=>fcf::p::INT 31 }, [v, fcf::INT 0])
                             =>
                             { click "4"; v;};

			 (fcf::p::PURE_ARITH { op=>fcf::p::BITWISE_XOR, kindbits=>fcf::p::INT 31 }, [fcf::INT i, fcf::INT j])
                             =>
			     { click "5"; fcf::INT (wtoi (unt::bitwise_xor (itow i, itow j)));};

			 (fcf::p::PURE_ARITH { op=>fcf::p::BITWISE_XOR, kindbits=>fcf::p::INT 31 }, [fcf::INT 0, v])
                             =>
			     { click "6"; v;};

			 (fcf::p::PURE_ARITH { op=>fcf::p::BITWISE_XOR, kindbits=>fcf::p::INT 31 }, [v, fcf::INT 0])
                             =>
                             { click "7"; v;};

			 (fcf::p::PURE_ARITH { op=>fcf::p::BITWISE_NOT, kindbits=>fcf::p::INT 31 }, [fcf::INT i])
                             =>
			     { click "8"; fcf::INT (wtoi (unt::bitwise_not (itow i)));};

			 (fcf::p::PURE_ARITH { op=>fcf::p::BITWISE_AND, kindbits=>fcf::p::INT 31 }, [fcf::INT i, fcf::INT j])
                             =>
			     { click "9"; fcf::INT (wtoi (unt::bitwise_and (itow i, itow j)));};

			 (fcf::p::PURE_ARITH { op=>fcf::p::BITWISE_AND, kindbits=>fcf::p::INT 31 }, [fcf::INT 0, _])
                             =>
			     { click "0"; fcf::INT 0;};

			 (fcf::p::PURE_ARITH { op=>fcf::p::BITWISE_AND, kindbits=>fcf::p::INT 31 }, [_, fcf::INT 0])
                             =>
			     { click "T"; fcf::INT 0;};

			 (fcf::p::CONVERT_FLOAT { from=>fcf::p::INT 31, to=>fcf::p::FLOAT 64 }, [fcf::INT i])
                             =>
			     (fcf::FLOAT64 (int::to_string i + ".0"));					# Isn't this cool? 

			 (fcf::p::FUNWRAP,[x as fcf::VAR v])
                             => 
			     case (get v)
                                 #
				 { info=>WRPINFO (fcf::p::FWRAP, u), ... }
				     =>
				     {   click "U"; 
                                         use_less x;
                                         u;
                                     };

				 _   =>   raise exception CONSTANT_FOLD;
                             esac;

			 (fcf::p::FWRAP,[x as fcf::VAR v])
                             =>
			     case (get v)
                               
                                  { info=>WRPINFO (fcf::p::FUNWRAP, u), ... }
                                      =>
				      { click "U"; use_less x; u;};

				  _   =>
                                      raise exception CONSTANT_FOLD;
                             esac;

			 (fcf::p::IUNWRAP,[x as fcf::VAR v])
                             =>
			     case (get v)
                                 #
				 { info=>WRPINFO (fcf::p::IWRAP, u), ... }
				     =>
				     { click "U"; use_less x; u;};

				 _   =>   raise exception CONSTANT_FOLD;
                             esac;

			 (fcf::p::IWRAP,[x as fcf::VAR v])
                             =>
			     case (get (v))
                                 #
				 { info=>WRPINFO (fcf::p::IUNWRAP, u), ... }
				     =>
				     { click "U"; use_less x; u;};

				 _   =>   raise exception CONSTANT_FOLD;
                             esac;

			 (fcf::p::I32UNWRAP,[x as fcf::VAR v])
                             =>
			     case (get v)
                                 #
				 { info=>WRPINFO (fcf::p::I32WRAP, u), ... }
				     =>
				     { click "U"; use_less x; u;};

				 _   =>   raise exception CONSTANT_FOLD;
                             esac;

			 (fcf::p::I32WRAP, [x as fcf::VAR v])
			      =>
			      case (get v)
                                  #
				  { info => WRPINFO (fcf::p::I32UNWRAP, u), ... }
				     =>
				     { click "U"; use_less x; u;};

				  _ => raise exception CONSTANT_FOLD;
			      esac;

			 _    =>
                              raise exception CONSTANT_FOLD;
                  end;

		  debugprint "Contract: ";
		  debugflush ();
		  enter_misc0 fvar;
		  apply enter_misc0 fargs;
		  pass1 cexp;
		  nextcode_size := iht::vals_count m;

		  cexp' = reduce cexp;
		  debugprint "\n";

		  if   (debug)
		      
		       debugprint "After contract: \n"; 
		       prettyprint_nextcode::print_nextcode_expression cexp';
		  fi;
	    end;
    };					# generic package contract_g 
end;					# stipulate









##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Copyright 1996 by Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
