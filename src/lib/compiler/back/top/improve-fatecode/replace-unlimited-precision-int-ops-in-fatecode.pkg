## replace-unlimited-precision-int-ops-in-fatecode.pkg

# Compiled by:
#     src/lib/compiler/core.sublib



# Expand out any remaining occurrences
# of test_inf, trunc_inf, extend_inf,
# and copy_inf.
#
# These primops carry a second argument
# which is a function that performs the
# operation for 32 bit precision.




###                                "John von Neumann was the only
###                                 student I was ever afraid of."
###
###                                              -- George Pólya,


stipulate
    package fcf =  fatecode_form;			# fatecode_form		is from   src/lib/compiler/back/top/fatecode/fatecode-form.pkg
    package hv  =  highcode_var;			# highcode_var		is from   src/lib/compiler/back/top/highcode/highcode-var.pkg
herein

    package replace_unlimited_precision_int_ops_in_fatecode
    : (weak)
    api {

	replace_unlimited_precision_int_ops_in_fatecode
	    :
	    { function:   fcf::Function,
	      mk_kvar:    Void -> hv::Variable,	# Make new fate var. 
	      mk_i32var:  Void -> hv::Variable		# Make new int32 var. 
	    }
	    ->
	    fcf::Function;

    }

    {

	fun replace_unlimited_precision_int_ops_in_fatecode
	      {
		function,
		mk_kvar,
		mk_i32var
	      }
	    =
	    do_function function
	    where
		fun do_function (fk, f, vl, tl, e)
		    =
		    (fk, f, vl, tl, cexp e)

		also
		fun cexp (fcf::DEFINE_RECORD { kind, fields, name,  fate              })
		      =>  fcf::DEFINE_RECORD { kind, fields, name,  fate => cexp fate };
		    #
		    cexp (fcf::GET_FIELD_I   { i, record, name, type, fate              })
		      =>  fcf::GET_FIELD_I   { i, record, name, type, fate => cexp fate };
		    #
		    cexp (fcf::GET_ADDRESS_OF_FIELD_I { i, record, name,       fate              })
                      =>  fcf::GET_ADDRESS_OF_FIELD_I { i, record, name,       fate => cexp fate };

		    cexp (fcf::TAIL_CALL funargs)		=>   fcf::TAIL_CALL  funargs;
		    cexp (fcf::DEFINE_FUNS { funs, fate })	=>   fcf::DEFINE_FUNS {  funs => map do_function funs,  fate => cexp fate  };

		    cexp (fcf::JUMPTABLE { i, xvar, fates })	=>   fcf::JUMPTABLE { i, xvar, fates => map cexp fates };
		    #
		    cexp (fcf::IF_THEN_ELSE { op, args, xvar, thenfate, elsefate })
			=>
			fcf::IF_THEN_ELSE   { op, args, xvar, thenfate => cexp thenfate,
                                                              elsefate => cexp elsefate
                                            };

		    cexp (fcf::STORE_TO_RAM   { op, args,             fate }) =>   fcf::STORE_TO_RAM   { op, args,             fate => cexp fate };
		    cexp (fcf::FETCH_FROM_RAM { op, args, name, type, fate }) =>   fcf::FETCH_FROM_RAM { op, args, name, type, fate => cexp fate };

		    cexp (fcf::PURE { op   =>  fcf::p::COPY_TO_INTEGER 32,
                                      args =>  [x, func],
                                      name,
                                      type,
                                      fate
                                    }
                         )
			=>
			{   k = mk_kvar ();
			    #
			    fate = cexp fate;

			    fcf::DEFINE_FUNS  { funs =>  [(fcf::FATE, k, [name], [type], fate)],
						#
						fate =>  fcf::TAIL_CALL {  func,
                                                                       args =>  [fcf::VAR k, x, fcf::INT 0]
                                                                    }
                              		      };
			};

		    cexp (fcf::PURE { op   =>  fcf::p::STRETCH_TO_INTEGER 32,
                                      args =>  [x, func],
                                      name,
                                      type,
                                      fate
                                    }
                         )
			=>
			{   k = mk_kvar ();

			    fate = cexp fate;

			    fcf::DEFINE_FUNS  { funs =>  [(fcf::FATE, k, [name], [type], fate)],
						#
						fate =>  fcf::TAIL_CALL {  func,  args => [fcf::VAR k, x, fcf::INT 1] }
                              		      };
			};

		    cexp (   fcf::MATH { op => fcf::p::SHRINK_INTEGER 32, args => [x, func], name, type, fate }
			 |   fcf::PURE { op => fcf::p::CHOP_INTEGER   32, args => [x, func], name, type, fate }
			 )
			=>
			{   k = mk_kvar ();

			    fate = cexp fate;

			    fcf::DEFINE_FUNS  { funs =>  [(fcf::FATE, k, [name], [type], fate)],
						fate =>  fcf::TAIL_CALL { func, args => [fcf::VAR k, x] }
			      		      };
			};

		    cexp (fcf::MATH { op   =>  fcf::p::SHRINK_INTEGER i,
                                      args =>  [x, func],
                                      name,
                                      type,
                                      fate
                                    }
                         )
			=>
			{   k  =  mk_kvar ();
			    v' =  mk_i32var ();

			    fate =  cexp fate;

			    fcf::DEFINE_FUNS
			      {
				funs =>
				    [ ( fcf::FATE,
					k,
					[v'],
					[fcf::type::INT32],
					fcf::MATH
					  { op => fcf::p::SHRINK_INT (32, i),
					    args => [fcf::VAR v'],
					    name,
					    type,
					    fate
					  }
				      )
				    ],

				fate =>  fcf::TAIL_CALL { func, args => [fcf::VAR k, x] }
			      };
			};

		    cexp (fcf::MATH { op, args, name, type, fate              })
		      =>  fcf::MATH { op, args, name, type, fate => cexp fate };


		    cexp (fcf::PURE { op   =>  fcf::p::CHOP_INTEGER i,
                                      args =>  [x, func],
                                      name,
                                      type,
                                      fate
                                    }
                         )
			=>
			{   k    =  mk_kvar ();
			    v'   =  mk_i32var ();
			    fate =  cexp fate;

			    fcf::DEFINE_FUNS
			      {
				funs =>
				    [ ( fcf::FATE,
					k,
					[v'],
					[fcf::type::INT32],
					fcf::PURE
					  { op   =>  fcf::p::CHOP (32, i),
					    args => [fcf::VAR v'],
					    name,
					    type,
					    fate
					   }
				      )
				    ],
				#
				fate =>  fcf::TAIL_CALL {   func,   args => [fcf::VAR k, x]   }
			      };
			};

		    cexp (fcf::PURE { op   =>  fcf::p::COPY_TO_INTEGER i,
                                      args =>  [x, func],
                                      name,
                                      type,
                                      fate
                                    }
                         )
			=>
			{   k    =  mk_kvar ();
			    v'   =  mk_i32var ();
			    fate =  cexp fate;

			    fcf::DEFINE_FUNS
			      {
				funs =>  [ (fcf::FATE, k, [name], [type], fate) ],
				#
				fate =>
				    fcf::PURE
				      { op => fcf::p::COPY (i, 32),
					args => [x],
					name => v',
					type => fcf::type::INT32,
					fate => fcf::TAIL_CALL {   func,   args => [fcf::VAR k, fcf::VAR v', fcf::INT 0]  }
				      }
			      };
			};

		    cexp (fcf::PURE { op   =>  fcf::p::STRETCH_TO_INTEGER i,
                                      args =>  [x, func],
                                      name,
                                      type,
                                      fate
                                    }
                         )
			=>
			{   k    =  mk_kvar ();
			    v'   =  mk_i32var ();
			    fate =  cexp fate;

			    fcf::DEFINE_FUNS
                              {
				funs =>  [(fcf::FATE, k, [name], [type], fate)],
				#
				fate =>
				    fcf::PURE
				      { op => fcf::p::STRETCH (i, 32),
					args => [x],
					name => v',
					type => fcf::type::INT32,
					fate => fcf::TAIL_CALL { func,
                                                             args => [fcf::VAR k, fcf::VAR v', fcf::INT 1]
                                                           }
				      }
                              };
			};

		    cexp (fcf::PURE { op, args, name, type, fate              })
		      =>  fcf::PURE { op, args, name, type, fate => cexp fate };

		    cexp (fcf::RAW_C_CALL { kind, cfun_name, cfun_type, args, results,  fate               })
		      =>  fcf::RAW_C_CALL { kind, cfun_name, cfun_type, args, results,  fate => cexp fate  };
		end;
	    end;
    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################

## (C) 2003 The SML/NJ fellowship.
## Author: Matthias Blume (blume@tti-c.org)
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
