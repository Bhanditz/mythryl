## make-machcode-controlflow-graph-g.pkg
#
# This appears to be the live facility described in the
#     "Directly from instructions"
# section of
#     http://www.cs.nyu.edu/leunga/MLRISC/Doc/html/mlrisc-ir.html 

# Compiled by:
#     src/lib/compiler/back/low/lib/lowhalf.lib



# We are invoked from:
#
#     src/lib/compiler/back/low/main/main/backend-lowhalf-g.pkg

stipulate
    package iht =  int_hashtable;				# int_hashtable			is from   src/lib/src/int-hashtable.pkg
    package lbl =  codelabel;					# codelabel				is from   src/lib/compiler/back/low/code/codelabel.pkg
    package lcn =  lowhalf_notes;				# lowhalf_notes				is from   src/lib/compiler/back/low/code/lowhalf-notes.pkg
    package lem =  lowhalf_error_message;			# lowhalf_error_message			is from   src/lib/compiler/back/low/control/lowhalf-error-message.pkg
    package odg =  oop_digraph;					# oop_digraph				is from   src/lib/graph/oop-digraph.pkg
    package pb  =  pseudo_op_basis_type;			# pseudo_op_basis_type			is from   src/lib/compiler/back/low/mcg/pseudo-op-basis-type.pkg
    package ptf =  sfprintf;					# sfprintf				is from   src/lib/src/sfprintf.pkg
herein

    # This generic is invoked (only) in:
    #
    #     src/lib/compiler/back/low/main/main/backend-lowhalf-g.pkg
    #
    generic package   make_machcode_controlflow_graph_g   ( 
	#             ================================
	#
	package mu:  Machcode_Universals;			# Machcode_Universals			is from   src/lib/compiler/back/low/code/machcode-universals.api

	package cst: Codestream;				# Codestream				is from   src/lib/compiler/back/low/code/codestream.api

	package mcg: Machcode_Controlflow_Graph			# Machcode_Controlflow_Graph		is from   src/lib/compiler/back/low/mcg/machcode-controlflow-graph.api
		     where
			  mcf == mu::mcf			# "mcf" == "machcode_form" (abstract machine code).
		     also pop == cst::pop;			# "pop" == "pseudo_op".
    )
    : (weak) Make_Machcode_Controlflow_Graph			# Make_Machcode_Controlflow_Graph	is from   src/lib/compiler/back/low/mcg/make-machcode-controlflow-graph.api
    {
	# Exported for client packages:
	#
	package mcg =  mcg;					# "mcg" == "machcode_controlflow_graph".
	package pop =  mcg::pop;				# "pop" == "pseudo_op".
	package mcf =  mu::mcf;					# "mcf" == "machcode_form" (abstract machine code).
	package cst =  cst;					# "cst" == "codestream".

	stipulate
#	    package pso =  pseudo_op;
#	    package ins =  machcode;
	    package mu  =  mu;					# "mu"  == "machcode_universals".
	herein

	    exception LABEL_NOT_FOUND;

	    Codestream
		= 
		cst::Codestream
		  (
		    mcf::Machine_Op,
		    note::Notes,
		    mcg::mcf::rgk::Codetemplists,
		    mcg::Machcode_Controlflow_Graph
		  );

	    dump_initial_machcode_controlflow_graph
		= 
		lowhalf_control::make_bool 
		  ("dump_initial_machcode_controlflow_graph",
		   "Dump machcode_controlflow_graph after instruction selection");

	    #
	    fun error msg
		=
		lem::error ("BuildFlowGraph", msg);

	    hash_label
		=
		unt::to_int o lbl::codelabel_to_hashcode;
	    #
	    fun make_machcode_controlflow_graph ()
		=
		{
		    (REF (mcg::make_machcode_controlflow_graph ()))
			->
			mcg as REF (odg::DIGRAPH graph);


		    block_list   =  REF ([]: List( mcg::Bblock    ));				# List of blocks generated so far.
		    entry_labels =  REF ([]: List( lbl::Codelabel ));				# List of entry labels to patch successors of ENTRY.


		    # Block id associated with a label:
		    #
		    label_map    = iht::make_hashtable  { size_hint => 32,  not_found_exception => LABEL_NOT_FOUND };
		    find_label   = iht::find label_map;
		    add_label    = iht::set label_map;

		    # Data in text segment is read-only:
		    #
		    Segment_T = TEXT | DATA | RO_DATA | BSS | DECLS;
		    segment_f    = REF DECLS;

		    block_names   = REF [] : Ref( note::Notes );				# The block names.

		    reorder      = REF [] : Ref( note::Notes );					# Can instructions be reordered?

		    no_block = mcg::make_bblock { id => -1, execution_frequency => REF 0.0 };	# noblock or invalid block has id of -1

		    currentablock = REF no_block;						# Current block being built up.


		    # Add a new badic block; also make it the
		    # current block being built up:
		    #
		    fun make_bblock  freq
			=
			{   (*mcg) ->   odg::DIGRAPH  graph;

			    id = graph.allot_node_id ();

			    (mcg::make_bblock { id, execution_frequency => REF freq })
				->	
			        blk as mcg::BBLOCK { notes, ... };

			    currentablock :=   blk;
			    notes         :=  *block_names @ *reorder;
			    block_list    :=   blk ! *block_list;

			    graph.add_node (id, blk);

			    blk;
			};


		    # Get current basic block:
		    #
		    fun getablock ()
			= 
			case *currentablock
			    #
			    mcg::BBLOCK { id=> -1, ... } =>  make_bblock  1.0;
			    other                        =>  other;
			esac;


		    #  ------------------------cluster---------------------------
		    # Start a new cluster:
		    #
		    fun begin_connected_component _
			= 
			{   block_list    :=  [];
			    entry_labels  :=  [];
			    block_names   :=  [];
			    currentablock :=  no_block;

			    iht::clear label_map;
			};

		    # Emit an instruction:
		    #	
		    fun emit_op op
		    =
		    {   (getablock ()) ->   mcg::BBLOCK { ops, ... };
			#
			fun terminate ()
			    =
			    currentablock := no_block;

			ops := op ! *ops;

			case (mu::instruction_kind  op)
			    #
			    mu::k::JUMP           =>  terminate ();
			    mu::k::CALL_WITH_CUTS =>  terminate ();
			    _                     =>  ();
			esac;
		    };

		    # Make current block an exit block:
		    #
		    fun emit__end_of_fn__mark  liveout
			=
			{   fun set_live_out (mcg::BBLOCK { notes, ... } )
				= 
				notes :=   mcg::liveout.x_to_note  liveout
                                           !
                                           *notes;

			    case *currentablock
				#
				mcg::BBLOCK { id=> -1, ... }
				    =>
				    case *block_list
					#
					[]      =>  error "emit__end_of_fn__marks";
					#
					blk ! _ =>  set_live_out blk;
				    esac;

				blk =>  set_live_out blk;
			    esac;
			};


		    # End cluster --- all done:
		    #
		    fun end_connected_component  given_notes
			=
			mcg
			where
			    my mcg as odg::DIGRAPH graph
				=
				(*mcg
				 before
				     mcg := mcg::make_machcode_controlflow_graph ()
				);

			    mcg::add_start_node_and_stop_node_to_graph  mcg;		#  Create unique ENTRY/EXIT nodes.

			    entry = head (graph.entries ());
			    exit  = head (graph.exits   ());
			    #
			    fun add_edge (from, to, kind)
				=
				graph.add_edge
				  ( from,
				    to,
				    mcg::EDGE_INFO
				      { kind,
					execution_frequency =>  REF 0.0,
					notes		    =>  REF []
				      }
				  );
			    #	
			    fun add_edge_an (from, to, kind, an)
				=
				graph.add_edge
				  ( from,
				    to,
				    mcg::EDGE_INFO
				      { kind,
					execution_frequency =>  REF 0.0,
					notes  		    =>  REF an
				      }
				  );
			    #
			    fun target lab
				=
				case (iht::find label_map (hash_label lab))
				    #
				    THE b_id =>   b_id; 
				    NULL     =>   exit;
				esac;

			    my { get=>get_prob, ... }
				=
				lcn::branch_probability;
			    #
			    fun jump (from, instruction, blocks)
				=
				{   fun branch (target_lab)
					=
					{   my (_, an)
						=
						mu::get_notes
						    instruction;

					    an =    list::filter
							fn  (lcn::BRANCH_PROBABILITY _) => TRUE;
							    _                                     => FALSE;
							end
							an;
					    #
					    fun next (mcg::BBLOCK { id, ... } ! _) =>  id;
						next []                            =>  error "jump::next";
					    end;

					    add_edge_an (from, target target_lab, mcg::BRANCH TRUE, an);
					    add_edge (from, next blocks, mcg::BRANCH FALSE);
					};

				    case (mu::branch_targets instruction)
				        #
					[mu::ESCAPES                      ] =>  add_edge (from, exit, mcg::EXIT);
					[mu::LABELLED lab                 ] =>  add_edge (from, target lab, mcg::JUMP);
					#
					[mu::LABELLED lab, mu::FALLTHROUGH] =>  branch lab;
					[mu::FALLTHROUGH, mu::LABELLED lab] =>  branch lab;

					targets
					    =>
					    {   list::fold_left  switch  0  targets;
						();
					    }
					    where
						fun switch (mu::LABELLED lab, n)
							=> 
							{   add_edge (from, target lab, mcg::SWITCH (n));
							    n+1;
							};

						    switch _
							=>
							error "jump::switch";
						end;
					   end;
				    esac;
				}

			    also
			    fun falls_thru (id, blks)
				= 
				case blks
				    #
				    []  =>   add_edge (id, exit, mcg::EXIT);

				    mcg::BBLOCK { id=>next, ... } ! _
					=>
					add_edge (id, next, mcg::FALLSTHRU);
				 esac

			    also
			    fun add_edges [] => ();
				add_edges (mcg::BBLOCK { id, ops=>REF [], ... } ! blocks) => falls_thru (id, blocks);
				add_edges (mcg::BBLOCK { id, ops=>REF (instruction ! _), ... } ! blocks)
				    =>
				    {   fun do_jmp ()
					    =
					   jump (id, instruction, blocks);

					case (mu::instruction_kind instruction)
					    #
					    mu::k::JUMP           =>  do_jmp ();
					    mu::k::CALL_WITH_CUTS =>  do_jmp ();
					    _ => falls_thru (id, blocks);
					esac;

					add_edges (blocks);
				    };
			    end;

			    add_edges (reverse *block_list);

			    apply
				(fn lab =  add_edge (entry, target lab, mcg::ENTRY))
				*entry_labels;

			    global_graph_notes  =  mcg::get_global_graph_notes mcg;
			    global_graph_notes :=  given_notes @ *global_graph_notes;

			    if *dump_initial_machcode_controlflow_graph
				#
				mcg::dump
				  (
				    *lowhalf_control::debug_stream,
				    "after instruction selection",
				    mcg
				  );
			    fi;
			end;			# where (fun end_connected_component)


		    #  ------------------------annotations-----------------------
		    # XXX: Bug: EMPTYBLOCK does not really generate an empty block 
		    #	but merely terminates the current block. Contradicts the comment
		    #  in code/lowhalf-notes.api.
		    #  It should be (newBlock (1.0); newBlock (1.0); ())
		    #

		    # Add a new annotation:
		    #
		    fun emit_bblock_note note
			= 
			case note
			    #
			    lcn::BLOCKNAMES  names
				=>
				{   block_names := names;
				    make_bblock 1.0;
				    ();
				};

			    lcn::EMPTYBLOCK
				=>
				{   make_bblock 1.0;
				    ();
				};

			    lcn::EXECUTION_FREQUENCY f
				=> 
				case *currentablock
				    #
				    mcg::BBLOCK { id=> -1, ... }
					=>
					{   make_bblock (real f);
					    ();
					};

				    mcg::BBLOCK { execution_frequency, ... }
					=>
					execution_frequency := real f;
				esac;

			    note =>
				{   (getablock ()) ->   mcg::BBLOCK { notes, ... };
				    #
				    notes := note ! *notes;
				};
			esac;


		    # Get notes associated with machcode controlflow graph: 
		    #	
		    fun get_notes ()
			=
			mcg::get_global_graph_notes  *mcg;


		    # Add a comment annotation
		    # to the current basic block:
		    #
		    fun emit_comment  msg
			= 
			case *segment_f 
			    #
			    TEXT => emit_bblock_note (lcn::comment.x_to_note msg);

			    _ =>    {   (*mcg) ->   odg::DIGRAPH graph;
				        #
				        graph.graph_info ->   mcg::GRAPH_INFO { dataseg_pseudo_ops, ... };
				        #
				        dataseg_pseudo_ops :=  pb::COMMENT msg ! *dataseg_pseudo_ops;
				    };
			esac;


		    #  -------------------------labels---------------------------
		    # BUG: Does not respect any ordering between labels and pseudo_ops. 
		    # This could be a problem with jump tables. 		XXX BUGGO FIXME
		    #	
		    fun emit_pseudo_op  p
			=
			{
			    (*mcg)           ->  odg::DIGRAPH graph;
			    graph.graph_info ->  mcg::GRAPH_INFO { dataseg_pseudo_ops, decls, ... };
			    #
			    fun add_alignment ()
				= 
				case *segment_f
				    #
				    DECLS => error "addAlignment: DECLS";

				    TEXT =>
					{   (make_bblock 1.0) ->   mcg::BBLOCK { alignment_pseudo_op, ... };
					    alignment_pseudo_op := THE p;
					};

				    _  =>   dataseg_pseudo_ops  :=  p ! *dataseg_pseudo_ops;
				esac;

			    #
			    fun start_segment seg
				=
				{   dataseg_pseudo_ops :=   p   !   *dataseg_pseudo_ops;
				    #
				    segment_f := seg;
				};

			    #
			    fun add_data ()
				=
				dataseg_pseudo_ops :=    p   !   *dataseg_pseudo_ops;

			    #
			    fun check_add_data  seg
				=
				{   fun errmsg curr
					=
					ptf::sprintf' "addPseudoOp: %s in %s segment" [ptf::STRING seg, ptf::STRING curr];

				    case *segment_f
					#
					DECLS =>  error (errmsg "DECLS");
					TEXT  =>  error (errmsg "TEXT");
					#
					_     =>  dataseg_pseudo_ops :=   p   !   *dataseg_pseudo_ops;
				    esac;
				 };
			    #
			    fun add_decl ()
				=
				case *segment_f
				    #
				    DECLS =>  decls := p  !  *decls;
				    _     =>  dataseg_pseudo_ops :=   p   !   *dataseg_pseudo_ops;
				esac;

			    case p
				#
				pb::ALIGN_SIZE _ =>  add_alignment ();
				pb::ALIGN_ENTRY  =>  add_alignment ();
				pb::ALIGN_LABEL  =>  add_alignment ();

				pb::DATA_LABEL _
				    =>
				    case *segment_f
					#
					TEXT =>  error "add_pseudo_op: DATA_LABEL in TEXT segment";
					#
					_    =>  dataseg_pseudo_ops :=   p   !   *dataseg_pseudo_ops;
				    esac;


				pb::DATA_READ_ONLY =>  start_segment  RO_DATA;
				pb::DATA           =>  start_segment  DATA;

				pb::TEXT => segment_f := TEXT;
				pb::BSS  => start_segment (BSS);

				pb::SECTION _
				    => 
				    case *segment_f
					#
					TEXT =>  error "add_pseudo_op: SECTION in TEXT segment";
					#
					_    =>  dataseg_pseudo_ops  :=   p   !   *dataseg_pseudo_ops;
				    esac;

				pb::REORDER
				    =>
				    {   reorder := [];
					make_bblock 1.0;
					();
				    };

				pb::NOREORDER
				    => 
				    {   reorder := [ lcn::noreorder.x_to_note () ];
					make_bblock 1.0;
					();
				    };

				pb::INT     _ =>  check_add_data  "INT";
				pb::FLOAT   _ =>  check_add_data  "FLOAT";
				pb::ASCII   _ =>  check_add_data  "ASCII";
				pb::ASCIIZ  _ =>  check_add_data  "ASCIIZ";
				pb::SPACE   _ =>  check_add_data  "SPACE";

				pb::COMMENT _ =>  add_decl ();
				pb::IMPORT  _ =>  add_decl ();
				pb::EXPORT  _ =>  add_decl ();

				pb::EXT _
				    => 
				    case *segment_f
					#
					TEXT =>  error "EXT in TEXT segment";
					_    =>  add_decl ();
				    esac;
			   esac;
			};
		    #
		    fun emit_private_label lab
			= 
			case *segment_f 
			    #
			    TEXT => 
				case (find_label (hash_label lab))
				    #
				    NULL =>
					{   fun make_bblock' ()
						= 
						case *currentablock
						    #
						    mcg::BBLOCK { id  => -1,     ... } =>  make_bblock 1.0;
						    mcg::BBLOCK { ops => REF [], ... } => *currentablock;		# Probably aligned block.
						    _ => make_bblock 1.0;
						esac;

					    (make_bblock' ()) ->   mcg::BBLOCK { id, labels, ... };

					    labels :=  lab  !  *labels;

					    add_label (hash_label lab, id);
					};

				    THE _ =>   error (cat ["multiple definitions of label \"", lbl::codelabel_to_string lab, "\""]);
				esac;

			    _   =>
				{   # Non-text segment:
				    # 
				    (*mcg)           ->   odg::DIGRAPH graph;
				    graph.graph_info ->   mcg::GRAPH_INFO { dataseg_pseudo_ops, ... };

				    dataseg_pseudo_ops :=   pb::DATA_LABEL lab   !   *dataseg_pseudo_ops;
				};
			esac;

		    #
		    fun emit_public_label lab
			=
			{   emit_private_label  lab;
			    #
			    entry_labels :=  lab  !  *entry_labels;
			};

		    
		    { emit_comment,
		      get_notes,
		      emit_bblock_note,
		      emit_private_label,
		      emit_public_label,
		      emit_pseudo_op,
		      begin_connected_component,
		      emit_op,
		      emit__end_of_fn__mark,
		      end_connected_component
		    };
		};											# fun make_machcode_controlflow_graph
	end;												# stipulate
    };													# generic package make_machcode_controlflow_graph_g
end;													# stipulate





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## COPYRIGHT (c) 2001 Bell Labs, Lucent Technologies
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
