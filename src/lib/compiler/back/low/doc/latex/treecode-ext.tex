\section{Treecode Extensions} \label{sec:treecode-extension}
	Pattern matching over the Treecode intermediate representation
may not be sufficient to provide access to all the registers or
operations provided on a specific architecture. Treecode extensions is a 
method of extending the Treecode intermediate language so that it is a
better match for the target architecture.


\subsection{Why Extensions}

	Pattern matching over the Treecode intermediate representation
may not be sufficient to provide access to all the registers or
operations provided on a specific architecture. Treecode extensions is a 
method of extending the Treecode intermediate language so that it is a
better match for the target architecture.

For example there may be special registers to support the
increment-and-test operation on loop indices, or 
support for complex mathematical functions such as
square root, or access to hardware specific registers such as the
current register window pointer on the SPARC32 architecture. It is not
usually possible to write expression trees that would directly
generate these instructions.
Some complex operations can be generated by performing a peephole
optimization over simpler instructions, however this is not always the 
most convenient or simple thing to do.

\subsection{Cyclic Dependency}

The easiest way to provide extensions is to parameterize the Treecode
interface with types that extend the various kinds of trees. Thus if
the type \sml{sext} represented statement extensions, we might define
Treecode statement trees as :
\begin{SML}
  enum statement
    = ...
    | SEXT of sext * lowhalf list * statement list

  and lowhalf = GPR of int_expression | FPR of float_expression | CCR of bool_expression
\end{SML}
where the constructor \sml{SEXT} applies the extension to a list of
arguments. This approach is unsatisfactory in several ways, for
example, if one wanted to extend TREECODEs with for-loops, then the
following could be generated:
\begin{SML}
  SEXT(FORLOOP, [GPR from, GPR to, GPR step], body)
\end{SML}	
First, the loop arguments have to be wrapped up in \sml{GPR} and there
is little self documentation on the order of elements that are
arguments to the for-loop. It would be better to be able to write
something like:
\begin{SML}
  SEXT(FORLOOP\{from=f, to=t, step=s, body=b\}) 
\end{SML}

Where \sml{f}, \sml{t}, and \sml{s} are \sml{int_expression} trees representing
the loop index start, end, and step size;  \sml{b} is a statement list
representing the body of the loop. Unfortunately, there is a cyclic
dependency as TREECODEs are defined in terms of \sml{sext}, and {\tt
sext} is defined in terms of TREECODEs. The usual way to break
cyclic dependencies is to use type variables. 

\subsection{Treecode EXTENSION}

The statement extension type \sml{sext}, is now a type constructor
with arity four, i.e. 
\sml{('s, 'r, 'f, 'c) sx} where \sml{sx} is used instead of {\tt
sext}, and \sml{'s}, \sml{'r}, \sml{'f}, and \sml{'c} represents
Treecode statement expressions, register expressions, floating point
expressions, and condition code expressions. Thus the for-loop
extension could be declared using something like:
\begin{SML}
  enum sx ('s,'r,'f,'c) 
    = FORLOOP of \{from: 'r, to: 'r, step: 'r, body: 's\}
\end{SML}
and the Treecode interface is defined as:
\begin{SML}
  api Treecode = sig
    type ('s, 'r, 'f, 'c) sx

    enum statement =
      = ...
      | SEXT of sext

   withtype sext = (statement, int_expression, float_expression, cexp) sx
  end
\end{SML}

where \sml{sext} is the user defined statement extension but the
type variables have been instantiated to the final form the the Treecode 
\sml{statement}, \sml{int_expression}, \sml{float_expression}, and \sml{cexp} components. 

\subsection{Compilation}

There are dedicated modules that perform pattern matching over TREECODEs 
and emit native instructions, and similar modules must be written for
extensions.  However, the same kinds of choices used in regular Treecode 
patterns must be repeated for extensions. For example, one may define
an extension for the Intel INTEL32 of the form:

\begin{SML}
  enum sx ('s,'r,'f,'c) = PUSHL of 'r | POPL of 'r | ...
\end{SML}

that translate directly to the Intel push and pop instructions; the
operands in each case are either memory locations or registers, but
immediates are allowed in the case of \sml{PUSHL}. Considerable effort 
has been invested into pattern matching the extensive set of
addressing modes for the Intel architecture, and
one would like to reuse this when compiling extensions. The pattern
matching functions are exposed by a set of functions exported from the 
instruction selection module, and provided in the Treecode
interface. They are: 

\begin{SML}
  struture I : Machcode
  enum reducer = 
    REDUCER of \{
      reduceRexp    : int_expression -> reg,
      reduceFexp    : float_expression -> reg,
      reduceCCexp   : bool_expression -> reg,
      reduceStm     : statement * an list -> Void,
      operand       : int_expression -> I.operand,
      reduceOperand : I.operand -> reg,
      addressOf     : int_expression -> I.addressing_mode,
      emit          : I.instruction * an list -> Void,
      codestream   : (I.instruction, I.regmap, I.registerset) stream,
      treecodeStream  : (statement, I.regmap, lowhalf list) stream
    \}
\end{SML}

where \sml{I} is the native instruction set. 
\begin{description}
\item[\tt reduceRexp]: reduces an Treecode \sml{int_expression} to a register, and
	similarly for \sml{reduceFexp} and \sml{reduceCCexp}.
\item[\tt reduceStm]: reduces an Treecode \sml{statement} to a set of instructions
	that implement the set of statements.
\item[\tt operand]: reduced an Treecode \sml{int_expression} into an instruction
operand --- usually an immediate or memory address.
\item[\tt operand]: moves a native operand into a register.
\item[\tt addressOf]: reduces an Treecode \sml{int_expression} into a memory address.
\item[\tt emit]: emits an instruction together with an annotation.
\item[\tt Codebuffer]: is the native instruction output stream, and
\item[\tt treecodeStream]: is the Treecode output stream.
\end{description}

Each extension must provide a function \sml{compileSext} that compiles
a statement extension into native instructions. In the
\sml{Treecode_Extension_Compiler} interface we have:
\begin{SML}
  my compileSext: reducer -> {statement: Treecode.sexp, notes:Treecode.an list} -> Void
\end{SML}

The use of extensions must follow a special package. 
\begin{enumerate}
 \item A module defining the extension type using a type constructor
of arity four. Let us call this package \sml{ExtTy} and must match
the \sml{Treecode_Extension} interface.
 \item The extension module must be used to specialize TREECODEs. 
 \item A module that describes how to compile the extension must be
created, and must match the \sml{Treecode_Extension_Compiler} interace.
This module will typically be genericized over the Treecode interface.
Let us call the result of applying the generic, \sml{ExtComp}.
 \item The extension compiler must be passed as a parameter to the
instruction selection module that will invoke it whenever an extension 
is seen.
\end{enumerate}


\subsection{Multiple Extensions}

Multiple extensions are handled in a similar fashion, except that the
extension type used to specialize TREECODEs is a tagged union of the
individual extensions. The generic to compile the extension dispatches 
to the compilation modules for the individual extensions.

\subsection{Example}
Suppose you are in the process of writing a compiler for a digital
signal processing(\newdef{DSP}) programming language using the LOWHALF
framework.  This wonderful language that you are developing allows the
programmer to specify high level looping and iteration, and
aggregation constructs that are common in DSP applications.
Furthermore, since saturated and fixed point arithmetic are common
constructs in DSP applications, the language and consequently the
compiler should directly support these operators.  For simplicity, we
would like to have a unified intermediate representation that can be
used to directly represent high level constructs in our language, and
low level constructs that are already present in Treecode.  Since,
Treecode does not directly support these constructs, it seems that it is
not possible to use LOWHALF for such a compiler infrastructure without
substantial rewrite of the core components.

Let us suppose that for illustration that we would like to
implement high level looping and aggregation constructs such as
\begin{verbatim}
   for i := lower bound ... upper bound
       body
   x := sum{i := lower bound ... upper bound} expression
\end{verbatim}
together with saturated arithmetic mentioned above.

Here is a first attempt:
\begin{SML}
package DSPTreecodeExtension
struct
   package Basis = treecode_pith
   enum sx ('s,'r,'f,'c) = 
      FOR of Basis.var * 'r * 'r * 's
   and ('s,'r,'f,'c) rx = 
      SUM of Basis.var * 'r * 'r * 'r
    | SADD of 'r * 'r
    | SSUB of 'r * 'r
    | SMUL of 'r * 'r
    | SDIV of 'r * 'r
   type ('s,'r,'f,'c) fx = Void
   type ('s,'r,'f,'c) ccx = Void
end
package DSPTreecode : treecode_transforms_g
    (package extension = DSPTreecodeExtension
     ...
    )
\end{SML}
In the above api, we have defined two new sumtypes \newtype{sx}
and \newtype{rx} that are used for representing the DSP statement
and integer expression extensions.  Integer expression extensions
include the high level sum construct, and the low level saturated
arithmetic operators.  The recursive type definition is
necessary to ``inject'' these new constructors into the basic Treecode 
definition.

The following is an example of how these new constructors that we have defined can be used.  Suppose the source program in our DSP language is:
\begin{verbatim}
   for i := a ... b
   {  s := sadd(s, table[i]);
   }
\end{verbatim}
\noindent where \verb|sadd| is the saturated add operator.
For simplicity, let us also assume that all operations and addresses
are in 32-bits.
Then the translation of the above into our extended DSP-Treecode could be:
\begin{SML}
   EXT(FOR(\(i\), REG(32, \(a\)), REG(32, \(b\)),
           MOVE_INT(32, \(s\), REXT(32, SADD(REG(32, \(s\)), 
                LOAD(32, 
                    ADD(32, REG(32, \(table\)), 
                        LEFT_SHIFT(32, REG(32, \(i\)), LITERAL 2)),
                         \(region\)))))
          ))
\end{SML}

One potential short coming of our DSP extension to Treecode is that
the extension does not allow any further extensions.  This restriction
may be entirely satisfactory if DSP-Treecode is only used in your compiler
applications and no where else.  However, if DSP-Treecode is intended
to be an extension library for LOWHALF, then  we must build in the flexibility
for extension.  This can be done in the same way as in the base Treecode
definition, like this: 
\begin{SML}
generic package ExtensibleDSPTreecodeExtension
  (Extension : \lowhalfhref{treecode/treecode-extension.api}{Treecode_Extension}) =
struct
   package Basis = treecode_pith
   package extension = Extension
   enum sx ('s,'r,'f,'c) = 
      FOR of Basis.var * 'r * 'r * 's
    | EXT of ('s,'r,'f,'c) Extension.sx 
   and ('s,'r,'f,'c) rx = 
      SUM of Basis.var * 'r * 'r * 'r
    | SADD of 'r * 'r
    | SSUB of 'r * 'r
    | SMUL of 'r * 'r
    | SDIV of 'r * 'r
    | REXT of ('s,'r,'f,'c) Extension.rx
   withtype
        ('s,'r,'f,'c) fx   = ('s,'r,'f,'c) Extension.fx
   and  ('s,'r,'f,'c) ccx  = ('s,'r,'f,'c) Extension.ccx
end
\end{SML}

As in Treecode, we provide two new extension 
constructors \verb|EXT| and \verb|REXT| in
the definition of \sml{DSP_TREECODE}, which  can 
be used to further enhance the extended Treecode language.
