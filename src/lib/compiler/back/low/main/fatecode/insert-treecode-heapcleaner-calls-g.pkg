# insert-treecode-heapcleaner-calls-g.pkg
#
# This module is responsible for generating code to
# invoke the  heapcleaner ("garbage collector").
#
# For general background see
#
#     src/A.GARBAGE-COLLECTOR.OVERVIEW
#
#
#
# Nomenclature:
#
#     A (heapcleaner) "root" is a live pointer into the heap.
#     which is to say, the root of a tree of live heap values
#     which the heapcleaner ("garbage collector") must NOT
#     recycle.  Much of our work in this package consists of
#     making sure that all roots get passed to the heapcleaner.
#
#
#
# We insert heaplimit checks at points determined by
#
#     src/lib/compiler/back/low/main/fatecode/pick-fatecode-funs-for-heaplimit-checks.pkg
#
# These checks work in conjunction with related code generated in
#
#     src/lib/compiler/back/low/main/main/translate-fatecode-to-treecode-g.pkg
#
# The basic idea here is to buy time and space efficiency
# by structuring the heapcleaner ("garbage collector")
# invocation logic as a three-level hierarchy:
# 
#     Level 1:
#         In every loop, we have a test like
#             if (heapcleaner_allocation_pointer > heapcleaner_allocation_limit)  longjump_to_heapcleaner_call();
#         In assembly code, that looks like
#             cmp heapcleaner_allocation_pointer, heapcleaner_allocation_limit
#             bgt longjump_to_heapcleaner_call					# "bgt" == "branch if greater-than"
#         We want the latter to be as small and fast as possible,
#         so on Intel32 these will typically be two-byte ops:
#         one byte of opcode and one byte of address.
#         On 32-bit RISCS they will have two bytes of address.
#         (On 32-bit RISCS with delay slots we try to further
#         optimize by putting the CMP instruction in a delay slot
#         and the BGT in the next block.)
#
#     Level 2:
#         Longjumps to the actual code to call the heapcleaner.
#         These will generally need to have a full 32-bit address.
#         One such longjump can be shared among multiple Level-1 branches.
# 
#     Level 3:
#         Codeblocks to actually call the heapcleaner.
#         
#	      The major problem to be solved by these blocks is that
#         at different points in the code we have live data in
#         different registers, and the types of data in those
#         registers also varies -- for example at one point
#         EAX may hold a 32-bit integer, but at another point it may
#         hold a pointer to a binary tree.  The garbage collector
#         needs to have all live pointers to keep it from recycling
#	  a value we're using when it runs.
#         
#         Thus, the main purpose of the heapcleaner-call blocks is to:
#         
#	    o Pack the live register contents into a standard
#             form intelligible to the heapcleaner. Unused
#             registers also need to be nulled out at this point.
#
#           o Call the heapcleaner.
#
#           o Unpack the original register contents back into
#             the registers, and resume execution.
#
#
#
#                -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
#                "This new version is derived from the generic CallGC.
#                 It can handle derived pointers as roots and it can also be used as 
#                 callbacks.  These extra facilities are neccessary for global
#                 optimizations  in the presence of heapcleaning."
# 
#                        -- Allen Leung

# Compiled by:
#     src/lib/compiler/core.sublib


###              "I hate flowers. I paint them because they're
###               cheaper than models and they don't move."
###
###                            -- Georgia O'Keeffe




###              "We believe in rough concensus and working code."
###
###                                    -- David Clark, IETF


# We are invoked from:
#
#     src/lib/compiler/back/low/main/main/backend-lowhalf-g.pkg

stipulate
    package ctl =  controls;					# controls				is from   src/lib/compiler/toplevel/main/controls.pkg
    package cos =  registerkinds_junk::cos;			# "cos" == "colorset".
    package err =  error_message;				# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    package fcf =  fatecode_form;				# fatecode_form				is from   src/lib/compiler/back/top/fatecode/fatecode-form.pkg
    package frr =  fatecode_ramregions;				# fatecode_ramregions			is from   src/lib/compiler/back/low/main/fatecode/fatecode-ramregions.pkg
    package lbl =  codelabel;					# codelabel				is from   src/lib/compiler/back/low/code/codelabel.pkg
    package lhn =  lowhalf_notes;				# lowhalf_notes				is from   src/lib/compiler/back/low/code/lowhalf-notes.pkg
    package lun =  large_unt;					# large_unt				is from   src/lib/std/large-unt.pkg
    package rkj =  registerkinds_junk;				# registerkinds_junk			is from   src/lib/compiler/back/low/code/registerkinds-junk.pkg
    package rwv =  rw_vector;					# rw_vector				is from   src/lib/std/src/rw-vector.pkg
    package sl  =  sorted_list;					# sorted_list				is from   src/lib/compiler/back/low/library/sorted-list.pkg
herein

    generic package  insert_treecode_heapcleaner_calls_g  (
	#            ===================================
        #
								# machine_properties_intel32		is from   src/lib/compiler/back/low/main/intel32/machine-properties-intel32.pkg
	package mp: Machine_Properties;				# Machine_Properties			is from   src/lib/compiler/back/low/main/main/machine-properties.api

								# platform_register_info_intel32	is from   src/lib/compiler/back/low/main/intel32/backend-lowhalf-intel32-g.pkg
	package pri: Platform_Register_Info			# Platform_Register_Info		is from   src/lib/compiler/back/low/main/fatecode/platform-register-info.api
		     where					# "tcf" == "treecode_form".
			 tcf::rgn == fatecode_ramregions;	# "rgn" == "region".

	package tcs: Treecode_Stream				# Treecode_Stream			is from   src/lib/compiler/back/low/treecode/treecode-stream.api
		     where
			 tcf == pri::tcf;			# "tcf" == "treecode_form".

	package mcg: Machcode_Controlflow_Graph			# Machcode_Controlflow_Graph		is from   src/lib/compiler/back/low/mcg/machcode-controlflow-graph.api
		     where
			 pop == tcs::cst::pop;			# "pop" == "pseudo_op".
    )
    : (weak) Insert_Treecode_Heapcleaner_Calls			# Insert_Treecode_Heapcleaner_Calls	is from   src/lib/compiler/back/low/main/fatecode/insert-treecode-heapcleaner-calls.api
    {
	# Export to client packages:
	#
	package tcs = tcs;					# "tcs" == "treecode_stream".
	package mcg = mcg;					# "mcg" == "machcode_controlflow_graph".

	stipulate
	    package tcf =  pri::tcf;				# "tcf" == "treecode_form".
	    package cd  =  mp::heap_tags;
	    package rgk =  pri::rgk;				# "rgk" == "registerkinds".
	herein

	    fun error msg
		=
		err::impossible("cleaner." + msg);

	    Fun_Info
	      =
	      { max_heapbytes_allocated_before_next_heaplimit_check:		Int,
		#
		live_registers:		List( tcf::Expression ),
		live_register_types:	List( fcf::Type ),
		#
		return:			tcf::Void_Expression
	      };

	    Stream = tcs::Treecode_Stream
		      (
			tcf::Void_Expression,
			List( tcf::Expression ),
			mcg::Machcode_Controlflow_Graph
		      ); 

	    debug_heapcleaner
		=
		ctl::lowhalf::make_bool ("debug_heapcleaner", "heapcleaner invocation debug mode");


												    # lowhalf_notes		is from   src/lib/compiler/back/low/code/lowhalf-notes.pkg
	    zero_freq_note	  =  lhn::execution_freq.x_to_note  0;
	    heapcleaner_call_note =  lhn::call_heapcleaner.x_to_note ();
	    no_optimization_note  =  lhn::no_optimization.x_to_note ();


	    # The following type is used to encapsulate
	    # all the information needed to generate code
	    # to invoke the heapcleaner.
	    #
	    # The important fields are:
	    #
	    #    all_callers_known:
	    #		      Do we known all callers of this function
	    #                 -- that is, is it an internal function? 
	    #
	    #    optimized:   If this is on, heapcleaner code generation is delayed
	    #                 until we have performed all optimizations.
	    #                 This is FALSE for normal Mythryl use.
	    #
	    #    heapcleaner_label:
	    #		      The codelabel on the call-heapcleaner block.
	    #
	    #    live_registers:   The heapcleaner "roots" -- actually, all live registers.
	    #
	    #    root_holding_registers, float_holding_registers, int_holding_registers:
	    #		      live_registers partitioned into three classes:
	    #                   o Registers containing integers.
	    #                   o Registers containing floats.
	    #                   o Registers containing heapcleaner roots -- pointers into the heap.
	    #
	    #    return:      How to return from the call-heapcleaner block.
	    #
	    Heapcleaner_Call
		=
	        HEAPCLEANER_CALL
		  {
		    all_callers_known:		Bool,					# Known function ? 
		    optimized:			Bool,					# Optimized? 
		    #
		    label_on_heapcleaner_call:	Ref( lbl::Codelabel ),			# The longjumps to this heapcleaner call jump to this codelabel.
		    #
		    live_registers:		List( tcf::Expression ),		# All live registers.
		    #
		    root_holding_registers:	List( tcf::Int_Expression ),		# Live registers holding boxed values.
		    int_holding_registers:	List( tcf::Int_Expression ),		# Live registers holding int32 values.			# 64-bit issue.
		    float_holding_registers:	List( tcf::Float_Expression ),		# Live registers holding float values.
		    #
		    return:			tcf::Void_Expression			# How to return.
		  };

	    Longjump_To_Heapcleaner_Call
		=
	        LONGJUMP_TO_HEAPCLEANER_CALL 
		  {
		    heapcleaner_call:		Heapcleaner_Call,				# It appears that in practice this must always be a HEAPCLEANER_CALL, never a LONGJUMP_TO_HEAPCLEANER_CALL. 
		    labels_on_longjump:		Ref(  List(  lbl::Codelabel ) )		# One codelabel for each branch that jumps to us.
		  };



	    ######################################################################
	    # Implementation/architecture specific stuff starts here.
	    ######################################################################

	    # Extra space in allocation space 
	    # The Mythryl runtime system leaves around 4K of extra space
	    # in the allocation space for safety.

	    skid_pad_size_in_bytes = 4096;	# This has(?) to match   max_heapwords_to_allocate_between_heaplimit_checks   in   src/lib/compiler/back/low/main/fatecode/pick-fatecode-funs-for-heaplimit-checks.pkg
						# This has(?) to match   4 * ONE_K_BINARY				      in   src/c/main/run-mythryl-code-and-runtime-eventloop.c

	    pty  = 32;				# Pointer width in bits. 					 64-BIT-ISSUE. XXX SUCKO FIXME.

	    vfp = FALSE;			# Don't use virtual frame ptr here.

	    void = tcf::LITERAL 1;		# Representation of Mythryl's Void; 				XXX SUCKO FIXME this should be a manifest constant of some sort.
						# this is used to initialize registers.

	    fun make_int_literal i
		=
		tcf::LITERAL (tcf::mi::from_int (32, i));							# 64-bit ISSUE. XXX SUCKO FIXME.



	    # Callee-save registers 
	    # All callee-save registers are used
	    # in the heapcleaner calling convention.
	    #
	    calleesaves												# On Intel32 this is [ ebx, ecx, edx ].
		=
		list::take_n (pri::miscregs, mp::num_callee_saves);


	    # Registers that are roots for the heapcleaner --
	    # which is to say, pointers to live items in the heap
	    # that the heapcleaner must not recycle as garbage:
	    #
	    root_registers
		= 
		(   pri::stdlink vfp								# vreg 0 on Intel32.
		!   pri::stdclos vfp								# vreg 1 on Intel32.
		!   pri::stdfate vfp								# esi    on Intel32.
		!   pri::stdarg  vfp								# ebp    on Intel32.
		!   calleesaves
		);


	    # Synthesize treecode form of a call to the heapcleaner:
	    #
	    # This involves a jump into the C/assembly runtime via a
	    # pointer maintained on the C stack, accessible via the
	    # framepointer register, which may be a real register,
	    # or a virtual register faked via creative use of the
	    # stackpointer register:
	    #
	    heapcleaner_call
		=
		{   uses =  map  tcf::INT_EXPRESSION  root_registers;

		    defs =  case pri::heap_is_exhausted__test
				#
				THE platform_specific__heap_is_exhausted__test =>  tcf::FLAG_EXPRESSION platform_specific__heap_is_exhausted__test  !  uses;
				NULL                                           =>                                                                      uses;
			    esac;

		    # Make treecode to call the heapcleaner.
		    #
		    # The pointer             mp::run_heapcleaner__offset              here
		    # corresponds to          run_heapcleaner_ptr                      in   src/c/machine-dependent/prim.intel32.asm
		    # which is set up by      asm_run_mythryl_task                     in   src/c/machine-dependent/prim.intel32.asm
		    # to REQUEST_CLEANING to  run_mythryl_task_and_runtime_eventloop   in   src/c/main/run-mythryl-code-and-runtime-eventloop.c
		    # which will call         clean_heap                               in   src/c/cleaner/call-cleaner.c
		    #
		    heapcleaner_call
			=
			tcf::CALL
			  {
			    funct   => tcf::LOAD  ( 32, 								# 64-bit issue, obviously.
						    tcf::ADD  ( pri::address_width,
								pri::frameptr vfp,
								make_int_literal  mp::run_heapcleaner__offset		# run_heapcleaner__offset is 32 on Intel32.
							      ),
						    frr::stack
						  ),
			    targets => [],
			    defs,
			    uses,
			    region  => frr::stack,
			    pops    => 0
			  };

		    # Mark it with a heapcleaner_call annotation:
		    #
		    heapcleaner_call =   tcf::NOTE (heapcleaner_call, heapcleaner_call_note);
		    heapcleaner_call =   tcf::NOTE (heapcleaner_call, lhn::comment.x_to_note "call heapcleaner");
		    heapcleaner_call;
		};


	    # Heapchunk tagwords:
	    #
	    fun make_unboxed_tagword  words =   lun::to_int (cd::make_tagword (words, cd::eight_byte_aligned_nonpointer_data_btag ));
	    fun   make_boxed_tagword  words =   lun::to_int (cd::make_tagword (words, cd::pairs_and_records_btag));


	    # The allocation pointer must
	    # always be in a register! 
	    #
	    heap_allocation_pointer_register
		= 
		case pri::heap_allocation_pointer
		    #
		    tcf::REG(_, heap_allocation_pointer_register) =>  heap_allocation_pointer_register; 
		    _                                             =>  error "heap_allocation_pointer must be a register";
		esac;

	    # Should we use signed- or unsigned-greater-than
	    # compares to check for heap exhaustion by doing
	    #
	    #     (heap_allocation_pointer > heap_allocation_limit)
	    #
	    # Either one may be faster, depending on target architecture:
	    #
	    heapcleaner_gt
		=
		pri::signed_gctest  ??  tcf::GT
				    ::  tcf::GTU;

	    unlikely          =   lhn::branch_probability.x_to_note   probability::unlikely;

	    # This is the straightforward way to test for
	    #
	    #     (heap_allocation_pointer > heap_allocation_limit)
	    #
	    normal__heap_is_exhausted__test								# The vanilla way to test for (heap_allocation_pointer > heap_allocation_limit);
		=											# this vanilla approach may be overridden on a per-platform basis via pri::heap_is_exhausted__test
		tcf::CMP
                  ( pty,
                    heapcleaner_gt,									# Signed or unsigned   >   test, depending on platform.
		    pri::heap_allocation_pointer,							# We allocate heap memory just by advancing this pointer.
                    pri::heap_allocation_limit vfp							# Heap is exhausted when heap_allocation_pointer reaches this point.
                  );


	    ######################################################################
	    # Private state										# All three of these are:  More icky thread-hostile mutable global state. XXX SUCKO FIXME
	    ######################################################################

	    cccomponent_heapcleaner_blocks	 =    REF  ([]:  List(Heapcleaner_Call));		# These will all be HEAPCLEANER_CALL, not LONGJUMP_TO_HEAPCLEANER_CALL.
	    all_callers_known_heapcleaner_blocks =    REF  ([]:  List(Heapcleaner_Call));		# These will all be HEAPCLEANER_CALL, not LONGJUMP_TO_HEAPCLEANER_CALL.
	    longjumps_to_heapcleaner_calls	 =    REF  ([]:  List(Longjump_To_Heapcleaner_Call));	# These must actually all be LONGJUMP_TO_HEAPCLEANER_CALL, not HEAPCLEANER_CALL.  



	    ######################################################################
	    # Auxiliary functions
	    ######################################################################

	    # Divide a list of live expressions into
	    # two lists, one containing the register expressions
	    # and one containing the memory expressions.
	    #
	    # Memory offsets must be relative
	    # to the frame pointer.
	    #
	    # We need this mainly(?) because Intel32 is so register-starved
	    # that we use memory words for some of our "registers":
	    #
	    fun split_expression_list_into_register_vs_ram_lists  namings
		=
		{   the_vfp =   pri::virtual_framepointer;

		    the_fp
			= 
			case (pri::frameptr FALSE)
			    #
			    tcf::REG (_, the_fp)
				=>
				the_fp;

			    _ => error "the_fp";
			esac;

		    # At this point, the_vfp will always eventually
		    # end up being the_fp, but lowhalf_gen might
		    # pass in references to the_vfp anyway (because
		    # of some RCC that happens to be in the ccomponent).
		    # Therefor, we test for either the real frame
		    # pointer (the_fp) or the virtual frame pointer
		    # (the_vfp) here.
		    #
		    fun is_frame_ptr fp
			=
			rkj::codetemps_are_same_color (fp, the_fp)    or
			rkj::codetemps_are_same_color (fp, the_vfp);


		    fun live (tcf::REG(_, r) ! es, regs, mem)
			    =>
			    live (es, r ! regs, mem);

			live (tcf::LOAD(_, tcf::REG(_, fp), _) ! es, regs, mem)
			    =>
			    if (is_frame_ptr fp)   live (es, regs, 0 ! mem);
			    else                   error "split_expression_list_into_register_vs_ram_lists: LOAD32";							# Possible 64-BIT_ISSUE
			    fi;

			live (tcf::LOAD(_, tcf::ADD(_, tcf::REG(_, fp), tcf::LITERAL i), _) ! es, regs, mem)
			    =>
			    if (is_frame_ptr fp)   live (es, regs, tcf::mi::to_int (32, i) ! mem);									# Possible 64-BIT_ISSUE
			    else                   error "split_expression_list_into_register_vs_ram_lists: LOAD32";							# Possible 64-BIT_ISSUE
			    fi;

			live([], regs, mem)
			    =>
			    (regs, mem);

			live _
			    =>
			    error "live";
		    end;

		    (live (namings, [], []))
			->
			(regs, mem);

		    { regs =>   rkj::sortuniq_colored_codetemps  regs,		# This sorts 'regs' by color (i.e., actual hardware register id) and drops any duplicated colors.
		      mem  =>   sl::uniq mem
		    };
		};

	    fun difference (   { regs=>r1, mem=>m1 },
			       { regs=>r2, mem=>m2 }
			   )
		=
		{ regs =>   cos::difference_of_colorsets (r1, r2),
		  mem  =>    sl::difference              (m1, m2)
		};

	    fun rootset_to_string { regs, mem }
		#
		= "{ "
		+   fold_right   (fn (r, s) =   rkj::register_to_string r + " " + s)   ""   regs
		+   fold_right   (fn (m, s) =   int::to_string          m + " " + s)   ""   mem
		+ "}";



	    # The client passes root pointers to the
	    # heapcleaner via the following set of
	    # registers and memory locations.
	    #
	    heapcleaner_root_set =   split_expression_list_into_register_vs_ram_lists  root_registers;

	    a_root_reg           =   tcf::REG (32, head heapcleaner_root_set.regs);		# 64-BIT ISSUE. XXX BUGGO FIXME.


	    # This function generates a heapcleaner heaplimit check.
	    # It returns the codelabel to which the test jumps,
	    # which needs to be placed on the heapcleaner-invocation
	    # basic block:
	    #
	    fun emit_heaplimit_check_and_branch (emit, max_heapbytes_allocated_before_next_heaplimit_check)
		=
		run_heapcleaner__codelabel
		where
		    run_heapcleaner__codelabel =   lbl::make_anonymous_codelabel ();

		    fun emit__run_heapcleaner_if						# Emit code which tests for heap-exhausted and runs the heapcleaner if it is.
			    #
			    heap_is_exhausted__test						# Some way of testing whether  (heap_allocation_pointer > heap_allocation_limit)
			=									#  -- see src/lib/compiler/back/low/main/fatecode/platform-register-info.api
			emit  (tcf::NOTE
				( tcf::IF_GOTO (heap_is_exhausted__test, run_heapcleaner__codelabel),
                                  unlikely
                                )
                              );

		    if (max_heapbytes_allocated_before_next_heaplimit_check < skid_pad_size_in_bytes)
			#
			case pri::heap_is_exhausted__test
			    #
			    THE platform_specific__heap_is_exhausted__test =>  emit__run_heapcleaner_if  platform_specific__heap_is_exhausted__test;		# Check result of heap-exhausted test preserved in status register.
			    NULL                                           =>  emit__run_heapcleaner_if             normal__heap_is_exhausted__test;		# Do full heap-exhausted test.
			esac;
			#
			# In the platform-specific case above
			# we are not actually doing the
			#
			#     (heap_allocation_pointer > heap_allocation_limit)
			#
			# comparison at this point, but rather just checking
			# preserved status-register bits generated by the
			# compare generated in
			#
			#     src/lib/compiler/back/low/main/main/translate-fatecode-to-treecode-g.pkg 

		    else  
			offset_heap_allocation_pointer
			    =
			    tcf::ADD  ( pri::address_width,
					pri::heap_allocation_pointer,
					make_int_literal (max_heapbytes_allocated_before_next_heaplimit_check - skid_pad_size_in_bytes)
				      );

			shifted_heaplimit_test =   tcf::CMP (pty, heapcleaner_gt, offset_heap_allocation_pointer, pri::heap_allocation_limit vfp);

			case pri::heap_is_exhausted__test
			    #
			    THE (platform_specific__heap_is_exhausted__test as tcf::CC(_, r))
				=> 
				{   emit (tcf::LOAD_INT_REGISTER_FROM_FLAGS_REGISTER (r, shifted_heaplimit_test));
				    #
				    emit__run_heapcleaner_if  platform_specific__heap_is_exhausted__test;
				};

			    NULL =>  emit__run_heapcleaner_if  shifted_heaplimit_test;

			    _ => error "emit_heaplimit_check_and_branch";
			esac;
		    fi;
		end;								# fun emit_heaplimit_check_and_branch


	    base_offset
		=
		tcf::LITERAL (integer::from_int  mp::const_base_reg_offset);


	    # Recompute the base pointer address:
	    #
	    fun emit_baseptr_update (emit, define_local_label, put_bblock_note)
		=
		{   return_label =   lbl::make_anonymous_codelabel ();

		    base_expression											# heapcleaner_link + (base_offset - return_label)
			= 
			tcf::ADD  ( pri::address_width,
				    pri::heapcleaner_link  vfp,
				    tcf::LABEL_EXPRESSION
				        (tcf::SUB
					  ( pri::address_width,
					    base_offset,
					    tcf::LABEL return_label
					  )
					)
				  );

		    define_local_label  return_label;

		    put_bblock_note  zero_freq_note; 

		    emit    case (pri::baseptr vfp)									# "The baseptr contains the start address of the entire compilation unit."
				#
				tcf::REG (type, bpt)      =>  tcf::LOAD_INT_REGISTER (type, bpt, base_expression);
				tcf::LOAD (type, ea, mem) =>  tcf::STORE_INT (type, ea, base_expression, mem);
				_                         =>  error "emit_baseptr_update";
			    esac;
		};


	    ######################################################################
	    # Main functions
	    ######################################################################

	    # This fun is called (only) from:
	    #
	    #     src/lib/compiler/back/low/main/main/backend-lowhalf-g.pkg
	    #
	    fun clear__cccomponent_heapcleaner_blocks__all_callers_known_heapcleaner_blocks__and__longjumps_to_heapcleaner_calls  ()
		=
		{   cccomponent_heapcleaner_blocks	    :=  [];
		    all_callers_known_heapcleaner_blocks    :=  [];
		    longjumps_to_heapcleaner_calls	    :=  [];
		};


	    # Split the root set into three lists by type:
	    #
	    #    o Boxed
	    #    o Int32
	    #    o Float
	    #
	    fun classify_live_registers_into_root_int_and_float ([], [], root_holding_registers, int_holding_registers, float_holding_registers)
		    => 
		    { root_holding_registers, int_holding_registers, float_holding_registers };

		classify_live_registers_into_root_int_and_float (  tcf::INT_EXPRESSION r ! rl, fcf::type::FLOAT64 ! tl, b, i, f) =>   error "classify_live_registers_into_root_int_and_float: tcf::INT_EXPRESSION";
		classify_live_registers_into_root_int_and_float (  tcf::INT_EXPRESSION r ! rl, fcf::type::INT32   ! tl, b, i, f) =>   classify_live_registers_into_root_int_and_float (rl, tl,     b, r ! i,     f);
		classify_live_registers_into_root_int_and_float (  tcf::INT_EXPRESSION r ! rl, _                  ! tl, b, i, f) =>   classify_live_registers_into_root_int_and_float (rl, tl, r ! b,     i,     f);
		classify_live_registers_into_root_int_and_float (tcf::FLOAT_EXPRESSION r ! rl, fcf::type::FLOAT64 ! tl, b, i, f) =>   classify_live_registers_into_root_int_and_float (rl, tl,     b,     i, r ! f);

		classify_live_registers_into_root_int_and_float _ => error "classify_live_registers_into_root_int_and_float";
	    end;

	    stipulate
		fun make_and_save_heaplimit_check_for__ccomponent_ref
			{
			  ccomponent_ref,					# This will be either   cccomponent_heapcleaner_blocks   or   all_callers_known_heapcleaner_blocks.
			  all_callers_known,
			  optimized
			}
			( { emit_op, ... }: Stream)
			{ max_heapbytes_allocated_before_next_heaplimit_check, live_registers, live_register_types, return }
		    =
		    {   # Partition the live registers into:
			#
			#    o Those that hold roots (pointers into the heap) -- we'll pass these to the heapcleaner.
			#    o Those that hold integer values.
			#    o Those that hold float   values.
			#
			(classify_live_registers_into_root_int_and_float (live_registers, live_register_types, [], [], []))
			    ->
			    { root_holding_registers, int_holding_registers, float_holding_registers };


			# Generate a heaplimit check and push it on 'component_ref':
			#
			ccomponent_ref
			    := 
			    HEAPCLEANER_CALL
			      {
				all_callers_known,
				optimized,
				label_on_heapcleaner_call =>  REF (emit_heaplimit_check_and_branch (emit_op, max_heapbytes_allocated_before_next_heaplimit_check)),
				root_holding_registers,
				int_holding_registers,
				float_holding_registers,
				live_registers,
				return
			    }
			    !
			    *ccomponent_ref;
		    };
	    herein

		# Check-limit for standard functions,
		# i.e. functions which may have unknown callers:
		#
		make_and_save_heaplimit_check_for_standard_function
		    =
		    make_and_save_heaplimit_check_for__ccomponent_ref   { ccomponent_ref => cccomponent_heapcleaner_blocks, all_callers_known => FALSE, optimized => FALSE };


		# Check-limit for all-callers-known functions,
		# i.e.~functions called only from within the
		# same callgraph connected component:
		#
		make_and_save_heaplimit_check_for_all_callers_known_function
		    =
		    make_and_save_heaplimit_check_for__ccomponent_ref { ccomponent_ref => all_callers_known_heapcleaner_blocks, all_callers_known => TRUE, optimized => FALSE };


		# Same as above, but for functions which are to be optimized:
		#
		make_and_save_heaplimit_check_for_optimized_all_callers_known_function
		    =
		    make_and_save_heaplimit_check_for__ccomponent_ref { ccomponent_ref => all_callers_known_heapcleaner_blocks, all_callers_known => TRUE, optimized => TRUE };
	    end;

	    # A rw_vector for checking cycles:
	    #
	    stipulate
		max_root_register_id_plus_1
		    =
		    1 + fold_right
			(fn (register, n) =  int::max (rkj::intrakind_register_id_of  register,  n)) 
			0
			heapcleaner_root_set.regs;
	    herein

		client_roots__global = rwv::make_rw_vector (max_root_register_id_plus_1, -1);			# More icky thread-hostile mutable global state.  XXX SUCKO FIXME
		stamp__global        = REF 0;									# More icky thread-hostile mutable global state.  XXX SUCKO FIXME
	    end;


	    # This function packs root_holding_registers, int_holding_registers and
	    # float_holding_registers into heapcleaner_parameter_registers.  If the registers
	    # to pass (first three) outnumber the registers available
	    # (heapcleaner_parameter_registers) then we pack stuff into a heap
	    # record and pass a pointer to the rectord.
	    #
	    # heapcleaner_parameter_registers must be non-empty -- we can't pass
	    # anything to the heapcleaner in zero registers!
	    #
	    # We return a function to unpack everything back into
	    # the original registers after heapcleaning is complete.
	    #
	    fun pack (emit_op, heapcleaner_parameter_registers, root_holding_registers, int_holding_registers, float_holding_registers)
		=
		{   # Datatype naming describes the contents a heapcleaner root.
		    #
		    Naming
		      = REG      rkj::Codetemp_Info			# Integer register.
		      | FREG     rkj::Codetemp_Info			# Floating point register.
		      | MEM      (tcf::Int_Expression, frr::Ramregion)	# Integer memory register.
		      | RECORD   { is_boxed:	Bool,			# Is it a boxed record?
				   words:	Int,			# How many words?
				   reg:		rkj::Codetemp_Info,	# Address of this record.
				   reg_tmp:	rkj::Codetemp_Info,	# Temp used for unpacking.
				   fields:	List( Naming )		# Its fields.
				 };


		    # Translate int_expression/float_expression into namings.
		    # Note: client roots from memory (XXX) should NOT be used without
		    # fixing a potential cycle problem in the parallel copies below.		XXX SUCKO FIXME
		    # Currently no architectures -- including Intel32 -- use
		    # the LOAD(...) form, so we are safe.
		    #	
		    fun bind (tcf::REG  (32, r            )) =>   REG r;
			bind (tcf::LOAD (32, ea, ramregion)) =>   MEM (ea, ramregion);  #  XXX 
			bind (_)                             =>   error "bind";
		    end;

		    fun fbind (tcf::FREG (64, r)) =>   FREG r;
			fbind (_)                 =>   error "fbind";
		    end;

		    stamp  =  *stamp__global;
		    cyclic =   stamp + 1;

		    if (stamp > 100000)   stamp__global := 0;
		    else                  stamp__global := stamp + 2;
		    fi;

		    client_root_count =   rwv::length  client_roots__global;


		    fun mark_clients []
			    =>
			    ();

			mark_clients (tcf::REG(_, register) ! rs)
			    => 
			    {   rx =  rkj::intrakind_register_id_of  register;

				if (rx < client_root_count)
				    #
				    rwv::set (client_roots__global, rx, stamp);
				fi;

				mark_clients rs;
			    };

			mark_clients(_ ! rs)
			    =>
			    mark_clients rs;
		    end;


		    fun mark_heapcleaner_parameter_registers []
			    =>
			    ();

			mark_heapcleaner_parameter_registers (tcf::REG(_, register) ! rest)
			    => 
			    {   rx = rkj::intrakind_register_id_of  register;

				if  (rwv::get (client_roots__global, rx) == stamp)
				     rwv::set (client_roots__global, rx, cyclic);
				fi; 

				mark_heapcleaner_parameter_registers rest;
			    };

			mark_heapcleaner_parameter_registers(_ ! rest)
			    =>
			    mark_heapcleaner_parameter_registers rest;
		    end;

		    mark_clients  root_holding_registers;
		    mark_clients  int_holding_registers;

		    mark_heapcleaner_parameter_registers  heapcleaner_parameter_registers;


		    # First, generate code to
		    # pack all unboxed roots
		    # (if any) into a record:
		    #
		    boxed_stuff
			= 
			case (int_holding_registers, float_holding_registers)
			    #
			    ([], [])
				=>
				map bind root_holding_registers;

			    _
				=>
				# Align the heap_allocation_pointer
				# if we have floating point roots:
				#
				{   case float_holding_registers
					#
					[] => ();

					_  => emit_op  ( tcf::LOAD_INT_REGISTER			# heap_allocation_pointer |= 4;
							   ( pri::address_width,
							     heap_allocation_pointer_register,
							     #	 
							     tcf::BITWISE_OR
							       ( pri::address_width,
								 pri::heap_allocation_pointer,
								 make_int_literal 4		# 64-bit issue. This aligns heap_allocation_pointer correctly for a 32-bit tagword followed by 64-bit float.
							       )				# This won't work and is counterproductive if we're using 64-bit tagwords and keeping the heap always 64-bit aligned.  XXX BUGGO FIXME.
							   )
						       );
				    esac;

				    # If we have int32 or floating point stuff, package them
				    # up into a raw record.  Float64 stuff (more generally,
				    # 64-bit stuff) has to come first, while we still have
				    # 64-bit alignment guaranteed.
				    #
				    qwords =   length float_holding_registers + (length int_holding_registers + 1) / 2;	# 64-bit issue. We'll be using int64 not int32 in 64-bit mode.
				    #
				    RECORD
				      {
					is_boxed =>  FALSE,
					reg      =>  rgk::make_int_codetemp (), 
					reg_tmp  =>  rgk::make_int_codetemp (),

					words    =>  qwords + qwords,
					fields   =>  map fbind float_holding_registers  @  map bind int_holding_registers
				      } 
				      !
				      map bind root_holding_registers;

				};
			esac;


		    # Then, we check whether we have enough
		    # heapcleaner roots to store boxed_stuff.
		    # If so, we are safe; otherwise, we have
		    # to pack up some of the  boxed stuff into
		    # a record too.

		    n_boxed_stuff			=   length  boxed_stuff;
		    n_heapcleaner_parameter_registers	=   length  heapcleaner_parameter_registers;

		    namings
			= 
			if (n_boxed_stuff <= n_heapcleaner_parameter_registers) 
			    #
			    boxed_stuff;						# Good enough.
			else
			    # Package up some of the boxed stuff:

			    extra         =  n_boxed_stuff - n_heapcleaner_parameter_registers + 1;

			    pack_up       =  list::take_n (boxed_stuff, extra);		# First 'extra' elements of boxed_stuff list.
			    don't_pack_up =  list::drop_n (boxed_stuff, extra);		# Remaining     elements of boxed_stuff list.

			    RECORD
			      {
				is_boxed =>   TRUE,
				words    =>   length pack_up,
				reg_tmp  =>   rgk::make_int_codetemp (),
				reg      =>   rgk::make_int_codetemp (),
				fields   =>   pack_up
			      }
			      !
			      don't_pack_up; 
			fi;

		    fun copy ( [],   _) =>   ();
			copy (dst, src) =>   emit_op (tcf::MOVE_INT_REGISTERS (32, dst, src));		# Parallel copy of N source registers to N destination registers, possibly overlapping.
		    end;


		    # Copy the client roots into the real heapcleaner roots.
		    # We have to make sure that cycles are correctly handled 
		    # so we can't do a copy at a time!  But see XXX below.
		    #
		    fun prolog (hp, unused_roots, [], rds, rss)						# "rds" == "destination registers";   "rss" == "source registers".
			    => 
			    {   fun set_registers_to_void [] => ();
				    #
				    set_registers_to_void (tcf::REG  (type, rd     ) ! roots) =>   { emit_op (tcf::LOAD_INT_REGISTER (type, rd, void));	set_registers_to_void roots; };
				    set_registers_to_void (tcf::LOAD (type, ea, mem) ! roots) =>   { emit_op (tcf::STORE_INT (type, ea, void, mem));	set_registers_to_void roots; };
				    #
				    set_registers_to_void _ => error "set_registers_to_void";
				end;


				# Update the heap pointer if we have done any allocation:
				#
				if (hp > 0)
				    #
				    emit_op ( tcf::LOAD_INT_REGISTER					# heap_allocation_pointer += hp;
                                                ( pri::address_width,
                                                  heap_allocation_pointer_register, 
					          tcf::ADD
                                                    ( pri::address_width,
                                                      pri::heap_allocation_pointer,
                                                      make_int_literal hp
                                                    )
                                                )
                                            );
				fi;

				# Emit the parallel copies:
				#
				copy (rds, rss);							# "rds" == "destination registers";   "rss" == "source registers".

				# Any unused heapcleaner roots
				# must be cleared to void.
				# The following MUST come last:
				#
				set_registers_to_void  unused_roots;
			    };


			prolog (hp,  tcf::REG(_, rd) ! roots,  REG rs ! bs,                       rds, rss)
			    => 
			    # Copy client root rs into heapcleaner root rd  
			    #
			    prolog (hp, roots, bs, rd ! rds, rs ! rss);


			prolog (hp,  tcf::REG(_, rd) ! roots,  RECORD (r as { reg, ... } ) ! bs,  rds, rss)
			    => 
			    {    # Make a record then copy:

				 hp =   make_record (hp, r);

				 prolog  (hp,  roots,  bs,  rd ! rds,  reg ! rss);
			    };

	     #          prolog (hp, tcf::LOAD(_, ea, mem) ! roots, b ! bs, rds, rss)    # XXX
	     #             =
	     #             # The following code is unsafe because of potential cycles!
	     #             # But luckly, it is unused XXX.
	     #             #
	     #             {   my (hp, e)
	     #                    = 
	     #                     Case b
	     #                       of REG r => (hp, tcf::REG (32, r))
	     #                        | MEM (ea, mem) => (hp, tcf::LOAD (32, ea, mem))
	     #                        | RECORD (r as { reg, ... } ) => 
	     #                         (makeRecord (hp, r), tcf::REG (32, reg))
	     #                        | _ => error "floating point root";
	     #                 emit_op (tcf::STORE_INT (32, ea, e, mem));
	     #                 prolog (hp, roots, bs, rds, rss);
	     #             }

			prolog _ => error "prolog";
		    end 

		    # Make a record and put it in reg:
		    #	
		    also
		    fun make_record (hp, { is_boxed, words, reg, fields, ... } )
			= 
			{   fun disp n											# heap_allocation_pointer + n
				=
				tcf::ADD  (pri::address_width,  pri::heap_allocation_pointer,  make_int_literal n);


			    fun alloci (hp, e)										# heap_allocation_pointer[hp] = e
				=
				emit_op (tcf::STORE_INT (32, disp hp, e, frr::memory));					# 64-bit issue: '32' is wordsize-in-bits.



			    fun allocf (hp, e)										# heap_allocation_pointer[hp] = e
				=
				emit_op (tcf::STORE_FLOAT (64, disp hp, e, frr::memory));



			    fun alloc (hp, [])										# Store given list of registers and records at successive locations starting at 'hp' (=="heap pointer").
				    =>
				    ();

				alloc (hp, what ! rest)
				    => 
				    case what
					#
					REG r
					    =>
					    {   alloci (hp, tcf::REG (32, r));						# heap_allocation_pointer[hp] = r
						alloc (hp+4, rest);							# 64-bit issue: '32' is wordsize-in-bytes.
					    };

					RECORD { reg, ... }
					    => 
					    {   alloci (hp, tcf::REG (32, reg));					# heap_allocation_pointer[hp] = reg
						alloc (hp+4, rest);							# 64-bit issue: '32' is wordsize-in-bytes.
					    };

					MEM (ea, m)
					    =>
					    {   alloci (hp, tcf::LOAD (32, ea, m));					# heap_allocation_pointer[hp] = *m
						alloc (hp+4, rest);							# 64-bit issue: '32' is wordsize-in-bytes.
					    };

					FREG r
					    =>
					    {   allocf (hp, tcf::FREG (64, r));						# heap_allocation_pointer[hp] = r
						alloc (hp+8, rest);
					    };
				     esac;
			    end;


			    fun evaluate_args ([], hp)
				    =>
				    hp;

				evaluate_args (RECORD r ! args, hp)
				    => 
				    evaluate_args (args, make_record (hp, r));

				evaluate_args(_ ! args, hp)
				    =>
				    evaluate_args (args, hp);
			    end;


			    # MUST evaluate nested records first: 
			    #
			    hp   =   evaluate_args (fields, hp);

			    tagword =   is_boxed  ??    make_boxed_tagword  words
					          ::  make_unboxed_tagword  words;

			    # Write record/rawrec tagword:
			    # 
			    emit_op (tcf::STORE_INT (32,  disp hp,  make_int_literal tagword,  frr::memory));		# 64-bit issue: '32' is bits-per-word.

			    # Write record fields:
			    #	
			    alloc (hp+4, fields);									# 64-bit issue:  '4' is bytes-per-word.

			    # Save record address in register:
			    #
			    emit_op (tcf::LOAD_INT_REGISTER (pri::address_width, reg, disp (hp+4))); 			# 64-bit issue:  '4' is bytes-per-word.

			    # Return new top-of-heap:
			    #
			    hp + 4 + unt::to_int_x (unt::(<<) (unt::from_int words, 0u2)); 				# 64-bit issue:  '4' is bytes-per-word.
			};												# fun make_record


		    # Copy the heapcleaner roots back to client roots. 
		    # Again, to avoid potential cycles we
		    # generate a single parallel copy that
		    # moves the heapcleaner roots back to the client roots.
		    #
		    fun epilog ([], unused_heapcleaner_parameter_registers, rds, rss)
			    => 
			    copy (rds, rss);

			epilog (REG rd ! bs, tcf::REG(_, rs) ! roots, rds, rss)
			    => 
			    epilog (bs, roots, rd ! rds, rs ! rss);

			epilog (RECORD { fields, reg_tmp, ... } ! bs, tcf::REG(_, r) ! roots, rds, rss)
			    => 
			    {   # Unbundle record 

				emit_op (tcf::MOVE_INT_REGISTERS (32, [reg_tmp], [r]));

				my  (rds, rss)
				    =
				    unpack (reg_tmp, fields, rds, rss);

				epilog (bs, roots, rds, rss);
			    };

			epilog (b ! bs, r ! roots, rds, rss)
			    => 
			    {   assign (b, r); #  XXX 
				epilog (bs, roots, rds, rss);
			    };

			epilog _ => error "epilog";
		    end 

		    also
		    fun assign (REG r, e)         =>   emit_op (tcf::LOAD_INT_REGISTER (32, r, e));
			assign (MEM (ea, mem), e) =>   emit_op (tcf::STORE_INT (32, ea, e, mem));
			assign _                  =>   error "assign";
		    end 

		    # Unpack fields from record:
		    #
		    also
		    fun unpack (record_r, fields, rds, rss)
			= 
			{   record =   tcf::REG (32, record_r);									# Probable 64-bit issue.


			    fun disp n =   tcf::ADD  (pri::address_width,  record,  make_int_literal n);

			    fun  sel n =   tcf::LOAD  (32, disp n, frr::memory);						# Probable 64-bit issue.
			    fun fsel n =   tcf::FLOAD (64, disp n, frr::memory);


			    client_root_count =   rwv::length  client_roots__global;

			    # Unpack normal fields:
			    #
			    fun unpack_fields (n, [], rds, rss)
				    =>
				    (rds, rss);

				unpack_fields (n, FREG r ! bs, rds, rss)
				    => 
				    {   emit_op (tcf::LOAD_FLOAT_REGISTER (64, r, fsel n));
					#
					unpack_fields (n+8, bs, rds, rss);
				    };

				unpack_fields (n, MEM (ea, mem) ! bs, rds, rss)
				    => 
				    {   emit_op (tcf::STORE_INT (32, ea, sel n, mem));  #  XXX 					# Probable 64-bit issue.
					#
					unpack_fields (n+4, bs, rds, rss);							# Probable 64-bit issue.
				    };

				unpack_fields (n, RECORD { reg_tmp, ... } ! bs, rds, rss)
				    => 
				    {   emit_op (tcf::LOAD_INT_REGISTER (32, reg_tmp, sel n));					# Probable 64-bit issue.
					#
					unpack_fields (n+4, bs, rds, rss);							# Probable 64-bit issue.
				    };

				unpack_fields (n, REG rd ! bs, rds, rss)
				    => 
				    {   rdx =   rkj::intrakind_register_id_of  rd;

					if (rdx < client_root_count  and  rwv::get (client_roots__global, rdx) == cyclic)
					    #
					    tmp_r =   rgk::make_int_codetemp ();

					    # print "WARNING: CYCLE\n"; 

					    emit_op (tcf::LOAD_INT_REGISTER (32, tmp_r, sel n));				# Probable 64-bit issue.

					    unpack_fields (n+4, bs, rd ! rds, tmp_r ! rss);					# Probable 64-bit issue.
					else
					    emit_op (tcf::LOAD_INT_REGISTER (32, rd, sel n));					# Probable 64-bit issue.

					    unpack_fields (n+4, bs, rds, rss);							# Probable 64-bit issue.
					fi;
				    };
				end;

			    # Unpack nested record:
			    # 
			    fun unpack_nested (_, [], rds, rss)
				    =>
				    (rds, rss);

				unpack_nested (n, RECORD { fields, reg_tmp, ... } ! bs, rds, rss)
				    => 
				    {   my  (rds, rss)
					    =
					    unpack (reg_tmp, fields, rds, rss);

					unpack_nested (n+4, bs, rds, rss);							# 64-bit issue: '4' is bytes-per-word.
				    };

				unpack_nested (n, FREG _ ! bs, rds, rss)
				    =>
				    unpack_nested (n+8, bs, rds, rss);

				unpack_nested (n, _ ! bs, rds, rss)
				    =>
				    unpack_nested (n+4, bs, rds, rss);								# Probable 64-bit issue.
			    end;

			    my  (rds, rss)
				=
				unpack_fields (0, fields, rds, rss);

			    unpack_nested (0, fields, rds, rss);
		       };


		    # Generate code:
		    #
		    prolog (0, heapcleaner_parameter_registers, namings, [], []);


		    # Return the unpack function:
		    #
		    fn () =  epilog (namings, heapcleaner_parameter_registers, [], []);
		};


	    # The following auxiliary function generates
	    # the actual call-heapcleaner code. 
	    #
	    # It packages up the roots into the appropriate
	    # records, calls the heapcleaner routine, then
	    # unpacks the roots from the record.
	    #
	    fun emit_heapcleaner_call''
                  {
		    stream => { emit_op, put_bblock_note, define_local_label, ... }: Stream,
		    all_callers_known,
		    root_holding_registers,
		    int_holding_registers,
		    float_holding_registers,
		    return
                  }
		=
		{   fun convert_rootset_to_treecode { regs, mem }
			=
			map (fn r = tcf::REG (32, r))												# 64-bit issue: '32' is bits-per-word.
			    regs
			@ 
			map (fn i = tcf::LOAD (32, tcf::ADD (pri::address_width, pri::frameptr vfp, make_int_literal i), frr::memory))		# 64-bit issue: '32' is bits-per-word.
			    mem;


		    # IMPORTANT NOTE:  
		    # If a root happens be in a heapcleaner parameter register,
		    # we can remove this root since it will be correctly
		    # targetted. 
		    #
		    # root_holding_registers' are the boxed roots that
		    # we have to move to the appropriate registers.
		    #
		    # heapcleaner_root_set are the registers that are
		    # available for communicating to the heapcleaner.
		    #
		    boxed_set    =   split_expression_list_into_register_vs_ram_lists  root_holding_registers;
		    root_holding_registers' =   difference (boxed_set, heapcleaner_root_set);			# Roots.

		    available_heapcleaner_parameter_registers =   difference (heapcleaner_root_set, boxed_set);	# Available heapcleaner_parameter_registers.

		    fun mark call
			=
			if *debug_heapcleaner
			    #
			    tcf::NOTE
                              ( call,
                                lhn::comment.x_to_note
				    ( "roots="  + rootset_to_string  available_heapcleaner_parameter_registers
				    + " boxed=" + rootset_to_string  root_holding_registers'
				    )
                              );
			else
			    call;
			fi;

		    #  Convert them back to Treecode 
		    #
		    root_holding_registers          =   convert_rootset_to_treecode   root_holding_registers'               ;
		    heapcleaner_parameter_registers =   convert_rootset_to_treecode   available_heapcleaner_parameter_registers;

		    # If we have any remaining client roots
		    # after the above trick, we have to 
		    # make sure that heapcleaner_parameter_registers is not empty
		    # -- we need at least one heapcleaner root register
		    # in which to pass the remaining client roots to
		    # the heapcleaner:
		    #
		    my  (heapcleaner_parameter_registers, root_holding_registers)
			= 
			case (heapcleaner_parameter_registers, int_holding_registers, float_holding_registers, root_holding_registers)
			    #
			    ([], [], [], [])
				=>
				([], []);		#  It is okay.

			    ([], _, _, _)
				=>
				([a_root_reg], root_holding_registers @ [a_root_reg]); 

			    # We put a_root_reg last to reduce
			    # register pressure  during unpacking.

			    _  => (heapcleaner_parameter_registers, root_holding_registers);
			esac;

		    unpack =   pack (emit_op, heapcleaner_parameter_registers, root_holding_registers, int_holding_registers, float_holding_registers);

		    put_bblock_note  heapcleaner_call_note;
		    put_bblock_note  no_optimization_note; 
		    put_bblock_note  zero_freq_note;

		    emit_op  (mark  heapcleaner_call);

		    if all_callers_known
			#
			emit_baseptr_update (emit_op, define_local_label, put_bblock_note);
		    fi;

		    put_bblock_note  no_optimization_note;

		    unpack ();

		    emit_op  return;
		};												# fun emit_heapcleaner_call''


	    # The following function is responsible
	    # for generating only the call_heapcleaner code.
	    #
#	    fun emit_heapcleaner_call  stream  { live_registers, live_register_types, return }					# Commented out 2011-08-05 CrT because it is never called.
#		=
#		{   (classify_live_registers_into_root_int_and_float (live_registers, live_register_types, [], [], []))
#			->
#			{ root_holding_registers, int_holding_registers, float_holding_registers };
#
#		    emit_heapcleaner_call'' { stream, all_callers_known=>TRUE, root_holding_registers, int_holding_registers, float_holding_registers, return };
#		};
#


	    # This function emits a comment
	    # that prettyprints the root set.
	    # This is used for debugging only.
	    #
	    fun root_set_to_string { root_holding_registers, int_holding_registers, float_holding_registers }
		= 
		{   fun extract_reg (tcf::REG (32, r)) =>  r;							# Peel an int register.
			extract_reg _                  =>  error "extract_reg";
		    end;

		    fun extract_freg (tcf::FREG (64, f)) => f;							# Peel a float register.
			extract_freg _                   => error "extract_freg";
		    end;

		    fun listify title f []
			    =>
			    "";

			listify title f l
			    => 
			    title + fold_right
					fn (x, "") => f x;
					   (x,  y) => f x  +  ", "  +  y;
					end
					""
					(cos::make_colorset  l) + " ";
		    end;

		    listify  "boxed="  rkj::register_to_string  (map  extract_reg   root_holding_registers)    +
		    listify  "int32="  rkj::register_to_string  (map  extract_reg   int_holding_registers)    +
		    listify  "float="  rkj::register_to_string  (map  extract_freg  float_holding_registers);
		};


	    # The following function is responsible for generating actual
	    # heapcleaner-calling code, with entry labels and return information.
	    #
	    fun emit_heapcleaner_call'
                  { stream  as { emit_op, define_local_label, define_global_label, end_procedure, put_bblock_note, ... },
		    external_entry
                  }
                  heapcleaner_call
		= 
		{   heapcleaner_call
			->
			HEAPCLEANER_CALL { all_callers_known, optimized, root_holding_registers, int_holding_registers, float_holding_registers, live_registers, return, label_on_heapcleaner_call };

		    liveout =   optimized  ??  []
					   ::  live_registers;

		    if external_entry     define_global_label  *label_on_heapcleaner_call;
		    else                  define_local_label   *label_on_heapcleaner_call;
		    fi;

		    # When an all-callers-known block is to be optimized,
		    # no actual code is generated until later:
		    #
		    if (not optimized)
			#
			emit_heapcleaner_call'' { stream, all_callers_known, root_holding_registers, int_holding_registers, float_holding_registers, return };
		    else
			put_bblock_note (
			    #
			    lhn::heapcleaner_safepoint.x_to_note
				#
				(*debug_heapcleaner  ??  root_set_to_string { root_holding_registers, int_holding_registers, float_holding_registers }
					             ::  ""
				)
			);

			emit_op  return;
		    fi;

		    end_procedure (
			#
			case pri::heap_is_exhausted__test
			    #
			    THE platform_specific__heap_is_exhausted__test =>   tcf::FLAG_EXPRESSION platform_specific__heap_is_exhausted__test ! liveout;
			    NULL                                           =>                                                                     liveout; 
			esac
		    );
		};


	    # The following function checks
	    # whether two rootsets have the
	    # same calling convention.
	    #
	    fun same_calling_convention
		    ( HEAPCLEANER_CALL { root_holding_registers=>b1, int_holding_registers=>i1, float_holding_registers=>f1, return=>tcf::GOTO (ret1, _), ... },
		      HEAPCLEANER_CALL { root_holding_registers=>b2, int_holding_registers=>i2, float_holding_registers=>f2, return=>tcf::GOTO (ret2, _), ... }
		    )
		    =>
		    {   fun eq_ea ( tcf::REG(_, r1),
                                    tcf::REG(_, r2)
                                  )
				=>
				rkj::codetemps_are_same_color (r1, r2);

			    eq_ea ( tcf::ADD(_, tcf::REG(_, r1), tcf::LITERAL i),
				    tcf::ADD(_, tcf::REG(_, r2), tcf::LITERAL j)
                                  )
				=>  
				rkj::codetemps_are_same_color (r1, r2)
                                and
                                tcf::mi::eq (32, i, j);								# 64-bit issue: '32' is 'wordbits'.

			    eq_ea _ => FALSE;
			end;


			fun eq_r ( tcf::REG (_, r1),
                                   tcf::REG (_, r2)
                                 )
				=>
				rkj::codetemps_are_same_color (r1, r2);

			    eq_r ( tcf::LOAD(_, ea1, _),
                                   tcf::LOAD(_, ea2, _)
                                 )
				=>
				eq_ea (ea1, ea2);

			    eq_r _
				=>
				FALSE;
			end;


			fun eq_f ( tcf::FREG(_, f1),
                                   tcf::FREG(_, f2)
                                 )
				=>
				rkj::codetemps_are_same_color (f1, f2);

			    eq_f ( tcf::FLOAD(_, ea1, _),
                                   tcf::FLOAD(_, ea2, _)
                                 )
				=>
				eq_ea (ea1, ea2);

			    eq_f _ => FALSE;
			end;


			# Compare two lists; return TRUE iff
			# they compare pairwise equal per 'predicate'
			# and are the same length:
			#
			fun lists_match  predicate
			    = 
			    all'
			    where
				fun all' ( a ! resta,
                                           b ! restb
                                         )           =>   predicate (a, b)   and   all' (resta, restb);
				    all' ([],    []) =>   TRUE;
				    all' _           =>   FALSE;
				end;
			    end;

			same_int_expression =   lists_match  eq_r;

			same_int_expression (b1,   b2  )   and
                        eq_r                (ret1, ret2)   and 
			same_int_expression (i1,   i2  )   and
                        lists_match  eq_f   (f1,   f2  );
		    };

		same_calling_convention _
		    =>
		    FALSE;
	    end;


	    # The following function is called once
	    # at the end of compiling a cccomponent.							# "cccomponent" == "callgraph connected-component".
	    #
	    # It generates long jumps to the end
	    # of the module unit for standard functions,
	    # and directly invokes the heapcleaner for
	    # all-callers-known functions.
	    #
	    # The actual heapcleaner invocation code is not generated yet.
	    #
	    # This function is called (only) by   translate_fatecode_cccomponent_to_treecode   in
	    #
	    #     src/lib/compiler/back/low/main/main/translate-fatecode-to-treecode-g.pkg
	    #
	    fun emit_longjump_heapcleaner_calls
		(
		  stream as { emit_op,
			      define_local_label,
			      end_procedure,
			      ...
			    }
		)
		=
		{   # Heapcleaner code can be shared if the calling convention is the same.
		    # Use linear search to find the heapcleaner function.
		    #
		    fun find (heapcleaner_call as HEAPCLEANER_CALL { label_on_heapcleaner_call as REF heapcleaner_label, ... } )
			=
			search  *longjumps_to_heapcleaner_calls
			where 
			    fun search (LONGJUMP_TO_HEAPCLEANER_CALL { heapcleaner_call=>heapcleaner_call', labels_on_longjump } ! rest)
				    =>
				    if (same_calling_convention (heapcleaner_call, heapcleaner_call'))   labels_on_longjump :=  heapcleaner_label ! *labels_on_longjump;
				    else					                         search  rest;
				    fi;

				search []
				    => 
				    {   # No matching convention:

					label =   lbl::make_anonymous_codelabel ();

					label_on_heapcleaner_call :=   label;

					longjumps_to_heapcleaner_calls
					    :=
					    LONGJUMP_TO_HEAPCLEANER_CALL { heapcleaner_call, labels_on_longjump => REF [ heapcleaner_label ] }
					    !
					    *longjumps_to_heapcleaner_calls;
				    };
			    end;
			end;


		    # Generate long jumps to all external call-heapcleaner routines:
		    #
		    fun emit_long_jumps (LONGJUMP_TO_HEAPCLEANER_CALL { labels_on_longjump => REF [], ... } )
			    =>
			    ();

			emit_long_jumps
                            (LONGJUMP_TO_HEAPCLEANER_CALL
			      {
				labels_on_longjump,
				heapcleaner_call =>  HEAPCLEANER_CALL { label_on_heapcleaner_call, root_holding_registers, int_holding_registers, float_holding_registers, ... }
                              }
                            )
			    =>
			    {   live_out   =    live_plain_regs @ live_float_regs
						where
						    live_plain_regs =   map  tcf::INT_EXPRESSION    (int_holding_registers @ root_holding_registers);
						    live_float_regs =   map  tcf::FLOAT_EXPRESSION  float_holding_registers;
						end;

				apply  define_local_label  *labels_on_longjump
				before
				    labels_on_longjump := [];

				emit_op (tcf::GOTO (tcf::LABEL *label_on_heapcleaner_call, []));

				end_procedure  live_out;
			    };
		    end;

		    apply  find  *cccomponent_heapcleaner_blocks;

		    cccomponent_heapcleaner_blocks := [];

		    apply  emit_long_jumps  *longjumps_to_heapcleaner_calls;

		    apply   (emit_heapcleaner_call' { stream, external_entry => FALSE })   *all_callers_known_heapcleaner_blocks;

		    all_callers_known_heapcleaner_blocks := [];
		};																	# fun emit_longjump_heapcleaner_calls

	    # Generate module-specific heapcleaner-invocation code.
	    # We are called (only) from:
	    #
	    #     src/lib/compiler/back/low/main/main/translate-fatecode-to-treecode-g.pkg
	    #
	    fun emit_heapcleaner_calls_for_package  stream
		=
		{   heapcleaner_calls
			=
			map   heapcleaner_call_for_longjump   *longjumps_to_heapcleaner_calls
			where
			    fun heapcleaner_call_for_longjump   (LONGJUMP_TO_HEAPCLEANER_CALL { heapcleaner_call, ... })
				=
				heapcleaner_call;
			end;

		    apply   (emit_heapcleaner_call' { stream, external_entry => TRUE })   heapcleaner_calls;

		    longjumps_to_heapcleaner_calls := [];
		};

	end;
    };
end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


