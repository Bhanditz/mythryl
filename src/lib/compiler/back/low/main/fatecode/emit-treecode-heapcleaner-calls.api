# emit-treecode-heapcleaner-calls.api
#
# This is an alternative module for generating
# heapcleaner ("garbage collector") invocation code.
# There are a few improvements.
#
# All code to invoke heapcleaner is generated once at the end of the
# compilation unit---with one exception. For each cluster, a 
# call to heapcleaner is a jump  to the end of the cluster  where there 
# is another jump.
#
# Code to invoke heapcleaner for known functions is generated at the end of
# the cluster. This is important as there may be spilling across
# heapcleaner invocation calls.

# Compiled by:
#     src/lib/compiler/core.sublib


stipulate
    package fcf =  fatecode_form;				# fatecode_form			is from   src/lib/compiler/back/top/fatecode/fatecode-form.pkg
herein

    # This api is implemented in:
    #
    #     src/lib/compiler/back/low/main/fatecode/emit-treecode-heapcleaner-calls-g.pkg
    #
    api Emit_Treecode_Heapcleaner_Calls {
	#
	package tcs: Treecode_Stream;				# Treecode_Stream		is from   src/lib/compiler/back/low/treecode/treecode-stream.api

	package mcg: Machcode_Controlflow_Graph			# Machcode_Controlflow_Graph	is from   src/lib/compiler/back/low/mcg/machcode-controlflow-graph.api
		     where
			 pop == tcs::cst::pop;			# "pop" == "pseudo_op".


	Fun_Info
	  =
	  { max_heapbytes_eaten_before_next_heaplimit_check:	Int,
	    #
	    live_registers:	    List( tcs::tcf::Expression ),
	    live_register_types:    List( fcf::Type ),
	    return:		    tcs::tcf::Void_Expression
	  };

	Stream
	   =
	   tcs::Treecode_Stream (
	       tcs::tcf::Void_Expression,
	       List( tcs::tcf::Expression ),
	       mcg::Machcode_Controlflow_Graph
	   );


	# List of registers which are used
	# as roots for the heapcleaner:
	#
	heapcleaner_arg_registers
	    :
	    List( tcs::tcf::Int_Expression );			# Float registers don't contain pointers, so heapcleaner can ignore them.


	# Initialize the state before compiling a module 
	#
        clear__public_fn_heapcleaner_call_specs__private_fn_heapcleaner_call_specs__and__longjumps_to_heapcleaner_calls
	    :
	    Void -> Void;

	emit_heaplimit_check_and_push_heapcleaner_call_spec_for_public_fn	      :		Stream -> Fun_Info -> Void;
	emit_heaplimit_check_and_push_heapcleaner_call_spec_for_unoptimized_private_fn:		Stream -> Fun_Info -> Void;
	emit_heaplimit_check_and_push_heapcleaner_call_spec_for_optimized_private_fn  :		Stream -> Fun_Info -> Void;
	    #
	    # These all basically emit code equivalent to
	    #
	    #     if (heap_allocation_pointer > heap_allocation_limit)  goto foo;
	    #
	    # and then push code address 'foo' on a list.  Later we do
	    # a pass generating all the call-heapcleaner blocks 'foo' --
	    # the Fun_Info stuff is saved for this pass.


	# Generate longjumps to call the
	# heapcleaner ("garbage collector"): 
	#
	emit_longjump_heapcleaner_calls
	    :
	    Stream -> Void;


	# Generate all heapcleaner invocation code in a package:
	# 
	emit_heapcleaner_calls_for_package
	    :
	    Stream -> Void;


	# Generate the actual heapcleaner invocation code:
	#
#	emit_heapcleaner_call													# Commented out 2011-08-05 CrT because it is never called.
#	    :
#	    Stream
#	    ->
#	    { live_registers:	    List( tcs::tcf::Expression ), 	# Formal parameters.
#	      live_register_types:  List( fcf::Type ),			# Formal paramter types.
#	      return:		    tcs::tcf::Void_Expression
#	    }
#	    ->
#	    Void;

    };
end;

## Changes by Jeff Prothero Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
