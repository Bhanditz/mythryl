# codestream.api
#
# The compiler backend lowhalf components pass code
# via streams of treecode expressions and machcode
# (abstract machine code) instructions.   Here we define the
# abstract API shared by all such streams;  this API gets
# specialized to the various concrete streams.
#
# Codestream gets specialized to Treecode_Form in:				# Treecode_Form		is from   src/lib/compiler/back/low/treecode/treecode-form.api
#
#     src/lib/compiler/back/low/treecode/treecode-stream.api
#     src/lib/compiler/back/low/treecode/treecode-stream-g.pkg
#
# Codestream is also referenced in the architecture-agnostic files:
#
#     src/lib/compiler/back/low/mcg/make-machcode-controlflow-graph-g.pkg
#     src/lib/compiler/back/low/emit/instruction-emitter.api
#     src/lib/compiler/back/low/treecode/instruction-sequence-generator.api
#     src/lib/compiler/back/low/treecode/instruction-sequence-generator-g.pkg
#
# and the the architecture-specific files:
#
#     src/lib/compiler/back/low/intel32/emit/translate-machcode-to-asmcode-intel32-g.codemade.pkg
#     src/lib/compiler/back/low/pwrpc32/emit/translate-machcode-to-asmcode-pwrpc32-g.codemade.pkg
#     src/lib/compiler/back/low/sparc32/emit/translate-machcode-to-asmcode-sparc32-g.codemade.pkg
# 
#     src/lib/compiler/back/low/pwrpc32/emit/translate-machcode-to-execode-pwrpc32-g.codemade.pkg
#     src/lib/compiler/back/low/sparc32/emit/translate-machcode-to-execode-sparc32-g.codemade.pkg
#

# Compiled by:
#     src/lib/compiler/back/low/lib/lowhalf.lib

stipulate
    package lbl =  codelabel;							# codelabel		is from   src/lib/compiler/back/low/code/codelabel.pkg
herein

    # This api is "implemented" (mostly just echoed) in:
    #
    #     src/lib/compiler/back/low/code/codestream-g.pkg
    #
    api Codestream {
	#
	package pop:  Pseudo_Ops;						# Pseudo_Ops		is from   src/lib/compiler/back/low/mcg/pseudo-op.api

	Codestream (X,Y,Z,W)
	    =
	    { begin_connected_component:       Int -> Void,			# Start new compilation unit consisting of one connected component of the callgraph.
	      end_connected_component:         Y -> W,				# End compilation unit 
	      emit_op:             X -> Void,					# Emit assembly or machine instruction.
	      emit_pseudo_op:      pop::Pseudo_Op -> Void,			# Emit a pseudo op 
	      emit_public_label: lbl::Codelabel -> Void,			# Emit an externally   visible label marking current spot in codestream.
	      emit_private_label:  lbl::Codelabel -> Void,			# Emit an externally invisible label marking current spot in codestream.
	      emit_comment:        String -> Void,				# Emit comment 
	      emit_bblock_note:     note::Note -> Void,				# Add note to current basic block.
	      get_notes:           Void -> Ref( note::Notes ),			# Get annotations
	      emit__end_of_fn__mark:       Z -> Void					# Mark the end of a procedure 
	    };

       # Note:
       #	o  Each compilation unit should be wrapped between begin_connected_component/end_connected_component.
       #
       #	o  The method 'emit_bblock_note' adds an annotation to the current basic block,
       #	   not to the current instruction. 
       #
       #	o  The method emit_comment adds a comment to the current basic block.
       #	   Usually emit_comment(msg) is the same as 
       #	           emit_bblock_note(BasicAnnotations::COMMENT msg).


    };
end;