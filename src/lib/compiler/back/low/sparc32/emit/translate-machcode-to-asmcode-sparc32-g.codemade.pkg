## translate-machcode-to-asmcode-sparc32-g.codemade.pkg
#
# This file generated at   2011-08-04:02:01:34   by
#
#     src/lib/compiler/back/low/tools/arch/make-sourcecode-for-translate-machcode-to-asmcode-xxx-g-package.pkg
#
# from the architecture description file
#
#     src/lib/compiler/back/low/sparc32/sparc32.architecture-description
#
# Edits to this file will be LOST on next system rebuild.


# We are invoked by:
#
#     src/lib/compiler/back/low/main/sparc32/backend-lowhalf-sparc32.pkg
#
stipulate
    package lem =  lowhalf_error_message;						# lowhalf_error_message		is from   src/lib/compiler/back/low/control/lowhalf-error-message.pkg
    package rkj =  registerkinds_junk;						# registerkinds_junk		is from   src/lib/compiler/back/low/code/registerkinds-junk.pkg
herein

    generic package translate_machcode_to_asmcode_sparc32_g (
        #
        package cst: Codestream;							# Codestream			is from   src/lib/compiler/back/low/code/codestream.api
        
        package mcf: Machcode_Sparc32							# Machcode_Sparc32		is from   src/lib/compiler/back/low/sparc32/code/machcode-sparc32.codemade.api
                     where
                         tcf == cst::pop::tcf;				# "tcf" == "treecode_form".
        
        package crm: Compile_Register_Moves_Sparc32					# Compile_Register_Moves_Sparc32	is from   src/lib/compiler/back/low/sparc32/code/compile-register-moves-sparc32.api
                     where
                         mcf == mcf;
        
        package tce: Treecode_Eval							# Treecode_Eval			is from   src/lib/compiler/back/low/treecode/treecode-eval.api
                     where
                         tcf == mcf::tcf;					# "tcf" == "treecode_form".
        

###line 479.22 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"
        v9: Bool;

    )
    : (weak) Instruction_Emitter
    {
        									# Instruction_Emitter		is from   src/lib/compiler/back/low/emit/instruction-emitter.api
        
        # Export to client packages:
        #
        package cst =  cst;							# "cst"  == "codestream".
        package mcf =  mcf;							# "mcf" == "machcode_form" (abstract machine code).
        
        stipulate
            package rgk =  mcf::rgk;		# "rgk" == "registerkinds".
            package tcf =  mcf::tcf;		# "tcf" == "treecode_form".
            package pop =  cst::pop;						# "pop" == "pseudo_op".
            package lac =  mcf::lac;						# "lac" == "late_constant".
        herein
        
        include asm_flags;							# asm_flags		is from   src/lib/compiler/back/low/emit/asm-flags.pkg
        
        fun error msg
            =
            lem::error ("translate_machcode_to_asmcode_sparc32_g", msg);
        
        fun make_stream format_annotations
            =
            {   stream = *asm_stream::asm_out_stream;				# asm_stream		is from   src/lib/compiler/back/low/emit/asm-stream.pkg
        
                fun emit' s
                    =
                    file::write (stream, s);
        
                newline = REF TRUE;
                tabs    = REF 0;
        
                fun tabbing 0 => ();
                    tabbing n => { emit' "\t"; tabbing (n - 1); } ;
                end;
        
                fun emit s
                    =
                    {   tabbing *tabs;
                        tabs := 0;
                        newline := FALSE;
                        emit' s;
                    };
        
                fun nl     ()
                    =
                    {   tabs := 0;
                        if (not *newline)
                            #
                            newline := TRUE;
                            emit' "\n";
                        fi;
                    };
        
                fun comma  () =  emit ", ";
                fun tab    () =  tabs := 1;
                fun indent () =  tabs := 2;
        
                fun ms n
                    =
                    {   s = int::to_string n;
        
                        if (n < 0)   "-" + string::substring (s, 1, size s - 1);
                        else         s;
                        fi;
                    };
        
                fun emit_label lab           = emit (pop::cpo::bpo::label_expression_to_string (tcf::LABEL lab));
                fun emit_label_expression le = emit (pop::cpo::bpo::label_expression_to_string (tcf::LABEL_EXPRESSION le));
        
                fun emit_const lateconst
                    =
                    emit (lac::late_constant_to_string  lateconst);
        
                fun emit_int i
                    =
                    emit (ms i);
        
                fun paren f
                    =
                    {   emit "(";
                        f ();
                        emit ")";
                    };
        
                fun define_local_label  label
                    =
                    emit (pop::cpo::bpo::define_local_label label  +  "\n");
        
                fun define_global_label  label
                    =
                    define_local_label  label;
        
                fun emit_comment  msg
                    =
                    {   tab ();
                        emit ("/* " + msg + " */");
                        nl ();
                    };
        
                fun put_bblock_note a
                    =
                    emit_comment (note::to_string a);
        
                fun get_notes () =  error "get_notes";
                fun do_nothing _ =  ();
                fun fail _       =  raise exception FAIL "asmcode-emitter";
        
                fun emit_ramregion  ramregion
                    =
                    emit_comment (mcf::rgn::ramregion_to_string  ramregion);
        
                emit_ramregion
                    =
                    if *show_region    emit_ramregion;
                    else               do_nothing;
                    fi;
        
                fun emit_pseudo_op  pseudo_op
                    =
                    {   emit (pop::pseudo_op_to_string  pseudo_op);
                        emit "\n";
                    };
        
                fun init  size
                    =
                    {   emit_comment ("Code Size = " + ms size);
                        nl ();
                    };
        
                emit_register_info = asm_formatting_utilities::reginfo
                                         (emit, format_annotations);
        
                fun emit_register r
                    =
                    {   emit (rkj::register_to_string r);
                        emit_register_info r;
                    };
        
                fun emit_registerset (title, registerset)
                    =
                    {   nl ();
                        emit_comment  (title  +  rkj::cls::codetemplists_to_string  registerset);
                    };
        
                emit_registerset
                    =
                    if *show_registerset   emit_registerset;
                    else                   do_nothing;
                    fi;
        
                fun emit_defs  registerset =  emit_registerset ("defs: ", registerset);
                fun emit_uses  registerset =  emit_registerset ("uses: ", registerset);
        
                emit_cuts_to
                    =
                    *show_cuts_to   ??   asm_formatting_utilities::emit_cuts_to  emit
                                    ::   do_nothing;
        
                fun emitter instruction
                    =
                    {
                        # NB: The following incorrect-indentation problem is nontrivial to fix
                        #     so I'm just living with it for the moment.  -- 2011-05-14 CrT

        fun asm_load (mcf::LDSB) => "ldsb";
            asm_load (mcf::LDSH) => "ldsh";
            asm_load (mcf::LDUB) => "ldub";
            asm_load (mcf::LDUH) => "lduh";
            asm_load (mcf::LD) => "ld";
            asm_load (mcf::LDX) => "ldx";
            asm_load (mcf::LDD) => "ldd";
        end

        also
        fun emit_load x 
            =
            emit (asm_load x)

        also
        fun asm_store (mcf::STB) => "stb";
            asm_store (mcf::STH) => "sth";
            asm_store (mcf::ST) => "st";
            asm_store (mcf::STX) => "stx";
            asm_store (mcf::STD) => "std";
        end

        also
        fun emit_store x 
            =
            emit (asm_store x)

        also
        fun asm_fload (mcf::LDF) => "ldf";
            asm_fload (mcf::LDDF) => "lddf";
            asm_fload (mcf::LDQF) => "ldqf";
            asm_fload (mcf::LDFSR) => "ldfsr";
            asm_fload (mcf::LDXFSR) => "ldxfsr";
        end

        also
        fun emit_fload x 
            =
            emit (asm_fload x)

        also
        fun asm_fstore (mcf::STF) => "stf";
            asm_fstore (mcf::STDF) => "stdf";
            asm_fstore (mcf::STFSR) => "stfsr";
        end

        also
        fun emit_fstore x 
            =
            emit (asm_fstore x)

        also
        fun asm_arith (mcf::AND) => "and";
            asm_arith (mcf::ANDCC) => "andcc";
            asm_arith (mcf::ANDN) => "andn";
            asm_arith (mcf::ANDNCC) => "andncc";
            asm_arith (mcf::OR) => "or";
            asm_arith (mcf::ORCC) => "orcc";
            asm_arith (mcf::ORN) => "orn";
            asm_arith (mcf::ORNCC) => "orncc";
            asm_arith (mcf::XOR) => "xor";
            asm_arith (mcf::XORCC) => "xorcc";
            asm_arith (mcf::XNOR) => "xnor";
            asm_arith (mcf::XNORCC) => "xnorcc";
            asm_arith (mcf::ADD) => "add";
            asm_arith (mcf::ADDCC) => "addcc";
            asm_arith (mcf::TADD) => "tadd";
            asm_arith (mcf::TADDCC) => "taddcc";
            asm_arith (mcf::TADDTV) => "taddtv";
            asm_arith (mcf::TADDTVCC) => "taddtvcc";
            asm_arith (mcf::SUB) => "sub";
            asm_arith (mcf::SUBCC) => "subcc";
            asm_arith (mcf::TSUB) => "tsub";
            asm_arith (mcf::TSUBCC) => "tsubcc";
            asm_arith (mcf::TSUBTV) => "tsubtv";
            asm_arith (mcf::TSUBTVCC) => "tsubtvcc";
            asm_arith (mcf::UMUL) => "umul";
            asm_arith (mcf::UMULCC) => "umulcc";
            asm_arith (mcf::SMUL) => "smul";
            asm_arith (mcf::SMULCC) => "smulcc";
            asm_arith (mcf::UDIV) => "udiv";
            asm_arith (mcf::UDIVCC) => "udivcc";
            asm_arith (mcf::SDIV) => "sdiv";
            asm_arith (mcf::SDIVCC) => "sdivcc";
            asm_arith (mcf::MULX) => "mulx";
            asm_arith (mcf::SDIVX) => "sdivx";
            asm_arith (mcf::UDIVX) => "udivx";
        end

        also
        fun emit_arith x 
            =
            emit (asm_arith x)

        also
        fun asm_shift (mcf::SLL) => "sll";
            asm_shift (mcf::SRL) => "srl";
            asm_shift (mcf::SRA) => "sra";
            asm_shift (mcf::SLLX) => "sllx";
            asm_shift (mcf::SRLX) => "srlx";
            asm_shift (mcf::SRAX) => "srax";
        end

        also
        fun emit_shift x 
            =
            emit (asm_shift x)

        also
        fun asm_farith1 (mcf::FITOS) => "fitos";
            asm_farith1 (mcf::FITOD) => "fitod";
            asm_farith1 (mcf::FITOQ) => "fitoq";
            asm_farith1 (mcf::FSTOI) => "fstoi";
            asm_farith1 (mcf::FDTOI) => "fdtoi";
            asm_farith1 (mcf::FQTOI) => "fqtoi";
            asm_farith1 (mcf::FSTOD) => "fstod";
            asm_farith1 (mcf::FSTOQ) => "fstoq";
            asm_farith1 (mcf::FDTOS) => "fdtos";
            asm_farith1 (mcf::FDTOQ) => "fdtoq";
            asm_farith1 (mcf::FQTOS) => "fqtos";
            asm_farith1 (mcf::FQTOD) => "fqtod";
            asm_farith1 (mcf::FMOVS) => "fmovs";
            asm_farith1 (mcf::FNEGS) => "fnegs";
            asm_farith1 (mcf::FABSS) => "fabss";
            asm_farith1 (mcf::FMOVD) => "fmovd";
            asm_farith1 (mcf::FNEGD) => "fnegd";
            asm_farith1 (mcf::FABSD) => "fabsd";
            asm_farith1 (mcf::FMOVQ) => "fmovq";
            asm_farith1 (mcf::FNEGQ) => "fnegq";
            asm_farith1 (mcf::FABSQ) => "fabsq";
            asm_farith1 (mcf::FSQRTS) => "fsqrts";
            asm_farith1 (mcf::FSQRTD) => "fsqrtd";
            asm_farith1 (mcf::FSQRTQ) => "fsqrtq";
        end

        also
        fun emit_farith1 x 
            =
            emit (asm_farith1 x)

        also
        fun asm_farith2 (mcf::FADDS) => "fadds";
            asm_farith2 (mcf::FADDD) => "faddd";
            asm_farith2 (mcf::FADDQ) => "faddq";
            asm_farith2 (mcf::FSUBS) => "fsubs";
            asm_farith2 (mcf::FSUBD) => "fsubd";
            asm_farith2 (mcf::FSUBQ) => "fsubq";
            asm_farith2 (mcf::FMULS) => "fmuls";
            asm_farith2 (mcf::FMULD) => "fmuld";
            asm_farith2 (mcf::FMULQ) => "fmulq";
            asm_farith2 (mcf::FSMULD) => "fsmuld";
            asm_farith2 (mcf::FDMULQ) => "fdmulq";
            asm_farith2 (mcf::FDIVS) => "fdivs";
            asm_farith2 (mcf::FDIVD) => "fdivd";
            asm_farith2 (mcf::FDIVQ) => "fdivq";
        end

        also
        fun emit_farith2 x 
            =
            emit (asm_farith2 x)

        also
        fun asm_fcmp (mcf::FCMPS) => "fcmps";
            asm_fcmp (mcf::FCMPD) => "fcmpd";
            asm_fcmp (mcf::FCMPQ) => "fcmpq";
            asm_fcmp (mcf::FCMPES) => "fcmpes";
            asm_fcmp (mcf::FCMPED) => "fcmped";
            asm_fcmp (mcf::FCMPEQ) => "fcmpeq";
        end

        also
        fun emit_fcmp x 
            =
            emit (asm_fcmp x)

        also
        fun asm_branch (mcf::BN) => "n";
            asm_branch (mcf::BE) => "e";
            asm_branch (mcf::BLE) => "le";
            asm_branch (mcf::BL) => "l";
            asm_branch (mcf::BLEU) => "leu";
            asm_branch (mcf::BCS) => "cs";
            asm_branch (mcf::BNEG) => "neg";
            asm_branch (mcf::BVS) => "vs";
            asm_branch (mcf::BA) => "";
            asm_branch (mcf::BNE) => "ne";
            asm_branch (mcf::BG) => "g";
            asm_branch (mcf::BGE) => "ge";
            asm_branch (mcf::BGU) => "gu";
            asm_branch (mcf::BCC) => "cc";
            asm_branch (mcf::BPOS) => "pos";
            asm_branch (mcf::BVC) => "vs";
        end

        also
        fun emit_branch x 
            =
            emit (asm_branch x)

        also
        fun asm_rcond (mcf::RZ) => "rz";
            asm_rcond (mcf::RLEZ) => "rlez";
            asm_rcond (mcf::RLZ) => "rlz";
            asm_rcond (mcf::RNZ) => "rnz";
            asm_rcond (mcf::RGZ) => "rgz";
            asm_rcond (mcf::RGEZ) => "rgez";
        end

        also
        fun emit_rcond x 
            =
            emit (asm_rcond x)

        also
        fun asm_prediction (mcf::PT) => "pt";
            asm_prediction (mcf::PN) => "pn";
        end

        also
        fun emit_prediction x 
            =
            emit (asm_prediction x)

        also
        fun asm_fbranch (mcf::FBN) => "fbn";
            asm_fbranch (mcf::FBNE) => "fbne";
            asm_fbranch (mcf::FBLG) => "fblg";
            asm_fbranch (mcf::FBUL) => "fbul";
            asm_fbranch (mcf::FBL) => "fbl";
            asm_fbranch (mcf::FBUG) => "fbug";
            asm_fbranch (mcf::FBG) => "fbg";
            asm_fbranch (mcf::FBU) => "fbu";
            asm_fbranch (mcf::FBA) => "fb";
            asm_fbranch (mcf::FBE) => "fbe";
            asm_fbranch (mcf::FBUE) => "fbue";
            asm_fbranch (mcf::FBGE) => "fbge";
            asm_fbranch (mcf::FBUGE) => "fbuge";
            asm_fbranch (mcf::FBLE) => "fble";
            asm_fbranch (mcf::FBULE) => "fbule";
            asm_fbranch (mcf::FBO) => "fbo";
        end

        also
        fun emit_fbranch x 
            =
            emit (asm_fbranch x)

        also
        fun asm_fsize (mcf::SS) => "s";
            asm_fsize (mcf::DD) => "d";
            asm_fsize (mcf::QQ) => "q";
        end

        also
        fun emit_fsize x 
            =
            emit (asm_fsize x)

        also
        fun emit_operand (mcf::REG int_register) => emit_register int_register;
            emit_operand (mcf::IMMED int) => emit_int int;
            emit_operand (mcf::LAB label_expression) => emit_label_expression label_expression;
            emit_operand (mcf::LO label_expression) => {   emit "%lo("; 
                                                           emit_label_expression label_expression; 
                                                           emit ")"; 
                                                       };
            emit_operand (mcf::HI label_expression) => {   emit "%hi("; 
                                                           emit_label_expression label_expression; 
                                                           emit ")"; 
                                                       };
        end;

###line 482.7 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"

        fun emit_leaf FALSE => ();
            emit_leaf TRUE => emit "l";
        end;

###line 483.7 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"

        fun emit_nop FALSE => ();
            emit_nop TRUE => emit "\n\tnop";
        end;

###line 484.7 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"

        fun emit_a FALSE => ();
            emit_a TRUE => emit ",a";
        end;

###line 485.7 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"

        fun emit_cc FALSE => ();
            emit_cc TRUE => emit "cc";
        end;

        fun emit_op' instruction 
            =
            case instruction
                #
                mcf::LOAD { l, 
                            d, 
                            r, 
                            i, 
                            ramregion
                          }
                    => {   emit_load l; 
                           emit "\t["; 
                           emit_register r; 
                           emit "+"; 
                           emit_operand i; 
                           emit "], "; 
                           emit_register d; 
                           emit_ramregion ramregion; 
                       };
                mcf::STORE { s, 
                             d, 
                             r, 
                             i, 
                             ramregion
                           }
                    => {   emit_store s; 
                           emit "\t"; 
                           emit_register d; 
                           emit ", ["; 
                           emit_register r; 
                           emit "+"; 
                           emit_operand i; 
                           emit "]"; 
                           emit_ramregion ramregion; 
                       };
                mcf::FLOAD { l, 
                             r, 
                             i, 
                             d, 
                             ramregion
                           }
                    => {   emit_fload l; 
                           emit "\t["; 
                           emit_register r; 
                           emit "+"; 
                           emit_operand i; 
                           emit "], "; 
                           emit_register d; 
                           emit_ramregion ramregion; 
                       };
                mcf::FSTORE { s, 
                              d, 
                              r, 
                              i, 
                              ramregion
                            }
                    => {   emit_fstore s; 
                           emit "\t["; 
                           emit_register r; 
                           emit "+"; 
                           emit_operand i; 
                           emit "], "; 
                           emit_register d; 
                           emit_ramregion ramregion; 
                       };
                mcf::UNIMP { const22 } => {   emit "unimp "; 
                                              emit_int const22; 
                                          };
                mcf::SETHI { i, 
                             d
                           }
                    => {   
###line 669.18 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"
                           i = unt32::to_string (unt32::(<<) (unt32::from_int i, 
                                                    0uxA));

                               {   emit "sethi\t%hi(0x"; 
                                   emit i; 
                                   emit "), "; 
                                   emit_register d; 
                               };
                       };
                mcf::ARITH { a, 
                             r, 
                             i, 
                             d
                           }
                    => case (a, rkj::interkind_register_id_of r, rkj::interkind_register_id_of d, 
                               i)
                           #
                           (mcf::OR, 0, _, mcf::REG _) => {   emit "mov\t"; 
                                                              emit_operand i; 
                                                              emit ", "; 
                                                              emit_register d; 
                                                          };
                           (mcf::OR, 0, _, _) => {   emit "set\t"; 
                                                     emit_operand i; 
                                                     emit ", "; 
                                                     emit_register d; 
                                                 };
                           (mcf::SUBCC, _, 0, _) => {   emit "cmp\t"; 
                                                        emit_register r; 
                                                        emit ", "; 
                                                        emit_operand i; 
                                                    };
                           _   => {   emit_arith a; 
                                      emit "\t"; 
                                      emit_register r; 
                                      emit ", "; 
                                      emit_operand i; 
                                      emit ", "; 
                                      emit_register d; 
                                  };
                       esac;
                mcf::SHIFT { s, 
                             r, 
                             i, 
                             d
                           }
                    => {   emit_shift s; 
                           emit "\t"; 
                           emit_register r; 
                           emit ", "; 
                           emit_operand i; 
                           emit ", "; 
                           emit_register d; 
                       };
                mcf::MOVICC { b, 
                              i, 
                              d
                            }
                    => {   emit "mov"; 
                           emit_branch b; 
                           emit "\t"; 
                           emit_operand i; 
                           emit ", "; 
                           emit_register d; 
                       };
                mcf::MOVFCC { b, 
                              i, 
                              d
                            }
                    => {   emit "mov"; 
                           emit_fbranch b; 
                           emit "\t"; 
                           emit_operand i; 
                           emit ", "; 
                           emit_register d; 
                       };
                mcf::MOVR { rcond, 
                            r, 
                            i, 
                            d
                          }
                    => {   emit "movr"; 
                           emit_rcond rcond; 
                           emit "\t"; 
                           emit_register r; 
                           emit ", "; 
                           emit_operand i; 
                           emit ", "; 
                           emit_register d; 
                       };
                mcf::FMOVICC { size, 
                               b, 
                               r, 
                               d
                             }
                    => {   emit "fmov"; 
                           emit_fsize size; 
                           emit_branch b; 
                           emit "\t"; 
                           emit_register r; 
                           emit ", "; 
                           emit_register d; 
                       };
                mcf::FMOVFCC { size, 
                               b, 
                               r, 
                               d
                             }
                    => {   emit "fmov"; 
                           emit_fsize size; 
                           emit_fbranch b; 
                           emit "\t"; 
                           emit_register r; 
                           emit ", "; 
                           emit_register d; 
                       };
                mcf::BICC { b, 
                            a, 
                            label, 
                            nop
                          }
                    => {   emit "b"; 
                           emit_branch b; 
                           emit_a a; 
                           emit "\t"; 
                           emit_label label; 
                           emit_nop nop; 
                       };
                mcf::FBFCC { b, 
                             a, 
                             label, 
                             nop
                           }
                    => {   emit_fbranch b; 
                           emit_a a; 
                           emit "\t"; 
                           emit_label label; 
                           emit_nop nop; 
                       };
                mcf::BR { rcond, 
                          p, 
                          r, 
                          a, 
                          label, 
                          nop
                        }
                    => {   emit "b"; 
                           emit_rcond rcond; 
                           emit_a a; 
                           emit_prediction p; 
                           emit "\t"; 
                           emit_register r; 
                           emit ", "; 
                           emit_label label; 
                           emit_nop nop; 
                       };
                mcf::BP { b, 
                          p, 
                          cc, 
                          a, 
                          label, 
                          nop
                        }
                    => {   emit "bp"; 
                           emit_branch b; 
                           emit_a a; 
                           emit_prediction p; 
                           emit "\t%"; 
                           emit if (cc == mcf::ICC)   "i";
                                else   "x";
                                fi; 
                           emit "cc, "; 
                           emit_label label; 
                           emit_nop nop; 
                       };
                mcf::JMP { r, 
                           i, 
                           labs, 
                           nop
                         }
                    => {   emit "jmp\t["; 
                           emit_register r; 
                           emit "+"; 
                           emit_operand i; 
                           emit "]"; 
                           emit_nop nop; 
                       };
                mcf::JMPL { r, 
                            i, 
                            d, 
                            defs, 
                            uses, 
                            cuts_to, 
                            nop, 
                            ramregion
                          }
                    => {   emit "jmpl\t["; 
                           emit_register r; 
                           emit "+"; 
                           emit_operand i; 
                           emit "], "; 
                           emit_register d; 
                           emit_ramregion ramregion; 
                           emit_defs defs; 
                           emit_uses uses; 
                           emit_cuts_to cuts_to; 
                           emit_nop nop; 
                       };
                mcf::CALL { defs, 
                            uses, 
                            label, 
                            cuts_to, 
                            nop, 
                            ramregion
                          }
                    => {   emit "call\t"; 
                           emit_label label; 
                           emit_ramregion ramregion; 
                           emit_defs defs; 
                           emit_uses uses; 
                           emit_cuts_to cuts_to; 
                           emit_nop nop; 
                       };
                mcf::TICC { t, 
                            cc, 
                            r, 
                            i
                          }
                    => {   emit "t"; 
                           emit_branch t; 
                           emit "\t"; 
                           if (cc == mcf::ICC)   ();
                           else   (emit "%xcc, ");
                           fi; 
                           emit_register r; 
                           emit "+"; 
                           emit_operand i; 
                       };
                mcf::FPOP1 { a, 
                             r, 
                             d
                           }
                    => {   
###line 777.18 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"

                           fun f (a, r, d) 
                               =
                               {   emit a; 
                                   emit "\t"; 
                                   emit (rgk::float_register_to_string r); 
                                   emit ", "; 
                                   emit (rgk::float_register_to_string d); 
                               };

###line 782.18 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"

                           fun g (a, r, d) 
                               =
                               {   
###line 783.22 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"
                                   r = rkj::intrakind_register_id_of r;

###line 784.22 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"
                                   d = rkj::intrakind_register_id_of d;

                                   f (a, r, d); 
                                       emit "\n\t"; 
                                       f ("fmovs", r + 1, d + 1);
                               };

###line 788.18 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"

                           fun h (a, r, d) 
                               =
                               {   
###line 789.22 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"
                                   r = rkj::intrakind_register_id_of r;

###line 790.22 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"
                                   d = rkj::intrakind_register_id_of d;

                                   f (a, r, d); 
                                       emit "\n\t"; 
                                       f ("fmovs", r + 1, d + 1); 
                                       emit "\n\t"; 
                                       f ("fmovs", r + 2, d + 2); 
                                       emit "\n\t"; 
                                       f ("fmovs", r + 3, d + 3);
                               };

                           if  v9
                               #
                               emit_farith1 a; 
                               emit "\t"; 
                               emit_register r; 
                               emit ", "; 
                               emit_register d; 
                           else
                           case a
                               #
                               mcf::FMOVD => g ("fmovs", r, d);
                               mcf::FNEGD => g ("fnegs", r, d);
                               mcf::FABSD => g ("fabss", r, d);
                               mcf::FMOVQ => h ("fmovs", r, d);
                               mcf::FNEGQ => h ("fnegs", r, d);
                               mcf::FABSQ => h ("fabss", r, d);
                               _   => {   emit_farith1 a; 
                                          emit "\t"; 
                                          emit_register r; 
                                          emit ", "; 
                                          emit_register d; 
                                      };
                           esac;
                           fi;
                       };
                mcf::FPOP2 { a, 
                             r1, 
                             r2, 
                             d
                           }
                    => {   emit_farith2 a; 
                           emit "\t"; 
                           emit_register r1; 
                           emit ", "; 
                           emit_register r2; 
                           emit ", "; 
                           emit_register d; 
                       };
                mcf::FCMP { cmp, 
                            r1, 
                            r2, 
                            nop
                          }
                    => {   emit_fcmp cmp; 
                           emit "\t"; 
                           emit_register r1; 
                           emit ", "; 
                           emit_register r2; 
                           emit_nop nop; 
                       };
                mcf::SAVE { r, 
                            i, 
                            d
                          }
                    => {   emit "save\t"; 
                           emit_register r; 
                           emit ", "; 
                           emit_operand i; 
                           emit ", "; 
                           emit_register d; 
                       };
                mcf::RESTORE { r, 
                               i, 
                               d
                             }
                    => {   emit "restore\t"; 
                           emit_register r; 
                           emit ", "; 
                           emit_operand i; 
                           emit ", "; 
                           emit_register d; 
                       };
                mcf::RDY { d } => {   emit "rd\t%y, "; 
                                      emit_register d; 
                                  };
                mcf::WRY { r, 
                           i
                         }
                    => {   emit "wr\t"; 
                           emit_register r; 
                           emit ", "; 
                           emit_operand i; 
                           emit ", %y"; 
                       };
                mcf::RET { leaf, 
                           nop
                         }
                    => {   emit "ret"; 
                           emit_leaf leaf; 
                           emit_nop nop; 
                       };
                mcf::SOURCE { } => emit "source";
                mcf::SINK { } => emit "sink";
                mcf::PHI { } => emit "phi";
            esac;
                        tab ();
                        emit_op' instruction;
                        nl ();
                    }						# fun emitter
        
                also
                fun emit_indented_instruction  instruction
                    =
                    {   indent ();
                        emit_op instruction;
                        nl ();
                    }
        
                also
                fun emit_instructions instructions
                    =
                    apply if *indent_copies   emit_indented_instruction;
                          else emit_op;
                          fi
                          instructions
        
                also
                fun emit_op (mcf::NOTE { op, note } )
                        =>
                        {   emit_comment (note::to_string note);
                            nl ();
                            emit_op op;
                        };
        
                    emit_op (mcf::LIVE { regs, spilled } )
                        =>
                        emit_comment("live= " + rkj::cls::codetemplists_to_string regs +
                            "spilled= " + rkj::cls::codetemplists_to_string spilled);
        
                    emit_op (mcf::DEAD { regs, spilled } )
                        =>
                        emit_comment("dead= " + rkj::cls::codetemplists_to_string regs +			# 'dead' here was 'killed' -- is there a critical difference?
                            "spilled= " + rkj::cls::codetemplists_to_string spilled);
        
                    emit_op (mcf::BASE_OP i)
                        =>
                        emitter i;
        
                    emit_op (mcf::COPY { kind=>rkj::INT_REGISTER, size_in_bits, src, dst, tmp } )
                        =>
                        emit_instructions (crm::compile_int_register_moves { tmp, src, dst } );
        
                    emit_op (mcf::COPY { kind=>rkj::FLOAT_REGISTER, size_in_bits, src, dst, tmp } )
                        =>
                        emit_instructions (crm::compile_float_register_moves { tmp, src, dst } );
        
                    emit_op _
                        =>
                        error "emit_op";
                end;
        
                
                {
                  begin_connected_component => init,
                  emit_pseudo_op,
                  emit_op,
                  end_connected_component => fail,
                  define_local_label,
                  define_global_label,
                  emit_comment,
                  end_procedure => do_nothing,
                  put_bblock_note,
                  get_notes
                };
            };										# fun make_stream
        end;										# stipulate
    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.            #
#  ^C @ ^T hides all Text. (Leaves all headings.)                        #
#  ^C @ ^A shows All of file.                                            #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)     #
#  ^C @ ^I shows Immediate children of node.                             #
#  ^C @ ^S Shows all of a node.                                          #
#  ^C @ ^D hiDes all of a node.                                          #
#  ^HFoutline-mode gives more details.                                   #
#  (Or do ^HI and read emacs:outline mode.)                              #
#                                                                        #
# Local variables:                                                       #
# mode: outline-minor                                                    #
# outline-regexp: "[{ \t]*\\(fun \\)"                                    #
# End:                                                                   #
##########################################################################
