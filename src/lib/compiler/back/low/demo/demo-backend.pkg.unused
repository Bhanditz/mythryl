/* 
 * This generic factors out the machine independent part of the register
 * allocator.   This works well for RISC machines; not applicable to intel32.
 */
generic package backend (
    package translate_treecode_to_machcode:  Translate_Treecode_To_Machcode    #  instruction selection 
    package flowgraph:   FLOWGRAPH
    package machcode_universals:   Machcode_Universals
    package asm_emitter: Instruction_Emitter
    package ra:          CLUSTER_OPTIMIZATION
       sharing machcode_universals::I = flowgraph::I = asm_emitter::I = translate_treecode_to_machcode::I 
       sharing asm_emitter::P = flowgraph::P = translate_treecode_to_machcode::T.PseudoOp
       sharing ra::F = flowgraph
  ) : api
         package t:  Treecode
         package c:  Cells
         my coder:  label::label * List( t::statement ) -> Void  
      end
{
   package f      = flowgraph
   package t      = translate_treecode_to_machcode::T
   package i      = f::I
   package c      = i::C
   package stream = t::Stream

   #  Flowgraph generation 
   package flow_graph_g =
       ClusterGen (package flowgraph = F
                  package machcode_universals = machcode_universals
                  package treecode    = translate_treecode_to_machcode::T
                 )

   #  Assembly output 
   package assembler = 
      ClusterEmit (package f = F
                  package e = asm_emitter)

   fun error msg = lowhalf_error_message::error("backend", msg)

   /* How to compile a cluster */ 
   fun compile cluster =
   let cluster = ra::run cluster #  just run register allocation 
   in  assembler::asmEmit cluster    #  And output the assembly 
   end

   fun coder (functionName, treecodeStms) =
   let 
         #  initialize all hidden states first 
          label::reset();  /* okay, just the label counters */ 
       /*
        * Extract the methods from a stream 
        */
       my stream as Stream::STREAM
          { begin_connected_component,  #  start a compilation unit consisting of one connected component of the callgraph.
            end_connected_component,    #  end a compilation unit.
            emit,          #  emit Treecode statement 
            define_local_label,   #  Define a local label 
            define_global_label,    #  Define an external entry 
            end_procedure,     #  mark the end of a procedure 
            pseudoOp,      #  emit a pseudo op 
            annotation,    #  Add an annotation 
            ... } =
            translate_treecode_to_machcode::translate_treecode_to_machcode
                (flow_graph_g::newStream { compile=compile, flowgraph=NULL } )
   in  begin_connected_component 0;      #  start a new cluster 
       define_global_label functionName; #  Define the entry label 
       apply emit treecodeStms; #  emit all the statements 
         #  IMPORTANT: normally you'll have to call the other methods too 
       end_connected_component []        #  end the cluster 
   end 
}
