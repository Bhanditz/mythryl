## translate-machcode-to-execode-intel32-g.codemade.pkg.unused
#
# This file generated at   2011-07-05:01:48:58   by
#
#     src/lib/compiler/back/low/tools/arch/make-sourcecode-for-translate-machcode-to-execode-xxx-g-package.pkg
#
# from the architecture description file
#
#     src/lib/compiler/back/low/intel32/intel32.architecture-description
#
# Edits to this file will be LOST on next system rebuild.


# This file is unused in favor of
#     src/lib/compiler/back/low/intel32/translate-machcode-to-execode-intel32-g.pkg
# -- 2011-04-02 CrT
#
stipulate
    package lbl =  codelabel;							# codelabel			is from   src/lib/compiler/back/low/code/codelabel.pkg
    package lem =  lowhalf_error_message;					# lowhalf_error_message		is from   src/lib/compiler/back/low/control/lowhalf-error-message.pkg
    package rkj =  registerkinds_junk;						# registerkinds_junk		is from   src/lib/compiler/back/low/code/registerkinds-junk.pkg
    package u32 =  unt32;							# unt32				is from   src/lib/std/unt32.pkg
herein

    generic package translate_machcode_to_execode_intel32_g (
        #
        package mcf: Machcode_Intel32;						# Machcode_Intel32		is from   src/lib/compiler/back/low/intel32/code/machcode-intel32.codemade.api
        
        package tce: Treecode_Eval						# Treecode_Eval			is from   src/lib/compiler/back/low/treecode/treecode-eval.api
                     where
                         tcf == mcf::tcf;					# "tcf" == "treecode_form".
        
        package cst: Codestream;						# Codestream			is from   src/lib/compiler/back/low/code/codestream.api
        
        package csb: Code_Segment_Buffer;					# Code_Segment_Buffer		is from   src/lib/compiler/back/low/emit/code-segment-buffer.api
    )
    : (weak) Instruction_Emitter
    {
        									# Instruction_Emitter		is from   src/lib/compiler/back/low/emit/instruction-emitter.api
        # Export to client packages:
        #
        package cst = cst;
        package mcf = mcf;							# "mcf"  == "machcode_form" (abstract machine code).
        
        # Local abbreviations:
        #
        package rgk =  mcf::rgk;							# "rgk" == "registerkinds".
        package lac =  mcf::lac;							# "lac" == "late_constant".
        package csb =  csb;
        package pop =  cst::pop;
        
        # INTEL32 is little endian.
        
        fun error msg
            =
            lem::error ("INTEL32MC", msg);
        fun make_stream _
            =
            {   infix val & | << >> >>> ;
                #
                (<<)  = u32::(<<);
                (>>)  = u32::(>>);
                (>>>) = u32::(>>>);
                (|)   = u32::bitwise_or;
                (&)   = u32::bitwise_and;
        
                fun emit_bool FALSE => 0u0:  u32::Unt;
                    emit_bool TRUE  => 0u1:  u32::Unt;
                end;
        
                emit_int = u32::from_int;
        
                fun emit_word w = w;
                fun emit_label l = u32::from_int (lbl::get_codelabel_address l);
                fun emit_label_expression le = u32::from_int (tce::value_of le);
                fun emit_const lateconst = u32::from_int (lac::late_constant_to_int lateconst);
        
                loc = REF 0;
        
                # Emit a byte:
                #
                fun emit_byte  byte
                    =
                    {   offset = *loc;
                        loc := offset + 1;
                        csb::write_byte_to_code_segment_buffer { offset, byte };
                    };
        
                # Emit the low order byte of a word.
                # Note: from_large_unt strips the high order bits!
                #
                fun emit_byte_w  word
                    =
                    {   offset = *loc;
                        loc := offset + 1; 
                        csb::write_byte_to_code_segment_buffer { offset, byte => unt8::from_large_unt word };
                    };
        
                fun do_nothing _ = ();
                fun fail _ = raise exception FAIL "MCEmitter";
                fun get_notes () = error "get_notes";
        
                fun emit_pseudo_op  pseudo_op
                    =
                    pop::emit_pseudo_op { pseudo_op, loc => *loc, emit_byte };
        
                fun begin_connected_component  size_in_bytes
                    =
                    {    csb::initialize_code_segment_buffer { size_in_bytes };
                         loc := 0;
                    };
        
        

        fun e_word8 w 
            =
            {   b8 = w;

                emit_byte_w b8;
            }

        also
        fun e_word16 w 
            =
            {   b8 = w;
                w = w >> 0ux8;
                b16 = w;

                    {   emit_byte_w b8; 
                        emit_byte_w b16; 
                    };
            }

        also
        fun e_word32 w 
            =
            {   b8 = w;
                w = w >> 0ux8;
                b16 = w;
                w = w >> 0ux8;
                b24 = w;
                w = w >> 0ux8;
                b32 = w;

                    {   emit_byte_w b8; 
                        emit_byte_w b16; 
                        emit_byte_w b24; 
                        emit_byte_w b32; 
                    };
            };

        fun emit_int_register r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun emit_float_register r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun emit_flags_register r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun emit_ram_byte r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun emit_control_dependency r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun emit_eflags r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun emit_fflags r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun emit_registerset r 
            =
            u32::from_int (rkj::hardware_register_id_of r);

        fun emit_cond (mcf::EQ) => (0ux4 : unt32::Unt);
            emit_cond (mcf::NE) => (0ux5 : unt32::Unt);
            emit_cond (mcf::LT) => (0uxC : unt32::Unt);
            emit_cond (mcf::LE) => (0uxE : unt32::Unt);
            emit_cond (mcf::GT) => (0uxF : unt32::Unt);
            emit_cond (mcf::GE) => (0uxD : unt32::Unt);
            emit_cond (mcf::BB) => (0ux2 : unt32::Unt);
            emit_cond (mcf::BE) => (0ux6 : unt32::Unt);
            emit_cond (mcf::AA) => (0ux7 : unt32::Unt);
            emit_cond (mcf::AE) => (0ux3 : unt32::Unt);
            emit_cond (mcf::CC) => (0ux2 : unt32::Unt);
            emit_cond (mcf::NC) => (0ux3 : unt32::Unt);
            emit_cond (mcf::PP) => (0uxA : unt32::Unt);
            emit_cond (mcf::NP) => (0uxB : unt32::Unt);
            emit_cond (mcf::OO) => (0ux0 : unt32::Unt);
            emit_cond (mcf::NO) => (0ux1 : unt32::Unt);
        end

        also
        fun emit_fibin_op (mcf::FIADDS) => (0uxDE, 0);
            emit_fibin_op (mcf::FIMULS) => (0uxDE, 1);
            emit_fibin_op (mcf::FICOMS) => (0uxDE, 2);
            emit_fibin_op (mcf::FICOMPS) => (0uxDE, 3);
            emit_fibin_op (mcf::FISUBS) => (0uxDE, 4);
            emit_fibin_op (mcf::FISUBRS) => (0uxDE, 5);
            emit_fibin_op (mcf::FIDIVS) => (0uxDE, 6);
            emit_fibin_op (mcf::FIDIVRS) => (0uxDE, 7);
            emit_fibin_op (mcf::FIADDL) => (0uxDA, 0);
            emit_fibin_op (mcf::FIMULL) => (0uxDA, 1);
            emit_fibin_op (mcf::FICOML) => (0uxDA, 2);
            emit_fibin_op (mcf::FICOMPL) => (0uxDA, 3);
            emit_fibin_op (mcf::FISUBL) => (0uxDA, 4);
            emit_fibin_op (mcf::FISUBRL) => (0uxDA, 5);
            emit_fibin_op (mcf::FIDIVL) => (0uxDA, 6);
            emit_fibin_op (mcf::FIDIVRL) => (0uxDA, 7);
        end

        also
        fun emit_fun_op (mcf::FCHS) => (0uxE0 : unt32::Unt);
            emit_fun_op (mcf::FABS) => (0uxE1 : unt32::Unt);
            emit_fun_op (mcf::FTST) => (0uxE4 : unt32::Unt);
            emit_fun_op (mcf::FXAM) => (0uxE5 : unt32::Unt);
            emit_fun_op (mcf::FPTAN) => (0uxF2 : unt32::Unt);
            emit_fun_op (mcf::FPATAN) => (0uxF3 : unt32::Unt);
            emit_fun_op (mcf::FXTRACT) => (0uxF4 : unt32::Unt);
            emit_fun_op (mcf::FPREM1) => (0uxF5 : unt32::Unt);
            emit_fun_op (mcf::FDECSTP) => (0uxF6 : unt32::Unt);
            emit_fun_op (mcf::FINCSTP) => (0uxF7 : unt32::Unt);
            emit_fun_op (mcf::FPREM) => (0uxF8 : unt32::Unt);
            emit_fun_op (mcf::FYL2XP1) => (0uxF9 : unt32::Unt);
            emit_fun_op (mcf::FSQRT) => (0uxFA : unt32::Unt);
            emit_fun_op (mcf::FSINCOS) => (0uxFB : unt32::Unt);
            emit_fun_op (mcf::FRNDINT) => (0uxFC : unt32::Unt);
            emit_fun_op (mcf::FSCALE) => (0uxFD : unt32::Unt);
            emit_fun_op (mcf::FSIN) => (0uxFE : unt32::Unt);
            emit_fun_op (mcf::FCOS) => (0uxFF : unt32::Unt);
        end;

        fun modrm { mod, 
                    reg, 
                    rm
                  }

            =
            e_word8 (((%) << 0ux6) + ((reg << 0ux3) + rm))

        also
        fun reg { opc, 
                  reg
                }

            =
            e_word8 ((opc << 0ux3) + reg)

        also
        fun sib { ss, 
                  index, 
                  base
                }

            =
            e_word8 ((ss << 0ux6) + ((index << 0ux3) + base))

        also
        fun immed8 { imm } 
            =
            e_word8 imm

        also
        fun immed32 { imm } 
            =
            e_word32 imm

        also
        fun immedopnd { opnd } 
            =
            case opnd
                #
                mcf::IMMED i32 => i32;
                mcf::IMMEDLABEL le => lexp le;
                mcf::LABELEA le => lexp le;
                _   => error "immedOpnd";
            esac

        also
        fun extension { opc, 
                        opnd
                      }

            =
            case opnd
                #
                mcf::DIRECT r => modrm { mod => 3, 
                                         reg => opc, 
                                         rm => r
                                       }
;
                mcf::RAMREG _ => extension { opc, 
                                             opnd => ramreg opnd
                                           }
;
                mcf::FDIRECT _ => extension { opc, 
                                              opnd => ramreg opnd
                                            }
;
                mcf::DISPLACE { base, 
                                disp, 
                                ...
                              }
                    => {   
###line 740.8 "src/lib/compiler/back/low/intel32/intel32.architecture-description"
                           immed = immedopnd { opnd => disp };

                           (   );
                       };
                mcf::INDEXED { base => NULL, 
                               index, 
                               scale, 
                               disp, 
                               ...
                             }
                    => ();
                mcf::INDEXED { base => THE b, 
                               index, 
                               scale, 
                               disp, 
                               ...
                             }
                    => ();
                _   => error "immedExt";
            esac

        also
        fun encodest { prefix, 
                       opc, 
                       st
                     }

            =
            {   st = emit_float_register st;

                e_word16 ((prefix << 0ux8) + ((opc << 0ux3) + st));
            }

        also
        fun encodereg { prefix, 
                        reg, 
                        opnd
                      }

            =
            {   reg = emit_int_register reg;

                    {   emit prefix; 
                        immedext { opc => reg, 
                                   opnd
                                 }
; 
                    };
            }

        also
        fun arith { opc1, 
                    opc2, 
                    src, 
                    dst
                  }

            =
            case (src, dst)
                #
                (mcf::IMMEDLABEL le, dst) => arith { opc1, 
                                                     opc2, 
                                                     src => mcf::Immed (lexp le), 
                                                     dst
                                                   }
;
                (mcf::LABELEA le, dst) => arith { opc1, 
                                                  opc2, 
                                                  src => mcf::Immed (lexp le), 
                                                  dst
                                                }
;
                (mcf::IMMED i, dst) => ();
                (src, mcf::DIRECT r) => encodereg { prefix => opc1 + op3, 
                                                    reg, 
                                                    opnd => src
                                                  }
;
                (mcf::DIRECT r, dst) => encodereg { prefix => opc1 + 0ux1, 
                                                    reg, 
                                                    opnd => dst
                                                  }
;
                _   => error "arith";
            esac;
            fun emitter instruction
                =
                {

        fun emit_op (mcf::NOP) => error "NOP";
            emit_op (mcf::JMP (operand, list)) => error "JMP";
            emit_op (mcf::JCC { cond, 
                                operand
                              }
            )   => error "JCC";
            emit_op (mcf::CALL { operand, 
                                 defs, 
                                 uses, 
                                 return, 
                                 cuts_to, 
                                 ramregion, 
                                 pops
                               }
            )   => error "CALL";
            emit_op (mcf::ENTER { src1, 
                                  src2
                                }
            )   => error "ENTER";
            emit_op (mcf::LEAVE) => error "LEAVE";
            emit_op (mcf::RET option) => error "RET";
            emit_op (mcf::MOVE { mv_op, 
                                 src, 
                                 dst
                               }
            )   => error "MOVE";
            emit_op (mcf::LEA { r32, 
                                address
                              }
            )   => error "LEA";
            emit_op (mcf::CMPL { lsrc, 
                                 rsrc
                               }
            )   => error "CMPL";
            emit_op (mcf::CMPW { lsrc, 
                                 rsrc
                               }
            )   => error "CMPW";
            emit_op (mcf::CMPB { lsrc, 
                                 rsrc
                               }
            )   => error "CMPB";
            emit_op (mcf::TESTL { lsrc, 
                                  rsrc
                                }
            )   => error "TESTL";
            emit_op (mcf::TESTW { lsrc, 
                                  rsrc
                                }
            )   => error "TESTW";
            emit_op (mcf::TESTB { lsrc, 
                                  rsrc
                                }
            )   => error "TESTB";
            emit_op (mcf::BITOP { bit_op, 
                                  lsrc, 
                                  rsrc
                                }
            )   => error "BITOP";
            emit_op (mcf::BINARY { bin_op, 
                                   src, 
                                   dst
                                 }
            )   => error "BINARY";
            emit_op (mcf::SHIFT { shift_op, 
                                  src, 
                                  dst, 
                                  count
                                }
            )   => error "SHIFT";
            emit_op (mcf::CMPXCHG { lock, 
                                    size, 
                                    src, 
                                    dst
                                  }
            )   => error "CMPXCHG";
            emit_op (mcf::MULTDIV { mult_div_op, 
                                    src
                                  }
            )   => error "MULTDIV";
            emit_op (mcf::MUL3 { dst, 
                                 src2, 
                                 src1
                               }
            )   => error "MUL3";
            emit_op (mcf::UNARY { un_op, 
                                  operand
                                }
            )   => error "UNARY";
            emit_op (mcf::SET { cond, 
                                operand
                              }
            )   => error "SET";
            emit_op (mcf::CMOV { cond, 
                                 src, 
                                 dst
                               }
            )   => error "CMOV";
            emit_op (mcf::PUSHL operand) => error "PUSHL";
            emit_op (mcf::PUSHW operand) => error "PUSHW";
            emit_op (mcf::PUSHB operand) => error "PUSHB";
            emit_op (mcf::PUSHFD) => error "PUSHFD";
            emit_op (mcf::POPFD) => error "POPFD";
            emit_op (mcf::POP operand) => error "POP";
            emit_op (mcf::CDQ) => error "CDQ";
            emit_op (mcf::INTO) => error "INTO";
            emit_op (mcf::FBINARY { bin_op, 
                                    src, 
                                    dst
                                  }
            )   => error "FBINARY";
            emit_op (mcf::FIBINARY { bin_op, 
                                     src
                                   }
            )   => error "FIBINARY";
            emit_op (mcf::FUNARY fun_op) => error "FUNARY";
            emit_op (mcf::FUCOM operand) => error "FUCOM";
            emit_op (mcf::FUCOMP operand) => error "FUCOMP";
            emit_op (mcf::FUCOMPP) => error "FUCOMPP";
            emit_op (mcf::FCOMPP) => error "FCOMPP";
            emit_op (mcf::FCOMI operand) => error "FCOMI";
            emit_op (mcf::FCOMIP operand) => error "FCOMIP";
            emit_op (mcf::FUCOMI operand) => error "FUCOMI";
            emit_op (mcf::FUCOMIP operand) => error "FUCOMIP";
            emit_op (mcf::FXCH { operand }) => error "FXCH";
            emit_op (mcf::FSTPL operand) => error "FSTPL";
            emit_op (mcf::FSTPS operand) => error "FSTPS";
            emit_op (mcf::FSTPT operand) => error "FSTPT";
            emit_op (mcf::FSTL operand) => error "FSTL";
            emit_op (mcf::FSTS operand) => error "FSTS";
            emit_op (mcf::FLD1) => error "FLD1";
            emit_op (mcf::FLDL2E) => error "FLDL2E";
            emit_op (mcf::FLDL2T) => error "FLDL2T";
            emit_op (mcf::FLDLG2) => error "FLDLG2";
            emit_op (mcf::FLDLN2) => error "FLDLN2";
            emit_op (mcf::FLDPI) => error "FLDPI";
            emit_op (mcf::FLDZ) => error "FLDZ";
            emit_op (mcf::FLDL operand) => error "FLDL";
            emit_op (mcf::FLDS operand) => error "FLDS";
            emit_op (mcf::FLDT operand) => error "FLDT";
            emit_op (mcf::FILD operand) => error "FILD";
            emit_op (mcf::FILDL operand) => error "FILDL";
            emit_op (mcf::FILDLL operand) => error "FILDLL";
            emit_op (mcf::FNSTSW) => error "FNSTSW";
            emit_op (mcf::FENV { fenv_op, 
                                 operand
                               }
            )   => error "FENV";
            emit_op (mcf::FMOVE { fsize, 
                                  src, 
                                  dst
                                }
            )   => error "FMOVE";
            emit_op (mcf::FILOAD { isize, 
                                   ea, 
                                   dst
                                 }
            )   => error "FILOAD";
            emit_op (mcf::FBINOP { fsize, 
                                   bin_op, 
                                   lsrc, 
                                   rsrc, 
                                   dst
                                 }
            )   => error "FBINOP";
            emit_op (mcf::FIBINOP { isize, 
                                    bin_op, 
                                    lsrc, 
                                    rsrc, 
                                    dst
                                  }
            )   => error "FIBINOP";
            emit_op (mcf::FUNOP { fsize, 
                                  un_op, 
                                  src, 
                                  dst
                                }
            )   => error "FUNOP";
            emit_op (mcf::FCMP { i, 
                                 fsize, 
                                 lsrc, 
                                 rsrc
                               }
            )   => error "FCMP";
            emit_op (mcf::SAHF) => error "SAHF";
            emit_op (mcf::LAHF) => error "LAHF";
            emit_op (mcf::SOURCE { }) => ();
            emit_op (mcf::SINK { }) => ();
            emit_op (mcf::PHI { }) => ();
        end;
        
                emit_op instruction;
            };
        
        fun emit_op (mcf::NOTE { op, ... } ) =>  emit_op  op;
            emit_op (mcf::BASE_OP i) => emitter i;
            emit_op (mcf::LIVE _)  => ();
            emit_op (mcf::DEAD _)  => ();
            emit_op _ => error "emit_op";
        end;
        
         { begin_connected_component, 
           emit_pseudo_op, 
           emit_op, 
           end_connected_component=>fail, 
           emit_private_label=>do_nothing, 
           emit_public_label=>do_nothing, 
           emit_comment=>do_nothing, 
           emit__end_of_fn__mark=>do_nothing, 
           emit_bblock_note=>do_nothing, 
           get_notes
         };
        };
    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.            #
#  ^C @ ^T hides all Text. (Leaves all headings.)                        #
#  ^C @ ^A shows All of file.                                            #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)     #
#  ^C @ ^I shows Immediate children of node.                             #
#  ^C @ ^S Shows all of a node.                                          #
#  ^C @ ^D hiDes all of a node.                                          #
#  ^HFoutline-mode gives more details.                                   #
#  (Or do ^HI and read emacs:outline mode.)                              #
#                                                                        #
# Local variables:                                                       #
# mode: outline-minor                                                    #
# outline-regexp: "[{ \t]*\\(fun \\)"                                    #
# End:                                                                   #
##########################################################################
