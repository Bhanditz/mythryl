## peephole-intel32-g.pkg
#
# I can find no other reference in the codebase to   
#
#    src/lib/compiler/back/low/intel32/code/peephole-intel32-g.pkg
#
# -- presumably this file is not actually used.  -- 2011-05-23 CrT

# Compiled by:
#     src/lib/compiler/back/low/lib/intel32-peephole.lib

# WARNING: this is generated by running 'nowhere intel32Peephole.peep'.
# Do not edit this file directly.
# Version 1.2.2

# Compiled by:
#     src/lib/compiler/back/low/lib/intel32-peephole.lib


###line 20.1 "intel32Peephole::peep"
generic package peephole_intel32_g (
###line 21.5 "intel32Peephole::peep"
                    package mcf: Machcode_Intel32;					# Machcode_Intel32		is from   src/lib/compiler/back/low/intel32/code/machcode-intel32.codemade.api

###line 22.5 "intel32Peephole::peep"
                    package tce:  Treecode_Eval;					# Treecode_Eval			is from   src/lib/compiler/back/low/treecode/treecode-eval.api

###line 23.7 "intel32Peephole::peep"
                    sharing mcf::tcf == tce::tcf;
)

: (weak) Peephole									# Peephole			is from   src/lib/compiler/back/low/code/peephole.api

{
  
###line 26.4 "intel32Peephole::peep"
   package mcf= mcf;
   package registerkinds  = mcf::rgk;							# "rgk" == "registerkinds".


###line 27.4 "intel32Peephole::peep"
   package rgk = registerkinds;

###line 28.4 "intel32Peephole::peep"
   package rkj =  registerkinds_junk;							# registerkinds_junk	is from   src/lib/compiler/back/low/code/registerkinds-junk.pkg

###line 31.4 "intel32Peephole::peep"
   fun peephole instrs = 
       { 
###line 32.8 "intel32Peephole::peep"
           fun is_stack_ptr (mcf::DIRECT r) => rkj::codetemps_are_same_color (r, rgk::esp);
               is_stack_ptr _ => FALSE;
           end;

###line 35.8 "intel32Peephole::peep"
           fun is_zero_le le = (((tce::value_of le) == 0) except _ = FALSE);

###line 37.8 "intel32Peephole::peep"
           fun is_zero (mcf::IMMED n)   =>   n == 0;
               is_zero (mcf::IMMED_LABEL le) => is_zero_le le;
               is_zero _ => FALSE;
           end;

###line 41.8 "intel32Peephole::peep"
           fun is_zero_opt NULL => TRUE;
               is_zero_opt (THE opn) => is_zero opn;
           end;

###line 44.8 "intel32Peephole::peep"
           fun loop (code, instrs) = 
               { v_34 = code;
                   fun state_9 (v_0, v_3) = 
                       { i = v_0;
                         rest = v_3;
                        loop (rest, i ! instrs);
                       };
                   fun state_22 (v_0, v_17, v_3) = 
                       { le = v_17;
                         rest = v_3;
                        (if ((is_zero_le le))
                                  (loop (rest, instrs));
                             else (state_9 (v_0, v_3));fi);
                       };
                   fun state_51 (v_0, v_1, v_2, v_3) = 
                       (case v_1   
                         mcf::DIRECT v_26 => 
                         { dst = v_1;
                           rest = v_3;
                           src = v_2;
                          (if ((is_zero src))
                                    (loop (rest, (mcf::binary { bin_op=>mcf::XORL, src=>dst, dst } ) ! instrs));
                               else (state_9 (v_0, v_3));fi);
                         };
                        _ => state_9 (v_0, v_3); esac
                       );
                
                  (case v_34   
                    (!) v_33 => 
                    { my (v_0, v_3) = v_33;
                     
                       (case v_0   
                         mcf::BASE_OP v_32 => 
                         (case v_32   
                           mcf::BINARY v_19 => 
                           { my { bin_op=>v_31, dst=>v_1, src=>v_2, ... } = v_19;
                            
                              (case v_31   
                                mcf::ADDL => 
                                (case v_2   
                                  mcf::IMMED v_17 => 
                                  (case v_1   
                                    mcf::DIRECT v_26 => 
                                    (case v_3   
                                      (!) v_14 => 
                                      { my (v_13, v_4) = v_14;
                                       
                                         (case v_13   
                                           mcf::BASE_OP v_12 => 
                                           (case v_12   
                                             mcf::BINARY v_11 => 
                                             { my { bin_op=>v_10, dst=>v_9, src=>v_8, ... } = v_11;
                                              
                                                (case v_10   
                                                  mcf::SUBL => 
                                                  (case v_9   
                                                    mcf::DIRECT v_5 => 
                                                    (case v_8   
                                                      mcf::IMMED v_7 => 
                                                      { d_i = v_26;
                                                          d_j = v_5;
                                                          m = v_7;
                                                          n = v_17;
                                                          rest = v_4;
                                                       (if (((rkj::codetemps_are_same_color (d_i, rgk::esp)) and (rkj::codetemps_are_same_color (d_j, rgk::esp))))
                                                                 (if ((m == n))
                                                                    (loop (rest, instrs));
                                                               else (if ((m < n))
                                                                       (loop (rest, (mcf::binary { bin_op=>mcf::ADDL, src=>mcf::IMMED (n - m), dst=>mcf::DIRECT rgk::esp } ) ! instrs));
                                                                  else (loop (rest, (mcf::binary { bin_op=>mcf::SUBL, src=>mcf::IMMED (m - n), dst=>mcf::DIRECT rgk::esp } ) ! instrs));fi);fi);
                                                            else (state_9 (v_0, v_3));fi);
                                                      };
                                                     _ => state_9 (v_0, v_3); esac
                                                    );
                                                   _ => state_9 (v_0, v_3); esac
                                                  );
                                                 _ => state_9 (v_0, v_3); esac
                                                );
                                             };
                                            _ => state_9 (v_0, v_3); esac
                                           );
                                          _ => state_9 (v_0, v_3); esac
                                         );
                                      };
                                     NIL => state_9 (v_0, v_3); esac
                                    );
                                   _ => state_9 (v_0, v_3); esac
                                  );
                                 mcf::IMMED_LABEL v_17 => state_22 (v_0, v_17, v_3);
                                 _ => state_9 (v_0, v_3); esac
                                );
                               mcf::SUBL => 
                                (case v_2   
                                  mcf::IMMED v_17 => 
                                  (case v_1   
                                    mcf::DIRECT v_26 => 
                                    (case v_17   
                                      4 => 
                                      (case v_3   
                                        (!) v_14 => 
                                        { my (v_13, v_4) = v_14;
                                         
                                           (case v_13   
                                             mcf::BASE_OP v_12 => 
                                             (case v_12   
                                               mcf::MOVE v_11 => 
                                               { my { dst=>v_9, mv_op=>v_28, src=>v_8, ... } = v_11;
                                                
                                                  (case v_9   
                                                    mcf::DISPLACE v_5 => 
                                                    { my { base=>v_27, disp=>v_30, ... } = v_5;
                                                     
                                                       (case v_30   
                                                         mcf::IMMED v_29 => 
                                                         (case v_29   
                                                           0 => 
                                                           (case v_28   
                                                             mcf::MOVL => 
                                                             { base = v_27;
                                                                 dst_i = v_26;
                                                                 rest = v_4;
                                                                 src = v_8;
                                                              (if ((((rkj::codetemps_are_same_color (base, rgk::esp)) and (rkj::codetemps_are_same_color (dst_i, rgk::esp))) and (not (is_stack_ptr src))))
                                                                        (loop (rest, (mcf::pushl src) ! instrs));
                                                                   else (state_9 (v_0, v_3));fi);
                                                             };
                                                            _ => state_9 (v_0, v_3); esac
                                                           );
                                                          _ => state_9 (v_0, v_3); esac
                                                         );
                                                        _ => state_9 (v_0, v_3); esac
                                                       );
                                                    };
                                                   _ => state_9 (v_0, v_3); esac
                                                  );
                                               };
                                              _ => state_9 (v_0, v_3); esac
                                             );
                                            _ => state_9 (v_0, v_3); esac
                                           );
                                        };
                                       NIL => state_9 (v_0, v_3); esac
                                      );
                                     _ => state_9 (v_0, v_3); esac
                                    );
                                   _ => state_9 (v_0, v_3); esac
                                  );
                                 mcf::IMMED_LABEL v_17 => state_22 (v_0, v_17, v_3);
                                 _ => state_9 (v_0, v_3); esac
                                );
                               _ => state_9 (v_0, v_3); esac
                              );
                           };
                          mcf::LEA v_19 => 
                           { my { address=>v_25, r32=>v_20, ... } = v_19;
                            
                              (case v_25   
                                mcf::DISPLACE v_24 => 
                                { my { base=>v_22, disp=>v_23, ... } = v_24;
                                 
                                   (case v_23   
                                     mcf::IMMED_LABEL v_21 => 
                                     { base = v_22;
                                         le = v_21;
                                         r32 = v_20;
                                         rest = v_3;
                                      (if (((is_zero_le le) and (rkj::codetemps_are_same_color (r32, base))))
                                                (loop (rest, instrs));
                                           else (state_9 (v_0, v_3));fi);
                                     };
                                    _ => state_9 (v_0, v_3); esac
                                   );
                                };
                               _ => state_9 (v_0, v_3); esac
                              );
                           };
                          mcf::MOVE v_19 => 
                           { my { dst=>v_1, mv_op=>v_18, src=>v_2, ... } = v_19;
                            
                              (case v_18   
                                mcf::MOVL => 
                                (case v_2   
                                  mcf::DISPLACE v_17 => 
                                  { my { base=>v_6, disp=>v_16, ... } = v_17;
                                   
                                     (case v_16   
                                       mcf::IMMED v_15 => 
                                       (case v_15   
                                         0 => 
                                         (case v_3   
                                           (!) v_14 => 
                                           { my (v_13, v_4) = v_14;
                                            
                                              (case v_13   
                                                mcf::BASE_OP v_12 => 
                                                (case v_12   
                                                  mcf::BINARY v_11 => 
                                                  { my { bin_op=>v_10, dst=>v_9, src=>v_8, ... } = v_11;
                                                   
                                                     (case v_10   
                                                       mcf::ADDL => 
                                                       (case v_9   
                                                         mcf::DIRECT v_5 => 
                                                         (case v_8   
                                                           mcf::IMMED v_7 => 
                                                           (case v_7   
                                                             4 => 
                                                             { base = v_6;
                                                                 dst = v_1;
                                                                 dst_i = v_5;
                                                                 rest = v_4;
                                                              (if ((((rkj::codetemps_are_same_color (base, rgk::esp)) and (rkj::codetemps_are_same_color (dst_i, rgk::esp))) and (not (is_stack_ptr dst))))
                                                                        (loop (rest, (mcf::pop dst) ! instrs));
                                                                   else (state_51 (v_0, v_1, v_2, v_3));fi);
                                                             };
                                                            _ => state_51 (v_0, v_1, v_2, v_3); esac
                                                           );
                                                          _ => state_51 (v_0, v_1, v_2, v_3); esac
                                                         );
                                                        _ => state_51 (v_0, v_1, v_2, v_3); esac
                                                       );
                                                      _ => state_51 (v_0, v_1, v_2, v_3); esac
                                                     );
                                                  };
                                                 _ => state_51 (v_0, v_1, v_2, v_3); esac
                                                );
                                               _ => state_51 (v_0, v_1, v_2, v_3); esac
                                              );
                                           };
                                          NIL => state_51 (v_0, v_1, v_2, v_3); esac
                                         );
                                        _ => state_51 (v_0, v_1, v_2, v_3); esac
                                       );
                                      _ => state_51 (v_0, v_1, v_2, v_3); esac
                                     );
                                  };
                                 _ => state_51 (v_0, v_1, v_2, v_3); esac
                                );
                               _ => state_9 (v_0, v_3); esac
                              );
                           };
                          _ => state_9 (v_0, v_3); esac
                         );
                        _ => state_9 (v_0, v_3); esac
                       );
                    };
                   NIL => instrs; esac
                  );
               };
        loop (instrs, []);
       };
};

