## old-pp.pkg
#
# An implementation of the Lib7's pp interface.

# Compiled by:
#     src/lib/c-kit/src/parser/c-parser.sublib




###                           "I have had my results for a long time:
###                            but I do not yet know how I am to arrive at them."
###
###                                              --Carl Friedrich Gauss



api Old_Prettyprint {

    Ppstream;

    Prettyprint_Consumer
        =
        { consumer:  String -> Void,
	  linewidth:  Int,
	  flush:  Void -> Void,
	  close:  Void -> Void
        };

    Break_Style
        =
        CONSISTENT | INCONSISTENT;

    exception PP_FAIL  String;

    make_ppstream:	Prettyprint_Consumer -> Ppstream;
    dest_ppstream:	Ppstream -> Prettyprint_Consumer;
    add_break:	 	Ppstream -> (Int, Int) -> Void;
    add_newline:	Ppstream -> Void;
    add_string:		Ppstream -> String -> Void;
    begin_block:	Ppstream -> Break_Style -> Int -> Void;
    end_block:		Ppstream -> Void;
    clear_ppstream:	Ppstream -> Void;
    flush_ppstream:	Ppstream -> Void;

    with_prettyprinter:	 Prettyprint_Consumer -> (Ppstream -> Void) -> Void;
    prettyprint_to_string:	 Int -> (Ppstream -> X -> Void) -> X -> String;

};

package old_prettyprint
:       Old_Prettyprint							# Old_Prettyprint	is from   src/lib/c-kit/src/parser/stuff/old-pp.pkg
{
    Prettyprint_Consumer
      =
      { consumer:   String -> Void,
	linewidth:  Int,
	flush:      Void -> Void,
	close:      Void -> Void
      };

   package out								# "out" == "prettyprinter output stream"
	=
	package {
	    Prettyprinter_Output_Stream = Prettyprint_Consumer;
	    Textstyle = Void;
	    fun same_textstyle _ = TRUE;
	    fun push_textstyle _ = ();
	    fun pop_textstyle _ = ();
	    fun default_textstyle _ = ();
	    fun depth _ = NULL;
	    fun line_width { consumer, linewidth, flush, close } = THE linewidth;
	    fun text_width _ = NULL;
	    fun space ( { consumer, linewidth, flush, close }, n) =
		  consumer (number_string::pad_left ' ' n "");
	    fun newline { consumer, linewidth, flush, close } = consumer "\n";
	    fun string ( { consumer, linewidth, flush, close }, s) = consumer s;
	    fun char ( { consumer, linewidth, flush, close }, c) = consumer (str c);
	    fun flush { consumer, linewidth, flush, close } = flush();
	    fun close { consumer, linewidth, flush, close } = close();
	};

    package pp
        =
        prettyprinter_g (					# prettyprinter_g	is from   src/lib/prettyprint/big/src/prettyprinter-g.pkg
            package ss  = unstyled_string;			# unstyled_string	is from   src/lib/prettyprint/big/src/unstyled-string.pkg
            package out = out;
        );

    Ppstream
        =
        STRM  {   consumer:  Prettyprint_Consumer,
	           stream:   pp::Prettyprinter
              };


    Break_Style
        =
        CONSISTENT | INCONSISTENT;


    exception PP_FAIL  String;


    fun make_ppstream  output_stream
  	=
        STRM {
	  consumer =>  output_stream,
	  stream   =>  pp::make_prettyprinter  output_stream
	};


    fun dest_ppstream (STRM { consumer, ... } )
        =
        consumer;


    fun add_break (STRM { stream, ... } ) (spaces, indent_on_wrap)
        =
	pp::break stream { spaces, indent_on_wrap };

    fun add_newline (STRM { stream, ... } )   =   pp::newline stream;
    fun add_string  (STRM { stream, ... } ) s =   pp::string  stream  s;


    fun begin_block (STRM { stream, ... } ) CONSISTENT indent
            =>
	    pp::begin_indented_align_box stream (pp::CURSOR_RELATIVE indent);
        begin_block (STRM { stream, ... } ) INCONSISTENT indent
            =>
	    pp::begin_indented_wrap_box stream (pp::CURSOR_RELATIVE indent);
    end;


    fun end_block (STRM { stream, ... } )
        =
        pp::end_box stream;


    fun clear_ppstream (STRM { stream, ... } )
        =
	raise exception FAIL "clear_ppstream not implemented";


    fun flush_ppstream (STRM { stream, ... } )
        =
        pp::flush_prettyprinter stream;


    fun with_prettyprinter output_stream f
        =
        {   (make_ppstream output_stream) ->   (prettyprinter as (STRM { stream, ... } ));
	    #
	    f  prettyprinter;

	    pp::close_prettyprinter  stream;
	};


    fun prettyprint_to_string  wid  prettyprint_fn  chunk
        =
        {   l =  REF ([] : List( String ));
	    #
	    fun attach s
                =
                l :=  s ! *l;

	    with_prettyprinter
                {
		  consumer  =>  attach,
		  linewidth =>  wid,
		  flush     =>  fn ()=(),
		  close     =>  fn ()=()
	        }
                (fn prettyprinter =  prettyprint_fn  prettyprinter  chunk);

	    string::cat (list::reverse *l);
	};

};



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1998 Bell Labs, Lucent Technologies.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
