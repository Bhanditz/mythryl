## old-pp.pkg
#
# An implementation of the Lib7's pp interface.

# Compiled by:
#     src/lib/c-kit/src/parser/c-parser.sublib




###                           "I have had my results for a long time:
###                            but I do not yet know how I am to arrive at them."
###
###                                              --Carl Friedrich Gauss



api Old_Prettyprint {

    Ppstream;

    Prettyprint_Consumer
        =
        { consumer:  String -> Void,
	  flush:  Void -> Void,
	  close:  Void -> Void
        };

    Break_Style
        =
        CONSISTENT | INCONSISTENT;

    exception PP_FAIL  String;

    make_ppstream:	Prettyprint_Consumer -> Ppstream;
    dest_ppstream:	Ppstream -> Prettyprint_Consumer;
    add_break:	 	Ppstream -> (Int, Int) -> Void;
    add_newline:	Ppstream -> Void;
    add_string:		Ppstream -> String -> Void;
    begin_block:	Ppstream -> Break_Style -> Int -> Void;
    end_block:		Ppstream -> Void;
    clear_ppstream:	Ppstream -> Void;
    flush_ppstream:	Ppstream -> Void;

    with_prettyprinter:	 Prettyprint_Consumer -> (Ppstream -> Void) -> Void;
    prettyprint_to_string:  (Ppstream -> Void) -> String;

};

package old_prettyprint
:       Old_Prettyprint							# Old_Prettyprint	is from   src/lib/c-kit/src/parser/stuff/old-pp.pkg
{
    Prettyprint_Consumer
      =
      { consumer:   String -> Void,
	flush:      Void -> Void,
	close:      Void -> Void
      };

   package out								# "out" == "prettyprinter output stream"
	=
	package {
	    Prettyprinter_Output_Stream = Prettyprint_Consumer;
	    Textstyle = Void;
	    #
	    fun same_textstyle    _ =  TRUE;
	    fun push_textstyle    _ =  ();
	    fun pop_textstyle     _ =  ();
	    fun default_textstyle _ =  ();
	    fun depth             _ =  NULL;
	    fun text_width        _ =  NULL;
	    #
	    fun space  ( { consumer, flush, close }, n) =  consumer (number_string::pad_left ' ' n "");
	    fun newline  { consumer, flush, close }     =  consumer "\n";
	    fun string ( { consumer, flush, close }, s) =  consumer s;
	    fun char   ( { consumer, flush, close }, c) =  consumer (str c);
	    fun flush    { consumer, flush, close }     =  flush();
	    fun close    { consumer, flush, close }     =  close();
	};

    package pp
        =
        prettyprinter_g (					# prettyprinter_g	is from   src/lib/prettyprint/big/src/prettyprinter-g.pkg
            package ss  = unstyled_string;			# unstyled_string	is from   src/lib/prettyprint/big/src/unstyled-string.pkg
            package out = out;
        );

    Ppstream
        =
        STRM  { consumer:	Prettyprint_Consumer,
	        pp:		pp::Prettyprinter
              };


    Break_Style
        =
        CONSISTENT | INCONSISTENT;


    exception PP_FAIL  String;


    fun make_ppstream  output_stream
  	=
        STRM {
	  consumer =>  output_stream,
	  pp       =>  pp::make_prettyprinter  output_stream  []
	};


    fun dest_ppstream (STRM { consumer, ... } )
        =
        consumer;


    fun add_break (STRM { pp, ... } ) (spaces, indent_on_wrap)
        =
	pp::break pp { spaces, indent_on_wrap };

    fun add_newline (STRM { pp, ... } )   =   pp::newline pp;
    fun add_string  (STRM { pp, ... } ) s =   pp::string  pp  s;


    fun begin_block (STRM { pp, ... } ) CONSISTENT indent
            =>
	    pp::begin_indented_align_box  pp  (pp::CURSOR_RELATIVE indent);

        begin_block (STRM { pp, ... } ) INCONSISTENT indent
            =>
	    pp::begin_indented_wrap_box  pp  (pp::CURSOR_RELATIVE indent);
    end;


    fun end_block (STRM { pp, ... } )
        =
        pp::end_box pp;


    fun clear_ppstream (STRM { pp, ... } )
        =
	raise exception FAIL "clear_ppstream not implemented";


    fun flush_ppstream (STRM { pp, ... } )
        =
        pp::flush_prettyprinter  pp;


    fun with_prettyprinter output_stream f
        =
        {   (make_ppstream output_stream) ->   (prettyprinter as (STRM { pp, ... } ));
	    #
	    f  prettyprinter;

	    pp::close_prettyprinter  pp;
	};


    fun prettyprint_to_string  prettyprint_fn
        =
        {   l =  REF ([] : List( String ));
	    #
	    fun consumer s
                =
                l :=  s ! *l;

	    with_prettyprinter
	      {
		consumer,
		flush     =>  fn ()=(),
		close     =>  fn ()=()
	      }
	      prettyprint_fn;

	    string::cat (list::reverse *l);
	};

};



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1998 Bell Labs, Lucent Technologies.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
