## checkbutton.pkg
#
# See also:
#     src/lib/x-kit/widget/leaf/arrowbutton.pkg
#     src/lib/x-kit/widget/leaf/diamondbutton.pkg
#     src/lib/x-kit/widget/leaf/roundbutton.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib





# This package gets used in:
#
#     

stipulate
    include package   threadkit;						# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    include package   geometry2d;						# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    #
#   package xc  =  xclient;							# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
    #
#   package d3  =  three_d;							# three_d			is from   src/lib/x-kit/widget/old/lib/three-d.pkg

    package gt  =  guiboss_types;						# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
    package evt =  gui_event_types;						# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
#   package b2g =  guiboss_to_gadget;						# guiboss_to_gadget		is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg
#   package g2g =  gadget_to_guiboss;						# gadget_to_guiboss		is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
    package g2p =  gadget_to_pixmap;						# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg
    package gd  =  gui_displaylist;						# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    package gt  =  guiboss_types;						# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
    package pt  =  widget_theme;						# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg
    package r8  =  rgb8;							# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;								# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package w2p =  widget_to_widgetspace;					# widget_to_widgetspace		is from   src/lib/x-kit/widget/space/widget/look-to-widget.pkg
    package wi  =  widget_imp;							# widget_imp			is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
    package g2d =  geometry2d;							# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package mtx =  rw_matrix;							# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
    package gws =  guiboss_to_windowsystem;					# guiboss_to_windowsystem	is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg

    package iul =  issue_unique_look_id;					# issue_unique_look_id		is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    nb =  log::note_on_stderr;							# log				is from   src/lib/std/src/log.pkg
herein

    package checkbutton
    :	    Checkbutton								# Checkbutton			is from   src/lib/x-kit/widget/leaf/checkbutton.api
    {
	package t {								# "t" for "type"
	    #
	    Button_Type		= MOMENTARY_CONTACT
				| PUSH_ON_PUSH_OFF
				;
	};

	Button_Appearance_Fn_Arg
	  =
	  { frame_number:		Int,
	    site:			g2d::Box,
	    state:			Bool,
	    type:			t::Button_Type,
	    relief:			pt::Relief,
	    mode:			gt::Gadget_Mode				# Whether gadget has mouse focus etc.
	  };

	Button_Appearance_Fn
	  =
	  { last:			Button_Appearance_Fn_Arg,
	    this:			Button_Appearance_Fn_Arg,
	    theme:			pt::Widget_Theme
	  }
	  ->
	  { displaylist:	gd::Gui_Displaylist,
	    point_in_gadget:	Null_Or(g2d::Point -> Bool)			# 
	  }
	  ;

	App_To_Checkbutton
	  =
	  { set_active_to:		Bool -> Void,
	    set_state_to:		Bool -> Void,
	    #
	    get_active:			Void -> Bool,
	    get_state:			Void -> Bool,
	    #
	    get_button_type:		Void -> t::Button_Type			# We deliberately do not provide a 'set' fn for this -- button type      should be selected at configuration time not runtime.
	  };

	Option	= PIXELS_SQUARE		Int
		#
		| PIXELS_HIGH_MIN	Int
		| PIXELS_WIDE_MIN	Int
		#
		| PIXELS_HIGH_CUT	Float
		| PIXELS_WIDE_CUT	Float
		#
		| INITIAL_STATE		Bool
		| INITIALLY_ACTIVE	Bool
		#
		| MOMENTARY_CONTACT						# State is non-default (opposite of INITIAL_STATE) only between mouse downclick and upclick.
		| PUSH_ON_PUSH_OFF						# Mouse downclicks toggle state between TRUE and FALSE.
		#
		| APPEARANCE		Button_Appearance_Fn
		#
		| STATE_WATCHER		(Bool -> Void)				# Widget's current state              will be sent to these fns each time state changes.
		| PORT_WATCHER		(App_To_Checkbutton -> Void)  		# Widget's app port                   will be sent to these fns at widget startup.
		| SITE_WATCHER		(g2d::Box -> Void)			# Widget's site in window coordinates will be sent to these fns each time it changes.
		| POPUP_WATCHER		((g2d::Box, gt::Gui_Plan)
							    -> ( g2d::Box,
                                                                 gt::Client_To_Guiwindow
                                                               )
					) -> Void
		#
		| MOUSE_TRANSIT_FN	wi::Mouse_Transit_Fn			# Application-specific handler for mouse enter/leave.
		| MOUSE_DRAG_FN		wi::Mouse_Drag_Fn			# Application-specific handler for mouse drags.
		;								# To help prevent deadlock, watcher fns should be fast and nonblocking, typically just setting a var or entering something into a mailqueue.
		
fun next_relief pt::FLAT   => pt::RAISED;	
    next_relief pt::RAISED => pt::SUNKEN;
    next_relief pt::SUNKEN => pt::GROOVE;
    next_relief pt::GROOVE => pt::RIDGE;
    next_relief pt::RIDGE  => pt::FLAT;
end;

	fun default_appearance
	      {
		last:			Button_Appearance_Fn_Arg,
		this:			Button_Appearance_Fn_Arg,		
		theme:			pt::Widget_Theme
	      }
	    =
	    {
		stipulate
		    offset = 1;
		herein
		    fun box_vertices ({ row, col, wide, high }: g2d::Box)			#   /\		
			= 									#  ----
			[ { col=> col + wide / 2,    row=> row + offset - 1  },
			  { col=> col + offset - 1,  row=> row + high-offset },
			  { col=> col + wide-offset, row=> row + high-offset }
			];
		end;

		point_in_gadget = NULL;

		(*theme.current_gadget_colors { gadget_is_on => this.state, gadget_mode  => this.mode })
		    ->
		    (p: pt::Gadget_Palette);
# r2s = rgb::rgb_to_string;
# printf "\n";
# printf "palette:             this.state => %B  -- default_appearance checkbutton.pkg\n" (                  this.state);
# printf "palette:         surround_color => %s  -- default_appearance checkbutton.pkg\n" (r2s         p.surround_color);
# printf "palette:             body_color => %s  -- default_appearance checkbutton.pkg\n" (r2s             p.body_color);
# printf "palette:             text_color => %s  -- default_appearance checkbutton.pkg\n" (r2s             p.text_color);
# printf "palette:  upperleft_bevel_color => %s  -- default_appearance checkbutton.pkg\n" (r2s  p.upperleft_bevel_color);
# printf "palette: lowerright_bevel_color => %s  -- default_appearance checkbutton.pkg\n" (r2s p.lowerright_bevel_color);
#		my (foreground_color, background_color)
#		    =
#		    case this.state	TRUE	=> (r64::cyan,	  r64::magenta);
#					FALSE	=> (r64::magenta, r64::cyan   );
#		    esac;
# printf "relief is %s  -- default_appearance checkbutton.pkg\n" (pt::relief_to_string this.relief);


		background_box =  this.site;
		foreground_box =  g2d::box::make_nested_box (background_box, 4);

		background =  [ gd::COLOR (p.surround_color,  [ gd::FILLED_BOXES [ background_box ]]) ];

#		foreground = gt::CHANGED (THE [ gd::COLOR (foreground_color,  [ gd::FILLED_BOXES [ foreground_box ]]) ] );

#		foreground = gt::CHANGED (THE (*theme.pictureframe p { box => foreground_box, thick => 20, relief => this.relief } ));

#		foreground = gt::CHANGED (THE (*theme.rounded_pictureframe p { box => foreground_box, thick => 20, relief => this.relief, corner_wide => 40, corner_high => 40 } ));

		stipulate
		    inner_box = g2d::box::make_nested_box (background_box, 40);
		herein
# stipulate
#     inner_box -> { row, col, high, wide };
# herein
#     clip_box = { row, col, high, wide => wide / 2 };
# end;

		    points =  box_vertices  inner_box;

#			points =  [ { row => b.row,           col => b.col		}, 
#				    { row => b.row + b.high,  col => b.col		},
#				    { row => b.row + b.high,  col => b.col + b.wide	},
#				    { row => b.row,	      col => b.col + b.wide	}
#				  ];


#			foreground = gt::CHANGED (THE (*theme.polygon3d p { points, thick => 20, relief => this.relief } ));

mgreen =  mtx::make_rw_matrix ((10,10), r8::rgb8_green);

midpoint    = g2d::box::midpoint foreground_box;
displaylist = (*theme.polygon3d p { points, thick => 20, relief => this.relief } );
textlist    = [ gd::DRAW_TEXT (gd::CENTERED_ON_POINT, [ gd::TEXT (midpoint, "xyz") ]) ];
# textlist  = [ gd::FONT ([ "-adobe-times-medium-i-normal--*-%d-*-*-p-*-iso8859-1", "9x15" ], textlist) ];
textlist    = [ gd::FONT ([ "-*-courier-bold-r-*-*-20-*-*-*-*-*-*-*", "9x15" ], textlist) ];
greenlist   = [ gd::IMAGE { to_point => midpoint, from_box => NULL, from => mgreen } ];

displaylist = displaylist @ textlist @ greenlist;

		    foreground = displaylist;

		    convex_hull = g2d::convex_hull (gd::find_all_points_in_gui_displaylist displaylist);

		    fun point_in_gadget (point: g2d::Point)
			=
#			    g2d::point_in_polygon (point, points);
			g2d::point_in_polygon (point, convex_hull);

		    point_in_gadget = THE point_in_gadget;
		end;

		{ displaylist => background @ foreground, point_in_gadget };
	    };

	fun process_options
	    ( options: List(Option),
	      #
	      {	button_type,
		#
		appearance,
		#
		initial_state,
		initially_active,
		#
		widget_options,
		#
		port_watchers,
		state_watchers,
		popup_watchers,
		mouse_transit_fn,
		mouse_drag_fn,
		site_watchers
	      }
	    )
	    =
	    {   my_button_type		=  REF  button_type;
		#
		my_appearance		=  REF  appearance;
		#
		my_initial_state	=  REF  initial_state;
		my_initially_active	=  REF  initially_active;
		#
		my_widget_options	=  REF  widget_options;
		#
		my_port_watchers	=  REF  port_watchers;
		my_state_watchers	=  REF  state_watchers;
		my_site_watchers	=  REF  site_watchers;
		my_popup_watchers	=  REF  popup_watchers;
		#
		my_mouse_transit_fn	=  REF  mouse_transit_fn;
		my_mouse_drag_fn	=  REF  mouse_drag_fn;

		apply  do_option  options
		where
		    fun do_option (INITIAL_STATE		b) =>   my_initial_state	:=  b;
			do_option (INITIALLY_ACTIVE		b) =>   my_initially_active	:=  b;
			#
			do_option (MOMENTARY_CONTACT		 ) =>   my_button_type		:=  t::MOMENTARY_CONTACT;
			do_option (PUSH_ON_PUSH_OFF		 ) =>   my_button_type		:=  t::PUSH_ON_PUSH_OFF;
			#
			do_option (APPEARANCE			c) =>   my_appearance		:=  c;
			#
			do_option (PORT_WATCHER			c) =>	my_port_watchers	:=  c ! *my_port_watchers;
			do_option (STATE_WATCHER		c) =>	my_state_watchers	:=  c ! *my_state_watchers;
			do_option (SITE_WATCHER			c) =>	my_site_watchers	:=  c ! *my_site_watchers;
			do_option (POPUP_WATCHER		c) =>	my_popup_watchers	:=  c ! *my_popup_watchers;
			#
			do_option (MOUSE_TRANSIT_FN		c) =>	my_mouse_transit_fn	:=  c;
			do_option (MOUSE_DRAG_FN		c) =>	my_mouse_drag_fn	:=  c;
			#
			do_option (PIXELS_HIGH_MIN		i) =>   my_widget_options	:=  (wi::PIXELS_HIGH_MIN i) ! *my_widget_options;
			do_option (PIXELS_WIDE_MIN		i) =>   my_widget_options	:=  (wi::PIXELS_WIDE_MIN i) ! *my_widget_options;
			#
			do_option (PIXELS_HIGH_CUT		f) =>   my_widget_options	:=  (wi::PIXELS_HIGH_CUT f) ! *my_widget_options;
			do_option (PIXELS_WIDE_CUT		f) =>   my_widget_options	:=  (wi::PIXELS_WIDE_CUT f) ! *my_widget_options;
			#
			do_option (PIXELS_SQUARE		i) =>   my_widget_options	:=  (wi::PIXELS_HIGH_MIN   i)
												!   (wi::PIXELS_WIDE_MIN   i)
												!   (wi::PIXELS_HIGH_CUT 0.0)
												!   (wi::PIXELS_WIDE_CUT 0.0)
												!   *my_widget_options;
		    end;
		end;

		{ button_type		=>  *my_button_type,
		  #
		  appearance		=>  *my_appearance,
		  #
		  initial_state		=>  *my_initial_state,
		  initially_active	=>  *my_initially_active,
		  #
		  widget_options	=>  *my_widget_options,
		  #
		  port_watchers		=>  *my_port_watchers,
		  state_watchers	=>  *my_state_watchers,
		  popup_watchers	=>  *my_popup_watchers,
		  #
		  mouse_transit_fn	=>  *my_mouse_transit_fn,
		  mouse_drag_fn		=>  *my_mouse_drag_fn,
		  #
		  site_watchers		=>  *my_site_watchers
		};
	    };


	offset = 1;

	fun get_vertices (wide: Int, high: Int)
	    =
	    [ { col=>wide / 2,    row=>offset - 1 },
	      { col=>offset - 1,  row=>high-offset },
	      { col=>wide-offset, row=>high-offset }
	    ];

	fun with (options: List(Option))									# PUBLIC
	    =
	    {
	        (process_options
		  (
		    options,
		    #
		    { button_type	=>  t::PUSH_ON_PUSH_OFF,
		      #
		      appearance	=>  default_appearance,
		      #
		      initial_state	=>  FALSE,
		      initially_active	=>  TRUE,
		      #
		      widget_options	=>  [],
		      #
		      port_watchers	=>  [],
		      state_watchers	=>  [],
		      popup_watchers	=>  [],
		      mouse_transit_fn	=>  (\\ _ = ()),
		      mouse_drag_fn	=>  (\\ _ = ()),
		      site_watchers	=>  []
		    }
		) )
		    ->
		    {												# These values are globally visible to the subsequenc fns, which can lock them in as needed.
		      button_type,									
		      #
		      appearance,
		      #
		      initial_state,
		      initially_active,
		      #
		      widget_options,
		      #
		      port_watchers,
		      state_watchers,
		      popup_watchers,
		      #
		      mouse_transit_fn,
		      mouse_drag_fn,
		      #
		      site_watchers
		    };


		###############################
		# Top of state variable section
		#

		gadget_to_guiboss__global
		    =
		    REF (NULL:  Null_Or((gt::Gadget_To_Guiboss, iul::Id)));

		fun note_changed_gadget_activity (is_active: Bool)
		    =
		    case (*gadget_to_guiboss__global)
			#
			THE (gadget_to_guiboss as gt::GADGET_TO_GUIBOSS g2g, id)	=>  g2g.note_changed_gadget_activity { id, is_active };
			NULL								=>  ();
		    esac;

		fun needs_redraw_gadget_request ()
		    =
		    case (*gadget_to_guiboss__global)
			#
			THE (gadget_to_guiboss as gt::GADGET_TO_GUIBOSS g2g, id)	=>  g2g.needs_redraw_gadget_request(id);
			NULL								=>  ();
		    esac;


		last_known_site
		    =
		    REF ( { col => -1,  wide => -1,
			    row => -1,  high => -1
			  }:				g2d::Box
			);

		button_relief
		    =
		    REF pt::FLAT;


		button_state
		    =
		    REF initial_state;

		last_appearance_arg										# Here we're initializing to any type-valid value; the values should never get used. 
		    =
		    REF ( { frame_number    =>	0,
			    site	    =>	{ row => 0,  col => 0,  high => 0,  wide => 0 },
			    state	    =>	*button_state,
			    type	    =>	t::PUSH_ON_PUSH_OFF,
relief => *button_relief,
			    mode	    =>  { is_active		=> TRUE,
						  has_mouse_focus	=> FALSE,
						  has_keyboard_focus	=> FALSE,
						  mousebutton_is_down	=> FALSE
						}
			  }
			  :			Button_Appearance_Fn_Arg
			);

		button_active
		    =
		    REF initially_active;


		exception SAVED_STATE { last_known_site:	g2d::Box,					# Here we're doing the usual hack of using Exception as an extensible datatype -- nothing to do with actually raising or trapping exceptions.
					button_state:		Bool,
					button_active:		Bool
				      };	


		fun note_site (site: g2d::Box)
		    =
		    if(*last_known_site != site)
			last_known_site := site;
			#
			apply notify_watcher site_watchers
			    where
				fun notify_watcher site_watcher
				    =
				    site_watcher site;
			    end;
		    fi;

		fun note_state (state: Bool)
		    =
		    if(*button_state != state)
			button_state := state;
			#
			apply notify_watcher state_watchers
			    where
				fun notify_watcher state_watcher
				    =
				    state_watcher state;
			    end;
		    fi;

		Make_Popup
		    =
		    ( g2d::Box,											# Requested site for popup.
		      gt::Gui_Plan										# GUI to run in popup.
		    )
		      -> ( g2d::Box,										# Actual site for popup.
			   gt::Client_To_Guiwindow								# Port allowing popup to be closed down etc.
			 );

		fun note_popup_maker (make_popup: Make_Popup)
		    =
		    apply notify_watcher popup_watchers
			where
			    fun notify_watcher popup_watcher
				=
				popup_watcher make_popup;
			end;

		#
		# End of state variable section
		###############################


		#####################
		# Top of port section
		#
		# Here we implement our App_To_Checkbutton port:

		fun set_active_to (is_active: Bool)
		    =
		    {   button_active :=  is_active;
			#
			note_changed_gadget_activity  is_active;
		    };

		fun set_state_to (state: Bool)
		    =
		    {   note_state state;
			#
			needs_redraw_gadget_request ();
		    };

		fun get_active ()
		    =
		    *button_active;

		fun get_state ()
		    =
		    *button_state;

		fun get_button_type ()
		    =
		    button_type;

		port =    { set_active_to,
			    set_state_to,
			    get_active,
			    get_state,
			    get_button_type
			  }
			  : App_To_Checkbutton
			  ;

		#
		# End of port section
		#####################


		###############################
		# Top of widget hook fn section
		#
		# These fns get called by widget_imp logic, ultimately						# widget_imp		is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
		# in response to user mouseclicks and keypresses etc:

		fun startup_fn
		    { 
		      id:				iul::Id,						# Unique id.
		      gadget_to_guiboss:		gt::Gadget_To_Guiboss,
		      widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
		      saved_widget_state:		Null_Or(Exception)
		    }
		    =
		    {	gadget_to_guiboss__global
			    :=  
			    THE (gadget_to_guiboss, id);

			case saved_widget_state
			    #
			    THE (SAVED_STATE r)									# Widget is being restarted after an earlier run.
				=>
				{ last_known_site   := r.last_known_site;					# Restore saved state.
				  button_state	    := r.button_state;
				  button_active	    := r.button_active;
				};

			    THE _ =>										# This shouldn't happen; guiboss_imp must have mistakenly given us another widget's saved state. (Type system cannot prevent this.)
				{   msg = "Wrong saved state! -- startup_fn in checkbutton.pkg";
				    log::fatal           msg;							# log			is from   src/lib/std/src/log.pkg
				    raise exception FAIL msg;							# Previous won't return, but type does not (yet?) indicate that properly.
				};

			    NULL => ();										# No saved state: We must be newly created in a fresh session.
			esac;

			apply   notify_watcher  port_watchers							# We do this here rather than (say) above this fn because we don't want the port in circulation until we're running.
				where
				    fun notify_watcher  port_watcher
					=
					port_watcher port;
				end;
nb {. "startup_fn called!   -- checkbutton.pkg"; };
			();
		    };

		fun shutdown_fn ()										# Return to widget_imp an exception packaging up our state; this will be returned to guiboss_imp, saved in the
		    =												# Paused_Gui tree, and passed to our startup_fn when/if gui is restarted. This exception will never be raised;
		    THE (SAVED_STATE  { last_known_site	=> *last_known_site,					# Exception is being used here purely as an extensible datatype.
					button_state	=> *button_state,
					button_active	=> *button_active
				      }	
		        );

		fun initialize_gadget_fn
		    {
		      id:				iul::Id,						# Unique id.
		      site:				g2d::Box,						# Window rectangle in which to draw.
		      gadget_to_guiboss:		gt::Gadget_To_Guiboss,
		      widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
		      theme:				pt::Widget_Theme,
		      pass_font:			List(String) -> Replyqueue
								     -> (evt::Font -> Void) -> Void,		# Nonblocking version of next, for use in imps.
		       get_font:			List(String) ->	 evt::Font,				# Accepts a list of font names which are tried in order.
		      make_rw_pixmap:			g2d::Size -> g2p::Gadget_To_Rw_Pixmap,
		      #
		      make_popup:			(g2d::Box, gt::Gui_Plan)
							    -> (g2d::Box, gt::Client_To_Guiwindow)

		    }
		    =
		    {	note_site site;
			note_popup_maker make_popup;
nb {. "initialize_gadget_fn called!   -- checkbutton.pkg"; };

			();
		    };

		fun redraw_gadget_request_fn
		    {
		      id:						iul::Id,				# Unique id.
		      frame_number:					Int,					# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
		      site:						g2d::Box,				# Window rectangle in which to draw.
		      visible:						Bool,					# If FALSE, widget is not visible on screen, so widget-imp may be able to avoid updating foreground and background.
		      duration_in_seconds:				Float,					# If state has changed widget-imp should call redraw_gadget() before this time is up. Also useful for motionblur.
		      gadget_to_guiboss as gt::GADGET_TO_GUIBOSS g2g:	gt::Gadget_To_Guiboss,
		      widget_to_widgetspace:				w2p::Widget_To_Widgetspace,
		      this_gadget_mode:					gt::Gadget_Mode,
		      theme:						pt::Widget_Theme
		    }
		    =
		    {
if (*log::debugging) log::note {. sprintf "redraw_gadget_request_fn/AAA id=%d -- checkbutton.pkg" (iul::id_to_int id); }; fi;
			note_site site;
# nb {. sprintf "redraw_gadget_request_fn frame_number d=%d called!   -- checkbutton.pkg" frame_number; };
			#
			this =	  { frame_number,
				    site,
				    state	=> *button_state,
				    type	=>  button_type,
				    relief	=> *button_relief,
				    mode	=>  this_gadget_mode
				  };

			last =	  case frame_number   1 =>   this;						# For the first frame we have no 'last', so just re-use 'this'.
						      _ =>  *last_appearance_arg;
				  esac;

			last_appearance_arg :=  this;

			(appearance { this, last, theme })
			    ->
			    { displaylist, point_in_gadget };

			g2g.redraw_gadget { id, displaylist, point_in_gadget };
		    };


		fun mousebutton_fn
		      {
			id:				iul::Id,						# Unique id.
			event:				gt::Mousebutton_Event,					# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE
			button:				evt::Mousebutton,
			point:				g2d::Point,
			site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
			theme:				pt::Widget_Theme
		      }
		    = 
		    {	note_site site;
			#
			case event
			    #
			    gt::MOUSEBUTTON_PRESS
				=>
				{	
				    button_relief :=  next_relief *button_relief;
				    needs_redraw_gadget_request ();
				};

			    gt::MOUSEBUTTON_RELEASE
				=>
				{
				    if (button_type == t::MOMENTARY_CONTACT)
					#
					note_state  initial_state;
				    fi;
				};
			esac;
		       ();
		    };

		fun mouse_transit_fn_wrapper
		      #
		      ( arg as
			{
			  id:				iul::Id,						# Unique id.
			  event_point:			g2d::Point,
			  site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
			  transit:			gt::Gadget_Transit,					# Mouse is entering (CAME) or leaving (LEFT) widget, or moving (MOVE) across it.
			  modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			  gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			  widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
			  theme:				pt::Widget_Theme
			}
		      )	
		    = 
		    {
# foo =	case transit
# 	    #
# 	    gt::CAME =>	"CAME";
# 	    gt::MOVE =>	"MOVE";
# 	    gt::LEFT =>	"LEFT";
# 	esac;
# nb {. sprintf "mouse_transit_fn/AAA %s { row => %d, col => %d }... -- arrowbutton.pkg" foo event_point.row event_point.col; };
# 			case transit
# 			    #
# 			    gt::CAME =>	nb {. sprintf "mouse_transit_fn called: CAME { row => %d, col => %d }  -- arrowbutton.pkg" event_point.row event_point.col; };
# 			    gt::MOVE =>	nb {. sprintf "mouse_transit_fn called: MOVE { row => %d, col => %d }  -- arrowbutton.pkg" event_point.row event_point.col; };
# 			    gt::LEFT =>	nb {. sprintf "mouse_transit_fn called: LEFT { row => %d, col => %d }  -- arrowbutton.pkg" event_point.row event_point.col; };
# 			esac;

			note_site site;

			mouse_transit_fn  arg;

			();
		    };

		fun key_event_fn
		      {
			id:				iul::Id,						# Unique id.
			key_event:			gt::Key_Event,						# KEY_PRESS or KEY_RELEASE.
			keycode:			evt::Keycode,						# Keycode of the depressed key.
			keysym:				evt::Keysym,						# Keysym  of the depressed key.
			string:				String,							# Ascii  for the depressed key.
			event_point:			g2d::Point,
			site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
			theme:				pt::Widget_Theme
		      }
		    = 
		    {	note_site site;
			#
nb {. "key_event_fn called!   -- checkbutton.pkg"; };
		       ();
		    };

		#
		# End of widget hook fn section
		###############################

		widget_options
		  =
		  [ wi::STARTUP_FN			startup_fn,
		    wi::SHUTDOWN_FN			shutdown_fn,
		    wi::INITIALIZE_GADGET_FN		initialize_gadget_fn,
		    wi::REDRAW_GADGET_REQUEST_FN	redraw_gadget_request_fn,
		    wi::MOUSEBUTTON_FN			mousebutton_fn,
		    wi::KEY_EVENT_FN			key_event_fn,
		    wi::MOUSE_TRANSIT_FN		mouse_transit_fn_wrapper,
		    wi::MOUSE_DRAG_FN			mouse_drag_fn
		  ]
		  @
		  widget_options
		  ;

		make_widget_fn =  wi::make_widget_start_fn  widget_options;

		( gt::WIDGET   make_widget_fn									# So caller can write   gui_plan =  gt::ROW [ checkbutton::with [...], checkbutton::with [...], ... ];
		);
	    };
    };
end;


## COPYRIGHT (c) 1994 by AT&T Bell Laboratories  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2014,
## released per terms of SMLNJ-COPYRIGHT.
