## frame.pkg
#
# Implementation of widget which draws a frame around a group of widgets.
# This is support for RG_FRAME in   src/lib/x-kit/widget/gui/guiboss-types.pkg
#
# See also:
#     src/lib/x-kit/widget/leaf/arrowbutton.pkg
#     src/lib/x-kit/widget/leaf/boxbutton.pkg
#     src/lib/x-kit/widget/leaf/diamondbutton.pkg
#     src/lib/x-kit/widget/leaf/roundbutton.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib






stipulate
    include package   threadkit;					# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    include package   geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    #
#   package xc  =  xclient;						# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
    #
#   package d3  =  three_d;						# three_d			is from   src/lib/x-kit/widget/old/lib/three-d.pkg

    package evt =  gui_event_types;					# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
#   package b2g =  guiboss_to_gadget;					# guiboss_to_gadget		is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg
#   package g2g =  gadget_to_guiboss;					# gadget_to_guiboss		is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
    package g2p =  gadget_to_pixmap;					# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg
    package gd  =  gui_displaylist;					# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    package gt  =  guiboss_types;					# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
    package pt  =  widget_theme;					# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg
    package r8  =  rgb8;						# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;							# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package w2p =  widget_to_widgetspace;				# widget_to_widgetspace		is from   src/lib/x-kit/widget/space/widget/look-to-widget.pkg
    package wi  =  widget_imp;						# widget_imp			is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
    package g2d =  geometry2d;						# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;					# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg
    package mtx =  rw_matrix;						# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
    package pp  =  standard_prettyprint_mill;				# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package gws =  guiboss_to_windowsystem;				# guiboss_to_windowsystem	is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg

    package iul =  issue_unique_look_id;				# issue_unique_look_id		is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    nb =  log::note_on_stderr;						# log				is from   src/lib/std/src/log.pkg
herein

    package frame
    :	    Frame							# Frame				is from   src/lib/x-kit/widget/leaf/frame.api
    {
	Frame_Appearance_Fn_Arg
	  =
	  { frame_number:		Int,
	    site:			g2d::Box,
# Strictly for debugging:
relief: pt::Relief,
	    mode:			gt::Gadget_Mode			# Whether gadget has mouse focus etc.
	  };

	Frame_Appearance_Fn
	  =
	  { last:			Frame_Appearance_Fn_Arg,
	    this:			Frame_Appearance_Fn_Arg,
	    #
	    outer_margin_in_pixels:	Int,
	    inner_margin_in_pixels:	Int,
	    frame_width_in_pixels:	Int,
	    #
	    theme:			pt::Widget_Theme
	  }
	  ->
	  Null_Or { displaylist:	gd::Gui_Displaylist,
		    point_in_gadget:	Null_Or(g2d::Point -> Bool)		# 
		  }
	  ;

	App_To_Frame
	  =
	  { 
	  };

	Option	= PIXELS_SQUARE			Int
		#
		| PIXELS_HIGH_MIN		Int
		| PIXELS_WIDE_MIN		Int
		#
		| PIXELS_HIGH_CUT		Float
		| PIXELS_WIDE_CUT		Float
		#
		| OUTER_MARGIN_IN_PIXELS	Int
		| INNER_MARGIN_IN_PIXELS	Int
		| FRAME_WIDTH_IN_PIXELS		Int
		#
		| APPEARANCE			Frame_Appearance_Fn
		| RELIEF			pt::Relief
		#
		| PORT_WATCHER			(App_To_Frame -> Void)  		# Widget's app port                   will be sent to these fns at widget startup.
		| SITE_WATCHER			(g2d::Box -> Void)			# Widget's site in window coordinates will be sent to these fns each time it changes.
# This is intended as a very temporary checkout hack:
		| MOUSE_WATCHER			(g2d::Point -> Void)  			# 
# Ditto:
		| POPUP_WATCHER			((g2d::Box, gt::Gui_Plan)
							    -> ( g2d::Box,
                                                                 gt::Client_To_Guiwindow
                                                               )
						) -> Void

		| MOUSE_DRAG_FN			wi::Mouse_Drag_Fn			# Application-specific handler for mouse motions.
		;									# To help prevent deadlock, watcher fns should be fast and nonblocking, typically just setting a var or entering something into a mailqueue.
		
fun next_relief pt::FLAT   => pt::RAISED;	
    next_relief pt::RAISED => pt::SUNKEN;
    next_relief pt::SUNKEN => pt::GROOVE;
    next_relief pt::GROOVE => pt::RIDGE;
    next_relief pt::RIDGE  => pt::FLAT;
end;

	fun process_options
	    ( options: List(Option),
	      #
	      {	appearance,
		relief,
		#
		outer_margin_in_pixels,
		inner_margin_in_pixels,
		frame_width_in_pixels,
		#
		widget_options,
		#
		port_watchers,
		mouse_watchers,
		popup_watchers,
		mouse_drag_fn,
		site_watchers
	      }
	    )
	    =
	    {   my_appearance			=  REF  appearance;
		my_relief			=  REF  relief;
		#
		my_outer_margin_in_pixels	=  REF  outer_margin_in_pixels;
		my_inner_margin_in_pixels	=  REF  inner_margin_in_pixels;
		my_frame_width_in_pixels	=  REF  frame_width_in_pixels;
		#
		my_widget_options	=  REF  widget_options;
		#
		my_port_watchers		=  REF  port_watchers;
		my_site_watchers		=  REF  site_watchers;
		my_mouse_watchers		=  REF  mouse_watchers;
		my_popup_watchers		=  REF  popup_watchers;
		my_mouse_drag_fn		=  REF  mouse_drag_fn;

		apply  do_option  options
		where
		    fun do_option (APPEARANCE			c) =>   my_appearance			:=  c;
			do_option (RELIEF			r) =>   my_relief			:=  r;
			#
			do_option (OUTER_MARGIN_IN_PIXELS	i) =>   my_outer_margin_in_pixels	:=  i;
			do_option (INNER_MARGIN_IN_PIXELS	i) =>   my_inner_margin_in_pixels	:=  i;
			do_option (FRAME_WIDTH_IN_PIXELS	i) =>   my_frame_width_in_pixels	:=  i;
			#
			do_option (PORT_WATCHER			c) =>	my_port_watchers		:=  c ! *my_port_watchers;
			do_option (SITE_WATCHER			c) =>	my_site_watchers		:=  c ! *my_site_watchers;
			do_option (MOUSE_WATCHER		c) =>	my_mouse_watchers		:=  c ! *my_mouse_watchers;
			do_option (POPUP_WATCHER		c) =>	my_popup_watchers		:=  c ! *my_popup_watchers;
			do_option (MOUSE_DRAG_FN		c) =>	my_mouse_drag_fn		:=  c;
			#
			do_option (PIXELS_HIGH_MIN		i) =>   my_widget_options	:=  (wi::PIXELS_HIGH_MIN i) ! *my_widget_options;
			do_option (PIXELS_WIDE_MIN		i) =>   my_widget_options	:=  (wi::PIXELS_WIDE_MIN i) ! *my_widget_options;
			#
			do_option (PIXELS_HIGH_CUT		f) =>   my_widget_options	:=  (wi::PIXELS_HIGH_CUT f) ! *my_widget_options;
			do_option (PIXELS_WIDE_CUT		f) =>   my_widget_options	:=  (wi::PIXELS_WIDE_CUT f) ! *my_widget_options;
			#
			do_option (PIXELS_SQUARE		i) =>   my_widget_options	:=  (wi::PIXELS_HIGH_MIN   i)
													!   (wi::PIXELS_WIDE_MIN   i)
													!   (wi::PIXELS_HIGH_CUT 0.0)
													!   (wi::PIXELS_WIDE_CUT 0.0)
													!   *my_widget_options;
		    end;
		end;

		{ appearance			=>  *my_appearance,
		  relief			=>  *my_relief,
		  #
		  outer_margin_in_pixels	=>  *my_outer_margin_in_pixels,
		  inner_margin_in_pixels	=>  *my_inner_margin_in_pixels,
		  frame_width_in_pixels		=>  *my_frame_width_in_pixels,
		  #
		  widget_options		=>  *my_widget_options,
		  #
		  port_watchers			=>  *my_port_watchers,
		  mouse_watchers		=>  *my_mouse_watchers,
		  popup_watchers		=>  *my_popup_watchers,
		  mouse_drag_fn			=>  *my_mouse_drag_fn,
		  site_watchers			=>  *my_site_watchers
		};
	    };


	fun with (options: List(Option))											# PUBLIC
	    =
	    {
		fun default_appearance												# Draw frame and surround near it, but do not touch the area reserved for the widgets which we are framing.
		      {
			last:			Frame_Appearance_Fn_Arg,
			this:			Frame_Appearance_Fn_Arg,		
			#
			outer_margin_in_pixels:	Int,										# Number of pixels width of surround outside the frame polygons.
			inner_margin_in_pixels:	Int,										# Number of pixels width of surround  inside the frame polygons.
			frame_width_in_pixels:	Int,										# Number of pixels width of frame polygons proper.
			#
			theme:			pt::Widget_Theme
		      }
		    =
		    {														# The code here is usable but sloppy.  Really need to analyse and document EXACTLY what polygon3d does,
			stipulate												# then carefully work through the code here based on that.  XXX SUCKO FIXME.
			    inset = outer_margin_in_pixels + frame_width_in_pixels;
			herein
			    fun frame_vertices ({ row, col, wide, high }: g2d::Box)						#
				    = 												#
				    [ { col=> col + inset - 1,        row=> row + inset		   },				# upper-left
				      { col=> col + inset - 1,        row=> row + high - (inset+1) },				# lower-left
				      { col=> col + wide - (inset+1), row=> row + high - (inset+1) },				# lower-right
				      { col=> col + wide - (inset+1), row=> row + inset		   }				# upper-right
				    ];
			end;

			(*theme.current_gadget_colors { gadget_is_on => TRUE, gadget_mode  => this.mode })
			    ->
			    (gadget_palette:	pt::Gadget_Palette);

			background_box =  this.site;

			foreground_indent = outer_margin_in_pixels
					  + inner_margin_in_pixels
					  + frame_width_in_pixels
					  ;	
			foreground_box    =  g2d::box::make_nested_box (background_box, foreground_indent);			# This is the window area reserved for the widgets we're framing.

			background_displaylist 											# The 'background' for the frame is the part not covered by the 3d polygon.
			    =													# In particular, we do NOT want to draw over the inner rectangle reserved
			    [ gd::COLOR												# for the widgets within the frame.
				(
				  gadget_palette.surround_color,
				  #
				  [ gd::FILLED_BOXES (g2d::box::subtract_box_b_from_box_a
						       {
							 a => background_box,
							 b => foreground_box
						       }
						     )
				  ]
				)
			    ];

			points =  frame_vertices  background_box;

			foreground_displaylist
			    =
			    (*theme.polygon3d gadget_palette
			      {
				points,
				thick => frame_width_in_pixels,
				relief => this.relief
			      }
			    );


			stipulate
			    frame_outer_limit =  g2d::box::make_nested_box (background_box, outer_margin_in_pixels                        );
			    frame_inner_limit =  g2d::box::make_nested_box (background_box, outer_margin_in_pixels + frame_width_in_pixels);
			herein
			    fun point_in_gadget (point: g2d::Point)								# A fn which will return TRUE iff the point is on the 3d frame itself, not the surround -- much less the inner widgets.
				=
				(    (g2d::point_in_polygon (point, g2d::box::to_points frame_outer_limit)))  and
				(not (g2d::point_in_polygon (point, g2d::box::to_points frame_inner_limit)));
			end;

			point_in_gadget =  THE  point_in_gadget;
			displaylist     =  background_displaylist @ foreground_displaylist;

			THE { displaylist, point_in_gadget };
		    };

	        (process_options
		  (
		    options,
		    #
		    { appearance		=>  default_appearance,
		      relief			=>  pt::RIDGE,
		      #												# If you change any of these numbers, BE SURE to update assign_sites_to_all_widgets/gt::RG_FRAME in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
		      outer_margin_in_pixels	=>  2,								# where the sum (9) is hardwired as 'indent'.  Yes, this sucks -- feel free to contribute a clean fix.  XXX SUCKO FIXME.
		      frame_width_in_pixels	=>  5,								# polygon3d result will probably look odd if this is not an odd number.
		      inner_margin_in_pixels	=>  2,								#
		      #
		      widget_options	=>  [],
		      #
		      port_watchers		=>  [],
		      mouse_watchers		=>  [],
		      popup_watchers		=>  [],
		      mouse_drag_fn		=>  (\\ _ = ()),
		      site_watchers		=>  []
		    }
		) )
		    ->
		    {												# These values are globally visible to the subsequenc fns, which can lock them in as needed.
		      appearance,
		      relief,	
		      #
		      outer_margin_in_pixels,
		      inner_margin_in_pixels,
		      frame_width_in_pixels,
		      #
		      widget_options,
		      #
		      port_watchers,
		      mouse_watchers,
		      popup_watchers,
		      mouse_drag_fn,
		      site_watchers
		    };


		###############################
		# Top of state variable section
		#

		gadget_to_guiboss__global
		    =
		    REF (NULL:  Null_Or((gt::Gadget_To_Guiboss, iul::Id)));

		fun needs_redraw_gadget_request ()
		    =
		    case (*gadget_to_guiboss__global)
			#
			THE (gt::GADGET_TO_GUIBOSS gadget_to_guiboss, id)	=>  gadget_to_guiboss.needs_redraw_gadget_request(id);
			NULL							=>  ();
		    esac;


		last_known_site
		    =
		    REF ( { col => -1,  wide => -1,
			    row => -1,  high => -1
			  }:				g2d::Box
			);

		frame_relief =  REF relief;


		last_appearance_arg										# Here we're initializing to any type-valid value; the values should never get used. 
		    =
		    REF ( { frame_number    =>	0,
			    site	    =>	{ row => 0,  col => 0,  high => 0,  wide => 0 },
			    relief 	    => *frame_relief,
			    mode	    =>  { is_active		=> TRUE,
						  has_mouse_focus	=> FALSE,
						  has_keyboard_focus	=> FALSE,
						  mousebutton_is_down	=> FALSE
						}
			  }
			  :			Frame_Appearance_Fn_Arg
			);

		exception SAVED_STATE { last_known_site:	g2d::Box					# Here we're doing the usual hack of using Exception as an extensible datatype -- nothing to do with actually raising or trapping exceptions.
				      };	


		fun note_site (site: g2d::Box)
		    =
		    if(*last_known_site != site)
			last_known_site := site;
			#
			apply notify_watcher site_watchers
			    where
				fun notify_watcher site_watcher
				    =
				    site_watcher site;
			    end;
		    fi;

# XXX SUCKO FIXME Make_Popup should be defined once in guiboss-types.pkg, not over and over in the widgets.
		Make_Popup
		    =
		    ( g2d::Box,											# Requested site for popup.
		      gt::Gui_Plan										# GUI to run in popup.
		    )
		      -> ( g2d::Box,										# Actual site for popup.
			   gt::Client_To_Guiwindow								# Port allowing popup to be closed down etc.
			 );

		fun note_popup_maker (make_popup: Make_Popup)
		    =
		    apply notify_watcher popup_watchers
		    where
			fun notify_watcher popup_watcher
			    =
			    popup_watcher make_popup;
		    end;

		#
		# End of state variable section
		###############################


		#####################
		# Top of port section
		#
		# Here we implement our App_To_Frame port:

		port =    { 
			  }
			  : App_To_Frame
			  ;

		#
		# End of port section
		#####################


		###############################
		# Top of widget hook fn section
		#
		# These fns get called by widget_imp logic, ultimately						# widget_imp		is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
		# in response to user mouseclicks and keypresses etc:

		fun startup_fn
		    { 
		      id:				iul::Id,						# Unique id.
		      gadget_to_guiboss:		gt::Gadget_To_Guiboss,
		      widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
		      saved_widget_state:		Null_Or(Exception)
		    }
		    =
		    {	gadget_to_guiboss__global
			    :=  
			    THE (gadget_to_guiboss, id);

			case saved_widget_state
			    #
			    THE (SAVED_STATE r)									# Widget is being restarted after an earlier run.
				=>
				{ last_known_site   := r.last_known_site;					# Restore saved state.
				};

			    THE _ =>										# This shouldn't happen; guiboss_imp must have mistakenly given us another widget's saved state. (Type system cannot prevent this.)
				{   msg = "Wrong saved state! -- startup_fn in frame.pkg";
				    log::fatal           msg;							# log			is from   src/lib/std/src/log.pkg
				    raise exception FAIL msg;							# Previous won't return, but type does not (yet?) indicate that properly.
				};

			    NULL => ();										# No saved state: We must be newly created in a fresh session.
			esac;

			apply   notify_watcher  port_watchers							# We do this here rather than (say) above this fn because we don't want the port in circulation until we're running.
				where
				    fun notify_watcher  port_watcher
					=
					port_watcher port;
				end;
			();
		    };

		fun shutdown_fn ()										# Return to widget_imp an exception packaging up our state; this will be returned to guiboss_imp, saved in the
		    =												# Paused_Gui tree, and passed to our startup_fn when/if gui is restarted. This exception will never be raised;
		    THE (SAVED_STATE  { last_known_site	=> *last_known_site					# Exception is being used here purely as an extensible datatype.
				      }	
		        );

		fun initialize_gadget_fn
		    {
		      id:				iul::Id,						# Unique id.
		      site:				g2d::Box,						# Window rectangle in which to draw.
		      gadget_to_guiboss:		gt::Gadget_To_Guiboss,
		      widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
		      theme:				pt::Widget_Theme,
		      pass_font:			List(String) -> Replyqueue
								     -> (evt::Font -> Void) -> Void,		# Nonblocking version of next, for use in imps.
		       get_font:			List(String) ->	 evt::Font,				# Accepts a list of font names which are tried in order.
		      make_rw_pixmap:			g2d::Size -> g2p::Gadget_To_Rw_Pixmap,
		      #
		      make_popup:			(g2d::Box, gt::Gui_Plan)
							    -> ( g2d::Box,
                                                                 gt::Client_To_Guiwindow
                                                               )
		    }
		    =
		    {	note_site site;
			note_popup_maker make_popup;
			();
		    };

		fun redraw_gadget_request_fn
		    {
		      id:							iul::Id,			# Unique id.
		      frame_number:						Int,				# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
		      site:							g2d::Box,			# Window rectangle in which to draw.
		      visible:							Bool,				# If FALSE, widget is not visible on screen, so widget-imp may be able to avoid updating foreground and background.
		      duration_in_seconds:					Float,				# If state has changed widget-imp should call redraw_gadget() before this time is up. Also useful for motionblur.
		      gadget_to_guiboss as gt::GADGET_TO_GUIBOSS g2g:		gt::Gadget_To_Guiboss,
		      widget_to_widgetspace:					w2p::Widget_To_Widgetspace,
		      this_gadget_mode:						gt::Gadget_Mode,
		      theme:							pt::Widget_Theme
		    }
		    =
		    {
			note_site site;
			#
			this =	  { frame_number,
				    site,
# Strictly for debugging:
relief => *frame_relief,
				    mode	=>  this_gadget_mode
				  };

			last =	  case frame_number   1 =>   this;						# For the first frame we have no 'last', so just re-use 'this'.
						      _ =>  *last_appearance_arg;
				  esac;

			last_appearance_arg :=  this;

			case (appearance { this, last, outer_margin_in_pixels, inner_margin_in_pixels, frame_width_in_pixels, theme })
			    #
			    THE { displaylist, point_in_gadget }
				=>
				g2g.redraw_gadget { id, displaylist, point_in_gadget };
				
			    NULL => ();
			esac;
		    };


		fun mousebutton_fn
		      {
			id:				iul::Id,						# Unique id.
			event:				gt::Mousebutton_Event,					# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE.
			button:				evt::Mousebutton,
			point:				g2d::Point,
			site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
			theme:				pt::Widget_Theme
		      }
		    = 
		    {
			note_site site;
			#
			case event
			    #
			    gt::MOUSEBUTTON_PRESS
				=>
				{	
				    frame_relief :=  next_relief *frame_relief;
				    needs_redraw_gadget_request ();
				};

			    gt::MOUSEBUTTON_RELEASE
				=>
				{
				};
			esac;

			();
		    };

		fun mouse_transit_fn
		      {
			id:				iul::Id,						# Unique id.
			event_point:			g2d::Point,
			site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
			transit:			gt::Gadget_Transit,					# Mouse is entering (CAME) or leaving (LEFT) widget, or moving (MOVE) across it.
			modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
			theme:				pt::Widget_Theme
		      }
		    = 
		    {	note_site  site;
			#
		        ();
		    };

		fun key_event_fn
		      {
			id:				iul::Id,						# Unique id.
			key_event:			gt::Key_Event,						# KEY_PRESS or KEY_RELEASE.
			keycode:			evt::Keycode,						# Keycode of the depressed key.
			keysym:				evt::Keysym,						# Keysym  of the depressed key.
			string:				String,							# Ascii  for the depressed key.
			event_point:			g2d::Point,
			site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
			theme:				pt::Widget_Theme
		      }
		    = 
		    {	note_site  site;
			#
		       ();
		    };


		#
		# End of widget hook fn section
		###############################

		widget_options
		  =
		  [ wi::STARTUP_FN			startup_fn,
		    wi::SHUTDOWN_FN			shutdown_fn,
		    wi::INITIALIZE_GADGET_FN		initialize_gadget_fn,
		    wi::REDRAW_GADGET_REQUEST_FN	redraw_gadget_request_fn,
		    wi::MOUSEBUTTON_FN			mousebutton_fn,
		    wi::KEY_EVENT_FN			key_event_fn,
		    wi::MOUSE_TRANSIT_FN		mouse_transit_fn,
		    wi::MOUSE_DRAG_FN			mouse_drag_fn
		  ]
		  @
		  widget_options
		  ;

		make_widget_fn =  wi::make_widget_start_fn  widget_options;

		( gt::WIDGET   make_widget_fn								# So caller can write   gui_plan = (widgetspace_options, gt::ROW [ frame::with [...], frame::with [...], ... ]);
		);
	    };													# fun with() 
    };
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1994 by AT&T Bell Laboratories  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2014,
## released per terms of SMLNJ-COPYRIGHT.
