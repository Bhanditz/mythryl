# frame.pkg
#
# See also:
#     src/lib/x-kit/widget/leaf/frame.pkg
#     src/lib/x-kit/widget/leaf/diamondbutton.pkg
#     src/lib/x-kit/widget/leaf/roundbutton.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib





###                "The problem is to compress a room full
###                 of digital computation equipment into
###                 the size of a suitcase, then a shoe box,
###                 and finally small enough to hold in the
###                 palm of the hand."
###                                    -- Jack Staller, 1959

# This package gets used in:
#
#     

stipulate
    include package   threadkit;						# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    include package   geometry2d;						# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    #
#   package xc  =  xclient;							# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
    #
#   package d3  =  three_d;							# three_d			is from   src/lib/x-kit/widget/old/lib/three-d.pkg

    package evt =  gui_event_types;						# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
#   package b2g =  guiboss_to_gadget;						# guiboss_to_gadget		is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg
#   package g2g =  gadget_to_guiboss;						# gadget_to_guiboss		is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
    package g2p =  gadget_to_pixmap;						# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg
    package gd  =  gui_displaylist;						# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    package gt  =  guiboss_types;						# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
    package wt  =  widget_theme;						# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg
    package r8  =  rgb8;							# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;								# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package w2p =  widget_to_widgetspace;					# widget_to_widgetspace		is from   src/lib/x-kit/widget/space/widget/look-to-widget.pkg
    package wi  =  widget_imp;							# widget_imp			is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
    package g2d =  geometry2d;							# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;						# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg
    package mtx =  rw_matrix;							# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
    package pp  =  standard_prettyprint_mill;					# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package gws =  guiboss_to_windowsystem;					# guiboss_to_windowsystem	is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg

    package iul =  issue_unique_look_id;					# issue_unique_look_id		is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    nb =  log::note_on_stderr;							# log				is from   src/lib/std/src/log.pkg
herein

    package frame
    :	    Frame								# Frame			is from   src/lib/x-kit/widget/leaf/frame.api
    {
	package t {								# "t" for "type"
	    #
	    Button_Type		= MOMENTARY_CONTACT
				| PUSH_ON_PUSH_OFF
				;
	};

	App_To_Frame
	  =
	  { get_active:			Void -> Bool,
	    get_state:			Void -> Bool,
	    #
	    get_button_relief:		Void -> wt::Relief,			# 
	    get_button_type:		Void -> t::Button_Type,			# 
	    #
	    set_active_to:		Bool -> Void,
	    set_state_to:		Bool -> Void,				# Also calls gadget_to_guiboss.needs_redraw_gadget_request(id);
	    set_button_relief_to:	wt::Relief -> Void			# Also calls gadget_to_guiboss.needs_redraw_gadget_request(id);
	  };


	Redraw_Request_Fn_Arg
	    =
	    REDRAW_REQUEST_FN_ARG
	      {
		id:				iul::Id,			# Unique id.
		frame_number:			Int,				# 1,2,3,... Purely for convenience of widget, guiboss-imp makes no use of this.
		site:				g2d::Box,			# Window rectangle in which to draw.
		visible:			Bool,				# If FALSE, widget is not visible on screen, so look-imp may be able to avoid updating foreground and background.
		duration_in_seconds:		Float,				# If state has changed look-imp should call note_changed_gadget_foreground() before this time is up. Also useful for motionblur.
		gadget_to_guiboss:		gt::Gadget_To_Guiboss,
		widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
		this_gadget_mode:		gt::Gadget_Mode,
		outer_margin_in_pixels:		Int,
		inner_margin_in_pixels:		Int,
		frame_width_in_pixels:		Int,
		theme:				wt::Widget_Theme,
		#
		default_redraw_request_fn:	Redraw_Request_Fn,
		#
		button_state:			Bool,				# Is the button ON or OFF?
		button_type:			t::Button_Type,			# Is the button push-on-push-off or momentary-contact?
		button_relief:			wt::Relief			# Is the button outline a slope, a ridge, or a flat band?
	      }
	withtype
	Redraw_Request_Fn
	  =
	  Redraw_Request_Fn_Arg
	  ->
	  { displaylist:		gd::Gui_Displaylist,
	    point_in_gadget:		Null_Or(g2d::Point -> Bool)		# 
	  }
	  ;



	Mousebutton_Fn_Arg
	    =
	    MOUSEBUTTON_FN_ARG							# Needs to be a sumtype because of recursive reference in default_mousebutton_fn.
	      { id:				iul::Id,			# Unique id.
		event:				gt::Mousebutton_Event,		# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE.
		button:				evt::Mousebutton,		# Which mousebutton was pressed/released.
		point:				g2d::Point,			# Where the mouse was.
		site:				g2d::Box,			# Widget's assigned area in window coordinates.
		modifier_keys_state:		evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
		mousebuttons_state:		evt::Mousebuttons_State,	# State of mouse buttons as a bool record.
		gadget_to_guiboss:		gt::Gadget_To_Guiboss,
		widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
		theme:				wt::Widget_Theme,
		#
		default_mousebutton_fn:		Mousebutton_Fn,
		#
		button_state:			Bool,				# Is the button ON or OFF?
		button_type:			    t::Button_Type,		# Is the button push-on-push-off or momentary-contact?
		button_relief:			Ref(wt::Relief),		# Is the button outline a slope, a ridge, or a flat band?
		#
		initial_state:			Bool,				# Original state of button.
		note_state:			Bool -> Void,			# Change state of button. This takes care of notifying our state-watchers.
		needs_redraw_gadget_request:	Void -> Void			# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
	      }
	withtype
	Mousebutton_Fn = Mousebutton_Fn_Arg -> Void;



	Mouse_Drag_Fn_Arg
	    =
	    MOUSE_DRAG_FN_ARG
	      {
		id:				iul::Id,			# Unique id.
		event_point:			g2d::Point,
		start_point:			g2d::Point,
		last_point:			g2d::Point,
		site:				g2d::Box,			# Widget's assigned area in window coordinates.
		phase:				gt::Drag_Phase,	
		modifier_keys_state:	        evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
		mousebuttons_state:		evt::Mousebuttons_State,	# State of mouse buttons as a bool record.
		gadget_to_guiboss:		gt::Gadget_To_Guiboss,
		widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
		theme:				wt::Widget_Theme,
		#
		default_mouse_drag_fn:		Mouse_Drag_Fn,
		#
		button_state:			Bool,				# Is the button ON or OFF?
		button_type:			    t::Button_Type,		# Is the button push-on-push-off or momentary-contact?
		button_relief:			Ref(wt::Relief),		# Is the button outline a slope, a ridge, or a flat band?
		#
		initial_state:			Bool,				# Original state of button.
		note_state:			Bool -> Void,			# Change state of button. This takes care of notifying our state-watchers.
		needs_redraw_gadget_request:	Void -> Void			# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
	      }
	withtype
	Mouse_Drag_Fn =  Mouse_Drag_Fn_Arg -> Void;



	Mouse_Transit_Fn_Arg							# Note that buttons are always all up in a mouse-transit event -- otherwise it is a mouse-drag event.
	    =
	    MOUSE_TRANSIT_FN_ARG
	      {
		id:				iul::Id,			# Unique id.
		event_point:			g2d::Point,
		site:				g2d::Box,			# Widget's assigned area in window coordinates.
		transit:			gt::Gadget_Transit,		# Mouse is entering (CAME) or leaving (LEFT) widget, or moving (MOVE) across it.
		modifier_keys_state:	        evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
		gadget_to_guiboss:		gt::Gadget_To_Guiboss,
		widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
		theme:				wt::Widget_Theme,
		#
		default_mouse_transit_fn:	Mouse_Transit_Fn,
		#
		button_state:			Bool,				# Is the button ON or OFF?
		button_type:			    t::Button_Type,		# Is the button push-on-push-off or momentary-contact?
		button_relief:			Ref(wt::Relief),		# Is the button outline a slope, a ridge, or a flat band?
		#
		initial_state:			Bool,				# Original state of button.
		note_state:			Bool -> Void,			# Change state of button. This takes care of notifying our state-watchers.
		needs_redraw_gadget_request:	Void -> Void			# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
	      }
	withtype
	Mouse_Transit_Fn =  Mouse_Transit_Fn_Arg -> Void;



	Key_Event_Fn_Arg
	    =
	    KEY_EVENT_FN_ARG
	      {
		id:				iul::Id,			# Unique id.
		key_event:			gt::Key_Event,			# KEY_PRESS or KEY_RELEASE
		keycode:			evt::Keycode,			# Keycode of the depressed key.
		keysym:				evt::Keysym,			# Keysym  of the depressed key.
		string:				String,				# Ascii  for the depressed key.
		event_point:			g2d::Point,
		site:				g2d::Box,			# Widget's assigned area in window coordinates.
		modifier_keys_state:	        evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
		mousebuttons_state:		evt::Mousebuttons_State,	# State of mouse buttons as a bool record.
		gadget_to_guiboss:		gt::Gadget_To_Guiboss,
		widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
		theme:				wt::Widget_Theme,
		#
		default_key_event_fn:		Key_Event_Fn,
		#
		button_state:			Bool,				# Is the button ON or OFF?
		button_type:			    t::Button_Type,		# Is the button push-on-push-off or momentary-contact?
		button_relief:			Ref(wt::Relief),		# Is the button outline a slope, a ridge, or a flat band?
		#
		initial_state:			Bool,				# Original state of button.
		note_state:			Bool -> Void,			# Change state of button. This takes care of notifying our state-watchers.
		needs_redraw_gadget_request:	Void -> Void			# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
	      }
	withtype
	Key_Event_Fn =  Key_Event_Fn_Arg -> Void;



	Option	= PIXELS_SQUARE		Int
		#
		| PIXELS_HIGH_MIN	Int
		| PIXELS_WIDE_MIN	Int
		#
		| PIXELS_HIGH_CUT	Float
		| PIXELS_WIDE_CUT	Float
		#
		| INITIAL_STATE		Bool
		| INITIALLY_ACTIVE	Bool
		#
		| MOMENTARY_CONTACT						# State is non-default (opposite of INITIAL_STATE) only between mouse downclick and upclick.
		| PUSH_ON_PUSH_OFF						# Mouse downclicks toggle state between TRUE and FALSE.
		#
		| OUTER_MARGIN_IN_PIXELS	Int
		| INNER_MARGIN_IN_PIXELS	Int
		| FRAME_WIDTH_IN_PIXELS		Int
		#
		| RELIEF		wt::Relief				# Should button boundary be drawn flat, raised, sunken, ridged or grooved?
		| MARGIN		Int					# How many pixels to inset button relative to its assigned window site.  Default is 4.
		| THICK			Int					# Thickness of lines (well, polygons) forming button.  Default is 5.
		| TEXT			String					# Text label to draw inside button.  Default is "".
		| FONT			List(String)				# Font to use for text label, e.g. "-*-courier-bold-r-*-*-20-*-*-*-*-*-*-*".  We'll use the first font in list which is found on X server, else "9x15" (which X guarantees to have).
		#
		| REDRAW_REQUEST_FN	Redraw_Request_Fn			# Application-specific handler for widget redraw.
		| MOUSEBUTTON_FN	Mousebutton_Fn				# Application-specific handler for mousebutton clicks.
		| MOUSE_DRAG_FN		Mouse_Drag_Fn				# Application-specific handler for mouse drags.
		| MOUSE_TRANSIT_FN	Mouse_Transit_Fn			# Application-specific handler for mouse crossings.
		| KEY_EVENT_FN		Key_Event_Fn				# Application-specific handler for keyboard input.
		#
		| STATE_WATCHER		(Bool -> Void)				# Widget's current state              will be sent to these fns each time state changes.
		| PORT_WATCHER		(App_To_Frame -> Void)  		# Widget's app port                   will be sent to these fns at widget startup.
		| SITE_WATCHER		(g2d::Box -> Void)			# Widget's site in window coordinates will be sent to these fns each time it changes.
		| POPUP_WATCHER		((g2d::Box, gt::Gui_Plan)
							    -> ( g2d::Box,
                                                                 gt::Client_To_Guiwindow
                                                               )
					) -> Void
		;								# To help prevent deadlock, watcher fns should be fast and nonblocking, typically just setting a var or entering something into a mailqueue.
		
	fun process_options
	    ( options: List(Option),
	      #
	      {	button_type,
		#
		relief,
		margin,
		thick,
		text,
		font,
		#
		outer_margin_in_pixels,
		inner_margin_in_pixels,
		frame_width_in_pixels,
		#
		mousebutton_fn,
		redraw_request_fn,
		mouse_drag_fn,
		mouse_transit_fn,
		key_event_fn,
		#
		initial_state,
		initially_active,
		#
		widget_options,
	        #
		port_watchers,
		state_watchers,
		popup_watchers,
		site_watchers
	      }
	    )
	    =
	    {   my_button_type		=  REF  button_type;
		#
		my_relief		=  REF  relief;
		my_margin		=  REF  margin;
		my_thick		=  REF  thick;
		my_text			=  REF  text;
		my_font			=  REF  font;
		#
		my_outer_margin_in_pixels	=  REF  outer_margin_in_pixels;
		my_inner_margin_in_pixels	=  REF  inner_margin_in_pixels;
		my_frame_width_in_pixels	=  REF  frame_width_in_pixels;
		#
		my_mousebutton_fn	=  REF  mousebutton_fn;
		my_redraw_request_fn	=  REF  redraw_request_fn;
		my_mouse_drag_fn	=  REF  mouse_drag_fn;
		my_mouse_transit_fn	=  REF  mouse_transit_fn;
		my_key_event_fn		=  REF  key_event_fn;
		#
		my_initial_state	=  REF  initial_state;
		my_initially_active	=  REF  initially_active;
		#
		my_widget_options	=  REF  widget_options;
		#
		my_port_watchers	=  REF  port_watchers;
		my_state_watchers	=  REF  state_watchers;
		my_site_watchers	=  REF  site_watchers;
		my_popup_watchers	=  REF  popup_watchers;
		#

		apply  do_option  options
		where
		    fun do_option (INITIAL_STATE		b) =>   my_initial_state	:=  b;
			do_option (INITIALLY_ACTIVE		b) =>   my_initially_active	:=  b;
			#
			do_option (MOMENTARY_CONTACT		 ) =>   my_button_type		:=  t::MOMENTARY_CONTACT;
			do_option (PUSH_ON_PUSH_OFF		 ) =>   my_button_type		:=  t::PUSH_ON_PUSH_OFF;
			#
			do_option (RELIEF			r) =>   my_relief		:=  r;
			do_option (MARGIN			i) =>   my_margin		:=  i;
			do_option (THICK			i) =>   my_thick		:=  i;
			do_option (TEXT				t) =>   my_text			:=  t;
			do_option (FONT				t) =>   my_font			:=  t;
			#
			do_option (OUTER_MARGIN_IN_PIXELS	i) =>   my_outer_margin_in_pixels	:=  i;
			do_option (INNER_MARGIN_IN_PIXELS	i) =>   my_inner_margin_in_pixels	:=  i;
			do_option (FRAME_WIDTH_IN_PIXELS	i) =>   my_frame_width_in_pixels	:=  i;
			#
			do_option (MOUSEBUTTON_FN		f) =>   my_mousebutton_fn	:=  f;
			do_option (REDRAW_REQUEST_FN		f) =>   my_redraw_request_fn	:=  f;
			do_option (MOUSE_DRAG_FN		f) =>	my_mouse_drag_fn	:=  THE f;
			do_option (MOUSE_TRANSIT_FN		f) =>	my_mouse_transit_fn	:=  THE f;
			do_option (KEY_EVENT_FN			f) =>	my_key_event_fn		:=  THE f;
			#
			do_option (PORT_WATCHER			c) =>	my_port_watchers	:=  c ! *my_port_watchers;
			do_option (STATE_WATCHER		c) =>	my_state_watchers	:=  c ! *my_state_watchers;
			do_option (SITE_WATCHER			c) =>	my_site_watchers	:=  c ! *my_site_watchers;
			do_option (POPUP_WATCHER		c) =>	my_popup_watchers	:=  c ! *my_popup_watchers;
			#
			#
			do_option (PIXELS_HIGH_MIN		i) =>   my_widget_options	:=  (wi::PIXELS_HIGH_MIN i) ! *my_widget_options;
			do_option (PIXELS_WIDE_MIN		i) =>   my_widget_options	:=  (wi::PIXELS_WIDE_MIN i) ! *my_widget_options;
			#
			do_option (PIXELS_HIGH_CUT		f) =>   my_widget_options	:=  (wi::PIXELS_HIGH_CUT f) ! *my_widget_options;
			do_option (PIXELS_WIDE_CUT		f) =>   my_widget_options	:=  (wi::PIXELS_WIDE_CUT f) ! *my_widget_options;
			#
			do_option (PIXELS_SQUARE		i) =>   my_widget_options	:=  (wi::PIXELS_HIGH_MIN   i)
												!   (wi::PIXELS_WIDE_MIN   i)
												!   (wi::PIXELS_HIGH_CUT 0.0)
												!   (wi::PIXELS_WIDE_CUT 0.0)
												!   *my_widget_options;
		    end;
		end;

		{ button_type		=>  *my_button_type,
		  #
		  relief		=>  *my_relief,
		  margin		=>  *my_margin,
		  thick			=>  *my_thick,
		  text			=>  *my_text,
		  font			=>  *my_font,
		  #
		  outer_margin_in_pixels	=>  *my_outer_margin_in_pixels,
		  inner_margin_in_pixels	=>  *my_inner_margin_in_pixels,
		  frame_width_in_pixels		=>  *my_frame_width_in_pixels,
		  #
		  redraw_request_fn	=>  *my_redraw_request_fn,
		  mousebutton_fn	=>  *my_mousebutton_fn,
		  mouse_drag_fn		=>  *my_mouse_drag_fn,
		  mouse_transit_fn	=>  *my_mouse_transit_fn,
		  key_event_fn		=>  *my_key_event_fn,
		  #
		  initial_state		=>  *my_initial_state,
		  initially_active	=>  *my_initially_active,
		  #
		  widget_options	=>  *my_widget_options,
		  #
		  port_watchers		=>  *my_port_watchers,
		  state_watchers	=>  *my_state_watchers,
		  popup_watchers	=>  *my_popup_watchers,
		  #	
		  site_watchers		=>  *my_site_watchers
		};
	    };


	offset = 1;

	fun with (options: List(Option))								# PUBLIC
	    =
	    {
		thickref  = REF 5;									# Thickness for lines delineating the box.  We need this little REF hack
													# because default_redraw_request_fn is an input to process_options() but 'thick'
													# is an output from process_options(), so something has to give a bit.

		reliefref = REF wt::RAISED;								# Same story.
		marginref = REF 4;									# Same story.

		textref   = REF "";									# Same story.

		fontref   = REF [ ];									# Same story.

		fun default_redraw_request_fn
		    (
		      REDRAW_REQUEST_FN_ARG
		      {
			id:				iul::Id,					# Unique id.
			frame_number:			Int,						# 1,2,3,... Purely for convenience of widget, guiboss-imp makes no use of this.
			site:				g2d::Box,					# Window rectangle in which to draw.
			visible:			Bool,						# If FALSE, widget is not visible on screen, so look-imp may be able to avoid updating foreground and background.
			duration_in_seconds:		Float,						# If state has changed look-imp should call note_changed_gadget_foreground() before this time is up. Also useful for motionblur.
			gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
			this_gadget_mode:		gt::Gadget_Mode,
			outer_margin_in_pixels:		Int,
			inner_margin_in_pixels:		Int,
			frame_width_in_pixels:		Int,
			theme:				wt::Widget_Theme,
			#
			default_redraw_request_fn:	Redraw_Request_Fn,
			#
			button_state:			Bool,						# Is the button ON or OFF?
			button_type:			t::Button_Type,					# Is the button push-on-push-off or momentary-contact?
			button_relief:			wt::Relief					# Is the button outline a slope, a ridge, or a flat band?
		      }
		    )
		    =
		    {
			stipulate												# then carefully work through the code here based on that.  XXX SUCKO FIXME.
			    inset = outer_margin_in_pixels + frame_width_in_pixels;
			herein
			    fun frame_vertices ({ row, col, wide, high }: g2d::Box)						#
				    = 												#
				    [ { col=> col + inset - 1,        row=> row + inset		   },				# upper-left
				      { col=> col + inset - 1,        row=> row + high - (inset+1) },				# lower-left
				      { col=> col + wide - (inset+1), row=> row + high - (inset+1) },				# lower-right
				      { col=> col + wide - (inset+1), row=> row + inset		   }				# upper-right
				    ];
			end;

			(*theme.current_gadget_colors { gadget_is_on => TRUE, gadget_mode  => this_gadget_mode })
			    ->
			    (gadget_palette:	wt::Gadget_Palette);

			background_box =  site;

			foreground_indent = outer_margin_in_pixels
					  + inner_margin_in_pixels
					  + frame_width_in_pixels
					  ;	
			foreground_box    =  g2d::box::make_nested_box (background_box, foreground_indent);			# This is the window area reserved for the widgets we're framing.

			background_displaylist 											# The 'background' for the frame is the part not covered by the 3d polygon.
			    =													# In particular, we do NOT want to draw over the inner rectangle reserved
			    [ gd::COLOR												# for the widgets within the frame.
				(
				  gadget_palette.surround_color,
				  #
				  [ gd::FILLED_BOXES (g2d::box::subtract_box_b_from_box_a
						       {
							 a => background_box,
							 b => foreground_box
						       }
						     )
				  ]
				)
			    ];

			points =  frame_vertices  background_box;

			foreground_displaylist
			    =
			    (*theme.polygon3d gadget_palette
			      {
				points,
				thick => frame_width_in_pixels,
				relief => button_relief
			      }
			    );


			stipulate
			    frame_outer_limit =  g2d::box::make_nested_box (background_box, outer_margin_in_pixels                        );
			    frame_inner_limit =  g2d::box::make_nested_box (background_box, outer_margin_in_pixels + frame_width_in_pixels);
			herein
			    fun point_in_gadget (point: g2d::Point)								# A fn which will return TRUE iff the point is on the 3d frame itself, not the surround -- much less the inner widgets.
				=
				(    (g2d::point_in_polygon (point, g2d::box::to_points frame_outer_limit)))  and
				(not (g2d::point_in_polygon (point, g2d::box::to_points frame_inner_limit)));
			end;

			point_in_gadget =  THE  point_in_gadget;
			displaylist     =  background_displaylist @ foreground_displaylist;

			{ displaylist, point_in_gadget };



#			stipulate
#			    offset = 1;
#			herein
#			    fun box_vertices ({ row, col, wide, high }: g2d::Box)		#   /\		
#				= 									#  ----
#				[ { col=> col + wide / 2,    row=> row + offset - 1  },
#				  { col=> col + offset - 1,  row=> row + high-offset },
#				  { col=> col + wide-offset, row=> row + high-offset }
#				];
#			end;
#
#			point_in_gadget = NULL;
#
#			(*theme.current_gadget_colors { gadget_is_on => button_state, gadget_mode  => this_gadget_mode })
#			    ->
#			    (p: wt::Gadget_Palette);
#
#			background_box =  site;
#
#			background = [ gd::COLOR (p.surround_color,  [ gd::FILLED_BOXES [ background_box ]]) ];
#
#
#			stipulate
#			    inner_box = g2d::box::make_nested_box (background_box, *marginref);				# 
#			herein
#
#
#			    points =  box_vertices  inner_box;
#
#			    outline =  *theme.polygon3d p { points, thick => *thickref, relief => button_relief };
#
#			    text    =   [ gd::FONT ( *fontref @ [ "9x15" ],
#						     [ gd::DRAW_TEXT  ( gd::CENTERED_ON_POINT,
#									[ gd::TEXT (g2d::point::mean points, *textref) ]
#								      )
#						     ]
#						   )
#					];
#
#			    displaylist =   case *textref
#						#
#						"" =>  outline;
#						t  =>  outline  @  text;
#					    esac;
#
#
#			    foreground = displaylist;
#
#			    convex_hull = g2d::convex_hull (gd::find_all_points_in_gui_displaylist  outline);
#
#			    fun point_in_gadget (point: g2d::Point)
#				=
#				g2d::point_in_polygon (point, convex_hull);
#
#			    point_in_gadget = THE point_in_gadget;
#			end;
#
#			{ displaylist => background @ foreground, point_in_gadget };
		    };

		fun default_mousebutton_fn
		    (
		      MOUSEBUTTON_FN_ARG
		      { id:				iul::Id,						# Unique id.
			event:				gt::Mousebutton_Event,					# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE.
			button:				evt::Mousebutton,
			point:				g2d::Point,
			site:				g2d::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
			theme:				wt::Widget_Theme,
			#
			default_mousebutton_fn:		Mousebutton_Fn_Arg -> Void,
			#
			button_state:			Bool,
			button_type:			    t::Button_Type,
			button_relief:			Ref(wt::Relief),
			#
			initial_state:			Bool,
			note_state:			Bool -> Void,
			needs_redraw_gadget_request:	Void -> Void
		      }:				Mousebutton_Fn_Arg
		    )
		    =
		    {
			case event
			    #
			    gt::MOUSEBUTTON_PRESS
				=>
				{	
				    note_state  (not button_state);
				    needs_redraw_gadget_request ();
				};

			    gt::MOUSEBUTTON_RELEASE
				=>
				{
				    if (button_type == t::MOMENTARY_CONTACT)
					#
					note_state  initial_state;
					needs_redraw_gadget_request ();
				    fi;
				};
			esac;

			();
		    };

	        (process_options
		  (
		    options,
		    #
		    { button_type	=>      t::PUSH_ON_PUSH_OFF,
		      #	
		      relief		=>  *reliefref,	
		      margin		=>  *marginref,
		      thick		=>  *thickref,
		      text		=>  *textref,
		      font		=>  *fontref,
		      #
		      outer_margin_in_pixels	=>  2,								# where the sum (9) is hardwired as 'indent'.  Yes, this sucks -- feel free to contribute a clean fix.  XXX SUCKO FIXME.
		      frame_width_in_pixels	=>  5,								# polygon3d result will probably look odd if this is not an odd number.
		      inner_margin_in_pixels	=>  2,								#
		      #
		      mousebutton_fn	=>  default_mousebutton_fn,
		      redraw_request_fn	=>  default_redraw_request_fn,
		      mouse_drag_fn	=>  NULL,
		      mouse_transit_fn	=>  NULL,
		      key_event_fn	=>  NULL,
		      #
		      initial_state	=>  FALSE,
		      initially_active	=>  TRUE,
		      #
		      widget_options	=>  [],
		      #
		      port_watchers	=>  [],
		      state_watchers	=>  [],
		      popup_watchers	=>  [],
		      site_watchers	=>  []
		    }
		) )
		    ->
		    {												# These values are globally visible to the subsequenc fns, which can lock them in as needed.
		      button_type,
		      #
		      relief,
		      margin,
		      thick,
		      text,
		      font,
		      #
		      outer_margin_in_pixels,
		      inner_margin_in_pixels,
		      frame_width_in_pixels,
		      #
		      mousebutton_fn,
		      redraw_request_fn,
		      mouse_drag_fn,
		      mouse_transit_fn,
		      key_event_fn,
		      #
		      initial_state,
		      initially_active,
		      #
		      widget_options,
		      #
		      port_watchers,
		      state_watchers,
		      popup_watchers,
		      #
		      #
		      site_watchers
		    };

		thickref  := thick;
		reliefref := relief;
		marginref := margin;
		textref   := text;
		fontref   := font;


		###############################
		# Top of state variable section
		#

		gadget_to_guiboss__global
		    =
		    REF (NULL:  Null_Or((gt::Gadget_To_Guiboss, iul::Id)));

		fun note_changed_gadget_activity (is_active: Bool)
		    =
		    case (*gadget_to_guiboss__global)
			#
			THE (gt::GADGET_TO_GUIBOSS gadget_to_guiboss, id)	=>  gadget_to_guiboss.note_changed_gadget_activity { id, is_active };
			NULL							=>  ();
		    esac;

		fun needs_redraw_gadget_request ()
		    =
		    case (*gadget_to_guiboss__global)
			#
			THE (gt::GADGET_TO_GUIBOSS gadget_to_guiboss, id)	=>  gadget_to_guiboss.needs_redraw_gadget_request(id);
			NULL							=>  ();
		    esac;


		last_known_site
		    =
		    REF ( { col => -1,  wide => -1,
			    row => -1,  high => -1
			  }:				g2d::Box
			);

		button_state  =  REF initial_state;


		button_active
		    =
		    REF initially_active;


		exception SAVED_STATE { last_known_site:	g2d::Box,					# Here we're doing the usual hack of using Exception as an extensible datatype -- nothing to do with actually raising or trapping exceptions.
					button_state:		Bool,
					button_active:		Bool
				      };	


		fun note_site (site: g2d::Box)
		    =
		    if(*last_known_site != site)
			last_known_site := site;
			#
			apply notify_watcher site_watchers
			    where
				fun notify_watcher site_watcher
				    =
				    site_watcher site;
			    end;
		    fi;

		fun note_state (state: Bool)
		    =
		    if(*button_state != state)
			button_state := state;
			#
			apply notify_watcher state_watchers
			    where
				fun notify_watcher state_watcher
				    =
				    state_watcher state;
			    end;
		    fi;

		Make_Popup
		    =
		    ( g2d::Box,											# Requested site for popup.
		      gt::Gui_Plan										# GUI to run in popup.
		    )
		      -> ( g2d::Box,										# Actual site for popup.
			   gt::Client_To_Guiwindow								# Port allowing popup to be closed down etc.
			 );

		fun note_popup_maker (make_popup: Make_Popup)
		    =
		    apply notify_watcher popup_watchers
			where
			    fun notify_watcher popup_watcher
				=
				popup_watcher make_popup;
			end;

		#
		# End of state variable section
		###############################


		#####################
		# Top of port section
		#
		# Here we implement our App_To_Frame port:

		fun set_active_to (is_active: Bool)
		    =
		    {   button_active :=  is_active;
			#
			note_changed_gadget_activity  is_active;
		    };

		fun set_state_to (state: Bool)
		    =
		    {   note_state state;
			#
			needs_redraw_gadget_request ();
		    };

		fun set_button_relief_to (relief: wt::Relief)
		    =
		    {
			reliefref := relief;
			#
			needs_redraw_gadget_request ();
		    };

		fun get_active ()
		    =
		    *button_active;

		fun get_state ()
		    =
		    *button_state;

		fun get_button_relief ()
		    =
		    *reliefref;

		fun get_button_type ()
		    =
		    button_type;

		app_to_frame
		  =
		  { get_active,
		    get_state,
		    get_button_relief,
		    get_button_type,
		    #
		    set_active_to,
		    set_state_to,
		    set_button_relief_to
		  }
		  : App_To_Frame
		  ;

		#
		# End of port section
		#####################


		###############################
		# Top of widget hook fn section
		#
		# These fns get called by widget_imp logic, ultimately						# widget_imp		is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
		# in response to user mouseclicks and keypresses etc:

		fun startup_fn
		    { 
		      id:				iul::Id,						# Unique id.
		      gadget_to_guiboss:		gt::Gadget_To_Guiboss,
		      widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
		      saved_widget_state:		Null_Or(Exception)
		    }
		    =
		    {	gadget_to_guiboss__global
			    :=  
			    THE (gadget_to_guiboss, id);

			case saved_widget_state
			    #
			    THE (SAVED_STATE r)									# Widget is being restarted after an earlier run.
				=>
				{ last_known_site   := r.last_known_site;					# Restore saved state.
				  button_state	    := r.button_state;
				  button_active	    := r.button_active;
				};

			    THE _ =>										# This shouldn't happen; guiboss_imp must have mistakenly given us another widget's saved state. (Type system cannot prevent this.)
				{   msg = "Wrong saved state! -- startup_fn in frame.pkg";
				    log::fatal           msg;							# log			is from   src/lib/std/src/log.pkg
				    raise exception FAIL msg;							# Previous won't return, but type does not (yet?) indicate that properly.
				};

			    NULL => ();										# No saved state: We must be newly created in a fresh session.
			esac;

			apply   notify_watcher  port_watchers							# We do this here rather than (say) above this fn because we don't want the port in circulation until we're running.
				where
				    fun notify_watcher  port_watcher
					=
					port_watcher  app_to_frame;
				end;
			();
		    };

		fun shutdown_fn ()										# Return to widget_imp an exception packaging up our state; this will be returned to guiboss_imp, saved in the
		    =												# Paused_Gui tree, and passed to our startup_fn when/if gui is restarted. This exception will never be raised;
		    THE (SAVED_STATE  { last_known_site	=> *last_known_site,					# Exception is being used here purely as an extensible datatype.
					button_state	=> *button_state,
					button_active	=> *button_active
				      }	
		        );

		fun initialize_gadget_fn
		    {
		      id:				iul::Id,						# Unique id.
		      site:				g2d::Box,						# Window rectangle in which to draw.
		      gadget_to_guiboss:		gt::Gadget_To_Guiboss,
		      widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
		      theme:				wt::Widget_Theme,
		      pass_font:			List(String) -> Replyqueue
								     -> (evt::Font -> Void) -> Void,		# Nonblocking version of next, for use in imps.
		       get_font:			List(String) ->	 evt::Font,				# Accepts a list of font names which are tried in order.
		      make_rw_pixmap:			g2d::Size -> g2p::Gadget_To_Rw_Pixmap,
		      #
		      make_popup:			(g2d::Box, gt::Gui_Plan)
							    -> ( g2d::Box,
                                                                 gt::Client_To_Guiwindow
                                                               )
		    }
		    =
		    {	note_site site;
			note_popup_maker make_popup;
# rw_pixmap = make_rw_pixmap { wide => 100, high => 100 };
# nb {. "initialize_gadget_fn setting a scratch_rw_pixmap refcell... -- frame.pkg"; };
# scratch_rw_pixmap := THE rw_pixmap;
# rw_pixmap.draw_displaylist [ gd::COLOR (r64::yellow, [ gd::FILLED_BOXES [ { row => 0, col => 0, high => 100, wide => 100 } ] ] ) ];
			();
		    };

		fun redraw_request_fn_wrapper
		    {
		      id:							iul::Id,			# Unique id.
		      frame_number:						Int,				# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
		      site:							g2d::Box,			# Window rectangle in which to draw.
		      visible:							Bool,				# If FALSE, widget is not visible on screen, so widget-imp may be able to avoid updating foreground and background.
		      duration_in_seconds:					Float,				# If state has changed widget-imp should call redraw_gadget() before this time is up. Also useful for motionblur.
		      gadget_to_guiboss as gt::GADGET_TO_GUIBOSS g2g:		gt::Gadget_To_Guiboss,
		      widget_to_widgetspace:					w2p::Widget_To_Widgetspace,
		      this_gadget_mode:						gt::Gadget_Mode,
		      theme:							wt::Widget_Theme
		    }
		    =
		    {	note_site site;
			#
			redraw_request_fn_arg
			    =
			    REDRAW_REQUEST_FN_ARG
			      { id,
				frame_number,
				site,
				visible,
				duration_in_seconds,
				gadget_to_guiboss,
				widget_to_widgetspace,
				this_gadget_mode,
				outer_margin_in_pixels,
				inner_margin_in_pixels,
				frame_width_in_pixels,
				theme,
				#
				default_redraw_request_fn,	
				#
				button_state     => *button_state,
				button_type,
				button_relief    => *reliefref
			      };

			(redraw_request_fn  redraw_request_fn_arg)
			    ->
			    { displaylist, point_in_gadget };

			g2g.redraw_gadget { id, displaylist, point_in_gadget };
		    };


		fun mousebutton_fn_wrapper									# This a callback we hand to   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
		      {
			id:				iul::Id,						# Unique id.
			event:				gt::Mousebutton_Event,					# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE.
			button:				evt::Mousebutton,
			point:				g2d::Point,
			site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
			theme:				wt::Widget_Theme
		      }
		    = 
		    {	note_site  site;
			#
			mousebutton_fn_arg
			    =
			    MOUSEBUTTON_FN_ARG
			      {
				id,
				event,
				button,
				point,
				site,
				modifier_keys_state,
				mousebuttons_state,
				gadget_to_guiboss,
				widget_to_widgetspace,
				theme,
				#
				default_mousebutton_fn,
				#
				button_state	=> *button_state,						# We don't pass the refcell here because we want client code to make state changes via note_state(), which will properly notify all state-watchers.
				button_type,
				button_relief	=>  reliefref,
				#
				initial_state,
				note_state,
				needs_redraw_gadget_request
			      };

			mousebutton_fn  mousebutton_fn_arg;
		    };

		fun mouse_drag_fn_wrapper									# This a callback we hand to   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
		    (
		      {	id:				iul::Id,						# Unique id.
			event_point:			g2d::Point,
			start_point:			g2d::Point,
			last_point:			g2d::Point,
			site:				g2d::Box,						# Widget's assigned area in window coordinates.
			phase:				gt::Drag_Phase,	
			modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
			theme:				wt::Widget_Theme
		      }
		    )
		    = 
		    {	note_site  site;
			#
			mouse_drag_fn_arg
			    =
			    MOUSE_DRAG_FN_ARG
			      {
				id,
				event_point,
				start_point,
				last_point,
				site,
				phase,
				modifier_keys_state,
				mousebuttons_state,
				gadget_to_guiboss,
				widget_to_widgetspace,
				theme,
				#
				default_mouse_drag_fn =>  \\ _ = (),						# Default drag behavior for buttons is to do absolutely nothing.
				#
				button_state	=> *button_state,						# We don't pass the refcell here because we want client code to make state changes via note_state(), which will properly notify all state-watchers.
				button_type,
				button_relief	=>  reliefref,
				#
				initial_state,
				note_state,
				needs_redraw_gadget_request
			      };

			case mouse_drag_fn
			    #
			    THE mouse_drag_fn =>   mouse_drag_fn  mouse_drag_fn_arg;
			    NULL	      =>   ();								# We do not expect this case to happen: If mouse_drag_fn is NULL mouse_drag_fn_wrapper should not have been registered with widget-imp so we should never get called.
			esac;
		    };

		fun mouse_transit_fn_wrapper
		      #
		      ( arg as
			{
			  id:				iul::Id,						# Unique id.
			  event_point:			g2d::Point,
			  site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
			  transit:			gt::Gadget_Transit,					# Mouse is entering (CAME) or leaving (LEFT) widget, or moving (MOVE) across it.
			  modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			  gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			  widget_to_widgetspace:	w2p::Widget_To_Widgetspace,
			  theme:			wt::Widget_Theme
			}
		      )	
		    = 
		    {	note_site site;
			#
			mouse_transit_fn_arg
			    =
			    MOUSE_TRANSIT_FN_ARG
			      {
				id,
				event_point,
				site,
				transit,
				modifier_keys_state,
				gadget_to_guiboss,
				widget_to_widgetspace,
				theme,
				#
				default_mouse_transit_fn =>  \\ _ = (),						# Default transit behavior for buttons is to do absolutely nothing.
				#
				button_state	=> *button_state,						# We don't pass the refcell here because we want client code to make state changes via note_state(), which will properly notify all state-watchers.
				button_type,
				button_relief	=>  reliefref,
				#
				initial_state,
				note_state,
				needs_redraw_gadget_request
			      };

			case mouse_transit_fn
			    #
			    THE mouse_transit_fn =>   mouse_transit_fn  mouse_transit_fn_arg;
			    NULL	         =>   ();							# We do not expect this case to happen: If mouse_transit_fn is NULL mouse_transit_fn_wrapper should not have been registered with widget-imp so we should never get called.
			esac;

			();
		    };

		fun key_event_fn_wrapper
		      {
			id:				iul::Id,						# Unique id.
			key_event:			gt::Key_Event,						# KEY_PRESS or KEY_RELEASE.
			keycode:			evt::Keycode,						# Keycode of the depressed key.
			keysym:				evt::Keysym,						# Keysym  of the depressed key.
			string:				String,							# Ascii  for the depressed key.
			event_point:			g2d::Point,
			site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:	        evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
			theme:				wt::Widget_Theme
		      }
		    = 
		    {	note_site site;
			#
			key_event_fn_arg
			    =
			    KEY_EVENT_FN_ARG
			      {
				id,
				key_event,
				keycode,
				keysym,
				string,
				event_point,
				site,
				modifier_keys_state,
				mousebuttons_state,
				gadget_to_guiboss,
				widget_to_widgetspace,
				theme,
				#
				default_key_event_fn =>  \\ _ = (),						# Default key event behavior for buttons is to do absolutely nothing.
				#
				button_state	=> *button_state,						# We don't pass the refcell here because we want client code to make state changes via note_state(), which will properly notify all state-watchers.
				button_type,
				button_relief	=>  reliefref,
				#
				initial_state,
				note_state,
				needs_redraw_gadget_request
			      };

			case key_event_fn
			    #
			    THE key_event_fn =>   key_event_fn  key_event_fn_arg;
			    NULL	     =>   ();								# We do not expect this case to happen: If key_event_fn is NULL key_event_fn_wrapper should not have been registered with widget-imp so we should never get called.
			esac;

		       ();
		    };


		#
		# End of widget hook fn section
		###############################

		widget_options
		    =
		    case mouse_drag_fn
			#
			THE _ =>  (wi::MOUSE_DRAG_FN mouse_drag_fn_wrapper)       ! widget_options;		# Register for drag events only if we are going to use them.
			NULL  =>					            widget_options;
		    esac;

		widget_options
		    =
		    case mouse_transit_fn
			#
			THE _ =>  (wi::MOUSE_TRANSIT_FN mouse_transit_fn_wrapper) ! widget_options;		# Register for transit events only if we are going to use them.
			NULL  =>						    widget_options;
		    esac;

		widget_options
		    =
		    case key_event_fn
			#
			THE _ =>  (wi::KEY_EVENT_FN key_event_fn_wrapper)	  ! widget_options;		# Register for key events only if we are going to use them.
			NULL  =>						    widget_options;
		    esac;

		widget_options
		  =
		  [ wi::STARTUP_FN			startup_fn,						# We always register for these five because our base behavior depends on them.
		    wi::SHUTDOWN_FN			shutdown_fn,
		    wi::INITIALIZE_GADGET_FN		initialize_gadget_fn,
		    wi::REDRAW_REQUEST_FN		redraw_request_fn_wrapper,
		    wi::MOUSEBUTTON_FN			mousebutton_fn_wrapper
		  ]
		  @
		  widget_options
		  ;

		make_widget_fn =  wi::make_widget_start_fn  widget_options;

		gt::WIDGET   make_widget_fn;									# So caller can write   gui_plan = gt::ROW [ frame::with [...], frame::with [...], ... ];
	    };													# PUBLIC
    };
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1994 by AT&T Bell Laboratories  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2014,
## released per terms of SMLNJ-COPYRIGHT.
