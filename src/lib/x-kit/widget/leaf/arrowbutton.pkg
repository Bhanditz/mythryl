## arrowbutton.pkg
#

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib





###                "The problem is to compress a room full
###                 of digital computation equipment into
###                 the size of a suitcase, then a shoe box,
###                 and finally small enough to hold in the
###                 palm of the hand."
###                                    -- Jack Staller, 1959

# This package gets used in:
#
#     

stipulate
    include package   xgeometry;					# xgeometry			is from   src/lib/std/2d/xgeometry.pkg
    #
#   package xc  =  xclient;						# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
    #
#   package d3  =  three_d;						# three_d			is from   src/lib/x-kit/widget/old/lib/three-d.pkg

    package evt =  gui_event_types;					# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package g2g =  gadget_to_guiboss;					# gadget_to_guiboss		is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
    package gd  =  gui_displaylist;					# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    package gp  =  gui_plan;						# gui_plan			is from   src/lib/x-kit/widget/gui/gui-plan.pkg
    package gt  =  gui_types;						# gui_types			is from   src/lib/x-kit/widget/gui/gui-types.pkg
    package pt  =  packed_theme;					# packed_theme			is from   src/lib/x-kit/widget/theme/packed/packed-theme.pkg
    package r8  =  rgb8;						# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package w2p =  widget_to_packedspace;				# widget_to_packedspace		is from   src/lib/x-kit/widget/space/packed/look-to-packed.pkg
    package wi  =  widget_imp;						# widget_imp			is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg
    package xg  =  xgeometry;						# xgeometry			is from   src/lib/std/2d/xgeometry.pkg

    package iul =  issue_unique_look_id;				# issue_unique_look_id		is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg
    package plh =  packedspace_layout_hint;				# packedspace_layout_hint	is from   src/lib/x-kit/widget/space/packed/packedspace-layout-hint.pkg

    nb =  log::note_on_stderr;						# log				is from   src/lib/std/src/log.pkg
herein

    package arrowbutton
    :	    Arrowbutton							# Arrowbutton			is from   src/lib/x-kit/widget/leaf/arrowbutton.api
    {
	package d {							# "d" for "direction"
	    #
	    Button_Direction    = UP
				| DOWN
				| LEFT
				| RIGHT
				;
	};

	package t {							# "t" for "type"
	    #
	    Button_Type		= MOMENTARY_CONTACT
				| PUSH_ON_PUSH_OFF
				;
	};

	App_To_Arrowbutton
	  =
	  { set_active_to:		Bool -> Void,
	    set_state_to:		Bool -> Void,
	    #
	    get_active:			Void -> Bool,
	    get_state:			Void -> Bool,
	    #
	    get_button_direction:	Void -> d::Button_Direction,		# We deliberately do not provide a 'set' fn for this -- button direction should be selected at configuration time not runtime.
	    get_button_type:		Void -> t::Button_Type			# We deliberately do not provide a 'set' fn for this -- button type      should be selected at configuration time not runtime.
	  };

	Option	= UP
		| DOWN
		| LEFT
		| RIGHT
		#
		| PIXELS_SQUARE		Int
		#
		| PIXELS_HIGH_MIN	Int
		| PIXELS_WIDE_MIN	Int
		#
		| PIXELS_HIGH_CUT	Float
		| PIXELS_WIDE_CUT	Float
		#
		| INITIAL_STATE		Bool
		| INITIALLY_ACTIVE	Bool
		#
		| MOMENTARY_CONTACT						# State is TRUE only between mouse downclick and upclick.
		| PUSH_ON_PUSH_OFF						# Mouse downclicks toggle state between TRUE and FALSE.
		#
		| STATE_WATCHER		(Bool -> Void)				# Widget's current state              will be sent to these fns each time state changes.
		| PORT_WATCHER		(App_To_Arrowbutton -> Void)  		# Widget's app port                   will be sent to these fns at widget startup.
		| SITE_WATCHER		(xg::Box -> Void)			# Widget's site in window coordinates will be sent to these fns each time it changes.
		;								# To help prevent deadlock, watcher fns should be fast and nonblocking, typically just setting a var or entering something into a mailqueue.
		
	fun process_options
	    ( options: List(Option),
	      #
	      {	button_direction,
		button_type,
		#
		initial_state,
		initially_active,
		#
		packed_widget_options,
		      #
		port_watchers,
		state_watchers,
		site_watchers
	      }
	    )
	    =
	    {   my_button_direction		=  REF  button_direction;
		my_button_type			=  REF  button_type;
		#
		my_initial_state		=  REF  initial_state;
		my_initially_active		=  REF  initially_active;
		#
		my_packed_widget_options	=  REF  packed_widget_options;
		#
		my_port_watchers		=  REF  port_watchers;
		my_state_watchers		=  REF  state_watchers;
		my_site_watchers		=  REF  site_watchers;

		apply  do_option  options
		where
		    fun do_option (UP				 ) =>   my_button_direction		:=  d::UP;
			do_option (DOWN				 ) =>   my_button_direction		:=  d::DOWN;
			do_option (RIGHT			 ) =>   my_button_direction		:=  d::RIGHT;
			do_option (LEFT				 ) =>   my_button_direction		:=  d::LEFT;
			#
			do_option (INITIAL_STATE		b) =>   my_initial_state		:=  b;
			do_option (INITIALLY_ACTIVE		b) =>   my_initially_active		:=  b;
			#
			do_option (MOMENTARY_CONTACT		 ) =>   my_button_type			:=  t::MOMENTARY_CONTACT;
			do_option (PUSH_ON_PUSH_OFF		 ) =>   my_button_type			:=  t::PUSH_ON_PUSH_OFF;
			#
			do_option (PORT_WATCHER			c) =>	my_port_watchers		:=  c ! *my_port_watchers;
			do_option (STATE_WATCHER		c) =>	my_state_watchers		:=  c ! *my_state_watchers;
			do_option (SITE_WATCHER			c) =>	my_site_watchers		:=  c ! *my_site_watchers;
			#
			do_option (PIXELS_HIGH_MIN		i) =>   my_packed_widget_options	:=  (wi::PIXELS_HIGH_MIN i) ! *my_packed_widget_options;
			do_option (PIXELS_WIDE_MIN		i) =>   my_packed_widget_options	:=  (wi::PIXELS_WIDE_MIN i) ! *my_packed_widget_options;
			#
			do_option (PIXELS_HIGH_CUT		f) =>   my_packed_widget_options	:=  (wi::PIXELS_HIGH_CUT f) ! *my_packed_widget_options;
			do_option (PIXELS_WIDE_CUT		f) =>   my_packed_widget_options	:=  (wi::PIXELS_WIDE_CUT f) ! *my_packed_widget_options;
			#
			do_option (PIXELS_SQUARE		i) =>   my_packed_widget_options	:=  (wi::PIXELS_HIGH_MIN   i)
													!   (wi::PIXELS_WIDE_MIN   i)
													!   (wi::PIXELS_HIGH_CUT 0.0)
													!   (wi::PIXELS_WIDE_CUT 0.0)
													!   *my_packed_widget_options;
		    end;
		end;

		{ button_direction		=>  *my_button_direction,
		  button_type			=>  *my_button_type,
		  #
		  initial_state			=>  *my_initial_state,
		  initially_active		=>  *my_initially_active,
		  #
		  packed_widget_options		=>  *my_packed_widget_options,
		  #
		  port_watchers			=>  *my_port_watchers,
		  state_watchers		=>  *my_state_watchers,
		  site_watchers			=>  *my_site_watchers
		};
	    };


	offset = 1;

	fun get_vertices (wide: Int, high: Int, d::UP)
		=> 
		[ { col=>wide / 2,    row=>offset - 1 },
		  { col=>offset - 1,  row=>high-offset },
		  { col=>wide-offset, row=>high-offset }
		];

	   get_vertices (wide, high, d::DOWN)
	       => 
	       [ { col=>wide / 2,     row=>high-offset },
		 { col=>wide-offset,  row=>offset },
		 { col=>offset,       row=>offset }
	       ];

	   get_vertices (wide, high, d::LEFT)
	       => 
	       [ { col=>offset,      row=>high / 2 },
		 { col=>wide-offset, row=>high-offset },
		 { col=>wide-offset, row=>offset - 1 }
	       ];

	   get_vertices (wide, high, d::RIGHT)
	       => 
	       [ { col=>wide-offset, row=>high / 2 },
		 { col=>offset,      row=>offset - 1 },
		 { col=>offset,      row=>high-offset }
	       ];
	end;

	fun size direction (wide, high)
	    =
	    {   length =   ((((wide - 2*offset)*173) + 100) / 200) + 2*offset;
		#
		my (wide, high)
		    =
		    case high
			#
			THE h => (wide, h);

			_     => case direction
				     #
				     (d::DOWN | d::UP) => (wide, length);
				     _                 => (length, wide);
				 esac;
		    esac;

#		wg::make_tight_size_preference (wide, high);
	    };

#                             drawable
#                             |
#                             |     
#                             v     
#	fun drawfn direction (d, size as { wide, high }, bwid)
#	    =
#	    {   verts = get_vertices (wide, high, direction);
#		#
#		\\ (base, top, bottom)							# Mode-dependent colors in which to draw.
#		    =
#		    {   xc::fill_polygon d base { verts, shape=>xc::CONVEX_SHAPE };
#			d3::draw3dpoly d (verts, bwid) { top, bottom };
#		    };
#	    };


	fun has (options: List(Option))					# PUBLIC
	    =
	    {
	        (process_options
		  (
		    options,
		    #
		    { button_direction		=>  d::DOWN,
		      button_type		=>  t::PUSH_ON_PUSH_OFF,
		      #
		      initial_state		=>  FALSE,
		      initially_active		=>  TRUE,
		      #
		      packed_widget_options	=>  [],
		      #
		      port_watchers		=>  [],
		      state_watchers		=>  [],
		      site_watchers		=>  []
		    }
		) )
		    ->
		    {												# These values are globally visible to the subsequenc fns, which can lock them in as needed.
		      button_direction,									
		      button_type,									
		      #
		      initial_state,
		      initially_active,
		      #
		      packed_widget_options,
		      #
		      port_watchers,
		      state_watchers,
		      site_watchers
		    };


		###############################
		# Top of state variable section
		#

		last_known_site
		    =
		    REF ( { col => -1,  wide => -1,
			    row => -1,  high => -1
			  }:				xg::Box
			);

		button_state
		    =
		    REF initial_state;

		button_active
		    =
		    REF initially_active;


		fun note_site (site: xg::Box)
		    =
		    if(*last_known_site != site)
			last_known_site := site;
			#
			apply notify_watcher site_watchers
			    where
				fun notify_watcher site_watcher
				    =
				    site_watcher site;
			    end;
		    fi;

		fun note_state (state: Bool)
		    =
		    if(*button_state != state)
			button_state := state;
			#
			apply notify_watcher state_watchers
			    where
				fun notify_watcher state_watcher
				    =
				    state_watcher state;
			    end;
		    fi;

		#
		# End of state variable section
		###############################


		#####################
		# Top of port section
		#
		# Here we implement our App_To_Arrowbutton port:

		fun set_active_to (active: Bool)
		    =
		    button_active := active;			# Clearly we need to do more here!  XXX BUGGO FIXME

		fun set_state_to (state: Bool)
		    =
		    note_state state;

		fun get_active ()
		    =
		    *button_active;

		fun get_state ()
		    =
		    *button_state;

		fun get_button_direction ()
		    =
		    button_direction;

		fun get_button_type ()
		    =
		    button_type;

		port =    { set_active_to,
			    set_state_to,
			    get_active,
			    get_state,
			    get_button_direction,
			    get_button_type
			  }
			  : App_To_Arrowbutton
			  ;

		#
		# End of port section
		#####################


		###############################
		# Top of widget hook fn section
		#
		# These fns get called by widget_imp logic, ultimately						# widget_imp		is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg
		# in response to user mouseclicks and keypresses etc:

		fun startup_fn
		    { 
		      gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
		      widget_to_packedspace:		w2p::Widget_To_Packedspace
		    }
		    =
		    {
			apply   notify_watcher  port_watchers							# We do this here rather than (say) above this fn because we don't want the port in circulation until we're running.
				where
				    fun notify_watcher  port_watcher
					=
					port_watcher port;
				end;
nb {. "startup_fn called!   -- arrowbutton.pkg"; };
			();
		    };

		fun before_first_frame_fn
		    {
		      id:				iul::Id,						# Unique id.
		      site:				xg::Box,						# Window rectangle in which to draw.
		      gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
		      widget_to_packedspace:		w2p::Widget_To_Packedspace,
		      theme:				pt::Packed_Theme
		    }
		    =
		    {
nb {. "before_first_frame_fn called!   -- arrowbutton.pkg"; };
			note_site site;
			();
		    };

		fun start_of_frame_fn
		    {
		      id:				iul::Id,						# Unique id.
		      frame_number:			Int,							# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
		      site:				xg::Box,						# Window rectangle in which to draw.
		      visible:				Bool,							# If FALSE, widget is not visible on screen, so widget-imp may be able to avoid updating foreground and background.
		      duration_in_seconds:		Float,							# If state has changed widget-imp should call note_changed_gadget_foreground() before this time is up. Also useful for motionblur.
		      gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
		      widget_to_packedspace:		w2p::Widget_To_Packedspace,
		      this_gadget_mode:			g2g::Gadget_Mode,
		      theme:				pt::Packed_Theme
		    }
		    =
		    {	note_site site;
			#
			background_box =  site;
			foreground_box =  xg::box::make_nested_box (background_box, 4);

			background = gd::COLOR (r8::rgb8_cyan,    [ gd::POLY_FILL_BOX [ background_box ]]);
			foreground = gd::COLOR (r8::rgb8_magenta, [ gd::POLY_FILL_BOX [ foreground_box ]]);

			gadget_to_guiboss.note_changed_gadget_foreground { id, foreground };
			gadget_to_guiboss.note_changed_gadget_background { id, background };
		    };


		fun button_press_fn
		      { button:				evt::Mousebutton,
			point:				xg::Point,
			site:		 		xg::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
			gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
			widget_to_packedspace:		w2p::Widget_To_Packedspace,
			theme:				pt::Packed_Theme
		      }
		    = 
		    {	note_site site;
			#
			note_state (not *button_state);

nb {. "button_press_fn called!   -- arrowbutton.pkg"; };
		       ();
		    };

		fun button_release_fn
		      { button:				evt::Mousebutton,
			point:				xg::Point,
			site:		 		xg::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
			gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
			widget_to_packedspace:		w2p::Widget_To_Packedspace,
			theme:				pt::Packed_Theme
		      }
		    = 
		    {	note_site site;
			#
			if (button_type == t::MOMENTARY_CONTACT)
			    #
			    note_state  initial_state;
			fi;

nb {. "button_release_fn called!   -- arrowbutton.pkg"; };
		       ();
		    };

		fun key_press_fn
		      { keycode:			evt::Keycode,						# Keycode of the depressed key.
			keysym:				evt::Keysym,						# Keysym  of the depressed key.
			ascii:				String,							# Ascii  for the depressed key.
			point:				xg::Point,
			site:		 		xg::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
			gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
			widget_to_packedspace:		w2p::Widget_To_Packedspace,
			theme:				pt::Packed_Theme
		      }
		    = 
		    {	note_site site;
			#
nb {. "key_press_fn called!   -- arrowbutton.pkg"; };
		       ();
		    };

		fun key_release_fn
		      { keycode:			evt::Keycode,						# Keycode of the released key.
			keysym:				evt::Keysym,						# Keysym  of the released key.
			ascii:				String,							# Ascii  for the released key.
			point:				xg::Point,
			site:		 		xg::Box,						# Widget's assigned area in window coordinates.
			modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
			gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
			widget_to_packedspace:		w2p::Widget_To_Packedspace,
			theme:				pt::Packed_Theme
		      }
		    = 
		    {	note_site site;
			#
nb {. "key_release_fn called!   -- arrowbutton.pkg"; };
		       ();
		    };

		#
		# End of widget hook fn section
		###############################

		packed_widget_options
		  =
		  [ wi::STARTUP_FN		startup_fn,
		    wi::BEFORE_FIRST_FRAME_FN	before_first_frame_fn,
		    wi::START_OF_FRAME_FN	start_of_frame_fn,
		    wi::BUTTON_PRESS_FN		button_press_fn,
		    wi::BUTTON_RELEASE_FN	button_release_fn,
		    wi::KEY_PRESS_FN		key_press_fn,
		    wi::KEY_RELEASE_FN		key_release_fn
		  ]
		  @
		  packed_widget_options
		  ;

		make_packed_widget_fn =  wi::make_packed_widget_start_fn  packed_widget_options;

		packedspace_layout_hints
		    =
		    []:	 List(plh::Packedspace_Layout_Hint);

		( packedspace_layout_hints,									# Returning this tuple is a convenience to the caller; it represents one complete gui_plan::ROW entry,
		  gp::WIDGET   make_packed_widget_fn								# So caller can write   gui_plan = (packedspace_options, gp::ROW [ arrowbutton::has [...], arrowbutton::has [...], ... ]);
		);
	    };





#	attributes = [
#	    (wa::arrow_dir,    wa::ARROW_DIR,    wa::ARROW_DIR_VAL wt::ARROW_UP)
#	  ];
#
#	offset = 1;
#
#	fun get_vertices (wide, high, wt::ARROW_UP)
#		=> 
#		[ { col=>wide / 2,    row=>offset - 1 },
#		  { col=>offset - 1,  row=>high-offset },
#		  { col=>wide-offset, row=>high-offset }
#		];
#
#	   get_vertices (wide, high, wt::ARROW_DOWN)
#	       => 
#	       [ { col=>wide / 2,     row=>high-offset },
#		 { col=>wide-offset,  row=>offset },
#		 { col=>offset,       row=>offset }
#	       ];
#
#	   get_vertices (wide, high, wt::ARROW_LEFT)
#	       => 
#	       [ { col=>offset,      row=>high / 2 },
#		 { col=>wide-offset, row=>high-offset },
#		 { col=>wide-offset, row=>offset - 1 }
#	       ];
#
#	   get_vertices (wide, high, wt::ARROW_RIGHT)
#	       => 
#	       [ { col=>wide-offset, row=>high / 2 },
#		 { col=>offset,      row=>offset - 1 },
#		 { col=>offset,      row=>high-offset }
#	       ];
#	end;
#
#	fun size direction (wide, high)
#	    =
#	    {   length =   ((((wide - 2*offset)*173) + 100) / 200) + 2*offset;
#		#
#		my (wide, high)
#		    =
#		    case high
#			#
#			THE h => (wide, h);
#
#			_     => case direction
#				     #
#				     (wt::ARROW_DOWN | wt::ARROW_UP) => (wide, length);
#				     _                               => (length, wide);
#				 esac;
#		    esac;
#
#		wg::make_tight_size_preference (wide, high);
#	    };
#
#	fun drawfn direction (d, size as { wide, high }, bwid)
#	    =
#	    {   verts = get_vertices (wide, high, direction);
#		#
#		\\ (base, top, bottom)							# Mode-dependent colors in which to draw.
#		    =
#		    {   xc::fill_polygon d base { verts, shape=>xc::CONVEX_SHAPE };
#			d3::draw3dpoly d (verts, bwid) { top, bottom };
#		    };
#	    };
#
#	fun make_button_drawfn_and_sizefn  attributes
#	    =
#	    {   direction =   wa::get_arrow_dir (attributes wa::arrow_dir);
#		#
#		( drawfn direction,
#		  size   direction
#		);
#	    };

    };
end;


## COPYRIGHT (c) 1994 by AT&T Bell Laboratories  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2014,
## released per terms of SMLNJ-COPYRIGHT.
