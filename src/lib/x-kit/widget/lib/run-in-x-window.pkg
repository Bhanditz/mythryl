## run-in-x-window.pkg
#

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib





stipulate
    include threadkit;						# threadkit					is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    #
    package qk = quark;						# quark						is from   src/lib/x-kit/style/quark.pkg
    package xc =  xclient;					# xclient					is from   src/lib/x-kit/xclient/xclient.pkg
    package un  =  unt;						# unt						is from   src/lib/std/unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire					is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package w2v =  wire_to_value;				# wire_to_value					is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package xg  =  xgeometry;					# xgeometry					is from   src/lib/std/2d/xgeometry.pkg
    package xtr =  xlogger;					# xlogger					is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    package wnx =  winix__premicrothread;			# winix__premicrothread				is from   src/lib/std/winix--premicrothread.pkg
    package v8s =  vector_slice_of_one_byte_unts;		# vector_slice_of_one_byte_unts			is from   src/lib/std/src/vector-slice-of-one-byte-unts.pkg
    package w8v =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg

    package mop =  mailop;					# mailop					is from   src/lib/src/lib/thread-kit/src/core-thread-kit/mailop.pkg
    package sok =  socket__premicrothread;			# socket__premicrothread			is from   src/lib/std/socket--premicrothread.pkg

    package dns =  dns_host_lookup;				# dns_host_lookup				is from   src/lib/std/src/socket/dns-host-lookup.pkg
    package exp =  encode_xpackets_port;			# encode_xpackets_port				is from   src/lib/x-kit/xclient/src/window/encode-xpackets-port.pkg
#   package exx =  encode_xpackets_ximp;			# encode_xpackets_ximp				is from   src/lib/x-kit/xclient/src/window/encode-xpackets-ximp.pkg

#   package kp  =  keymap_port;					# keymap_port					is from   src/lib/x-kit/xclient/src/window/keymap-port.pkg
    package pc  =  pen_cache;					# pen_cache					is from   src/lib/x-kit/xclient/src/window/pen-cache.pkg

    package sj  =  socket_junk;					# socket_junk					is from   src/lib/internet/socket-junk.pkg

#   package op  =  outbuf_port;					# outbuf_port					is from   src/lib/x-kit/xclient/src/wire/outbuf-port.pkg
#   package sp  =  xserver_port;				# xserver_port					is from   src/lib/x-kit/xclient/src/wire/xserver-port.pkg
#   package xes =  xevent_sink;					# xevent_sink					is from   src/lib/x-kit/xclient/src/wire/xevent-sink.pkg
#   package xew =  xerror_well;					# xerror_well					is from   src/lib/x-kit/xclient/src/wire/xerror-well.pkg
    package xt  =  xtypes;					# xtypes					is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package et  =  event_types;					# event_types					is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package rpx =  ro_pixmap_ximp;				# ro_pixmap_ximp				is from   src/lib/x-kit/widget/lib/ro-pixmap-ximp.pkg

    package imx =  image_ximp;					# image_ximp					is from   src/lib/x-kit/widget/lib/image-ximp.pkg
    package shx =  shade_ximp;					# shade_ximp					is from   src/lib/x-kit/widget/lib/shade-ximp.pkg

    package fx  =  font_index;					# font_index					is from   src/lib/x-kit/xclient/src/window/font-index.pkg

    package exx =  encode_xpackets_ximp;			# encode_xpackets_ximp				is from   src/lib/x-kit/xclient/src/window/encode-xpackets-ximp.pkg
    package exp =  encode_xpackets_port;			# encode_xpackets_port				is from   src/lib/x-kit/xclient/src/wire/encode-xpackets-port.pkg

#   not visible here.

#   package ox  =  outbuf_ximp;					# outbuf_ximp					is from   src/lib/x-kit/xclient/src/wire/outbuf-ximp.pkg
#   package sx  =  xserver_ximp;				# xserver_ximp					is from   src/lib/x-kit/xclient/src/wire/xserver-ximp.pkg
#   package dxx =  decode_xpackets_ximp;			# decode_xpackets_ximp				is from   src/lib/x-kit/xclient/src/wire/decode-xpackets-ximp.pkg
    package dy  =  display;					# display					is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package cxa =  crack_xserver_address;			# crack_xserver_address				is from   src/lib/x-kit/xclient/src/wire/crack-xserver-address.pkg
    package uds =  unix_domain_socket__premicrothread;		# unix_domain_socket__premicrothread		is from   src/lib/std/src/socket/unix-domain-socket--premicrothread.pkg
    package is  =  internet_socket__premicrothread;		# internet_socket__premicrothread		is from   src/lib/std/src/socket/internet-socket--premicrothread.pkg

#   package sox =  xsocket_ximps;				# xsocket_ximps					is from   src/lib/x-kit/xclient/src/wire/xsocket-ximps.pkg
#   package sex =  xsession_ximps;				# xsession_ximps				is from   src/lib/x-kit/xclient/src/window/xsession-ximps.pkg
    package clx =  xclient_ximps;				# xclient_ximps					is from   src/lib/x-kit/xclient/src/window/xclient-ximps.pkg

    package aut =  authentication;				# authentication				is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package ax  =  atom_ximp;					# atom_ximp					is from   src/lib/x-kit/xclient/src/iccc/atom-ximp.pkg

    package wpx =  window_property_ximp;			# window_property_ximp				is from   src/lib/x-kit/xclient/src/window/window-property-ximp.pkg
    package sel =  selection_ximp;				# selection_ximp				is from   src/lib/x-kit/xclient/src/window/selection-ximp.pkg
    package sep =  selection_port;				# selection_port				is from   src/lib/x-kit/xclient/src/window/selection-port.pkg
    package sl  =  selection;					# selection					is from   src/lib/x-kit/xclient/src/window/selection.pkg

    package xj  =  xsession_junk;				# xsession_junk					is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package dt  =  draw_types;					# draw_types					is from   src/lib/x-kit/xclient/src/window/draw-types.pkg

    package csp =  cs_pixmap;					# cs_pixmap					is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
    package rop =  ro_pixmap;					# ro_pixmap					is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
    package rwp =  rw_pixmap;					# rw_pixmap					is from   src/lib/x-kit/xclient/src/window/rw-pixmap.pkg
    package pn  =  pen;						# pen						is from   src/lib/x-kit/xclient/src/window/pen.pkg
    package drw =  draw;					# draw						is from   src/lib/x-kit/xclient/src/window/draw.pkg

    package wdw =  window;					# window					is from   src/lib/x-kit/xclient/src/window/window.pkg
    package atm =  atom;					# atom						is from   src/lib/x-kit/xclient/src/iccc/atom.pkg
    package csr =  cursors;					# cursors					is from   src/lib/x-kit/xclient/src/window/cursors.pkg
    package ic  =  iccc_property;				# iccc_property					is from   src/lib/x-kit/xclient/src/iccc/iccc-property.pkg
    package ewi =  xevent_to_widget_ximp;			# xevent_to_widget_ximp				is from   src/lib/x-kit/xclient/src/window/xevent-to-widget-ximp.pkg
    package wa  =  widget_attribute;				# widget_attribute				is from   src/lib/x-kit/xclient/src/iccc/widget-attribute.pkg
    package wc  =  widget_cable;				# widget_cable					is from   src/lib/x-kit/xclient/src/iccc/widget-cable.pkg
    package hw  =  hash_window;					# hash_window					is from   src/lib/x-kit/xclient/src/window/hash-window.pkg
    package wp  =  window_property;				# window_property				is from   src/lib/x-kit/xclient/src/iccc/window-property.pkg
    package ws  =  widget_style;				# widget_style					is from   src/lib/x-kit/xclient/src/iccc/widget-style.pkg
    package wmh =  window_manager_hint;				# window_manager_hint				is from   src/lib/x-kit/xclient/src/iccc/window-manager-hint.pkg
    package rw  =  root_window;					# root_window					is from   src/lib/x-kit/widget/basic/root-window.pkg

    Dummy == xj::Xsession;					# Temporary kludge to force xsession-junk.pkg  to compile.
    Dummo == dt::Window;
    Dumma == csp::Cs_Pixmap;
    Dummb == rop::Ro_Pixmap;
    dummc  = rwp::BAD_PIXMAP_PARAMETER;
    dummd  = pn::BAD_PEN_TRAIT;
    dumme  = drw::BAD_DRAW_PARAMETER;
    dummf  = wdw::BAD_WINDOW_SITE;
    dummg  = atm::make_atom;
    Dummh == csr::Standard_Xcursor;
    dummi  =  ic::make_atom_property;
    dummj  = ewi::foo;
    dummk  =  wc::make_widget_cable;
    dumml  =  hw::make_map;
    Dummm == wmh::Window_Manager_Size_Hint;
    Dummn ==  wp::Raw_Data;
    dummo  =  sl::acquire_selection;
    dummp  =  wa::active;
    Dummq  =  ws::Style_Name;
    dummr  =  rw::make_root_window;

#    Dummy = dy::Xdisplay;					# Temporary kludge to force display.pkg  to compile.
#    Dummi = ax::Configstate;					# Temporary kludge to force atom-ximp.pkg to compile.
#    Dummu = sep::Selection_Handle;				# Temporary kludge to force compilation.
#    Dummo = sep::Selection_Port;				# Temporary kludge to force compilation.
herein


    package   run_in_x_window
    :         Run_In_X_Window					# Run_In_X_Window				is from   src/lib/x-kit/widget/lib/run-in-x-window.api
    {
	Dummy = Int;

	Screen_Info =   SCREEN_INFO
			  {
			    xscreen:    			dy::Xscreen,				# Xscreen	def in    src/lib/x-kit/xclient/src/wire/display.pkg
			    per_depth_imps:	List( Per_Depth_Imps ),	# The pen-cache and draw imps for the supported depths on this screen.
			    rootwindow_per_depth_imps:         Per_Depth_Imps		# The pen-cache and draw imps for the root window on this screen.
			  }

	also
	Per_Depth_Imps
	    =
	    # For each combination of visual and depth
	    # we allocate a pair of imps, one to draw,
	    # one to manage graphics contexts.  This
	    # is forced because X requires that each
	    # gc and pixmap be associated with a
	    # particular screen, visual and depth:
	    #
	    PER_DEPTH_IMPS {								# The pen-cache and draw_imp
		#									# for a given depth, visual and screen.
		depth:			Int,
		pen_cache:		pc::Pen_Cache,					# The pen-cache         for this depth on this screen.
		encode_xpackets_port:	exp::Encode_Xpackets_Port			# Rootwindow encode-imp for this depth on this screen.
	    }

	also
	Screen										# A screen handle for users.
	    =
	    SCREEN  {
#		xsession:      Xsession,
		screen_info:   Screen_Info
	    };

	#
	fun make_screen_info (xscreen as dy::XSCREEN { root_window_id, root_visual, visuals, ... } )		# Adapted from make_screen_info in   src/lib/x-kit/xclient/src/window/xsession-old.pkg
	    =
	    {
#		rootwindow_per_depth_imps
#		    =
#		    make_per_depth_imps
#		      (
#			dy::depth_of_visual  root_visual,
#			p2g::make_pen_to_gcontext_imp  (xdisplay, root_window_id)
#		      );
#
#		per_depth_imps
#		    =
#		    make_pen_imps (visuals, [ rootwindow_per_depth_imps ]);
#
#		per_depth_imps
#		    =
#		    make_pen_imps ( [ xt::NO_VISUAL_FOR_THIS_DEPTH 1 ],
#				    per_depth_imps
#				  );
#
#		SCREEN_INFO
#		  {
#		    xscreen,
#		    per_depth_imps,
#		    rootwindow_per_depth_imps
#		  };
	    };
#	    where
#		fun make_per_depth_imps (depth, pen_imp)
#		    =
#		    {   drawimp_mappedstate_slot =  make_mailslot ();
#
#			make_thread  "send FIRST_EXPOSE"  .{   put_in_mailslot (drawimp_mappedstate_slot, di::s::FIRST_EXPOSE);   };
#
#			PER_DEPTH_IMPS {
#			    depth,
#			    pen_imp,
#			    to_screen_drawimp
#				=>
#				di::make_draw_imp
#				  ( take_from_mailslot'  drawimp_mappedstate_slot,
#				    pen_imp,
#				    xsocket
#				  )
#			};
#		    };
#		#
#		fun make_pen_imps ([], l)
#			=>
#			l;
#
#		    make_pen_imps (vd ! r, l)
#			=>
#			{
#			    visual_depth =  dy::depth_of_visual  vd;
#
#			    #
#			    fun make_imps ()
#				=
#				{   pixmap_id = next_xid ();
#
#				    # Make a pixmap to serve as the
#				    # witness drawable for the GC server:
#				    #
#				    xok::send_xrequest xsocket
#				      ( value_to_wire::encode_create_pixmap
#					  { pixmap_id,
#					    drawable_id =>  root_window_id,
#					    size        =>  xg::SIZE { wide=>1, high=>1 },
#					    depth       =>  visual_depth
#					  }
#				      );
#
#				    make_per_depth_imps
#					(visual_depth, p2g::make_pen_to_gcontext_imp (xdisplay, pixmap_id));
#				};
#
#			    #
#			    fun get []
#				    =>
#				    make_imps() ! l;
#
#				get (PER_DEPTH_IMPS { depth, ... } ! rest)
#				    =>
#				    depth == visual_depth
#				     ??  l
#				     ::  get rest;
#			    end;
#
#
#			    make_pen_imps (r, get l);
#			};
#		end;
#	    end;

	fun make_root_window								# External entrypoint
                (display_or_null:  Null_Or( String ))					# Allow overriding of the DISPLAY environment variable setting.
	    =
	    {	(aut::get_xdisplay_string_and_xauthentication  display_or_null)		# This is from Reppy's oldworld make_root_window in src/lib/x-kit/widget/lib/run-in-x-window-old.pkg
		    ->
		    ( display_name:		String,					# Typically from $DISPLAY environment variable.
                      xauthentication:  Null_Or(xt::Xauthentication)			# Typically from ~/.Xauthority
                    );
											# Here canonical sequence calls make_root_window in src/lib/x-kit/widget/basic/root-window-old.pkg
											# which			  calls open_xsession    in src/lib/x-kit/xclient/src/window/xsession-old.pkg
											# which                   calls open_xdisplay    in src/lib/x-kit/xclient/src/wire/display-old.pkg
		(dy::open_xdisplay { display_name, xauthentication })
		    ->
		    (xdisplay as dy::XDISPLAY { default_screen, screens, socket, next_xid, ... } );	# Canonical sequence has 'xsocket' not 'socket' here.

		
		default_screen =    list::nth (screens, default_screen)
				    except
					SUBSCRIPT = {   msg = "Bad default_screen value -- make_root_window in xclient-ximps-junk.pkg";
							log::fatal msg;			# Doesn't return.
							raise exception FAIL msg;	# Should never get here.
						    };

		default_screen ->   dy::XSCREEN { root_window_id, ... };

		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };


		(clx::make_xclient_ximps_state ()	  ) ->   xclient_ximps_state;
		(clx::make_xclient_ximps "xclient_ximps"  ) ->  (xclient_ximps_configstate, xclient_ximps_exports);

		(ax::make_atom_ximp_state ()		  ) ->   atom_ximp_state;
		(ax::make_atom_ximp "atom_ximp"		  ) ->  (atom_ximp_configstate, atom_ximp_exports);

		(wpx::make_window_property_ximp_state ()  ) ->   window_property_ximp_state;
		(wpx::make_window_property_ximp "wpx"	  ) ->  (window_property_ximp_configstate, window_property_ximp_exports);

		(sel::make_selection_ximp_state ()	  ) ->   selection_ximp_state;
		(sel::make_selection_ximp "sel"		  ) ->  (selection_ximp_configstate, selection_ximp_exports);

		(imx::make_image_ximp_state ()		  ) ->   image_ximp_state;
		(imx::make_image_ximp "image"		  ) ->  (image_ximp_configstate, image_ximp_exports);

		(rpx::make_ro_pixmap_ximp_state ()	  ) ->   ro_pixmap_ximp_state;
		(rpx::make_ro_pixmap_ximp "ro_pixmap"	  ) ->  (ro_pixmap_ximp_configstate, ro_pixmap_ximp_exports);

		(shx::make_shade_ximp_state ()		  ) ->   shade_ximp_state;
		(shx::make_shade_ximp "shade"		  ) ->  (shade_ximp_configstate, shade_ximp_exports);

# This is done in xclient-ximps.pkg:
#		(exx::make_encode_xpackets_ximp_state ()  ) ->   encode_xpackets_ximp_state;
#		(exx::make_encode_xpackets_ximp "enc"	  ) ->  (encode_xpackets_ximp_configstate, encode_xpackets_ximp_exports);


		encode_xpackets_port		=	  xclient_ximps_exports.encode_xpackets_port;
		xevent_to_window_port		=	  xclient_ximps_exports.xevent_to_window_port;
		xserver_port			=         xclient_ximps_exports.xserver_port;
		xerror_well			=         xclient_ximps_exports.xerror_well;
		keymap_port			=         xclient_ximps_exports.keymap_port;

		window_property_port		=  window_property_ximp_exports.window_property_port;
		window_property_xevent_sink	=  window_property_ximp_exports.window_property_xevent_sink;

		selection_port			=        selection_ximp_exports.selection_port;
		selection_xevent_sink		=        selection_ximp_exports.selection_xevent_sink;

		image_port			=            image_ximp_exports.image_port;

		ro_pixmap_port			=        ro_pixmap_ximp_exports.ro_pixmap_port;

		shade_port			=            shade_ximp_exports.shade_port;

		atom_port			=             atom_ximp_exports.atom_port;




# not visible here.
#
# TBD: image_ximp	    configuration

#		window_property_xevent_sink =	{ put_value => 	(fn (event: et::x::Event) = { log::fatal  "window_property_xevent_sink called"; (); }) };	# Dummy to 'handle' X server PropertyNotify events.
#		selection_xevent_sink	    =	{ put_value => 	(fn (event: et::x::Event) = { log::fatal  "selection_xevent_sink called"      ; (); }) };	# Dummy to 'handle' X server SelectionNotify, SelectionRequest and SelectionClear events.

		fun name_to_cs_pixmap (name: qk::Quark)
		    =
		    raise exception FAIL "name_to_cs_pixmap not yet implemented";   # xc::Cs_Pixmap_Old

		clx::configure_xclient_ximps
		  (
		    xclient_ximps_configstate,
		    xclient_ximps_state,
		    { window_property_xevent_sink, selection_xevent_sink },
		    run_gun',
		    end_gun',
		    xdisplay,	
		    root_window_id,
		    socket 								# sok::Socket (X, sok::Stream(sok::Active))						# Socket to read.
		  );

		ax::configure_atom_ximp
		  (
		    atom_ximp_configstate,
		    atom_ximp_state,
		    { xserver_port },
		    run_gun',
		    end_gun'
		  );

		wpx::configure_window_property_ximp
		  (
		    window_property_ximp_configstate,
		    window_property_ximp_state,
		    { atom_port, xserver_port },
		    run_gun',
		    end_gun'
		  );

		sel::configure_selection_ximp
		  (
		    selection_ximp_configstate,
		    selection_ximp_state,
		    { xserver_port },
		    run_gun',
		    end_gun'
		  );

		imx::configure_image_ximp
		  (
		    image_ximp_configstate,
		    image_ximp_state,
		    {  },
		    run_gun',
		    end_gun'
		  );


		xsession =  xj::make_xsession
			      {
				run_gun',
				end_gun',
				xevent_to_window_port,
				xserver_port,
				atom_port,
				keymap_port,
				selection_port,
				window_property_port,
				xdisplay,
				drawable => root_window_id
			      };


# SOON! :-)
#		rpx::configure_ro_pixmap_ximp
#		  (
#		    ro_pixmap_ximp_configstate,
#		    ro_pixmap_ximp_state,
#		    {  },
#		    run_gun',
#		    end_gun',
#		    default_screen,
#		    name_to_cs_pixmap
#		  );
#
#		shx::configure_shade_ximp
#		  (
#		    shade_ximp_configstate,
#		    shade_ximp_state,
#		    {  },
#		    run_gun',
#		    end_gun'
#		  );




#		xlg::make_thread  "err_handler"  err_handler;

											# Canonical sequence is now back in open_xsession in src/lib/x-kit/xclient/src/window/xsession-old.pkg

#		atom_imp   =   ai::make_atom_imp    xdisplay;
#		(wpi::make_window_property_imp (xdisplay, atom_imp)) -> (to_window_property_imp_slot, window_property_imp);
#		(si::make_selection_imp  xdisplay)		     -> (to_selection_imp_slot,  selection_imp);
#		xsocket_to_topwindow_router = s2t::make_xsocket_to_topwindow_router { ... }

#		screens =  map  make_screen_info  screens;
#		xsession = XSESSION { ... }  
											# Canonical sequence is now back in make_root_window in  src/lib/x-kit/widget/basic/root-window-old.pkg
#		screen = xc::default_screen_of xsession;				# NB: xsession is part of 'screen':  	fun default_screen_of  (xsession as XSESSION { default_screen_info, ... } ) = SCREEN { xsession, screen_info => default_screen_info };

#		is =  ii::make_image_imp  init_images;
#		ts =  pxc::make_readonly_pixmap_cache  (screen,  ii::get_image  is);
#		shade_imp =  si::make_shade_imp  screen;

#		tilef = pxc::get_ro_pixmap ts;
#		make_thread "widget_id factory" .{  widget_id_loop 0;  };
#		ROOT_WINDOW
#		  { id => REF (), 
#		    screen, 
#		    style   =>  wy::empty_style { screen, tilef }, 
#		    make_tile  =>  tilef,
#		    make_shade =>  si::get_shades  shade_imp,
#		    next_widget_id =>  fn () =  take_from_mailslot  widget_id_slot	# Gets used (only) in widget::make_widget, in  src/lib/x-kit/widget/basic/widget.pkg
#		  };									# Canonical sequence now returns from make_root_window in src/lib/x-kit/widget/basic/root-window-old.pkg
#											# to make_root_window in src/lib/x-kit/widget/lib/run-in-x-window-old.pkg
#											# to run_in_x_window_old which passes the ROOT_WINDOW to user do_it() fn.  EOF! :-)





#		fire_run_gun ();
#		fire_end_gun ();

		();

#		wg::make_root_window (xdisplay, xauthentication)			# make_root_window is nominally from  src/lib/x-kit/widget/basic/widget.pkg   but actually from   src/lib/x-kit/widget/basic/root-window-old.pkg
#		except
#		    x as xclient::XSERVER_CONNECT_ERROR s
#			=
#			{   fil::write
#				( fil::stderr,
#				  string::cat
#				    [ "run_in_x_window_old: unable to open display \"",   xdisplay,   "\"\n",
#				      "  ",   s,   "\n"
#				    ]
#				);
#
#			    raise exception x;	
##			    shut_down_thread_scheduler  winix::process::failure;	# No longer kosher since 6.3
#			};
	      };



# We will want this eventually, but we do not yet have
# a newworld Root_Window:
#
#	fun run_in_x_window_old  do_it
#	    =
#	    {
#		{   do_it (make_root_window NULL);
#		    #
#		    winix__premicrothread::process::success;
#		}
#		except
#		    _ = winix__premicrothread::process::failure;
#
#		();
#	    };

    };															# package run_in_x_window
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
