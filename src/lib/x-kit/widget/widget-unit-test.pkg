## widget-unit-test.pkg
#
# NB: We must compile this locally via
#         xclient-internals.sublib
#     instead of globally via
#         src/lib/test/unit-tests.lib
#     like most unit tests, in order to have
#     access to required library internals.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


# Run by:
#     src/lib/test/all-unit-tests.pkg

stipulate
    include unit_test;						# unit_test				is from   src/lib/src/unit-test.pkg
    include makelib::scripting_globals;
    include threadkit;						# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ap  =  atom_port;					# atom_port				is from   src/lib/x-kit/xclient/src/iccc/atom-port.pkg
    package au  =  authentication;				# authentication			is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package awx =  appwindow_for_x;				# appwindow_for_x			is from   src/lib/x-kit/widget/xkit/app/appwindow-for-x.pkg
    package cpm =  cs_pixmap;					# cs_pixmap				is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
    package cpt =  cs_pixmat;					# cs_pixmat				is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
    #
    package gp  =  gui_plan;					# gui_plan				is from   src/lib/x-kit/widget/gui/gui-plan.pkg
    package sg  =  stopped_gui;					# stopped_gui				is from   src/lib/x-kit/widget/gui/stopped-gui.pkg
    #
    package dbl =  default_ball_look_imp_for_x;			# default_ball_look_imp_for_x		is from   src/lib/x-kit/widget/xkit/theme/bounce/default/look/default-ball-look-imp-for-x.pkg
    package dnl =  default_node_look_imp_for_x;			# default_node_look_imp_for_x		is from   src/lib/x-kit/widget/xkit/theme/canvas/default/look/default-node-look-imp-for-x.pkg
    #
    package dlx =  string_look_imp_for_x;			# string_look_imp_for_x			is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/string-look-imp-for-x.pkg
    #
    package dbx =  default_bounce_theme_imp_for_x;		# default_bounce_theme_imp_for_x	is from   src/lib/x-kit/widget/xkit/theme/bounce/default/default-bounce-theme-for-x.pkg
    package dcx =  default_canvas_theme_imp_for_x;		# default_canvas_theme_imp_for_x	is from   src/lib/x-kit/widget/xkit/theme/canvas/default/default-canvas-theme-for-x.pkg
    package dtx =  default_packed_theme_imp_for_x;		# default_packed_theme_imp_for_x	is from   src/lib/x-kit/widget/xkit/theme/packed/default/default-packed-theme-for-x.pkg
    #
    package dy  =  display;					# display				is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package et  =  event_types;					# event_types				is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
#   package w2x =  widget_to_xserver;				# widget_to_xserver			is from   src/lib/x-kit/xclient/src/window/widget-to-xserver.pkg
    package fil =  file__premicrothread;			# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
    package fti =  font_index;					# font_index				is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
    package gq  =  gui_boss_imp;				# gui_boss_imp				is from   src/lib/x-kit/widget/gui/gui-boss-imp.pkg
#   package c2g =  client_to_gui;				# client_to_gui				is from   src/lib/x-kit/widget/gui/client-to-gui.pkg
    package kp  =  keymap;					# keymap				is from   src/lib/x-kit/xclient/src/window/keymap.pkg
    package mtx =  rw_matrix;					# rw_matrix				is from   src/lib/std/src/rw-matrix.pkg
    package r8  =  rgb8;					# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package rgb =  rgb;						# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package rop =  ro_pixmap;					# ro_pixmap				is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
    package rw  =  root_window;					# root_window				is from   src/lib/x-kit/widget/lib/root-window.pkg
    package rwv =  rw_vector;					# rw_vector				is from   src/lib/std/src/rw-vector.pkg
    package s2p =  xevent_to_window;				# xevent_to_window			is from   src/lib/x-kit/xclient/src/window/xevent-to-window.pkg
    package sep =  selection_port;				# selection_port			is from   src/lib/x-kit/xclient/src/window/selection-port.pkg
    package shp =  shade;					# shade					is from   src/lib/x-kit/widget/lib/shade.pkg
    package sj  =  socket_junk;					# socket_junk				is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer			is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
    package lsi =  string_state_imp;				# string_state_imp			is from   src/lib/x-kit/widget/space/packed/string-state-imp.pkg
    package ls  =  client_to_string_state;			# client_to_string_state		is from   src/lib/x-kit/widget/space/packed/client-to-string-state.pkg
    package ssi =  float_state_imp;				# float_state_imp			is from   src/lib/x-kit/widget/space/packed/float-state-imp.pkg
    package plh =  packed_space_layout_hint;			# packed_space_layout_hint		is from   src/lib/x-kit/widget/space/packed/packed-space-layout-hint.pkg
    package ss  =  client_to_float_state;			# client_to_float_state			is from   src/lib/x-kit/widget/space/packed/client-to-float-state.pkg
    package ti  =  template_imp;				# template_imp				is from   src/lib/x-kit/xclient/src/wire/template-imp.pkg
    package tem =  template;					# template				is from   src/lib/x-kit/xclient/src/wire/template.pkg
    package tr  =  logger;					# logger				is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
    package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
    package u1  =  one_byte_unt;				# one_byte_unt				is from   src/lib/std/one-byte-unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts		is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire				is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package wg  =  widget;					# widget				is from   src/lib/x-kit/widget/basic/widget.pkg
    package wi  =  window;					# window				is from   src/lib/x-kit/xclient/src/window/window.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink			is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package wpp =  window_watcher;				# window_watcher			is from   src/lib/x-kit/xclient/src/window/window-watcher.pkg
    package wy  =  widget_style;				# widget_style				is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package e2s =  xevent_to_string;				# xevent_to_string			is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
    package xc  =  xclient;					# xclient				is from   src/lib/x-kit/xclient/xclient.pkg
    package xg  =  xgeometry;					# xgeometry				is from   src/lib/std/2d/xgeometry.pkg
    package xj  =  xsession_junk;				# xsession_junk				is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package xt  =  xtypes;					# xtypes				is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package xtr =  xlogger;					# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #
    tracefile   =  "widget-unit-test.trace.log";

#   id =  iui::issue_unique_id;

    nb =  log::note_on_stderr;					# log					is from   src/lib/std/src/log.pkg
herein

    package widget_unit_test {
	#
	name = "src/lib/x-kit/widget/widget-unit-test.pkg";

	trace =  xtr::log_if  xtr::io_logging 0;		# Conditionally write strings to tracing.log or whatever.


	fun exercise_window_stuff  ()
	    =
	    {
		fun int_sink i = ();
printf "widget-unit-test.pkg/exercise_window_stuff/TOP\n";

		# Here we build a three-layer cake:
		#
		#    -----------------
		#    |     Gui Boss |
		#    -----------------
		#    |     Theme     |
		#    -----------------
		#    |     Appwindow |
		#    -----------------
		#
		# The Gui Boss is renderlib-agnostic; it de/constructs and maintains running GUI impnets from gui specification trees. 
		# The Theme is renderlib-specific (e.g., X-specific) and encapsulates how to draw the various widgets on the given renderlib.
		# The Appwindow is renderlib-specific and encapulates X-specific application window stuff like EXPOSE event-handling.


		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		appwindow_needs
		    =
		    { site => { upperleft	 =>   { col =>    0, row  =>  0 },
			      	size		 =>   { wide => 800, high => 600 },
			      	border_thickness =>  1
			      }: xg::Window_Site,
		      #	
		      background_pixel =>  r8::rgb8_from_ints (16, 128+32, 32)		# Slightly desaturated green.
		    };
		appwindow_options =  [];
		appwindow_arg     =  (appwindow_needs, appwindow_options);
		#
		(awx::make_appwindow_egg  appwindow_arg  NULL) ->  appwindow_egg;
		#
		(appwindow_egg			()) ->   (appwindow_exports, appwindow_egg');


		(dbx::make_bounce_theme_egg	[]) ->   bounce_theme_egg;
		(bounce_theme_egg		()) ->  (bounce_theme_exports, bounce_theme_egg');
		#
		(dcx::make_canvas_theme_egg	[]) ->   canvas_theme_egg;
		(canvas_theme_egg		()) ->  (canvas_theme_exports, canvas_theme_egg');
		#
		(dtx::make_packed_theme_egg	[]) ->   packed_theme_egg;
		(packed_theme_egg		()) ->  (packed_theme_exports, packed_theme_egg');

		
		label_arg      = ({ value => "foo" }, []);
		label_look_arg = [];

		label_endstate_oneshot = NULL;

		(lsi::make_egg  label_arg  label_endstate_oneshot)
		    ->
		    string_state_egg;

		(string_state_egg		()) -> (string_state_exports, string_state_egg');
		#


		slider_endstate_oneshot = NULL;

		slider_arg = ({ value => 0.0 }, []);

		(ssi::make_egg  slider_arg  slider_endstate_oneshot)
		    ->
		    float_state_egg;

		(float_state_egg		()) -> (float_state_exports, float_state_egg');


		(gq::make_gui_boss_egg		[]) ->  gui_boss_egg;
		(gui_boss_egg			()) -> (gui_boss_exports, gui_boss_egg');

		#
		(ti::make_template_egg		[]) -> template_egg;
		(template_egg			()) -> (template_exports, template_egg');

		#
		appwindow_exports	-> { gui_to_appwindow	};
		#
		client_to_string_state		=  string_state_exports.client_to_state;
		client_to_float_state		=   float_state_exports.client_to_state;
		#
		bounce_theme_exports	-> { gui_to_bounce_theme	};
		canvas_theme_exports	-> { gui_to_canvas_theme	};
		packed_theme_exports	-> { gui_to_packed_theme	};
		#
		gui_boss_exports	-> { client_to_gui	};
		template_exports	-> { template		};

		template_imports = { int_sink =>  \\ (i: Int) = ()  };

		gui_boss_egg'		( { int_sink,
					    gui_to_appwindow,
					    gui_to_bounce_theme,
					    gui_to_canvas_theme,
					    gui_to_packed_theme
					  },
					  run_gun', end_gun'
				        );
		#
		bounce_theme_egg'	({ int_sink,     gui_to_appwindow	},	run_gun', end_gun');
		canvas_theme_egg'	({ int_sink,     gui_to_appwindow	},	run_gun', end_gun');
		packed_theme_egg'	({ int_sink,     gui_to_appwindow	},	run_gun', end_gun');
		#
		appwindow_egg'		({ int_sink				},	run_gun', end_gun');
		template_egg'		( template_imports,				run_gun', end_gun');



		fire_run_gun ();

		t  =  client_to_gui.get_packed_theme ();
		#
		{
		    include gui_plan;							# gui_plan		is from   src/lib/x-kit/widget/gui/gui-plan.pkg
		    #
		    #
		    label_arg      = ({ value => "foo" }, []);
		    label_look_arg = (                   []);

		      label_endstate_oneshot = NULL;
		       knob_endstate_oneshot = NULL;

		     layout_hints =  []:  List( plh::Packed_Space_Layout_Hint );
		     knob_options =  []:  List( gp::knob::Knob_Option );
		    label_options =  []:  List( gp::label::Label_Option );

		    gui_plan
		      =
		      ( [],								# Packed-space options
			ROW [ (LABEL { value => "foo", options => label_options },  layout_hints),
			      (KNOB  { value => 0.0,   options => knob_options  },  layout_hints)
			    ]
		      );

		    gui_plan
		      =
		      ( [],								# Packed-space options
			ROW [ (LABEL { value => "fee", options => label_options }, layout_hints),
			      (LABEL { value => "fie", options => label_options }, layout_hints),
			      (LABEL { value => "foe", options => label_options }, layout_hints),
			      (LABEL { value => "fum", options => label_options }, layout_hints)
			    ]
		      );

nb {. sprintf "widget-unit-test pprinting gui_plan:"; };
		    gp::pprint_gui_plan  gui_plan;

nb {. sprintf "widget-unit-test calling client_to_gui.restart_gui..."; };
		    (client_to_gui.start_gui  gui_plan) ->  block_until_gui_startup_is_complete;

nb {. sprintf "widget-unit-test calling block_until_gui_startup_is_complete() ..."; };
		    block_until_gui_startup_is_complete();

nb {. sprintf "widget-unit-test calling sleep_for 5.0 ..."; };
		    sleep_for 5.0;

nb {. sprintf "widget-unit-test ending gui run..."; };
		    stopped_gui' = client_to_gui.stop_gui ();

nb {. sprintf "widget-unit-test pprinting stopped_gui':"; };
		    sg::pprint_stopped_gui  stopped_gui';
		};	

		look_to_bounce									# Dummy port back to bounce-space-imp from look-imp.
		  =
		  { id           =>  id_zero,
		    look_changed =>  (\\ _ = ())
		  };

		look_to_canvas									# Dummy port back to canvas-space-imp from look-imp.
		  =
		  { id           =>  id_zero,
		    look_changed =>  (\\ _ = ())
		  };

		look_to_packed									# Dummy port back to packed-space-imp from look-imps.
		  =
		  { id           =>  id_zero,
		    look_changed =>  (\\ _ = ())
		  };

		lle =  t.make_string_widget_state_imp_egg   ( label_arg, label_look_arg, look_to_packed);


		# Widgets are intended to be created with/by a running
		#     gui_boss + theme + appwindow
		# impnet, so we create them after the above fire_run_gun() call:

		string_state_endstate_oneshot'	= NULL;
		label_look_endstate_oneshot'	= NULL;

		(dlx::make_egg	(/* gui_to_appwindow, */ label_look_arg, label_arg, look_to_packed, string_state_endstate_oneshot', label_look_endstate_oneshot'))
		    ->
		    label_look_egg;
		(label_look_egg			()) -> (label_look_exports, label_look_egg');
		#
		  label_look_control	=    label_look_exports.packed_to_look;

		ball_state_endstate_oneshot = NULL;
		ball_look_endstate_oneshot  = NULL;
		ball_look_arg         = [];
		ball_arg =  ( { position => { x => 0.0, y => 0.0, z => 0.0 },
				velocity => { x => 0.0, y => 0.0, z => 0.0 }
			      }, 	
			      []
			    );
		(dbl::make_ball_egg ( /* gui_to_appwindow, */ ball_arg, ball_look_arg, look_to_bounce, ball_state_endstate_oneshot, ball_look_endstate_oneshot))
		    ->
		    ball_look_egg;



		node_state_endstate_oneshot = NULL;
		node_look_endstate_oneshot  = NULL;
		node_look_arg         = [];
		node_arg =  ( { text => "foo" },
			      []
			    );
		(dnl::make_node_egg ( /* gui_to_appwindow, */ node_arg, node_look_arg, look_to_canvas, node_state_endstate_oneshot, node_look_endstate_oneshot))
		    ->
		    node_look_egg;






#		wait_until_exercise_is_complete
#		    =
#		    gui_to_appwindow.exercise_appwindow ();
#
# printf "widget-unit-text.pkg/exercise_window_stuff waiting for exercise to complete...\n";
#		wait_until_exercise_is_complete ();
# printf "widget-unit-text.pkg/exercise_window_stuff done waiting for exercise to complete.\n";

#		wait_until_exercise_is_complete
#		    =
#		    default_packed_theme_imp_for_x_port.exercise_appwindow ();
#
#		wait_until_exercise_is_complete ();


		wait_until_exercise_is_complete
		    =
		    client_to_gui.exercise_appwindow ();

		wait_until_exercise_is_complete ();


		fire_end_gun ();
		

		();
	    };

	fun run ()
	    =
	    {   # Remove any old version of the tracefile:
		#
		if (isfile tracefile)  
		    unlink tracefile;
		fi;


		printf "\nDoing %s:\n" name;   


		# Open tracelog file and
                # select tracing level:
		#
		{   include logger;				# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
		    #
		    set_logger_to  (fil::LOG_TO_FILE tracefile);
		    #
#		    enable fil::all_logging;			# Gross overkill.
#		    enable xtr::xkit_logging;			# Lesser overkill.
#		    enable xtr::io_logging;			# Saner yet.	
		};

		assert  (tsr::thread_scheduler_is_running ());

		exercise_window_stuff  ();



		assert TRUE;

		summarize_unit_tests  name;
	    };
    };

end;
