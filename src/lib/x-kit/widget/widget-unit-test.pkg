## widget-unit-test.pkg
#
# NB: We must compile this locally via
#         xclient-internals.sublib
#     instead of globally via
#         src/lib/test/unit-tests.lib
#     like most unit tests, in order to have
#     access to required library internals.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


# Run by:
#     src/lib/test/all-unit-tests.pkg

stipulate
    include unit_test;						# unit_test				is from   src/lib/src/unit-test.pkg
    include makelib::scripting_globals;
    include threadkit;						# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ap  =  atom_port;					# atom_port				is from   src/lib/x-kit/xclient/src/iccc/atom-port.pkg
    package au  =  authentication;				# authentication			is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package awx =  appwindow_for_x;				# appwindow_for_x			is from   src/lib/x-kit/widget/xkit/app/appwindow-for-x.pkg
    package cpm =  cs_pixmap;					# cs_pixmap				is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
    package cpt =  cs_pixmat;					# cs_pixmat				is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
    #
    package gp  =  gui_plan;					# gui_plan				is from   src/lib/x-kit/widget/gui/gui-plan.pkg
    #
    package dbl =  default_ball_look_imp_for_x;			# default_ball_look_imp_for_x		is from   src/lib/x-kit/widget/xkit/theme/bounce/default/look/default-ball-look-imp-for-x.pkg
    package dnl =  default_node_look_imp_for_x;			# default_node_look_imp_for_x		is from   src/lib/x-kit/widget/xkit/theme/canvas/default/look/default-node-look-imp-for-x.pkg
    #
    package dkx =  default_knob_look_imp_for_x;			# default_knob_look_imp_for_x		is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/default-knob-look-imp-for-x.pkg
    package dxx =  default_xslider_look_imp_for_x;		# default_xslider_look_imp_for_x	is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/default-xslider-look-imp-for-x.pkg
    package dyx =  default_yslider_look_imp_for_x;		# default_yslider_look_imp_for_x	is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/default-yslider-look-imp-for-x.pkg
    package dlx =  default_label_look_imp_for_x;		# default_label_look_imp_x		is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/default-label-look-imp-for-x.pkg
    #
    package dbx =  default_bounce_theme_imp_for_x;		# default_bounce_theme_imp_for_x	is from   src/lib/x-kit/widget/xkit/theme/bounce/default/default-bounce-theme-for-x.pkg
    package dcx =  default_canvas_theme_imp_for_x;		# default_canvas_theme_imp_for_x	is from   src/lib/x-kit/widget/xkit/theme/canvas/default/default-canvas-theme-for-x.pkg
    package dtx =  default_packed_theme_imp_for_x;		# default_packed_theme_imp_for_x	is from   src/lib/x-kit/widget/xkit/theme/packed/default/default-packed-theme-for-x.pkg
    #
    package dy  =  display;					# display				is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package et  =  event_types;					# event_types				is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package exp =  xserver;					# xserver				is from   src/lib/x-kit/xclient/src/window/xserver.pkg
    package fil =  file__premicrothread;			# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
    package fti =  font_index;					# font_index				is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
    package iui =  issue_unique_id;				# issue_unique_id			is from   src/lib/src/issue-unique-id.pkg
    package gq  =  gui_boss_imp;				# gui_boss_imp				is from   src/lib/x-kit/widget/gui/gui-boss-imp.pkg
    package gqp =  gui_boss;					# gui_boss				is from   src/lib/x-kit/widget/gui/gui-boss.pkg
    package kp  =  keymap;					# keymap				is from   src/lib/x-kit/xclient/src/window/keymap.pkg
    package mtx =  rw_matrix;					# rw_matrix				is from   src/lib/std/src/rw-matrix.pkg
    package r8  =  rgb8;					# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package rgb =  rgb;						# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package rop =  ro_pixmap;					# ro_pixmap				is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
    package rw  =  root_window;					# root_window				is from   src/lib/x-kit/widget/lib/root-window.pkg
    package rwv =  rw_vector;					# rw_vector				is from   src/lib/std/src/rw-vector.pkg
    package s2p =  xevent_to_window;				# xevent_to_window			is from   src/lib/x-kit/xclient/src/window/xevent-to-window.pkg
    package sep =  selection_port;				# selection_port			is from   src/lib/x-kit/xclient/src/window/selection-port.pkg
    package shp =  shade;					# shade					is from   src/lib/x-kit/widget/lib/shade.pkg
    package sj  =  socket_junk;					# socket_junk				is from   src/lib/internet/socket-junk.pkg
    package sp  =  xsequencer;					# xsequencery				is from   src/lib/x-kit/xclient/src/wire/xsequencer.pkg
    package lsi =  label_state_imp;				# label_state_imp			is from   src/lib/x-kit/widget/space/packed/label/label-state-imp.pkg
    package ls  =  label_state;					# label_state				is from   src/lib/x-kit/widget/space/packed/label/label-state.pkg
    package ssi =  slider_state_imp;				# slider_state_imp			is from   src/lib/x-kit/widget/space/packed/slider/slider-state-imp.pkg
    package ss  =  slider_state;				# slider_state				is from   src/lib/x-kit/widget/space/packed/slider/slider-state.pkg
    package ti  =  template_imp;				# template_imp				is from   src/lib/x-kit/xclient/src/wire/template-imp.pkg
    package tem =  template;					# template				is from   src/lib/x-kit/xclient/src/wire/template.pkg
    package tr  =  logger;					# logger				is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
    package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
    package u1  =  one_byte_unt;				# one_byte_unt				is from   src/lib/std/one-byte-unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts		is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire				is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package wg  =  widget;					# widget				is from   src/lib/x-kit/widget/basic/widget.pkg
    package wi  =  window;					# window				is from   src/lib/x-kit/xclient/src/window/window.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink			is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package wpp =  window_watcher;				# window_watcher			is from   src/lib/x-kit/xclient/src/window/window-watcher.pkg
    package wy  =  widget_style;				# widget_style				is from   src/lib/x-kit/widget/lib/widget-style.pkg
    package x2s =  xevent_to_string;				# xevent_to_string			is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
    package xc  =  xclient;					# xclient				is from   src/lib/x-kit/xclient/xclient.pkg
    package xg  =  xgeometry;					# xgeometry				is from   src/lib/std/2d/xgeometry.pkg
    package xj  =  xsession_junk;				# xsession_junk				is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package xt  =  xtypes;					# xtypes				is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package xtr =  xlogger;					# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #
    tracefile   =  "widget-unit-test.trace.log";

    id =  iui::issue_unique_id;
herein

    package widget_unit_test {
	#
	name = "src/lib/x-kit/widget/widget-unit-test.pkg";

	trace =  xtr::log_if  xtr::io_logging 0;		# Conditionally write strings to tracing.log or whatever.


	fun exercise_window_stuff  ()
	    =
	    {
		fun int_sink i = ();
printf "widget-unit-test.pkg/exercise_window_stuff/TOP\n";

		# Here we build a three-layer cake:
		#
		#    -----------------
		#    |     Gui Boss |
		#    -----------------
		#    |     Theme     |
		#    -----------------
		#    |     Appwindow |
		#    -----------------
		#
		# The Gui Boss is renderlib-agnostic; it de/constructs and maintains running GUI impnets from gui specification trees. 
		# The Theme is renderlib-specific (e.g., X-specific) and encapsulates how to draw the various widgets on the given renderlib.
		# The Appwindow is renderlib-specific and encapulates X-specific application window stuff like EXPOSE event-handling.


		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		appwindow_needs
		    =
		    { site => xg::WINDOW_SITE { upperleft	 =>  xg::POINT { col =>   0,  row  =>  0 },
						size		 =>  xg::SIZE  { wide => 165, high => 85 },
						border_thickness =>  1
					      },
		      #	
		      background_pixel =>  r8::rgb8_from_ints (16, 128+32, 32)		# Slightly desaturated green.
		    };
		appwindow_options =  [];
		appwindow_arg     =  (appwindow_needs, appwindow_options);
		#
		(awx::make_appwindow_egg  appwindow_arg  NULL) ->  appwindow_egg;
		#
		(appwindow_egg			()) ->   (appwindow_exports, appwindow_egg');


		(dbx::make_bounce_theme_egg	[]) ->   bounce_theme_egg;
		(bounce_theme_egg		()) ->  (bounce_theme_exports, bounce_theme_egg');
		#
		(dcx::make_canvas_theme_egg	[]) ->   canvas_theme_egg;
		(canvas_theme_egg		()) ->  (canvas_theme_exports, canvas_theme_egg');
		#
		(dtx::make_packed_theme_egg	[]) ->   packed_theme_egg;
		(packed_theme_egg		()) ->  (packed_theme_exports, packed_theme_egg');

		
		label_arg      = ({ text => "foo" }, []);
		label_look_arg = [];

		label_endstate_oneshot = NULL;

		(lsi::make_label_state_egg  label_arg  label_endstate_oneshot)
		    ->
		    label_state_egg;

		(label_state_egg		()) -> (label_state_exports, label_state_egg');
		#


		slider_endstate_oneshot = NULL;

		slider_arg = ({ min => 0.0, val => 0.0, max => 1.0 }, []);

		(ssi::make_slider_state_egg  slider_arg  slider_endstate_oneshot)
		    ->
		    slider_state_egg;

		(slider_state_egg		()) -> (slider_state_exports, slider_state_egg');


		(gq::make_gui_boss_egg		[]) ->  gui_boss_egg;
		(gui_boss_egg			()) -> (gui_boss_exports, gui_boss_egg');

		#
		(ti::make_template_egg		[]) -> template_egg;
		(template_egg			()) -> (template_exports, template_egg');

		#
		appwindow_exports	-> { appwindow		};
		#
		label_state		=   label_state_exports.label_state;
		slider_state		=  slider_state_exports.slider_state;
		#
		#
		bounce_theme_exports	-> { bounce_theme	};
		canvas_theme_exports	-> { canvas_theme	};
		packed_theme_exports	-> { packed_theme	};
		#
		gui_boss_exports	-> { gui_boss		};
		template_exports	-> { template		};

		template_imports = { int_sink =>  fn (i: Int) = ()  };

		gui_boss_egg'		( { int_sink,
					    bounce_theme,
					    canvas_theme,
					    packed_theme
					  },
					  run_gun', end_gun'
				        );
		#
		bounce_theme_egg'	({ int_sink,     appwindow	},	run_gun', end_gun');
		canvas_theme_egg'	({ int_sink,     appwindow	},	run_gun', end_gun');
		packed_theme_egg'	({ int_sink,     appwindow	},	run_gun', end_gun');
		#
		appwindow_egg'		({ int_sink			},	run_gun', end_gun');
		template_egg'		( template_imports,			run_gun', end_gun');



		fire_run_gun ();

		t  =  gui_boss.get_packed_theme ();
		#
		{
		    include gui_plan;							# gui_plan		is from   src/lib/x-kit/widget/gui/gui-plan.pkg
		    #
		    #
		    label_arg      = ({ text => "foo" }, []);
		    label_look_arg = (                   []);

		      label_endstate_oneshot = NULL;
		       knob_endstate_oneshot = NULL;
		    xslider_endstate_oneshot = NULL;
		    yslider_endstate_oneshot = NULL;

		    gui_plan
		      =
		      ( [],								# Packed-space options
			ROW [ (LABEL   (label_arg,  label_look_arg), []),
			      (KNOB    (slider_arg, []	          ), []),
			      (XSLIDER (slider_arg, []	          ), []),
			      (YSLIDER (slider_arg, []	          ), [])
			    ]
		      );

		    gui_plan
		      =
		      ( [],								# Packed-space options
			ROW [ (LABEL (({ text => "fee" }, []), []), []),
			      (LABEL (({ text => "fie" }, []), []), []),
			      (LABEL (({ text => "foe" }, []), []), []),
			      (LABEL (({ text => "fum" }, []), []), [])
						       #  ^    ^    ^
						       #  |    |    |
						       #  |    |    List(ps::Layout_Hint)
						       #  |    lli::Label_Look_Arg
						       #  List(lsi::Label_State_Options)
			    ]
		      );

		    printf "widget-unit-test pprinting gui_plan:\n";
		    gp::pprint_gui_plan gui_plan;

		    printf "widget-unit-test running gui...\n";
		    gui_boss.run_gui  gui_plan;

		    printf "widget-unit-test ending gui run...\n";
		    gui_plan' = gui_boss.end_gui ();

		    printf "widget-unit-test pprinting gui_plan':\n";
		    gp::pprint_gui_plan gui_plan';
		};	
			
		lle =  t.label   ( label_arg, label_look_arg);
		kle =  t.knob    (slider_arg, []);
		xle =  t.xslider (slider_arg, []);
		yle =  t.yslider (slider_arg, []);


		# Widgets are intended to be created with/by a running
		#     gui_boss + theme + appwindow
		# impnet, so we create them after the above fir_run_gun() call:

		label_state_endstate_oneshot'	= NULL;
		label_look_endstate_oneshot'	= NULL;

		(dlx::make_label_look_egg	(/* appwindow, */ label_look_arg, label_arg, label_state_endstate_oneshot', label_look_endstate_oneshot'))
		    ->
		    label_look_egg;
		(label_look_egg			()) -> (label_look_exports, label_look_egg');
		#
		  label_look_control	=    label_look_exports.packed_widget_control;

		knob_state_endstate_oneshot'	= NULL;
		knob_look_endstate_oneshot'	= NULL;

		(dkx::make_knob_egg  ( /* appwindow, */ slider_arg, [], knob_state_endstate_oneshot', knob_look_endstate_oneshot'))
		    ->
		    knob_look_egg;
		#
		(knob_look_egg			()) -> (knob_look_exports, knob_look_egg');
		knob_look_control	=     knob_look_exports.packed_widget_control;


#        make_ball_egg: (aw::Appwindow, bsi::Ball_Arg, Ball_Look_Arg, Null_Or(Oneshot_Maildrop(bsi::Ball_Arg)))
		ball_state_endstate_oneshot = NULL;
		ball_look_endstate_oneshot  = NULL;
		ball_look_arg         = [];
		ball_arg =  ( { position => { x => 0.0, y => 0.0, z => 0.0 },
				velocity => { x => 0.0, y => 0.0, z => 0.0 }
			      }, 	
			      []
			    );
		(dbl::make_ball_egg ( /* appwindow, */ ball_arg, ball_look_arg, ball_state_endstate_oneshot, ball_look_endstate_oneshot))
		    ->
		    ball_look_egg;



		node_state_endstate_oneshot = NULL;
		node_look_endstate_oneshot  = NULL;
		node_look_arg         = [];
		node_arg =  ( { text => "foo" },
			      []
			    );
		(dnl::make_node_egg ( /* appwindow, */ node_arg, node_look_arg, node_state_endstate_oneshot, node_look_endstate_oneshot))
		    ->
		    node_look_egg;




		xslider_state_endstate_oneshot'	= NULL;
		xslider_look_endstate_oneshot'	= NULL;

		(dxx::make_xslider_egg  ( /* appwindow, */ slider_arg, [], xslider_state_endstate_oneshot', xslider_look_endstate_oneshot'))
		    ->
		    xslider_look_egg;
		#
		(xslider_look_egg		()) -> (xslider_look_exports, xslider_look_egg');
		xslider_look_control	=  xslider_look_exports.packed_widget_control;


		yslider_state_endstate_oneshot'	= NULL;
		yslider_look_endstate_oneshot'	= NULL;

		(dyx::make_yslider_egg  ( /* appwindow, */ slider_arg, [], yslider_state_endstate_oneshot', yslider_look_endstate_oneshot'))
		    ->
		    yslider_look_egg;
		#
		(yslider_look_egg		()) -> (yslider_look_exports, yslider_look_egg');
		yslider_look_control	=  yslider_look_exports.packed_widget_control;




#		wait_until_exercise_is_complete
#		    =
#		    appwindow.exercise_appwindow ();
#
# printf "widget-unit-text.pkg/exercise_window_stuff waiting for exercise to complete...\n";
#		wait_until_exercise_is_complete ();
# printf "widget-unit-text.pkg/exercise_window_stuff done waiting for exercise to complete.\n";

#		wait_until_exercise_is_complete
#		    =
#		    default_packed_theme_imp_for_x_port.exercise_appwindow ();
#
#		wait_until_exercise_is_complete ();


		wait_until_exercise_is_complete
		    =
		    gui_boss.exercise_appwindow ();

		wait_until_exercise_is_complete ();


		fire_end_gun ();
		

		();
	    };

	fun run ()
	    =
	    {   # Remove any old version of the tracefile:
		#
		if (isfile tracefile)  
		    unlink tracefile;
		fi;


		printf "\nDoing %s:\n" name;   


		# Open tracelog file and
                # select tracing level:
		#
		{   include logger;				# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
		    #
		    set_logger_to  (fil::LOG_TO_FILE tracefile);
		    #
#		    enable fil::all_logging;			# Gross overkill.
#		    enable xtr::xkit_logging;			# Lesser overkill.
#		    enable xtr::io_logging;			# Saner yet.	
		};

		assert  (tsr::thread_scheduler_is_running ());

		exercise_window_stuff  ();



		assert TRUE;

		summarize_unit_tests  name;
	    };
    };

end;
