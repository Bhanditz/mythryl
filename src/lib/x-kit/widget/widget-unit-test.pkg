## widget-unit-test.pkg
#
# For the big picture see the imp dataflow diagrams in
#
#     src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
#
# NB: We must compile this locally via
#         xclient-internals.sublib
#     instead of globally via
#         src/lib/test/unit-tests.lib
#     like most unit tests, in order to have
#     access to required library internals.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


# Run by:
#     src/lib/test/all-unit-tests.pkg

stipulate
    include package   unit_test;				# unit_test				is from   src/lib/src/unit-test.pkg
    include package   makelib::scripting_globals;
    include package   threadkit;				# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ap  =  client_to_atom;				# client_to_atom			is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
    package au  =  authentication;				# authentication			is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package awx =  windowsystem_imp_for_x;			# windowsystem_imp_for_x		is from   src/lib/x-kit/widget/xkit/app/windowsystem-imp-for-x.pkg
    package cpm =  cs_pixmap;					# cs_pixmap				is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
    package cpt =  cs_pixmat;					# cs_pixmat				is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
    #
    package gd  =  gui_displaylist;				# gui_displaylist			is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    package gp  =  gui_plan;					# gui_plan				is from   src/lib/x-kit/widget/gui/gui-plan.pkg
    package sg  =  stopped_gui;					# stopped_gui				is from   src/lib/x-kit/widget/gui/stopped-gui.pkg
    #
    package dbx =  bounce_theme_imp;				# bounce_theme_imp			is from   src/lib/x-kit/widget/xkit/theme/bounce/default/default-bounce-theme-for-x.pkg
    package dcx =  canvas_theme_imp;				# canvas_theme_imp			is from   src/lib/x-kit/widget/xkit/theme/canvas/default/default-canvas-theme-for-x.pkg
    package dtx =  packed_theme_imp;				# packed_theme_imp			is from   src/lib/x-kit/widget/xkit/theme/packed/default/default-packed-theme-for-x.pkg
    #
    package dy  =  display;					# display				is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package w2x =  windowsystem_to_xserver;			# windowsystem_to_xserver		is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xserver.pkg
    package fil =  file__premicrothread;			# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
    package fti =  font_index;					# font_index				is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
    package g2p =  guiboss_to_packedspace;			# guiboss_to_packedspace		is from   src/lib/x-kit/widget/space/packed/guiboss-to-packedspace.pkg
    package gws =  guiboss_to_windowsystem;			# guiboss_to_windowsystem		is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg
    package gq  =  guiboss_imp;					# guiboss_imp				is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
#   package c2g =  client_to_guiboss;				# client_to_guiboss			is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap		is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
    package mtx =  rw_matrix;					# rw_matrix				is from   src/lib/std/src/rw-matrix.pkg
    package r8  =  rgb8;					# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package rgb =  rgb;						# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package rop =  ro_pixmap;					# ro_pixmap				is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
    package rw  =  root_window;					# root_window				is from   src/lib/x-kit/widget/lib/root-window.pkg
    package rwv =  rw_vector;					# rw_vector				is from   src/lib/std/src/rw-vector.pkg
    package sep =  client_to_selection;				# client_to_selection			is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
    package shp =  shade;					# shade					is from   src/lib/x-kit/widget/lib/shade.pkg
    package sj  =  socket_junk;					# socket_junk				is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer			is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
    package plh =  packedspace_layout_hint;			# packedspace_layout_hint		is from   src/lib/x-kit/widget/space/packed/packedspace-layout-hint.pkg
    package ti  =  template_imp;				# template_imp				is from   src/lib/x-kit/xclient/src/wire/template-imp.pkg
    package tem =  template;					# template				is from   src/lib/x-kit/xclient/src/wire/template.pkg
    package tr  =  logger;					# logger				is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
    package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
    package u1  =  one_byte_unt;				# one_byte_unt				is from   src/lib/std/one-byte-unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts		is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire				is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package wg  =  widget;					# widget				is from   src/lib/x-kit/widget/old/basic/widget.pkg
    package wi  =  window;					# window				is from   src/lib/x-kit/xclient/src/window/window.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink			is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package wpp =  client_to_window_watcher;			# client_to_window_watcher		is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
    package wy  =  widget_style;				# widget_style				is from   src/lib/x-kit/widget/lib/widget-style.pkg
    package xc  =  xclient;					# xclient				is from   src/lib/x-kit/xclient/xclient.pkg
    package xg  =  xgeometry;					# xgeometry				is from   src/lib/std/2d/xgeometry.pkg
    package xj  =  xsession_junk;				# xsession_junk				is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package xtr =  xlogger;					# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package ab  =  arrowbutton;					# arrowbutton				is from   src/lib/x-kit/widget/leaf/arrowbutton.pkg

    package iul =  issue_unique_look_id;			# issue_unique_look_id			is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    package g2g =  gadget_to_guiboss;				# gadget_to_guiboss			is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
    package w2p =  widget_to_packedspace;			# widget_to_packedspace			is from   src/lib/x-kit/widget/space/packed/look-to-packed.pkg

#   package xet =  xevent_types;				# xevent_types				is from   src/lib/x-kit/xclient/src/wire/xevent-types.pkg
#   package e2s =  xevent_to_string;				# xevent_to_string			is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
#   package xt  =  xtypes;					# xtypes				is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    #
    # The above three are the X-specific versions of the
    # below two platform-independent packages.  X events
    # come to windowsystem-imp-for-x in xet:: encoding.  It	# For the big dataflow diagram see   src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
    # translates them to evt:: encoding and forward them to
    # guiboss_imp, which forwards them to appropriate imps.	# guiboss_imp				is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
    #
    package gt  =  gui_types;					# gui_types				is from   src/lib/x-kit/widget/gui/gui-types.pkg
    package pt  =  packed_theme;				# packed_theme				is from   src/lib/x-kit/widget/theme/packed/packed-theme.pkg

    package evt =  gui_event_types;				# gui_event_types			is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
#   package gts =  gui_event_to_string;				# gui_event_to_string			is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    #
    # This one translates from the X to Gui versions:
#   package x2g =  xevent_to_gui_event;				# xevent_to_gui_event			is from   src/lib/x-kit/widget/xkit/app/xevent-to-gui-event.pkg
#   package g2x =  gui_event_to_xevent;				# gui_event_to_xevent			is from   src/lib/x-kit/widget/xkit/app/gui-event-to-xevent.pkg

    package oim =  object_imp;					# object_imp				is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/object-imp.pkg
    package sim =  sprite_imp;					# sprite_imp				is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/sprite-imp.pkg
    package wim =  widget_imp;					# widget_imp				is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg

    tracefile   =  "widget-unit-test.trace.log";

#   id =  iui::issue_unique_id;

    nb =  log::note_on_stderr;					# log					is from   src/lib/std/src/log.pkg

Dummy1 = wim::Packed_Widget;
Dummy2 = oim::Canvas_Object;
Dummy3 = sim::Bounce_Sprite;
dummy4 = ab::has;

herein

    package widget_unit_test {
	#
	name = "src/lib/x-kit/widget/widget-unit-test.pkg";

	trace =  xtr::log_if  xtr::io_logging 0;		# Conditionally write strings to tracing.log or whatever.


	fun exercise_window_stuff  ()
	    =
	    {
		fun int_sink i = ();
printf "widget-unit-test.pkg/exercise_window_stuff/TOP\n";

		# Here we build a three-layer cake:
		#
		#    -----------------
		#    |     Gui Boss |
		#    -----------------
		#    |     Theme     |
		#    -----------------
		#    |     Appwindow |
		#    -----------------
		#
		# The Gui Boss is windowsystem-agnostic; it de/constructs and maintains running GUI impnets from gui specification trees. 
		# The Theme is windowsystem-specific (e.g., X-specific) and encapsulates how to draw the various widgets on the given windowsystem.
		# The Appwindow is windowsystem-specific and encapulates X-specific application window stuff like EXPOSE event-handling.


		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		windowsystem_needs
		    =
		    { 
		    };

		windowsystem_options =  [];
		windowsystem_arg     =  (windowsystem_needs, windowsystem_options);
		#
		(awx::make_windowsystem_egg  windowsystem_arg  NULL) ->  windowsystem_egg;
		#
		(windowsystem_egg			()) ->   (windowsystem_exports, windowsystem_egg');


		(dbx::make_bounce_theme_egg	[]) ->   bounce_theme_egg;
		(bounce_theme_egg		()) ->  (bounce_theme_exports, bounce_theme_egg');
		#
		(dcx::make_canvas_theme_egg	[]) ->   canvas_theme_egg;
		(canvas_theme_egg		()) ->  (canvas_theme_exports, canvas_theme_egg');
		#
		(dtx::make_packed_theme_egg	[]) ->   packed_theme_egg;
		(packed_theme_egg		()) ->  (packed_theme_exports, packed_theme_egg');

		
		(gq::make_guiboss_egg		[]) ->  guiboss_egg;
		(guiboss_egg			()) -> (guiboss_exports, guiboss_egg');

		#
		(ti::make_template_egg		[]) -> template_egg;
		(template_egg			()) -> (template_exports, template_egg');

		#
		windowsystem_exports	-> { guiboss_to_windowsystem	};
		#
		bounce_theme_exports	-> { gui_to_bounce_theme	};
		canvas_theme_exports	-> { gui_to_canvas_theme	};
		packed_theme_exports	-> { theme			};
		#
		guiboss_exports	-> { client_to_guiboss	};
		template_exports	-> { template		};

		template_imports = { int_sink =>  \\ (i: Int) = ()  };

		guiboss_egg'		( { int_sink,
					    guiboss_to_windowsystem,
					    gui_to_bounce_theme,
					    gui_to_canvas_theme,
					    theme
					  },
					  run_gun', end_gun'
				        );
		#
		bounce_theme_egg'	({ int_sink,     guiboss_to_windowsystem	},	run_gun', end_gun');
		canvas_theme_egg'	({ int_sink,     guiboss_to_windowsystem	},	run_gun', end_gun');
		packed_theme_egg'	({ int_sink,     guiboss_to_windowsystem	},	run_gun', end_gun');
		#
		windowsystem_egg'	({ int_sink					},	run_gun', end_gun');
		template_egg'		( template_imports,					run_gun', end_gun');



		fire_run_gun ();

		b  =  client_to_guiboss.get_bounce_theme ();
		c  =  client_to_guiboss.get_canvas_theme ();
		t  =  client_to_guiboss.get_packed_theme ();
		#
		{
		    include package   gui_plan;							# gui_plan		is from   src/lib/x-kit/widget/gui/gui-plan.pkg
		    #
		    #

		           layout_hints =  []:  List( plh::Packedspace_Layout_Hint	);
		    packedspace_options =  []:        g2p::Packedspace_Arg;

# We do not yet have asserts on these two:    XXX SUCKO FIXME
		    got_state_change_event	= REF FALSE;
		    got_start_of_frame_event	= REF FALSE;
		    #
		    got_button_press_event	= REF FALSE;
		    got_button_release_event	= REF FALSE;
		    #
		    got_key_press_event		= REF FALSE;
		    got_key_release_event	= REF FALSE;

# 		    stipulate
# 			first_frame1 =  REF TRUE;
# 			first_frame2 =  REF TRUE;
# 
# 			fun start_of_frame_fn1
# 			    {
# 			      id:				iul::Id,						# Unique id.
# 			      frame_number:			Int,							# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
# 			      site:				xg::Box,						# Window rectangle in which to draw.
# 			      visible:				Bool,							# If FALSE, widget is not visible on screen, so widget-imp may be able to avoid updating foreground and background.
# 			      duration_in_seconds:		Float,							# If state has changed widget-imp should call note_changed_gadget_foreground() before this time is up. Also useful for motionblur.
# 			      gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
# 			      widget_to_packedspace:		w2p::Widget_To_Packedspace,
# 			      this_gadget_mode:			g2g::Gadget_Mode,
# 			      theme:				pt::Packed_Theme
# 			    }
# 			    =
# 			    {
# #				if *first_frame1
# 				    first_frame1 := FALSE;
# 
# 				    background_box =  site;
# 				    foreground_box =  xg::box::make_nested_box (background_box, 4);
# 
# 				    background = gd::COLOR (r8::rgb8_red,    [ gd::POLY_FILL_BOX [ background_box ]]);
# 				    foreground = gd::COLOR (r8::rgb8_yellow, [ gd::POLY_FILL_BOX [ foreground_box ]]);
# 
# 				    gadget_to_guiboss.note_changed_gadget_foreground { id, foreground };
# 				    gadget_to_guiboss.note_changed_gadget_background { id, background };
# #				fi;
# 			    };
# 
# 			fun start_of_frame_fn2
# 			    {
# 			      id:				iul::Id,						# Unique id.
# 			      frame_number:			Int,							# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
# 			      site:				xg::Box,						# Window rectangle in which to draw.
# 			      visible:				Bool,							# If FALSE, widget is not visible on screen, so widget-imp may be able to avoid updating foreground and background.
# 			      duration_in_seconds:		Float,							# If state has changed widget-imp should call note_changed_gadget_foreground() before this time is up. Also useful for motionblur.
# 			      gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
# 			      widget_to_packedspace:		w2p::Widget_To_Packedspace,
# 			      this_gadget_mode:			g2g::Gadget_Mode,
# 			      theme:				pt::Packed_Theme
# 			    }
# 			    =
# 			    {
# #				if *first_frame
# 				    first_frame2 := FALSE;
# 
# 				    background_box =  site;
# 				    foreground_box =  xg::box::make_nested_box (background_box, 4);
# 
# 				    background = gd::COLOR (r8::rgb8_red,    [ gd::POLY_FILL_BOX [ background_box ]]);
# 				    foreground = gd::COLOR (r8::rgb8_yellow, [ gd::POLY_FILL_BOX [ foreground_box ]]);
# 
# 				    gadget_to_guiboss.note_changed_gadget_foreground { id, foreground };
# 				    gadget_to_guiboss.note_changed_gadget_background { id, background };
# #				fi;
# 			    };
# 
# 			fun button_press_fn
# 			      { button:				evt::Mousebutton,
# 				point:				xg::Point,
# 				site:		 		xg::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
# 				widget_to_packedspace:		w2p::Widget_To_Packedspace,
# 				theme:				pt::Packed_Theme
# 			      }
# 			    = 
# 			    {
# 				got_button_press_event := TRUE;
# nb {. sprintf "button_press_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			fun button_release_fn
# 			      { button:				evt::Mousebutton,
# 				point:				xg::Point,
# 				site:		 		xg::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
# 				widget_to_packedspace:		w2p::Widget_To_Packedspace,
# 				theme:				pt::Packed_Theme
# 			      }
# 			    = 
# 			    {
# 				got_button_release_event := TRUE;
# nb {. sprintf "button_release_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			fun key_press_fn
# 			      { keycode:			evt::Keycode,						# Keycode of the depressed key.
# 				keysym:				evt::Keysym,						# Keysym  of the depressed key.
# 				ascii:				String,							# Ascii  for the depressed key.
# 				point:				xg::Point,
# 				site:		 		xg::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
# 				widget_to_packedspace:		w2p::Widget_To_Packedspace,
# 				theme:				pt::Packed_Theme
# 			      }
# 			    = 
# 			    {
# 				got_key_press_event := TRUE;
# nb {. sprintf "key_press_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			fun key_release_fn
# 			      { keycode:			evt::Keycode,						# Keycode of the released key.
# 				keysym:				evt::Keysym,						# Keysym  of the released key.
# 				ascii:				String,							# Ascii  for the released key.
# 				point:				xg::Point,
# 				site:		 		xg::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				gadget_to_guiboss:		g2g::Gadget_To_Guiboss,
# 				widget_to_packedspace:		w2p::Widget_To_Packedspace,
# 				theme:				pt::Packed_Theme
# 			      }
# 			    = 
# 			    {
# 				got_key_release_event := TRUE;
# nb {. sprintf "key_release_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			packed_widget_options1
# 			  =
# 			  [
# 			    wim::START_OF_FRAME_FN	start_of_frame_fn1,
# 			    wim::BUTTON_PRESS_FN	button_press_fn,
# 			    wim::BUTTON_RELEASE_FN	button_release_fn,
# 			    wim::KEY_PRESS_FN		key_press_fn,
# 			    wim::KEY_RELEASE_FN		key_release_fn
# 			  ];
# 
# 			packed_widget_options2
# 			  =
# 			  [
# 			    wim::START_OF_FRAME_FN	start_of_frame_fn2,
# 			    wim::BUTTON_PRESS_FN	button_press_fn,
# 			    wim::BUTTON_RELEASE_FN	button_release_fn,
# 			    wim::KEY_PRESS_FN		key_press_fn,
# 			    wim::KEY_RELEASE_FN		key_release_fn
# 			  ];
# 
# 		    herein
# 			make_packed_widget_fn1 =  wim::make_packed_widget_start_fn  packed_widget_options1;
# 			make_packed_widget_fn2 =  wim::make_packed_widget_start_fn  packed_widget_options2;
# 			    
# 		    end;

		    gui_plan
		      =
		      ( packedspace_options,
			#
			ROW [
			      arrowbutton::has [],
			      arrowbutton::has [],
			      arrowbutton::has []
			    ]
		      );

nb {. sprintf "widget-unit-test pprinting gui_plan:"; };
		    gp::pprint_gui_plan  gui_plan;

		    topwindow_hints		# The following values are the defaults, so we
			=			# could omit them all here and pass an empty list:
			[
			  gws::BACKGROUND_PIXEL	(r8::rgb8_from_ints (16, 128+32, 32)),		# Slightly desaturated green.
			  gws::BORDER_PIXEL	(r8::rgb8_from_ints (0,       0,  0)),		# Black.
			  #
			  gws::SITE		( { upperleft		=>   { col =>    0, row  =>  0 },
						    size		=>   { wide => 800, high => 600 },
						    border_thickness	=>  1
						  }
						  : xg::Window_Site
						)
			];

nb {. sprintf "widget-unit-test calling client_to_guiboss.make_topwindow..."; };
		    (client_to_guiboss.make_topwindow  topwindow_hints)
			->
			guiboss_to_topwindow;

		    (guiboss_to_topwindow.exercise_appwindow ())
			->
		        wait_until_exercise_is_complete;
			

		    wait_until_exercise_is_complete ();



nb {. sprintf "widget-unit-test calling client_to_guiboss.start_gui..."; };
		    (client_to_guiboss.start_gui  (guiboss_to_topwindow, gui_plan))
			->
			block_until_gui_startup_is_complete;

nb {. sprintf "widget-unit-test calling block_until_gui_startup_is_complete() ..."; };
		    (block_until_gui_startup_is_complete())
			->
			client_to_guiwindow;

nb {. sprintf "widget-unit-test doing guiboss_to_topwindow.send_fake_mousebutton_press_event() ..."; };
		    #
#		    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, { row => 13, col => 17 });
#		    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, { row => 14, col => 18 });
		    #
#		    guiboss_to_topwindow.send_fake_key_press_event   (evt::KEYCODE 1, { row => 23, col => 27 });
#		    guiboss_to_topwindow.send_fake_key_release_event (evt::KEYCODE 1, { row => 24, col => 28 });

nb {. sprintf "widget-unit-test calling sleep_for 30.0 ..."; };
		    sleep_for 30.0;

#		    assert *got_button_press_event;
#		    assert *got_button_release_event;

#		    assert *got_key_press_event;
#		    assert *got_key_release_event;

nb {. sprintf "widget-unit-test ending gui run..."; };
		    stopped_gui' = client_to_guiwindow.stop_gui ();

nb {. sprintf "widget-unit-test pprinting stopped_gui':"; };
		    sg::pprint_stopped_gui  stopped_gui';
		};	

		sprite_to_bouncespace									# Dummy port back to bouncespace-imp from sprite-imp.
		  =
		  { id           =>  id_zero,
		    look_changed =>  (\\ _ = ())
		  };

		object_to_canvasspace									# Dummy port back to canvasspace-imp from object-imp.
		  =
		  { id           =>  id_zero,
		    look_changed =>  (\\ _ = ())
		  };



# Following is broken at the moment by the restructuring
# of bounce and canvas code on the model of packed code.
# In particular I think balls wound up with boolean values
# instead of position+velocity values.
#
# For the moment my focus is elsewhere so I'm letting this slide.
# XXX SUCKO FIXME.
# 			-- 2014-07-05 CrT

#		ball_state_endstate_oneshot = NULL;
#		ball_look_endstate_oneshot  = NULL;
#		ball_look_arg         = [];
#		ball_arg =  ( { position => { x => 0.0, y => 0.0, z => 0.0 },
#				velocity => { x => 0.0, y => 0.0, z => 0.0 }
#			      }, 	
#			      []
#			    );
#		(dbl::make_egg ( /* guiboss_to_windowsystem, */ ball_arg, ball_look_arg, sprite_to_bouncespace, ball_state_endstate_oneshot, ball_look_endstate_oneshot))
#		    ->
#		    ball_look_egg;
#
#
#
#		node_state_endstate_oneshot = NULL;
#		node_look_endstate_oneshot  = NULL;
#		node_look_arg         = [];
#		node_arg =  ( { text => "foo" },
#			      []
#			    );
#		(dnl::make_egg ( /* guiboss_to_windowsystem, */ node_arg, node_look_arg, object_to_canvasspace, node_state_endstate_oneshot, node_look_endstate_oneshot))
#		    ->
#		    node_look_egg;


		fire_end_gun ();
		

		();
	    };

	fun run ()
	    =
	    {   # Remove any old version of the tracefile:
		#
		if (isfile tracefile)  
		    unlink tracefile;
		fi;


		printf "\nDoing %s:\n" name;   


		# Open tracelog file and
                # select tracing level:
		#
		{   include package   logger;				# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
		    #
		    set_logger_to  (fil::LOG_TO_FILE tracefile);
		    #
#		    enable fil::all_logging;			# Gross overkill.
#		    enable xtr::xkit_logging;			# Lesser overkill.
#		    enable xtr::io_logging;			# Saner yet.	
		};

		assert  (tsr::thread_scheduler_is_running ());

		exercise_window_stuff  ();



		assert TRUE;

		summarize_unit_tests  name;
	    };
    };

end;
