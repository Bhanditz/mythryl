## widget-unit-test.pkg
#
# NB: We must compile this locally via
#         xclient-internals.sublib
#     instead of globally via
#         src/lib/test/unit-tests.lib
#     like most unit tests, in order to have
#     access to required library internals.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


# Run by:
#     src/lib/test/all-unit-tests.pkg

stipulate
    include unit_test;						# unit_test			is from   src/lib/src/unit-test.pkg
    include makelib::scripting_globals;
    include threadkit;						# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ap  =  atom_port;					# atom_port			is from   src/lib/x-kit/xclient/src/iccc/atom-port.pkg
    package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package awx =  appwindow_for_x;				# appwindow_for_x		is from   src/lib/x-kit/widget/xkit/app/appwindow-for-x.pkg
    package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
    package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
    package dlx =  default_label_skin_for_x;			# default_label_skin_for_x	is from   src/lib/x-kit/widget/xkit/theme/default/default-label-skin-for-x.pkg
    package dtx =  default_theme_for_x;				# default_theme_for_x		is from   src/lib/x-kit/widget/xkit/theme/default/default-theme-for-x.pkg
    package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package et  =  event_types;					# event_types			is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package exp =  xserver;					# xserver			is from   src/lib/x-kit/xclient/src/window/xserver.pkg
    package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
    package gq  =  gui_queen;					# gui_queen			is from   src/lib/x-kit/widget/gui/gui-queen.pkg
    package gqp =  gui_queen_port;				# gui_queen_port		is from   src/lib/x-kit/widget/gui/gui-queen-port.pkg
    package kp  =  keymap;					# keymap			is from   src/lib/x-kit/xclient/src/window/keymap.pkg
    package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package rgb =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
    package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
    package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
    package s2p =  xevent_to_window;				# xevent_to_window		is from   src/lib/x-kit/xclient/src/window/xevent-to-window.pkg
    package sep =  selection_port;				# selection_port		is from   src/lib/x-kit/xclient/src/window/selection-port.pkg
    package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
    package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
    package sp  =  xsequencer;					# xsequencery			is from   src/lib/x-kit/xclient/src/wire/xsequencer.pkg
    package ti  =  template_imp;				# template_imp			is from   src/lib/x-kit/xclient/src/wire/template-imp.pkg
    package tem =  template;					# template			is from   src/lib/x-kit/xclient/src/wire/template.pkg
    package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
    package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
    package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/basic/widget.pkg
    package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package wpp =  window_watcher;				# window_watcher		is from   src/lib/x-kit/xclient/src/window/window-watcher.pkg
    package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
    package x2s =  xevent_to_string;				# xevent_to_string		is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
    package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
    package xg  =  xgeometry;					# xgeometry			is from   src/lib/std/2d/xgeometry.pkg
    package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package xt  =  xtypes;					# xtypes			is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #
    tracefile   =  "widget-unit-test.trace.log";
herein

    package widget_unit_test {

	name = "src/lib/x-kit/widget/widget-unit-test.pkg";

	trace =  xtr::log_if  xtr::io_logging 0;		# Conditionally write strings to tracing.log or whatever.


	fun exercise_window_stuff  ()
	    =
	    {
		fun int_sink i = ();
printf "widget-unit-test.pkg/exercise_window_stuff/TOP\n";

		# Here we build a three-layer cake:
		#
		#    -----------------
		#    |     Gui Queen |
		#    -----------------
		#    |     Theme     |
		#    -----------------
		#    |     Appwindow |
		#    -----------------
		#
		# The Gui Queen is renderlib-agnostic; it de/constructs and maintains running GUI impnets from gui specification trees. 
		# The Theme is renderlib-specific (e.g., X-specific) and encapsulates how to draw the various widgets on the given renderlib.
		# The Appwindow is renderlib-specific and encapulates X-specific application window stuff like EXPOSE event-handling.


		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		(awx::make_appwindow_state ()) ->    appwindow_for_x_state;
		(awx::make_appwindow    "awx") ->   (appwindow_for_x_configstate, appwindow_for_x_exports);
		#
		(dtx::make_theme_state ()) ->  theme_state;
		(dtx::make_theme    "dtx") -> (theme_configstate, theme_exports);
		#
		(gq::make_gui_queen_state ()) ->  gui_queen_state;
		(gq::make_gui_queen     "gq") -> (gui_queen_configstate, gui_queen_exports);
		#
		(dlx::make_label_skin_state ()) -> label_skin_state;
		#
		(ti::make_template_egg [])	-> template_egg;
		(template_egg ())		-> (template_exports, template_egg');

		#
		appwindow_for_x_exports     -> { appwindow_port };
		theme_exports               -> { theme_port	};
		gui_queen_exports	    -> { gui_queen_port };
		template_exports	    -> { template	};

		template_imports = { int_sink =>  fn (i: Int) = ()  };

		awx::configure_appwindow     (    appwindow_for_x_configstate,     appwindow_for_x_state,  { int_sink                            },  run_gun', end_gun');
		dtx::configure_theme               (              theme_configstate,               theme_state,  { int_sink,     appwindow_port  },  run_gun', end_gun');
		 gq::configure_gui_queen           (          gui_queen_configstate,           gui_queen_state,  { int_sink,               theme_port  },  run_gun', end_gun');

		template_egg' (template_imports, run_gun', end_gun');



		fire_run_gun ();

#		wait_until_exercise_is_complete
#		    =
#		    appwindow_port.exercise_appwindow ();
#
# printf "widget-unit-text.pkg/exercise_window_stuff waiting for exercise to complete...\n";
#		wait_until_exercise_is_complete ();
# printf "widget-unit-text.pkg/exercise_window_stuff done waiting for exercise to complete.\n";

#		wait_until_exercise_is_complete
#		    =
#		    default_theme_for_x_port.exercise_appwindow ();
#
#		wait_until_exercise_is_complete ();


		wait_until_exercise_is_complete
		    =
		    gui_queen_port.exercise_appwindow ();

		wait_until_exercise_is_complete ();


		fire_end_gun ();
		

		();
	    };

	fun run ()
	    =
	    {   # Remove any old version of the tracefile:
		#
		if (isfile tracefile)  
		    unlink tracefile;
		fi;


		printf "\nDoing %s:\n" name;   


		# Open tracelog file and
                # select tracing level:
		#
		{   include logger;				# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
		    #
		    set_logger_to  (fil::LOG_TO_FILE tracefile);
		    #
#		    enable fil::all_logging;			# Gross overkill.
#		    enable xtr::xkit_logging;			# Lesser overkill.
#		    enable xtr::io_logging;			# Saner yet.	
		};

		assert  (tsr::thread_scheduler_is_running ());

		exercise_window_stuff  ();



		assert TRUE;

		summarize_unit_tests  name;
	    };
    };

end;
