## widget-unit-test.pkg
#
# For the big picture see the imp dataflow diagrams in
#
#     src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
#
# NB: We must compile this locally via
#         xclient-internals.sublib
#     instead of globally via
#         src/lib/test/unit-tests.lib
#     like most unit tests, in order to have
#     access to required library internals.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


# Run by:
#     src/lib/test/all-unit-tests.pkg

stipulate
    include package   unit_test;				# unit_test				is from   src/lib/src/unit-test.pkg
    include package   makelib::scripting_globals;
    include package   threadkit;				# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ap  =  client_to_atom;				# client_to_atom			is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
    package au  =  authentication;				# authentication			is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package awx =  windowsystem_imp_for_x;			# windowsystem_imp_for_x		is from   src/lib/x-kit/widget/xkit/app/windowsystem-imp-for-x.pkg
    package cpm =  cs_pixmap;					# cs_pixmap				is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
    package cpt =  cs_pixmat;					# cs_pixmat				is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
    #
    package gd  =  gui_displaylist;				# gui_displaylist			is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    #
    package dbx =  bounce_theme_imp;				# bounce_theme_imp			is from   src/lib/x-kit/widget/xkit/theme/bounce/default/default-bounce-theme-for-x.pkg
    package dcx =  canvas_theme_imp;				# canvas_theme_imp			is from   src/lib/x-kit/widget/xkit/theme/canvas/default/default-canvas-theme-for-x.pkg
    package dtx =  packed_theme_imp;				# packed_theme_imp			is from   src/lib/x-kit/widget/xkit/theme/packed/default/default-packed-theme-for-x.pkg
    #
    package dy  =  display;					# display				is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package w2x =  windowsystem_to_xserver;			# windowsystem_to_xserver		is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xserver.pkg
    package fil =  file__premicrothread;			# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
    package fti =  font_index;					# font_index				is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
    package gws =  guiboss_to_windowsystem;			# guiboss_to_windowsystem		is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg
    package gq  =  guiboss_imp;					# guiboss_imp				is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
#   package c2g =  client_to_guiboss;				# client_to_guiboss			is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap		is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
    package mtx =  rw_matrix;					# rw_matrix				is from   src/lib/std/src/rw-matrix.pkg
    package r8  =  rgb8;					# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package rgb =  rgb;						# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package rop =  ro_pixmap;					# ro_pixmap				is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
    package rw  =  root_window;					# root_window				is from   src/lib/x-kit/widget/lib/root-window.pkg
    package rwv =  rw_vector;					# rw_vector				is from   src/lib/std/src/rw-vector.pkg
    package sep =  client_to_selection;				# client_to_selection			is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
    package shp =  shade;					# shade					is from   src/lib/x-kit/widget/lib/shade.pkg
    package sj  =  socket_junk;					# socket_junk				is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer			is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
    package plh =  packedspace_layout_hint;			# packedspace_layout_hint		is from   src/lib/x-kit/widget/space/packed/packedspace-layout-hint.pkg
    package ti  =  template_imp;				# template_imp				is from   src/lib/x-kit/xclient/src/wire/template-imp.pkg
    package tem =  template;					# template				is from   src/lib/x-kit/xclient/src/wire/template.pkg
    package tr  =  logger;					# logger				is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
    package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
    package u1  =  one_byte_unt;				# one_byte_unt				is from   src/lib/std/one-byte-unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts		is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire				is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package wg  =  widget;					# widget				is from   src/lib/x-kit/widget/old/basic/widget.pkg
    package wi  =  window;					# window				is from   src/lib/x-kit/xclient/src/window/window.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink			is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package wpp =  client_to_window_watcher;			# client_to_window_watcher		is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
    package wy  =  widget_style;				# widget_style				is from   src/lib/x-kit/widget/lib/widget-style.pkg
    package xc  =  xclient;					# xclient				is from   src/lib/x-kit/xclient/xclient.pkg
    package g2d =  geometry2d;					# geometry2d				is from   src/lib/std/2d/geometry2d.pkg
    package xj  =  xsession_junk;				# xsession_junk				is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package xtr =  xlogger;					# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package ab  =  arrowbutton;					# arrowbutton				is from   src/lib/x-kit/widget/leaf/arrowbutton.pkg
    package bb  =  boxbutton;					# boxbutton				is from   src/lib/x-kit/widget/leaf/boxbutton.pkg
    package db  =  diamondbutton;				# diamondbutton				is from   src/lib/x-kit/widget/leaf/diamondbutton.pkg
    package rb  =  roundbutton;					# roundbutton				is from   src/lib/x-kit/widget/leaf/roundbutton.pkg

    package iul =  issue_unique_look_id;			# issue_unique_look_id			is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

#   package b2g =  guiboss_to_gadget;				# guiboss_to_gadget			is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg
#   package g2g =  gadget_to_guiboss;				# gadget_to_guiboss			is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
    package w2p =  widget_to_packedspace;			# widget_to_packedspace			is from   src/lib/x-kit/widget/space/packed/look-to-packed.pkg

#   package xet =  xevent_types;				# xevent_types				is from   src/lib/x-kit/xclient/src/wire/xevent-types.pkg
#   package e2s =  xevent_to_string;				# xevent_to_string			is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
#   package xt  =  xtypes;					# xtypes				is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    #
    # The above three are the X-specific versions of the
    # below two platform-independent packages.  X events
    # come to windowsystem-imp-for-x in xet:: encoding.  It	# For the big dataflow diagram see   src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
    # translates them to evt:: encoding and forward them to
    # guiboss_imp, which forwards them to appropriate imps.	# guiboss_imp				is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
    #
    package gt  =  guiboss_types;				# guiboss_types				is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
    package pt  =  packed_theme;				# packed_theme				is from   src/lib/x-kit/widget/theme/packed/packed-theme.pkg

    package evt =  gui_event_types;				# gui_event_types			is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
#   package gts =  gui_event_to_string;				# gui_event_to_string			is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    #
    # This one translates from the X to Gui versions:
#   package x2g =  xevent_to_gui_event;				# xevent_to_gui_event			is from   src/lib/x-kit/widget/xkit/app/xevent-to-gui-event.pkg
#   package g2x =  gui_event_to_xevent;				# gui_event_to_xevent			is from   src/lib/x-kit/widget/xkit/app/gui-event-to-xevent.pkg

    package oim =  object_imp;					# object_imp				is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/object-imp.pkg
    package sim =  sprite_imp;					# sprite_imp				is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/sprite-imp.pkg
    package wim =  widget_imp;					# widget_imp				is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg

    tracefile   =  "widget-unit-test.trace.log";

#   id =  iui::issue_unique_id;

    nb =  log::note_on_stderr;					# log					is from   src/lib/std/src/log.pkg

Dummy1 = wim::Packed_Widget;
Dummy2 = oim::Canvas_Object;
Dummy3 = sim::Bounce_Sprite;
dummy4 = ab::has;

herein

    package widget_unit_test {
	#
	name = "src/lib/x-kit/widget/widget-unit-test.pkg";

	trace =  xtr::log_if  xtr::io_logging 0;		# Conditionally write strings to tracing.log or whatever.


	fun exercise_convex_hull  ()				# Probably should be in a separate geometry2d-unit-text.pkg, but at the moment I'm too lazy to take time to establish one.
	    =
	    {
		points1 = [ { col => 100, row => 100 }, { col => 400, row => 100 }, { col => 400, row => 400 }, { col => 100, row => 400 } ];
		points2 = [ { col => 200, row => 200 }, { col => 300, row => 200 }, { col => 300, row => 300 }, { col => 200, row => 300 } ];
		points3 = points1 @ points2;
		#
		points1' = g2d::convex_hull points1;
		points2' = g2d::convex_hull points2;
		points4  = g2d::convex_hull points3;
		#
		assert (points1' == points1);
		assert (points2' == points2);
		assert (points4  == points1);
		#
		points1' = g2d::convex_hull (reverse points1);
		points2' = g2d::convex_hull (reverse points2);
		points4  = g2d::convex_hull (reverse points3);
		#
		assert (points1' == points1);
		assert (points2' == points2);
		assert (points4  == points1);
	    };

	fun exercise_point_in_polygon ()				# Probably should be in a separate geometry2d-unit-text.pkg, but at the moment I'm too lazy to take time to establish one.
	    =
	    {
		# Basic square, as above
		#
		points = [ { col => 100, row => 100 }, { col => 200, row => 100 }, { col => 200, row => 200 }, { col => 100, row => 200 } ];
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };  	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) ==  TRUE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);




		points = [ { col => 100, row => 200 }, { col => 200, row => 200 }, { col => 200, row => 100 }, { col => 100, row => 100 } ];	# Does vertex order matter?

		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };  	# Middles of the 9 squares of a tic-tac-toe pattern.  
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) ==  TRUE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);




		points = [ { col => 100, row => 100 }, { col => 100, row => 100 },		# Do duplicate vertices matter?
			   { col => 200, row => 100 }, { col => 200, row => 100 },
			   { col => 200, row => 200 }, { col => 200, row => 200 },
                           { col => 100, row => 200 }, { col => 100, row => 200 }
			 ];

		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };    	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) ==  TRUE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);



		# Diamond instead of square:
		# 
		points = [ { col => 100, row => 150 }, { col => 150, row => 200 }, { col => 200, row => 150 }, { col => 150, row => 100 } ];
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) ==  TRUE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);



		# Chevron shape concave down:
		# 
		points = [ { col => 100, row => 150 }, { col => 150, row => 200 }, { col => 200, row => 150 }, { col => 150, row => 190 } ];
		#
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);


		# Chevron shape concave up:
		# 
		points = [ { col => 100, row => 150 }, { col => 150, row => 110 }, { col => 200, row => 150 }, { col => 150, row => 100 } ];
		#
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);


		# Chevron shape concave left:
		# 
		points = [ { col => 190, row => 150 }, { col => 150, row => 200 }, { col => 200, row => 150 }, { col => 150, row => 100 } ];
		#
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);


		# Chevron shape concave right:
		# 
		points = [ { col => 100, row => 150 }, { col => 150, row => 200 }, { col => 110, row => 150 }, { col => 150, row => 100 } ];
		#
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);


	    };

	fun exercise_window_stuff  ()
	    =
	    {
		fun int_sink i = ();
printf "widget-unit-test.pkg/exercise_window_stuff/TOP\n";

		# Here we build a three-layer cake:
		#
		#    -----------------
		#    |     Gui Boss |
		#    -----------------
		#    |     Theme     |
		#    -----------------
		#    |     Appwindow |
		#    -----------------
		#
		# The Gui Boss is windowsystem-agnostic; it de/constructs and maintains running GUI impnets from gui specification trees. 
		# The Theme is windowsystem-specific (e.g., X-specific) and encapsulates how to draw the various widgets on the given windowsystem.
		# The Appwindow is windowsystem-specific and encapulates X-specific application window stuff like EXPOSE event-handling.


		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		windowsystem_needs   =  { };
		windowsystem_options =  [ ];
		windowsystem_arg     =  (windowsystem_needs, windowsystem_options);
		#
		(awx::make_windowsystem_egg  windowsystem_arg  NULL) ->  windowsystem_egg;
		#
		(windowsystem_egg			()) ->   (windowsystem_exports, windowsystem_egg');


		(dbx::make_bounce_theme_egg	[]) ->   bounce_theme_egg;
		(bounce_theme_egg		()) ->  (bounce_theme_exports, bounce_theme_egg');
		#
		(dcx::make_canvas_theme_egg	[]) ->   canvas_theme_egg;
		(canvas_theme_egg		()) ->  (canvas_theme_exports, canvas_theme_egg');
		#
		(dtx::make_packed_theme_egg	[]) ->   packed_theme_egg;
		(packed_theme_egg		()) ->  (packed_theme_exports, packed_theme_egg');

		
		(gq::make_guiboss_egg		[]) ->  guiboss_egg;
		(guiboss_egg			()) -> (guiboss_exports, guiboss_egg');

		#
		(ti::make_template_egg		[]) -> template_egg;
		(template_egg			()) -> (template_exports, template_egg');

		#
		windowsystem_exports	-> { guiboss_to_windowsystem	};
		#
		bounce_theme_exports	-> { gui_to_bounce_theme	};
		canvas_theme_exports	-> { gui_to_canvas_theme	};
		packed_theme_exports	-> { theme			};
		#
		guiboss_exports		-> { client_to_guiboss	};
		template_exports	-> { template		};

		template_imports = { int_sink =>  \\ (i: Int) = ()  };

		guiboss_egg'		( { int_sink,
					    guiboss_to_windowsystem,
					    gui_to_bounce_theme,
					    gui_to_canvas_theme,
					    theme
					  },
					  run_gun', end_gun'
				        );
		#
		bounce_theme_egg'	({ int_sink,     guiboss_to_windowsystem	},	run_gun', end_gun');
		canvas_theme_egg'	({ int_sink,     guiboss_to_windowsystem	},	run_gun', end_gun');
		packed_theme_egg'	({ int_sink,     guiboss_to_windowsystem	},	run_gun', end_gun');
		#
		windowsystem_egg'	({ int_sink					},	run_gun', end_gun');
		template_egg'		( template_imports,					run_gun', end_gun');



		fire_run_gun ();

		b  =  client_to_guiboss.get_bounce_theme ();
		c  =  client_to_guiboss.get_canvas_theme ();
		t  =  client_to_guiboss.get_packed_theme ();
		#
		{
#		    include package   gui_plan;							# gui_plan		is from   src/lib/x-kit/widget/gui/gui-plan.pkg
		    #
		    #

		           layout_hints =  []:  List( plh::Packedspace_Layout_Hint	);
		    packedspace_options =  []:        gt::Packedspace_Arg;

# We do not yet have asserts on these two:    XXX SUCKO FIXME
		    got_state_change_event	= REF FALSE;
		    got_start_of_frame_event	= REF FALSE;
		    #
		    got_button_press_event	= REF FALSE;
		    got_button_release_event	= REF FALSE;
		    #
		    got_key_press_event		= REF FALSE;
		    got_key_release_event	= REF FALSE;

# 		    stipulate
# 			first_frame1 =  REF TRUE;
# 			first_frame2 =  REF TRUE;
# 
# 			fun start_of_frame_fn1
# 			    {
# 			      id:				iul::Id,						# Unique id.
# 			      frame_number:			Int,							# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
# 			      site:				g2d::Box,						# Window rectangle in which to draw.
# 			      visible:				Bool,							# If FALSE, widget is not visible on screen, so widget-imp may be able to avoid updating foreground and background.
# 			      duration_in_seconds:		Float,							# If state has changed widget-imp should call update_gadget_appearance() before this time is up. Also useful for motionblur.
# 			      gadget_to_guiboss:		gt::Gadget_To_Guiboss,
# 			      widget_to_packedspace:		w2p::Widget_To_Packedspace,
# 			      this_gadget_mode:			gt::Gadget_Mode,
# 			      theme:				pt::Packed_Theme
# 			    }
# 			    =
# 			    {
# #				if *first_frame1
# 				    first_frame1 := FALSE;
# 
# 				    background_box =  site;
# 				    foreground_box =  g2d::box::make_nested_box (background_box, 4);
# 
# 				    background = gt::CHANGED (THE (gd::COLOR (r8::rgb8_red,    [ gd::POLY_FILL_BOX [ background_box ]])));
# 				    foreground = gt::CHANGED (THE (gd::COLOR (r8::rgb8_yellow, [ gd::POLY_FILL_BOX [ foreground_box ]])));
# 
# 				    gadget_to_guiboss.update_gadget_appearance { id, foreground, background };
# #				fi;
# 			    };
# 
# 			fun start_of_frame_fn2
# 			    {
# 			      id:				iul::Id,						# Unique id.
# 			      frame_number:			Int,							# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
# 			      site:				g2d::Box,						# Window rectangle in which to draw.
# 			      visible:				Bool,							# If FALSE, widget is not visible on screen, so widget-imp may be able to avoid updating foreground and background.
# 			      duration_in_seconds:		Float,							# If state has changed widget-imp should call update_gadget_appearance() before this time is up. Also useful for motionblur.
# 			      gadget_to_guiboss:		gt::Gadget_To_Guiboss,
# 			      widget_to_packedspace:		w2p::Widget_To_Packedspace,
# 			      this_gadget_mode:			gt::Gadget_Mode,
# 			      theme:				pt::Packed_Theme
# 			    }
# 			    =
# 			    {
# #				if *first_frame
# 				    first_frame2 := FALSE;
# 
# 				    background_box =  site;
# 				    foreground_box =  g2d::box::make_nested_box (background_box, 4);
# 
# 				    background = gt::CHANGED (THE (gd::COLOR (r8::rgb8_red,    [ gd::POLY_FILL_BOX [ background_box ]])));
# 				    foreground = gt::CHANGED (THE (gd::COLOR (r8::rgb8_yellow, [ gd::POLY_FILL_BOX [ foreground_box ]])));
# 
# 				    gadget_to_guiboss.update_gadget_appearance { id, foreground, background };
# #				fi;
# 			    };
# 
# 			fun button_press_fn
# 			      {
#				id:				iul::Id,						# Unique id.
#				button:				evt::Mousebutton,
# 				point:				g2d::Point,
# 				site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				gadget_to_guiboss:		gt::Gadget_To_Guiboss,
# 				widget_to_packedspace:		w2p::Widget_To_Packedspace,
# 				theme:				pt::Packed_Theme
# 			      }
# 			    = 
# 			    {
# 				got_button_press_event := TRUE;
# nb {. sprintf "button_press_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			fun button_release_fn
# 			      {
#				id:				iul::Id,						# Unique id.
#				button:				evt::Mousebutton,
# 				point:				g2d::Point,
# 				site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				gadget_to_guiboss:		gt::Gadget_To_Guiboss,
# 				widget_to_packedspace:		w2p::Widget_To_Packedspace,
# 				theme:				pt::Packed_Theme
# 			      }
# 			    = 
# 			    {
# 				got_button_release_event := TRUE;
# nb {. sprintf "button_release_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			fun key_press_fn
# 			      {
#				id:				iul::Id,						# Unique id.
#				keycode:			evt::Keycode,						# Keycode of the depressed key.
# 				keysym:				evt::Keysym,						# Keysym  of the depressed key.
# 				ascii:				String,							# Ascii  for the depressed key.
# 				point:				g2d::Point,
# 				site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				gadget_to_guiboss:		gt::Gadget_To_Guiboss,
# 				widget_to_packedspace:		w2p::Widget_To_Packedspace,
# 				theme:				pt::Packed_Theme
# 			      }
# 			    = 
# 			    {
# 				got_key_press_event := TRUE;
# nb {. sprintf "key_press_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			fun key_release_fn
# 			      {
#				id:				iul::Id,						# Unique id.
#			        keycode:			evt::Keycode,						# Keycode of the released key.
# 				keysym:				evt::Keysym,						# Keysym  of the released key.
# 				ascii:				String,							# Ascii  for the released key.
# 				point:				g2d::Point,
# 				site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				gadget_to_guiboss:		gt::Gadget_To_Guiboss,
# 				widget_to_packedspace:		w2p::Widget_To_Packedspace,
# 				theme:				pt::Packed_Theme
# 			      }
# 			    = 
# 			    {
# 				got_key_release_event := TRUE;
# nb {. sprintf "key_release_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			packed_widget_options1
# 			  =
# 			  [
# 			    wim::START_OF_FRAME_FN	start_of_frame_fn1,
# 			    wim::BUTTON_PRESS_FN	button_press_fn,
# 			    wim::BUTTON_RELEASE_FN	button_release_fn,
# 			    wim::KEY_PRESS_FN		key_press_fn,
# 			    wim::KEY_RELEASE_FN		key_release_fn
# 			  ];
# 
# 			packed_widget_options2
# 			  =
# 			  [
# 			    wim::START_OF_FRAME_FN	start_of_frame_fn2,
# 			    wim::BUTTON_PRESS_FN	button_press_fn,
# 			    wim::BUTTON_RELEASE_FN	button_release_fn,
# 			    wim::KEY_PRESS_FN		key_press_fn,
# 			    wim::KEY_RELEASE_FN		key_release_fn
# 			  ];
# 
# 		    herein
# 			make_packed_widget_fn1 =  wim::make_packed_widget_start_fn  packed_widget_options1;
# 			make_packed_widget_fn2 =  wim::make_packed_widget_start_fn  packed_widget_options2;
# 			    
# 		    end;


		    # We're constructing a gui_plan with three rows of four buttons each.
		    #
		    # Each button responds to a click by changing its appearance.
		    #
		    # Also, the middle row of buttons is in a scrollable viewport;
		    # dragging on any button will scroll the middle row around in
		    # its viewport.
		    #
		    # We also note the site (size and location) of each button widget;
		    # we need this information (only) to synthesize fake test clicks
		    # on the buttons via
		    #     guiboss_to_topwindow.send_fake_mousebutton_release_event()

		    site1a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   first  button, site notification maildrop.
		    site2a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   second button, site notification maildrop.
		    site3a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   third  button, site notification maildrop.
		    site4a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   fourth button, site notification maildrop.

		    fun site_watcher1a (site: g2d::Box) =  put_in_maildrop (site1a', site);			# Row one,   first  button, site notification callback.
		    fun site_watcher2a (site: g2d::Box) =  put_in_maildrop (site2a', site);			# Row one,   second button, site notification callback.
		    fun site_watcher3a (site: g2d::Box) =  put_in_maildrop (site3a', site);			# Row one,   third  button, site notification callback.
		    fun site_watcher4a (site: g2d::Box) =  put_in_maildrop (site4a', site);			# Row one,   fourth button, site notification callback.


		    site1b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   first  button, site notification maildrop.
		    site2b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   second button, site notification maildrop.
		    site3b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   third  button, site notification maildrop.
		    site4b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   fourth button, site notification maildrop.
														                                                     
		    fun site_watcher1b (site: g2d::Box) =  put_in_maildrop (site1b', site);			# Row two,   first  button, site notification callback.
		    fun site_watcher2b (site: g2d::Box) =  put_in_maildrop (site2b', site);			# Row two,   second button, site notification callback.
		    fun site_watcher3b (site: g2d::Box) =  put_in_maildrop (site3b', site);			# Row two,   third  button, site notification callback.
		    fun site_watcher4b (site: g2d::Box) =  put_in_maildrop (site4b', site);			# Row two,   fourth button, site notification callback.


		    site1c' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row three, first  button, site notification maildrop.
		    site2c' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row three, second button, site notification maildrop.
		    site3c' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row three, third  button, site notification maildrop.
		    site4c' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row three, fourth button, site notification maildrop.
														                                                     
		    fun site_watcher1c (site: g2d::Box) =  put_in_maildrop (site1c', site);			# Row three, first  button, site notification callback.
		    fun site_watcher2c (site: g2d::Box) =  put_in_maildrop (site2c', site);			# Row three, second button, site notification callback.
		    fun site_watcher3c (site: g2d::Box) =  put_in_maildrop (site3c', site);			# Row three, third  button, site notification callback.
		    fun site_watcher4c (site: g2d::Box) =  put_in_maildrop (site4c', site);			# Row three, fourth button, site notification callback.



		    # As above, but for popup_plan:

		    sitep1a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   first  button, site notification maildrop.
#		    sitep2a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   second button, site notification maildrop.
#		    sitep3a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   third  button, site notification maildrop.
#		    sitep4a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   fourth button, site notification maildrop.

		    fun site_watcherp1a (site: g2d::Box) =  put_in_maildrop (sitep1a', site);			# Row one,   first  button, site notification callback.
#		    fun site_watcherp2a (site: g2d::Box) =  put_in_maildrop (sitep2a', site);			# Row one,   second button, site notification callback.
#		    fun site_watcherp3a (site: g2d::Box) =  put_in_maildrop (sitep3a', site);			# Row one,   third  button, site notification callback.
#		    fun site_watcherp4a (site: g2d::Box) =  put_in_maildrop (sitep4a', site);			# Row one,   fourth button, site notification callback.


		    sitep1b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   first  button, site notification maildrop.
#		    sitep2b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   second button, site notification maildrop.
#		    sitep3b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   third  button, site notification maildrop.
#		    sitep4b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   fourth button, site notification maildrop.
														                                                     
		    fun site_watcherp1b (site: g2d::Box) =  put_in_maildrop (sitep1b', site);			# Row two,   first  button, site notification callback.
#		    fun site_watcherp2b (site: g2d::Box) =  put_in_maildrop (sitep2b', site);			# Row two,   second button, site notification callback.
#		    fun site_watcherp3b (site: g2d::Box) =  put_in_maildrop (sitep3b', site);			# Row two,   third  button, site notification callback.
#		    fun site_watcherp4b (site: g2d::Box) =  put_in_maildrop (sitep4b', site);			# Row two,   fourth button, site notification callback.


		    sitep1c' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row three, first  button, site notification maildrop.
#		    sitep2c' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row three, second button, site notification maildrop.
#		    sitep3c' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row three, third  button, site notification maildrop.
#		    sitep4c' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row three, fourth button, site notification maildrop.
														                                                     
		    fun site_watcherp1c (site: g2d::Box) =  put_in_maildrop (sitep1c', site);			# Row three, first  button, site notification callback.
#		    fun site_watcherp2c (site: g2d::Box) =  put_in_maildrop (sitep2c', site);			# Row three, second button, site notification callback.
#		    fun site_watcherp3c (site: g2d::Box) =  put_in_maildrop (sitep3c', site);			# Row three, third  button, site notification callback.
#		    fun site_watcherp4c (site: g2d::Box) =  put_in_maildrop (sitep4c', site);			# Row three, fourth button, site notification callback.


		    Make_Popup
			=
			( g2d::Box,										# Requested site for popup.
			  gt::Gui_Plan										# GUI to run in popup.
			)
			  -> ( g2d::Box,									# Actual site for popup.
			       gt::Client_To_Guiwindow								# Port allowing popup to be closed down etc.
			     );
		    #
		    popup_maker4a' = make_empty_maildrop(): Maildrop( Make_Popup );				# 
		    #
		    fun popup_watcher4a (make_popup: Make_Popup)
			=
			put_in_maildrop (popup_maker4a', make_popup);

		    make_popup4a = REF (NULL: Null_Or(Make_Popup));


		    viewport_scroller = REF (NULL: Null_Or(gt::Viewport_Scroller));				# This global tracks the viewport scroller which will be handed to use by guiboss-imp at GUI startup -- see SCROLLABLE_VIEW below in gui_plan.

		    autoscroll_distance =     { row => 10, col => 10 };						# Not currently in use. Support for having the viewport scroll around automatically without user intervention.
		    scroll_state        = REF { row =>  0, col =>  0 };						# Not currently in use. This global tracks where the middle roll is current scrolled to. We only need this when doing autoscrolling in conjunction with autoscroll_distance above.
  
		    fun mouse_drag_fn										# This mouse-drag callback fn is used by all twelve buttons.
			  {	
			    id:				iul::Id,						# Unique id.
			    event_point:		g2d::Point,
			    start_point:		g2d::Point,
			    last_point:			g2d::Point,
			    site:			g2d::Box,						# Widget's assigned area in window coordinates.
			    phase:			gt::Drag_Phase,	
			    modifier_keys_state:	evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			    mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			    gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			    widget_to_packedspace:	w2p::Widget_To_Packedspace,
			    theme:			pt::Packed_Theme
			  }
			=
{
foo = case phase  gt::OPEN => "OPEN";
		  gt::DRAG => "DRAG";
		  gt::DONE => "DONE";
      esac;	
nb {. sprintf "mouse_drag_fn/AAA called! %s -- widget-unit-test.pkg" foo; };
			if (phase == gt::DRAG)									# Ignore the OPEN and DONE events because OPEN won't have a good last_point and
			    #											# DONE's event_point may be dubious, e.g. if drag ended outside of drag widget.
			    motion = event_point - last_point;
			    #
			    scroll_state := *scroll_state + motion;

nb {. sprintf "mouse_drag_fn/DRAG called! event_point => { %d,%d } last_point => { %d,%d} motion => { %d,%d }  -- widget-unit-test.pkg" event_point.row event_point.col last_point.row last_point.col motion.row motion.col; };
			    case *viewport_scroller
				#
				NULL  =>    ();
				THE s =>    s.set_viewport_origin *scroll_state;
			    esac;
			fi;
};

		    popup_plan
		      =
		      ( packedspace_options,
			#
			gt::COL
			  [
			    ( []: List(plh::Packedspace_Layout_Hint),
			      #	
			      gt::ROW [
				    arrowbutton::has [ ab::SITE_WATCHER site_watcherp1a, ab::DOWN , ab::MOUSE_DRAG_FN mouse_drag_fn ]
#				    arrowbutton::has [ ab::SITE_WATCHER site_watcherp1a, ab::LEFT , ab::MOUSE_DRAG_FN mouse_drag_fn ]
#				    arrowbutton::has [ ab::SITE_WATCHER site_watcherp2a, ab::UP   , ab::MOUSE_DRAG_FN mouse_drag_fn ],
#				    arrowbutton::has [ ab::SITE_WATCHER site_watcherp3a, ab::DOWN , ab::MOUSE_DRAG_FN mouse_drag_fn ],
#				    arrowbutton::has [ ab::SITE_WATCHER site_watcherp4a, ab::RIGHT, ab::MOUSE_DRAG_FN mouse_drag_fn ]
				  ]
			    )

# 			    ( []: List(plh::Packedspace_Layout_Hint),
# 			      #		
# 		      gt::SCROLLABLE_VIEW
# 				( (\\ scroller =  viewport_scroller := scroller):	gt::Viewport_Scroller_Callback,
# #				  { wide => 1200, high => 300 },										# This setting makes middle row exactly fill viewport.
# 				  { wide => 1150, high => 280 },										# This setting makes middle row slightly to small for viewport -- useful for testing the logic which fills the cracks with black at startup.
# 				  gt::ROW [
# 					arrowbutton::has [ ab::SITE_WATCHER site_watcherp1b, ab::LEFT , ab::MOUSE_DRAG_FN mouse_drag_fn ]
# #					arrowbutton::has [ ab::SITE_WATCHER site_watcherp2b, ab::UP   , ab::MOUSE_DRAG_FN mouse_drag_fn ],
# #					arrowbutton::has [ ab::SITE_WATCHER site_watcherp3b, ab::DOWN , ab::MOUSE_DRAG_FN mouse_drag_fn ],
# #					arrowbutton::has [ ab::SITE_WATCHER site_watcherp4b, ab::RIGHT, ab::MOUSE_DRAG_FN mouse_drag_fn ]
# 				      ]
# 				)
# 			    ),
# 
# 			    ( []: List(plh::Packedspace_Layout_Hint),
# 			      #	
# 			      gt::ROW [
# 				    arrowbutton::has [ ab::SITE_WATCHER site_watcherp1c, ab::LEFT , ab::MOUSE_DRAG_FN mouse_drag_fn ]
# #				    arrowbutton::has [ ab::SITE_WATCHER site_watcherp2c, ab::UP   , ab::MOUSE_DRAG_FN mouse_drag_fn ],
# #				    arrowbutton::has [ ab::SITE_WATCHER site_watcherp3c, ab::DOWN , ab::MOUSE_DRAG_FN mouse_drag_fn ],
# #				    arrowbutton::has [ ab::SITE_WATCHER site_watcherp4c, ab::RIGHT, ab::MOUSE_DRAG_FN mouse_drag_fn ]
# 				  ]
# 			    )

			  ]
		      );

		    fun mouse_drag_and_popup_fn									# This mouse-drag callback fn is used by only row-1, button-4
			  {	
			    id:				iul::Id,						# Unique id.
			    event_point:		g2d::Point,
			    start_point:		g2d::Point,
			    last_point:			g2d::Point,
			    site:			g2d::Box,						# Widget's assigned area in window coordinates.
			    phase:			gt::Drag_Phase,	
			    modifier_keys_state:	evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			    mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			    gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			    widget_to_packedspace:	w2p::Widget_To_Packedspace,
			    theme:			pt::Packed_Theme
			  }
			=
			case phase
			    #
			    gt::DONE => ();									# Ignore the DONE event.
			    gt::OPEN
				=>
				case *make_popup4a
				    #
				    NULL => {
nb {. "mouse_drag_and_popup_fn: make_popup4a is NOT set!"; };
					    };
				    THE make_popup
					=>  {
nb {. "mouse_drag_and_popup_fn: make_popup4a IS set!"; };
						requested_site = { row => 200, col => 200, wide => 1200, high => 900 };
						#
						if TRUE
						    #
						    (make_popup (requested_site, popup_plan))
							->
							(actual_site, client_to_guiwindow);


#	Client_To_Guiwindow
#	  =
#	  { id:			Id,											# Unique id to facilitate storing guiboss instances in indexed datastructures like red-black trees.
#	    pause_gui:		Void -> Paused_Gui,
#	    kill_gui:		Void -> Void
#	  };

						fi;
					    };
				esac;

			    gt::DRAG										# Ignore the OPEN and DONE events because OPEN won't have a good last_point and
				=>
				{
				    #											# DONE's event_point may be dubious, e.g. if drag ended outside of drag widget.
				    motion = event_point - last_point;
				    #
				    scroll_state := *scroll_state + motion;

nb {. sprintf "mouse_drag_fn called! event_point => { %d,%d } last_point => { %d,%d} motion => { %d,%d }  -- widget-unit-test.pkg" event_point.row event_point.col last_point.row last_point.col motion.row motion.col; };
				    case *viewport_scroller
					#
					NULL  =>    ();
					THE s =>    s.set_viewport_origin *scroll_state;
				    esac;
				};
			esac;

		    gui_plan
		      =
		      ( packedspace_options,
			#
			gt::COL
			  [
			    ( []: List(plh::Packedspace_Layout_Hint),
			      #	
			      gt::ROW [
				    arrowbutton::has [ ab::SITE_WATCHER site_watcher1a, ab::LEFT , ab::MOUSE_DRAG_FN mouse_drag_fn ],
				    arrowbutton::has [ ab::SITE_WATCHER site_watcher2a, ab::UP   , ab::MOUSE_DRAG_FN mouse_drag_fn ],
				    arrowbutton::has [ ab::SITE_WATCHER site_watcher3a, ab::DOWN , ab::MOUSE_DRAG_FN mouse_drag_fn ],
				    arrowbutton::has [ ab::SITE_WATCHER site_watcher4a, ab::RIGHT, ab::MOUSE_DRAG_FN mouse_drag_and_popup_fn, ab::POPUP_WATCHER popup_watcher4a ]
				  ]
			    ),

			    ( []: List(plh::Packedspace_Layout_Hint),
			      #	
			      gt::SCROLLABLE_VIEW
				( (\\ scroller =  viewport_scroller := scroller):	gt::Viewport_Scroller_Callback,
#				  { wide => 1600, high => 400 },										# This setting makes middle row exactly fill viewport.
				  { wide => 1580, high => 380 },										# This setting makes middle row slightly to small for viewport -- useful for testing the logic which fills the cracks with black at startup.
				  gt::ROW [
					arrowbutton::has [ ab::SITE_WATCHER site_watcher1b, ab::LEFT , ab::MOUSE_DRAG_FN mouse_drag_fn ],
					arrowbutton::has [ ab::SITE_WATCHER site_watcher2b, ab::UP   , ab::MOUSE_DRAG_FN mouse_drag_fn ],
					arrowbutton::has [ ab::SITE_WATCHER site_watcher3b, ab::DOWN , ab::MOUSE_DRAG_FN mouse_drag_fn ],
					arrowbutton::has [ ab::SITE_WATCHER site_watcher4b, ab::RIGHT, ab::MOUSE_DRAG_FN mouse_drag_fn ]
				      ]
				)
			    ),

			    ( []: List(plh::Packedspace_Layout_Hint),
			      #	
			      gt::ROW [
				    arrowbutton::has [ ab::SITE_WATCHER site_watcher1c, ab::LEFT , ab::MOUSE_DRAG_FN mouse_drag_fn ],
				    arrowbutton::has [ ab::SITE_WATCHER site_watcher2c, ab::UP   , ab::MOUSE_DRAG_FN mouse_drag_fn ],
				    arrowbutton::has [ ab::SITE_WATCHER site_watcher3c, ab::DOWN , ab::MOUSE_DRAG_FN mouse_drag_fn ],
				    arrowbutton::has [ ab::SITE_WATCHER site_watcher4c, ab::RIGHT, ab::MOUSE_DRAG_FN mouse_drag_fn ]
				  ]
			    )

			  ]
		      );

nb {. sprintf "widget-unit-test pprinting gui_plan:"; };
		    gt::pprint_gui_plan  gui_plan;

		    topwindow_hints		# 
			=			# 
			[
			  gws::BACKGROUND_PIXEL	(r8::rgb8_from_ints (128+32, 16, 32)),		# Slightly desaturated green. (NOW RED.)
			  gws::BORDER_PIXEL	(r8::rgb8_from_ints (0,       0,  0)),		# Black.
			  #
			  gws::SITE		( { upperleft		=>   { col =>     0, row  =>    0 },
						    size		=>   { wide => 1600, high => 1200 },
						    border_thickness	=>  1
						  }
						  : g2d::Window_Site
						)
			];

nb {. sprintf "widget-unit-test calling client_to_guiboss.make_topwindow..."; };
		    (client_to_guiboss.make_topwindow  topwindow_hints)
			->
			guiboss_to_topwindow;

		    (guiboss_to_topwindow.exercise_appwindow ())
			->
		        wait_until_exercise_is_complete;
			

		    wait_until_exercise_is_complete ();



# log::note  {. "widget-unit-test setting log::debugging to TRUE..."; };
# log::debugging := TRUE;
# interprocess_signals::set_log_if_on TRUE;
# log::note  {. "widget-unit-test set     log::debugging to TRUE."; };
nb {. sprintf "widget-unit-test calling client_to_guiboss.start_gui..."; };
if (*log::debugging) log::note  {. "widget-unit-test calling client_to_guiboss.start_gui..."; }; fi;
		    (client_to_guiboss.start_gui  (guiboss_to_topwindow, gui_plan))
			->
			block_until_gui_startup_is_complete;

nb {. sprintf "widget-unit-test calling block_until_gui_startup_is_complete() ..."; };
		    (block_until_gui_startup_is_complete())
			->
			client_to_guiwindow;

# nb {. sprintf "widget-unit-test doing guiboss_to_topwindow.send_fake_mousebutton_press_event() ..."; };

		    #
#		    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, { row => 13, col => 17 });
#		    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, { row => 14, col => 18 });
		    #
#		    guiboss_to_topwindow.send_fake_key_press_event   (evt::KEYCODE 1, { row => 23, col => 27 });
#		    guiboss_to_topwindow.send_fake_key_release_event (evt::KEYCODE 1, { row => 24, col => 28 });

		    # Now we establish globals to contain the
		    # sites of our twelve pushbuttons:

		    site1a = REF (NULL: Null_Or(g2d::Box));									# Row one,   button one.
#		    site2a = REF (NULL: Null_Or(g2d::Box));									# Row one,   button two.
#		    site3a = REF (NULL: Null_Or(g2d::Box));									# Row one,   button three.
		    site4a = REF (NULL: Null_Or(g2d::Box));									# Row one,   button four. 

		    site1b = REF (NULL: Null_Or(g2d::Box));									# Row two,   button one.  
#		    site2b = REF (NULL: Null_Or(g2d::Box));									# Row two,   button two.  
#		    site3b = REF (NULL: Null_Or(g2d::Box));									# Row two,   button three.
#		    site4b = REF (NULL: Null_Or(g2d::Box));									# Row two,   button four. 

		    site1c = REF (NULL: Null_Or(g2d::Box));									# Row three, button one.  
#		    site2c = REF (NULL: Null_Or(g2d::Box));									# Row three, button two.  
#		    site3c = REF (NULL: Null_Or(g2d::Box));									# Row three, button three.
#		    site4c = REF (NULL: Null_Or(g2d::Box));									# Row three, button four. 


		    # Fill in the above globals via blocking reads of the maildrops
		    # set by the callbacks we handed to guiboss-imp via gui_plan.
		    # We use timeouts (only) to recover gracefully if things are
		    # somehow so broken that guiboss-imp never calls our callbacks.
		    # The order shouldn't matter; here we go left-to-right top-to-bottom:

		    do_one_mailop [ get_from_maildrop' site1a'	==> {. site1a := THE #site;		assert(TRUE);  },	# Row one,   button one.
				    timeout_in' 1.0		==> {. printf "no site1a in 1 sec!\n";	assert(FALSE); }
				  ];
#		    do_one_mailop [ get_from_maildrop' site2a'	==> {. site2a := THE #site;		assert(TRUE);  },	# Row one,   button two.
#				    timeout_in' 1.0		==> {. printf "no site2a in 1 sec!\n";	assert(FALSE); }
#				  ];
#		    do_one_mailop [ get_from_maildrop' site3a'	==> {. site3a := THE #site;		assert(TRUE);  },	# Row one,   button three.
#				    timeout_in' 1.0		==> {. printf "no site3a in 1 sec!\n";	assert(FALSE); }
#				  ];
		    do_one_mailop [ get_from_maildrop' site4a'	==> {. site4a := THE #site;		assert(TRUE);  },	# Row one,   button four.
				    timeout_in' 1.0		==> {. printf "no site4a in 1 sec!\n";	assert(FALSE); }
				  ];

		    do_one_mailop [ get_from_maildrop' site1b'	==> {. site1b := THE #site;		assert(TRUE);  },	# Row two,   button one.
				    timeout_in' 1.0		==> {. printf "no site1b in 1 sec!\n";	assert(FALSE); }
				  ];
#		    do_one_mailop [ get_from_maildrop' site2b'	==> {. site2b := THE #site;		assert(TRUE);  },	# Row two,   button two.
#				    timeout_in' 1.0		==> {. printf "no site2b in 1 sec!\n";	assert(FALSE); }
#				  ];
#		    do_one_mailop [ get_from_maildrop' site3b'	==> {. site3b := THE #site;		assert(TRUE);  },	# Row two,   button three.
#				    timeout_in' 1.0		==> {. printf "no site3b in 1 sec!\n";	assert(FALSE); }
#				  ];
#		    do_one_mailop [ get_from_maildrop' site4b'	==> {. site4b := THE #site;		assert(TRUE);  },	# Row two,   button four.
#				    timeout_in' 1.0		==> {. printf "no site4b in 1 sec!\n";	assert(FALSE); }
#				  ];

		    do_one_mailop [ get_from_maildrop' site1c'	==> {. site1c := THE #site;		assert(TRUE);  },	# Row three, button one.
				    timeout_in' 1.0		==> {. printf "no site1c in 1 sec!\n";	assert(FALSE); }
				  ];
#		    do_one_mailop [ get_from_maildrop' site2c'	==> {. site2c := THE #site;		assert(TRUE);  },	# Row three, button two.
#				    timeout_in' 1.0		==> {. printf "no site2c in 1 sec!\n";	assert(FALSE); }
#				  ];
#		    do_one_mailop [ get_from_maildrop' site3c'	==> {. site3c := THE #site;		assert(TRUE);  },	# Row three, button three.
#				    timeout_in' 1.0		==> {. printf "no site3c in 1 sec!\n";	assert(FALSE); }
#				  ];
#		    do_one_mailop [ get_from_maildrop' site4c'	==> {. site4c := THE #site;		assert(TRUE);  },	# Row three, button four.
#				    timeout_in' 1.0		==> {. printf "no site4c in 1 sec!\n";	assert(FALSE); }
#				  ];

		    do_one_mailop [ get_from_maildrop' popup_maker4a' ==> {. make_popup4a := THE #make_popup; 		assert(TRUE);  },
				    timeout_in' 1.0		      ==> {. printf "no make_popup4a in 1 sec!\n";	assert(FALSE); }
				  ];



# nb {. sprintf "widget-unit-test calling sleep_for 3.0 ..."; };
if (*log::debugging) log::note  {. "widget-unit-test calling sleep_for 3.0 ..."; }; fi;
		    sleep_for 3.0;												# Just to give human observer time to observe.

 		    for (i = 1; i <= 10; ++i) {
 			#
if (*log::debugging) log::note  {. sprintf "widget-unit-test lup %d ..." i; }; fi;

#			scroll_state := *scroll_state + autoscroll_distance;
#
#			case *viewport_scroller
#			    #
#			    NULL  =>    ();
#			    THE s =>    s.set_viewport_origin *scroll_state;
#			esac;

			case *site1a
			    #
			    THE site => {
# printf "site1 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
					    site_midpoint = g2d::box::midpoint site;
if (*log::debugging) log::note  {. "widget-unit-test sending site1 downclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
if (*log::debugging) log::note  {. "widget-unit-test sending site1   upclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
					    window_rectangle_to_read = g2d::box::make (site_midpoint, { wide => 5, high => 5 });
					    rw_matrix_rgb8 = guiboss_to_topwindow.get_pixel_rectangle window_rectangle_to_read;
					    row = 1;
					    col = 1;
					    rgb8 = rw_matrix_rgb8[row,col];
					    rgb  =  r8::rgb8_to_rgb rgb8;
# nb {. sprintf "widget-unit-test rw_matrix_rgb8[%d,%d] = { red => %g, green => %g, blue => %g }\n" row col rgb.red rgb.green rgb.blue; };
					};
			    NULL	 => ();
			esac;
# 			case *site2a
# 			    #
# 			    THE site => {
# # printf "site2 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site2 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site2   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site3a
# 			    #
# 			    THE site => {
# # printf "site3 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site3 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site3   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
			case *site4a
			    #
			    THE site => {
# printf "site4 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
					    site_midpoint = g2d::box::midpoint site;
if (*log::debugging) log::note  {. "widget-unit-test sending site4 downclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
if (*log::debugging) log::note  {. "widget-unit-test sending site4   upclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
					};
			    NULL	 => ();
			esac;


			case *site1b
			    #
			    THE site => {
# printf "site1 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# XXX BUGGO FIXME DO NOT USE 'i' HERE!!!
					    site_midpoint = g2d::box::midpoint site + { row => 400 + i*10, col => i*10 };				# The added 400 is to transform us from the scrollable-view coordinate system into the toplevel window coordinate system.
if (*log::debugging) log::note  {. "widget-unit-test sending site1 downclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
if (*log::debugging) log::note  {. "widget-unit-test sending site1   upclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
					    window_rectangle_to_read = g2d::box::make (site_midpoint, { wide => 5, high => 5 });
					    rw_matrix_rgb8 = guiboss_to_topwindow.get_pixel_rectangle window_rectangle_to_read;
					    row = 1;
					    col = 1;
					    rgb8 = rw_matrix_rgb8[row,col];
					    rgb  =  r8::rgb8_to_rgb rgb8;
# nb {. sprintf "widget-unit-test rw_matrix_rgb8[%d,%d] = { red => %g, green => %g, blue => %g }\n" row col rgb.red rgb.green rgb.blue; };
					};
			    NULL	 => ();
			esac;
# 			case *site2b
# 			    #
# 			    THE site => {
# # printf "site2 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# # XXX BUGGO FIXME DO NOT USE 'i' HERE!!!
# 					    site_midpoint = g2d::box::midpoint site + { row => 400 + i*10, col => i*10 };				# The added 400 is to transform us from the scrollable-view coordinate system into the toplevel window coordinate system.
# if (*log::debugging) log::note  {. "widget-unit-test sending site2 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site2   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site3b
# 			    #
# 			    THE site => {
# # printf "site3 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# # XXX BUGGO FIXME DO NOT USE 'i' HERE!!!
# 					    site_midpoint = g2d::box::midpoint site + { row => 400 + i*10, col => i*10 };				# The added 400 is to transform us from the scrollable-view coordinate system into the toplevel window coordinate system.
# if (*log::debugging) log::note  {. "widget-unit-test sending site3 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site3   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site4b
# 			    #
# 			    THE site => {
# # printf "site4 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# # XXX BUGGO FIXME DO NOT USE 'i' HERE!!!
# 					    site_midpoint = g2d::box::midpoint site + { row => 400 + i*10, col => i*10 };				# The added 400 is to transform us from the scrollable-view coordinate system into the toplevel window coordinate system.
# if (*log::debugging) log::note  {. "widget-unit-test sending site4 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site4   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;


			case *site1c
			    #
			    THE site => {
# printf "site1 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
					    site_midpoint = g2d::box::midpoint site;
if (*log::debugging) log::note  {. "widget-unit-test sending site1 downclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
if (*log::debugging) log::note  {. "widget-unit-test sending site1   upclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
					    window_rectangle_to_read = g2d::box::make (site_midpoint, { wide => 5, high => 5 });
					    rw_matrix_rgb8 = guiboss_to_topwindow.get_pixel_rectangle window_rectangle_to_read;
					    row = 1;
					    col = 1;
					    rgb8 = rw_matrix_rgb8[row,col];
					    rgb  =  r8::rgb8_to_rgb rgb8;
# nb {. sprintf "widget-unit-test rw_matrix_rgb8[%d,%d] = { red => %g, green => %g, blue => %g }\n" row col rgb.red rgb.green rgb.blue; };
					};
			    NULL	 => ();
			esac;
# 			case *site2c
# 			    #
# 			    THE site => {
# # printf "site2 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site2 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site2   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site3c
# 			    #
# 			    THE site => {
# # printf "site3 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site3 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site3   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site4c
# 			    #
# 			    THE site => {
# # printf "site4 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site4 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site4   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;



# nb {. sprintf "widget-unit-test calling sleep_for 5.0 ..."; };
if (*log::debugging) log::note  {. "widget-unit-test calling sleep_for 2.0 ..."; }; fi;
			sleep_for 2.0;
		    };
# if (*log::debugging) log::note  {. "widget-unit-test setting log::debugging back to FALSE."; }; fi;
# log::debugging := FALSE;
# interprocess_signals::set_log_if_on FALSE;

#		    assert *got_button_press_event;
#		    assert *got_button_release_event;

#		    assert *got_key_press_event;
#		    assert *got_key_release_event;

nb {. sprintf "widget-unit-test ending gui run..."; };
		    paused_gui' = client_to_guiwindow.pause_gui ();

nb {. sprintf "widget-unit-test pprinting paused_gui':"; };
		    gt::pprint_paused_gui  paused_gui';
		};	

		sprite_to_bouncespace									# Dummy port back to bouncespace-imp from sprite-imp.
		  =
		  { id           =>  id_zero,
		    look_changed =>  (\\ _ = ())
		  };

		object_to_canvasspace									# Dummy port back to canvasspace-imp from object-imp.
		  =
		  { id           =>  id_zero,
		    look_changed =>  (\\ _ = ())
		  };



# Following is broken at the moment by the restructuring
# of bounce and canvas code on the model of packed code.
# In particular I think balls wound up with boolean values
# instead of position+velocity values.
#
# For the moment my focus is elsewhere so I'm letting this slide.
# XXX SUCKO FIXME.
# 			-- 2014-07-05 CrT

#		ball_state_endstate_oneshot = NULL;
#		ball_look_endstate_oneshot  = NULL;
#		ball_look_arg         = [];
#		ball_arg =  ( { position => { x => 0.0, y => 0.0, z => 0.0 },
#				velocity => { x => 0.0, y => 0.0, z => 0.0 }
#			      }, 	
#			      []
#			    );
#		(dbl::make_egg ( /* guiboss_to_windowsystem, */ ball_arg, ball_look_arg, sprite_to_bouncespace, ball_state_endstate_oneshot, ball_look_endstate_oneshot))
#		    ->
#		    ball_look_egg;
#
#
#
#		node_state_endstate_oneshot = NULL;
#		node_look_endstate_oneshot  = NULL;
#		node_look_arg         = [];
#		node_arg =  ( { text => "foo" },
#			      []
#			    );
#		(dnl::make_egg ( /* guiboss_to_windowsystem, */ node_arg, node_look_arg, object_to_canvasspace, node_state_endstate_oneshot, node_look_endstate_oneshot))
#		    ->
#		    node_look_egg;


		fire_end_gun ();
		

		();
	    };

	fun run ()
	    =
	    {   # Remove any old version of the tracefile:
		#
		if (isfile tracefile)  
		    unlink tracefile;
		fi;


		printf "\nDoing %s:\n" name;   


		# Open tracelog file and
                # select tracing level:
		#
		{   include package   logger;				# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
		    #
		    set_logger_to  (fil::LOG_TO_FILE tracefile);
		    #
#		    enable fil::all_logging;			# Gross overkill.
#		    enable xtr::xkit_logging;			# Lesser overkill.
#		    enable xtr::io_logging;			# Saner yet.	
		};

		assert  (tsr::thread_scheduler_is_running ());

		exercise_convex_hull	    ();
		exercise_point_in_polygon   ();
		exercise_window_stuff	    ();

		assert TRUE;

		summarize_unit_tests  name;
	    };
    };

end;
