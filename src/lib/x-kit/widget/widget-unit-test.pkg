## widget-unit-test.pkg
#
# For the big picture see the imp dataflow diagrams in
#
#     src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
#
# NB: We must compile this locally via
#         xclient-internals.sublib
#     instead of globally via
#         src/lib/test/unit-tests.lib
#     like most unit tests, in order to have
#     access to required library internals.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


# Run by:
#     src/lib/test/all-unit-tests.pkg

stipulate
    include package   unit_test;				# unit_test				is from   src/lib/src/unit-test.pkg
    include package   makelib::scripting_globals;
    include package   threadkit;				# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ap  =  client_to_atom;				# client_to_atom			is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
    package au  =  authentication;				# authentication			is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package awx =  windowsystem_imp_for_x;			# windowsystem_imp_for_x		is from   src/lib/x-kit/widget/xkit/app/windowsystem-imp-for-x.pkg
    package cpm =  cs_pixmap;					# cs_pixmap				is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
    package cpt =  cs_pixmat;					# cs_pixmat				is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
    #
    package gd  =  gui_displaylist;				# gui_displaylist			is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    #
    package dbx =  sprite_theme_imp;				# sprite_theme_imp			is from   src/lib/x-kit/widget/xkit/theme/sprite/default/default-sprite-theme-for-x.pkg
    package dcx =  object_theme_imp;				# object_theme_imp			is from   src/lib/x-kit/widget/xkit/theme/object/default/default-object-theme-for-x.pkg
    package dtx =  widget_theme_imp;				# widget_theme_imp			is from   src/lib/x-kit/widget/xkit/theme/widget/default/default-widget-theme-for-x.pkg
    #
    package dy  =  display;					# display				is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package w2x =  windowsystem_to_xserver;			# windowsystem_to_xserver		is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xserver.pkg
    package fil =  file__premicrothread;			# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
    package fti =  font_index;					# font_index				is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
    package gws =  guiboss_to_windowsystem;			# guiboss_to_windowsystem		is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg
    package gq  =  guiboss_imp;					# guiboss_imp				is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
#   package c2g =  client_to_guiboss;				# client_to_guiboss			is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap		is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
    package mtx =  rw_matrix;					# rw_matrix				is from   src/lib/std/src/rw-matrix.pkg
    package r8  =  rgb8;					# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package rgb =  rgb;						# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package rop =  ro_pixmap;					# ro_pixmap				is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
    package rw  =  root_window;					# root_window				is from   src/lib/x-kit/widget/lib/root-window.pkg
    package rwv =  rw_vector;					# rw_vector				is from   src/lib/std/src/rw-vector.pkg
    package sep =  client_to_selection;				# client_to_selection			is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
    package shp =  shade;					# shade					is from   src/lib/x-kit/widget/lib/shade.pkg
    package sj  =  socket_junk;					# socket_junk				is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer			is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
    package ti  =  template_imp;				# template_imp				is from   src/lib/x-kit/xclient/src/wire/template-imp.pkg
    package tem =  template;					# template				is from   src/lib/x-kit/xclient/src/wire/template.pkg
    package tr  =  logger;					# logger				is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
    package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
    package u1  =  one_byte_unt;				# one_byte_unt				is from   src/lib/std/one-byte-unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts		is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire				is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package wg  =  widget;					# widget				is from   src/lib/x-kit/widget/old/basic/widget.pkg
    package wi  =  window;					# window				is from   src/lib/x-kit/xclient/src/window/window.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink			is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package wpp =  client_to_window_watcher;			# client_to_window_watcher		is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
    package wy  =  widget_style;				# widget_style				is from   src/lib/x-kit/widget/lib/widget-style.pkg
    package xc  =  xclient;					# xclient				is from   src/lib/x-kit/xclient/xclient.pkg
    package g2d =  geometry2d;					# geometry2d				is from   src/lib/std/2d/geometry2d.pkg
    package xj  =  xsession_junk;				# xsession_junk				is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package xtr =  xlogger;					# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package blk =  blank;					# blank					is from   src/lib/x-kit/widget/leaf/blank.pkg
    package frm =  frame;					# frame					is from   src/lib/x-kit/widget/leaf/frame.pkg
    package ab  =  arrowbutton;					# arrowbutton				is from   src/lib/x-kit/widget/leaf/arrowbutton.pkg
    package bb  =  boxbutton;					# boxbutton				is from   src/lib/x-kit/widget/leaf/boxbutton.pkg
    package db  =  diamondbutton;				# diamondbutton				is from   src/lib/x-kit/widget/leaf/diamondbutton.pkg
    package rb  =  roundbutton;					# roundbutton				is from   src/lib/x-kit/widget/leaf/roundbutton.pkg

    package iul =  issue_unique_look_id;			# issue_unique_look_id			is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

#   package b2g =  guiboss_to_gadget;				# guiboss_to_gadget			is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg
#   package g2g =  gadget_to_guiboss;				# gadget_to_guiboss			is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
    package w2p =  widget_to_widgetspace;			# widget_to_widgetspace			is from   src/lib/x-kit/widget/space/widget/look-to-widget.pkg

#   package xet =  xevent_types;				# xevent_types				is from   src/lib/x-kit/xclient/src/wire/xevent-types.pkg
#   package e2s =  xevent_to_string;				# xevent_to_string			is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
#   package xt  =  xtypes;					# xtypes				is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    #
    # The above three are the X-specific versions of the
    # below two platform-independent packages.  X events
    # come to windowsystem-imp-for-x in xet:: encoding.  It	# For the big dataflow diagram see   src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
    # translates them to evt:: encoding and forward them to
    # guiboss_imp, which forwards them to appropriate imps.	# guiboss_imp				is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
    #
    package gt  =  guiboss_types;				# guiboss_types				is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
    package pt  =  widget_theme;				# widget_theme				is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

    package evt =  gui_event_types;				# gui_event_types			is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
#   package gts =  gui_event_to_string;				# gui_event_to_string			is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    #
    # This one translates from the X to Gui versions:
#   package x2g =  xevent_to_gui_event;				# xevent_to_gui_event			is from   src/lib/x-kit/widget/xkit/app/xevent-to-gui-event.pkg
#   package g2x =  gui_event_to_xevent;				# gui_event_to_xevent			is from   src/lib/x-kit/widget/xkit/app/gui-event-to-xevent.pkg

    package oim =  object_imp;					# object_imp				is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/object-imp.pkg
    package sim =  sprite_imp;					# sprite_imp				is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/sprite-imp.pkg
    package wim =  widget_imp;					# widget_imp				is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg

    tracefile   =  "widget-unit-test.trace.log";

#   id =  iui::issue_unique_id;

    nb =  log::note_on_stderr;					# log					is from   src/lib/std/src/log.pkg

# These are crude hacks for force these to compile: 
#
Dummy1 = wim::Widget;
Dummy2 = oim::Object;
Dummy3 = sim::Sprite;
dummy4 = ab::with;
dummy5 = frm::with;
dummy6 = blk::with;

herein

    package widget_unit_test {
	#
	name = "src/lib/x-kit/widget/widget-unit-test.pkg";

	trace =  xtr::log_if  xtr::io_logging 0;		# Conditionally write strings to tracing.log or whatever.


	fun exercise_convex_hull  ()				# Probably should be in a separate geometry2d-unit-text.pkg, but at the moment I'm too lazy to take time to establish one.
	    =
	    {
		points1 = [ { col => 100, row => 100 }, { col => 400, row => 100 }, { col => 400, row => 400 }, { col => 100, row => 400 } ];
		points2 = [ { col => 200, row => 200 }, { col => 300, row => 200 }, { col => 300, row => 300 }, { col => 200, row => 300 } ];
		points3 = points1 @ points2;
		#
		points1' = g2d::convex_hull points1;
		points2' = g2d::convex_hull points2;
		points4  = g2d::convex_hull points3;
		#
		assert (points1' == points1);
		assert (points2' == points2);
		assert (points4  == points1);
		#
		points1' = g2d::convex_hull (reverse points1);
		points2' = g2d::convex_hull (reverse points2);
		points4  = g2d::convex_hull (reverse points3);
		#
		assert (points1' == points1);
		assert (points2' == points2);
		assert (points4  == points1);
	    };

	fun exercise_point_in_polygon ()				# Probably should be in a separate geometry2d-unit-text.pkg, but at the moment I'm too lazy to take time to establish one.
	    =
	    {
		# Basic square, as above
		#
		points = [ { col => 100, row => 100 }, { col => 200, row => 100 }, { col => 200, row => 200 }, { col => 100, row => 200 } ];
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };  	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) ==  TRUE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);




		points = [ { col => 100, row => 200 }, { col => 200, row => 200 }, { col => 200, row => 100 }, { col => 100, row => 100 } ];	# Does vertex order matter?

		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };  	# Middles of the 9 squares of a tic-tac-toe pattern.  
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) ==  TRUE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);




		points = [ { col => 100, row => 100 }, { col => 100, row => 100 },		# Do duplicate vertices matter?
			   { col => 200, row => 100 }, { col => 200, row => 100 },
			   { col => 200, row => 200 }, { col => 200, row => 200 },
                           { col => 100, row => 200 }, { col => 100, row => 200 }
			 ];

		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };    	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) ==  TRUE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);



		# Diamond instead of square:
		# 
		points = [ { col => 100, row => 150 }, { col => 150, row => 200 }, { col => 200, row => 150 }, { col => 150, row => 100 } ];
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) ==  TRUE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);



		# Chevron shape concave down:
		# 
		points = [ { col => 100, row => 150 }, { col => 150, row => 200 }, { col => 200, row => 150 }, { col => 150, row => 190 } ];
		#
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);


		# Chevron shape concave up:
		# 
		points = [ { col => 100, row => 150 }, { col => 150, row => 110 }, { col => 200, row => 150 }, { col => 150, row => 100 } ];
		#
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);


		# Chevron shape concave left:
		# 
		points = [ { col => 190, row => 150 }, { col => 150, row => 200 }, { col => 200, row => 150 }, { col => 150, row => 100 } ];
		#
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);


		# Chevron shape concave right:
		# 
		points = [ { col => 100, row => 150 }, { col => 150, row => 200 }, { col => 110, row => 150 }, { col => 150, row => 100 } ];
		#
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);


	    };

	Make_Popup
	    =
	    ( g2d::Box,												# Requested site for popup.
	      gt::Gui_Plan											# GUI to run in popup.
	    )
	      -> ( g2d::Box,											# Actual site of popup.
		   gt::Client_To_Guiwindow									# Port allowing popup to be closed down etc.
		 );

	fun make_three_row_gui_plan
	      (
		scrollable_view_size:	    g2d::Size,


		popup_info:	Null_Or( Void ->  { requested_popup_site:		g2d::Box,		# For popup_plan this was:  { row => 200, col => 200, wide => 1200, high => 900 };
						    popup_plan:				gt::Gui_Plan,		# 
						    read__make_popupp4a__from_guiboss:	Void -> Void		# This may be a no-op, or it may read the make_popup used by popup_plan to create popup_plan2.
						  }
				       ),


		popup_info3:	Null_Or( Void ->  { requested_popup_site:		g2d::Box,		# 
						    popup_plan:				gt::Gui_Plan,		# 
						    read__make_popupp4a__from_guiboss:	Void -> Void		# This may be a no-op, or it may read the make_popup used by popup_plan to create popup_plan2.
						  }
				       )
	      )
	      :	{ gui_plan:		gt::Gui_Plan,
														# Here we return globals which wind up containing the window sites
														# assigned to our various widgets.  Normal application code never
														# needs to know this, but our test code needs this information in
														# order to synthesize fake mouseclicks etc on the buttons.
														#
		  viewport_scroller:	Ref( Null_Or( gt::Viewport_Scroller ) ),

		  scroll_state:		Ref( g2d::Point ),

		  widget_sites:   { site1a: Ref (Null_Or(g2d::Box)),						# Row one,   button one.
				    site2a: Ref (Null_Or(g2d::Box)),						# Row one,   button two.
				    site3a: Ref (Null_Or(g2d::Box)),						# Row one,   button three.
				    site4a: Ref (Null_Or(g2d::Box)),						# Row one,   button four. 
														#
				    site1b: Ref (Null_Or(g2d::Box)),						# Row two,   button one.  
				    site2b: Ref (Null_Or(g2d::Box)),						# Row two,   button two.  
				    site3b: Ref (Null_Or(g2d::Box)),						# Row two,   button three.
				    site4b: Ref (Null_Or(g2d::Box)),						# Row two,   button four. 
														#
				    site1c: Ref (Null_Or(g2d::Box)),						# Row three, button one.  
				    site2c: Ref (Null_Or(g2d::Box)),						# Row three, button two.  
				    site3c: Ref (Null_Or(g2d::Box)),						# Row three, button three.
				    site4c: Ref (Null_Or(g2d::Box))						# Row three, button four. 
				  },

		  read_back_sites_of_guiplan_widgets:	Void -> Void,						# Fills in values of widget_sites

		  read__make_popup1a__from_guiboss:	Void -> Void,
		  read__make_popup4a__from_guiboss:	Void -> Void
		}
	    =
	    {	stipulate
		    popup_maker1a'  = make_empty_maildrop(): Maildrop( Make_Popup );				# Used by gui_plan to pop up popup_plan
		    popup_maker4a'  = make_empty_maildrop(): Maildrop( Make_Popup );				# Used by gui_plan to pop up popup_plan
		herein
		    #
		    fun popup_watcher1a (make_popup: Make_Popup) = put_in_maildrop (popup_maker1a', make_popup);	# This gets passed to guiboss_imp via gui plan.
		    fun popup_watcher4a (make_popup: Make_Popup) = put_in_maildrop (popup_maker4a', make_popup);	# This gets passed to guiboss_imp via gui plan.


		    make_popup1a  = REF (NULL: Null_Or(Make_Popup));
		    make_popup4a  = REF (NULL: Null_Or(Make_Popup));


		    fun read__make_popup1a__from_guiboss ()
			=
			do_one_mailop [ get_from_maildrop' popup_maker1a' ==> {. make_popup1a := THE #make_popup; 	assert(TRUE);  },
					timeout_in' 1.0		          ==> {. printf "no make_popup1a in 1 sec!\n";	assert(FALSE); }
				      ];

		    fun read__make_popup4a__from_guiboss ()
			=
			do_one_mailop [ get_from_maildrop' popup_maker4a' ==> {. make_popup4a := THE #make_popup; 	assert(TRUE);  },
					timeout_in' 1.0		          ==> {. printf "no make_popup4a in 1 sec!\n";	assert(FALSE); }
				      ];
		end;		      

		viewport_scroller	= REF (NULL: Null_Or(gt::Viewport_Scroller));				# This global tracks the viewport scroller which will be handed to use by guiboss-imp at GUI startup -- see SCROLLABLE_VIEW below in gui_plan.

		scroll_state		= REF { row =>  0, col =>  0 };						# Not currently in use. This global tracks where the middle roll is current scrolled to. We only need this when doing autoscrolling in conjunction with autoscroll_distance above.

		stipulate
		    site1a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   first  button, site notification maildrop.
		    site2a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   second button, site notification maildrop.
		    site3a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   third  button, site notification maildrop.
		    site4a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   fourth button, site notification maildrop.
														#
		    site1b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   first  button, site notification maildrop.
		    site2b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   second button, site notification maildrop.
		    site3b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   third  button, site notification maildrop.
		    site4b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   fourth button, site notification maildrop.
														#														                                                     
		    site1c' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row three, first  button, site notification maildrop.
		    site2c' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row three, second button, site notification maildrop.
		    site3c' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row three, third  button, site notification maildrop.
		    site4c' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row three, fourth button, site notification maildrop.
		herein														                                                     
														# These globals hold the values read from the above
														# mailops by the later do_one_mailop() calls.
														# They hold the sites (window locations) assigned to
														# our twelve pushbuttons. (We need this information
														# to generate fake mouseclicks on them for test
														# purposes. A normal GUI app wouldn't do this.) 
														#
		    site1a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button one.
		    site2a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button two.
		    site3a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button three.
		    site4a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button four. 
														#
		    site1b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button one.  
		    site2b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button two.  
		    site3b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button three.
		    site4b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button four. 
														#
		    site1c = REF (NULL: Null_Or(g2d::Box));							# Row three, button one.  
		    site2c = REF (NULL: Null_Or(g2d::Box));							# Row three, button two.  
		    site3c = REF (NULL: Null_Or(g2d::Box));							# Row three, button three.
		    site4c = REF (NULL: Null_Or(g2d::Box));							# Row three, button four. 

														# These are the site-watcher callbacks we pass to the
														# guiboss layer to find out where our buttons are on
														# the window:
														#
		    fun site_watcher1a (site: g2d::Box) =  put_in_maildrop (site1a', site);			# Row one,   first  button, site notification callback.
		    fun site_watcher2a (site: g2d::Box) =  put_in_maildrop (site2a', site);			# Row one,   second button, site notification callback.
		    fun site_watcher3a (site: g2d::Box) =  put_in_maildrop (site3a', site);			# Row one,   third  button, site notification callback.
		    fun site_watcher4a (site: g2d::Box) =  put_in_maildrop (site4a', site);			# Row one,   fourth button, site notification callback.
														#
		    fun site_watcher1b (site: g2d::Box) =  put_in_maildrop (site1b', site);			# Row two,   first  button, site notification callback.
		    fun site_watcher2b (site: g2d::Box) =  put_in_maildrop (site2b', site);			# Row two,   second button, site notification callback.
		    fun site_watcher3b (site: g2d::Box) =  put_in_maildrop (site3b', site);			# Row two,   third  button, site notification callback.
		    fun site_watcher4b (site: g2d::Box) =  put_in_maildrop (site4b', site);			# Row two,   fourth button, site notification callback.
														#
		    fun site_watcher1c (site: g2d::Box) =  put_in_maildrop (site1c', site);			# Row three, first  button, site notification callback.
		    fun site_watcher2c (site: g2d::Box) =  put_in_maildrop (site2c', site);			# Row three, second button, site notification callback.
		    fun site_watcher3c (site: g2d::Box) =  put_in_maildrop (site3c', site);			# Row three, third  button, site notification callback.
		    fun site_watcher4c (site: g2d::Box) =  put_in_maildrop (site4c', site);			# Row three, fourth button, site notification callback.


		    fun read_back_sites_of_guiplan_widgets ()							# Fill in the above globals via blocking reads.
			=											# We use timeouts (only) to recover gracefully if things are
			{											# somehow so broken that guiboss-imp never calls our callbacks.
														# The order shouldn't matter; here we go left-to-right top-to-bottom:

			    do_one_mailop [ get_from_maildrop' site1a'	==> {. site1a := THE #site;		assert(TRUE);  },	# Row one,   button one.
					    timeout_in' 1.0		==> {. printf "no site1a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site2a'	==> {. site2a := THE #site;		assert(TRUE);  },	# Row one,   button two.
					    timeout_in' 1.0		==> {. printf "no site2a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site3a'	==> {. site3a := THE #site;		assert(TRUE);  },	# Row one,   button three.
					    timeout_in' 1.0		==> {. printf "no site3a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site4a'	==> {. site4a := THE #site;		assert(TRUE);  },	# Row one,   button four.
					    timeout_in' 1.0		==> {. printf "no site4a in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ get_from_maildrop' site1b'	==> {. site1b := THE #site;		assert(TRUE);  },	# Row two,   button one.
					    timeout_in' 1.0		==> {. printf "no site1b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site2b'	==> {. site2b := THE #site;		assert(TRUE);  },	# Row two,   button two.
					    timeout_in' 1.0		==> {. printf "no site2b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site3b'	==> {. site3b := THE #site;		assert(TRUE);  },	# Row two,   button three.
					    timeout_in' 1.0		==> {. printf "no site3b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site4b'	==> {. site4b := THE #site;		assert(TRUE);  },	# Row two,   button four.
					    timeout_in' 1.0		==> {. printf "no site4b in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ get_from_maildrop' site1c'	==> {. site1c := THE #site;		assert(TRUE);  },	# Row three, button one.
					    timeout_in' 1.0		==> {. printf "no site1c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site2c'	==> {. site2c := THE #site;		assert(TRUE);  },	# Row three, button two.
					    timeout_in' 1.0		==> {. printf "no site2c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site3c'	==> {. site3c := THE #site;		assert(TRUE);  },	# Row three, button three.
					    timeout_in' 1.0		==> {. printf "no site3c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site4c'	==> {. site4c := THE #site;		assert(TRUE);  },	# Row three, button four.
					    timeout_in' 1.0		==> {. printf "no site4c in 1 sec!\n";	assert(FALSE); }
					  ];
			};
		end;

		fun mouse_drag_fn										# This mouse-drag callback fn is used by all twelve buttons.
		      {	
			id:			iul::Id,							# Unique id.
			event_point:		g2d::Point,
			start_point:		g2d::Point,
			last_point:		g2d::Point,
			site:			g2d::Box,							# Widget's assigned area in window coordinates.
			phase:			gt::Drag_Phase,	
			modifier_keys_state:	evt::Modifier_Keys_State,					# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:	evt::Mousebuttons_State,					# State of mouse buttons as a bool record.
			gadget_to_guiboss:	gt::Gadget_To_Guiboss,
			widget_to_widgetspace:	w2p::Widget_To_Widgetspace,
			theme:			pt::Widget_Theme
		      }
		    =
		    if (phase == gt::DRAG)									# Ignore the OPEN and DONE events because OPEN won't have a good last_point and
			#											# DONE's event_point may be dubious, e.g. if drag ended outside of drag widget.
			motion = event_point - last_point;
			#
			scroll_state := *scroll_state + motion;

			case *viewport_scroller
			    #
			    NULL  =>    ();
			    THE s =>    s.set_viewport_origin *scroll_state;
			esac;
		    fi;


		stipulate
		    client_to_guiwindow_ref = REF (NULL: Null_Or( gt::Client_To_Guiwindow ) );			# This is NULL when our popup_plan sub-gui is not running; when popup_plan gui is running it contains (THE client_to_guiwindow), which interface contains the call to shut down the popup gui.
		herein
		    fun mouse_drag_and_popup_fn_1a								# This mouse-drag callback fn is used by only row-1, button-4 on gui_plan gui, which button pops up a popup gui based on popup_plan.
			  {	
			    id:				iul::Id,						# Unique id.
			    event_point:		g2d::Point,
			    start_point:		g2d::Point,
			    last_point:			g2d::Point,
			    site:			g2d::Box,						# Widget's assigned area in window coordinates.
			    phase:			gt::Drag_Phase,	
			    modifier_keys_state:	evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			    mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			    gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			    widget_to_widgetspace:	w2p::Widget_To_Widgetspace,
			    theme:			pt::Widget_Theme
			  }
			=
{
nb {. "mouse_drag_and_popup_fn_1a invoked!\n"; };
			case phase
			    #
			    gt::DONE => ();									# Ignore the DONE event.
			    gt::OPEN
				=>
				case *client_to_guiwindow_ref
				    #
				    THE client_to_guiwindow							# popup_plan is running, so we'll interpret the mouse downclick as a request to kill it.
					=>
					{
nb {. "mouse_drag_and_popup_fn_1a: running, shutting down.\n"; };
					    client_to_guiwindow.kill_gui ();					# Tell guiboss_imp to shut down the popup_plan gui.
					    #
					    client_to_guiwindow_ref := NULL;					# Trust that guiboss_imp did so and record the popup_plan as being dead.
					};

				    NULL =>									# popup_plan is not currently running, so we'll interpret the mouse downclick as a request try starting it.
{
nb {. "mouse_drag_and_popup_fn_1a: not running, starting up.\n"; };
					case *make_popup1a
					    #
					    NULL => {								# We don't yet have a make_popup(), so we cannot start up popup_plan.
nb {. "mouse_drag_and_popup_fn_1a: *make_popup1a is NULL\n"; };
							();
						    };

					    THE make_popup							# We DO have a make_popup(), so go ahead and start up popup_plan.
						=>
{
nb {. "mouse_drag_and_popup_fn_1a: *make_popup1a is NON-null\n"; };
						case popup_info3
						    #
						    NULL => ();							# This gui doesn't pop up a sub-gui.

						    THE popup_info_fn
							=>
							{
nb {. "mouse_drag_and_popup_fn_1a: calling popup_info_fn()\n"; };
							    (popup_info_fn ())
								->
								{ requested_popup_site:	g2d::Box,		# For popup_plan this was:  { row => 200, col => 200, wide => 1200, high => 900 };
								  popup_plan:		gt::Gui_Plan,		# 
								  read__make_popupp4a__from_guiboss
								};

							    (make_popup (requested_popup_site, popup_plan))
								->
								(actual_site, client_to_guiwindow);

							    client_to_guiwindow_ref :=  (THE client_to_guiwindow);

							    read__make_popupp4a__from_guiboss ();		# Read the make_popup used by popup_gui to create popup_gui2.
							};
						esac;
};
					esac;
};
				esac;

			    gt::DRAG										# For drag purposes (sliding the viewport contents) we ignore the OPEN
				=>										# and DONE events because OPEN won't have a good last_point and DONE's
				{										# event_point may be dubious, e.g. if drag ended outside of drag widget.
				    motion = event_point - last_point;
				    #
				    scroll_state := *scroll_state + motion;

				    case *viewport_scroller
					#
					NULL  =>    ();
					THE s =>    s.set_viewport_origin *scroll_state;
				    esac;
				};
			esac;
};

		    fun mouse_drag_and_popup_fn_4a								# This mouse-drag callback fn is used by only row-1, button-4 on gui_plan gui, which button pops up a popup gui based on popup_plan.
			  {	
			    id:				iul::Id,						# Unique id.
			    event_point:		g2d::Point,
			    start_point:		g2d::Point,
			    last_point:			g2d::Point,
			    site:			g2d::Box,						# Widget's assigned area in window coordinates.
			    phase:			gt::Drag_Phase,	
			    modifier_keys_state:	evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			    mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			    gadget_to_guiboss:		gt::Gadget_To_Guiboss,
			    widget_to_widgetspace:	w2p::Widget_To_Widgetspace,
			    theme:			pt::Widget_Theme
			  }
			=
			case phase
			    #
			    gt::DONE => ();									# Ignore the DONE event.
			    gt::OPEN
				=>
				case *client_to_guiwindow_ref
				    #
				    THE client_to_guiwindow							# popup_plan is running, so we'll interpret the mouse downclick as a request to kill it.
					=>
					{
					    client_to_guiwindow.kill_gui ();					# Tell guiboss_imp to shut down the popup_plan gui.
					    #
					    client_to_guiwindow_ref := NULL;					# Trust that guiboss_imp did so and record the popup_plan as being dead.
					};

				    NULL =>									# popup_plan is not currently running, so we'll interpret the mouse downclick as a request try starting it.
					case *make_popup4a
					    #
					    NULL => {								# We don't yet have a make_popup(), so we cannot start up popup_plan.
							();
						    };

					    THE make_popup							# We DO have a make_popup(), so go ahead and start up popup_plan.
						=>
						case popup_info
						    #
						    NULL => ();							# This gui doesn't pop up a sub-gui.

						    THE popup_info_fn
							=>
							{   (popup_info_fn ())
								->
								{ requested_popup_site:	g2d::Box,		# For popup_plan this was:  { row => 200, col => 200, wide => 1200, high => 900 };
								  popup_plan:		gt::Gui_Plan,		# 
								  read__make_popupp4a__from_guiboss
								};

							    (make_popup (requested_popup_site, popup_plan))
								->
								(actual_site, client_to_guiwindow);

							    client_to_guiwindow_ref :=  (THE client_to_guiwindow);

							    read__make_popupp4a__from_guiboss ();		# Read the make_popup used by popup_gui to create popup_gui2.
							};
						esac;
					esac;
				esac;

			    gt::DRAG										# For drag purposes (sliding the viewport contents) we ignore the OPEN
				=>										# and DONE events because OPEN won't have a good last_point and DONE's
				{										# event_point may be dubious, e.g. if drag ended outside of drag widget.
				    motion = event_point - last_point;
				    #
				    scroll_state := *scroll_state + motion;

				    case *viewport_scroller
					#
					NULL  =>    ();
					THE s =>    s.set_viewport_origin *scroll_state;
				    esac;
				};
			esac;
		end;


		font = [ "-*-courier-bold-r-*-*-20-*-*-*-*-*-*-*" ];

		gui_plan
		  =
		  gt::FRAME
		    ( [],
		      gt::COL
			[
			  ( gt::FRAME
			      ( [],
				gt::ROW [
				      arrowbutton::with     [ ab::LEFT ,  ab::TEXT "ZOO",  ab::THICK 20,  ab::FONT font,  ab::MARGIN 40,  ab::SITE_WATCHER site_watcher1a,  ab::MOUSE_DRAG_FN mouse_drag_and_popup_fn_1a, ab::POPUP_WATCHER popup_watcher1a ],
				      arrowbutton::with     [ ab::UP   ,  ab::TEXT "xyz",  ab::THICK 20,  ab::FONT font,  ab::MARGIN 40,  ab::SITE_WATCHER site_watcher2a,  ab::MOUSE_DRAG_FN mouse_drag_fn ],
				      arrowbutton::with     [ ab::DOWN ,  ab::TEXT "xyz",  ab::THICK 20,  ab::FONT font,  ab::MARGIN 40,  ab::SITE_WATCHER site_watcher3a,  ab::MOUSE_DRAG_FN mouse_drag_fn ],
				      arrowbutton::with     [ ab::RIGHT,  ab::TEXT "SUB",  ab::THICK 20,  ab::FONT font,  ab::MARGIN 40,  ab::SITE_WATCHER site_watcher4a,  ab::MOUSE_DRAG_FN mouse_drag_and_popup_fn_4a, ab::POPUP_WATCHER popup_watcher4a ]
				    ]
			      )
			  ),

			  ( gt::SCROLLABLE_VIEW
			      ( (\\ scroller =  viewport_scroller := scroller):	gt::Viewport_Scroller_Callback,
				scrollable_view_size,
				gt::FRAME
				  ( [],
				    gt::ROW [
					  arrowbutton::with [ ab::LEFT ,  ab::TEXT "xyz",  ab::THICK 20,  ab::FONT font,  ab::MARGIN 40,  ab::SITE_WATCHER site_watcher1b,  ab::MOUSE_DRAG_FN mouse_drag_fn ],
					  arrowbutton::with [ ab::UP   ,  ab::TEXT "xyz",  ab::THICK 20,  ab::FONT font,  ab::MARGIN 40,  ab::SITE_WATCHER site_watcher2b,  ab::MOUSE_DRAG_FN mouse_drag_fn ],
					  arrowbutton::with [ ab::DOWN ,  ab::TEXT "xyz",  ab::THICK 20,  ab::FONT font,  ab::MARGIN 40,  ab::SITE_WATCHER site_watcher3b,  ab::MOUSE_DRAG_FN mouse_drag_fn ],
					  arrowbutton::with [ ab::RIGHT,  ab::TEXT "xyz",  ab::THICK 20,  ab::FONT font,  ab::MARGIN 40,  ab::SITE_WATCHER site_watcher4b,  ab::MOUSE_DRAG_FN mouse_drag_fn ]
					]
				  )
			      )
			  ),

			  ( gt::FRAME
			      ( [],
				gt::ROW [
				      arrowbutton::with     [ ab::LEFT ,  ab::TEXT "xyz",  ab::THICK 20,  ab::FONT font,  ab::MARGIN 40,  ab::SITE_WATCHER site_watcher1c,  ab::MOUSE_DRAG_FN mouse_drag_fn ],
				      arrowbutton::with     [ ab::UP   ,  ab::TEXT "xyz",  ab::THICK 20,  ab::FONT font,  ab::MARGIN 40,  ab::SITE_WATCHER site_watcher2c,  ab::MOUSE_DRAG_FN mouse_drag_fn ],
				      arrowbutton::with     [ ab::DOWN ,  ab::TEXT "xyz",  ab::THICK 20,  ab::FONT font,  ab::MARGIN 40,  ab::SITE_WATCHER site_watcher3c,  ab::MOUSE_DRAG_FN mouse_drag_fn ],
				      arrowbutton::with     [ ab::RIGHT,  ab::TEXT "xyz",  ab::THICK 20,  ab::FONT font,  ab::MARGIN 40,  ab::SITE_WATCHER site_watcher4c,  ab::MOUSE_DRAG_FN mouse_drag_fn ]
				    ]
			      )
			  )
			]
		    );

		{ gui_plan,
		  viewport_scroller,
		  scroll_state,

		  widget_sites =>     { site1a, site2a, site3a, site4a,
					site1b, site2b, site3b, site4b,
					site1c, site2c, site3c, site4c
				      },

		  read_back_sites_of_guiplan_widgets,

		  read__make_popup1a__from_guiboss,
		  read__make_popup4a__from_guiboss
		};
	    };													# fun make_three_row_gui_plan

	fun make_grid_gui_plan  ()
	      #
	      :	{ gui_plan:		gt::Gui_Plan,
														# Here we return globals which wind up containing the window sites
														# assigned to our various widgets.  Normal application code never
														# needs to know this, but our test code needs this information in
														# order to synthesize fake mouseclicks etc on the buttons.
														#
		  widget_sites:   { site1a: Ref (Null_Or(g2d::Box)),						# Row one,   button one.
				    site2a: Ref (Null_Or(g2d::Box)),						# Row one,   button two.
														#
				    site1b: Ref (Null_Or(g2d::Box)),						# Row two,   button one.  
				    site2b: Ref (Null_Or(g2d::Box))						# Row two,   button two.  
				  },

		  read_back_sites_of_grid_guiplan_widgets:	Void -> Void					# Fills in values of widget_sites
		}
	    =
	    {
		stipulate
		    site1a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   first  button, site notification maildrop.
		    site2a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   second button, site notification maildrop.
														#
		    site1b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   first  button, site notification maildrop.
		    site2b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   second button, site notification maildrop.
		herein														                                                     
														# These globals hold the values read from the above
														# mailops by the later do_one_mailop() calls.
														# They hold the sites (window locations) assigned to
														# our twelve pushbuttons. (We need this information
														# to generate fake mouseclicks on them for test
														# purposes. A normal GUI app wouldn't do this.) 
														#
		    site1a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button one.
		    site2a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button two.
														#
		    site1b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button one.  
		    site2b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button two.  

														# These are the site-watcher callbacks we pass to the
														# guiboss layer to find out where our buttons are on
														# the window:
														#
		    fun site_watcher1a (site: g2d::Box) =  put_in_maildrop (site1a', site);			# Row one,   first  button, site notification callback.
		    fun site_watcher2a (site: g2d::Box) =  put_in_maildrop (site2a', site);			# Row one,   second button, site notification callback.
														#
		    fun site_watcher1b (site: g2d::Box) =  put_in_maildrop (site1b', site);			# Row two,   first  button, site notification callback.
		    fun site_watcher2b (site: g2d::Box) =  put_in_maildrop (site2b', site);			# Row two,   second button, site notification callback.


		    fun read_back_sites_of_grid_guiplan_widgets ()						# Fill in the above globals via blocking reads.
			=											# We use timeouts (only) to recover gracefully if things are
			{											# somehow so broken that guiboss-imp never calls our callbacks.
														# The order shouldn't matter; here we go left-to-right top-to-bottom:

			    do_one_mailop [ get_from_maildrop' site1a'	==> {. site1a := THE #site;		assert(TRUE);  },	# Row one,   button one.
					    timeout_in' 1.0		==> {. printf "no site1a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site2a'	==> {. site2a := THE #site;		assert(TRUE);  },	# Row one,   button two.
					    timeout_in' 1.0		==> {. printf "no site2a in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ get_from_maildrop' site1b'	==> {. site1b := THE #site;		assert(TRUE);  },	# Row two,   button one.
					    timeout_in' 1.0		==> {. printf "no site1b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site2b'	==> {. site2b := THE #site;		assert(TRUE);  },	# Row two,   button two.
					    timeout_in' 1.0		==> {. printf "no site2b in 1 sec!\n";	assert(FALSE); }
					  ];
			};
		end;

		fun mouse_drag_fn										# 
		      {	
			id:			iul::Id,							# Unique id.
			event_point:		g2d::Point,
			start_point:		g2d::Point,
			last_point:		g2d::Point,
			site:			g2d::Box,							# Widget's assigned area in window coordinates.
			phase:			gt::Drag_Phase,	
			modifier_keys_state:	evt::Modifier_Keys_State,					# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:	evt::Mousebuttons_State,					# State of mouse buttons as a bool record.
			gadget_to_guiboss:	gt::Gadget_To_Guiboss,
			widget_to_widgetspace:	w2p::Widget_To_Widgetspace,
			theme:			pt::Widget_Theme
		      }
		    =
		    if (phase == gt::DRAG)									# Ignore the OPEN and DONE events because OPEN won't have a good last_point and
			#											# DONE's event_point may be dubious, e.g. if drag ended outside of drag widget.
			motion = event_point - last_point;
			#
		    fi;




		gui_plan
		  =
		  gt::FRAME
		    ( [],
		      ( gt::GRID
			  [
			    [ arrowbutton::with [ ab::SITE_WATCHER site_watcher1a, ab::LEFT , ab::MOUSE_DRAG_FN mouse_drag_fn,  ab::PIXELS_HIGH_MIN  0,  ab::PIXELS_WIDE_MIN  0,  ab::PIXELS_HIGH_CUT 1.0,  ab::PIXELS_WIDE_CUT 1.0,  ab::MARGIN 40,  ab::THICK 20  ],
			      arrowbutton::with [ ab::SITE_WATCHER site_watcher2a, ab::UP   , ab::MOUSE_DRAG_FN mouse_drag_fn,  ab::PIXELS_HIGH_MIN  0,  ab::PIXELS_WIDE_MIN 40,  ab::PIXELS_HIGH_CUT 1.0,  ab::PIXELS_WIDE_CUT 0.0 ]
			    ],
			    [ arrowbutton::with [ ab::SITE_WATCHER site_watcher1b, ab::LEFT , ab::MOUSE_DRAG_FN mouse_drag_fn,  ab::PIXELS_HIGH_MIN 40,  ab::PIXELS_WIDE_MIN  0,  ab::PIXELS_HIGH_CUT 0.0,  ab::PIXELS_WIDE_CUT 1.0 ],
			      arrowbutton::with [ ab::SITE_WATCHER site_watcher2b, ab::UP   , ab::MOUSE_DRAG_FN mouse_drag_fn,  ab::PIXELS_HIGH_MIN 40,  ab::PIXELS_WIDE_MIN 40,  ab::PIXELS_HIGH_CUT 0.0,  ab::PIXELS_WIDE_CUT 0.0 ]
			    ]
			  ]
		      )
		    );

		{ gui_plan,

		  widget_sites =>     { site1a, site2a,
					site1b, site2b
				      },

		  read_back_sites_of_grid_guiplan_widgets
		};
	    };																	# fun make_grid_gui_plan

	fun make_zoo_gui_plan  ()
	      #
	      :	{ gui_plan:		gt::Gui_Plan,
														# Here we return globals which wind up containing the window sites
														# assigned to our various widgets.  Normal application code never
														# needs to know this, but our test code needs this information in
														# order to synthesize fake mouseclicks etc on the buttons.
														#
		  widget_sites:   { site1a: Ref (Null_Or(g2d::Box)),						# Row one,   button one.
				    site2a: Ref (Null_Or(g2d::Box)),						# Row one,   button two.
														#
				    site1b: Ref (Null_Or(g2d::Box)),						# Row two,   button one.  
				    site2b: Ref (Null_Or(g2d::Box))						# Row two,   button two.  
				  },

		  read_back_sites_of_zoo_guiplan_widgets:	Void -> Void					# Fills in values of widget_sites
		}
	    =
	    {
		stipulate
		    site1a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   first  button, site notification maildrop.
		    site2a' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row one,   second button, site notification maildrop.
														#
		    site1b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   first  button, site notification maildrop.
		    site2b' = make_empty_maildrop(): Maildrop( g2d::Box );					# Row two,   second button, site notification maildrop.
		herein														                                                     
														# These globals hold the values read from the above
														# mailops by the later do_one_mailop() calls.
														# They hold the sites (window locations) assigned to
														# our twelve pushbuttons. (We need this information
														# to generate fake mouseclicks on them for test
														# purposes. A normal GUI app wouldn't do this.) 
														#
		    site1a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button one.
		    site2a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button two.
														#
		    site1b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button one.  
		    site2b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button two.  

														# These are the site-watcher callbacks we pass to the
														# guiboss layer to find out where our buttons are on
														# the window:
														#
		    fun site_watcher1a (site: g2d::Box) =  put_in_maildrop (site1a', site);			# Row one,   first  button, site notification callback.
		    fun site_watcher2a (site: g2d::Box) =  put_in_maildrop (site2a', site);			# Row one,   second button, site notification callback.
														#
		    fun site_watcher1b (site: g2d::Box) =  put_in_maildrop (site1b', site);			# Row two,   first  button, site notification callback.
		    fun site_watcher2b (site: g2d::Box) =  put_in_maildrop (site2b', site);			# Row two,   second button, site notification callback.


		    fun read_back_sites_of_zoo_guiplan_widgets ()						# Fill in the above globals via blocking reads.
			=											# We use timeouts (only) to recover gracefully if things are
			{											# somehow so broken that guiboss-imp never calls our callbacks.
														# The order shouldn't matter; here we go left-to-right top-to-bottom:

			    do_one_mailop [ get_from_maildrop' site1a'	==> {. site1a := THE #site;		assert(TRUE);  },	# Row one,   button one.
					    timeout_in' 1.0		==> {. printf "no site1a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site2a'	==> {. site2a := THE #site;		assert(TRUE);  },	# Row one,   button two.
					    timeout_in' 1.0		==> {. printf "no site2a in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ get_from_maildrop' site1b'	==> {. site1b := THE #site;		assert(TRUE);  },	# Row two,   button one.
					    timeout_in' 1.0		==> {. printf "no site1b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ get_from_maildrop' site2b'	==> {. site2b := THE #site;		assert(TRUE);  },	# Row two,   button two.
					    timeout_in' 1.0		==> {. printf "no site2b in 1 sec!\n";	assert(FALSE); }
					  ];
			};
		end;

		fun mouse_drag_fn										# 
		      {	
			id:			iul::Id,							# Unique id.
			event_point:		g2d::Point,
			start_point:		g2d::Point,
			last_point:		g2d::Point,
			site:			g2d::Box,							# Widget's assigned area in window coordinates.
			phase:			gt::Drag_Phase,	
			modifier_keys_state:	evt::Modifier_Keys_State,					# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:	evt::Mousebuttons_State,					# State of mouse buttons as a bool record.
			gadget_to_guiboss:	gt::Gadget_To_Guiboss,
			widget_to_widgetspace:	w2p::Widget_To_Widgetspace,
			theme:			pt::Widget_Theme
		      }
		    =
		    if (phase == gt::DRAG)									# Ignore the OPEN and DONE events because OPEN won't have a good last_point and
			#											# DONE's event_point may be dubious, e.g. if drag ended outside of drag widget.
			motion = event_point - last_point;
			#
		    fi;




		gui_plan
		  =
		  gt::FRAME
		    ( [],
		      ( gt::GRID
			  [
			    [ arrowbutton::with [ ab::SITE_WATCHER site_watcher1a, ab::LEFT , ab::MOUSE_DRAG_FN mouse_drag_fn,  ab::PIXELS_HIGH_MIN  0,  ab::PIXELS_WIDE_MIN  0,  ab::PIXELS_HIGH_CUT 1.0,  ab::PIXELS_WIDE_CUT 1.0 ],
			      arrowbutton::with [ ab::SITE_WATCHER site_watcher2a, ab::UP   , ab::MOUSE_DRAG_FN mouse_drag_fn,  ab::PIXELS_HIGH_MIN  0,  ab::PIXELS_WIDE_MIN  0,  ab::PIXELS_HIGH_CUT 1.0,  ab::PIXELS_WIDE_CUT 1.0 ]
			    ],
			    [ arrowbutton::with [ ab::SITE_WATCHER site_watcher1b, ab::LEFT , ab::MOUSE_DRAG_FN mouse_drag_fn,  ab::PIXELS_HIGH_MIN  0,  ab::PIXELS_WIDE_MIN  0,  ab::PIXELS_HIGH_CUT 1.0,  ab::PIXELS_WIDE_CUT 1.0 ],
			      arrowbutton::with [ ab::SITE_WATCHER site_watcher2b, ab::UP   , ab::MOUSE_DRAG_FN mouse_drag_fn,  ab::PIXELS_HIGH_MIN  0,  ab::PIXELS_WIDE_MIN  0,  ab::PIXELS_HIGH_CUT 1.0,  ab::PIXELS_WIDE_CUT 1.0 ]
			    ]
			  ]
		      )
		    );

		{ gui_plan,

		  widget_sites =>     { site1a, site2a,
					site1b, site2b
				      },

		  read_back_sites_of_zoo_guiplan_widgets
		};
	    };																	# fun make_zoo_gui_plan

	fun exercise_window_stuff  ()
	    =
	    {
		fun int_sink i = ();
printf "widget-unit-test.pkg/exercise_window_stuff/TOP\n";

		# Here we build a three-layer cake:
		#
		#    -----------------
		#    |     Gui Boss |
		#    -----------------
		#    |     Theme     |
		#    -----------------
		#    |     Appwindow |
		#    -----------------
		#
		# The Gui Boss is windowsystem-agnostic; it de/constructs and maintains running GUI impnets from gui specification trees. 
		# The Theme is windowsystem-specific (e.g., X-specific) and encapsulates how to draw the various widgets on the given windowsystem.
		# The Appwindow is windowsystem-specific and encapulates X-specific application window stuff like EXPOSE event-handling.


		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		windowsystem_needs   =  { };
		windowsystem_options =  [ ];
		windowsystem_arg     =  (windowsystem_needs, windowsystem_options);
		#
		(awx::make_windowsystem_egg  windowsystem_arg  NULL) ->  windowsystem_egg;
		#
		(windowsystem_egg			()) ->   (windowsystem_exports, windowsystem_egg');


		(dbx::make_sprite_theme_egg	[]) ->   sprite_theme_egg;
		(sprite_theme_egg		()) ->  (sprite_theme_exports, sprite_theme_egg');
		#
		(dcx::make_object_theme_egg	[]) ->   object_theme_egg;
		(object_theme_egg		()) ->  (object_theme_exports, object_theme_egg');
		#
		(dtx::make_widget_theme_egg	[]) ->   widget_theme_egg;
		(widget_theme_egg		()) ->  (widget_theme_exports, widget_theme_egg');

		
		(gq::make_guiboss_egg		[]) ->  guiboss_egg;
		(guiboss_egg			()) -> (guiboss_exports, guiboss_egg');

		#
		(ti::make_template_egg		[]) -> template_egg;
		(template_egg			()) -> (template_exports, template_egg');

		#
		windowsystem_exports	-> { guiboss_to_windowsystem	};
		#
		sprite_theme_exports	-> { gui_to_sprite_theme	};
		object_theme_exports	-> { gui_to_object_theme	};
		widget_theme_exports	-> { theme			};
		#
		guiboss_exports		-> { client_to_guiboss	};
		template_exports	-> { template		};

		template_imports = { int_sink =>  \\ (i: Int) = ()  };

		guiboss_egg'		( { int_sink,
					    guiboss_to_windowsystem,
					    gui_to_sprite_theme,
					    gui_to_object_theme,
					    theme
					  },
					  run_gun', end_gun'
				        );
		#
		sprite_theme_egg'	({ int_sink,     guiboss_to_windowsystem	},	run_gun', end_gun');
		object_theme_egg'	({ int_sink,     guiboss_to_windowsystem	},	run_gun', end_gun');
		widget_theme_egg'	({ int_sink,     guiboss_to_windowsystem	},	run_gun', end_gun');
		#
		windowsystem_egg'	({ int_sink					},	run_gun', end_gun');
		template_egg'		( template_imports,					run_gun', end_gun');



		fire_run_gun ();

		b  =  client_to_guiboss.get_sprite_theme ();
		c  =  client_to_guiboss.get_object_theme ();
		t  =  client_to_guiboss.get_widget_theme ();
		#
		{
# We do not yet have asserts on these two:    XXX SUCKO FIXME
		    got_state_change_event		= REF FALSE;
		    got_redraw_gadget_request_event	= REF FALSE;
		    #
		    got_button_press_event		= REF FALSE;
		    got_button_release_event		= REF FALSE;
		    #
		    got_key_press_event			= REF FALSE;
		    got_key_release_event		= REF FALSE;

# 		    stipulate
# 			first_frame1 =  REF TRUE;
# 			first_frame2 =  REF TRUE;
# 
# 			fun redraw_gadget_request_fn1
# 			    {
# 			      id:				iul::Id,						# Unique id.
# 			      frame_number:			Int,							# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
# 			      site:				g2d::Box,						# Window rectangle in which to draw.
# 			      visible:				Bool,							# If FALSE, widget is not visible on screen, so widget-imp may be able to avoid updating foreground and background.
# 			      duration_in_seconds:		Float,							# If state has changed widget-imp should call redraw_gadget() before this time is up. Also useful for motionblur.
# 			      gadget_to_guiboss:		gt::Gadget_To_Guiboss,
# 			      widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
# 			      this_gadget_mode:			gt::Gadget_Mode,
# 			      theme:				pt::Widget_Theme
# 			    }
# 			    =
# 			    {
# #				if *first_frame1
# 				    first_frame1 := FALSE;
# 
# 				    background_box =  site;
# 				    foreground_box =  g2d::box::make_nested_box (background_box, 4);
# 
# 				    background = gt::CHANGED (THE (gd::COLOR (r8::rgb8_red,    [ gd::POLY_FILL_BOX [ background_box ]])));
# 				    foreground = gt::CHANGED (THE (gd::COLOR (r8::rgb8_yellow, [ gd::POLY_FILL_BOX [ foreground_box ]])));
# 
# 				    gadget_to_guiboss.redraw_gadget { id, foreground, background };
# #				fi;
# 			    };
# 
# 			fun redraw_gadget_request_fn2
# 			    {
# 			      id:				iul::Id,						# Unique id.
# 			      frame_number:			Int,							# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
# 			      site:				g2d::Box,						# Window rectangle in which to draw.
# 			      visible:				Bool,							# If FALSE, widget is not visible on screen, so widget-imp may be able to avoid updating foreground and background.
# 			      duration_in_seconds:		Float,							# If state has changed widget-imp should call redraw_gadget() before this time is up. Also useful for motionblur.
# 			      gadget_to_guiboss:		gt::Gadget_To_Guiboss,
# 			      widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
# 			      this_gadget_mode:			gt::Gadget_Mode,
# 			      theme:				pt::Widget_Theme
# 			    }
# 			    =
# 			    {
# #				if *first_frame
# 				    first_frame2 := FALSE;
# 
# 				    background_box =  site;
# 				    foreground_box =  g2d::box::make_nested_box (background_box, 4);
# 
# 				    background = gt::CHANGED (THE (gd::COLOR (r8::rgb8_red,    [ gd::POLY_FILL_BOX [ background_box ]])));
# 				    foreground = gt::CHANGED (THE (gd::COLOR (r8::rgb8_yellow, [ gd::POLY_FILL_BOX [ foreground_box ]])));
# 
# 				    gadget_to_guiboss.redraw_gadget { id, foreground, background };
# #				fi;
# 			    };
# 
# 			fun button_press_fn
# 			      {
#				id:				iul::Id,						# Unique id.
#				button:				evt::Mousebutton,
# 				point:				g2d::Point,
# 				site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				gadget_to_guiboss:		gt::Gadget_To_Guiboss,
# 				widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
# 				theme:				pt::Widget_Theme
# 			      }
# 			    = 
# 			    {
# 				got_button_press_event := TRUE;
# nb {. sprintf "button_press_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			fun button_release_fn
# 			      {
#				id:				iul::Id,						# Unique id.
#				button:				evt::Mousebutton,
# 				point:				g2d::Point,
# 				site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				gadget_to_guiboss:		gt::Gadget_To_Guiboss,
# 				widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
# 				theme:				pt::Widget_Theme
# 			      }
# 			    = 
# 			    {
# 				got_button_release_event := TRUE;
# nb {. sprintf "button_release_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			fun key_press_fn
# 			      {
#				id:				iul::Id,						# Unique id.
#				keycode:			evt::Keycode,						# Keycode of the depressed key.
# 				keysym:				evt::Keysym,						# Keysym  of the depressed key.
# 				ascii:				String,							# Ascii  for the depressed key.
# 				point:				g2d::Point,
# 				site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				gadget_to_guiboss:		gt::Gadget_To_Guiboss,
# 				widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
# 				theme:				pt::Widget_Theme
# 			      }
# 			    = 
# 			    {
# 				got_key_press_event := TRUE;
# nb {. sprintf "key_press_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			fun key_release_fn
# 			      {
#				id:				iul::Id,						# Unique id.
#			        keycode:			evt::Keycode,						# Keycode of the released key.
# 				keysym:				evt::Keysym,						# Keysym  of the released key.
# 				ascii:				String,							# Ascii  for the released key.
# 				point:				g2d::Point,
# 				site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				gadget_to_guiboss:		gt::Gadget_To_Guiboss,
# 				widget_to_widgetspace:		w2p::Widget_To_Widgetspace,
# 				theme:				pt::Widget_Theme
# 			      }
# 			    = 
# 			    {
# 				got_key_release_event := TRUE;
# nb {. sprintf "key_release_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			widget_options1
# 			  =
# 			  [
# 			    wim::REDRAW_GADGET_REQUEST_FN	redraw_gadget_request_fn1,
# 			    wim::BUTTON_PRESS_FN		button_press_fn,
# 			    wim::BUTTON_RELEASE_FN		button_release_fn,
# 			    wim::KEY_PRESS_FN			key_press_fn,
# 			    wim::KEY_RELEASE_FN			key_release_fn
# 			  ];
# 
# 			widget_options2
# 			  =
# 			  [
# 			    wim::REDRAW_GADGET_REQUEST_FN	redraw_gadget_request_fn2,
# 			    wim::BUTTON_PRESS_FN		button_press_fn,
# 			    wim::BUTTON_RELEASE_FN		button_release_fn,
# 			    wim::KEY_PRESS_FN			key_press_fn,
# 			    wim::KEY_RELEASE_FN			key_release_fn
# 			  ];
# 
# 		    herein
# 			make_widget_fn1 =  wim::make_widget_start_fn  widget_options1;
# 			make_widget_fn2 =  wim::make_widget_start_fn  widget_options2;
# 			    
# 		    end;


		    # We're constructing a gui_plan with three rows of four buttons each.
		    #
		    # Each button responds to a click by changing its appearance.
		    #
		    # Also, the middle row of buttons is in a scrollable viewport;
		    # dragging on any button will scroll the middle row around in
		    # its viewport.
		    #
		    # We also note the site (size and location) of each button widget;
		    # we need this information (only) to synthesize fake test clicks
		    # on the buttons via
		    #     guiboss_to_topwindow.send_fake_mousebutton_release_event()

														# These mailops are referenced only in
														#     1) The immediately following site_watcher1a etc fns
														#     2) The read_back_sites_of_guiplan_widgets do_one_mailop() calls
														#        which copy read value into site1a etc.





		    # Create gui_plan:
		    #
		    stipulate														# NB: This is size for the view visible in the viewport, not the viewport itself.
#			scrollable_view_size = { wide => 1600, high => 400 },								# This setting makes middle row exactly fill viewport.
			scrollable_view_size = { wide => 1580, high => 380 };								# This setting makes middle row slightly to small for viewport -- useful for testing the logic which fills the cracks with black at startup.


			fun popup_info ()
			    =
			    {   requested_popup_site = { row => 200, col => 200, wide => 1200, high => 900 };
				#
				# Create popup_plan:
				#
				stipulate												# NB: This is size for the view visible in the viewport, not the viewport itself.
#				    scrollable_view_size = { wide => 1200, high => 300 };						# This setting makes middle row exactly fill viewport.
				    scrollable_view_size = { wide => 1150, high => 280 };						# This setting makes middle row slightly to small for viewport -- useful for testing the logic which fills the cracks with black at startup.

				    fun popup_info2 ()
					=
					{   requested_popup_site = { row => 300, col => 300, wide => 600, high => 600 };
					    #
					    # Create popup_plan2:
					    #
					    (make_grid_gui_plan ())
						->
						{ gui_plan	=>  popup_plan2,
						  widget_sites	=>  widget_sites_for_popup2,
						  #
						  read_back_sites_of_grid_guiplan_widgets => read_back_sites_of_guiplan_widgets_for_popup2
						};


					    { requested_popup_site,
					      popup_plan => popup_plan2,
					      read__make_popupp4a__from_guiboss =>   \\ () = ()
					    };
					};


				herein
				    (make_three_row_gui_plan (scrollable_view_size, THE popup_info2, NULL))
					->
					{ gui_plan		=>  popup_plan,
					  viewport_scroller	=>  viewport_scroller_for_popup,
					  scroll_state		=>  scroll_state_for_popup,
					  widget_sites		=>  widget_sites_for_popup,
					  #
					  read_back_sites_of_guiplan_widgets => read_back_sites_of_guiplan_widgets_for_popup,
					  read__make_popup1a__from_guiboss   => read__make_popup1a__from_guiboss_for_popup,
					  read__make_popup4a__from_guiboss   => read__make_popup4a__from_guiboss_for_popup
					};
				end;

				{ requested_popup_site,
 				  popup_plan,
				  read__make_popupp4a__from_guiboss => read__make_popup4a__from_guiboss_for_popup
				};
			    };

			fun popup_info3 ()
			    =
			    {   requested_popup_site = { row => 300, col => 300, wide => 600, high => 600 };
				#
				# Create popup_plan3:
				#
				(make_zoo_gui_plan ())
				    ->
				    { gui_plan	=>  popup_plan3,
				      widget_sites	=>  widget_sites_for_popup3,
				      #
				      read_back_sites_of_zoo_guiplan_widgets => read_back_sites_of_guiplan_widgets_for_popup3
				    };


				requested_popup_site = { row => 400, col => 400, wide => 100, high => 100 };

				{ requested_popup_site,
				  popup_plan => popup_plan3,
				  read__make_popupp4a__from_guiboss =>   \\ () = ()
				};
			    };

		    herein
			(make_three_row_gui_plan (scrollable_view_size, THE popup_info, THE popup_info3))
			    ->
			    { gui_plan,
			      viewport_scroller,
			      scroll_state,
			      widget_sites,
			      #	
			      read_back_sites_of_guiplan_widgets,
			      read__make_popup1a__from_guiboss,
			      read__make_popup4a__from_guiboss
			    };
		    end;



# nb {. sprintf "widget-unit-test pprinting gui_plan:"; };
#		    gt::pprint_gui_plan  gui_plan;

		    topwindow_hints		# 
			=			# 
			[
			  gws::BACKGROUND_PIXEL	(r8::rgb8_from_ints (128+32, 16, 32)),		# Slightly desaturated green. (NOW RED.)
			  gws::BORDER_PIXEL	(r8::rgb8_from_ints (0,       0,  0)),		# Black.
			  #
			  gws::SITE		( { upperleft		=>   { col =>     0, row  =>    0 },
						    size		=>   { wide => 1600, high => 1200 },
						    border_thickness	=>  1
						  }
						  : g2d::Window_Site
						)
			];

		    (client_to_guiboss.make_topwindow  topwindow_hints)
			->
			guiboss_to_topwindow;

		    (guiboss_to_topwindow.exercise_appwindow ())
			->
		        wait_until_exercise_is_complete;
			

		    wait_until_exercise_is_complete ();



		    (client_to_guiboss.start_gui  (guiboss_to_topwindow, gui_plan))
			->
			block_until_gui_startup_is_complete;

		    (block_until_gui_startup_is_complete())
			->
			client_to_guiwindow;

# nb {. sprintf "widget-unit-test doing guiboss_to_topwindow.send_fake_mousebutton_press_event() ..."; };
		    #
#		    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, { row => 13, col => 17 });
#		    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, { row => 14, col => 18 });
		    #
#		    guiboss_to_topwindow.send_fake_key_press_event   (evt::KEYCODE 1, { row => 23, col => 27 });
#		    guiboss_to_topwindow.send_fake_key_release_event (evt::KEYCODE 1, { row => 24, col => 28 });



		    read_back_sites_of_guiplan_widgets ();

		    read__make_popup1a__from_guiboss ();
		    read__make_popup4a__from_guiboss ();




		    sleep_for 3.0;												# Just to give human observer time to observe.

 		    for (i = 1; i <= 10; ++i) {
 			#
if (*log::debugging) log::note  {. sprintf "widget-unit-test lup %d ..." i; }; fi;

#			scroll_state := *scroll_state + autoscroll_distance;
#
#			case *viewport_scroller
#			    #
#			    NULL  =>    ();
#			    THE s =>    s.set_viewport_origin *scroll_state;
#			esac;

			case *widget_sites.site1a
			    #
			    THE site => {
# printf "site1 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
					    site_midpoint = g2d::box::midpoint site;
if (*log::debugging) log::note  {. "widget-unit-test sending site1 downclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
if (*log::debugging) log::note  {. "widget-unit-test sending site1   upclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
					    window_rectangle_to_read = g2d::box::make (site_midpoint, { wide => 5, high => 5 });
					    rw_matrix_rgb8 = guiboss_to_topwindow.get_pixel_rectangle window_rectangle_to_read;
					    row = 1;
					    col = 1;
					    rgb8 = rw_matrix_rgb8[row,col];
					    rgb  =  r8::rgb8_to_rgb rgb8;
# nb {. sprintf "widget-unit-test rw_matrix_rgb8[%d,%d] = { red => %g, green => %g, blue => %g }\n" row col rgb.red rgb.green rgb.blue; };
					};
			    NULL	 => ();
			esac;
# 			case *site2a
# 			    #
# 			    THE site => {
# # printf "site2 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site2 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site2   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site3a
# 			    #
# 			    THE site => {
# # printf "site3 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site3 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site3   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
			case *widget_sites.site4a
			    #
			    THE site => {
# printf "site4 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
					    site_midpoint = g2d::box::midpoint site;
if (*log::debugging) log::note  {. "widget-unit-test sending site4 downclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
if (*log::debugging) log::note  {. "widget-unit-test sending site4   upclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
					};
			    NULL	 => ();
			esac;


			case *widget_sites.site1b
			    #
			    THE site => {
# printf "site1 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# XXX BUGGO FIXME DO NOT USE 'i' HERE!!!
					    site_midpoint = g2d::box::midpoint site + { row => 400 + i*10, col => i*10 };				# The added 400 is to transform us from the scrollable-view coordinate system into the toplevel window coordinate system.
if (*log::debugging) log::note  {. "widget-unit-test sending site1 downclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
if (*log::debugging) log::note  {. "widget-unit-test sending site1   upclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
					    window_rectangle_to_read = g2d::box::make (site_midpoint, { wide => 5, high => 5 });
					    rw_matrix_rgb8 = guiboss_to_topwindow.get_pixel_rectangle window_rectangle_to_read;
					    row = 1;
					    col = 1;
					    rgb8 = rw_matrix_rgb8[row,col];
					    rgb  =  r8::rgb8_to_rgb rgb8;
# nb {. sprintf "widget-unit-test rw_matrix_rgb8[%d,%d] = { red => %g, green => %g, blue => %g }\n" row col rgb.red rgb.green rgb.blue; };
					};
			    NULL	 => ();
			esac;
# 			case *site2b
# 			    #
# 			    THE site => {
# # printf "site2 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# # XXX BUGGO FIXME DO NOT USE 'i' HERE!!!
# 					    site_midpoint = g2d::box::midpoint site + { row => 400 + i*10, col => i*10 };				# The added 400 is to transform us from the scrollable-view coordinate system into the toplevel window coordinate system.
# if (*log::debugging) log::note  {. "widget-unit-test sending site2 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site2   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site3b
# 			    #
# 			    THE site => {
# # printf "site3 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# # XXX BUGGO FIXME DO NOT USE 'i' HERE!!!
# 					    site_midpoint = g2d::box::midpoint site + { row => 400 + i*10, col => i*10 };				# The added 400 is to transform us from the scrollable-view coordinate system into the toplevel window coordinate system.
# if (*log::debugging) log::note  {. "widget-unit-test sending site3 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site3   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site4b
# 			    #
# 			    THE site => {
# # printf "site4 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# # XXX BUGGO FIXME DO NOT USE 'i' HERE!!!
# 					    site_midpoint = g2d::box::midpoint site + { row => 400 + i*10, col => i*10 };				# The added 400 is to transform us from the scrollable-view coordinate system into the toplevel window coordinate system.
# if (*log::debugging) log::note  {. "widget-unit-test sending site4 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site4   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;


			case *widget_sites.site1c
			    #
			    THE site => {
# printf "site1 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
					    site_midpoint = g2d::box::midpoint site;
if (*log::debugging) log::note  {. "widget-unit-test sending site1 downclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
if (*log::debugging) log::note  {. "widget-unit-test sending site1   upclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
					    window_rectangle_to_read = g2d::box::make (site_midpoint, { wide => 5, high => 5 });
					    rw_matrix_rgb8 = guiboss_to_topwindow.get_pixel_rectangle window_rectangle_to_read;
					    row = 1;
					    col = 1;
					    rgb8 = rw_matrix_rgb8[row,col];
					    rgb  =  r8::rgb8_to_rgb rgb8;
# nb {. sprintf "widget-unit-test rw_matrix_rgb8[%d,%d] = { red => %g, green => %g, blue => %g }\n" row col rgb.red rgb.green rgb.blue; };
					};
			    NULL	 => ();
			esac;
# 			case *site2c
# 			    #
# 			    THE site => {
# # printf "site2 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site2 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site2   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site3c
# 			    #
# 			    THE site => {
# # printf "site3 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site3 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site3   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site4c
# 			    #
# 			    THE site => {
# # printf "site4 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site4 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site4   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;



# nb {. sprintf "widget-unit-test calling sleep_for 5.0 ..."; };
if (*log::debugging) log::note  {. "widget-unit-test calling sleep_for 2.0 ..."; }; fi;
			sleep_for 2.0;
		    };
# if (*log::debugging) log::note  {. "widget-unit-test setting log::debugging back to FALSE."; }; fi;
# log::debugging := FALSE;
# interprocess_signals::set_log_if_on FALSE;

#		    assert *got_button_press_event;
#		    assert *got_button_release_event;

#		    assert *got_key_press_event;
#		    assert *got_key_release_event;

nb {. sprintf "widget-unit-test ending gui run by calling kill_gui..."; };
		    paused_gui' = client_to_guiwindow.kill_gui ();

# nb {. sprintf "widget-unit-test pprinting paused_gui':"; };
#		    gt::pprint_paused_gui  paused_gui';
		};	

		sprite_to_spritespace									# Dummy port back to spritespace-imp from sprite-imp.
		  =
		  { id           =>  id_zero,
		    look_changed =>  (\\ _ = ())
		  };

		object_to_objectspace									# Dummy port back to objectspace-imp from object-imp.
		  =
		  { id           =>  id_zero,
		    look_changed =>  (\\ _ = ())
		  };



# Following is broken at the moment by the restructuring
# of sprite and object code on the model of widget code.
# In particular I think balls wound up with boolean values
# instead of position+velocity values.
#
# For the moment my focus is elsewhere so I'm letting this slide.
# XXX SUCKO FIXME.
# 			-- 2014-07-05 CrT

#		ball_state_endstate_oneshot = NULL;
#		ball_look_endstate_oneshot  = NULL;
#		ball_look_arg         = [];
#		ball_arg =  ( { position => { x => 0.0, y => 0.0, z => 0.0 },
#				velocity => { x => 0.0, y => 0.0, z => 0.0 }
#			      }, 	
#			      []
#			    );
#		(dbl::make_egg ( /* guiboss_to_windowsystem, */ ball_arg, ball_look_arg, sprite_to_spritespace, ball_state_endstate_oneshot, ball_look_endstate_oneshot))
#		    ->
#		    ball_look_egg;
#
#
#
#		node_state_endstate_oneshot = NULL;
#		node_look_endstate_oneshot  = NULL;
#		node_look_arg         = [];
#		node_arg =  ( { text => "foo" },
#			      []
#			    );
#		(dnl::make_egg ( /* guiboss_to_windowsystem, */ node_arg, node_look_arg, object_to_objectspace, node_state_endstate_oneshot, node_look_endstate_oneshot))
#		    ->
#		    node_look_egg;


		fire_end_gun ();
		

		();
	    };

	fun run ()
	    =
	    {   # Remove any old version of the tracefile:
		#
		if (isfile tracefile)  
		    unlink tracefile;
		fi;


		printf "\nDoing %s:\n" name;   


		# Open tracelog file and
                # select tracing level:
		#
		{   include package   logger;				# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
		    #
		    set_logger_to  (fil::LOG_TO_FILE tracefile);
		    #
#		    enable fil::all_logging;			# Gross overkill.
#		    enable xtr::xkit_logging;			# Lesser overkill.
#		    enable xtr::io_logging;			# Saner yet.	
		};

		assert  (tsr::thread_scheduler_is_running ());

		exercise_convex_hull	    ();
		exercise_point_in_polygon   ();
		exercise_window_stuff	    ();

		assert TRUE;

		summarize_unit_tests  name;
	    };
    };

end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
