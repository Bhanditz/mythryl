# textpane.pkg
#
# This package manages one view onto a textbuffer,
# consisting of a number of 
#
#     src/lib/x-kit/widget/edit/screenline.pkg
#
# instances displaying (part of) the contents of
# the textbuffer, plus one displaying the dirtyflag,
# filename etc associated with the textbuffer.
#
# In "Model/View/Controller" terms, textbuffer-imp.pkg
# is the Model and textpane.pkg is the View+Controller.
#
# (textpane.pkg also draws the visible frame around
# the textpane contents, but that is largely incidental
# to its main function.)
#
# Per emacs tradition, we allow multiple textpanes
# to be simultaneously open onto a single textbuffer;
# this heavily influences the design and implementation.
#
# See also:
#     src/lib/x-kit/widget/edit/editboss-imp.pkg
#     src/lib/x-kit/widget/edit/textbuffer-imp.pkg
#     src/lib/x-kit/widget/edit/textedit.pkg
#     src/lib/x-kit/widget/edit/screenline.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib




# This package gets used in:
#
#     

stipulate
    include package   threadkit;						# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    include package   geometry2d;						# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    #
    package evt =  gui_event_types;						# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package g2p =  gadget_to_pixmap;						# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg
    package gd  =  gui_displaylist;						# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    package gt  =  guiboss_types;						# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
    package gtj =  guiboss_types_junk;						# guiboss_types_junk		is from   src/lib/x-kit/widget/gui/guiboss-types-junk.pkg
    package wt  =  widget_theme;						# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg
    package wti =  widget_theme_imp;						# widget_theme_imp		is from   src/lib/x-kit/widget/xkit/theme/widget/default/widget-theme-imp.pkg
    package r8  =  rgb8;							# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;								# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package wi  =  widget_imp;							# widget_imp			is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
    package g2d =  geometry2d;							# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;						# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg
    package mtx =  rw_matrix;							# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
    package pp  =  standard_prettyprint_mill;					# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package gtg =  guiboss_to_guishim;						# guiboss_to_guishim		is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg
    package le  =  screenline;							# screenline			is from   src/lib/x-kit/widget/edit/screenline.pkg
    package tbi =  textbuffer_imp;						# textbuffer_imp		is from   src/lib/x-kit/widget/edit/textbuffer-imp.pkg
    package psx =  posixlib;							# posixlib			is from   src/lib/std/src/psx/posixlib.pkg

    package nl  =  red_black_numbered_list;					# red_black_numbered_list	is from   src/lib/src/red-black-numbered-list.pkg
    package im  =  int_red_black_map;						# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
    package sm  =  string_map;							# string_map			is from   src/lib/src/string-map.pkg

    package iuw =  issue_unique_widget_id;					# issue_unique_widget_id	is from   src/lib/x-kit/widget/gui/issue-unique-widget-id.pkg
    package e2p =  textedit_to_textpane;					# textedit_to_textpane		is from   src/lib/x-kit/widget/edit/textedit-to-textpane.pkg
    package l2p =  screenline_to_textpane;					# screenline_to_textpane	is from   src/lib/x-kit/widget/edit/screenline-to-textpane.pkg
    package p2l =  textpane_to_screenline;					# textpane_to_screenline	is from   src/lib/x-kit/widget/edit/textpane-to-screenline.pkg
    package b2p =  editboss_to_textpane;					# editboss_to_textpane		is from   src/lib/x-kit/widget/edit/editboss-to-textpane.pkg
    package p2e =  textpane_to_textedit;					# textpane_to_textedit		is from   src/lib/x-kit/widget/edit/textpane-to-textedit.pkg
    package tpt =  textpane_types;						# textpane_types		is from   src/lib/x-kit/widget/edit/textpane-types.pkg
    package mj  =  mode_junk;							# mode_junk			is from   src/lib/x-kit/widget/edit/mode-junk.pkg
    package fm  =  fundamental_mode;						# fundamental_mode		is from   src/lib/x-kit/widget/edit/fundamental-mode.pkg
    package mm  =  minibuffer_mode;						# minibuffer_mode		is from   src/lib/x-kit/widget/edit/minibuffer-mode.pkg
    package tc  =  tab_completion;						# tab_completion		is from   src/lib/x-kit/widget/edit/tab-completion.pkg

    nb =  log::note_on_stderr;							# log				is from   src/lib/std/src/log.pkg

Dummy1 = e2p::Textedit_To_Textpane; 	# XXX SUCKO DELETEME This is just to force compilation during initial development.
Dummy2 = l2p::Screenline_To_Textpane; 	# XXX SUCKO DELETEME This is just to force compilation during initial development.
Dummy4 = b2p::Editboss_To_Textpane; 	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy5 =  le::Redraw_Fn_Arg; 		# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy6 =  tc::Dummy;	 		# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
herein

    package textpane
    :	    Textpane								# Textpane			is from   src/lib/x-kit/widget/edit/textpane.api
    {
	App_To_Textpane
	  =
	  { id:					iuw::Id
	  };


	Redraw_Fn_Arg
	    =
	    REDRAW_FN_ARG
	      {
		id:				iuw::Id,			# Unique Id for widget.
		doc:				String,				# Human-readable description of this widget, for debug and inspection.
		frame_number:			Int,				# 1,2,3,... Purely for convenience of widget, guiboss-imp makes no use of this.
		frame_indent_hint:		gt::Frame_Indent_Hint,
		site:				g2d::Box,			# Window rectangle in which to draw.
		popup_nesting_depth:		Int,				# 0 for gadgets on basewindow, 1 for gadgets on popup on basewindow, 2 for gadgets on popup on popup, etc.
		#
		duration_in_seconds:		Float,				# If state has changed look-imp should call note_changed_gadget_foreground() before this time is up. Also useful for motionblur.
		widget_to_guiboss:		gt::Widget_To_Guiboss,
		gadget_mode:			gt::Gadget_Mode,
		#
		theme:				wt::Widget_Theme,
		do:				(Void -> Void) -> Void,		# Used by widget subthreads to execute code in main widget microthread.
		to:				Replyqueue,			# Used to call 'pass_*' methods in other imps.
		palette:			wt::Gadget_Palette,
		#
		default_redraw_fn:		Redraw_Fn
	      }
	withtype
	Redraw_Fn
	  =
	  Redraw_Fn_Arg
	  ->
	  { displaylist:		gd::Gui_Displaylist,
	    point_in_gadget:		Null_Or(g2d::Point -> Bool)		# 
	  }
	  ;



	Mouse_Click_Fn_Arg
	    =
	    MOUSE_CLICK_FN_ARG							# Needs to be a sumtype because of recursive reference in default_mouse_click_fn.
	      {
		id:				iuw::Id,			# Unique Id for widget.
		doc:				String,				# Human-readable description of this widget, for debug and inspection.
		event:				gt::Mousebutton_Event,		# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE.
		button:				evt::Mousebutton,		# Which mousebutton was pressed/released.
		point:				g2d::Point,			# Where the mouse was.
		widget_layout_hint:		gt::Widget_Layout_Hint,
		frame_indent_hint:		gt::Frame_Indent_Hint,
		site:				g2d::Box,			# Widget's assigned area in window coordinates.
		modifier_keys_state:		evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
		mousebuttons_state:		evt::Mousebuttons_State,	# State of mouse buttons as a bool record.
		widget_to_guiboss:		gt::Widget_To_Guiboss,
		theme:				wt::Widget_Theme,
		do:				(Void -> Void) -> Void,		# Used by widget subthreads to execute code in main widget microthread.
		to:				Replyqueue,			# Used to call 'pass_*' methods in other imps.
		#
		default_mouse_click_fn:		Mouse_Click_Fn,
		#
		needs_redraw_gadget_request:	Void -> Void			# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
	      }
	withtype
	Mouse_Click_Fn = Mouse_Click_Fn_Arg -> Void;



	Mouse_Drag_Fn_Arg
	    =
	    MOUSE_DRAG_FN_ARG
	      {
		id:				iuw::Id,			# Unique Id for widget.
		doc:				String,				# Human-readable description of this widget, for debug and inspection.
		event_point:			g2d::Point,
		start_point:			g2d::Point,
		last_point:			g2d::Point,
		widget_layout_hint:		gt::Widget_Layout_Hint,
		frame_indent_hint:		gt::Frame_Indent_Hint,
		site:				g2d::Box,			# Widget's assigned area in window coordinates.
		phase:				gt::Drag_Phase,	
		button:				evt::Mousebutton,
		modifier_keys_state:	        evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
		mousebuttons_state:		evt::Mousebuttons_State,	# State of mouse buttons as a bool record.
		widget_to_guiboss:		gt::Widget_To_Guiboss,
		theme:				wt::Widget_Theme,
		do:				(Void -> Void) -> Void,		# Used by widget subthreads to execute code in main widget microthread.
		to:				Replyqueue,			# Used to call 'pass_*' methods in other imps.
		#
		default_mouse_drag_fn:		Mouse_Drag_Fn,
		#
		needs_redraw_gadget_request:	Void -> Void			# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
	      }
	withtype
	Mouse_Drag_Fn =  Mouse_Drag_Fn_Arg -> Void;



	Mouse_Transit_Fn_Arg							# Note that buttons are always all up in a mouse-transit event -- otherwise it is a mouse-drag event.
	    =
	    MOUSE_TRANSIT_FN_ARG
	      {
		id:				iuw::Id,			# Unique Id for widget.
		doc:				String,				# Human-readable description of this widget, for debug and inspection.
		event_point:			g2d::Point,
		widget_layout_hint:		gt::Widget_Layout_Hint,
		frame_indent_hint:		gt::Frame_Indent_Hint,
		site:				g2d::Box,			# Widget's assigned area in window coordinates.
		transit:			gt::Gadget_Transit,		# Mouse is entering (CAME) or leaving (LEFT) widget, or moving (MOVE) across it.
		modifier_keys_state:	        evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
		widget_to_guiboss:		gt::Widget_To_Guiboss,
		theme:				wt::Widget_Theme,
		do:				(Void -> Void) -> Void,		# Used by widget subthreads to execute code in main widget microthread.
		to:				Replyqueue,			# Used to call 'pass_*' methods in other imps.
		#
		default_mouse_transit_fn:	Mouse_Transit_Fn,
		#
		needs_redraw_gadget_request:	Void -> Void			# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
	      }
	withtype
	Mouse_Transit_Fn =  Mouse_Transit_Fn_Arg -> Void;



	Key_Event_Fn_Arg
	    =
	    KEY_EVENT_FN_ARG
	      {
		id:				iuw::Id,			# Unique Id for widget.
		doc:				String,				# Human-readable description of this widget, for debug and inspection.
		key_event:			gt::Key_Event,			# KEY_PRESS or KEY_RELEASE
		keycode:			evt::Keycode,			# Keycode of the depressed key.
		keysym:				evt::Keysym,			# Keysym  of the depressed key.  See Note[1] in src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.api
		keystring:			String,				# Ascii  for the depressed key.  See Note[1] in src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.api
		keychar:			Char,				# First char of 'string' ('\0' if string-length != 1).
		event_point:			g2d::Point,
		widget_layout_hint:		gt::Widget_Layout_Hint,
		frame_indent_hint:		gt::Frame_Indent_Hint,
		site:				g2d::Box,			# Widget's assigned area in window coordinates.
		modifier_keys_state:	        evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
		mousebuttons_state:		evt::Mousebuttons_State,	# State of mouse buttons as a bool record.
		widget_to_guiboss:		gt::Widget_To_Guiboss,
		theme:				wt::Widget_Theme,
		do:				(Void -> Void) -> Void,		# Used by widget subthreads to execute code in main widget microthread.
		to:				Replyqueue,			# Used to call 'pass_*' methods in other imps.
		#
		default_key_event_fn:		Key_Event_Fn,
		#
		needs_redraw_gadget_request:	Void -> Void			# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
	      }
	withtype
	Key_Event_Fn =  Key_Event_Fn_Arg -> Void;



	Modeline_Fn_Arg
	    =
	    MODELINE_FN_ARG
	      {
		point:					g2d::Point,		# (0,0)-origin 'point' (==cursor) screen coordinates, in rows and cols (we assume a fixed-width font).  (Remember to display these as (1,1)-origin when printing them out as numbers!)
		mark:				Null_Or(g2d::Point),		# (0,0)-origin 'mark' if set, else NULL.  Same coordinate system as 'point'.
		lastmark:			Null_Or(g2d::Point),		# (0,0)-origin last-valid-value-of-mark if set, else NULL.  We use this in exchange_point_and_mark() when 'mark' is not set -- see   src/lib/x-kit/widget/edit/fundamental-mode.pkg

		dirty:				Bool,				# TRUE iff textbuffer contents have been modified since being loaded from file.
		buffername:			String,				# 
		buffermode:			String
	      }
	withtype
	Modeline_Fn =  Modeline_Fn_Arg -> String;


	Textpane_Hint								# We store these into textbuffer-imp.pkg via Textpane_To_Textbuffer.set_textpane_hint().
	  =									# The point of the exercise is that if we open a different textbuffer in this textpane and then later come back to it, we can position the point+cursor at a reasonable spot instead of just the top of file, and select a reasonable buffermode.
	  { point:			g2d::Point,				# (0,0)-origin 'point' (==cursor) screen coordinates, in rows and cols (we assume a fixed-width font).  (Remember to display these as (1,1)-origin when printing them out as numbers!)
	    mark:			Null_Or(g2d::Point),			# (0,0)-origin 'mark' if set, else NULL.  Same coordinate system as 'point'.
	    lastmark:			Null_Or(g2d::Point),			# (0,0)-origin last-valid-value-of-mark if set, else NULL.  We use this in exchange_point_and_mark() when 'mark' is not set -- see   src/lib/x-kit/widget/edit/fundamental-mode.pkg
	    buffermode:			mj::Buffermode
	  };
	exception TEXTPANE_HINT Textpane_Hint;					# We'll never 'raise' this exception:  It is purely a datastructure to hide the Textpane_Hint datatype from textbuffer-imp.pkg, in the interests of good modularity.


	Option	= ID			iuw::Id
		| DOC			String
		#
		| FRAME_INDENT_HINT	gt::Frame_Indent_Hint
		#
		| UTF8			String					# Initial textbuffer contents.
		#
		| REDRAW_FN		Redraw_Fn				# Application-specific handler for widget redraw.
		| MOUSE_CLICK_FN	Mouse_Click_Fn				# Application-specific handler for mousebutton clicks.
		| MOUSE_DRAG_FN		Mouse_Drag_Fn				# Application-specific handler for mouse drags.
		| MOUSE_TRANSIT_FN	Mouse_Transit_Fn			# Application-specific handler for mouse crossings.
		| KEY_EVENT_FN		Key_Event_Fn				# Application-specific handler for keyboard input.
		#
		| MODELINE_FN		Modeline_Fn				# Application-specific fn to format modeline display.
		#
		| PORTWATCHER		(Null_Or(App_To_Textpane) -> Void)	# Widget's app port                   will be sent to these fns at widget startup.
		| SITEWATCHER		(Null_Or((iuw::Id,g2d::Box)) -> Void)	# Widget's site in window coordinates will be sent to these fns each time it changes.
		;								# To help prevent deadlock, watcher fns should be fast and nonblocking, typically just setting a var or entering something into a mailqueue.
		
	fun process_options
	    ( options: List(Option),
	      #
	      {	widget_id,
		widget_doc,
		#
		frame_indent_hint,
		text,
		#
		redraw_fn,
		mouse_click_fn,
		mouse_drag_fn,
		mouse_transit_fn,
		key_event_fn,
		modeline_fn,
		#
		widget_options,
	        #
		portwatchers,
		sitewatchers
	      }
	    )
	    =
	    {   my_widget_id		=  REF  widget_id;
		my_widget_doc		=  REF  widget_doc;
		#
		my_frame_indent_hint	=  REF  frame_indent_hint;
		my_text			=  REF  text;
		#
		my_redraw_fn		=  REF  redraw_fn;
		my_mouse_click_fn	=  REF  mouse_click_fn;
		my_mouse_drag_fn	=  REF  mouse_drag_fn;
		my_mouse_transit_fn	=  REF  mouse_transit_fn;
		my_key_event_fn		=  REF  key_event_fn;
		my_modeline_fn		=  REF  modeline_fn;
		#
		my_widget_options	=  REF  widget_options;
		#
		my_portwatchers		=  REF  portwatchers;
		my_sitewatchers		=  REF  sitewatchers;
		#

		apply  do_option  options
		where
		    fun do_option (ID				i) =>   my_widget_id		:=  THE i;
			do_option (DOC				d) =>   my_widget_doc		:=      d;
			#
			do_option (FRAME_INDENT_HINT		h) =>   my_frame_indent_hint	:=  THE h;
			do_option (UTF8				h) =>   my_text			:=      h;
			#
			do_option (REDRAW_FN			f) =>   my_redraw_fn		:=      f;
			do_option (MOUSE_CLICK_FN		f) =>   my_mouse_click_fn	:=      f;
			do_option (MOUSE_DRAG_FN		f) =>	my_mouse_drag_fn	:=  THE f;
			do_option (MOUSE_TRANSIT_FN		f) =>	my_mouse_transit_fn	:=  THE f;
			do_option (KEY_EVENT_FN			f) =>	my_key_event_fn		:=  THE f;
			do_option (MODELINE_FN			f) =>	my_modeline_fn		:=      f;
			#
			do_option (PORTWATCHER			c) =>	my_portwatchers		:=  c ! *my_portwatchers;
			do_option (SITEWATCHER			c) =>	my_sitewatchers		:=  c ! *my_sitewatchers;
		    end;
		end;

		{ widget_id		=>  *my_widget_id,
		  widget_doc		=>  *my_widget_doc,
		  #
		  frame_indent_hint	=>  *my_frame_indent_hint,
		  text			=>  *my_text,
		  #
		  redraw_fn		=>  *my_redraw_fn,
		  mouse_click_fn	=>  *my_mouse_click_fn,
		  mouse_drag_fn		=>  *my_mouse_drag_fn,
		  mouse_transit_fn	=>  *my_mouse_transit_fn,
		  key_event_fn		=>  *my_key_event_fn,
		  modeline_fn		=>  *my_modeline_fn,
		  #
		  widget_options	=>  *my_widget_options,
		  #
		  portwatchers		=>  *my_portwatchers,
		  sitewatchers		=>  *my_sitewatchers
		};
	    };


	Panestate													# We have two panes -- our main textpane and the one-line minibuffer pane.  This type encapsulates per-pane state.
	  =
	  { textpane_to_textbuffer:	mj::Textpane_To_Textbuffer,
	    screenlines:		Ref( im::Map( p2l::Textpane_To_Screenline )),					# Indexed by paneline.
	    expected_screenlines:	Ref( Int ),									# So we can tell when ps.screenlines is fully populated (for example).
	    #
	    buffermode:			Ref( mj::Buffermode ),								# Contains mode name and mode keymap.
	    sitewatchers:		Ref( List(  Null_Or((iuw::Id, g2d::Box )) -> Void  )),
	    last_known_site:		Ref (Null_Or( g2d::Box )),
	    #
	    point:			Ref(          g2d::Point   ),							# (0,0)-origin 'point' (==cursor) screen coordinates, in rows and cols (we assume a fixed-width font).  (Remember to display these as (1,1)-origin when printing them out as numbers!)
	    mark:			Ref( Null_Or( g2d::Point ) ),							# (0,0)-origin 'mark' if set, else NULL.  Same coordinate system as 'point'.
	    lastmark:			Ref( Null_Or( g2d::Point ) ),							# (0,0)-origin last-valid-value-of-mark if set, else NULL.  We use this in exchange_point_and_mark() when 'mark' is not set -- see   src/lib/x-kit/widget/edit/fundamental-mode.pkg
	    #
	    screen_origin:		Ref(	      g2d::Point   ),							# Origin of screen relative to textbuffer contents:  (0,0) means we're showing top of buffer at top of textpane.
	    #
	    line_prefix:		Ref( String ),									# Prefix to show at start of each screenline.  Main motivation is to support minibuffer prompts.
	    minibuffer_screenlines:	Null_Or( Ref( im::Map( p2l::Textpane_To_Screenline ) ) )
	  };

	bogus_site
	   =
	   { col => -1,  wide => -1,
	     row => -1,  high => -1
	   }:						g2d::Box;

	fun make_minibuffer (): Panestate
	    =
	    {   buffername = "*minibuffer*";
		#
		textbuffer_options
		    =
		    [ mj::UTF8 "\n" ];

		textbuffer_arg
		  =
		  { buffername, textbuffer_options }:	mj::Textbuffer_Arg;

		egg =  tbi::make_textbuffer_egg  textbuffer_arg;
		#
		(egg ())
		    ->
		    ( textbuffer_exports:	tbi::Exports,
		      egg':		       (tbi::Imports, Run_Gun, End_Gun) -> Void
		    );

		textbuffer_imports
		  =
		  { };

		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		egg' (textbuffer_imports, run_gun', end_gun');

		fire_run_gun ();

		textbuffer_exports -> { textpane_to_textbuffer };

		screenlines = REF (im::empty:  im::Map(p2l::Textpane_To_Screenline));

		buffermode  = REF mm::minibuffer_mode;

		expected_screenlines =	REF 1;

		panestate
		  =
		  { textpane_to_textbuffer,
		    screenlines,
		    expected_screenlines,
		    #
		    buffermode,
		    sitewatchers    =>  REF ([]:    List(  Null_Or((iuw::Id, g2d::Box )) -> Void  )),
		    last_known_site =>  REF NULL,
		    #
		    point	    =>  REF ( g2d::point::zero ),							# Location of visible cursor in textbuffer.  Upperleft origin is { row => 0, col => 0 } (but is displayed to user as L1C1 to conform with standard text-editor practice).  This is in buffer (file) coordinates, not screen coordinates.
		    mark	    =>  REF (NULL:		Null_Or(g2d::Point)),					# Location of the emacs-traditional buffer 'mark'.  If this is non-NULL, the 'mark' and 'point' delimit the current text selection in the buffer.
		    lastmark	    =>  REF (NULL:		Null_Or(g2d::Point)),					# When we set 'mark' field to NULL we save its previous value in 'lastmark' field.  This gets used by exchange_point_and_mark in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
		    #
		    screen_origin   =>	REF( g2d::point::zero ),							# Origin of screen relative to textbuffer contents:  (0,0) means we're showing top of buffer at top of textpane.
		    #
		    line_prefix	    =>  REF "",
		    minibuffer_screenlines => NULL
		  };

		panestate;
	    };



	fun with													# PUBLIC
	      {														# These ids are initially generated and assigned by 'with' in src/lib/x-kit/widget/edit/texteditor.pkg
		textedit_id:		iuw::Id,									# We belong to this instance of src/lib/x-kit/widget/edit/textedit.pkg
		textpane_id:		iuw::Id,									# Our own unique id.
		screenlines_mark:	Id,										# This MARK marks our COL of src/lib/x-kit/widget/edit/screenline.pkg instances in the guipith. This is set up by src/lib/x-kit/widget/edit/texteditor.pkg.

		options:		List(Option)
	      }
	    =
	    {
		fun default_modeline_fn (MODELINE_FN_ARG a)
		    =
		    {
			sprintf "%s   %s   L%d.%d   (%s)"
				(a.dirty ?? "**" :: "  ")
				 a.buffername
				(a.point.row+1)										# '+1's because lines and columns are internally numbered 0->(N-1), but user expects traditional numbering of 1->N.
				(a.point.col+1)
				 a.buffermode
			;
		    };

		#######################################
		# Top of per-imp state variable section
		#

		textpane_to_textedit__global	=  REF (NULL:  Null_Or( p2e::Textpane_To_Textedit   ));
		widget_to_guiboss__global	=  REF (NULL:  Null_Or( { widget_to_guiboss: gt::Widget_To_Guiboss, textpane_id: iuw::Id }));

		font_height__global		=  REF (NULL:  Null_Or( Int			    ));
		modeline_fn__global		=  REF default_modeline_fn;						# Generates string for modeline, typically via sprintf.

		have_keyboard_focus__global	=  REF FALSE;
	
		subkeymap__global											# Normally NULL; Used to implement keys with prefixes by saving current subkeymap in it.
		    =
		    REF (NULL:  Null_Or( mj::Keymap ));


		minibuffer__global =  make_minibuffer ();								# The one-line minibuffer we use to interactively read in in arguments like filenames and search strings.  So far there doesn't seem to be any reason to make this a REF cell.
		mainbuffer__global =  REF (minibuffer__global);								# This is a dummy initial value, overwritten by startup().

		Editfn_Prompting_In_Progress
		  =
		  { promptingfor:	Ref(       mj::Promptfor      ),						# The editfn arg which we're currently prompting user to supply interactively via modeline minibuffer.
		    to_promptfor:	Ref( List( mj::Promptfor    ) ),						# Remaining editfn args to prompt user for once above one is completely read.
		    prompted_for:	Ref( List( mj::Prompted_Arg ) ),						# The editfn args which we've already read from user via modeline minibuffer.
		    stage:		Ref(	   mj::Stage	      ),
		    #
		    editfn_node:	 	   mj::Editfn_Node							# The editfn to call with the above args, once they are all read.
		  };
		prompting__global											# This is normally NULL: we send keystrokes to mainbuffer__global to edit its contents.
		    =													# When this is non-NULL  we send keystrokes to minibuffer__global to edit its contents -- a string being read interactively from user as an argument for an editfn.
		    REF (NULL: Null_Or( Editfn_Prompting_In_Progress ));	

		Keystroke_Entry_State
		  =
		  { meta_is_set:	Ref( Bool ),									# TRUE after ESC has been hit.
		    super_is_set:	Ref( Bool ),									# TRUE between press and release of windows/command key.
		    doing_cntrlu:	Ref( Bool ),									# TRUE after user enters ^U (universal numeric prefix) until user enters something other than ^U or digits 0-9.
		    done_cntrlu:	Ref( Bool ),									# 
		    seen_digit:		Ref( Bool ),
		    numeric_prefix:	Ref( Int  )									# 
		  };
		keystroke_entry__global
		  =
		  { meta_is_set	    => REF FALSE,
		    super_is_set    => REF FALSE,
		    doing_cntrlu    => REF FALSE,
		    done_cntrlu	    => REF FALSE,
		    seen_digit	    => REF FALSE,
		    numeric_prefix  => REF 0
		  };	
		  
		

		#
		# End of state variable section
		###############################



		fun make_screenlines_guipith
		      (
			screenline_count:	Int
		      )
		    =
		    {	screenlines =   make_screenlines  (screenline_count - 1,  [])				# NB: panelines run  0..screenline_count-1.
					where
					    fun make_screenlines (-1, result)
						    =>
						    result;

						make_screenlines (paneline, result_so_far)
						    =>
						    {   screenline
							    =
							    screenline::with
							      {
								paneline,
								textpane_id,
								textedit_id,
								options	    =>  [ le::DOC   (sprintf "Screenline %d"  paneline),
										  le::PIXELS_HIGH_MIN 0,
										  #
										  le::STATE   { text	    =>  sprintf "I am screenline %d"  paneline,
												selected    =>  NULL,
												cursor_at   =>  p2l::NO_CURSOR,
												prompt	    =>  "",
												screencol0  =>  0
											      }
										]
							      };

							make_screenlines  (paneline - 1,  screenline ! result_so_far);
						    };
					    end;
					end;

			gt::XI_GUIPLAN  (gt::COL screenlines);
		    };

		fun maybe_change_number_of_screenlines (ps: Panestate)
		    =
		    {   # We depend upon the state variables
			#
			#     last_known_site
			#     font_height__global
			#     widget_to_guiboss__global
			#
			# so it is critically important that we
			# be called whenever any of those changes.
			#
			# For now we're ensuring that via ad hoc
			# coding.  Eventually it would be nice to
			# have some methodology like CHR.						# CHR == Constraint Handling Rules, see https://dtai.cs.kuleuven.be/CHR/biblio.shtml  e.g. http://arxiv.org/abs/1406.2121
			#
			case (*font_height__global,  *ps.last_known_site,  *widget_to_guiboss__global)
			    #
			    (THE font_height, THE site, THE { widget_to_guiboss, textpane_id })
				=>
				{   # Decide how many screenlines will fit comfortably.
				    #
				    frame_pixels	 = 10;		# XXX SUCKO FIXME  We must have the actual number somewhere.
				    pixels_between_lines =  2;

				    number_of_modelines = 1;

				    reasonable_line_count
					=
					(site.high - frame_pixels) / (font_height + pixels_between_lines);

				    reasonable_screenline_count
					=
					reasonable_line_count - number_of_modelines;

				    if (reasonable_screenline_count != *ps.expected_screenlines)
					#
					screenlines_guipith_subtree
					    =
					    make_screenlines_guipith  reasonable_screenline_count;

					full_guipith_tree
					    =
					    widget_to_guiboss.g.get_guipiths ();

					revised_full_guipith_tree
					    =
					    gtj::guipith_map  (full_guipith_tree,  [ gtj::XI_MARK_MAP_FN do_mark ])
						where
						    fun do_mark (xi_mark:	gt::Xi_Mark)
							=
							if (same_id (xi_mark.id, screenlines_mark))
							    #
							    xi_mark ->    { id:		Id, 
									    doc:	String,
									    widget:	gt::Xi_Widget_Type
									  };
							    xi_mark =	  { id,
									    doc,
									    widget =>	screenlines_guipith_subtree
									  };
							    xi_mark;
							else
							    xi_mark;
							fi;
						end;

					widget_to_guiboss.g.install_updated_guipiths
					    #
					    revised_full_guipith_tree;

					ps.expected_screenlines := reasonable_screenline_count;
				    fi;

				};

			    _ =>
				{								# Insufficient information to reconfigure screenlines so doing nothing.  (Eventually all required information will arrive.)
				};	
			esac;
		    };


		fun refresh_screenlines  (ps:  Panestate)					# Update screenline instances to reflect textbuffer contents.
		    =										# "ps" == "panestate".
		    {   ps.textpane_to_textbuffer
			    ->
			    mj::TEXTPANE_TO_TEXTBUFFER tb;					# "tb" == "textbuffer".

			ts  = tb.get_textstate ();						# "ts" == "textstate".
			#
			ts -> { textlines:	mj::Textlines,					# Complete text contents of textbuffer.
				editcount:	Int						# Count of edits applied.  Intended to allow clients to quickly detect whether any changes have been made since they last polled us.
			      };								# By pro-actively fetching the entire textbuffer state we not only save inter-imp round trips, but more importantly guarantee that we do the complete redisplay on a single self-consistent state.

			point  =  *ps.point;
			mark   =  *ps.mark;

			screen_origin	=  *ps.screen_origin;

			apply do_line (0 .. (*ps.expected_screenlines - 1))
			    where
				fun do_line (screen_line: Int)
				    =
				    {
					case (im::get (*ps.screenlines, screen_line))
					    #
					    THE textpane_to_screenline
						=>
						{   line_key = screen_line + screen_origin.row;		# Figure out which textlines entry should be displayed in this screenline.    NB: Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).
						    #
						    line =  case (nl::find (textlines, line_key))
								#
								THE line => line;
								NULL	 => "\n";
							    esac;

						    line_number = screen_line + screen_origin.row;

						    my (selected, cursor_at)															# Figure out what part (if any) of line is part of the selected region, and if so which end (if either) the cursor is at.
							=
							case mark
							    #
							    THE mark
								=>
								if   (mark.row <  line_number  and  line_number <  point.row)	(THE (0, NULL),			p2l::NO_CURSOR		);	# Marked region starts before line and ends after it -- select entire line.
								elif (mark.row >  line_number  and  line_number >  point.row)	(THE (0, NULL),			p2l::NO_CURSOR		);	# Marked region starts before line and ends after it -- select entire line.
								#
								elif (mark.row <  line_number  and  line_number >  point.row)	(NULL,				p2l::NO_CURSOR		);	# Marked region is entirely before line -- select nothing.
								elif (mark.row >  line_number  and  line_number <  point.row)	(NULL,				p2l::NO_CURSOR		);	# Marked region is entirely after  line -- select nothing.
								#
								elif (mark.row <  line_number  and  line_number == point.row)   (THE (0, THE point.col),	p2l::CURSOR_AT_END	);	# Marked region starts before line and ends on it -- select leading part of line.
								elif (mark.row == line_number  and  line_number >  point.row)   (THE (0, THE mark.col ),	p2l::NO_CURSOR		);	# Marked region starts before line and ends on it -- select leading part of line.
								#
								elif (mark.row >  line_number  and  line_number == point.row)   (THE (point.col, NULL),		p2l::CURSOR_AT_START	);	# Marked region starts on line and ends after it -- select trailing part of line.
								elif (mark.row == line_number  and  line_number <  point.row)   (THE (mark.col,  NULL),		p2l::NO_CURSOR		);	# Marked region starts on line and ends after it -- select trailing part of line.
								#
								elif (mark.col < point.col)					(THE (mark.col,  THE point.col),p2l::CURSOR_AT_END	);	# Marked region starts and ends on line -- select middle part of line.
								else 								(THE (point.col, THE mark.col ),p2l::CURSOR_AT_START	);	# Marked region starts and ends on line -- select middle part of line.
								fi;

							    NULL =>																# No mark set.
								if (point.row == line_number)					(THE (point.col, THE point.col),p2l::CURSOR_AT_END	);	# Display the cursor by itself.
								else								(NULL,				p2l::NO_CURSOR		);	# Nothing to display in reverse video on this line.
								fi;
							esac;

						    linestate
						      =
						      { cursor_at,
							selected,
							text	    =>  string::chomp line,	# Chomp it because screenline.pkg doesn't want the terminating newline (if any).
							prompt	    => *ps.line_prefix,
							screencol0  =>  screen_origin.col
						      };	

						    textpane_to_screenline.set_state_to  linestate;
						};

					    NULL =>						# Ignore this line because the relevant screenline.pkg instance has not yet registered with us (via editboss.pkg).
						{
						};
					esac;
				    };
			    end;


			case (*prompting__global, ps.minibuffer_screenlines)			# Update modeline display appropriately, unless the minibuffer is active (which preempts the modeline screenline to display itself) or unless we *are* minibuffer.
			    #
			    (NULL, THE (REF minibuffer_screenlines))				# *prompting__global==NULL so minibuffer is not active and we can go ahead and update the modeline, which displays on the same screenline as the minibuffer.
				=>
				case (im::get (minibuffer_screenlines, 0))			# We expect a single screenline, stored under key 0 (but internally marked as paneline -1).
				    #
				    THE textpane_to_screenline
					=>
					{   ps.textpane_to_textbuffer				# Note that we're writing info *about* the main textpane *to* the modeline textpane.
						->
						mj::TEXTPANE_TO_TEXTBUFFER tb;
					    #
					    modeline_fn_arg
						=
						MODELINE_FN_ARG
						  {
						    point	=>  *ps.point,
						    mark	=>  *ps.mark,
						    lastmark	=>  *ps.lastmark,
						    #
						    dirty	=>   tb.get_dirty (),
						    buffername	=>   tb.get_buffername (),
						    buffermode
						  }
						where
						    (*ps.buffermode)
							->
							mj::BUFFERMODE { name => buffermode, ... };
						end;

					    modeline_fn   =  *modeline_fn__global;

					    modeline_text =  modeline_fn  modeline_fn_arg;

					    modeline_state
					      =
					      { cursor_at   =>  p2l::NO_CURSOR,
						selected    =>  NULL,
						text	    =>  modeline_text,
						prompt	    =>  "",
						screencol0  =>  0
					      };	

					    textpane_to_screenline.set_state_to  modeline_state;
					};

				    NULL => ();							# This case can happen if we haven't gotten our screenline notification yet.
				esac;

			    _ => ();								# Skip modeline update -- either the minibuffer is active or we *are* the minibuffer.
			esac;
		    };


		fun needs_redraw_gadget_request ()
		    =
		    case (*widget_to_guiboss__global)
			#
			THE { widget_to_guiboss, textpane_id }	=>  widget_to_guiboss.g.needs_redraw_gadget_request(textpane_id);
			NULL					=>  ();
		    esac;

		fun note_site
		      (
			id:		iuw::Id,
			site:		g2d::Box
		      )
		    =
		    {   ps  =  *mainbuffer__global;
			#
			if(*ps.last_known_site != THE site)
			    ps.last_known_site := THE site;

			    maybe_change_number_of_screenlines ps;

			    apply  tell_watcher  *ps.sitewatchers
				where
				    fun tell_watcher sitewatcher
					=
					sitewatcher (THE (id,site));
				end;
			fi;
		    };	

		fun default_redraw_fn (REDRAW_FN_ARG a)
		    =
		    {	font_size		=  NULL;
			font_weight		=  (THE wt::BOLD_FONT: Null_Or(wt::Font_Weight));
			fonts			=  [];

			id			=  a.id;
			palette			=  a.palette;
			frame_indent_hint	=  a.frame_indent_hint;
			site			=  a.site;
			theme			=  a.theme;

			note_site (id, site);

			fun get_fontnames ()
			    =
			    {   font_size_to_use
				    =
				    case font_size	THE i => i;
							NULL  => *theme.default_font_size;
				    esac;

				fontname_to_use
				    =
				    case font_weight  THE wt::ROMAN_FONT  =>  *theme.get_roman_fontname  font_size_to_use;
						      THE wt::ITALIC_FONT =>  *theme.get_italic_fontname font_size_to_use;
						      THE wt::BOLD_FONT   =>  *theme.get_bold_fontname   font_size_to_use;
						      NULL                =>  *theme.get_roman_fontname  font_size_to_use;
				    esac;

				fontnames =  fonts  @  [ fontname_to_use, "9x15" ];

				fontnames;
			    };

			fun get_text_dimensions (text: String)
			    =
			    {   g =  wti::get__guiboss_to_topwindow  theme;
				#
				font = g.get_font (get_fontnames ());

				font_height__global
				    :=
				    THE (font.font_height.ascent + font.font_height.descent);

				ps  =  *mainbuffer__global;

				maybe_change_number_of_screenlines ps;

				{ font_ascent      =>  font.font_height.ascent,
				  font_descent     =>  font.font_height.descent,
				  length_in_pixels =>  font.string_length_in_pixels text					# Currently this seems to return results 2X too large for multibyte utf8 chars.
				};
			    };

# Currently just for side-effect:
get_text_dimensions "foo";

			frame_indent_hint
			  ->
			  { pixels_for_top_of_frame:	Int,									# Vertical   pixels to allocate for top    side of frame.
			    pixels_for_bottom_of_frame:	Int,									# Vertical   pixels to allocate for bottom side of frame.
			    #
			    pixels_for_left_of_frame:	Int,									# Horizontal pixels to allocate for left   side of frame.
			    pixels_for_right_of_frame:	Int									# Horizontal pixels to allocate for right  side of frame.
			  };
			  
			if (pixels_for_top_of_frame == pixels_for_bottom_of_frame
			and pixels_for_top_of_frame == pixels_for_left_of_frame
			and pixels_for_top_of_frame == pixels_for_right_of_frame
			and pixels_for_top_of_frame >  8)
			    #
			    # This branch of the 'if' is basically Compatibility Mode:
			    # it is what we used to do when frame.pkg was hardwired to
			    # always draw a frame 9 pixels thick on every side:

			    relief			=  wt::RIDGE;
			    thick			=  5;

			    stipulate												# then carefully work through the code here based on that.  XXX SUCKO FIXME.
				inset = 6;
			    herein
				fun frame_vertices ({ row, col, wide, high }: g2d::Box)						#
					= 												#
					[ { col=> col + inset - 1,        row=> row + inset		   },				# upper-left
					  { col=> col + inset - 1,        row=> row + high - (inset+1) },				# lower-left
					  { col=> col + wide - (inset+1), row=> row + high - (inset+1) },				# lower-right
					  { col=> col + wide - (inset+1), row=> row + inset		   }				# upper-right
					];
			    end;

			    background_box =  site;

			    foreground_indent = 9;

			    foreground_box    =  g2d::box::make_nested_box (background_box, foreground_indent);			# This is the window area reserved for the widgets we're framing.

			    background_displaylist 											# The 'background' for the frame is the part not covered by the 3d polygon.
				=													# In particular, we do NOT want to draw over the inner rectangle reserved
				[ gd::COLOR												# for the widgets within the frame.
				    (
				      palette.surround_color,
				      #
				      [ gd::FILLED_BOXES (g2d::box::subtract_box_b_from_box_a
							   {
							     a => background_box,
							     b => foreground_box
							   }
							 )
				      ]
				    )
				];

			    points =  frame_vertices  background_box;

			    foreground_displaylist
				=
				(*theme.polygon3d  palette
				  {
				    points,
				    thick,
				    relief
				  }
				);


			    stipulate
				frame_outer_limit =  g2d::box::make_nested_box (background_box, 3 );
				frame_inner_limit =  g2d::box::make_nested_box (background_box, 6 );
			    herein
				fun point_in_gadget (point: g2d::Point)								# A fn which will return TRUE iff the point is on the 3d frame itself, not the surround -- much less the inner widgets.
				    =
				    (    (g2d::box::point_in_box (point, frame_outer_limit)))  and
				    (not (g2d::box::point_in_box (point, frame_inner_limit)));
			    end;

			    point_in_gadget =  THE  point_in_gadget;
			    displaylist     =  background_displaylist @ foreground_displaylist;

			    { displaylist, point_in_gadget };

			else
			    # This branch of the 'if' handles all the frame_indent_hint
			    # cases that the original code really wasn't set up to handle:
			    #
			    if (pixels_for_top_of_frame    == 0
			    and pixels_for_bottom_of_frame == 0
			    and pixels_for_left_of_frame   == 0
			    and pixels_for_right_of_frame  == 0)

				fun point_in_gadget (point: g2d::Point)								# A fn which will return TRUE iff the point is on the frame itself -- not on inner widgets.
				    =
				    FALSE;

				point_in_gadget =  THE  point_in_gadget;
				displaylist     =  [ gd::FILLED_BOXES [] ];

				{ displaylist, point_in_gadget };
			    else
				background_box =  site;
				foreground_box =  gtj::make_nested_box (background_box, frame_indent_hint);				# This is the window area reserved for the widgets we're framing.

				background_displaylist 											# The 'background' for the frame is the part not covered by the 3d polygon.
				    =													# In particular, we do NOT want to draw over the inner rectangle reserved
				    [ gd::COLOR												# for the widgets within the frame.
					(
					  palette.surround_color,
					  #
					  [ gd::FILLED_BOXES (g2d::box::subtract_box_b_from_box_a
							       {
								 a => background_box,
								 b => foreground_box
							       }
							     )
					  ]
					)
				    ];

				foreground_displaylist
				  =
				  [ gd::COLOR
				      (
					a.palette.text_color,
					[ gd::BOXES [ foreground_box, background_box ] ]
				      )
				  ];

				fun point_in_gadget (point: g2d::Point)								# A fn which will return TRUE iff the point is on the frame itself -- not on inner widgets.
				    =
				    (    (g2d::box::point_in_box (point, background_box)))  and
				    (not (g2d::box::point_in_box (point, foreground_box)));

				point_in_gadget =  THE  point_in_gadget;
				displaylist     =  background_displaylist @ foreground_displaylist;

				{ displaylist, point_in_gadget };
			    fi;
			fi;


		    };

		fun default_mouse_click_fn (MOUSE_CLICK_FN_ARG a)
		    =
		    {
			();
		    };

	        (process_options
		  (
		    options,
		    #
		    { widget_id		=>  THE textpane_id,
		      widget_doc	=>  "<textpane>",
		      #	
		      frame_indent_hint	=>  NULL,
		      text		=>  "",
		      #	
		      redraw_fn		=>  default_redraw_fn,
		      mouse_click_fn	=>  default_mouse_click_fn,
		      mouse_drag_fn	=>  NULL,
		      mouse_transit_fn	=>  NULL,
		      key_event_fn	=>  NULL,
		      modeline_fn	=> *modeline_fn__global,
		      #
		      widget_options	=>  [],
		      #
		      portwatchers	=>  [],
		      sitewatchers	=>  []
		    }
		) )
		    ->
		    {												# These values are globally visible to the subsequenc fns, which can lock them in as needed.
		      widget_id,
		      widget_doc,
		      #
		      frame_indent_hint,
		      text,
		      #
		      redraw_fn,
		      mouse_click_fn,
		      mouse_drag_fn,
		      mouse_transit_fn,
		      key_event_fn,
		      modeline_fn,
		      #
		      widget_options,
		      #
		      portwatchers,
		      sitewatchers
		    };

#		sitewatchers_global	:= sitewatchers;
		modeline_fn__global	:= modeline_fn;



		#####################
		# Top of port section
		#
		# Here we implement our App_To_Textpane port:

		#
		# End of port section
		#####################


		###############################
		# Top of widget hook fn section
		#
		# These fns get called by widget_imp logic, ultimately						# widget_imp		is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
		# in response to user mouseclicks and keypresses etc:

		fun startup_fn
		    { 
		      id:				iuw::Id,						# Unique Id for widget.
		      doc:				String,							# Human-readable description of this widget, for debug and inspection.
		      widget_to_guiboss:		gt::Widget_To_Guiboss,
		      do:				(Void -> Void) -> Void,					# Used by widget subthreads to execute code in main widget microthread.
		      to:				Replyqueue
		    }
		    =
		    {	widget_to_guiboss__global
			    :=  
			    THE { widget_to_guiboss, textpane_id => id };

			app_to_textpane
			  =
			  { id
			  }
			  : App_To_Textpane
			  ;

			(mj::find__gadget_to_editboss  (widget_to_guiboss.g,  "textpane::startup_fn"))		# Find our port to src/lib/x-kit/widget/edit/editboss-imp.pkg
			    ->
			    mj::GADGET_TO_EDITBOSS eb;


			mainbuffer__global
			    :=
			    { textpane_to_textbuffer,
			      expected_screenlines => REF 1,
			      #
			      screenlines     =>  REF (im::empty:  im::Map(p2l::Textpane_To_Screenline)),
			      #
			      buffermode      =>  REF fm::fundamental_mode,
			      sitewatchers    =>  REF sitewatchers,
			      last_known_site =>  REF NULL,
			      #
			      point	      =>  REF ( g2d::point::zero ),					# Location of visible cursor in textbuffer.  Upperleft origin is { row => 0, col => 0 } (but is displayed to user as L1C1 to conform with standard text-editor practice).  This is in buffer (file) coordinates, not screen coordinates.
			      mark	      =>  REF (NULL:			 Null_Or(g2d::Point)),		# Location of the emacs-traditional buffer 'mark'.  If this is non-NULL, the 'mark' and 'point' delimit the current text selection in the buffer.
			      lastmark	      =>  REF (NULL:			 Null_Or(g2d::Point)),		# When we set mark__global to NULL we save its previous value in lastmark__global.  This gets used by exchange_point_and_mark in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
			      #
			      screen_origin   =>  REF( g2d::point::zero ),					# Origin of screen relative to textbuffer contents:  (0,0) means we're showing top of buffer at top of textpane.
			      #	
			      line_prefix	     =>  REF "",
			      minibuffer_screenlines =>  THE minibuffer__global.screenlines			# Note that we're sharing the minibuffer__global.screenlines refcell here.
			    }
			    where
				textpane_to_textbuffer
				    =
				    eb.get_or_make_textbuffer
					#
					{ buffername	     =>  "mybuffer",
					  textbuffer_options =>	 [ mj::UTF8 text ]
					};
			    end;	

			maybe_change_number_of_screenlines *mainbuffer__global;

			eb.note_textpane
			  (
			    editboss_to_textpane:			b2p::Editboss_To_Textpane,
			    textedit_to_textpane:			e2p::Textedit_To_Textpane,
			    screenline_to_textpane:			l2p::Screenline_To_Textpane
			  )
			    where
				fun note__textpane_to_textedit
				      (
					textpane_to_textedit:   	p2e::Textpane_To_Textedit
				      )
				    =
				    do {.									# The 'do' switches us from executing in microthread of screenline caller to our own textpane microthread -- ensuring proper mutual exclusion while updating our state.
					textpane_to_textedit__global   := THE textpane_to_textedit;
				    };

				fun note__textpane_to_screenline
				      (
					textpane_to_screenline:		p2l::Textpane_To_Screenline
				      )
				    =
				    do {.									# The 'do' switches us from executing in microthread of screenline caller to our own textpane microthread -- ensuring proper mutual exclusion while updating our state.
					if (textpane_to_screenline.paneline != -1)				# This '-1' kludge to distinguish the minibuffer/modeline screenline is pretty ugly.  Feel free to dream up something nicer.
					    #
					    ps  =  *mainbuffer__global;						# Normal case -- we're registering a screenline in the main textpane.
					    #
					    ps.screenlines
						:=
						im::set   (*ps.screenlines,
							    textpane_to_screenline.paneline,
							    textpane_to_screenline
							  );

					    refresh_screenlines ps;
					else
					    ps  =  minibuffer__global;						# We're registering the screenline for the minibuffer/modeline textpane.
					    #
					    ps.screenlines
						:=
						im::set   (*ps.screenlines,
							    0,							# Ignore the bogus '-1' paneline value, so as to have the screenlines numbering be 0-based as usual.
							    textpane_to_screenline
							  );
					fi;
				    };



				Editfn_Out									# mj::Editfn_Out in a more convenient form.
				  =
				  { textlines_changed:	Bool,		textlines:	mj::Textlines,
				    point_changed:	Bool,		point:		g2d::Point,
				    mark_changed:	Bool,		mark:		Null_Or(g2d::Point),
				    lastmark_changed:	Bool,		lastmark:	Null_Or(g2d::Point),
				    textbuffer_changed:	Bool,		textbuffer:	Null_Or( mj::Textpane_To_Textbuffer ),
				    done:		Bool,		quit:		Bool,
				    editfn_failed:	Bool,		save:		Bool
				  };

				fun parse_editfn_out (editfn_out: mj::Editfn_Out)
				    =
				    {   ps  =  *mainbuffer__global;
					#
					r = { textlines_changed  => FALSE,	textlines =>  nl::empty,
					      point_changed	 => FALSE,	point	  => *ps.point,
					      mark_changed	 => FALSE,	mark	  => *ps.mark,
					      lastmark_changed	 => FALSE,	lastmark  => *ps.lastmark,
					      textbuffer_changed => FALSE,	textbuffer=>  NULL,
					      done		 => FALSE,	quit	  => FALSE,
					      editfn_failed	 => TRUE,	save	  => FALSE
					    };

					case editfn_out
					    #
					    NULL        =>  r;
					    THE options =>  process_options (options, r);
					esac;
				    }
				    where
					fun process_options
					      (	
						options:	List(mj::Editfn_Out_Option),
						r:		Editfn_Out
					      )	
					    =
					    {   my_textlines		= REF r.textlines;
						my_textlines_changed	= REF r.textlines_changed;
						#
						my_point		= REF r.point;
						my_point_changed	= REF r.point_changed;
						#
						my_mark			= REF r.mark;
						my_mark_changed		= REF r.mark_changed;
						#
						my_lastmark		= REF r.lastmark;
						my_lastmark_changed	= REF r.lastmark_changed;
						#
						my_textbuffer		= REF r.textbuffer;
						my_textbuffer_changed	= REF r.textbuffer_changed;
						#
						my_quit			= REF r.quit;
						my_done			= REF r.done;
						my_save			= REF r.save;

						apply do_option options
						where
						    fun do_option (mj::TEXTLINES textlines) =>	{ my_textlines  := textlines;	my_textlines_changed  := TRUE;	};
							do_option (mj::POINT     point    ) =>	{ my_point      := point;	my_point_changed      := TRUE;	};
							do_option (mj::MARK      mark	  ) =>	{ my_mark       := mark;	my_mark_changed       := TRUE;	};
							do_option (mj::LASTMARK  lastmark ) =>	{ my_lastmark   := lastmark;	my_lastmark_changed   := TRUE;	};
							do_option (mj::TEXTBUFFER       tb) =>  { my_textbuffer := THE tb;	my_textbuffer_changed := TRUE;	};
							do_option (mj::QUIT		  ) =>  { my_quit       := TRUE;					};
							do_option (mj::DONE		  ) =>  { my_done       := TRUE;					};
							do_option (mj::SAVE		  ) =>  { my_save       := TRUE;					};
						    end;	
						end;

						{ textlines		=> *my_textlines,
						  textlines_changed	=> *my_textlines_changed,
						  #
						  point			=> *my_point,
						  point_changed		=> *my_point_changed,
						  #
						  mark			=> *my_mark,
						  mark_changed		=> *my_mark_changed,

						  lastmark		=> *my_lastmark,
						  lastmark_changed	=> *my_lastmark_changed,

						  textbuffer		=> *my_textbuffer,
						  textbuffer_changed	=> *my_textbuffer_changed,

						  quit			=> *my_quit,
						  done			=> *my_done,
						  save			=> *my_save,

						  editfn_failed		=> FALSE
						};
					    };
				    end;


				fun set_up_to_read_interactive_arg_from_minibuffer
				      (
					editfn_node:		mj::Editfn_Node,
					this_arg:		mj::Promptfor,
					remaining_args:	  List(	mj::Promptfor ),
					read_so_far:	  List( mj::Prompted_Arg )
				      )
				    =
				    {
					my (prompt, minibuffer_seed, incremental)						# Prompt to display (uneditable) and initial minibuffer contents (editable).
					    =
					    case this_arg
						#
						mj::STRING { prompt, doc }
						    =>
						    (prompt, "", FALSE);

						mj::FILENAME { prompt, doc }
						    =>
						    {	cwd = psx::current_directory ();					# Returns something like  "/mythryl7/mythryl7.110.58/mythryl7.110.58".
							#
							(prompt, cwd + "/", FALSE);
						    };

						mj::INCREMENTAL_STRING { prompt, doc }
						    =>
						    (prompt, "", TRUE);
					    esac;

					mb = minibuffer__global;

					mb.line_prefix	:=  prompt + ":  ";

					mb.point										# Set minibuffer cursor at end of text seeded into minibuffer.
					  :=
					  {
					    row =>  0,
					    col =>  string::length_in_chars  minibuffer_seed
					  };

					mb.textpane_to_textbuffer
					    ->
					    mj::TEXTPANE_TO_TEXTBUFFER tb;

					tb.set_lines
					  [
					    minibuffer_seed
					  ];

					editfn_prompting_in_progress
					  =
					  { promptingfor =>  REF  this_arg,
					    to_promptfor =>  REF  remaining_args,
					    prompted_for =>  REF  read_so_far,
					    stage	 =>  REF  mj::INITIAL,
					    editfn_node
					  };

					prompting__global
					    :=
					    THE editfn_prompting_in_progress;

					refresh_screenlines mb;
				    };


				fun do_edit											# Main fn to invoke an editfn in (e.g.) fundamental-mode.pkg once the keystrokes invoking it are processed and the corresponding editfn located.
				      (
					editfn_node:	mj::Editfn_Node,
					keystring:	String,									# User keystroke that invoked this editfn.
					ps:		Panestate,
					prompted_args:	List( mj::Prompted_Arg ),
					numeric_prefix:	Null_Or(Int)
				      )
				    =
				    {   ps.textpane_to_textbuffer
					    ->
					    mj::TEXTPANE_TO_TEXTBUFFER  tb;
					#
					point_and_mark  = { point => *ps.point,
							    mark  => *ps.mark
							  };
					lastmark	= *ps.lastmark;
					log_undo_info   = FALSE;

					editfn_in =   { editfn_node,
							prompted_args,
							point_and_mark,
							lastmark,
							widget_to_guiboss,
							log_undo_info,
							keystring,
							numeric_prefix
						      };

					tb.pass_edit_result  editfn_in								# NB:  Here we do the actual edit in the textbuffer microthread to guarantee proper mutual exclusion of concurrent edits on the textfuffer.
					    to											#      Also, any edits to the textlines in the textbuffer will come back to us via our statewatcher subscription.
					    {.  (parse_editfn_out #editfn_out)
						    ->
						    { textlines_changed,  textlines, 
						      point_changed,      point,	 
						      mark_changed,       mark,
						      lastmark_changed,   lastmark,
						      textbuffer_changed, textbuffer, 	
						      #	
						      done,		  quit,
						      editfn_failed,	  save
						    };

						if editfn_failed								# Editfn was not able to run to completion.
						    #
						    # Should beep here, but not sure how to do that yet.	XXX SUCKO FIXME.
						    ();
						else

						    if point_changed
							#
							point -> { row, col };							# First, normalize the editfn-generated 'point' value to be sane:
																#
							row = max (0, row);							# Don't allow negative line   numbers.
							col = max (0, col);							# Don't allow negative column numbers.
																#
							point =  { row, col };							#

																# Now, if 'point' has moved out of view, scroll textpane contents to make it visible again/
																#
							screen_row0 = (*ps.screen_origin).row;					# What is the first file line visible in the textpane?

							screenlines   = *ps.expected_screenlines;				# Number of lines displayable in textpane.
							screenlines2  = screenlines / 2;					# Useful for centering cursor line within textpane.

							if (row <  screen_row0							# If the cursor line is out of sight above textpane window or
							or  row >= screen_row0 + screenlines)					# if the cursor line is out of sight below textpane window
							    #									# then we need to change ps.screen_origin so cursor line is visible.
							    #
							    screen_row0'  = row - screenlines2;					# When possible we like to leave cursor line in middle of textpane.
							    screen_row0'  = max (0, screen_row0');				# But do not let (*ps.screen_origin).row go negative.
							    #
							    ps.screen_origin :=   { row =>  screen_row0',
										    col =>  (*ps.screen_origin).col
										  };
							fi;

							ps.point := point;
						    fi;

						    if mark_changed
							#
							if (mark == NULL)
							    ps.lastmark := *ps.mark;						# Save mark__global contents for possible use by   exchange_point_and_mark()	in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
							fi;

							ps.mark := mark;
						    fi;

						    if lastmark_changed
							#
							ps.lastmark := lastmark;
						    fi;

						    if quit									# Implement keyboard_quit (usually bound to C-g) functionality.  This basically means "cancel everything currently happening".
							#
							keystroke_entry__global.meta_is_set    := FALSE;			# Reset keystroke entry.  (Although they should all be reset already...)
							keystroke_entry__global.super_is_set   := FALSE;
							keystroke_entry__global.doing_cntrlu   := FALSE;
							keystroke_entry__global.done_cntrlu    := FALSE;
							keystroke_entry__global.seen_digit     := FALSE;
							keystroke_entry__global.numeric_prefix := 0;

							ps  =  *mainbuffer__global;						# Return attention to mainbuffer if it was on minibuffer.

							ps.mark	    := NULL;							# Clear region if a selection is in progress.  We leave *ps.lastmark unchanged on the grounds that 'quit' should change as little state as reasonable.

							prompting__global := NULL;						# If we're reading stuff from the minibuffer, cancel that.

							refresh_screenlines  *mainbuffer__global;				# Refresh main textpane -- this will redraw the modeline screenline, clearing any minibuffer entry which was in progress.
						    fi;

						    if done									# Done prompting interactively for a string value (e.g., filename for find_file).
							#
							minibuffer__global.textpane_to_textbuffer				# Extract textbuffer port from its wrapper.
							    ->
							    mj::TEXTPANE_TO_TEXTBUFFER tb;

							string_arg								# Extract filepath from minibuffer.
							    =
							    case (tb.get_line 0)
								#
								THE filepath => filepath;
								NULL	     =>	"foo";						# Shouldn't happen.
							    esac;

							case *prompting__global							# Prompt for next arg, if any, else invoke editfn with accumulated args.
							    #
							    THE p =>
								{   p.prompted_for						# Salt away arg just read via minibuffer.
									:=
									(mj::STRING_ARG string_arg)
									!
									*p.prompted_for;

								    case *p.to_promptfor
									#
									[] =>							# No more args to prompt for -- time to pass accumulated prompted args to the editfn.
									    {   prompting__global := NULL;			# Clear interactive-prompt state, returning us to normal textedit mode in main textpane (vs minibuffer).
										#
										refresh_screenlines  *mainbuffer__global;	# Refresh main textpane -- this will redraw the modeline screenline, which currently contains the minibuffer display used to read our string.

										prompted_args =  reverse  *p.prompted_for;

										do_edit ( p.editfn_node,
											  keystring,
											  ps,
											  prompted_args,
											  numeric_prefix
											);
									    };

									this_arg ! remaining_args				# At least one more arg to read -- set up to read it interactively from user.
									    =>
									    set_up_to_read_interactive_arg_from_minibuffer
									      (
										p.editfn_node,
										this_arg,
										remaining_args,
										*p.prompted_for
									      );
								    esac;
								};
							    NULL => ();								# We're not expecting this to happen -- 'done' should only be set if we're reading prompted args from user by setting *prompting__global non-NULL.
							esac;

							refresh_screenlines  *mainbuffer__global;				# Refresh main textpane -- this will redraw the modeline screenline, which currently contains the minibuffer display used to read our string.
						    else

							if (mark_changed							# NB: Changing lastmark will have no visible effect on screenline display.
							or  point_changed
							or  textlines_changed
							or  textbuffer_changed)
							    #
							    refresh_screenlines ps;
							fi;
						    fi;

						    case textbuffer								# If we've been switched to display a different textbuffer/file, handle that.
							#
							THE textpane_to_textbuffer =>						# Editfn did indeed switch us to a different textbuffer.
							    {
								tb = *mainbuffer__global;
								#
								mainbuffer__global						# Remember the new textbuffer we're now displaying.
								  := 
								  { textpane_to_textbuffer,
								    screenlines		=>  tb.screenlines,			# We still have the same screen real estate in which to display.
								    expected_screenlines=>  tb.expected_screenlines,		# "							      ".
								    last_known_site	=>  tb.last_known_site,			# "							      ".
								    minibuffer_screenlines	=>  tb.minibuffer_screenlines,	# "							      ".
								    #
# XXX SUCKO FIXME At some point we need to pick filemodes intelligently based on file extension (presumably).
								    buffermode		=>  REF fm::fundamental_mode,
								    sitewatchers	=>  tb.sitewatchers,			# We still have the same set of clients watching us for state changes.
								    #
								    point		=>  REF ({ row => 0, col => 0 }),	# This is a newly loaded file so set cursor to topleft origin.
								    mark		=>  REF NULL,				# No mark set in this new file.
								    lastmark		=>  REF NULL,				# 
								    #
								    screen_origin	=>  REF( g2d::point::zero ),		# Origin of screen relative to textbuffer contents:  (0,0) means we're showing top of buffer at top of textpane.
								    #
								    line_prefix		=>  REF ""
								  };

								refresh_screenlines  *mainbuffer__global;			# Refresh main textpane -- this will redraw the modeline screenline, which currently contains the minibuffer display used to read our string, and also the main textpane, to show the new file.

								();
							    };

							NULL => ();								# Editfn did NOT switch us to a different textbuffer/file, so nothing to do here.
						    esac;

						fi;										# editfn_failed 'else' clause.


						if (ps.minibuffer_screenlines != NULL)						# If we're not in the minibuffer...          [ Yes, we should have a cleaner way of expressing this test. ]
						    #										# Update our hint in the textbuffer.
						    textpane_hint
							=
							TEXTPANE_HINT
							  {
							    point	=>  *ps.point,
							    mark	=>  *ps.mark,
							    lastmark    =>  *ps.lastmark,
							    buffermode  =>  *ps.buffermode
							  };

						    ps.textpane_to_textbuffer
							->
							mj::TEXTPANE_TO_TEXTBUFFER  tb;

						    tb.set_textpane_hint  textpane_hint;

						    if save									# Maybe save buffer contents to disk.
							#
							tb.save_to_file ();

							refresh_screenlines  ps;						# Force modeline to redraw, clearing the 'dirty' flag ('**' at left).
						    fi;

						else										# We ARE in the minibuffer

						    if textlines_changed							# If the contents of the minibuffer changed
							#									# ...
							case *prompting__global							# AND
							    #									# ...
							    THE (p as { promptingfor => REF (mj::INCREMENTAL_STRING _), ... })	# if we're reading a mj::INCREMENTAL_STRING
								=>								# THEN
								{								# we need to call the editfn (typically isearch_forward) even though we're not done reading in the argument.

								    minibuffer__global.textpane_to_textbuffer			# Extract textbuffer port from its wrapper.
									->
									mj::TEXTPANE_TO_TEXTBUFFER tb;

								    string_arg							# Extract incremental string from minibuffer.
									=
									case (tb.get_line 0)
									    #
									    THE string
										=>
										mj::INCREMENTAL_STRING_ARG (*p.stage, string);

									    NULL =>
										mj::INCREMENTAL_STRING_ARG (*p.stage, "foo");	# Shouldn't happen.
									esac;

								    p.stage := mj::MEDIAL;

								    prompted_args						# The code duplication through here is pretty awful.  It would be nice to find a cleaner way of factoring this code.  The mainbuffer/minibuffer parallelism isn't working out very well. :-/ XXX SUCKO FIXME. 
									=
									reverse (string_arg ! *p.prompted_for);

								    ps = *mainbuffer__global;

								    point_and_mark  = { point => *ps.point,
											mark  => *ps.mark
										      };
								    lastmark	= *ps.lastmark;
								    log_undo_info   = FALSE;

								    ps.textpane_to_textbuffer					# Extract mainbuffer's textbuffer port from its wrapper.
									->
									mj::TEXTPANE_TO_TEXTBUFFER tb;

								    editfn_in =   { editfn_node		=> p.editfn_node,
										    prompted_args,
										    point_and_mark,
										    lastmark,
										    widget_to_guiboss,
										    log_undo_info,
										    keystring		=> "",
										    numeric_prefix	=> NULL
										  };

								    tb.pass_edit_result  editfn_in				# 
									to							# 
									{.  (parse_editfn_out #editfn_out)
										->
										{ textlines_changed,	textlines, 
										  point_changed,	point,	 
										  mark_changed,		mark,
										  lastmark_changed,	lastmark,
										  textbuffer_changed,	textbuffer, 	
										  #	
										  done,		  	quit,
										  editfn_failed,	save
										};

									    if point_changed					# At the moment this mj::INCREMENTAL_STRING stuff is dedicated support for isearch_forward(), which is only going to change 'point',
										#						# so I'm not going to duplicate here the above code for other possible return flags.
										ps.point := point;

										refresh_screenlines  ps;			# 
									    fi;

									    if mark_changed
										#
										if (mark == NULL)
										    ps.lastmark := *ps.mark;			# Save mark__global contents for possible use by   exchange_point_and_mark()	in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
										fi;

										ps.mark := mark;

										refresh_screenlines  ps;			# 
									    fi;

									    if lastmark_changed
										#
										ps.lastmark := lastmark;
									    fi;
									};
								};

							    _ => ();								# We're not reading an mj::INCREMENTAL_STRING so we can skip all this fuss.
							esac;
						    fi;						    
						fi;
					    };											# Editfn-result thunk.
					};


				fun merge_modifier_keys_info									# Make ESC look like normal meta (mod1) modifier key.  Ditto Windows/Command key as super (mod4) modifier key.
				      {
					modifier_keys_state:		evt::Modifier_Keys_State,
					meta_is_set:			Bool,
					super_is_set:			Bool
				      }												# Using a record rather than tuple reduces the risk of caller getting meta and super args interchanged.
				      :					evt::Modifier_Keys_State
				    =
				    {   modifier_keys_state
					  ->
					  { shift_key_was_down:		Bool,
					    shiftlock_key_was_down:	Bool,
					    control_key_was_down:	Bool,
					    mod1_key_was_down:		Bool,							# ALT, which emacs traditionally interprets as META modifier key.
					    mod2_key_was_down:		Bool,
					    mod3_key_was_down:		Bool,
					    mod4_key_was_down:		Bool,							# Windows/Command key, which emacs traditionally interprets as SUPER modifier key.
					    mod5_key_was_down:		Bool
					  };

					modifier_keys_state
					  =
					  { shift_key_was_down,
					    shiftlock_key_was_down,
					    control_key_was_down,
					    mod1_key_was_down	    =>	mod1_key_was_down or meta_is_set, 
					    mod2_key_was_down,
					    mod3_key_was_down,
					    mod4_key_was_down	    =>	mod4_key_was_down or super_is_set, 
					    mod5_key_was_down
					  };

					modifier_keys_state;
				    };

				fun screenline__key_event_fn									# Process a user keystroke forwarded to us by one of our screenline.pkg instances.
				      (
					a:				tpt::Key_Event_Fn_Arg
				      )
				    =
				    do {.											# The 'do' switches us from executing in microthread of screenline caller to our own textpane microthread.
					a ->  { id:			iuw::Id,						# Unique Id for widget.
						doc:			String,							# Human-readable description of this widget, for debug and inspection.
						key_event:		gt::Key_Event,						# KEY_PRESS or KEY_RELEASE
						keycode:		evt::Keycode,						# Keycode of the depressed key.
						keysym:			evt::Keysym,						# Keysym  of the depressed key.  See Note[1] in src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.api
						keystring:		String,							# Ascii  for the depressed key.  See Note[1] in src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.api
						keychar:		Char,							# First char of 'keystring' ('\0' if string-length != 1).
						event_point:		g2d::Point,
						widget_layout_hint:	gt::Widget_Layout_Hint,
						frame_indent_hint:	gt::Frame_Indent_Hint,
						site:			g2d::Box,						# Widget's assigned area in window coordinates.
						modifier_keys_state:	evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
						mousebuttons_state:	evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
						widget_to_guiboss:	gt::Widget_To_Guiboss,
						theme:			wt::Widget_Theme
					      };
# keycode -> evt::KEYCODE kc;
# nb {. sprintf "screenline__key_event_fn/AAA: keycode=%d key_event=%s keystring='%s' modkeys=%s  -- textpane.pkg" kc case key_event gt::KEY_PRESS=>"KEY_PRESS"; _ => "KEY_RELEASE"; esac  keystring  (evt::modifier_keys_state__to__string  modifier_keys_state); };


					case key_event
					    #
					    gt::KEY_RELEASE									# 
						=>
						if (keystring == "<cmd>")							# This is the Windows/Command key, which following emacs we use as the 'super' key.
						    #
						    keystroke_entry__global.super_is_set := FALSE;
						fi;

					    gt::KEY_PRESS									# 
					    #
						=>
						{   keystring									# Some keystrings we process pre-emptively without invoking editfns, mainly the numeric prefix keys and ESC-as-meta key.
							=									# In those cases we'll return keystring "" here to signal that no further processing is needed.
							if (keystring == "\^[")
							    #
							    keystroke_entry__global.meta_is_set := TRUE;

							    "";									# No further processing needed.

							elif (keystring == "<cmd>")						# This is the Windows/Command key, which following emacs we use as the 'super' key.
							    #
							    keystroke_entry__global.super_is_set := TRUE;

							    "";									# No further processing needed.

							elif (keystring == "<leftShift>" )    "";				# Don't do normal processing on this keystroke because it would clear our numeric-prefix state (and also meta_is_set/super_is_set).
							elif (keystring == "<rightShift>")    "";				# Don't do normal processing on this keystroke because it would clear our numeric-prefix state (and also meta_is_set/super_is_set).
							elif (keystring == "<leftMeta>"	 )    "";				# Don't do normal processing on this keystroke because it would clear our numeric-prefix state (and also meta_is_set/super_is_set).
							elif (keystring == "<rightMeta>" )    "";				# Don't do normal processing on this keystroke because it would clear our numeric-prefix state (and also meta_is_set/super_is_set).
							elif (keystring == "<leftCtrl>"	 )    "";				# Don't do normal processing on this keystroke because it would clear our numeric-prefix state (and also meta_is_set/super_is_set).
							elif (keystring == "<rightCtrl>" )    "";				# Don't do normal processing on this keystroke because it would clear our numeric-prefix state (and also meta_is_set/super_is_set).
							elif (keystring == "<leftAlt>"	 )    "";				# Don't do normal processing on this keystroke because it would clear our numeric-prefix state (and also meta_is_set/super_is_set).
							elif (keystring == "<rightAlt>"  )    "";				# Don't do normal processing on this keystroke because it would clear our numeric-prefix state (and also meta_is_set/super_is_set).
							elif (keystring == "<capsLock>"  )    "";				# Don't do normal processing on this keystroke because it would clear our numeric-prefix state (and also meta_is_set/super_is_set).
							elif (keystring == "<numLock>"   )    "";				# Don't do normal processing on this keystroke because it would clear our numeric-prefix state (and also meta_is_set/super_is_set).

							elif (keystring == "\^U")

							    if (not *keystroke_entry__global.doing_cntrlu)
								#
								keystroke_entry__global.doing_cntrlu   := TRUE;
								keystroke_entry__global.seen_digit     := FALSE;
								keystroke_entry__global.numeric_prefix := 4;

							    elif (*keystroke_entry__global.seen_digit)
								#
								keystroke_entry__global.seen_digit     := FALSE;
								keystroke_entry__global.numeric_prefix := 4;
							    else
								keystroke_entry__global.numeric_prefix := *keystroke_entry__global.numeric_prefix * 4;
							    fi;

							    "";									# No further processing needed.

							elif (*keystroke_entry__global.doing_cntrlu)

							    case keystring
								#
								"0" =>	if (*keystroke_entry__global.seen_digit)	keystroke_entry__global.numeric_prefix := *keystroke_entry__global.numeric_prefix * 10 + 0;							"";	# No further processing needed.
									else						keystroke_entry__global.numeric_prefix := 						 0;	keystroke_entry__global.seen_digit := TRUE;	"";	# No further processing needed.
									fi;

								"1" =>	if (*keystroke_entry__global.seen_digit)	keystroke_entry__global.numeric_prefix := *keystroke_entry__global.numeric_prefix * 10 + 1;							"";	# No further processing needed.
									else						keystroke_entry__global.numeric_prefix := 						 1;	keystroke_entry__global.seen_digit := TRUE;	"";	# No further processing needed.
									fi;

								"2" =>	if (*keystroke_entry__global.seen_digit)	keystroke_entry__global.numeric_prefix := *keystroke_entry__global.numeric_prefix * 10 + 2;							"";	# No further processing needed.
									else						keystroke_entry__global.numeric_prefix := 						 2;	keystroke_entry__global.seen_digit := TRUE;	"";	# No further processing needed.
									fi;

								"3" =>	if (*keystroke_entry__global.seen_digit)	keystroke_entry__global.numeric_prefix := *keystroke_entry__global.numeric_prefix * 10 + 3;							"";	# No further processing needed.
									else						keystroke_entry__global.numeric_prefix := 						 3;	keystroke_entry__global.seen_digit := TRUE;	"";	# No further processing needed.
									fi;

								"4" =>	if (*keystroke_entry__global.seen_digit)	keystroke_entry__global.numeric_prefix := *keystroke_entry__global.numeric_prefix * 10 + 4;							"";	# No further processing needed.
									else						keystroke_entry__global.numeric_prefix := 						 4;	keystroke_entry__global.seen_digit := TRUE;	"";	# No further processing needed.
									fi;

								"5" =>	if (*keystroke_entry__global.seen_digit)	keystroke_entry__global.numeric_prefix := *keystroke_entry__global.numeric_prefix * 10 + 5;							"";	# No further processing needed.
									else						keystroke_entry__global.numeric_prefix := 						 5;	keystroke_entry__global.seen_digit := TRUE;	"";	# No further processing needed.
									fi;

								"6" =>	if (*keystroke_entry__global.seen_digit)	keystroke_entry__global.numeric_prefix := *keystroke_entry__global.numeric_prefix * 10 + 6;							"";	# No further processing needed.
									else						keystroke_entry__global.numeric_prefix := 						 6;	keystroke_entry__global.seen_digit := TRUE;	"";	# No further processing needed.
									fi;

								"7" =>	if (*keystroke_entry__global.seen_digit)	keystroke_entry__global.numeric_prefix := *keystroke_entry__global.numeric_prefix * 10 + 7;							"";	# No further processing needed.
									else						keystroke_entry__global.numeric_prefix := 						 7;	keystroke_entry__global.seen_digit := TRUE;	"";	# No further processing needed.
									fi;

								"8" =>	if (*keystroke_entry__global.seen_digit)	keystroke_entry__global.numeric_prefix := *keystroke_entry__global.numeric_prefix * 10 + 8;							"";	# No further processing needed.
									else						keystroke_entry__global.numeric_prefix := 						 8;	keystroke_entry__global.seen_digit := TRUE;	"";	# No further processing needed.
									fi;

								"9" =>	if (*keystroke_entry__global.seen_digit)	keystroke_entry__global.numeric_prefix := *keystroke_entry__global.numeric_prefix * 10 + 9;							"";	# No further processing needed.
									else						keystroke_entry__global.numeric_prefix := 						 9;	keystroke_entry__global.seen_digit := TRUE;	"";	# No further processing needed.
									fi;

								_   =>  {   keystroke_entry__global.doing_cntrlu   := FALSE;
									    keystroke_entry__global.seen_digit     := FALSE;
									    keystroke_entry__global.done_cntrlu    := TRUE;

									    keystring;					# Do normal processing on keystring.
									};
							    esac;
							else
							    keystring;							# Do normal processing on keystring.
						    	fi;

						    if (keystring != "")
							#
							# Start by making local copies of the global modifier-key and
							# numeric-prefix stuff and then clearing global state so it
							# will be ready to process next keystroke:
							#
							super_is_set   =     *keystroke_entry__global.super_is_set;	keystroke_entry__global.super_is_set := FALSE;
							meta_is_set    =     *keystroke_entry__global.meta_is_set;	keystroke_entry__global.meta_is_set  := FALSE;
							#
							numeric_prefix =  if *keystroke_entry__global.done_cntrlu	THE *keystroke_entry__global.numeric_prefix;
									  else						NULL;
									  fi;

							keystroke_entry__global.doing_cntrlu   := FALSE;				# This should not be needed.
							keystroke_entry__global.done_cntrlu    := FALSE;
							keystroke_entry__global.numeric_prefix := 0;

							ps  =   case *prompting__global							# Which textbuffer is keystroke addressed to?
								    #
								    NULL =>	*mainbuffer__global;					# Normal   input case -- keystrokes are editing the main textbuffer in the main textpane.
								    _    =>  minibuffer__global;					# Prompted input case -- keystrokes are editing the minibuffer in the modeline screenline. 
								esac;


							modifier_keys_state								# Make ESC look like normal meta (mod1) modifier key.  Ditto Windows/Command key as super (mod4) modifier key.
							    =
							    merge_modifier_keys_info { modifier_keys_state, meta_is_set, super_is_set };

							canonical_keystring
							    =
							    mj::keystring_to_modemap_key  (keystring, modifier_keys_state);

							editfn
							    =
							    case *subkeymap__global
								#
								THE keymap
								    =>
								    {   subkeymap__global := NULL;					# We're partway through a multi-key sequence, so continue down it.
										    #
									sm::get (keymap, canonical_keystring);
								    };

								NULL =>
								    find_keymap *ps.buffermode						# Check keymap in current buffermode, then (if necessary) search up its parent buffermodes.
								    where
									fun find_keymap  buffermode
									    = 
									    {   buffermode
										    ->
										    mj::BUFFERMODE { keymap, parent, ... };

										case (sm::get (*keymap, canonical_keystring))
										    #
										    THE editfn => THE editfn;				# Found a binding for the keystroke in current keymap -- return it.

										    NULL => case parent					# No binding for keystroke in this keymap -- search parent keymaps.
												#
												THE buffermode				# We do have a current keymap, so ...
												    =>
												    find_keymap  buffermode;		# ... go search it.

												NULL =>  NULL;				# No parent keymap so give up -- this keystroke does nothing.
											    esac;
										esac;
									    };
								    end;
							    esac;


							case editfn
							    #
							    THE editfn
								=>
								case editfn
								    #
								    mj::EDITFN (editfn_node  as  mj::PLAIN_EDITFN node)
									=>
									if (node.args == [])
									    #
									    do_edit  (editfn_node, keystring, ps, [], numeric_prefix);
									else

									    this_arg       =  head  node.args;
									    remaining_args =  tail  node.args;

									    set_up_to_read_interactive_arg_from_minibuffer
									      (
										editfn_node,
										this_arg,
										remaining_args,
										[]
									      );
									fi;

								    mj::EDITFN (mj::FANCY_EDITFN  /* node */)
									=>
									nb {. "mj::FANCY_EDITFN unsupported  -- textpane.pkg"; };

								    mj::SUBKEYMAP subkeymap
									=>
									subkeymap__global := THE subkeymap;
								esac;

							    NULL => {
									();							# This keystroke unimplemented in keymap.  Should probably beep here or something. Don't know how to beep yet.
								    };
							esac;
						    fi;										# keystring != ""
						};										# gt::KEY_PRESS
					esac;
				    };

				fun screenline__mouse_click_fn									# Process a user keystroke forwarded to us by one of our screenline.pkg instances.
				      (
					a:				tpt::Mouse_Click_Fn_Arg
				      )
				    =
				    do {.											# The 'do' switches us from executing in microthread of screenline caller to our own textpane microthread.
					a ->  { id:			iuw::Id,						# Unique Id for widget.
						doc:			String,							# Human-readable description of this widget, for debug and inspection.
						event:			gt::Mousebutton_Event,					# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE.
						button:			evt::Mousebutton,
						point:			g2d::Point,
						widget_layout_hint:	gt::Widget_Layout_Hint,
						frame_indent_hint:	gt::Frame_Indent_Hint,
						site:			g2d::Box,						# Widget's assigned area in window coordinates.
						modifier_keys_state:	evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
						mousebuttons_state:	evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
						widget_to_guiboss:	gt::Widget_To_Guiboss,
						theme:			wt::Widget_Theme
					      };
				    };

				fun screenline__cursor_offscreen								# Scroll horizontally in response to screenline notification that cursor is offscreen to left or right.
				      {
				        out_by_in_cols:		Int,								# If 'out_by_in_cols' is 10, cursor is 10 columns beyond right margin.  If arg0 is -10, cursor is 10 columns to left of left margin.
					panewidth_in_cols:	Int,								# Width of textpane in screencols.
					screencol0:		Int								# Using (*ps.screen_origin).col here directly led to weird oscillations due to messages getting stacked up in mailqueues between screenline.pkg and textpane.pkg instances.
				      }
				    =
				    do {.											# The 'do' switches us from executing in microthread of screenline caller to our own textpane microthread.
					ps =	case *prompting__global
						    #
						    NULL =>	    *mainbuffer__global;
						    _    =>	     minibuffer__global;	
						esac;

					panewidth2 = panewidth_in_cols / 2;

					screen_origin =  *ps.screen_origin;


					screencol0'
					    =
					    if (out_by_in_cols < 0)
						#
						screencol0' = screencol0 + out_by_in_cols - panewidth2;

						max (0, screencol0');								# Don't let screen origin column go negative.

					    else
						screencol0 + out_by_in_cols + panewidth2;
					    fi;

					ps.screen_origin
					  :=
					  { row =>  screen_origin.row,
					    col =>  screencol0'
					  };

					refresh_screenlines  ps;
				    };

				editboss_to_textpane
				  =
				  { textpane_id => id,										# Unique id to facilitate storing editboss_to_textpane instances in indexed datastructures like red-black trees.
				    textedit_id,										# We belong to this textpane group.,
				    #
				    note__textpane_to_textedit,
				    note__textpane_to_screenline
				  }:					b2p::Editboss_To_Textpane;

				textedit_to_textpane
				  =
				  { textpane_id => id,
				    textedit_id											# We belong to this textpane group.
				  }:					e2p::Textedit_To_Textpane;

				screenline_to_textpane
				  =
				  { textpane_id => id,
				    textedit_id,										# We belong to this Textedit instance.
				    #
#				    mouse_click_fn	=>  screenline__mouse_click_fn,
				    key_event_fn	=>  screenline__key_event_fn,
				    cursor_offscreen	=>  screenline__cursor_offscreen

				  }:					l2p::Screenline_To_Textpane;
			    end;

			widget_to_guiboss.g.request_keyboard_focus  id;

			refresh_screenlines *mainbuffer__global;

			apply   tell_watcher  portwatchers									# We do this here rather than (say) above this fn because we don't want the port in circulation until we're running.
				where
				    fun tell_watcher  portwatcher
					=
					portwatcher  (THE app_to_textpane);
				end;
			();
		    };

		fun shutdown_fn ()												# Return to widget_imp an exception packaging up our state; this will be returned to guiboss_imp, saved in the
		    =														# Paused_Gui tree, and passed to our startup_fn when/if gui is restarted. This exception will never be raised;
		    {	case *widget_to_guiboss__global
			    #
			    THE { widget_to_guiboss, textpane_id }
				=>
				{   (mj::find__gadget_to_editboss  (widget_to_guiboss.g,  "textpane::shutdown_fn"))		# Find our port to src/lib/x-kit/widget/edit/editboss-imp.pkg
					->
					mj::GADGET_TO_EDITBOSS eb;

				    eb.drop_textpane  { textpane_id, textedit_id };
				};

			    NULL => ();
			esac;

			ps  =  *mainbuffer__global;

			apply   tell_watcher  portwatchers									# 
				where
				    fun tell_watcher  portwatcher
					=
					portwatcher  NULL;
				end;

			apply  tell_watcher  *ps.sitewatchers
			    where
				fun tell_watcher sitewatcher
				    =
				    sitewatcher NULL;
			    end;
		    };

		fun initialize_gadget_fn
		    {
		      id:				iuw::Id,								# Unique Id for widget.
		      doc:				String,									# Human-readable description of this widget, for debug and inspection.
		      site:				g2d::Box,								# Window rectangle in which to draw.
		      widget_to_guiboss:		gt::Widget_To_Guiboss,
		      theme:				wt::Widget_Theme,
		      pass_font:			List(String) -> Replyqueue
								     -> (evt::Font -> Void) -> Void,				# Nonblocking version of next, for use in imps.
		       get_font:			List(String) ->	 evt::Font,						# Accepts a list of font names which are tried in order.
		      make_rw_pixmap:			g2d::Size -> g2p::Gadget_To_Rw_Pixmap,
		      #
		      do:				(Void -> Void) -> Void,							# Used by widget subthreads to execute code in main widget microthread.
		      to:				Replyqueue								# Used to call 'pass_*' methods in other imps.
		    }
		    =
		    {	note_site (id,site);
			#
			();
		    };

		fun redraw_request_fn_wrapper
		    {
		      id:				iuw::Id,								# Unique Id for widget.
		      doc:				String,									# Human-readable description of this widget, for debug and inspection.
		      frame_number:			Int,									# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
		      frame_indent_hint:		gt::Frame_Indent_Hint,
		      site:				g2d::Box,								# Window rectangle in which to draw.
		      popup_nesting_depth:		Int,									# 0 for gadgets on basewindow, 1 for gadgets on popup on basewindow, 2 for gadgets on popup on popup, etc.
		      #
		      duration_in_seconds:		Float,									# If state has changed widget-imp should call redraw_gadget() before this time is up. Also useful for motionblur.
		      widget_to_guiboss:		gt::Widget_To_Guiboss,
		      gadget_mode:			gt::Gadget_Mode,
		      #
		      theme:				wt::Widget_Theme,
		      do:				(Void -> Void) -> Void,
		      to:				Replyqueue								# Used to call 'pass_*' methods in other imps.
		    }
		    =
		    {	note_site (id,site);
			#
			(*theme.current_gadget_colors {	gadget_is_on => FALSE,
							gadget_mode,
							popup_nesting_depth,
							#
							body_color			    => NULL,
							body_color_when_on		    => NULL,
							body_color_with_mousefocus	    => NULL,
							body_color_when_on_with_mousefocus  => NULL
						      }
			)
			    ->
			    (palette: wt::Gadget_Palette);

			redraw_fn_arg
			    =
			    REDRAW_FN_ARG
			      { id,
				doc,
				frame_number,
				frame_indent_hint,
				site,
				popup_nesting_depth,
				duration_in_seconds,
				widget_to_guiboss,
				gadget_mode,
				theme,
				do,
				to,
				palette,
				#
				default_redraw_fn
			      };

			(redraw_fn  redraw_fn_arg)
			    ->
			    { displaylist, point_in_gadget };

			widget_to_guiboss.g.redraw_gadget { id, site, displaylist, point_in_gadget };
		    };


		fun mouse_click_fn_wrapper											# This a callback we hand to   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
		      {
			id:				iuw::Id,								# Unique Id for widget.
			doc:				String,									# Human-readable description of this widget, for debug and inspection.
			event:				gt::Mousebutton_Event,							# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE.
			button:				evt::Mousebutton,
			point:				g2d::Point,
			widget_layout_hint:		gt::Widget_Layout_Hint,
			frame_indent_hint:		gt::Frame_Indent_Hint,
			site:		 		g2d::Box,								# Widget's assigned area in window coordinates.
			modifier_keys_state:	        evt::Modifier_Keys_State,						# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,						# State of mouse buttons as a bool record.
			widget_to_guiboss:		gt::Widget_To_Guiboss,
			theme:				wt::Widget_Theme,
			do:				(Void -> Void) -> Void,							# Used by widget subthreads to execute code in main widget microthread.
			to:				Replyqueue								# Used to call 'pass_*' methods in other imps.
		      }
		    = 
		    {	note_site  (id,site);
			#
			mouse_click_fn_arg
			    =
			    MOUSE_CLICK_FN_ARG
			      {
				id,
				doc,
				event,
				button,
				point,
				widget_layout_hint,
				frame_indent_hint,
				site,
				modifier_keys_state,
				mousebuttons_state,
				widget_to_guiboss,
				theme,
				do,
				to,
				#
				default_mouse_click_fn,
				#
				needs_redraw_gadget_request
			      };

			mouse_click_fn  mouse_click_fn_arg;
		    };

		fun mouse_drag_fn_wrapper											# This a callback we hand to   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
		    (
		      {	id:				iuw::Id,								# Unique Id for widget.
			doc:				String,									# Human-readable description of this widget, for debug and inspection.
			event_point:			g2d::Point,
			start_point:			g2d::Point,
			last_point:			g2d::Point,
			widget_layout_hint:		gt::Widget_Layout_Hint,
			frame_indent_hint:		gt::Frame_Indent_Hint,
			site:				g2d::Box,								# Widget's assigned area in window coordinates.
			phase:				gt::Drag_Phase,	
			button:				evt::Mousebutton,
			modifier_keys_state:	        evt::Modifier_Keys_State,						# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,						# State of mouse buttons as a bool record.
			widget_to_guiboss:		gt::Widget_To_Guiboss,
			theme:				wt::Widget_Theme,
			do:				(Void -> Void) -> Void,							# Used by widget subthreads to execute code in main widget microthread.
			to:				Replyqueue								# Used to call 'pass_*' methods in other imps.
		      }
		    )
		    = 
		    {	note_site  (id,site);
			#
			mouse_drag_fn_arg
			    =
			    MOUSE_DRAG_FN_ARG
			      {
				id,
				doc,
				event_point,
				start_point,
				last_point,
				widget_layout_hint,
				frame_indent_hint,
				site,
				phase,
				button,
				modifier_keys_state,
				mousebuttons_state,
				widget_to_guiboss,
				theme,
				do,
				to,
				#
				default_mouse_drag_fn =>  \\ _ = (),								# Default drag behavior for buttons is to do absolutely nothing.
				#
				needs_redraw_gadget_request
			      };

			case mouse_drag_fn
			    #
			    THE mouse_drag_fn =>   mouse_drag_fn  mouse_drag_fn_arg;
			    NULL	      =>   ();										# We do not expect this case to happen: If mouse_drag_fn is NULL mouse_drag_fn_wrapper should not have been registered with widget-imp so we should never get called.
			esac;
		    };

		fun mouse_transit_fn_wrapper
		      #
		      ( arg as
			{
			  id:				iuw::Id,								# Unique Id for widget.
			  doc:				String,									# Human-readable description of this widget, for debug and inspection.
			  event_point:			g2d::Point,
			  widget_layout_hint:		gt::Widget_Layout_Hint,
			  frame_indent_hint:		gt::Frame_Indent_Hint,
			  site:		 		g2d::Box,								# Widget's assigned area in window coordinates.
			  transit:			gt::Gadget_Transit,							# Mouse is entering (CAME) or leaving (LEFT) widget, or moving (MOVE) across it.
			  modifier_keys_state:	        evt::Modifier_Keys_State,						# State of the modifier keys (shift, ctrl...).
			  widget_to_guiboss:		gt::Widget_To_Guiboss,
			  theme:			wt::Widget_Theme,
			  do:				(Void -> Void) -> Void,							# Used by widget subthreads to execute code in main widget microthread.
			  to:				Replyqueue								# Used to call 'pass_*' methods in other imps.
			}
		      )	
		    = 
		    {	note_site (id,site);
			#
			mouse_transit_fn_arg
			    =
			    MOUSE_TRANSIT_FN_ARG
			      {
				id,
				doc,
				event_point,
				widget_layout_hint,
				frame_indent_hint,
				site,
				transit,
				modifier_keys_state,
				widget_to_guiboss,
				theme,
				do,
				to,
				#
				default_mouse_transit_fn =>  \\ _ = (),								# Default transit behavior for buttons is to do absolutely nothing.
				#
				needs_redraw_gadget_request
			      };

			case mouse_transit_fn
			    #
			    THE mouse_transit_fn =>   mouse_transit_fn  mouse_transit_fn_arg;
			    NULL	         =>   ();									# We do not expect this case to happen: If mouse_transit_fn is NULL mouse_transit_fn_wrapper should not have been registered with widget-imp so we should never get called.
			esac;

			();
		    };

		fun key_event_fn_wrapper
		      {
			id:				iuw::Id,								# Unique Id for widget.
			doc:				String,									# Human-readable description of this widget, for debug and inspection.
			key_event:			gt::Key_Event,								# KEY_PRESS or KEY_RELEASE.
			keycode:			evt::Keycode,								# Keycode of the depressed key.
			keysym:				evt::Keysym,								# Keysym  of the depressed key.
			keystring:			String,									# Ascii  for the depressed key.
			keychar:			Char,									# First char of 'string' ('\0' if string-length != 1).
			event_point:			g2d::Point,
			widget_layout_hint:		gt::Widget_Layout_Hint,
			frame_indent_hint:		gt::Frame_Indent_Hint,
			site:		 		g2d::Box,								# Widget's assigned area in window coordinates.
			modifier_keys_state:	        evt::Modifier_Keys_State,						# State of the modifier keys (shift, ctrl...).
			mousebuttons_state:		evt::Mousebuttons_State,						# State of mouse buttons as a bool record.
			widget_to_guiboss:		gt::Widget_To_Guiboss,
			theme:				wt::Widget_Theme,
			do:				(Void -> Void) -> Void,							# Used by widget subthreads to execute code in main widget microthread.
			to:				Replyqueue								# Used to call 'pass_*' methods in other imps.
		      }
		    = 
		    {	note_site (id,site);
			#
			key_event_fn_arg
			    =
			    KEY_EVENT_FN_ARG
			      {
				id,
				doc,
				key_event,
				keycode,
				keysym,
				keystring,
				keychar,
				event_point,
				widget_layout_hint,
				frame_indent_hint,
				site,
				modifier_keys_state,
				mousebuttons_state,
				widget_to_guiboss,
				theme,
				do,
				to,
				#
				default_key_event_fn =>  \\ _ = (),								# Default key event behavior for frame is to do absolutely nothing.
				#
				needs_redraw_gadget_request
			      };

			case key_event_fn
			    #
			    THE key_event_fn =>   key_event_fn  key_event_fn_arg;
			    NULL	     =>   ();										# We do not expect this case to happen: If key_event_fn is NULL key_event_fn_wrapper should not have been registered with widget-imp so we should never get called.
			esac;

		       ();
		    };

		fun note_keyboard_focus_fn_wrapper										# Not really a wrapper because we don't currently allow clients to replace it, but it is structurally parallel with our other wrapper fns in that it gets handed to widget-imp.pkg.
		      {
			id:				iuw::Id,								# Unique Id for widget.
			doc:				String,									# Human-readable description of this widget, for debug and inspection.
			have_keyboard_focus:		Bool,
			widget_to_guiboss:		gt::Widget_To_Guiboss,
			theme:				wt::Widget_Theme,
			do:				(Void -> Void) -> Void,							# Used by widget subthreads to execute code in main widget microthread.
			to:				Replyqueue								# Used to call 'pass_*' methods in other imps.
		      }
		    = 
		    {
nb {. sprintf "note_keyboard_focus_fn_wrapper setting have_keyboard_focus__global := %B   -- textpane.pkg"  have_keyboard_focus;  };
			have_keyboard_focus__global
			    :=
			    have_keyboard_focus;
		    };


		#
		# End of widget hook fn section
		###############################

		widget_options
		    =
		    case mouse_drag_fn
			#
			THE _ =>  (wi::MOUSE_DRAG_FN mouse_drag_fn_wrapper)       ! widget_options;				# Register for drag events only if we are going to use them.
			NULL  =>					            widget_options;
		    esac;

		widget_options
		    =
		    case mouse_transit_fn
			#
			THE _ =>  (wi::MOUSE_TRANSIT_FN mouse_transit_fn_wrapper) ! widget_options;				# Register for transit events only if we are going to use them.
			NULL  =>						    widget_options;
		    esac;

		widget_options
		    =
		    case key_event_fn
			#
			THE _ =>  (wi::KEY_EVENT_FN key_event_fn_wrapper)	  ! widget_options;				# Register for key events only if we are going to use them.
			NULL  =>						    widget_options;
		    esac;

		widget_options
		    =
		    case widget_id
			#
			THE id =>  (wi::ID id)					  ! widget_options;				# 
			NULL   =>						    widget_options;
		    esac;

		widget_options
		    =
		    case frame_indent_hint
			#
			THE h  =>  (wi::FRAME_INDENT_HINT h)			  ! widget_options;				# 
			NULL   =>						    widget_options;
		    esac;

		widget_options
		  =
		  [ wi::STARTUP_FN			startup_fn,								# We always register for these five because our base behavior depends on them.
		    wi::SHUTDOWN_FN			shutdown_fn,
		    wi::INITIALIZE_GADGET_FN		initialize_gadget_fn,
		    wi::REDRAW_REQUEST_FN		redraw_request_fn_wrapper,
		    wi::MOUSE_CLICK_FN			mouse_click_fn_wrapper,
		    wi::NOTE_KEYBOARD_FOCUS_FN		note_keyboard_focus_fn_wrapper,
		    wi::DOC				widget_doc
		  ]
		  @
		  widget_options
		  ;

		make_widget_fn =  wi::make_widget_start_fn  widget_options;

		gt::WIDGET  make_widget_fn;											# So caller can write   guiplan = gt::ROW [ frame::with [...], frame::with [...], ... ];
	    };															# PUBLIC
    };
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1994 by AT&T Bell Laboratories  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2014,
## released per terms of SMLNJ-COPYRIGHT.
