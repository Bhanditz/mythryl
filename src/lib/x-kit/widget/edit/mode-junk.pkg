# mode-junk.pkg
#
# Types (and some code) in support of textpane modes like
#
#     src/lib/x-kit/widget/edit/fundamental-mode.pkg
#     src/lib/x-kit/widget/edit/minibuffer-mode.pkg
#
# This is another of those files full of datatypes which wanted
# so much to be mutually recursive that finally I gave up, merged
# the relevant files, and let them recurse to their heart's content.
#
# See also:
#     src/lib/x-kit/widget/edit/textpane.pkg
#     src/lib/x-kit/widget/edit/editboss-imp.pkg
#     src/lib/x-kit/widget/edit/textmill-imp.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package ct  =  cutbuffer_types;				# cutbuffer_types		is from   src/lib/x-kit/widget/edit/cutbuffer-types.pkg
    package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package l2p =  screenline_to_textpane;			# screenline_to_textpane	is from   src/lib/x-kit/widget/edit/screenline-to-textpane.pkg
    package e2p =  editboss_to_textpane;			# editboss_to_textpane		is from   src/lib/x-kit/widget/edit/editboss-to-pane.pkg
    package b2p =  editboss_to_pane;				# editboss_to_pane		is from   src/lib/x-kit/widget/edit/editboss-to-pane.pkg
    package p2l =  textpane_to_screenline;			# textpane_to_screenline	is from   src/lib/x-kit/widget/edit/textpane-to-screenline.pkg
    package b2l =  editboss_to_screenline;			# editboss_to_screenline	is from   src/lib/x-kit/widget/edit/editboss-to-screenline.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg
    package sm  =  string_map;					# string_map			is from   src/lib/src/string-map.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
#   package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

#   package ebt =  editboss_types;				# editboss_types		is from   src/lib/x-kit/widget/edit/editboss-types.pkg


    package que =  queue;					# queue				is from   src/lib/src/queue.pkg
    package nl  =  red_black_numbered_list;			# red_black_numbered_list	is from   src/lib/src/red-black-numbered-list.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

herein

    package mode_junk						# 
    {
	Filespec
	  =											# A valid path to the file in question should be produced by the expression   dirname + "/" + filename
	  { dirname:		String,								# Should NOT have a trailing '/'.
	    basename:		String								# Should be entirely '/'-free.
	  };

	Point_And_Mark										# 'Point' is the visible cursor.  'Mark' (if set) marks the other end of the selected region.  (Emacs nomenclature.)
	  =
	  { point:		g2d::Point,							# Note that point and mark are per-textpane, not per-textmill. (This matters because there may be multiple textpanes open on one textmill).  This is different from emacs, where 'mark' is per-textmill.
	    mark:		Null_Or(g2d::Point)						# NULL means the emacs-style 'mark' is not currently set.
	  };

	Textlines = nl::Numbered_List(String);							# In textmill.pkg we store our file contents in this, line by line.

	Stage = INITIAL
	      | MEDIAL
	      | FINAL
	      ;
	#
	Promptfor
	  #
	  = STRING		{ prompt: String,  doc: String }				# String arg is the prompt to supply to user.
	  | FILENAME		{ prompt: String,  doc: String }
	  | INCREMENTAL_STRING  { prompt: String,  doc: String }
#	  | COMMAND										# The point of these two is to support tab-completion functionality by cuing the system to what sort of string to expect.
	  ;
	
	Prompted_Arg
	  #
	  = STRING_ARG		    String							# String arg is the string read from user.
	  | INCREMENTAL_STRING_ARG (Stage, String)						# An INCREMENTAL_STRING -- editfn gets called each time it changes, even though not net complete.
#	  | COMMAND_ARG
#	  | FILENAME_ARG									# I'm not sure we'll need this -- any reason a filename can't be just a string at this point?
	  ;

	Editfn_Out_Option									# This conveys information from editfns back to textpane.
	  #
	  = TEXTLINES		Textlines							# Note revised contents of textmill.
	  | TEXTMILL		Textpane_To_Textmill						# Note that textpane is now open on a different textmill.
	  | POINT		g2d::Point
	  | MARK		Null_Or(g2d::Point)
	  | LASTMARK		Null_Or(g2d::Point)
	  | READONLY		Bool								# Set textmill readonly flag to given value.
	  | SAVE										# Save textmill contents to disk, if dirty.
	  | QUIT										# This is intended to implement keyboard_quit  (normally bound to C-g) functionality in fundamental-mode.pkg.
	  | DONE										# This is intended to implement input_complete (normally bound to RET) functionality in minibuffer-mode.pkg.
	  | MODELINE_MESSAGE	String								# Post a message (e.g., "No files need saving.") to the textpane modeline that will be visible until next keystroke is typed. 

	also
	Textmill_Statechange									# Used to tell clients (mostly textpane.pkg) about changes in our state.
	  #											# The 'Id' field in each case is Textpane_To_Textmill.id;  it may be used by client to identify and discard stale statechanges which arrive after calling drop_statewatcher().
	  = TEXTSTATE_CHANGED	{ was: Textstate,	   now: Textstate	  }
	  | UNDO		{ was: Textstate,	   now: Undostate	  }
	  | FILESPEC_CHANGED	{ was: Null_Or(Filespec),  now: Null_Or(Filespec) }		# File being visited in the textmill.  Some textmills visit no file (in-memory editing only), hence the Null_Or.
	  | NAME_CHANGED	{ was: String,		   now: String		  }		# Name of textmill.  Every textmills has a globally unique name.
	  | READONLY_CHANGED	{ was: Bool,		   now: Bool		  }		#
	  | DIRTY_CHANGED	{ was: Bool,		   now: Bool		  }		#

	also
	Textmill_Option
	  #
	  =  MICROTHREAD_NAME	String								# 
	  |  ID			Id								# Stable, unique id for imp.
	  |  STATEWATCHER	(Id, ((Id, Textmill_Statechange) -> Void))			# Equivalent to Textpane_To_Textmill.note_statewatcher(). First 'Id' is textpane_id; it identifies this particular watcher/connection for drop_statewatcher. Second 'Id' is textmill_id.
	  |  INITIAL_FILENAME	String								# 
	  |  UTF8		String

	also
	Textpane_To_Textmill
	    =
	    TEXTPANE_TO_TEXTMILL
	      { id:			Id,							# Unique id to facilitate storing textpane_to_textmill instances in indexed datastructures like red-black trees.
		#
		get_maxline:		Void -> Int,						# Max currently valid line number.
		pass_maxline:		Replyqueue -> (Int -> Void) -> Void,
		#
		get_line:		Int -> Null_Or(String),
		pass_line:		Replyqueue
					   -> Int
					   -> (Null_Or(String) -> Void)
					   -> Void,
		#
		set_lines:		List(String) -> Void,
		get_lines:		(Int, Int) -> List(String),
		pass_lines:		Replyqueue
					     -> (Int, Int)
					     -> (List(String) -> Void)
					     -> Void,
		#
		get_textstate:		Void -> Textstate,					# 
		pass_textstate:		Replyqueue -> (Textstate -> Void) -> Void,
		#
		pass_edit_result:	Edit_Arg
					     -> Replyqueue
					     -> (Editfn_Out -> Void)
					     -> Void,						# 

		undo:			Void -> Void,

		get_dirty:		Void -> Bool,						# TRUE iff textmill contents are currently out of sync with diskfile contents.
		pass_dirty:		Replyqueue -> (Bool -> Void) -> Void,

		set_readonly:		Bool -> Void,						# 
		get_readonly:		Void -> Bool,						# TRUE iff textmill contents are currently marked as ineditable.
		pass_readonly:		Replyqueue -> (Bool -> Void) -> Void,

		set_filespec:		Null_Or(Filespec) -> Void,				# Filename controls what file textmill contents are read/written from/to.
		get_filespec:		Void -> Null_Or(Filespec),				# 
		pass_filespec:		Replyqueue -> (Null_Or(Filespec) -> Void) -> Void,

		set_name:		String -> Void,						# Name uniquely identifies textmill to interactive user.
		get_name:		Void -> String,						# 
		pass_name:	Replyqueue -> (String -> Void) -> Void,
												# The statewatcher protocol allows others imps (including other texteditors and also arbitrary application imps) to monitor changes to a given textmill.
		set_textpane_hint:	Exception -> Void,					# Store the current textpane's point+mark etc info on the textmill, so that if/when we open a new textpane onto this textmill, we can put the cursor in a sensible spot.
		get_textpane_hint:	Void -> Exception,					# Using 'Exception' spares textmill-imp.pkg from needing to know about the relevant textpane.pkg types.

		note_statewatcher:	(Id, (Id, Textmill_Statechange) -> Void) -> Void,	# First 'Id' is caller's, typically editboss_id or textpane_id -- identifies this particular watcher for drop_statewatcher.  Second 'Id' is textmill_id.
		drop_statewatcher:	 Id -> Void,						# 'Id' must match that given to note_statewatcher (or texteditor_imp::STATEWATCHER).

		reload_from_file:	Void -> Void,
		save_to_file:		Void -> Void
	      }

	# This port is implemented in:
	#
	#     src/lib/x-kit/widget/edit/editboss-imp.pkg
	#
	also
	Gadget_To_Editboss									# guiboss provides this interface to gadgets via the guiboss_types Gadget_To_Guiboss interface.  This is the toplevel application code access pathway to texteditor functionality.
	    =											# This was in a separate guiboss-to-editboss.pkg file:  Moved it here to resolve a package-cycle problem.
	    GADGET_TO_EDITBOSS
	      {
		id:			Id,							# Unique id to facilitate storing gadget_to_editboss instances in indexed datastructures like red-black trees.
		#
		get_textmill:		String -> Null_Or( Textpane_To_Textmill ),		# Get pre-existing textmill by name, return NULL if not found.
		make_textmill:		Textmill_Arg ->    Textpane_To_Textmill,		# Create new       textmill.  If there is a pre-existing one by the same name, modify given name to make new buffer's name unique.
		get_or_make_textmill:	Textmill_Arg ->    Textpane_To_Textmill,		# Get pre-existing textmill if one is found, create and return one if not found.
		get_or_make_filebuffer:	Filespec ->        Textpane_To_Textmill,		# Find (or failing that, create) a textmill open on the given file.

		get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,				# O(1) nonblocking.
		set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void,

		note_pane:		(b2p::Editboss_To_Pane) -> Void,			# Remember existence of a pane. Intended to support textpanes but also eventually other kinds of panes.
		drop_pane:		{ pane_id: Id }		-> Void,			# Forget   existence of a pane. Inverse of above.
		mail_pane:		(Id, Crypt)		-> Void				# Send something to a pane. If the pane is not yet registered with editboss, the crypt will be queued up and delivered when the pane registers. Used for linking up screenline.pkg instances to textpane.pkg instances at startup (etc).
												# Using a Crypt here makes the mechanism general at a small cost in typesafety.  In particular, it buys us valuable modularity by keeping editboss from needing to know the types of the interfaces between textpane and screenline (etc).
	      }

	also
	Editfn_Node
	  #
	  = PLAIN_EDITFN	Plain_Editfn
	  | FANCY_EDITFN									# Not currently useful.  Intended to support fns which need to do significant work in the context of textpane.pkg (vs textmill-imp.pkg).

	also
	Keymap_Node
	  #
	  = EDITFN		Editfn_Node
	  | SUBKEYMAP		Keymap

	also
	Buffermode										# A buffermode defines the semantics of a textmill. In particular, the keymap defines what editfns are invoked by what keystrokes.
	    =
	    BUFFERMODE
	      {
		name:		String,
		doc:		String,
		#
		keymap:		Ref(Keymap),
		parent:		Null_Or( Buffermode )						# So we can dynamically inherit keybindings from less specialized buffermodes.
	      }

	withtype
	Keymap
	  = 
	  sm::Map( Keymap_Node )

	also
	Textmill_Arg
	  =
	  { name:			String,
	    textmill_options:		List( Textmill_Option )
	  }

	also
	Editfn_In										# This is what  do_pass_edit_result()  passes to editfns in   src/lib/x-kit/widget/edit/textmill-imp.pkg
	  =
	  { args:			List( Prompted_Arg ),
	    textlines:			Textlines,
	    point:			g2d::Point,						# As in Point_And_Mark.  (Emacs nomenclature -- 'point' is the visible cursor, 'mark' if set is the other end of the selected region.)
	    mark:			Null_Or( g2d::Point ),					# 
	    lastmark:			Null_Or( g2d::Point ),					# Last valid value of 'mark' if any -- used to retrieve old mark values by   exchange_point_and_mark	in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
	    keystring:			String,							# User keystroke that invoked this editfn.
	    readonly:			Bool,							# TRUE iff textmill contents are currently marked as read-only.
	    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
	    pane_id:			Id,							# Id of pane for which this editfn is being invoked.
	    widget_to_guiboss:		gt::Widget_To_Guiboss,					# 
	    gadget_to_editboss:		Gadget_To_Editboss,
	    mainbuffer_mode:		Buffermode,
	    minibuffer_mode:		Buffermode
	  }

	also
	Editfn_Out										# Return   NULL    to abort. This is appropriate when operation cannot be performed, for example previous_char called at start of buffer.
	  =											# Return   THE []  otherwise, where list contains CHANGES to state.  E.g., do not return TEXTLINES unless textlines value was changed.
	  Fail_Or (List( Editfn_Out_Option ) )							# One advantage of this system is that additional returns can be accomodated without breaking old code.

	also
	Editfn = Editfn_In -> Editfn_Out

	also
	Textstate
	  =
	  { textlines:		Textlines,							# Complete text contents of textmill.
	    editcount:		Int								# Count of edits applied.  Intended to allow clients to quickly detect whether any changes have been made since they last polled us.
	  }
	also
	Undostate = Textstate									# Synonym for readability.

	also
	Plain_Editfn
	  =
	  { name:		String,
	    doc:		String,
	    args:		List(Promptfor),						# Technically 'parameters', but 'args' is shorter. :-)  Args to read in interactively from user, e.g. filenames and search strings.
	    editfn:		Editfn								# 
	  }

	also
	Edit_Arg										# Arg type for	pass_edit_result()   in   src/lib/x-kit/widget/edit/textmill-imp.pkg
	  =
	  { keystring:		String,								# User keystroke that invoked this editfn.
	    numeric_prefix:	Null_Or( Int ),							# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
	    prompted_args:	List( Prompted_Arg ),						# Args read interactively from user.
	    point_and_mark:	Point_And_Mark,
	    lastmark:		Null_Or(g2d::Point),
	    log_undo_info:	Bool,								# If log_undo_info is FALSE no entry will be made in the undo history.
	    #
	    pane_id:		Id,								# Id of pane for which this editfn is being invoked.
	    editfn_node:	Editfn_Node,
 	    widget_to_guiboss:	gt::Widget_To_Guiboss,						# Mainly for access to get_cutbuffer_contents/set_cutbuffer_contents in gadget_to_editboss.  NB: Passing gadget_to_editboss here instead results in a package cycle.
	    mainbuffer_mode:	Buffermode,
	    minibuffer_mode:	Buffermode
	  };



	exception  GADGET_TO_EDITBOSS__CRYPT	    Gadget_To_Editboss;
	exception  TEXTPANE_TO_SCREENLINE__CRYPT    p2l::Textpane_To_Screenline;


	fun find__gadget_to_editboss
	      (
		gadget_to_guiboss:	gt::Gadget_To_Guiboss,
		caller:			String
	      )
	    =
	    case (gadget_to_guiboss.find_global "gadget_to_editboss::GADGET_TO_EDITBOSS")
		#
		THE gadget_to_editboss
		    =>
		    case gadget_to_editboss.data
			#
			GADGET_TO_EDITBOSS__CRYPT gadget_to_editboss
			    =>
			    gadget_to_editboss;

			_ =>    {   msg =  sprintf "Expected Crypt of GADGET_TO_EDITBOSS__CRYPT but got Crypt of { type=>\"%s\", info=>\"%s\" }  -- gadget_to_editboss::find__gadget_to_editboss called by %s" gadget_to_editboss.type gadget_to_editboss.info caller;				# "Impossible."
				    log::fatal msg;
				    raise exception DIE msg;
				};
		    esac;

		NULL =>	{   msg =  sprintf "GADGET_TO_EDITBOSS global not registered with guiboss_imp in time?! -- gadget_to_editboss::find__gadget_to_editboss called by %s" caller;				# "Impossible."
			    log::fatal msg;
			    raise exception DIE msg;
			};
	    esac;


	empty_keymap =  sm::empty: Keymap;							# Helps clients abstract a bit from current specific implementation of keymaps.

	stipulate										# This idiom borrowed from   src/lib/src/quickstring.pkg
	    #
	    lock = make_full_maildrop ();
	    #
	herein
	    fun atomically f a
		=
		{   take_from_maildrop lock;
		    #
		    f a
		    then
			put_in_maildrop (lock, ());
		};
	end;

	fun keystring_to_modemap_key								# Convert keystroke string from guishim-imp-for-x.pkg (or other guishim) into traditional emacs keymap representation like "C-SPC" or "C-M-q" or such.
	      (
		keystring:		String,
		modifier_keys_state:	evt::Modifier_Keys_State
	      )
	    =
	    if (keystring == "")
		#
		keystring;									# Mostly just so we don't have to worry about empty strings in the rest of the routine.

	    else
		modifier_keys_state
		  ->
		  { shift_key_was_down:		Bool,
		    shiftlock_key_was_down:	Bool,
		    control_key_was_down:	Bool,
		    mod1_key_was_down:		Bool,						# ALT, which emacs traditionally interprets as META modifier key.
		    mod2_key_was_down:		Bool,
		    mod3_key_was_down:		Bool,
		    mod4_key_was_down:		Bool,						# Windows/Command key, which emacs traditionally interprets as SUPER modifier key.
		    mod5_key_was_down:		Bool
		  };

		my (keystring, control_key_was_down)						# Normalize actual control chars to modkey + alphabetic representation.
		    =
		    case keystring
			#
			"\^@"	=>	("@", TRUE);
			"\^A"	=>	("a", TRUE);
			"\^B"	=>	("b", TRUE);
			"\^C"	=>	("c", TRUE);
			"\^D"	=>	("d", TRUE);
			"\^E"	=>	("e", TRUE);
			"\^F"	=>	("f", TRUE);
			"\^G"	=>	("g", TRUE);
			"\^H"	=>	("h", TRUE);
			"\^I"	=>	("i", TRUE);
			"\^J"	=>	("j", TRUE);
			"\^K"	=>	("k", TRUE);
			"\^L"	=>	("l", TRUE);
			"\^M"	=>	("m", TRUE);
			"\^N"	=>	("n", TRUE);
			"\^O"	=>	("o", TRUE);
			"\^P"	=>	("p", TRUE);
			"\^Q"	=>	("q", TRUE);
			"\^R"	=>	("r", TRUE);
			"\^S"	=>	("s", TRUE);
			"\^T"	=>	("t", TRUE);
			"\^U"	=>	("u", TRUE);
			"\^V"	=>	("v", TRUE);
			"\^W"	=>	("w", TRUE);
			"\^X"	=>	("x", TRUE);
			"\^Y"	=>	("y", TRUE);
			"\^Z"	=>	("z", TRUE);
			"\^["	=>	("[", TRUE);
			"\^\"	=>	("\\",TRUE);
			"\^]"	=>	("]", TRUE);
			"\^_"	=>	("_", TRUE);
			#
			_	=>	(keystring, control_key_was_down);
		    esac;

		my (keystring, control_key_was_down)						# A few ad hoc traditional names.
		    =
		    case (keystring, control_key_was_down)
			#
			("i", TRUE) => ("TAB", FALSE);
			("m", TRUE) => ("RET", FALSE);
			("[", TRUE) => ("ESC", FALSE);
			#
			_	    => (keystring, control_key_was_down);
		    esac;

		keystring = if (keystring == " ")   "SPC";
			    else		    keystring;
			    fi;

		# By inspection of describe-bindings output,
		# the canonical emacs ordering for the
		#
		#     Super = 's-'
		#     Meta  = 'M-'
		#     Ctrl  = 'C-'
		#     Shift = 'S-'
		#
		# prefixes seems to be
		#
		#     s-C-M-S-x
		#
		# Here we build them up in right-to-left order:

		keystring							# The shift modifier 'S-' is only useful on special keys, which are represented in angle brackets, eg "<backspace>" or "<home>".
		    =
		    {	bytelen = string::length_in_bytes   keystring;
			charlen = string::length_in_chars   keystring;
			#
			if (charlen < 3)
			    #
			    keystring;
			else
			    firstchar =  string::get_byte_as_char (keystring, 0);
			    lastchar  =  string::get_byte_as_char (keystring, bytelen - 1);

			    keystring
				=
				case ( firstchar,
				       lastchar,
				       shift_key_was_down or shiftlock_key_was_down
				     )
				    #
				    ('<', '>', TRUE) => "S-" + keystring;	# We *do* have something like "<backspace>" and shift *is* set, so add the S- prefix.
				    _	             =>        keystring;	# Ignore shift (if any) because in cases like 4 vs $ (etc) it is implicit in the keystring.
				esac;

			    keystring;
			fi;
		    };

		keystring							# The META modifier 'M-' may be applied to anything.
		    =
		    case mod1_key_was_down
			#
			TRUE	    => "M-" + keystring;
			_	    =>        keystring;
		    esac;

		keystring							# The CTRL modifier 'C-' may be applied to anything.
		    =
		    case control_key_was_down
			#
			TRUE	    => "C-" + keystring;
			_	    =>        keystring;
		    esac;

		keystring							# The SUPER modifier 's-' may be applied to anything.
		    =
		    case mod4_key_was_down
			#
			TRUE	    => "s-" + keystring;
			_	    =>        keystring;
		    esac;


		keystring;
	    fi;



	fun add_editfn_to_keymap
	      (
		keymap:		Keymap,
		key:		List(String),							# The strings should have been run through keystring_to_modemap_key() or be in its format.  List has one string for single-keystroke commands, two strings for single-prefix commands etc.
		keymap_node:	Keymap_Node
	      )
	    :			Keymap
	    =
	    case key
		#
		[]	 => keymap;								# Shouldn't happen.

		k ! []   => sm::set (keymap, k, keymap_node);

		k ! rest => {   subkeymap = case (sm::get (keymap, k))
						#
						THE (SUBKEYMAP subkeymap)
						    =>
						    subkeymap;					# Use existing subkeymap for this prefix key.

						_   =>  empty_keymap;				# Start a new subkeymap for this prefix key.
					    esac;

				subkeymap
				    =
				    add_editfn_to_keymap (subkeymap, rest, keymap_node);

				sm::set (keymap, k, SUBKEYMAP subkeymap);			# Silently clobber any previous non-prefix-key keymap_node associated with 'k'.
			    };
	    esac;


	fun add_editfn_to_keymap_throughout_char_range						# Emacs directly represents char ranges in keymaps, but for now we'll keep our keymaps simple.  Ram is a million times cheaper now than it was in the early 1970s when emacs was designed. :-)
	      {
		keymap:		Keymap,
		keymap_node:	Keymap_Node,
		#
		firstchar:	Char,
		lastchar:	Char
	      }
	    :			Keymap
	    =
	    {   keymap =    loop (firstchar, keymap)
			    where
				fun loop (c: Char, keymap: Keymap)
				    =
				    if (c > lastchar)
					#
					keymap;
				    else
					key = char::to_string c;
					key = keystring_to_modemap_key (key, evt::no_modifier_keys_were_down);
					#
					keymap = sm::set (keymap, key, keymap_node);

					loop (char::next c,  keymap);
				    fi;
			    end;
		
		keymap;
	    };	
    };

end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
