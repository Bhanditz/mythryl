# mode-junk.pkg
#
# Types (and some code) in support of textpane modes like
#
#     src/lib/x-kit/widget/edit/fundamental-mode.pkg
#     src/lib/x-kit/widget/edit/minibuffer-mode.pkg
#
# This is another of those files full of datatypes which wanted
# so much to be mutually recursive that finally I gave up, merged
# the relevant files, and let them recurse to their heart's content.
#
# See also:
#     src/lib/x-kit/widget/edit/textpane.pkg
#     src/lib/x-kit/widget/edit/textedit.pkg
#     src/lib/x-kit/widget/edit/editboss-imp.pkg
#     src/lib/x-kit/widget/edit/textbuffer-imp.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package ct  =  cutbuffer_types;				# cutbuffer_types		is from   src/lib/x-kit/widget/edit/cutbuffer-types.pkg
    package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package p2e =  textpane_to_textedit;			# textpane_to_textedit		is from   src/lib/x-kit/widget/edit/textpane-to-textedit.pkg
    package b2e =  editboss_to_textedit;			# editboss_to_textedit		is from   src/lib/x-kit/widget/edit/editboss-to-textedit.pkg
    package l2p =  screenline_to_textpane;			# screenline_to_textpane	is from   src/lib/x-kit/widget/edit/screenline-to-textpane.pkg
    package e2p =  textedit_to_textpane;			# textedit_to_textpane		is from   src/lib/x-kit/widget/edit/textedit-to-textpane.pkg
    package b2p =  editboss_to_textpane;			# editboss_to_textpane		is from   src/lib/x-kit/widget/edit/editboss-to-textpane.pkg
    package p2l =  textpane_to_screenline;			# textpane_to_screenline	is from   src/lib/x-kit/widget/edit/textpane-to-screenline.pkg
    package b2l =  editboss_to_screenline;			# editboss_to_screenline	is from   src/lib/x-kit/widget/edit/editboss-to-screenline.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package iuw =  issue_unique_widget_id;			# issue_unique_widget_id	is from   src/lib/x-kit/widget/gui/issue-unique-widget-id.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg
    package sm  =  string_map;					# string_map			is from   src/lib/src/string-map.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
#   package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

#   package ebt =  editboss_types;				# editboss_types		is from   src/lib/x-kit/widget/edit/editboss-types.pkg


    package que =  queue;					# queue				is from   src/lib/src/queue.pkg
    package nl  =  red_black_numbered_list;			# red_black_numbered_list	is from   src/lib/src/red-black-numbered-list.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

herein

    package mode_junk						# 
    {
	Point_And_Mark										# 'Point' is the visible cursor.  'Mark' (if set) marks the other end of the selected region.  (Emacs nomenclature.)
	  =
	  { point:		g2d::Point,							# Note that point and mark are per-textpane, not per-textbuffer. (This matters because there may be multiple textpanes open on one textbuffer).  This is different from emacs, where 'mark' is per-textbuffer.
	    mark:		Null_Or(g2d::Point)						# NULL means the emacs-style 'mark' is not currently set.
	  };

	Textlines = nl::Numbered_List(String);							# In textbuffer.pkg we store our file contents in this, line by line.

	Editfn_Out_Option									# This conveys information from editfns back to textpane.
	  #
	  = TEXTLINES		Textlines							# Note revised contents of textbuffer.
	  | NEW_TEXTBUFFER	String								# Note that textpane is now open on a different textbuffer, available as Gadget_To_Editboss.get_textbuffer(buffername).
	  | POINT		g2d::Point
	  | MARK		Null_Or(g2d::Point)
	  | LASTMARK		Null_Or(g2d::Point)
	  | QUIT										# This is intended to implement keyboard_quit  (normally bound to C-g) functionality in fundamental-mode.pkg.
	  | DONE										# This is intended to implement input_complete (normally bound to RET) functionality in minibuffer-mode.pkg.
	  ;

	Editfn_Out										# Return   NULL    to abort. This is appropriate when operation cannot be performed, for example previous_char called at start of buffer.
	  =											# Return   THE []  otherwise, where list contains CHANGES to state.  E.g., do not return TEXTLINES unless textlines value was changed.
	  Null_Or (List( Editfn_Out_Option ) );							# One advantage of this system is that additional returns can be accomodated without breaking old code.

	Textstate
	  =
	  { textlines:		Textlines,							# Complete text contents of textbuffer.
	    editcount:		Int								# Count of edits applied.  Intended to allow clients to quickly detect whether any changes have been made since they last polled us.
	  };
	Undostate = Textstate;									# Synonym for readability.

	#
	Promptfor
	  #
	  = STRING   { prompt: String,  doc: String }						# String arg is the prompt to supply to user.
	  | FILENAME { prompt: String,  doc: String }
#	  | INCREMENTAL_STRING
#	  | COMMAND										# The point of these two is to support tab-completion functionality by cuing the system to what sort of string to expect.
	  ;
	
	Prompted_Arg
	  #
	  = STRING_ARG String									# String arg is the string read from user.
#	  | PARTSTRING_ARG									# An INCREMENTAL_STRING not yet fully entered
#	  | FULLSTRING_ARG									# An INCREMENTAL_STRING fully entered
#	  | COMMAND_ARG
#	  | FILENAME_ARG									# I'm not sure we'll need this -- any reason a filename can't be just a string at this point?
	  ;

	Textbuffer_Statechange									# Used to tell clients (mostly textpane.pkg) about changes in our state.
	  #											# The 'Id' field in each case is Textpane_To_Textbuffer.id;  it may be used by client to identify and discard stale statechanges which arrive after calling drop_statewatcher().
	  = TEXTSTATE_CHANGED	(Id, { was: Textstate, now: Textstate })
	  | UNDO		(Id, { was: Textstate, now: Undostate })
	  | FILENAME_CHANGED	(Id, { was: String,    now: String    })
	  | BUFFERNAME_CHANGED	(Id, { was: String,    now: String    })
	  ;

	Textbuffer_Option
	  #
	  =  MICROTHREAD_NAME	String								# 
	  |  ID			Id								# Stable, unique id for imp.
	  |  STATEWATCHER	(Id, (Textbuffer_Statechange -> Void))				# Equivalent to Textpane_To_Textbuffer.note_statewatcher(). 'Id' may be the id of the calling imp or may be freshly allocated via issue_unique_id. It identifies this particular watcher/connection for drop_statewatcher.
	  |  INITIAL_FILENAME	String								# 
	  |  UTF8		String
	  ;	

	Textbuffer_Arg =  { buffername:			String,
			    textbuffer_options:		List( Textbuffer_Option )
			  };


	Textpane_To_Textbuffer
	    =
	    TEXTPANE_TO_TEXTBUFFER
	      { id:			Id,							# Unique id to facilitate storing textpane_to_textbuffer instances in indexed datastructures like red-black trees.
		#
		get_maxline:		Void -> Int,						# Max currently valid line number.
		pass_maxline:		Replyqueue -> (Int -> Void) -> Void,
		#
		get_line:		Int -> Null_Or(String),
		pass_line:		Replyqueue
					   -> Int
					   -> (Null_Or(String) -> Void)
					   -> Void,
		#
		set_lines:		List(String) -> Void,
		get_lines:		(Int, Int) -> List(String),
		pass_lines:		Replyqueue
					     -> (Int, Int)
					     -> (List(String) -> Void)
					     -> Void,
		#
		get_textstate:		Void -> Textstate,					# 
		pass_textstate:		Replyqueue -> (Textstate -> Void) -> Void,
		#
		pass_edit_result:	Edit_Arg
					     -> Replyqueue
					     -> (Editfn_Out -> Void)
					     -> Void,						# 

		undo:			Void -> Void,

		get_dirty:		Void -> Bool,						# TRUE iff textbuffer contents are currently out of sync with diskfile contents.
		pass_dirty:		Replyqueue -> (Bool -> Void) -> Void,

		set_filename:		String -> Void,						# Filename controls what file textbuffer contents are read/written from/to.
		get_filename:		Void -> String,						# 
		pass_filename:		Replyqueue -> (String -> Void) -> Void,

		set_buffername:		String -> Void,						# Buffername uniquely identifies textbuffer to interactive user.
		get_buffername:		Void -> String,						# 
		pass_buffername:	Replyqueue -> (String -> Void) -> Void,
												# The statewatcher protocol allows others imps (including other texteditors and also arbitrary application imps) to monitor changes to a given textbuffer.
		set_textpane_hint:	Exception -> Void,					# Store the current textpane's point+mark etc info on the textbuffer, so that if/when we open a new textpane onto this textbuffer, we can put the cursor in a sensible spot.
		get_textpane_hint:	Void -> Exception,					# Using 'Exception' spares textbuffer-imp.pkg from needing to know about the relevant textpane.pkg types.

		note_statewatcher:	(Id, (Textbuffer_Statechange -> Void)) -> Void,		# 'Id' may be the id of the calling imp or may be freshly allocated via issue_unique_id. It identifies this particular watcher/connection for drop_statewatcher.
		drop_statewatcher:	Id -> Void,						# 'Id' must match that given to note_statewatcher (or texteditor_imp::STATEWATCHER).

		reload_from_file:	Void -> Void,
		save_to_file:		Void -> Void
	      }

	# This port is implemented in:
	#
	#     src/lib/x-kit/widget/edit/editboss-imp.pkg
	#
	also
	Gadget_To_Editboss									# guiboss provides this interface to gadgets via the guiboss_types Gadget_To_Guiboss interface.  This is the toplevel application code access pathway to texteditor functionality.
	    =											# This was in a separate guiboss-to-editboss.pkg file:  Moved it here to resolve a package-cycle problem.
	    GADGET_TO_EDITBOSS
	      {
		id:			Id,							# Unique id to facilitate storing gadget_to_editboss instances in indexed datastructures like red-black trees.
		#
		get_textbuffer:		String -> Null_Or( Textpane_To_Textbuffer ),	
		get_or_make_textbuffer:	Textbuffer_Arg -> Textpane_To_Textbuffer,
		#
		get_or_make_filebuffer:	{ dirname:		String,
					  textbuffer_arg:	Textbuffer_Arg
					}
					-> Textpane_To_Textbuffer,

		get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,				# O(1) nonblocking.
		set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void,

		note_screenline:	(b2l::Editboss_To_Screenline, p2l::Textpane_To_Screenline) -> Void,
		#
		note_textpane:		(b2p::Editboss_To_Textpane, e2p::Textedit_To_Textpane, l2p::Screenline_To_Textpane)  -> Void,
		note_textedit:		(b2e::Editboss_To_Textedit, p2e::Textpane_To_Textedit                             )  -> Void,

		drop_screenline:	{ screenline_id:	iuw::Id,
					  textedit_id:		iuw::Id,
					  textpane_id:		iuw::Id
					}
					-> Void,
		#
		drop_textpane:		{ textpane_id:		iuw::Id,
					  textedit_id:		iuw::Id
					}
					-> Void,

		drop_textedit:		{ textedit_id:		iuw::Id
					}
					-> Void
	      }

	also
	Editfn_Node
	  #
	  = PLAIN_EDITFN	Plain_Editfn
	  | FANCY_EDITFN									# Not currently useful.  Intended to support fns which need to do significant work in the context of textpane.pkg (vs textbuffer-imp.pkg).

	also
	Keymap_Node
	  #
	  = EDITFN		Editfn_Node
	  | SUBKEYMAP		Keymap

	withtype
	Keymap
	  = 
	  sm::Map( Keymap_Node )

	also
	Editfn_In										# This is what  do_pass_edit_result()  passes to editfns in   src/lib/x-kit/widget/edit/textbuffer-imp.pkg
	  =
	  { args:			List( Prompted_Arg ),
	    textlines:			Textlines,
	    point:			g2d::Point,						# As in Point_And_Mark.  (Emacs nomenclature -- 'point' is the visible cursor, 'mark' if set is the other end of the selected region.)
	    mark:			Null_Or(g2d::Point),					# 
	    lastmark:			Null_Or(g2d::Point),					# Last valid value of 'mark' if any -- used to retrieve old mark values by   exchange_point_and_mark	in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
	    keystring:			String,							# User keystroke that invoked this editfn.
	    gadget_to_editboss:		Gadget_To_Editboss
	  }

	also
	Editfn = Editfn_In -> Editfn_Out

	also
	Plain_Editfn
	  =
	  { name:		String,
	    doc:		String,
	    args:		List(Promptfor),						# Technically 'parameters', but 'args' is shorter. :-)  Args to read in interactively from user, e.g. filenames and search strings.
	    editfn:		Editfn								# 
	  }

	also
	Edit_Arg										# Arg type for pass_edit_result().
	  =
	  { point_and_mark:	Point_And_Mark,
	    lastmark:		Null_Or(g2d::Point),
	    editfn_node:	Editfn_Node,
	    prompted_args:	List( Prompted_Arg ),						# Args read interactively from user.
	    #
	    widget_to_guiboss:	gt::Widget_To_Guiboss,						# Mainly for access to get_cutbuffer_contents/set_cutbuffer_contents in gadget_to_editboss.  NB: Passing gadget_to_editboss here instead results in a package cycle.
	    log_undo_info:	Bool,								# If log_undo_info is FALSE no entry will be made in the undo history.
	    keystring:		String								# User keystroke that invoked this editfn.
	  };


	Editstate
	  =
	  { textlines:		Textlines,
	    point:		g2d::Point,							# As in Point_And_Mark.
	    mark:		Null_Or(g2d::Point)						# 
	  };


	Buffermode										# A buffermode defines the semantics of a textbuffer. In particular, the keymap defines what editfns are invoked by what keystrokes.
	    =
	    BUFFERMODE
	      {
		name:		String,
		doc:		String,
		#
		keymap:		Ref(Keymap),
		parent:		Null_Or( Buffermode )						# So we can dynamically inherit keybindings from less specialized buffermodes.
	      };



	exception GADGET_TO_EDITBOSS_CRYPT Gadget_To_Editboss;


	fun find__gadget_to_editboss
	      (
		gadget_to_guiboss:	gt::Gadget_To_Guiboss,
		caller:			String
	      )
	    =
	    case (gadget_to_guiboss.find_global "gadget_to_editboss::GADGET_TO_EDITBOSS")
		#
		THE gadget_to_editboss
		    =>
		    case gadget_to_editboss.val
			#
			GADGET_TO_EDITBOSS_CRYPT gadget_to_editboss
			    =>
			    gadget_to_editboss;

			_ =>    {   msg =  sprintf "Expected Crypt of GADGET_TO_EDITBOSS_CRYPT but got Crypt of { key=>\"%s\", doc=>\"%s\" }  -- gadget_to_editboss::find__gadget_to_editboss called by %s" gadget_to_editboss.key gadget_to_editboss.doc caller;				# "Impossible."
				    log::fatal msg;
				    raise exception FAIL msg;
				};
		    esac;

		NULL =>	{   msg =  sprintf "GADGET_TO_EDITBOSS global not registered with guiboss_imp in time?! -- gadget_to_editboss::find__gadget_to_editboss called by %s" caller;				# "Impossible."
			    log::fatal msg;
			    raise exception FAIL msg;
			};
	    esac;


	empty_keymap =  sm::empty: Keymap;							# Helps clients abstract a bit from current specific implementation of keymaps.

	fun keystring_to_modemap_key (keystring: String)					# Convert keystroke string from guishim-imp-for-x.pkg (or other guishim) into traditional emacs keymap representation.
	    =
	    case keystring
		#
		"\^@"	=>	"C-@";
		"\^A"	=>	"C-a";
		"\^B"	=>	"C-b";
		"\^C"	=>	"C-c";
		"\^D"	=>	"C-d";
		"\^E"	=>	"C-e";
		"\^F"	=>	"C-f";
		"\^G"	=>	"C-g";
		"\^H"	=>	"C-h";
		"\^I"	=>	"TAB";
		"\^J"	=>	"C-j";
		"\^K"	=>	"C-k";
		"\^L"	=>	"C-l";
		"\^M"	=>	"RET";
		"\^N"	=>	"C-n";
		"\^O"	=>	"C-o";
		"\^P"	=>	"C-p";
		"\^Q"	=>	"C-q";
		"\^R"	=>	"C-r";
		"\^S"	=>	"C-s";
		"\^T"	=>	"C-t";
		"\^U"	=>	"C-u";
		"\^V"	=>	"C-v";
		"\^W"	=>	"C-w";
		"\^X"	=>	"C-x";
		"\^Y"	=>	"C-y";
		"\^Z"	=>	"C-z";
		"\^["	=>	"ESC";
		"\^\"	=>	"C-\\";
		"\^]"	=>	"C-]";
		"\^_"	=>	"C-_";
		" "	=>	"SPC";
		#
		_	=>	keystring;
	    esac;


	fun add_editfn_to_keymap
	      (
		keymap:		Keymap,
		key:		List(String),							# The strings should have been run through keystring_to_modemap_key() or be in its format.  List has one string for single-keystroke commands, two strings for single-prefix commands etc.
		keymap_node:	Keymap_Node
	      )
	    :			Keymap
	    =
	    case key
		#
		[]	 => keymap;								# Shouldn't happen.

		k ! []   => sm::set (keymap, k, keymap_node);

		k ! rest => {   subkeymap = case (sm::get (keymap, k))
						#
						THE (SUBKEYMAP subkeymap)
						    =>
						    subkeymap;					# Use existing subkeymap for this prefix key.

						_   =>  empty_keymap;				# Start a new subkeymap for this prefix key.
					    esac;

				subkeymap
				    =
				    add_editfn_to_keymap (subkeymap, rest, keymap_node);

				sm::set (keymap, k, SUBKEYMAP subkeymap);			# Silently clobber any previous non-prefix-key keymap_node associated with 'k'.
			    };
	    esac;


	fun add_editfn_to_keymap_throughout_char_range						# Emacs directly represents char ranges in keymaps, but for now we'll keep our keymaps simple.  Ram is a million times cheaper now than it was in the early 1970s when emacs was designed. :-)
	      {
		keymap:		Keymap,
		keymap_node:	Keymap_Node,
		#
		firstchar:	Char,
		lastchar:	Char
	      }
	    :			Keymap
	    =
	    {   keymap =    loop (firstchar, keymap)
			    where
				fun loop (c: Char, keymap: Keymap)
				    =
				    if (c > lastchar)
					#
					keymap;
				    else
					key = char::to_string c;
					key = keystring_to_modemap_key key;
					#
					keymap = sm::set (keymap, key, keymap_node);

					loop (char::next c,  keymap);
				    fi;
			    end;
		
		keymap;
	    };	
    };

end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
