## mode-junk.pkg
#
# Support fns for textbuffer_imp -- mostly editing		# textbuffer_imp		is from   src/lib/x-kit/widget/edit/textbuffer-imp.pkg
# fns to be bound to keystrokes.
#
# See also:
#     src/lib/x-kit/widget/edit/textpane.pkg
#     src/lib/x-kit/widget/edit/textedit.pkg
#     src/lib/x-kit/widget/edit/editboss-imp.pkg
#     src/lib/x-kit/widget/edit/textbuffer-imp.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package iuw =  issue_unique_widget_id;			# issue_unique_widget_id	is from   src/lib/x-kit/widget/gui/issue-unique-widget-id.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg
    package sm  =  string_map;					# string_map			is from   src/lib/src/string-map.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
#   package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

#   package ebt =  editboss_types;				# editboss_types		is from   src/lib/x-kit/widget/edit/editboss-types.pkg


    package que =  queue;					# queue				is from   src/lib/src/queue.pkg
    package nl  =  red_black_numbered_list;			# red_black_numbered_list	is from   src/lib/src/red-black-numbered-list.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

herein

    package mode_junk						# 
    {
	Textlines = nl::Numbered_List(String);							# In textbuffer.pkg we store our file contents in this, line by line.
	#
	Editfn_In
	  =
	  { textlines:		Textlines,
	    cursor:		g2d::Point,							# As in Cursor_And Mark.
	    mark:		Null_Or(g2d::Point),						# 
	    keystring:		String								# User keystroke that invoked this editfn.
	  };

	Editfn_Out_Option
	  #
	  = TEXTLINES		Textlines
	  | CURSOR		g2d::Point
	  | MARK		Null_Or(g2d::Point)
	  ;

	Editfn_Out										# Return   NULL    to abort. This is appropriate when operation cannot be performed, for example previous_char called at start of buffer.
	  =											# Return   THE []  otherwise, where list contains CHANGES to state.  E.g., do not return TEXTLINES unless textlines value was changed.
	  Null_Or (List( Editfn_Out_Option ) );							# One advantage of this system is that additional returns can be accomodated without breaking old code.


	Keymap_Node
	  #
	  = PLAIN_EDITFN	Plain_Editfn
	  | FANCY_EDITFN
	  | SUB_KEYMAP		Keymap

	withtype
	Keymap
	  = 
	  sm::Map( Keymap_Node )

	also
	Plain_Editfn
	  =
	  { name:		String,
	    doc:		String,
	    editfn:		Editfn_In -> Editfn_Out						# 
	  };

	fun keystring_to_modemap_key (keystring: String)					# Convert keystroke string from guishim-imp-for-x.pkg (or other guishim) into traditional emacs keymap representation.
	    =
	    case keystring
		#
		"\^@"	=>	"C-@";
		"\^A"	=>	"C-a";
		"\^B"	=>	"C-b";
		"\^C"	=>	"C-c";
		"\^D"	=>	"C-d";
		"\^E"	=>	"C-e";
		"\^F"	=>	"C-f";
		"\^G"	=>	"C-g";
		"\^H"	=>	"C-h";
		"\^I"	=>	"C-i";
		"\^J"	=>	"C-j";
		"\^K"	=>	"C-k";
		"\^L"	=>	"C-l";
		"\^M"	=>	"C-m";
		"\^N"	=>	"C-n";
		"\^O"	=>	"C-o";
		"\^P"	=>	"C-p";
		"\^Q"	=>	"C-q";
		"\^R"	=>	"C-r";
		"\^S"	=>	"C-s";
		"\^T"	=>	"C-t";
		"\^U"	=>	"C-u";
		"\^V"	=>	"C-v";
		"\^W"	=>	"C-w";
		"\^X"	=>	"C-x";
		"\^Y"	=>	"C-y";
		"\^Z"	=>	"C-z";
		"\^["	=>	"ESC";
		"\^\"	=>	"C-\\";
		"\^]"	=>	"C-]";
		"\^_"	=>	"C-_";
		" "	=>	"SPC";
		#
		_	=>	keystring;
	    esac;


	fun add_editfn_to_keymap_throughout_char_range						# Emacs directly represents char ranges in keymaps, but for now we'll keep our keymaps simple.  Ram is a million times cheaper now than it was in the early 1970s when emacs was designed. :-)
	      {
		keymap:		Keymap,
		keymap_node:	Keymap_Node,
		#
		firstchar:	Char,
		lastchar:	Char
	      }
	    :			Keymap
	    =
	    {   keymap =    loop (firstchar, keymap)
			    where
				fun loop (c: Char, keymap: Keymap)
				    =
				    if (c > lastchar)
					#
					keymap;
				    else
					key = char::to_string c;
					key = keystring_to_modemap_key key;
					#
					keymap = sm::set (keymap, key, keymap_node);

					loop (char::next c,  keymap);
				    fi;
			    end;
		
		keymap;
	    };	
    };

end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
