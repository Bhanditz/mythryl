## millboss-imp.pkg
#
# See overview comments in:
#
#     src/lib/x-kit/widget/edit/millboss-imp.api

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    package lms =  list_mergesort;				# list_mergesort		is from   src/lib/src/list-mergesort.pkg

    package ct  =  cutbuffer_types;				# cutbuffer_types		is from   src/lib/x-kit/widget/edit/cutbuffer-types.pkg
#   package ct  =  gui_to_object_theme;				# gui_to_object_theme		is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
#   package bt  =  gui_to_sprite_theme;				# gui_to_sprite_theme		is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
#   package wt  =  widget_theme;				# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

#   package os  =  guiboss_to_spritespace;			# guiboss_to_spritespace	is from   src/lib/x-kit/widget/space/sprite/guiboss-to-spritespace.pkg
#   package cs  =  guiboss_to_objectspace;			# guiboss_to_objectspace	is from   src/lib/x-kit/widget/space/object/guiboss-to-objectspace.pkg


    package boi =  spritespace_imp;				# spritespace_imp		is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;				# objectspace_imp		is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;				# widgetspace_imp		is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;				# guiboss_to_guishim		is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2s =  spritespace_to_sprite;			# spritespace_to_sprite		is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;			# objectspace_to_object		is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2b =  sprite_to_spritespace;			# sprite_to_spritespace		is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2c =  object_to_objectspace;			# object_to_objectspace		is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg

    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg
    package sm  =  string_map;					# string_map			is from   src/lib/src/string-map.pkg
    package idm =  id_map;					# id_map			is from   src/lib/src/id-map.pkg

    package sj  =  string_junk;					# string_junk			is from   src/lib/std/src/string-junk.pkg
    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

    package mt  =  millboss_types;				# millboss_types		is from   src/lib/x-kit/widget/edit/millboss-types.pkg

    package e2g =  millboss_to_guiboss;				# millboss_to_guiboss		is from   src/lib/x-kit/widget/edit/millboss-to-guiboss.pkg

    package tbi =  textmill;					# textmill			is from   src/lib/x-kit/widget/edit/textmill.pkg
#   package t2t =  textpane_to_textmill;			# textpane_to_textmill		is from   src/lib/x-kit/widget/edit/textpane-to-textmill.pkg
    package tmt =  textmill_crypts;				# textmill_crypts		is from   src/lib/x-kit/widget/edit/textmill-crypts.pkg

    package p2l =  textpane_to_screenline;			# textpane_to_screenline	is from   src/lib/x-kit/widget/edit/textpane-to-screenline.pkg
    package l2p =  screenline_to_textpane;			# screenline_to_textpane	is from   src/lib/x-kit/widget/edit/screenline-to-textpane.pkg
    package b2l =  millboss_to_screenline;			# millboss_to_screenline	is from   src/lib/x-kit/widget/edit/millboss-to-screenline.pkg
    package b2p =  millboss_to_pane;				# millboss_to_pane		is from   src/lib/x-kit/widget/edit/millboss-to-pane.pkg

    package mgm =  millgraph_millout;				# millgraph_millout		is from   src/lib/x-kit/widget/edit/millgraph-millout.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

dummy1 = make_textpane::make_textpane;	# XXX SUCKO FIXME Clumsy way to force this to compile and load. Should think of a better. The problem is that it is never called directly, just backpatches itself into a refcell, so the usual dependency mechanisms do not kick in.

herein

    package millboss_imp
    :       Millboss_Imp												# Millboss_Imp		is from   src/lib/x-kit/widget/edit/millboss-imp.api
    {
	Millboss_Option
	  #
	  =  MICROTHREAD_NAME	String											# 
	  |  ID			Id											# Stable, unique id for imp.
	  ;	

	Millboss_Arg =  List(Millboss_Option);										# Currently no required component.

	Imports = {													# Ports we use, provided by other imps.
		    millboss_to_guiboss:	e2g::Millboss_To_Guiboss
		  };
															# millboss should probably not know so much about textmill/screenline/textpane.

	Millgraph_Watchers												# Type for tracking the set of clients subscribed to a mill for mt::Millgraph updates.
	    =														#
	    mt::ipm::Map( (mt::Inport, (mt::Outport, mt::Millgraph) -> Void) );						# 

	Pane_Info
	  =
	  { pane_id:				Id,
	    pane_tag:				Int,									# We assign each pane a small positive Int tag to be displayed on modeline and used by "C-x o" (other_pane) in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
	    mill_id:				Id,									# The mill displayed in the pane.
	    millboss_to_pane:			b2p::Millboss_To_Pane							# Our port to the pane.
	  };

	Millboss_State													# Holds all nonephemeral mutable state maintained by package.
	  =
	  { mills_by_name:			Ref(  sm::Map( mt::Mill_Info ) ),					# All currently active mills, by name.
	    mills_by_id:			Ref( idm::Map( mt::Mill_Info ) ),					# All currently active mills, by id. Maintained by note_mill_info(). NEVER DELETED AS YET. XXX SUCKO FIXME.
	    mills_by_filepath:			Ref(  sm::Map( mt::Mill_Info ) ),					# All currently active mills WHICH ARE OPEN ON A FILE, by filepath. (We expect this to typically be a full pathname like "/home/jayne/foo.txt", so as to help avoid having multiple buffers open on one file.)
	    #
	    millwatches:			Ref( mt::mwm::Map (mt::Millwatch )), 					# Tracks which mill inports are watching which outports, maintained via note_millwatch + drop_millwatch.
	    #
	    pending_pane_mail:			Ref( idm::Map( List( Crypt ) ) ),					# Messages to panes which have not yet registered with us, indexed by pane_id.	To preserve message order we reverse these lists before delivering them  (although message order should rarely if ever matter).
	    panes_by_id:			Ref( idm::Map( Pane_Info	   ) ),
	    #
	    name:				Ref( String		      )						# Name of millboss for display purposes.
	  };

	Me_Slot = Mailslot( { imports:		Imports,
			      me:		Millboss_State,
			      millboss_arg:	Millboss_Arg,
			      run_gun':		Run_Gun,
			      end_gun':		End_Gun
			    }
			  );

	Exports	= {													# Ports we provide for use by other imps.
		  };


	Millboss_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);


	Runstate =    {													# These values will be statically globally visible throughout the code body for the imp.
			id:			Id,
			me:			Millboss_State,								# 
			millboss_arg:		Millboss_Arg,
			imports:		Imports,								# Imps to which we send requests.
			to:			Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
			#												#
			millgraph_outport:	mt::Outport,								# 
			millgraph_watchers:	Ref( Millgraph_Watchers ),						# 
			#												#
			end_gun':		End_Gun									# We shut down the microthread when this fires.
		      };

	Millboss_Q    = Mailqueue( Runstate -> Void );



	fun note_mill_info
	      (
		me:				Millboss_State,
		mill_info:			mt::Mill_Info
	      )	
	    =
	    {   me.mills_by_id   := idm::set (*me.mills_by_id,   mill_info.mill_id, mill_info);
		me.mills_by_name :=  sm::set (*me.mills_by_name, mill_info.name,    mill_info);

		case mill_info.filepath
		    #
		    THE filepath
			=>
			{   me.mills_by_filepath
				:=
				sm::set (*me.mills_by_filepath, filepath,  mill_info);
			};
		    NULL => ();
		esac;
	    };

	fun run ( millboss_q:			Millboss_Q,								# 
		  #
		  runstate as
		  {													# These values will be statically globally visible throughout the code body for the imp.
		    id:				Id,
		    me:				Millboss_State,								# 
		    millboss_arg:		Millboss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    #													#
		    millgraph_outport:		mt::Outport,								# 
		    millgraph_watchers:		Ref( Millgraph_Watchers ),						# 
		    #													#
		    end_gun':			End_Gun									# 
		  }
		)
	    =
	    {	loop ();
	    }
	    where


		#
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    end_gun'                        ==>  shut_down_millboss_imp',
			    take_from_mailqueue' millboss_q ==>  do_millboss_plea
			];

			loop ();
		    }	
		    where
			fun do_millboss_plea  thunk
			    =
			    thunk runstate;
			#
			fun shut_down_millboss_imp' ()
			    =
			    {
				thread_exit { success => TRUE };							# Will not return.	
			    };
		    end;
	    end;	



	#
	fun startup   (id: Id,   reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()				# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		app_to_mill												# Generic interface supported by all mills.  Guiboss pretends to be a kinda-sorta mill itself to allow clients to subscribe to its Millgraph Outport via standard intermill connection protocols.
		    =
		    mt::APP_TO_MILL
		      {
			id,
			#
			get_dirty,
			pass_dirty,

			get_filepath,
			set_filepath,
			pass_filepath,

			get_name,
			set_name,
			pass_name,

			get_millouts,
			pass_millouts,

			get_millins,
			pass_millins,

			reload_from_file,
			save_to_file,

			make_pane
		      };

		mill_to_millboss
		    =
		    mt::MILL_TO_MILLBOSS
		      {
			id,
			get_textmill,
			make_textmill,
			get_or_make_textmill,
			get_or_make_filebuffer,
			#
			get_cutbuffer_contents,
			set_cutbuffer_contents,
			#
			note_pane,
			drop_pane,
			mail_pane,
			#
			get_panes_by_id,
			get_mills_by_name,
			get_mills_by_id,
			#
			note_millwatch,
			drop_millwatch,
			#
			app_to_mill											# Include App_To_Mill as a sub-interface to allow clients to subscribe to our Millgraph Outport via standard intermill connection protocols.
		      };

		mt::mill_to_millboss__global
		    :=
		    THE mill_to_millboss;

		exports	    = { };

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, exports));							# Return value from millboss_egg'().

		(take_from_mailslot  me_slot)										# Imports from millboss_egg'().
		    ->
		    { me, millboss_arg, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		millgraph_watchers =  REF mt::ipm::empty;

		millgraph_outport
		  =
		  { mill_id	 => id,
		    outport_name => "millgraph"
		  };

		run ( millboss_q,		 									# Will not return.
		      { id,
			me,
			millboss_arg,
			imports,
			to,
			#
			millgraph_outport,
			millgraph_watchers,
			#
			end_gun'
		      }
		);
	    }
	    where
		millboss_q     =  make_mailqueue (get_current_microthread()):  Millboss_Q;

		fun make_millgraph  (r:  Runstate):  mt::Millgraph
		    =
		    {
			millgraph
			  =
			  { millouts => mt::opm::empty,
			    millins  => mt::ipm::empty,
			    mills    =>     idm::empty
			  };

			millgraph;
		    };

		fun tell_millgraph_watchers
		      (
			millgraph_watchers:		Millgraph_Watchers,								# 
			millgraph:			mt::Millgraph,
			r:				Runstate
		      )
		    =
		    mt::ipm::apply   tell_watcher   millgraph_watchers
		    where
			fun tell_watcher
			      (
				inport:		 mt::Inport,											# Unique id identifying this watcher.
				watcher:	(mt::Outport, mt::Millgraph) -> Void							# 
			      )
			    =
			    {   outport = r.millgraph_outport;
				#
				watcher  (outport, millgraph);
			    };
		    end;

		fun tell_millgraph_watcher_current_state
		      (
			watchfn:		(mt::Outport, mt::Millgraph) -> Void,
			r:			Runstate
		      )	
		    =
		    {   outport = r.millgraph_outport;
			#
			millgraph =  make_millgraph r;

			watchfn  (outport, millgraph);
		    };

		fun tell_millgraph_watchers_current_state
		      (
			r:			Runstate
		      )
		    =
		    mt::ipm::apply   tell_watcher   *r.millgraph_watchers
		    where
			fun tell_watcher
			      (
				inport:		 mt::Inport,											# 
				watchfn:	(mt::Outport, mt::Millgraph) -> Void							# 
			      )
			    =
			    tell_millgraph_watcher_current_state (watchfn, r);
		    end;


		fun note_textmill_statechange												# Track textmill name changes.
		      (
			outport:	mt::Outport,
			statechange:	mt::Textmill_Statechange
		      )
		    =
		    case statechange
			#
			mt::NAME_CHANGED { was: String, now: String }
			    =>
			    put_in_mailqueue  (millboss_q,
				#
				\\ ({ me, ... }: Runstate)
				    =
				    case (idm::get  (*me.mills_by_id,  outport.mill_id))
					#
					THE mill_info
					    =>
					    {	mill_info								# Remember new name of mill.  This is one of those places where functional record update support in the compiler would be nice.
						  =
						  { name	 =>  now,						# The updated field.
						    freshness	 =>  id_to_int (issue_unique_id()),			# Might as well update freshness too.
						    #
						    mill_id      =>  mill_info.mill_id,					# The unchanged fields.
						    app_to_mill  =>  mill_info.app_to_mill,				#
						    pane_to_mill =>  mill_info.pane_to_mill,				#
						    filepath     =>  mill_info.filepath					#
						  };

						me.mills_by_name :=  sm::drop (*me.mills_by_name, was);			# Forget   old name of mill.
						note_mill_info (me, mill_info);						# Remember mill under its new name.
					    };
					#
					NULL =>
					    {   msg =  sprintf "outport.id (%d) not in *me.mills_by_id!" (id_to_int outport.mill_id);
						log::fatal msg;
						raise exception DIE msg;
					    };
				    esac
			    );	


			mt::TEXTSTATE_CHANGED _ =>  ();									# We list the rest explicitly here so as to draw a compile error if a new one gets added without us being updated.
			mt::UNDO 	      _ =>  ();
			mt::FILEPATH_CHANGED  _ =>  ();
			mt::READONLY_CHANGED  _ =>  ();
			mt::DIRTY_CHANGED     _ =>  ();
		    esac;

		#################################################################################
		# guiboss interface fns::
		#
		#

		fun find_first_unused_pane_tag										# 
		      (													# 
			me:		Millboss_State
		      ):		Int
		    =
		    {	panes = idm::vals_list  *me.panes_by_id;
			panes = lms::sort_list gt panes
				    where
					fun gt ( pane1: Pane_Info,
						 pane2: Pane_Info
					       )
					    =
					    pane1.pane_tag > pane2.pane_tag;
				    end;
			#
			try (panes, 1)											# All pane tags should be greater than zero.
			    where
				fun try ((pane: Pane_Info) ! rest,  n)							# Search sequentially through sorted list for first unused pane tag value.
					=>
					if (pane.pane_tag > n)   n;
					else			 try (rest, n+1);
					fi;

				    try ([], n) => n;
				end;
			    end;
		    };	

		fun note_pane												# Used to inform us of newly created panes, and also to update us when the mill associated with a pane changes.
		      {													# (Currently the only time we change the mill associated with a pane is in find_file -- fundamental-mode.pkg's switch_to_mill() just creates a new pane.)
			millboss_to_pane:			b2p::Millboss_To_Pane,
			mill_id:				Id
		      }
		    =
		    put_in_mailqueue  (millboss_q,
			#
			\\ (r as { id, me, ... }: Runstate)
			    =
			    {   pane_id  =  millboss_to_pane.pane_id;
				#
				pane_tag =  case (idm::get (*me.panes_by_id, pane_id))					# We assign each pane the smallest unused positive tag, to be displayed on modeline and used by "C-x o" (other_pane) in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
						#
						THE pane_info
						    =>
						    pane_info.pane_tag;							# We already knew about pane, so retain its existing pane_tag.

						NULL =>
						    {   pane_tag = find_first_unused_pane_tag  me;			# This is a new pane.
							millboss_to_pane.note_tag    pane_tag;				# Tell the pane what tag we assigned it.
							pane_tag;
						    };
					    esac;

				me.panes_by_id										# Remember what we've learned/decided about this pane.
				    :=
				    idm::set  (*me.panes_by_id,  pane_id,  pane_info)
					where
					    pane_info = { pane_id,
							  pane_tag,
							  mill_id,
							  millboss_to_pane
							};
					end;


				case (idm::get (*me.pending_pane_mail, pane_id))					# Deliver any pending mail for this pane.
				    #
				    THE (pending_pane_mail:  List( Crypt ))
					=>
					{   apply   do_crypt   (reverse pending_pane_mail)				# We reverse to restore original message ordering.
						    #
						    where
							fun do_crypt (crypt: Crypt)
							    =
							    millboss_to_pane.note_crypt  crypt;
						    end;

					    me.pending_pane_mail							# Forget about delivered mail, so we don't deliver it again.
						:=
						idm::drop  (*me.pending_pane_mail,   pane_id);
					};
				    NULL => ();
				esac;

				case (idm::get (*me.mills_by_id, mill_id))						# Freshen mill.
				    #
				    THE mill_info
					=>
					{   freshness =  id_to_int (issue_unique_id());
					    #
					    mill_info =	  { freshness,							# Updated field.
							    #
							    mill_id	  =>  mill_info.mill_id,			# Unchanged fields.  Oh, for functional record updates! :-)
							    app_to_mill	  =>  mill_info.app_to_mill,			#
							    pane_to_mill  =>  mill_info.pane_to_mill,			#	
							    name	  =>  mill_info.name,				#
							    filepath	  =>  mill_info.filepath			#
							  };

					    note_mill_info (me, mill_info);
					};

				    NULL => ();										# Mill has not registered yet.
				esac;
			    }
		    );
		fun mail_pane												# Send something to a pane. If the pane is not yet registered with millboss, the crypt will be queued up and delivered when the pane registers. Used for linking up screenline.pkg instances to textpane.pkg instances at startup (etc).
		      (													# Using a Crypt here makes the mechanism general at a small cost in typesafety.  In particular, it buys us valuable modularity by keeping millboss from needing to know the types of the interfaces between textpane and screenline (etc).
			pane_id:	Id,										#
			crypt:		Crypt
		      )
		    =
		    put_in_mailqueue  (millboss_q,
			#
			\\ (r as { id, me, ... }: Runstate)
			    =
			    case (idm::get (*me.panes_by_id, pane_id))							# Has the given pane registered with us yet?
				#
				THE pane_info										# Yes,
				    =>											# so
				    pane_info.millboss_to_pane.note_crypt  crypt;					# deliver the mail immediately.

				NULL =>											# No, so queue up the mail for later delivery.
				    #
				    case (idm::get (*me.pending_pane_mail, pane_id))					# Is there already pending mail for this pane?
					#
					THE pending_pane_mail								# Yes,
					    =>										# so
					    me.pending_pane_mail							# prepend
						:=									# new mail
						idm::set ( *me.pending_pane_mail,					# to
							   pane_id,							# existing
							   crypt ! pending_pane_mail					# queued-mail
							 );								# list.

					NULL =>					      					# No, so
					    me.pending_pane_mail							# start a new
						:=									# list of
						idm::set (*me.pending_pane_mail,  pane_id,  [ crypt ]);			# pending mail for that pane.
				    esac;
			    esac
		    );
		fun drop_pane
		      {
			pane_id:		Id
		      }
		    =
		    put_in_mailqueue  (millboss_q,
			#
			\\ (r as { id, me, ... }: Runstate)
			    =
			    me.panes_by_id
				:=
				idm::drop  (*me.panes_by_id,   pane_id)
		    );
		fun get_panes_by_id ()
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( idm::Map(mt::Pane_Info) );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ (r as { id, me, ... }: Runstate)
				=
				{   result = idm::map  do_pane  *me.panes_by_id
						where
						    fun do_pane ({ pane_id, pane_tag, mill_id, ... }: Pane_Info)
							=
							{ pane_id, pane_tag, mill_id };
						end;	

				    put_in_oneshot (reply_oneshot, result);
				}
			);
			get_from_oneshot  reply_oneshot;
		    };
		fun get_mills_by_name ()
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( sm::Map(mt::Mill_Info) );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ (r as { id, me, ... }: Runstate)
				=
				{   result = *me.mills_by_name;
				    #
				    put_in_oneshot (reply_oneshot, result);
				}
			);
			get_from_oneshot  reply_oneshot;
		    };
		fun get_mills_by_id ()
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( idm::Map(mt::Mill_Info) );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ (r as { id, me, ... }: Runstate)
				=
				{   result = *me.mills_by_id;
				    #
				    put_in_oneshot (reply_oneshot, result);
				}
			);
			get_from_oneshot  reply_oneshot;
		    };

		fun note_millwatch (millwatch:	mt::Millwatch)					# Remember new instance of inport on one mill watching outport on another mill.
		    =
		    {   put_in_mailqueue  (millboss_q,
			    #
			    \\ (r as { id, me, ... }: Runstate)
				=
				{   key = { inport  =>  millwatch.millin.inport,
					    outport =>  millwatch.millout.outport
					  };

				    me.millwatches
					:=
					mt::mwm::set (*me.millwatches, key, millwatch);
				}
			);
		    };
		fun drop_millwatch (key:  mt::millwatch_key::Key)				# Opposite of above: Forget that input port was watching output port.
		    =
		    {   put_in_mailqueue  (millboss_q,
			    #
			    \\ (r as { id, me, ... }: Runstate)
				=
				{   
				    me.millwatches
					:=
					mt::mwm::drop (*me.millwatches, key);
				}
			);
		    };



		stipulate
		    cutbuffer_contents =  REF (ct::PARTLINE "");
		herein
		    fun get_cutbuffer_contents ()
			=
			*cutbuffer_contents;										# We do this in caller's thread (not millboss thread) for speed and to reduce risk of deadlock.

		    fun set_cutbuffer_contents (new_contents:	ct::Cutbuffer_Contents)
			=
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				cutbuffer_contents :=  new_contents							# We do this in the millboss thread to ensure cutbuffer_contents value remains stable over any millboss_imp call, just as good practice.
			);
		end;

		fun uniquify_name											# Convert "foo" into "foo<1>" or "foo<2>" or such in order to avoid conflicting with any existing name.
		      (
			me:		Millboss_State,
			name:		String
		      )
		    :			String
		    =
		    case (sm::get (*me.mills_by_name, name))
			#
			NULL => name;											# Name is already unique.

			THE _ =>
			    uniquify_name' 0
			    where
				fun uniquify_name' (i: Int)
				    =
				    {   name' = sprintf "%s<%d>" name i;
					#
					case (sm::get (*me.mills_by_name, name'))
					    #
					    NULL  =>  name';								# Modified name is now unique.
					    THE _ =>  uniquify_name' (i + 1);						# Modified name already exists, try one number higher.
					esac;
				    };
			    end;
		    esac;


		fun get_textmill   (name: String)
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Null_Or( mt::Textpane_To_Textmill ) );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				case (tmt::get__null_or_textpane_to_textmill__from__null_or_textmill_info
					 (sm::get (*me.mills_by_name, name))
				     )
				    #
				    THE textpane_to_textmill =>    put_in_oneshot (reply_oneshot, THE textpane_to_textmill);
				    NULL 	             =>    put_in_oneshot (reply_oneshot, NULL);
				esac
			);

			get_from_oneshot  reply_oneshot;
		    };

		fun make_textmill											# Create a buffer, If an existing buffer has given name, modify the new buffer's name to make it unique.
		      (
			textmill_arg
			as
			{ name:			String,
			  textmill_options:	List( mt::Textmill_Option )
			}:			mt::Textmill_Arg
		      )
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mt::Textpane_To_Textmill );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				{   name =  uniquify_name (me, name);							# Convert "foo" into "foo<1>" or "foo<2>" or such in order to avoid conflicting with any existing name.
				    #
				    egg =  tbi::make_textmill_egg  textmill_arg;
				    #
				    (egg ())
					->
					( textmill_exports:	tbi::Exports,
					  egg':		       (tbi::Imports, Run_Gun, End_Gun) -> Void
					);

				    textmill_imports
				      =
				      { };

				    (make_run_gun ()) ->   { run_gun', fire_run_gun };
				    (make_end_gun ()) ->   { end_gun', fire_end_gun };

				    egg' (textmill_imports, run_gun', end_gun');

				    fire_run_gun ();

				    textmill_exports
					->
					{  textpane_to_textmill  as  mt::TEXTPANE_TO_TEXTMILL  tb  };

				    mill_info =   { name,
						    freshness	 =>  id_to_int (issue_unique_id()),
						    mill_id      =>  tb.id,
						    filepath	 =>  NULL,
						    app_to_mill	 =>  tb.app_to_mill,
						    pane_to_mill =>  tmt::encrypt__textpane_to_textmill  textpane_to_textmill
						  };

				    note_mill_info (me, mill_info);

				    watcher = { mill_id => id, inport_name => "" }:  mt::Inport;

				    tb.note__textmill_statechange__watcher (watcher, NULL, note_textmill_statechange);	# We subscribe just to track textmill name changes.

				    put_in_oneshot (reply_oneshot, textpane_to_textmill);
			    }
			);

			get_from_oneshot  reply_oneshot;
		    };

		fun get_or_make_textmill										# Find a buffer by name; if no such buffer exists, create one.  Buffer may or may not have an associated file.
		      (
			textmill_arg
			as
			{ name:			String,
			  textmill_options:	List( mt::Textmill_Option )
			}:			mt::Textmill_Arg
		      )
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mt::Textpane_To_Textmill );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				case (tmt::get__null_or_textpane_to_textmill__from__null_or_textmill_info
					 (sm::get (*me.mills_by_name, name))
				     )
				    #
				    THE textpane_to_textmill
					=> 
					put_in_oneshot (reply_oneshot, textpane_to_textmill);
				    #
				    NULL =>
					{   egg =  tbi::make_textmill_egg  textmill_arg;
					    #
					    (egg ())
						->
						( textmill_exports:	tbi::Exports,
						  egg':		       (tbi::Imports, Run_Gun, End_Gun) -> Void
						);

					    textmill_imports
					      =
					      { };

					    (make_run_gun ()) ->   { run_gun', fire_run_gun };
					    (make_end_gun ()) ->   { end_gun', fire_end_gun };

					    egg' (textmill_imports, run_gun', end_gun');

					    fire_run_gun ();

					    textmill_exports
						->
						{ textpane_to_textmill as mt::TEXTPANE_TO_TEXTMILL tb
						};

					    mill_info = { name,
							  freshness    =>  id_to_int (issue_unique_id()),
							  mill_id      =>  tb.id,
							  filepath     =>  NULL,
							  app_to_mill  =>  tb.app_to_mill,
							  pane_to_mill =>  tmt::encrypt__textpane_to_textmill  textpane_to_textmill
							};

					    note_mill_info (me, mill_info);

					    watcher = { mill_id => id, inport_name => "" }:  mt::Inport;

					    tb.note__textmill_statechange__watcher (watcher, NULL, note_textmill_statechange);	# We subscribe just to track textmill name changes.

					    put_in_oneshot (reply_oneshot, textpane_to_textmill);
					};
				esac
			);

			get_from_oneshot  reply_oneshot;
		    };

		fun get_or_make_filebuffer										# Find buffer open on given file.  If no such buffer exists, create one.  NB: We do our best to avoid having more than one buffer open on a given file.  (Multiple textpanes may be open on one buffer; that is a separate issue.)
		      (	
			filepath:		String
		      )
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mt::Textpane_To_Textmill );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				{   name = uniquify_name (me, sj::basename filepath);
				    #
				    textmill_options =  [];
				    textmill_arg     =  { name, textmill_options };

				    egg =  tbi::make_textmill_egg  textmill_arg;
				    #
				    (egg ())
					->
					( textmill_exports:	tbi::Exports,
					  egg':		       (tbi::Imports, Run_Gun, End_Gun) -> Void
					);

				    textmill_imports
				      =
				      { };

				    (make_run_gun ()) ->   { run_gun', fire_run_gun };
				    (make_end_gun ()) ->   { end_gun', fire_end_gun };

				    egg' (textmill_imports, run_gun', end_gun');

				    fire_run_gun ();

				    textmill_exports ->  { textpane_to_textmill  as  mt::TEXTPANE_TO_TEXTMILL tb
							 };

				    tb.app_to_mill   ->  mt::APP_TO_MILL am;

				    mill_info =   { name,
						    freshness    =>  id_to_int (issue_unique_id()),
						    mill_id	 =>  tb.id,
						    filepath     =>  THE filepath,
						    app_to_mill	 =>  tb.app_to_mill,
						    pane_to_mill =>  tmt::encrypt__textpane_to_textmill  textpane_to_textmill
						  };

				    note_mill_info (me, mill_info);

				    watcher = { mill_id => id, inport_name => "" }:  mt::Inport;

				    tb.note__textmill_statechange__watcher (watcher, NULL, note_textmill_statechange);		# We subscribe just to track textmill name changes.

				    am.set_filepath (THE filepath);

				    am.reload_from_file ();

				    put_in_oneshot (reply_oneshot, textpane_to_textmill);
				}
			);

			get_from_oneshot  reply_oneshot;
		    };

		#################################################################################
		# App_To_Mill interface fns::
		#
		#
		fun make_pane ():	gt::Gp_Widget_Type												# PUBLIC.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Gp_Widget_Type );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				{
# 				    filepath	  =  *me.filepath;
# 				    textpane_hint =  *me.textpane_hint;
# 				    #
# 				    gp_widget =	*make_pane_hack { textpane_to_textmill, filepath, textpane_hint };

# XXX BUGGO FIXME TBD

				    gp_widget = gt::NULL_WIDGET;

				    put_in_oneshot (reply_oneshot, gp_widget);
				}
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #

		fun get_dirty ()														# PUBLIC.  We don't actually support a 'dirty' flag on millboss, so this is always FALSE.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Bool );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, FALSE)
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #
		fun pass_dirty  (replyqueue: Replyqueue)  (reply_handler: Bool -> Void)								# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Bool );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, FALSE)
			);
 
			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };

		fun set_filepath (filepath: Null_Or( String ))											# PUBLIC.  We don't support a filepath on millboss, so this is a no-op.
		    =
		    {	put_in_mailqueue  (millboss_q,
			    #
			    \\ (runstate as { id, me, millgraph_watchers, ... }: Runstate)
				=
				{
				}
			);

		    };
		    #
		fun get_filepath ()														# PUBLIC.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Null_Or( String ) );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, millgraph_watchers, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, NULL)										# We don't support a filepath on millboss, so this is always NULL.
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #
		fun pass_filepath (replyqueue: Replyqueue)  (reply_handler: Null_Or( String ) -> Void)						# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Null_Or( String ) );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, NULL)										# We don't support a filepath on millboss, so this is always NULL.
			);
 
			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };

		fun set_name (name: String)													# PUBLIC.
		    =
		    {	put_in_mailqueue  (millboss_q,
			    #
			    \\ (runstate as { id, me, millgraph_watchers, ... }: Runstate)
				=
				{
				    me.name := name;
				}
			);
		    };
		    #
		fun get_name ()															# PUBLIC.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( String );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.name)
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #
		fun pass_name  (replyqueue: Replyqueue)  (reply_handler: String -> Void)							# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( String );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.name)
			);
 
			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };

		fun note_millgraph_watcher													# PUBLIC.
		      (
			watcher:		mt::Inport,											# 
			millin:			Null_Or(mt::Millin),										# This will be NULL if watcher is not another mill (e.g. a pane).
			watchfn:		(mt::Outport, mt::Millgraph) -> Void								# 
		      )	
		    =
		    {   put_in_mailqueue  (millboss_q,
			    #
			    \\ (runstate as { id, me, millgraph_watchers, ... }: Runstate)
				=
				{   millgraph_watchers
					:=
					mt::ipm::set ( *millgraph_watchers,
							watcher,
							(watcher, watchfn)
						     );

				    tell_millgraph_watcher_current_state (watchfn, runstate);							# Start out new watcher with current state.
				}
			);
		    };
		    #
		fun drop_millgraph_watcher (watcher:  mt::Inport)									# PUBLIC.
		    =
		    {   
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, millgraph_watchers, ... }: Runstate)
				=
				millgraph_watchers
				    :=
				    mt::ipm::drop (*millgraph_watchers, watcher)
			);
		    };


		stipulate
		    fun make_millouts (r: Runstate):			mt::opm::Map(mt::Millout)						# Construct a description of all our outports, for client use.
			=
			{   millouts =  mt::opm::empty;												# Start with an empty outport map.
			    #
			    millouts =  mt::opm::set (millouts, outport, millout)								# Add our millgraph outport.
					where													#
					    outport = r.millgraph_outport;									#
					    #													#
					    millgraph_millout											#
					      =													#
					      { note_watcher =>  note_millgraph_watcher,							#
						drop_watcher =>  drop_millgraph_watcher								#
					      };												#
																		#
					    millout  =  mgm::wrap__millgraph_millout								# Wrap it so millboss, plugboard &tc don't need to know about port-specific types.
							  (											#
							    outport,										#
							    millgraph_millout									#
							  );											#
					end;

			    millouts;														# Return map defining all our our outports.
			};
		herein
		    fun get_millouts ():	mt::opm::Map(mt::Millout)									# PUBLIC.  List outport available to watch.
			=
			{   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mt::opm::Map(mt::Millout) );
			    #
			    put_in_mailqueue  (millboss_q,
				#
				\\ (runstate: Runstate)
				    =
				    put_in_oneshot (reply_oneshot,  make_millouts runstate)
			    );

			    get_from_oneshot  reply_oneshot;
			};

		    fun pass_millouts														# PUBLIC.  Pass output streams available to watch.
			    (replyqueue:	Replyqueue)
			    (replyhandler:	(mt::opm::Map(mt::Millout) -> Void))
			:			Void
			=
			{   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mt::opm::Map(mt::Millout) );
			    #
			    put_in_mailqueue  (millboss_q,
				#
				\\ (runstate: Runstate)
				    =
				    put_in_oneshot (reply_oneshot,  make_millouts runstate)
			    );

			    put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> replyhandler);
			};
		end;

		stipulate
		    fun make_millins (r: Runstate):	mt::ipm::Map(mt::Millin)								# Construct a description of all our inports, for client use.
			=
			{   millins =  mt::ipm::empty;												# Start with an empty inport map.
			    #															# We currently have no input ports. If you need to add one, crib from (e.g.)  src/lib/x-kit/widget/edit/textmill.pkg
			    millins;														# Return map defining all our our inports.
			};
		herein
		    fun get_millins ():	mt::ipm::Map(mt::Millin)										# PUBLIC.  List input streams available to set.
			=
			{   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mt::ipm::Map(mt::Millin) );
			    #
			    put_in_mailqueue  (millboss_q,
				#
				\\ (runstate: Runstate)
				    =
				    put_in_oneshot (reply_oneshot,  make_millins runstate)
			    );

			    get_from_oneshot  reply_oneshot;
			};
		    
		    fun pass_millins														# PUBLIC.  Pass input streams available to set.
			    (replyqueue:	Replyqueue)
			    (replyhandler:	(mt::ipm::Map(mt::Millin) -> Void))
			:			Void
			=
			{   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mt::ipm::Map(mt::Millin) );
			    #
			    put_in_mailqueue  (millboss_q,
				#
				\\ (runstate: Runstate)
				    =
				    put_in_oneshot  (reply_oneshot,  make_millins runstate)
			    );

			    put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> replyhandler);
			};
		end;

		fun reload_from_file  ()													# PUBLIC.  We don't support a filepath or state save/restore so this is a no-op.
		    =
		    {   put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				()
			);
		    };
		    #
		fun save_to_file  ()														# PUBLIC.  We don't support a filepath or state save/restore so this is a no-op.
		    =
		    {   put_in_mailqueue  (millboss_q,
			    #
			    \\ (runstate as  { id, me, millgraph_watchers, ... }: Runstate)
				=
				()
			);
		    };
	    end;


	#
	fun process_options (options: List(Millboss_Option), { name, id })
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME	n) =>   my_name			:=  n;
			do_option (ID			i) =>   my_id                   :=  i;
		    end;
		end;

		{ name			=>  *my_name,
		  id 			=>   *my_id
		};
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_millboss_egg																# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	      (millboss_arg:		Millboss_Arg)													# Called (only) by startup()	in   src/lib/x-kit/widget/gui/guiboss-imp.pkg
	    =
	    {	millboss_arg ->  (millboss_options);													# Currently no guiboss_needs component, so this is a no-op.
		#
		(process_options
		  ( millboss_options,
		    { name		=> "millboss",
		      id		=>  id_zero
		    }
		) )
		    ->
		    { name,
		      id
		    };
	
		my (id, millboss_options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();														# Allocate unique imp id.
			(id, ID id ! millboss_options);													# Make our id stable across stop/restart cycles.
		    else
			(id, millboss_options);
		    fi;

		millboss_arg = (millboss_options);													# Currently no guiboss_needs component, so this is a no-op.

		me =  {	mills_by_name	  =>  REF  sm::empty,												# All currently active mills, by name.
			mills_by_id	  =>  REF idm::empty,												# All currently active mills, by id.
			mills_by_filepath =>  REF  sm::empty,												# All currently active mills WHICH ARE OPEN ON A FILE, by filename.
			#
			millwatches	  =>  REF  mt::mwm::empty,						 					# Everything we know about mill inports watching mill outports.
			#
			pending_pane_mail =>  REF idm::empty,												# Messages to panes which have not yet registered with us, indexed by pane_id.	To preserve message order we reverse these lists before delivering them  (although message order should rarely if ever matter).
			panes_by_id	  =>  REF idm::empty,												# All currently active panes, by id.
			#
			name		  =>  REF "millboss"												# Name of millboss-imp for display purposes.
					
		      };

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );						# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));									# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3															# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, millboss_arg, imports, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2015,
## released per terms of SMLNJ-COPYRIGHT.
