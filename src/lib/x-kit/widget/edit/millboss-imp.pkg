## millboss-imp.pkg
#
# See overview comments in:
#
#     src/lib/x-kit/widget/edit/millboss-imp.api

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    package lms =  list_mergesort;				# list_mergesort		is from   src/lib/src/list-mergesort.pkg

    package ct  =  cutbuffer_types;				# cutbuffer_types		is from   src/lib/x-kit/widget/edit/cutbuffer-types.pkg
#   package ct  =  gui_to_object_theme;				# gui_to_object_theme		is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
#   package bt  =  gui_to_sprite_theme;				# gui_to_sprite_theme		is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
#   package wt  =  widget_theme;				# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

#   package os  =  guiboss_to_spritespace;			# guiboss_to_spritespace	is from   src/lib/x-kit/widget/space/sprite/guiboss-to-spritespace.pkg
#   package cs  =  guiboss_to_objectspace;			# guiboss_to_objectspace	is from   src/lib/x-kit/widget/space/object/guiboss-to-objectspace.pkg


    package boi =  spritespace_imp;				# spritespace_imp		is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;				# objectspace_imp		is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;				# widgetspace_imp		is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;				# guiboss_to_guishim		is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2s =  spritespace_to_sprite;			# spritespace_to_sprite		is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;			# objectspace_to_object		is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2b =  sprite_to_spritespace;			# sprite_to_spritespace		is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2c =  object_to_objectspace;			# object_to_objectspace		is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg

    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg
    package sm  =  string_map;					# string_map			is from   src/lib/src/string-map.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

    package mt  =  millboss_types;				# millboss_types		is from   src/lib/x-kit/widget/edit/millboss-types.pkg

#   package g2b =  gadget_to_millboss;				# gadget_to_millboss		is from   src/lib/x-kit/widget/edit/gadget-to-millboss.pkg
    package e2g =  millboss_to_guiboss;				# millboss_to_guiboss		is from   src/lib/x-kit/widget/edit/millboss-to-guiboss.pkg

    package tbi =  textmill;					# textmill			is from   src/lib/x-kit/widget/edit/textmill.pkg
#   package t2t =  textpane_to_textmill;			# textpane_to_textmill		is from   src/lib/x-kit/widget/edit/textpane-to-textmill.pkg
    package tmt =  textmill_crypts;				# textmill_crypts		is from   src/lib/x-kit/widget/edit/textmill-crypts.pkg

    package p2l =  textpane_to_screenline;			# textpane_to_screenline	is from   src/lib/x-kit/widget/edit/textpane-to-screenline.pkg
    package l2p =  screenline_to_textpane;			# screenline_to_textpane	is from   src/lib/x-kit/widget/edit/screenline-to-textpane.pkg
    package b2l =  millboss_to_screenline;			# millboss_to_screenline	is from   src/lib/x-kit/widget/edit/millboss-to-screenline.pkg
    package b2p =  millboss_to_pane;				# millboss_to_pane		is from   src/lib/x-kit/widget/edit/millboss-to-pane.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

dummy1 = make_textpane::make_textpane;	# XXX SUCKO FIXME Clumsy way to force this to compile and load. Should think of a better. The problem is that it is never called directly, just backpatches itself into a refcell, so the usual dependency mechanisms do not kick in.

herein

    package millboss_imp
    :       Millboss_Imp												# Millboss_Imp		is from   src/lib/x-kit/widget/edit/millboss-imp.api
    {
	Millboss_Option
	  #
	  =  MICROTHREAD_NAME	String											# 
	  |  ID			Id											# Stable, unique id for imp.
	  ;	

	Millboss_Arg =  List(Millboss_Option);										# Currently no required component.

	Imports = {													# Ports we use, provided by other imps.
		    millboss_to_guiboss:	e2g::Millboss_To_Guiboss
		  };
															# millboss should probably not know so much about textmill/screenline/textpane.
	Pane_Info
	  =
	  { pane_id:				Id,
	    pane_tag:				Int,									# We assign each pane a small positive Int tag to be displayed on modeline and used by "C-x o" (other_pane) in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
	    mill_id:				Id,									# The mill displayed in the pane.
	    millboss_to_pane:			b2p::Millboss_To_Pane							# Our port to the pane.
	  };

	Millboss_State													# Holds all nonephemeral mutable state maintained by package.
	  =
	  { mills_by_name:			Ref( sm::Map( mt::Mill_Info ) ),					# All currently active mills, by name.
	    mills_by_id:			Ref( im::Map( mt::Mill_Info ) ),					# All currently active mills, by id.
	    mills_by_filepath:			Ref( sm::Map( mt::Mill_Info ) ),					# All currently active mills WHICH ARE OPEN ON A FILE, by filepath. (We expect this to typically be a full pathname like "/home/jayne/foo.txt", so as to help avoid having multiple buffers open on one file.)
	    #
	    pending_pane_mail:			Ref( im::Map( List( Crypt ) ) ),					# Messages to panes which have not yet registered with us, indexed by pane_id.	To preserve message order we reverse these lists before delivering them  (although message order should rarely if ever matter).
	    panes_by_id:			Ref( im::Map( Pane_Info	    ) )
	  };

	Me_Slot = Mailslot( { imports:		Imports,
			      me:		Millboss_State,
			      millboss_arg:	Millboss_Arg,
			      run_gun':		Run_Gun,
			      end_gun':		End_Gun
			    }
			  );

	Exports	= {													# Ports we provide for use by other imps.
		    gadget_to_millboss:		Crypt									# The Crypt encapsulates type gadget_to_millboss::Gadget_To_Millboss. (We don't want to drag that typecomplex into guiboss.)
		  };


	Millboss_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);


	Runstate =    {													# These values will be statically globally visible throughout the code body for the imp.
			me:			Millboss_State,								# State which is preserved across imp shutdown/restart cycles.
			millboss_arg:		Millboss_Arg,
			imports:		Imports,								# Imps to which we send requests.
			to:			Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
			end_gun':		End_Gun,								# We shut down the microthread when this fires.
			id:			Id
		      };

	Millboss_Q    = Mailqueue( Runstate -> Void );



	fun note_mill_info
	      (
		me:				Millboss_State,
		mill_info:			mt::Mill_Info
	      )	
	    =
	    {   me.mills_by_id   := im::set (*me.mills_by_id,   id_to_int mill_info.mill_id, mill_info);
		me.mills_by_name := sm::set (*me.mills_by_name,           mill_info.name,    mill_info);

		case mill_info.filespec
		    #
		    THE filespec
			=>
			{   filepath = filespec.dirname + "/" + filespec.basename;
			    #
			    me.mills_by_filepath
				:=
				sm::set (*me.mills_by_filepath, filepath,  mill_info);
			};
		    NULL => ();
		esac;
	    };

	fun run ( millboss_q:			Millboss_Q,								# 
		  #
		  runstate as
		  {													# These values will be statically globally visible throughout the code body for the imp.
		    me:				Millboss_State,								# State which is preserved across imp shutdown/restart cycles.
		    millboss_arg:		Millboss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# 
		    id:				Id
		  }
		)
	    =
	    {	loop ();
	    }
	    where


		#
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    end_gun'                        ==>  shut_down_millboss_imp',
			    take_from_mailqueue' millboss_q ==>  do_millboss_plea
			];

			loop ();
		    }	
		    where
			fun do_millboss_plea  thunk
			    =
			    thunk runstate;
			#
			fun shut_down_millboss_imp' ()
			    =
			    {
				thread_exit { success => TRUE };							# Will not return.	
			    };
		    end;
	    end;	



	#
	fun startup   (id: Id,   reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()				# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		gadget_to_millboss
		    =
		    mt::GADGET_TO_MILLBOSS
		      {
			id,
			get_textmill,
			make_textmill,
			get_or_make_textmill,
			get_or_make_filebuffer,
			#
			get_cutbuffer_contents,
			set_cutbuffer_contents,
			#
			note_pane,
			drop_pane,
			mail_pane,
			get_panes_by_id,
			get_mills_by_name,
			get_mills_by_id
		      };

		exports	    = { gadget_to_millboss => crypt }
				where
				    crypt = { type => "gadget_to_millboss::GADGET_TO_MILLBOSS",
					      info => "src/lib/x-kit/widget/edit/gadget-to-millboss.pkg",
					      data =>  mt::GADGET_TO_MILLBOSS__CRYPT  gadget_to_millboss
					    };	
				end;

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, exports));							# Return value from millboss_egg'().

		(take_from_mailslot  me_slot)										# Imports from millboss_egg'().
		    ->
		    { me, millboss_arg, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		run ( millboss_q,		 									# Will not return.
		      { me,
			millboss_arg,
			imports,
			to,
			end_gun',
			id
		      }
		);
	    }
	    where
		millboss_q     =  make_mailqueue (get_current_microthread()):  Millboss_Q;


		fun note_textmill_statechange (id: Id,  statechange: mt::Textmill_Statechange)
		    =
		    case statechange
			#
			mt::NAME_CHANGED { was: String, now: String }
			    =>
			    put_in_mailqueue  (millboss_q,
				#
				\\ ({ me, ... }: Runstate)
				    =
				    case (im::get  (*me.mills_by_id,  id_to_int id))
					#
					THE mill_info
					    =>
					    {	mill_info								# Remember new name of mill.  This is one of those places where functional record update support in the compiler would be nice.
						  =
						  { name	 =>  now,						# The updated field.
						    freshness	 =>  id_to_int (issue_unique_id()),			# Might as well update freshness too.
						    #
						    mill_id      =>  mill_info.mill_id,					# The unchanged fields.
						    app_to_mill  =>  mill_info.app_to_mill,				#
						    pane_to_mill =>  mill_info.pane_to_mill,				#
						    filespec     =>  mill_info.filespec					#
						  };

						me.mills_by_name :=  sm::drop (*me.mills_by_name, was);			# Forget   old name of mill.
						note_mill_info (me, mill_info);						# Remember mill under its new name.
					    };
					#
					NULL =>
					    {   msg =  sprintf "NAME.id (%d) not in *me.mills_by_id!" (id_to_int id);
						log::fatal msg;
						raise exception DIE msg;
					    };
				    esac
			    );	


			mt::TEXTSTATE_CHANGED _ =>  ();									# List rest explicitly so as to draw a compile error if a new one gets added without us being updated.
			mt::UNDO 	      _ =>  ();
			mt::FILESPEC_CHANGED  _ =>  ();
			mt::READONLY_CHANGED  _ =>  ();
			mt::DIRTY_CHANGED     _ =>  ();
		    esac;

		#################################################################################
		# guiboss interface fns::
		#
		#

		fun find_first_unused_pane_tag										# 
		      (													# 
			me:		Millboss_State
		      ):		Int
		    =
		    {	panes = im::vals_list  *me.panes_by_id;
			panes = lms::sort_list gt panes
				    where
					fun gt ( pane1: Pane_Info,
						 pane2: Pane_Info
					       )
					    =
					    pane1.pane_tag > pane2.pane_tag;
				    end;
			#
			try (panes, 1)											# All pane tags should be greater than zero.
			    where
				fun try ((pane: Pane_Info) ! rest,  n)							# Search sequentially through sorted list for first unused pane tag value.
					=>
					if (pane.pane_tag > n)   n;
					else			 try (rest, n+1);
					fi;

				    try ([], n) => n;
				end;
			    end;
		    };	

		fun note_pane												# Used to inform us of newly created panes, and also to update us when the mill associated with a pane changes.
		      {													# (Currently the only time we change the mill associated with a pane is in find_file -- fundamental-mode.pkg's switch_to_mill() just creates a new pane.)
			millboss_to_pane:			b2p::Millboss_To_Pane,
			mill_id:				Id
		      }
		    =
		    put_in_mailqueue  (millboss_q,
			#
			\\ (r as { id, me, ... }: Runstate)
			    =
			    {   pane_id  =  millboss_to_pane.pane_id;
				#
				pane_tag =  case (im::get (*me.panes_by_id, id_to_int pane_id))				# We assign each pane the smallest unused positive tag, to be displayed on modeline and used by "C-x o" (other_pane) in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
						#
						THE pane_info
						    =>
						    pane_info.pane_tag;							# We already knew about pane, so retain its existing pane_tag.

						NULL =>
						    {   pane_tag = find_first_unused_pane_tag  me;			# This is a new pane.
							millboss_to_pane.note_tag    pane_tag;				# Tell the pane what tag we assigned it.
							pane_tag;
						    };
					    esac;

				me.panes_by_id										# Remember what we've learned/decided about this pane.
				    :=
				    im::set  (*me.panes_by_id,  id_to_int pane_id,  pane_info)
					where
					    pane_info = { pane_id,
							  pane_tag,
							  mill_id,
							  millboss_to_pane
							};
					end;


				case (im::get (*me.pending_pane_mail, id_to_int pane_id))				# Deliver any pending mail for this pane.
				    #
				    THE (pending_pane_mail:  List( Crypt ))
					=>
					{   apply   do_crypt   (reverse pending_pane_mail)				# We reverse to restore original message ordering.
						    #
						    where
							fun do_crypt (crypt: Crypt)
							    =
							    millboss_to_pane.note_crypt  crypt;
						    end;

					    me.pending_pane_mail							# Forget about delivered mail, so we don't deliver it again.
						:=
						im::drop  (*me.pending_pane_mail,   id_to_int pane_id);
					};
				    NULL => ();
				esac;

				case (im::get (*me.mills_by_id, id_to_int mill_id))					# Freshen mill.
				    #
				    THE mill_info
					=>
					{   freshness =  id_to_int (issue_unique_id());
					    #
					    mill_info =	  { freshness,							# Updated field.
							    #
							    mill_id	  =>  mill_info.mill_id,			# Unchanged fields.  Oh, for functional record updates! :-)
							    app_to_mill	  =>  mill_info.app_to_mill,			#
							    pane_to_mill  =>  mill_info.pane_to_mill,			#	
							    name	  =>  mill_info.name,				#
							    filespec	  =>  mill_info.filespec			#
							  };

					    note_mill_info (me, mill_info);
					};

				    NULL => ();										# Mill has not registered yet.
				esac;
			    }
		    );
		fun mail_pane												# Send something to a pane. If the pane is not yet registered with millboss, the crypt will be queued up and delivered when the pane registers. Used for linking up screenline.pkg instances to textpane.pkg instances at startup (etc).
		      (													# Using a Crypt here makes the mechanism general at a small cost in typesafety.  In particular, it buys us valuable modularity by keeping millboss from needing to know the types of the interfaces between textpane and screenline (etc).
			pane_id:	Id,										#
			crypt:		Crypt
		      )
		    =
		    put_in_mailqueue  (millboss_q,
			#
			\\ (r as { id, me, ... }: Runstate)
			    =
			    case (im::get (*me.panes_by_id, id_to_int pane_id))						# Has the given pane registered with us yet?
				#
				THE pane_info										# Yes,
				    =>											# so
				    pane_info.millboss_to_pane.note_crypt  crypt;					# deliver the mail immediately.

				NULL =>											# No, so queue up the mail for later delivery.
				    #
				    case (im::get (*me.pending_pane_mail, id_to_int pane_id))				# Is there already pending mail for this pane?
					#
					THE pending_pane_mail								# Yes,
					    =>										# so
					    me.pending_pane_mail							# prepend
						:=									# new mail
						im::set ( *me.pending_pane_mail,					# to
							  id_to_int pane_id,						# existing
							  crypt ! pending_pane_mail					# queued-mail
							);								# list.

					NULL =>					      					# No, so
					    me.pending_pane_mail							# start a new
						:=									# list of
						im::set (*me.pending_pane_mail,  id_to_int pane_id,  [ crypt ]);	# pending mail for that pane.
				    esac;
			    esac
		    );
		fun drop_pane
		      {
			pane_id:		Id
		      }
		    =
		    put_in_mailqueue  (millboss_q,
			#
			\\ (r as { id, me, ... }: Runstate)
			    =
			    me.panes_by_id
				:=
				im::drop  (*me.panes_by_id,   id_to_int pane_id)
		    );
		fun get_panes_by_id ()
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( im::Map(mt::Pane_Info) );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ (r as { id, me, ... }: Runstate)
				=
				{   result = im::map  do_pane  *me.panes_by_id
						where
						    fun do_pane ({ pane_id, pane_tag, mill_id, ... }: Pane_Info)
							=
							{ pane_id, pane_tag, mill_id };
						end;	

				    put_in_oneshot (reply_oneshot, result);
				}
			);
			get_from_oneshot  reply_oneshot;
		    };
		fun get_mills_by_name ()
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( sm::Map(mt::Mill_Info) );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ (r as { id, me, ... }: Runstate)
				=
				{   result = *me.mills_by_name;
				    #
				    put_in_oneshot (reply_oneshot, result);
				}
			);
			get_from_oneshot  reply_oneshot;
		    };
		fun get_mills_by_id ()
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( im::Map(mt::Mill_Info) );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ (r as { id, me, ... }: Runstate)
				=
				{   result = *me.mills_by_id;
				    #
				    put_in_oneshot (reply_oneshot, result);
				}
			);
			get_from_oneshot  reply_oneshot;
		    };



		stipulate
		    cutbuffer_contents =  REF (ct::PARTLINE "");
		herein
		    fun get_cutbuffer_contents ()
			=
			*cutbuffer_contents;										# We do this in caller's thread (not millboss thread) for speed and to reduce risk of deadlock.

		    fun set_cutbuffer_contents (new_contents:	ct::Cutbuffer_Contents)
			=
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				cutbuffer_contents :=  new_contents							# We do this in the millboss thread to ensure cutbuffer_contents value remains stable over any millboss_imp call, just as good practice.
			);
		end;

		fun uniquify_name											# Convert "foo" into "foo<1>" or "foo<2>" or such in order to avoid conflicting with any existing name.
		      (
			me:		Millboss_State,
			name:		String
		      )
		    :			String
		    =
		    case (sm::get (*me.mills_by_name, name))
			#
			NULL => name;											# Name is already unique.

			THE _ =>
			    uniquify_name' 0
			    where
				fun uniquify_name' (i: Int)
				    =
				    {   name' = sprintf "%s<%d>" name i;
					#
					case (sm::get (*me.mills_by_name, name'))
					    #
					    NULL  =>  name';								# Modified name is now unique.
					    THE _ =>  uniquify_name' (i + 1);						# Modified name already exists, try one number higher.
					esac;
				    };
			    end;
		    esac;


		fun get_textmill   (name: String)
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Null_Or( mt::Textpane_To_Textmill ) );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				case (tmt::get__null_or_textpane_to_textmill__from__null_or_textmill_info
					 (sm::get (*me.mills_by_name, name))
				     )
				    #
				    THE textpane_to_textmill =>    put_in_oneshot (reply_oneshot, THE textpane_to_textmill);
				    NULL 	             =>    put_in_oneshot (reply_oneshot, NULL);
				esac
			);

			get_from_oneshot  reply_oneshot;
		    };

		fun make_textmill											# Create a buffer, If an existing buffer has given name, modify the new buffer's name to make it unique.
		      (
			textmill_arg
			as
			{ name:			String,
			  textmill_options:	List( mt::Textmill_Option )
			}:			mt::Textmill_Arg
		      )
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mt::Textpane_To_Textmill );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				{   name =  uniquify_name (me, name);							# Convert "foo" into "foo<1>" or "foo<2>" or such in order to avoid conflicting with any existing name.
				    #
				    egg =  tbi::make_textmill_egg  textmill_arg;
				    #
				    (egg ())
					->
					( textmill_exports:	tbi::Exports,
					  egg':		       (tbi::Imports, Run_Gun, End_Gun) -> Void
					);

				    textmill_imports
				      =
				      { };

				    (make_run_gun ()) ->   { run_gun', fire_run_gun };
				    (make_end_gun ()) ->   { end_gun', fire_end_gun };

				    egg' (textmill_imports, run_gun', end_gun');

				    fire_run_gun ();

				    textmill_exports
					->
					{ textpane_to_textmill as mt::TEXTPANE_TO_TEXTMILL tb
					};

				    mill_info =   { name,
						    freshness	 =>  id_to_int (issue_unique_id()),
						    mill_id      =>  tb.id,
						    filespec	 =>  NULL,
						    app_to_mill	 =>  tb.app_to_mill,
						    pane_to_mill =>  tmt::encrypt__textpane_to_textmill  textpane_to_textmill
						  };

				    note_mill_info (me, mill_info);

				    tb.note_watcher (id, note_textmill_statechange);

				    put_in_oneshot (reply_oneshot, textpane_to_textmill);
			    }
			);

			get_from_oneshot  reply_oneshot;
		    };

		fun get_or_make_textmill										# Find a buffer by name; if no such buffer exists, create one.  Buffer may or may not have an associated file.
		      (
			textmill_arg
			as
			{ name:			String,
			  textmill_options:	List( mt::Textmill_Option )
			}:			mt::Textmill_Arg
		      )
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mt::Textpane_To_Textmill );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				case (tmt::get__null_or_textpane_to_textmill__from__null_or_textmill_info
					 (sm::get (*me.mills_by_name, name))
				     )
				    #
				    THE textpane_to_textmill
					=> 
					put_in_oneshot (reply_oneshot, textpane_to_textmill);
				    #
				    NULL =>
					{   egg =  tbi::make_textmill_egg  textmill_arg;
					    #
					    (egg ())
						->
						( textmill_exports:	tbi::Exports,
						  egg':		       (tbi::Imports, Run_Gun, End_Gun) -> Void
						);

					    textmill_imports
					      =
					      { };

					    (make_run_gun ()) ->   { run_gun', fire_run_gun };
					    (make_end_gun ()) ->   { end_gun', fire_end_gun };

					    egg' (textmill_imports, run_gun', end_gun');

					    fire_run_gun ();

					    textmill_exports
						->
						{ textpane_to_textmill as mt::TEXTPANE_TO_TEXTMILL tb
						};

					    mill_info = { name,
							  freshness    =>  id_to_int (issue_unique_id()),
							  mill_id      =>  tb.id,
							  filespec     =>  NULL,
							  app_to_mill  =>  tb.app_to_mill,
							  pane_to_mill =>  tmt::encrypt__textpane_to_textmill  textpane_to_textmill
							};

					    note_mill_info (me, mill_info);

					    tb.note_watcher (id, note_textmill_statechange);

					    put_in_oneshot (reply_oneshot, textpane_to_textmill);
					};
				esac
			);

			get_from_oneshot  reply_oneshot;
		    };

		fun get_or_make_filebuffer										# Find buffer open on given file.  If no such buffer exists, create one.  NB: We do our best to avoid having more than one buffer open on a given file.  (Multiple textpanes may be open on one buffer; that is a separate issue.)
		      (	
			filespec:		mt::Filespec
		      )
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mt::Textpane_To_Textmill );
			#
			put_in_mailqueue  (millboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				{   name = uniquify_name (me, filespec.basename);
				    #
				    textmill_options =  [];
				    textmill_arg     =  { name, textmill_options };

				    egg =  tbi::make_textmill_egg  textmill_arg;
				    #
				    (egg ())
					->
					( textmill_exports:	tbi::Exports,
					  egg':		       (tbi::Imports, Run_Gun, End_Gun) -> Void
					);

				    textmill_imports
				      =
				      { };

				    (make_run_gun ()) ->   { run_gun', fire_run_gun };
				    (make_end_gun ()) ->   { end_gun', fire_end_gun };

				    egg' (textmill_imports, run_gun', end_gun');

				    fire_run_gun ();

				    textmill_exports ->  { textpane_to_textmill  as  mt::TEXTPANE_TO_TEXTMILL tb
							 };

				    tb.app_to_mill   ->  mt::APP_TO_MILL am;

				    mill_info =   { name,
						    freshness    =>  id_to_int (issue_unique_id()),
						    mill_id	 =>  tb.id,
						    filespec     =>  THE filespec,
						    app_to_mill	 =>  tb.app_to_mill,
						    pane_to_mill =>  tmt::encrypt__textpane_to_textmill  textpane_to_textmill
						  };

				    note_mill_info (me, mill_info);

				    tb.note_watcher (id, note_textmill_statechange);

				    am.set_filespec (THE filespec);

				    am.reload_from_file ();

				    put_in_oneshot (reply_oneshot, textpane_to_textmill);
				}
			);

			get_from_oneshot  reply_oneshot;
		    };
	    end;

	#
	fun process_options (options: List(Millboss_Option), { name, id })
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME	n) =>   my_name			:=  n;
			do_option (ID			i) =>   my_id                   :=  i;
		    end;
		end;

		{ name			=>  *my_name,
		  id 			=>   *my_id
		};
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_millboss_egg																# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	      (millboss_arg:		Millboss_Arg)													# Called (only) by startup()	in   src/lib/x-kit/widget/gui/guiboss-imp.pkg
	    =
	    {	millboss_arg ->  (millboss_options);													# Currently no guiboss_needs component, so this is a no-op.
		#
		(process_options
		  ( millboss_options,
		    { name		=> "millboss",
		      id		=>  id_zero
		    }
		) )
		    ->
		    { name,
		      id
		    };
	
		my (id, millboss_options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();														# Allocate unique imp id.
			(id, ID id ! millboss_options);													# Make our id stable across stop/restart cycles.
		    else
			(id, millboss_options);
		    fi;

		millboss_arg = (millboss_options);													# Currently no guiboss_needs component, so this is a no-op.

		me =  {	mills_by_name	  =>  REF sm::empty,												# All currently active mills, by name.
			mills_by_id	  =>  REF im::empty,												# All currently active mills, by id.
			mills_by_filepath =>  REF sm::empty,												# All currently active mills WHICH ARE OPEN ON A FILE, by filename.
			#
			pending_pane_mail =>  REF im::empty,												# Messages to panes which have not yet registered with us, indexed by pane_id.	To preserve message order we reverse these lists before delivering them  (although message order should rarely if ever matter).
			panes_by_id	  =>  REF im::empty												# All currently active panes, by id.
		      };

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );						# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));									# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3															# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, millboss_arg, imports, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
