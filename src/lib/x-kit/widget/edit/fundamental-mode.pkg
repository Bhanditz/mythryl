## fundamental-mode.pkg
#
# Support fns for textbuffer_imp -- mostly editing		# textbuffer_imp		is from   src/lib/x-kit/widget/edit/textbuffer-imp.pkg
# fns to be bound to keystrokes.
#
# See also:
#     src/lib/x-kit/widget/edit/textpane.pkg
#     src/lib/x-kit/widget/edit/textedit.pkg
#     src/lib/x-kit/widget/edit/editboss-imp.pkg
#     src/lib/x-kit/widget/edit/textbuffer-imp.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
#   package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package ct  =  cutbuffer_types;				# cutbuffer_types		is from   src/lib/x-kit/widget/edit/cutbuffer-types.pkg
#   package ct  =  gui_to_object_theme;				# gui_to_object_theme		is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
#   package bt  =  gui_to_sprite_theme;				# gui_to_sprite_theme		is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
#   package wt  =  widget_theme;				# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

#   package os  =  guiboss_to_spritespace;			# guiboss_to_spritespace	is from   src/lib/x-kit/widget/space/sprite/guiboss-to-spritespace.pkg
#   package cs  =  guiboss_to_objectspace;			# guiboss_to_objectspace	is from   src/lib/x-kit/widget/space/object/guiboss-to-objectspace.pkg


    package boi =  spritespace_imp;				# spritespace_imp		is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;				# objectspace_imp		is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;				# widgetspace_imp		is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;				# guiboss_to_guishim		is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2s =  spritespace_to_sprite;			# spritespace_to_sprite		is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;			# objectspace_to_object		is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2b =  sprite_to_spritespace;			# sprite_to_spritespace		is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2c =  object_to_objectspace;			# object_to_objectspace		is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg

#   package g2b =  gadget_to_editboss;				# gadget_to_editboss		is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package iuw =  issue_unique_widget_id;			# issue_unique_widget_id	is from   src/lib/x-kit/widget/gui/issue-unique-widget-id.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg
    package sm  =  string_map;					# string_map			is from   src/lib/src/string-map.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

    package ebt =  editboss_types;				# editboss_types		is from   src/lib/x-kit/widget/edit/editboss-types.pkg

#   package g2e =  gadget_to_editboss;				# gadget_to_editboss		is from   src/lib/x-kit/widget/edit/guiboss-to-editboss.pkg
    package e2g =  editboss_to_guiboss;				# editboss_to_guiboss		is from   src/lib/x-kit/widget/edit/editboss-to-guiboss.pkg

    package p2t =  textpane_to_textbuffer;			# textpane_to_textbuffer	is from   src/lib/x-kit/widget/edit/textpane-to-textbuffer.pkg
    package mj  =  mode_junk;					# mode_junk			is from   src/lib/x-kit/widget/edit/mode-junk.pkg

    package que =  queue;					# queue				is from   src/lib/src/queue.pkg
    package nl  =  red_black_numbered_list;			# red_black_numbered_list	is from   src/lib/src/red-black-numbered-list.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

herein

    package fundamental_mode {					# 
	#
	fun make_fundamental_mode ()
	    =
	    {   # In general most modes are likely to have
		# some state variables declared here, which
		# the keymap functions can share.									#


		fun next_line (was:	mj::Editfn_In)
		    :			mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,						# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),					# 
				    lastmark:			Null_Or(g2d::Point),					# 
				    keystring:			String,							# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,				# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };
			point -> { row, col };

			row = row + 1;

			point =  { row, col };

			THE [ mj::POINT point ];
		    };
		next_line__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "next_line",
			doc	=>  "Move point (cursor) to next line.",
			args	=>  [],
			editfn  =>  next_line
		      };	


		fun previous_line (was:	mj::Editfn_In)
		    :			mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,						# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),					# 
				    lastmark:			Null_Or(g2d::Point),					# 
				    keystring:			String,							# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,				# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };
			point -> { row, col };

			row = (row > 0) ?? row - 1 :: row;

			point =  { row, col };

			THE [ mj::POINT point ];
		    };
		previous_line__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "previous_line",
			doc	=>  "Move point (cursor) to previous line.",
			args	=>  [],
			editfn  =>  previous_line
		      };	


		fun previous_char (was: mj::Editfn_In)
		    :			mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,						# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),					# 
				    lastmark:			Null_Or(g2d::Point),					# 
				    keystring:			String,							# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,				# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };
			point -> { row, col };

			line_key = row;											# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

			text =  case (nl::find (textlines, line_key))
				    #
				    THE line => line;
				    NULL     => "\n";
				esac;

			text = string::chomp text;

			(string::expand_tabs_and_control_chars
			  {
			    utf8text	=> text,
			    startcol	=>  0,
			    screencol1	=>  col,
			    screencol2	=>  0
			  })
			  ->
			  { screencol1_firstcol_on_screen:	Int,
			    screencol1_colcount_on_screen:	Int,
			    ...
			  };

			col =  screencol1_firstcol_on_screen - 1;							# The point of this is that if we're on a control-char or tab (which both display on multiple screen columns) we want to move to the previous char, which may mean moving multiple screen columns.

			result =    if   (col >= 0)  THE [ mj::POINT { row, col } ];					# Normal case: moved back a char within current line.
				    elif (row == 1)  NULL;								# Abnormal case:  Was at start of buffer, couldn't move back.
				    else										# Moved back beyond start of current line so move cursor to end of previous line.
					text =  case (nl::find (textlines, line_key - 1))
						    #
						    THE line => line;
						    NULL     => "\n";							# 
						esac;

					text = string::chomp text;

					(string::expand_tabs_and_control_chars
					  {
					    utf8text	=> text,
					    startcol	=>  0,
					    screencol1	=>  0,
					    screencol2	=>  0
					  })
					  ->
					  { screentext_length_in_screencols:	Int,
					    ...
					  };

					THE [ mj::POINT { row => row - 1, col => screentext_length_in_screencols } ];
				    fi;

			result;
		    };
		previous_char__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "previous_char",
			doc	=>  "Move point (cursor) to previous char.",
			args	=>  [],
			editfn  =>  previous_char
		      };	


		fun forward_char (was:	mj::Editfn_In)
		    :			mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,						# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),					# 
				    lastmark:			Null_Or(g2d::Point),					# 
				    keystring:			String,							# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,				# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };
			point -> { row, col };

			line_key = row;											# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

			text =  case (nl::find (textlines, line_key))
				    #
				    THE line => line;
				    NULL     => "\n";
				esac;

			text =  string::chomp  text;

			(string::expand_tabs_and_control_chars
			  {
			    utf8text	=> text,
			    startcol	=>  0,
			    screencol1	=>  col,
			    screencol2	=>  0
			  })
			  ->
			  { screencol1_firstcol_on_screen:	Int,
			    screencol1_colcount_on_screen:	Int,
			    screentext_length_in_screencols:	Int,
			    ...
			  };

			col =  screencol1_firstcol_on_screen + screencol1_colcount_on_screen;				# The point of this is that if we're on a control-char or tab (which both display on multiple screen columns) we want to move to the next char, which may mean moving multiple screen columns.

			point =     if (col <= screentext_length_in_screencols)
					#
					{ row, col };									# Move right within line.
				    else
					{ row => row + 1, col => 0 };							# Wrap around at end of line to start of next line.
				    fi;

			THE [ mj::POINT point ];
		    };
		forward_char__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "forward_char",
			doc	=>  "Move point (cursor) to next char.",
			args	=>  [],
			editfn  =>  forward_char
		      };	


		fun move_beginning_of_line (was:	mj::Editfn_In)
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,						# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),					# 
				    lastmark:			Null_Or(g2d::Point),					# 
				    keystring:			String,							# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,				# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };
			point -> { row, col };

			point =  { row, col => 0 };

			THE [ mj::POINT point ];
		    };
		move_beginning_of_line__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "move_beginning_of_line",
			doc	=>  "Move point (cursor) to start of current line.",
			args	=>  [],
			editfn  =>  move_beginning_of_line
		      };	


		fun move_end_of_line (was:		mj::Editfn_In)
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,						# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),					# 
				    lastmark:			Null_Or(g2d::Point),					# 
				    keystring:			String,							# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,				# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };
			point -> { row, col };

			line_key = row;											# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

			text =  case (nl::find (textlines, line_key))
				    #
				    THE line => line;
				    NULL     => "\n";
				esac;

			text =  string::chomp  text;

			(string::expand_tabs_and_control_chars
			  {
			    utf8text	=> text,
			    startcol	=>  0,
			    screencol1	=>  col,
			    screencol2	=>  0
			  })
			  ->
			  { screentext_length_in_screencols:	Int,
			    ...
			  };

			point =  { row, col => screentext_length_in_screencols };

			THE [ mj::POINT point ];
		    };
		move_end_of_line__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "move_end_of_line",
			doc	=>  "Move point (cursor) to start of current line.",
			args	=>  [],
			editfn  =>  move_end_of_line
		      };	


		fun delete_one_char											# Implements functionality common to delete_char and delete_backward_char.
		      (
			textlines:	mj::Textlines,
			point:		g2d::Point,
			mark:		Null_Or(g2d::Point)								# 
		      )
		    :					mj::Editfn_Out
		    =
		    {	point -> { row, col };
			#
			line_key = row;											# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

			result
			    =
			    case (nl::find (textlines, line_key))
				#
				THE text => {   chomped_text =  string::chomp  text;

						(string::expand_tabs_and_control_chars
						  {
						    utf8text	=>  chomped_text,
						    startcol	=>  0,
						    screencol1	=>  col,
						    screencol2	=>  0
						  })
						  ->
						  { screentext_length_in_screencols:	Int,
						    #
						    screencol1_byteoffset_in_utf8text:	Int,
						    screencol1_bytescount_in_utf8text:	Int,
						    ...
						  };

						if (col >= screentext_length_in_screencols)
						    #
						    THE [ ];									# Cursor is on non-existent char past end of existing line.  Don't fail, but don't do anything either. (emacs deletes the end-of-line newline here, but I prefer to have only kill_line do that.)
						else
																# Cursor is on an existing char, possibly a multibyte utf8 char.  Excise it by replacing the line with the concatenation of the substrings preceding and following the char.
						    text_before_point
							=
							string::substring
							  (
							    text,								# String from which to extract substring.
							    0,									# The substring we want starts at offset 0.
							    screencol1_byteoffset_in_utf8text					# The substring we want runs to location of cursor.  Treating cursor offset as length works (only) because we're starting substring at offset zero.
							  );

						    text_beyond_point
							=
							string::extract
							  (
							    text,								# String from which to extract substring.
							    screencol1_byteoffset_in_utf8text + screencol1_bytescount_in_utf8text,	# Substring starts immediately after the byte(s) under the cursor.  (Cursor will mark multiple bytes only if it is on a multibyte utf8 char.)
							    NULL								# Substring runs to end of 'text'.
							  );

						    updated_text	=  string::cat [ text_before_point,
											 text_beyond_point
										       ];

						    updated_textlines 								# First remove existing line -- nl::set does NOT remove any previous line at that key.
							=
							{   (nl::remove (textlines, line_key))
								->
								(updated_textlines, oldline);

							    updated_textlines;
							}	
							except _ = textlines;							# This will happen if there is no line 'line_key' in textlines.

						    updated_textlines								# Now insert updated line.
							=
							nl::set (updated_textlines, line_key, updated_text);

						    THE [ mj::TEXTLINES updated_textlines,
							  mj::POINT { row, col }						# Needed for delete_backward_char, where cursor position changes.
							];
						fi; 	
					    };

				NULL     => THE [ ];										# Cursor is on non-existent line.  Don't fail, but don't do anything either.
			    esac;

			result;
		    };

		fun delete_char (was:			mj::Editfn_In)
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,							# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),						# 
				    lastmark:			Null_Or(g2d::Point),					# 
				    keystring:			String,								# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,					# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };
			point -> { row, col };

			delete_one_char (textlines, point, mark);								# Code shared with delete_backward_char.
		    };
		delete_char__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "delete_char",
			doc	=>  "Delete char under point (cursor).",
			args	=>  [],
			editfn  =>  delete_char
		      };	

		fun delete_backward_char (was:		mj::Editfn_In)
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,							# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),						# 
				    lastmark:			Null_Or(g2d::Point),					# 
				    keystring:			String,								# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,					# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };
			point -> { row, col };

			if (col > 0)
			    #
			    col = col - 1;

			    point = { row, col };

			    delete_one_char (textlines, point, mark);								# Code shared with delete_char.
			    #
			elif (row > 1)												# Delete preceding newline, appending current line to previous line.
			    #
			    point -> { row, col };

			    line_key2 =        row;										# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).
			    line_key1 =  line_key2 - 1;										# 

			    result =	case (nl::find (textlines, line_key1), nl::find (textlines, line_key2))
					    #
					    (THE line1, THE line2)
						=>
						{   chomped_line1 =  string::chomp  line1;
						    #
						    (string::expand_tabs_and_control_chars
						      {
							utf8text   =>  chomped_line1,
							startcol   =>  0,
							screencol1 =>  col,
							screencol2 =>  0
						      })
						      ->
						      { screentext_length_in_screencols:		Int,
							...
						      };

						    line12 = string::cat [ chomped_line1, line2 ];				# Prepend line1 (sans newline) to line2 to produce replacement for the pair of them.

						    updated_textlines 								# First remove existing two lines -- nl::set does NOT remove any previous line at that key.
							=
							{   (nl::remove (textlines,         line_key1)) -> (updated_textlines, _);
							    (nl::remove (updated_textlines, line_key1)) -> (updated_textlines, _);

							    updated_textlines;
							}	
							except _ = textlines;							# This will happen if there is no line 'line_key' in textlines.

						    updated_textlines								# Now insert updated line.
							=
							nl::set (updated_textlines, line_key1, line12);

						    THE [ mj::TEXTLINES updated_textlines,
							  mj::POINT { row => row - 1, col => screentext_length_in_screencols }	# Position cursor at end of previous line1 -- start of contents of merged-in former line2.
							];
						};

					    _  => NULL;										# Should maybe think harder about how/if this case can happen and if it can, what we should be doing. XXX SUCKO FIXME.
					esac;

			    result;
			else
			    NULL;												# Fail: No preceding char to delete in line.
			fi;
		    };
		delete_backward_char__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "delete_backward_char",
			doc	=>  "Delete char to left of point (cursor).",
			args	=>  [],
			editfn  =>  delete_backward_char
		      };	


		fun self_insert_command (was:		mj::Editfn_In)
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,							# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),						# 
				    lastmark:			Null_Or(g2d::Point),						# 
				    keystring:			String,								# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,					# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };
			point -> { row, col };

			line_key = row;												# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

			text =  case (nl::find (textlines, line_key))
				    #
				    THE line => line;
# XXX SUCKO FIXME: TBD 
				    NULL     => "\n";
				esac;

			chomped_text =  string::chomp  text;

			(string::expand_tabs_and_control_chars
			  {
			    utf8text	=>  chomped_text,
			    startcol	=>  0,
			    screencol1	=>  col,
			    screencol2	=>  0
			  })
			  ->
			  { screentext_length_in_screencols:	Int,
			    screencol1_byteoffset_in_utf8text:	Int,
			    ...
			  };

			if (col >= screentext_length_in_screencols)
			    #
# XXX SUCKO FIXME: TBD 
			    THE [ ];												# Cursor is on non-existent char past end of existing line.  Don't fail, but don't do anything either. (emacs deletes the end-of-line newline here, but I prefer to have only kill_line do that.)
			else
																# Cursor is on an existing char, possibly a multibyte utf8 char.  Excise it by replacing the line with the concatenation of the substrings preceding and following the char.
			    text_before_point
				=
				string::substring
				  (
				    text,											# String from which to extract substring.
				    0,												# The substring we want starts at offset 0.
				    screencol1_byteoffset_in_utf8text								# The substring we want runs to location of point.  Treating cursor offset as length works (only) because we're starting substring at offset zero.
				  );

			    text_beyond_point
				=
				string::extract
				  (
				    text,											# String from which to extract substring.
				    screencol1_byteoffset_in_utf8text,								# Substring starts at the byte(s) under the cursor.  (Cursor will mark multiple bytes only if it is on a multibyte utf8 char.)
				    NULL											# Substring runs to end of 'text'.
				  );

			    updated_text	=  string::cat [ text_before_point,
								 keystring,
								 text_beyond_point
							       ];

			    updated_textlines 											# First remove existing line -- nl::set does NOT remove any previous line at that key.
				=
				{   (nl::remove (textlines, line_key))
					->
					(updated_textlines, oldline);

				    updated_textlines;
				}	
				except _ = textlines;										# This will happen if there is no line 'line_key' in textlines.

			    updated_textlines											# Now insert updated line.
				=
				nl::set (updated_textlines, line_key, updated_text);

			    point = { row, col => col + 1 };	

			    THE   [ mj::TEXTLINES updated_textlines,
				    mj::POINT point
				  ];
			fi; 	
		    };
		self_insert_command__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "self_insert_command",
			doc	=>  "Insert keystroke at point (cursor).",
			args	=>  [],
			editfn  =>  self_insert_command
		      };	

		fun newline 		(was:		mj::Editfn_In)								# Split line at cursor, leave cursor at start of new line.
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,							# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),						# 
				    lastmark:			Null_Or(g2d::Point),						# 
				    keystring:			String,								# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,					# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };
			point -> { row, col };

			line_key = row;												# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

			text =  case (nl::find (textlines, line_key))
				    #
				    THE line => line;
# XXX SUCKO FIXME: TBD 
				    NULL     => "\n";
				esac;

			chomped_text =  string::chomp  text;

			(string::expand_tabs_and_control_chars
			  {
			    utf8text	=>  chomped_text,
			    startcol	=>  0,
			    screencol1	=>  col,
			    screencol2	=>  0
			  })
			  ->
			  { screentext_length_in_screencols:	Int,
			    screencol1_byteoffset_in_utf8text:	Int,
			    ...
			  };

			if (col >= screentext_length_in_screencols)
			    #
# XXX SUCKO FIXME: TBD 
			    THE [ ];												# Cursor is on non-existent char past end of existing line.  Don't fail, but don't do anything either. (emacs deletes the end-of-line newline here, but I prefer to have only kill_line do that.)
			else
																# Cursor is on an existing char, possibly a multibyte utf8 char.  Excise it by replacing the line with the concatenation of the substrings preceding and following the char.
			    text_before_point
				=
				string::substring
				  (
				    text,											# String from which to extract substring.
				    0,												# The substring we want starts at offset 0.
				    screencol1_byteoffset_in_utf8text								# The substring we want runs to location of cursor.  Treating cursor offset as length works (only) because we're starting substring at offset zero.
				  );

			    text_beyond_point
				=
				string::extract
				  (
				    text,											# String from which to extract substring.
				    screencol1_byteoffset_in_utf8text,								# Substring starts at the byte(s) under the cursor.  (Cursor will mark multiple bytes only if it is on a multibyte utf8 char.)
				    NULL											# Substring runs to end of 'text'.
				  );

			    # We're splitting the current line into two.
			    # Synthesize those two lines:
			    #
			    line1 =  string::cat [ text_before_point, "\n" ];
			    line2 =                text_beyond_point;

			    updated_textlines 											# First remove existing line -- nl::set does NOT remove any previous line at that key.
				=
				{   (nl::remove (textlines, line_key))
					->
					(updated_textlines, oldline);

				    updated_textlines;
				}	
				except _ = textlines;										# This will happen if there is no line 'line_key' in textlines.

			    updated_textlines = nl::set (updated_textlines, line_key, line2);					# Now insert the two new lines.
			    updated_textlines = nl::set (updated_textlines, line_key, line1);					# 

			    THE   [ mj::TEXTLINES updated_textlines,
				    mj::POINT { row => row + 1, col => 0 }							# Leave cursor at start of second line.
				  ];
			fi; 	
		    };
		newline__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "newline",
			doc	=>  "Split line at point (cursor), leave point at start of new line.",
			args	=>  [],
			editfn  =>  newline
		      };	


		fun kill_whole_line 	(was:		mj::Editfn_In)								# Remove complete line under cursor, leave cursor at same column on next line.
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,							# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),						# 
				    lastmark:			Null_Or(g2d::Point),						# 
				    keystring:			String,								# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,					# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };
			point -> { row, col };

			line_key = row;												# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

			my (updated_textlines, oldline) 									# Remove line.
			    =
			    {   (nl::remove (textlines, line_key))
				    ->
				    (updated_textlines, oldline);

				(updated_textlines, oldline);
			    }	
			    except _ = (textlines, "\n");									# This will happen if there is no line 'line_key' in textlines.

			set_cutbuffer_contents (ct::WHOLELINE oldline);

			THE   [ mj::TEXTLINES updated_textlines ];
		    };
		kill_whole_line__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "kill_whole_line",
			doc	=>  "Remove complete line under point (cursor), leave point at same column on next line.",
			args	=>  [],
			editfn  =>  kill_whole_line
		      };	


		fun yank 		(was:		mj::Editfn_In)								# Insert contents of cutbuffer at cursor. Insertion style depends on cutbuffer contents type.
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,							# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),						# 
				    lastmark:			Null_Or(g2d::Point),						# 
				    keystring:			String,								# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,					# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };
			point -> { row, col };

			line_key = row;												# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

			case (get_cutbuffer_contents())
			    #
			    ct::PARTLINE  text_to_insert									# Used for vanilla cut operations confined to a single line.
				=>
				{
				    line_key = point.row;									# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

				    text =  case (nl::find (textlines, line_key))
						#
						THE line => line;
						NULL     => "\n";
					    esac;

				    chomped_text =  string::chomp  text;

				    (string::expand_tabs_and_control_chars
				      {
					utf8text	=>  chomped_text,
					startcol	=>  0,
					screencol1	=>  point.col,
					screencol2	=>  0
				      })
				      ->
				      { screencol1_byteoffset_in_utf8text:	Int,
					...
				      };

				    textlen = string::length_in_chars  chomped_text;							# This logic is cut-and-pasted from default_redraw_fn in screenline.pkg -- possibly it should be shared via some package.
																	# 
				    my  { text_before_point,										# 
					  text_beyond_point										# 
					}												#
					=												#
					if (point.col >= textlen)									#
					    #
					    { text_before_point =>  chomped_text + (string::repeat(" ", point.col-textlen   )),		# 
					      text_beyond_point =>  ""
					    };
					else												# Region lies entirely within input string.

					    { text_before_point =>  string::substring (chomped_text, 0			      ,  screencol1_byteoffset_in_utf8text),
					      text_beyond_point =>  string::extract   (chomped_text, screencol1_byteoffset_in_utf8text,  NULL	                 )	except INDEX_OUT_OF_BOUNDS = ""
					    };
					fi;

				    updated_line = text_before_point + text_to_insert + text_beyond_point + "\n";			# XXX BUGGO FIXME This assumes the original line ended with a newline, which is not a given.

				    updated_textlines
					=
					{   (nl::remove (textlines, line_key))
						->
						(updated_textlines, oldline);

					    updated_textlines;
					};

				    updated_textlines
					=
					nl::set (updated_textlines, line_key, updated_line);

				    (string::expand_tabs_and_control_chars								# Now to compute screen column of end of text_to_insert.
				      {
					utf8text	=>  text_before_point + text_to_insert,
					startcol	=>  0,
					screencol1	=>  point.col,
					screencol2	=>  0
				      })
				      ->
				      { screentext_length_in_screencols:	Int,
					...
				      };

				    THE   [ mj::TEXTLINES updated_textlines,
					    mj::POINT    { row => point.row,  col => screentext_length_in_screencols },
					    mj::MARK     NULL,
					    mj::LASTMARK (THE point)
					  ];
				};

			    ct::WHOLELINE string											# Used for special cut operations which cut complete lines even if point (cursor) is in middle of line.
				=>
				{   updated_textlines
					=
					nl::set (textlines, line_key, string);

				    THE   [ mj::TEXTLINES updated_textlines ];
				};

			    ct::MULTILINE strings											# Used for vanilla cut operations which happen to span more than one line.
				=>
				{
				    line_key = point.row;										# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

				    text =  case (nl::find (textlines, line_key))
						#
						THE line => line;
						NULL     => "\n";
					    esac;

				    chomped_text =  string::chomp  text;

				    (string::expand_tabs_and_control_chars
				      {
					utf8text	=>  chomped_text,
					startcol	=>  0,
					screencol1	=>  point.col,
					screencol2	=>  0
				      })
				      ->
				      { screencol1_byteoffset_in_utf8text:	Int,
					...
				      };

				    textlen = string::length_in_chars  chomped_text;							# This logic is cut-and-pasted from default_redraw_fn in screenline.pkg -- possibly it should be shared via some package.
																	# 
				    my  { text_before_point,										# 
					  text_beyond_point										# 
					}												#
					=												#
					if (point.col >= textlen)									#
					    #
					    { text_before_point =>  chomped_text + (string::repeat(" ", point.col-textlen   )),		# 
					      text_beyond_point =>  ""
					    };
					else												# Region lies entirely within input string.

					    { text_before_point =>  string::substring (chomped_text, 0			      ,  screencol1_byteoffset_in_utf8text),
					      text_beyond_point =>  string::extract   (chomped_text, screencol1_byteoffset_in_utf8text,  NULL	                 )	except INDEX_OUT_OF_BOUNDS = ""
					    };
					fi;

				    my (firstline, remaininglines)
					=
					case strings
					    #
					    (firstline ! remaininglines) => (firstline, reverse remaininglines);
					    []				 => raise exception FAIL "impossible";				# We never generate a ct::MULTILINE containing less than two lines.
					esac;

				    updated_firstline = text_before_point + firstline;


				    my (lastline, remaininglines)
					=
					case remaininglines
					    #
					    (lastline ! remaininglines) => (lastline, remaininglines);
					    []				=> raise exception FAIL "impossible";				# We never generate a ct::MULTILINE containing less than two lines.
					esac;

				    updated_textlines											# Drop existing firstline, which will be replaced by updated_firstline.
					=
					{   (nl::remove (textlines, line_key))
						->
						(updated_textlines, oldline);

					    updated_textlines;
					};

				    updated_lastline
					=
					lastline + text_beyond_point + (chomped_text == text ?? "" :: "\n");


				    updated_textlines
					=
					nl::set (updated_textlines, line_key, updated_lastline);

				    updated_textlines
					=
					loop (remaininglines, updated_textlines)							# 
					where
					    fun loop ([], updated_textlines)
						    =>
						    updated_textlines;

						loop (thisline ! remaininglines,  updated_textlines)
						    =>
						    loop (remaininglines,  nl::set (updated_textlines, line_key, thisline));
					    end;
					end;

				    updated_textlines
					=
					nl::set (updated_textlines, line_key, updated_firstline);

				    THE   [ mj::TEXTLINES updated_textlines,
					    mj::MARK      NULL,
					    mj::LASTMARK (THE point),
					    mj::POINT     { col => point.col,
							    row => point.row + (list::length strings) - 1
							  }
					  ];
				};
			esac;
		    };
		yank__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "yank",
			doc	=>  "Insert contents of cutbuffer at point (cursor). Insertion style depends on cutbuffer contents type.",
			args	=>  [],
			editfn  =>  yank
		      };	


		fun set_mark_command	(was:		mj::Editfn_In)							# Insert contents of cutbuffer at cursor. Insertion style depends on cutbuffer contents type.
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,						# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),					# 
				    lastmark:			Null_Or(g2d::Point),					# 
				    keystring:			String,							# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,				# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };

			THE   [ mj::MARK (THE point) ];
		    };
		set_mark_command__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "set_mark_command",
			doc	=>  "Set 'mark' to location of point (cursor).",
			args	=>  [],
			editfn  =>  set_mark_command
		      };	


		fun keyboard_quit	(was:		mj::Editfn_In)							# This is emacs' stop-everything command.  For the moment it just clears the mark.
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,						# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),					# 
				    lastmark:			Null_Or(g2d::Point),					# 
				    keystring:			String,							# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,				# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };

			THE   [ mj::MARK NULL,
				mj::RESET										# Special hack just for keyboard_quit which instructs textpane.pkg to reset all ephemeral state etc.
			      ];
		    };
		keyboard_quit__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "keyboard_quit",
			doc	=>  "Stop everything, clear mark, reset to stable quiescient state.",
			args	=>  [],
			editfn  =>  keyboard_quit
		      };	


		fun exchange_point_and_mark (was:		mj::Editfn_In)						# 
		    :						mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,						# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),					# 
				    lastmark:			Null_Or(g2d::Point),					# 
				    keystring:			String,							# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,				# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };

			mark   =    case (mark, lastmark)
					#
					(THE _, _) =>     mark;								# Use 'mark' if it is set.
					_	   => lastmark;								# Use 'lastmark' otherwise.  (In this case lastmark will always be set unless no mark has ever been set in this buffer.)
				    esac;

			result =    case mark
					#
					NULL => NULL;									# Can't exchange point and mark when mark isn't set!

					THE mark
					    =>
					    if (mark.row <  point.row
					    or (mark.row == point.row  and  mark.col < point.col))
						#
						THE   [ mj::MARK  (THE { row => point.row, col => point.col - 1 }),
							mj::POINT mark
						      ];
					    else									# mark > point
						THE   [ mj::MARK   (THE point),
							mj::POINT  { row => mark.row, col => mark.col + 1 }
						      ];
					    fi;
				    esac;

			result;
		    };
		exchange_point_and_mark__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "exchange_point_and_mark",
			doc	=>  "Exchange mark and point (cursor) if mark is set.  Fail if mark is not set.",
			args	=>  [],
			editfn  =>  exchange_point_and_mark
		      };	


		fun kill_region (was:				mj::Editfn_In)						# 
		    :						mj::Editfn_Out
		    =
		    {   was -> 	  { args:			List( mj::Prompted_Arg ),
				    textlines:			mj::Textlines,
				    point:			g2d::Point,						# As in Point_And_Mark.
				    mark:			Null_Or(g2d::Point),					# 
				    lastmark:			Null_Or(g2d::Point),					# 
				    keystring:			String,							# User keystroke that invoked this editfn.
				    get_cutbuffer_contents:	Void -> ct::Cutbuffer_Contents,				# O(1) nonblocking.
				    set_cutbuffer_contents:	ct::Cutbuffer_Contents -> Void
				  };

			fun normalize_point (p: g2d::Point)								# Returned point guaranteed to be positioned on the first screen column of its char (which, like a tab or control char, may occupy multiple screen columns).
			    =
			    {	line_key = p.row;									# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).
				#
				text =  case (nl::find (textlines, line_key))
					    #
					    THE line => line;
					    NULL     => "\n";
					esac;

				chomped_text =  string::chomp  text;
						(string::expand_tabs_and_control_chars
						  {
						    utf8text	=>  chomped_text,
						    startcol	=>  0,
						    screencol1	=>  p.col,
						    screencol2	=>  0							# Don't-care.
						  })
						  ->
						  { screencol1_firstcol_on_screen:	Int,				# First screen column for 'point'.
#						    screencol1_colcount_on_screen:	Int,
						    ...
						  };
				{ row => p.row, col => screencol1_firstcol_on_screen};
			    };

			result =    case mark
					#
					NULL => NULL;									# Can't kill region when mark isn't set!

					THE mark
					    =>
					    {
						# The columns for 'mark' and 'point' may be
						# somewhere odd in the middle of (e.g.) tabs,
						# so start by deriving normalized versions:
						#
						mark'  = normalize_point mark;
						point' = normalize_point point;

						if (mark'.row == point'.row)
						    #
						    line_key = mark'.row;											# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

						    text =  case (nl::find (textlines, line_key))
								#
								THE line => line;
								NULL     => "\n";
							    esac;

						    chomped_text =  string::chomp  text;

						    my (col1, col2)												# First screen cols for first and last chars in selected region.
							=													# NB: We interpret point'==mark' as designating a single-char region.  This preserves the invariant that "C-x C-x" (exchange_point_and_mark) does not change the selected region.
							if  (point'.col <= mark'.col)
							    (point'.col,   mark'.col);
							else													# point.col > mark.col
							    # When point is beyond mark, don't include
							    # point's char (screen column(s)) in the region:
							    #
							    (string::expand_tabs_and_control_chars
							      {
								utf8text	=>  chomped_text,
								startcol	=>  0,
								screencol1	=>  point'.col - 1,								# Since point'.col is guaranteed to be first col for char, subtracting one is guaranteed to put us on previous char.
								screencol2	=>  0										# Don't-care.
							      })
							      ->
							      { screencol1_firstcol_on_screen:		Int,							# First screen column of last char in selected region. Note that screencol1 is guaranteed to be nonnegative because point'.col > mark'.col and both are normalized and on same line.
								...
							      };

							    (mark'.col,  screencol1_firstcol_on_screen);
							fi;

																				# NB: We may have col1==col2 here.  That's OK, and indicates a one-char region to be moved to the cutbuffer -- remember, col1,col2 are both included in the region.
						    (string::expand_tabs_and_control_chars									# Map screencols col1,col2 to byteoffsets in chomped_text.
						      {
							utf8text	=>  chomped_text,
							startcol	=>  0,
							screencol1	=>  col1,
							screencol2	=>  col2
						      })
						      ->
						      { screencol1_byteoffset_in_utf8text:	Int,
							screencol2_byteoffset_in_utf8text:	Int,
							screencol2_bytescount_in_utf8text:	Int,
							...
						      };

#						    utf8_len_in_chars = string::length_in_chars  chomped_text;						# 
						    utf8_len_in_bytes = string::length_in_bytes  chomped_text;							# 
																				# 
						    my  { text_before_region,											# 
							  text_within_region,											# 
							  text_beyond_region											# 
							}													#
							=													#
							if (screencol1_byteoffset_in_utf8text >= utf8_len_in_bytes)						# If region lies entirely beyond actual end of line in utf8text.
							    #
							    { text_before_region =>  chomped_text + (string::repeat(" ",  screencol1_byteoffset_in_utf8text-utf8_len_in_bytes )),
							      text_within_region =>                 (string::repeat(" ", (screencol2_byteoffset_in_utf8text-screencol1_byteoffset_in_utf8text) + 1)),		# 
							      text_beyond_region =>  ""										#
							    };
							elif (col2 >= utf8_len_in_bytes)									# Region starts within utf8text string but extends beyond actual end of line in utf8text.
							    #
							    { text_before_region =>   string::substring(chomped_text, 0,  screencol1_byteoffset_in_utf8text),
							      text_within_region =>  (string::extract  (chomped_text, screencol1_byteoffset_in_utf8text,  NULL)) + (string::repeat(" ", (screencol1_byteoffset_in_utf8text-utf8_len_in_bytes) + 1)),
							      text_beyond_region =>  ""
							    };
							else													# Region lies entirely within input string.
							    { text_before_region =>  string::substring (chomped_text, 0			                                                  ,   screencol1_byteoffset_in_utf8text),
							      text_within_region =>  string::substring (chomped_text, screencol1_byteoffset_in_utf8text                                   ,  (screencol2_byteoffset_in_utf8text + screencol2_bytescount_in_utf8text) - screencol1_byteoffset_in_utf8text),
							      text_beyond_region =>  string::extract   (chomped_text, screencol2_byteoffset_in_utf8text + screencol2_bytescount_in_utf8text,  NULL	                )
							    };
							fi;

						    set_cutbuffer_contents (ct::PARTLINE text_within_region);

						    updated_line = text_before_region + text_beyond_region + (chomped_text==text ?? "" :: "\n");		# Add back terminal newline, if original line had one.

						    updated_textlines
							=
							{   (nl::remove (textlines, line_key))
								->
								(updated_textlines, oldline);

							    updated_textlines;
							};

						    updated_textlines
							=
							nl::set (updated_textlines, line_key, updated_line);

						    THE   [ mj::TEXTLINES updated_textlines,
							    mj::POINT { row => point.row,  col => col1 },
							    mj::MARK     NULL,
							    mj::LASTMARK NULL
							  ];

						else														# mark'.row != point'.row, so this will be a cb::MULTILINE cut. 

						    my (first, final)												# Sort point and mark and implement the convention that if point is last, it points to first char BEYOND region, but if mark is last it points to last char IN region.
							=
							if (point'.row < mark'.row)										# NB: We know from above that mark.row != point.row.
							    #
							    (point', mark');

							elif (point'.col == 0)											# Specialcase check to keep following clause from yielding a negative final.col value.

							    (mark', point');
							else													# point.row > mark.row
							    # When point is beyond mark, don't include
							    # point's char (screen column(s)) in the region:
							    #
							    finalline_key = mark'.row;										# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

							    finaltext =     case (nl::find (textlines, finalline_key))
										#
										THE line => line;
										NULL     => "\n";
									    esac;

							    chomped_finaltext =  string::chomp  finaltext;

							    (string::expand_tabs_and_control_chars
							      {
								utf8text	=>  chomped_finaltext,
								startcol	=>  0,
								screencol1	=>  point'.col - 1,								# Since point' is normalized and point'.col is nonzero, subtracting one is guaranteed to put us on a valid previous char.
								screencol2	=>  0										# Don't-care.
							      })
							      ->
							      { screencol1_firstcol_on_screen:		Int,							# First screen column of last char in selected region.
								...
							      };

							    (mark', { row => point'.row, col => screencol1_firstcol_on_screen } );
							fi;

						    first' = normalize_point first;										# Construct normalized versions of first and final, where screencol is at start of char each is on.
						    final' = normalize_point final;

						    firstline_key = first'.row;											# 

						    firsttext =     case (nl::find (textlines, firstline_key))
									#
									THE line => line;
									NULL     => "\n";
								    esac;

						    chomped_firsttext =  string::chomp  firsttext;

						    firsttext_len_in_bytes = string::length_in_bytes  chomped_firsttext;					# 


						    finalline_key = final'.row;											# 

						    finaltext =     case (nl::find (textlines, finalline_key))
									#
									THE line => line;
									NULL     => "\n";
								    esac;

						    chomped_finaltext =  string::chomp  finaltext;

						    finaltext_len_in_bytes = string::length_in_bytes  chomped_finaltext;					# 


						    (string::expand_tabs_and_control_chars
						      {
							utf8text	=>  chomped_firsttext,
							startcol	=>  0,
							screencol1	=>  first'.col,									# Since point' is normalized and point'.col is nonzero, subtracting one is guaranteed to put us on a valid previous char.
							screencol2	=>  0										# Don't-care.
						      })
						      ->
						      { screencol1_byteoffset_in_utf8text => firstcol_byteoffset_in_firsttext,				# Byteoffset in firsttext corresponding to first char in selected region.
							...
						      };

						    (string::expand_tabs_and_control_chars
						      {
							utf8text	=>  chomped_finaltext,
							startcol	=>  0,
							screencol1	=>  final'.col,									# Since point' is normalized and point'.col is nonzero, subtracting one is guaranteed to put us on a valid previous char.
							screencol2	=>  0										# Don't-care.
						      })
						      ->
						      { screencol1_byteoffset_in_utf8text => finalcol_byteoffset_in_finaltext,				# Byteoffset in finaltext corresponding to final char in selected region.
							screencol1_bytescount_in_utf8text => finalcol_bytescount_in_finaltext,				# Number of bytes in final char.
							...
						      };



						    my  { text_before_firstline_region,									# 
							  text_within_firstline_region
							}												#
							=												#
							if (firstcol_byteoffset_in_firsttext >= firsttext_len_in_bytes)					# If start of region lies beyond actual end of line in firsttext.
							    #
							    { text_before_firstline_region =>  chomped_firsttext + (string::repeat(" ",  firstcol_byteoffset_in_firsttext - firsttext_len_in_bytes)),
							      text_within_firstline_region =>  ""
							    };
							else												# If start of region lies within firsttext.
							    #
							    { text_before_firstline_region =>  string::substring (chomped_firsttext, 0,   firstcol_byteoffset_in_firsttext),
							      text_within_firstline_region =>  string::extract   (chomped_firsttext, firstcol_byteoffset_in_firsttext,  NULL)
							    };
							fi;


						    my  { text_within_finalline_region,									# 
							  text_beyond_finalline_region
							}												#
							=												#
							{   beyondregion_byteoffset = finalcol_byteoffset_in_finaltext					# Compute first byteoffset BEYOND region.
										    + finalcol_bytescount_in_finaltext
										    ;
							    if (beyondregion_byteoffset >= finaltext_len_in_bytes)					# If end of region lies beyond actual end of line in finaltext.
								#
								{ text_within_finalline_region =>  chomped_finaltext + (string::repeat(" ", beyondregion_byteoffset - finaltext_len_in_bytes)),
								  text_beyond_finalline_region =>  ""										#
								};
							    else											# If end of region lies within finaltext.
								#
								{ text_within_finalline_region =>  string::substring (chomped_finaltext, 0,   beyondregion_byteoffset),
								  text_beyond_finalline_region =>  string::extract   (chomped_finaltext, beyondregion_byteoffset,  NULL)
								};
							    fi;
							};

						    whole_lines_in_cut											# Collect all lines strictly between firstline and finalline (== first'.row and final'.row).
							=
							loop (first'.row + 1, [])
							where
							    lastrow = final'.row - 1;

							    fun loop (thisrow, result)
								=
								if (thisrow > lastrow)
								    #
								    reverse  result;
								else
								    line_key = thisrow;

								    text =	case (nl::find (textlines, line_key))
										    #
										    THE line => line;
										    NULL     => "\n";
										esac;

								    loop (thisrow + 1, text ! result);
								fi;
							end;

						    text_within_region
							#
							=  [ text_within_firstline_region + "\n" ]							# We know firstline had a terminal newline, since there was at least one later line (finalline).
							@  whole_lines_in_cut
							@  [ text_within_finalline_region ]
							;

						    set_cutbuffer_contents (ct::MULTILINE text_within_region);


						    updated_textlines												# Drop firstline.
							=
							{   (nl::remove (textlines, first'.row))
								->
								(updated_textlines, oldline);

							    updated_textlines;
							};

						    updated_textlines												# Drop lines between firstline and finalline.
							=
							{   lastrow = final'.row - 1;
							    #
							    loop (first'.row + 1, updated_textlines)
							    where
								fun loop (thisrow, updated_textlines)
								    =
								    if (thisrow > lastrow)
									#
									updated_textlines;
								    else
									(nl::remove (updated_textlines, first'.row))
									    ->
									    (updated_textlines, oldline);

									loop (thisrow + 1,  updated_textlines);
								    fi;
							    end;
							};

						    updated_textlines												# Drop finalline.
							=
							{   (nl::remove (updated_textlines, first'.row))
								->
								(updated_textlines, oldline);

							    updated_textlines;
							};

						    replacement_line
							#
							= text_before_firstline_region
							+ text_beyond_finalline_region
							+ (chomped_finaltext==finaltext ?? "" :: "\n");								# Add back terminal newline, if original finalline had one.

						    updated_textlines
							=
							nl::set (updated_textlines, first'.row, replacement_line);

						    THE   [ mj::TEXTLINES updated_textlines,
							    mj::POINT { row => first.row,  col => first.col },
							    mj::MARK     NULL,
							    mj::LASTMARK NULL
							  ];
						fi;
					    };
				    esac;

			result;
		    };
		kill_region__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "kill_region",
			doc	=>  "Remove contents of region from buffer, saving in cutbuffer.  Fail if mark is not set.",
			args	=>  [],
			editfn  =>  kill_region
		      };	


		fundamental_mode_keymap
		    =
		    keymap
		    where
			keymap = mj::empty_keymap;
			#
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-@"		],	set_mark_command__editfn	);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-SPC"		],	set_mark_command__editfn	);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-a"		],	move_beginning_of_line__editfn	);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-b"		],	previous_char__editfn		);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-d"		],	delete_char__editfn		);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-e"		],	move_end_of_line__editfn	);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-f"		],	forward_char__editfn		);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-g"		],	keyboard_quit__editfn		);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-n"		],	next_line__editfn		);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-o"		],	kill_whole_line__editfn		);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-p"		],	previous_line__editfn		);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-w"		],	kill_region__editfn		);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-x", "C-x"	],	exchange_point_and_mark__editfn	);
			keymap = mj::add_editfn_to_keymap (keymap, [ "C-y"		],	yank__editfn			);
			keymap = mj::add_editfn_to_keymap (keymap, [ "RET"		],	newline__editfn			);
			#
			keymap = mj::add_editfn_to_keymap (keymap, [ "<backspace>"	],	delete_backward_char__editfn	);
			keymap = mj::add_editfn_to_keymap (keymap, [ "<delete>"		],	delete_char__editfn		);
			keymap = mj::add_editfn_to_keymap (keymap, [ "<down>"		],	next_line__editfn		);
			keymap = mj::add_editfn_to_keymap (keymap, [ "<end>"		],	move_end_of_line__editfn	);
			keymap = mj::add_editfn_to_keymap (keymap, [ "<home>"		],	move_beginning_of_line__editfn	);
			keymap = mj::add_editfn_to_keymap (keymap, [ "<left>"		],	previous_char__editfn		);
			keymap = mj::add_editfn_to_keymap (keymap, [ "<right>"		],	forward_char__editfn		);
			keymap = mj::add_editfn_to_keymap (keymap, [ "<up>"		],	previous_line__editfn		);

			keymap =    mj::add_editfn_to_keymap_throughout_char_range
				      {
					keymap,
					keymap_node =>  self_insert_command__editfn,
					#
					firstchar   =>  ' ',
					lastchar    =>	'~'
				      };	
		    end;

		fundamental_mode
		  =
		  { name   =>	"Fundamental",
		    doc    =>	"Root unspecialized textbuffer mode.",
		    keymap =>	fundamental_mode_keymap
		  };

		fundamental_mode;
	    };
    };

end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
