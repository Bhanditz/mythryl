## fundamental-mode.pkg
#
# Support fns for textbuffer_imp -- mostly editing		# textbuffer_imp		is from   src/lib/x-kit/widget/edit/textbuffer-imp.pkg
# fns to be bound to keystrokes.
#
# See also:
#     src/lib/x-kit/widget/edit/textpane.pkg
#     src/lib/x-kit/widget/edit/textedit.pkg
#     src/lib/x-kit/widget/edit/editboss-imp.pkg
#     src/lib/x-kit/widget/edit/textbuffer-imp.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package bt  =  gui_to_sprite_theme;				# gui_to_sprite_theme		is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
    package ct  =  gui_to_object_theme;				# gui_to_object_theme		is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
    package wt  =  widget_theme;				# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

#   package os  =  guiboss_to_spritespace;			# guiboss_to_spritespace	is from   src/lib/x-kit/widget/space/sprite/guiboss-to-spritespace.pkg
#   package cs  =  guiboss_to_objectspace;			# guiboss_to_objectspace	is from   src/lib/x-kit/widget/space/object/guiboss-to-objectspace.pkg


    package boi =  spritespace_imp;				# spritespace_imp		is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;				# objectspace_imp		is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;				# widgetspace_imp		is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;				# guiboss_to_guishim		is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2s =  spritespace_to_sprite;			# spritespace_to_sprite		is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;			# objectspace_to_object		is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2b =  sprite_to_spritespace;			# sprite_to_spritespace		is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2c =  object_to_objectspace;			# object_to_objectspace		is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg

#   package c2g =  gadget_to_editboss;				# gadget_to_editboss		is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package iuw =  issue_unique_widget_id;			# issue_unique_widget_id	is from   src/lib/x-kit/widget/gui/issue-unique-widget-id.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg
    package sm  =  string_map;					# string_map			is from   src/lib/src/string-map.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

    package ebt =  editboss_types;				# editboss_types		is from   src/lib/x-kit/widget/edit/editboss-types.pkg

#   package g2e =  gadget_to_editboss;				# gadget_to_editboss		is from   src/lib/x-kit/widget/edit/guiboss-to-editboss.pkg
    package e2g =  editboss_to_guiboss;				# editboss_to_guiboss		is from   src/lib/x-kit/widget/edit/editboss-to-guiboss.pkg

    package e2t =  editboss_to_textbuffer;			# editboss_to_textbuffer	is from   src/lib/x-kit/widget/edit/editboss-to-textbuffer.pkg
    package t2e =  textbuffer_to_editboss;			# textbuffer_to_editboss	is from   src/lib/x-kit/widget/edit/textbuffer-to-editboss.pkg

    package p2t =  textpane_to_textbuffer;			# textpane_to_textbuffer	is from   src/lib/x-kit/widget/edit/textpane-to-textbuffer.pkg
    package mj  =  mode_junk;					# mode_junk			is from   src/lib/x-kit/widget/edit/mode-junk.pkg

    package que =  queue;					# queue				is from   src/lib/src/queue.pkg
    package nl  =  red_black_numbered_list;			# red_black_numbered_list	is from   src/lib/src/red-black-numbered-list.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

herein

    package fundamental_mode {					# 
	#
	fun make_fundamental_mode ()
	    =
	    {   # In general most modes are likely to have
		# some state variables declared here, which
		# the keymap functions can share.


		fun next_line (was:	mj::Editfn_In)
		    :			mj::Editfn_Out
		    =
		    {   was -> 	  { textlines:		mj::Textlines,
				    cursor:		g2d::Point,							# As in Cursor_And Mark.
				    mark:		Null_Or(g2d::Point),						# 
				    keystring:		String								# User keystroke that invoked this editfn.
				  };
			cursor -> { row, col };

			row = row + 1;

			cursor =  { row, col };

			THE [ mj::CURSOR cursor ];
		    };
		next_line__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "next_line",
			doc	=>  "Move cursor to next line.",
			editfn  =>  next_line
		      };	


		fun previous_line (was:	mj::Editfn_In)
		    :			mj::Editfn_Out
		    =
		    {   was -> 	  { textlines:		mj::Textlines,
				    cursor:		g2d::Point,							# As in Cursor_And Mark.
				    mark:		Null_Or(g2d::Point),						# 
				    keystring:		String								# User keystroke that invoked this editfn.
				  };
			cursor -> { row, col };

			row = (row > 1) ?? row - 1 :: row;

			cursor =  { row, col };

			THE [ mj::CURSOR cursor ];
		    };
		previous_line__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "previous_line",
			doc	=>  "Move cursor to previous line.",
			editfn  =>  previous_line
		      };	


		fun previous_char (was: mj::Editfn_In)
		    :			mj::Editfn_Out
		    =
		    {   was -> 	  { textlines:		mj::Textlines,
				    cursor:		g2d::Point,							# As in Cursor_And Mark.
				    mark:		Null_Or(g2d::Point),						# 
				    keystring:		String								# User keystroke that invoked this editfn.
				  };
			cursor -> { row, col };

			line_key = row - 1;										# Because we number lines 1->N but numbered_lines numbers them 0->(N-1).

			text =  case (nl::find (textlines, line_key))
				    #
				    THE line => line;
				    NULL     => "\n";
				esac;

			text = string::chomp text;

			(string::expand_tabs_and_control_chars { text, col => 0, cursorcol => col })
			  ->
			  { cursor_firstcol_on_screen:	Int,
			    cursor_colcount_on_screen:	Int,
			    ...
			  };

			col =  cursor_firstcol_on_screen - 1;								# The point of this is that if we're on a control-char or tab (which both display on multiple screen columns) we want to move to the previous char, which may mean moving multiple screen columns.

			result =    if (col >= 0)    THE [ mj::CURSOR { row, col } ];					# Normal case: moved back a char within current line.
				    elif (row == 1)  NULL;								# Abnormal case:  Was at start of buffer, couldn't move back.
				    else										# Moved back beyond start of current line so move cursor to end of previous line.
					text =  case (nl::find (textlines, line_key - 1))
						    #
						    THE line => line;
						    NULL     => "\n";							# 
						esac;

					text = string::chomp text;

					(string::expand_tabs_and_control_chars { text, col => 0, cursorcol => 0 })
					  ->
					  { textlen_in_screencols:	Int,
					    ...
					  };

					THE [ mj::CURSOR { row => row - 1, col => textlen_in_screencols } ];
				    fi;

			result;
		    };
		previous_char__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "previous_char",
			doc	=>  "Move cursor to previous char.",
			editfn  =>  previous_char
		      };	


		fun forward_char (was:	mj::Editfn_In)
		    :			mj::Editfn_Out
		    =
		    {   was -> 	  { textlines:		mj::Textlines,
				    cursor:		g2d::Point,							# As in Cursor_And Mark.
				    mark:		Null_Or(g2d::Point),						# 
				    keystring:		String								# User keystroke that invoked this editfn.
				  };
			cursor -> { row, col };

			line_key = row - 1;										# Because we number lines 1->N but numbered_lines numbers them 0->(N-1).

			text =  case (nl::find (textlines, line_key))
				    #
				    THE line => line;
				    NULL     => "\n";
				esac;

			text =  string::chomp  text;

			(string::expand_tabs_and_control_chars { text, col => 0, cursorcol => col })
			  ->
			  { cursor_firstcol_on_screen:	Int,
			    cursor_colcount_on_screen:	Int,
			    textlen_in_screencols:	Int,
			    ...
			  };

			col =  cursor_firstcol_on_screen + cursor_colcount_on_screen;					# The point of this is that if we're on a control-char or tab (which both display on multiple screen columns) we want to move to the next char, which may mean moving multiple screen columns.

			cursor =    if (col <= textlen_in_screencols)
					#
					{ row, col };									# Move right within line.
				    else
					{ row => row + 1, col => 0 };							# Wrap around at end of line to start of next line.
				    fi;

			THE [ mj::CURSOR cursor ];
		    };
		forward_char__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "forward_char",
			doc	=>  "Move cursor to next char.",
			editfn  =>  forward_char
		      };	


		fun move_beginning_of_line (was:	mj::Editfn_In)
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { textlines:		mj::Textlines,
				    cursor:		g2d::Point,							# As in Cursor_And Mark.
				    mark:		Null_Or(g2d::Point),						# 
				    keystring:		String								# User keystroke that invoked this editfn.
				  };
			cursor -> { row, col };

			cursor =  { row, col => 0 };

			THE [ mj::CURSOR cursor ];
		    };
		move_beginning_of_line__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "move_beginning_of_line",
			doc	=>  "Move cursor to start of current line.",
			editfn  =>  move_beginning_of_line
		      };	


		fun move_end_of_line (was:		mj::Editfn_In)
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { textlines:		mj::Textlines,
				    cursor:		g2d::Point,							# As in Cursor_And Mark.
				    mark:		Null_Or(g2d::Point),						# 
				    keystring:		String								# User keystroke that invoked this editfn.
				  };
			cursor -> { row, col };

			line_key = row - 1;										# Because we number lines 1->N but numbered_lines numbers them 0->(N-1).

			text =  case (nl::find (textlines, line_key))
				    #
				    THE line => line;
				    NULL     => "\n";
				esac;

			text =  string::chomp  text;

			(string::expand_tabs_and_control_chars { text, col => 0, cursorcol => col })
			  ->
			  { textlen_in_screencols:	Int,
			    ...
			  };

			cursor =  { row, col => textlen_in_screencols };

			THE [ mj::CURSOR cursor ];
		    };
		move_end_of_line__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "move_end_of_line",
			doc	=>  "Move cursor to start of current line.",
			editfn  =>  move_end_of_line
		      };	


		fun delete_one_char											# Implements functionality common to delete_char and delete_backward_char.
		      (
			textlines:	mj::Textlines,
			cursor:		g2d::Point,
			mark:		Null_Or(g2d::Point)								# 
		      )
		    :					mj::Editfn_Out
		    =
		    {	cursor -> { row, col };
			#
			line_key = row - 1;										# Because we number lines 1->N but numbered_lines numbers them 0->(N-1).

			result
			    =
			    case (nl::find (textlines, line_key))
				#
				THE text => {   chomped_text =  string::chomp  text;

						(string::expand_tabs_and_control_chars { text => chomped_text, col => 0, cursorcol => col })
						  ->
						  { textlen_in_screencols:		Int,
						    #
						    cursor_byteoffset_in_input:	Int,
						    cursor_bytecount_in_input:	Int,
						    ...
						  };

						if (col >= textlen_in_screencols)
						    #
						    THE [ ];								# Cursor is on non-existent char past end of existing line.  Don't fail, but don't do anything either. (emacs deletes the end-of-line newline here, but I prefer to have only kill_line do that.)
						else
															# Cursor is on an existing char, possibly a multibyte utf8 char.  Excise it by replacing the line with the concatenation of the substrings preceding and following the char.
						    text_before_cursor
							=
							string::substring
							  (
							    text,							# String from which to extract substring.
							    0,								# The substring we want starts at offset 0.
							    cursor_byteoffset_in_input					# The substring we want runs to location of cursor.  Treating curso offset as length works (only) because we're starting substring at offset zero.
							  );

						    text_after_cursor
							=
							string::extract
							  (
							    text,							# String from which to extract substring.
							    cursor_byteoffset_in_input + cursor_bytecount_in_input,	# Substring starts immediately after the byte(s) under the cursor.  (Cursor will mark multiple bytes only if it is on a multibyte utf8 char.)
							    NULL							# Substring runs to end of 'text'.
							  );

						    updated_text	=  string::cat [ text_before_cursor,
											 text_after_cursor
										       ];

						    updated_textlines 							# First remove existing line -- nl::set does NOT remove any previous line at that key.
							=
							{   (nl::remove (textlines, line_key))
								->
								(updated_textlines, oldline);

							    updated_textlines;
							}	
							except _ = textlines;						# This will happen if there is no line 'line_key' in textlines.

						    updated_textlines							# Now insert updated line.
							=
							nl::set (updated_textlines, line_key, updated_text);

						    THE [ mj::TEXTLINES updated_textlines,
							  mj::CURSOR { row, col }					# Needed for delete_backward_char, where cursor position changes.
							];
						fi; 	
					    };

				NULL     => THE [ ];									# Cursor is on non-existent line.  Don't fail, but don't do anything either.
			    esac;

			result;
		    };

		fun delete_char (was:			mj::Editfn_In)
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { textlines:		mj::Textlines,
				    cursor:		g2d::Point,							# As in Cursor_And Mark.
				    mark:		Null_Or(g2d::Point),						# 
				    keystring:		String								# User keystroke that invoked this editfn.
				  };
			cursor -> { row, col };

			delete_one_char (textlines, cursor, mark);							# Code shared with delete_backward_char.
		    };
		delete_char__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "delete_char",
			doc	=>  "Delete char under cursor.",
			editfn  =>  delete_char
		      };	

		fun delete_backward_char (was:		mj::Editfn_In)
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { textlines:		mj::Textlines,
				    cursor:		g2d::Point,							# As in Cursor_And Mark.
				    mark:		Null_Or(g2d::Point),						# 
				    keystring:		String								# User keystroke that invoked this editfn.
				  };
			cursor -> { row, col };

			if (col > 0)
			    #
			    col = col - 1;

			    cursor = { row, col };

			    delete_one_char (textlines, cursor, mark);							# Code shared with delete_char.
			    #
			elif (row > 1)											# Delete preceding newline, appending current line to previous line.
			    #
			    cursor -> { row, col };

			    line_key2 =        row - 1;									# Because we number lines 1->N but numbered_lines numbers them 0->(N-1).
			    line_key1 =  line_key2 - 1;									# 

			    result =	case (nl::find (textlines, line_key1), nl::find (textlines, line_key2))
					    #
					    (THE line1, THE line2)
						=>
						{   chomped_line1 =  string::chomp  line1;
						    #
						    (string::expand_tabs_and_control_chars { text => chomped_line1, col => 0, cursorcol => col })
						      ->
						      { textlen_in_screencols:		Int,
							...
						      };

						    line12 = string::cat [ chomped_line1, line2 ];			# Prepend line1 (sans newline) to line2 to produce replacement for the pair of them.

						    updated_textlines 							# First remove existing two lines -- nl::set does NOT remove any previous line at that key.
							=
							{   (nl::remove (textlines,         line_key1)) -> (updated_textlines, _);
							    (nl::remove (updated_textlines, line_key1)) -> (updated_textlines, _);

							    updated_textlines;
							}	
							except _ = textlines;						# This will happen if there is no line 'line_key' in textlines.

						    updated_textlines							# Now insert updated line.
							=
							nl::set (updated_textlines, line_key1, line12);

						    THE [ mj::TEXTLINES updated_textlines,
							  mj::CURSOR { row => row - 1, col => textlen_in_screencols }	# Position cursor at end of previous line1 -- start of contents of merged-in former line2.
							];
						};

					    _  => NULL;									# Should maybe think harder about how/if this case can happen and if it can, what we should be doing. XXX SUCKO FIXME.
					esac;

			    result;
			else
			    NULL;											# Fail: No preceding char to delete in line.
			fi;
		    };
		delete_backward_char__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "delete_backward_char",
			doc	=>  "Delete char to left of cursor.",
			editfn  =>  delete_backward_char
		      };	


		fun self_insert_command (was:		mj::Editfn_In)
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { textlines:		mj::Textlines,
				    cursor:		g2d::Point,							# As in Cursor_And Mark.
				    mark:		Null_Or(g2d::Point),						# 
				    keystring:		String								# User keystroke that invoked this editfn.
				  };
			cursor -> { row, col };

			line_key = row - 1;										# Because we number lines 1->N but numbered_lines numbers them 0->(N-1).

			text =  case (nl::find (textlines, line_key))
				    #
				    THE line => line;
# XXX SUCKO FIXME: TBD 
				    NULL     => "\n";
				esac;

			chomped_text =  string::chomp  text;

			(string::expand_tabs_and_control_chars { text => chomped_text, col => 0, cursorcol => col })
			  ->
			  { textlen_in_screencols:	Int,
			    cursor_byteoffset_in_input:	Int,
			    ...
			  };

			if (col >= textlen_in_screencols)
			    #
# XXX SUCKO FIXME: TBD 
			    THE [ ];								# Cursor is on non-existent char past end of existing line.  Don't fail, but don't do anything either. (emacs deletes the end-of-line newline here, but I prefer to have only kill_line do that.)
			else
												# Cursor is on an existing char, possibly a multibyte utf8 char.  Excise it by replacing the line with the concatenation of the substrings preceding and following the char.
			    text_before_cursor
				=
				string::substring
				  (
				    text,							# String from which to extract substring.
				    0,								# The substring we want starts at offset 0.
				    cursor_byteoffset_in_input					# The substring we want runs to location of cursor.  Treating curso offset as length works (only) because we're starting substring at offset zero.
				  );

			    text_after_cursor
				=
				string::extract
				  (
				    text,							# String from which to extract substring.
				    cursor_byteoffset_in_input,					# Substring starts at the byte(s) under the cursor.  (Cursor will mark multiple bytes only if it is on a multibyte utf8 char.)
				    NULL							# Substring runs to end of 'text'.
				  );

			    updated_text	=  string::cat [ text_before_cursor,
								 keystring,
								 text_after_cursor
							       ];

			    updated_textlines 							# First remove existing line -- nl::set does NOT remove any previous line at that key.
				=
				{   (nl::remove (textlines, line_key))
					->
					(updated_textlines, oldline);

				    updated_textlines;
				}	
				except _ = textlines;						# This will happen if there is no line 'line_key' in textlines.

			    updated_textlines							# Now insert updated line.
				=
				nl::set (updated_textlines, line_key, updated_text);

			    cursor = { row, col => col + 1 };	

			    THE   [ mj::TEXTLINES updated_textlines,
				    mj::CURSOR cursor
				  ];
			fi; 	
		    };
		self_insert_command__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "self_insert_command",
			doc	=>  "Insert keystroke at cursor.",
			editfn  =>  self_insert_command
		      };	

		fun newline 		(was:		mj::Editfn_In)							# Split line at cursor, leave cursor at start of new line.
		    :					mj::Editfn_Out
		    =
		    {   was -> 	  { textlines:		mj::Textlines,
				    cursor:		g2d::Point,							# As in Cursor_And Mark.
				    mark:		Null_Or(g2d::Point),						# 
				    keystring:		String								# User keystroke that invoked this editfn.
				  };
			cursor -> { row, col };

			line_key = row - 1;										# Because we number lines 1->N but numbered_lines numbers them 0->(N-1).

			text =  case (nl::find (textlines, line_key))
				    #
				    THE line => line;
# XXX SUCKO FIXME: TBD 
				    NULL     => "\n";
				esac;

			chomped_text =  string::chomp  text;

			(string::expand_tabs_and_control_chars { text => chomped_text, col => 0, cursorcol => col })
			  ->
			  { textlen_in_screencols:	Int,
			    cursor_byteoffset_in_input:	Int,
			    ...
			  };

			if (col >= textlen_in_screencols)
			    #
# XXX SUCKO FIXME: TBD 
			    THE [ ];								# Cursor is on non-existent char past end of existing line.  Don't fail, but don't do anything either. (emacs deletes the end-of-line newline here, but I prefer to have only kill_line do that.)
			else
												# Cursor is on an existing char, possibly a multibyte utf8 char.  Excise it by replacing the line with the concatenation of the substrings preceding and following the char.
			    text_before_cursor
				=
				string::substring
				  (
				    text,							# String from which to extract substring.
				    0,								# The substring we want starts at offset 0.
				    cursor_byteoffset_in_input					# The substring we want runs to location of cursor.  Treating curso offset as length works (only) because we're starting substring at offset zero.
				  );

			    text_after_cursor
				=
				string::extract
				  (
				    text,							# String from which to extract substring.
				    cursor_byteoffset_in_input,					# Substring starts at the byte(s) under the cursor.  (Cursor will mark multiple bytes only if it is on a multibyte utf8 char.)
				    NULL							# Substring runs to end of 'text'.
				  );

			    # We're splitting the current line into two.
			    # Synthesize those two lines:
			    #
			    line1 =  string::cat [ text_before_cursor, "\n" ];
			    line2 =                text_after_cursor;

			    updated_textlines 							# First remove existing line -- nl::set does NOT remove any previous line at that key.
				=
				{   (nl::remove (textlines, line_key))
					->
					(updated_textlines, oldline);

				    updated_textlines;
				}	
				except _ = textlines;						# This will happen if there is no line 'line_key' in textlines.

			    updated_textlines = nl::set (updated_textlines, line_key, line2);	# Now insert the two new lines.
			    updated_textlines = nl::set (updated_textlines, line_key, line1);	# 

			    THE   [ mj::TEXTLINES updated_textlines,
				    mj::CURSOR { row => row + 1, col => 0 }			# Leave cursor at start of second line.
				  ];
			fi; 	
		    };
		newline__editfn
		    =
		    mj::PLAIN_EDITFN
		      {
			name	=>  "newline",
			doc	=>  "Split line at cursor, leave cursor at start of new line.",
			editfn  =>  newline
		      };	

		fundamental_mode
		    =
		    keymap
		    where
			keymap = sm::empty;
			#
			keymap = sm::set (keymap, "C-a",	move_beginning_of_line__editfn	);
			keymap = sm::set (keymap, "C-b",	previous_char__editfn		);
			keymap = sm::set (keymap, "C-d",	delete_char__editfn		);
			keymap = sm::set (keymap, "C-e",	move_end_of_line__editfn	);
			keymap = sm::set (keymap, "C-f",	forward_char__editfn		);
			keymap = sm::set (keymap, "C-n",	next_line__editfn		);
			keymap = sm::set (keymap, "C-p",	previous_line__editfn		);
			keymap = sm::set (keymap, "RET",	newline__editfn			);
			#
			keymap = sm::set (keymap, "<backspace>",delete_backward_char__editfn	);
			keymap = sm::set (keymap, "<delete>",	delete_char__editfn		);
			keymap = sm::set (keymap, "<down>",	next_line__editfn		);
			keymap = sm::set (keymap, "<end>",	move_end_of_line__editfn	);
			keymap = sm::set (keymap, "<home>",	move_beginning_of_line__editfn	);
			keymap = sm::set (keymap, "<left>",	previous_char__editfn		);
			keymap = sm::set (keymap, "<right>",	forward_char__editfn		);
			keymap = sm::set (keymap, "<up>",	previous_line__editfn		);

			keymap =    mj::add_editfn_to_keymap_throughout_char_range
				      {
					keymap,
					keymap_node =>  self_insert_command__editfn,
					#
					firstchar   =>  ' ',
					lastchar    =>	'~'
				      };	
		    end;

		fundamental_mode;
	    };
    };

end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
