## fundamental-mode.pkg
#
# Support fns for textmill_imp -- mostly editing		# textmill_imp			is from   src/lib/x-kit/widget/edit/textmill-imp.pkg
# fns to be bound to keystrokes.
#
# See also:
#     src/lib/x-kit/widget/edit/textpane.pkg
#     src/lib/x-kit/widget/edit/editboss-imp.pkg
#     src/lib/x-kit/widget/edit/textmill-imp.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
#   package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package ct  =  cutbuffer_types;				# cutbuffer_types		is from   src/lib/x-kit/widget/edit/cutbuffer-types.pkg
#   package ct  =  gui_to_object_theme;				# gui_to_object_theme		is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
#   package bt  =  gui_to_sprite_theme;				# gui_to_sprite_theme		is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
#   package wt  =  widget_theme;				# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

#   package os  =  guiboss_to_spritespace;			# guiboss_to_spritespace	is from   src/lib/x-kit/widget/space/sprite/guiboss-to-spritespace.pkg
#   package cs  =  guiboss_to_objectspace;			# guiboss_to_objectspace	is from   src/lib/x-kit/widget/space/object/guiboss-to-objectspace.pkg

    package psx =  posixlib;					# posixlib			is from   src/lib/std/src/psx/posixlib.pkg
    package sj  =  string_junk;					# string_junk			is from   src/lib/std/src/string-junk.pkg

    package boi =  spritespace_imp;				# spritespace_imp		is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;				# objectspace_imp		is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;				# widgetspace_imp		is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;				# guiboss_to_guishim		is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2s =  spritespace_to_sprite;			# spritespace_to_sprite		is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;			# objectspace_to_object		is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2b =  sprite_to_spritespace;			# sprite_to_spritespace		is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2c =  object_to_objectspace;			# object_to_objectspace		is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg

#   package g2b =  gadget_to_editboss;				# gadget_to_editboss		is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg
    package sm  =  string_map;					# string_map			is from   src/lib/src/string-map.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

    package ebt =  editboss_types;				# editboss_types		is from   src/lib/x-kit/widget/edit/editboss-types.pkg

    package e2g =  editboss_to_guiboss;				# editboss_to_guiboss		is from   src/lib/x-kit/widget/edit/editboss-to-guiboss.pkg

    package mj  =  mode_junk;					# mode_junk			is from   src/lib/x-kit/widget/edit/mode-junk.pkg

    package que =  queue;					# queue				is from   src/lib/src/queue.pkg
    package nl  =  red_black_numbered_list;			# red_black_numbered_list	is from   src/lib/src/red-black-numbered-list.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

herein

    package fundamental_mode {					# 
	#
	fun next_line (was:	mj::Editfn_In)
	    :			mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or( g2d::Point ),					# 
			    lastmark:			Null_Or( g2d::Point ),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };
		point -> { row, col };

		row = row + 1;

		point =  { row, col };

		WORK [ mj::POINT point ];
	    };
	next_line__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "next_line",
		  doc	 =>  "Move point (cursor) to next line.",
		  args	 =>  [],
		  editfn =>  next_line
		}
	      );


	fun previous_line (was:	mj::Editfn_In)
	    :			mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };
		point -> { row, col };

		row = (row > 0) ?? row - 1 :: row;

		point =  { row, col };

		WORK [ mj::POINT point ];
	    };
	previous_line__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "previous_line",
		  doc	 =>  "Move point (cursor) to previous line.",
		  args	 =>  [],
		  editfn =>  previous_line
		}
	      );


	fun previous_char (was: mj::Editfn_In)
	    :			mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };
		point -> { row, col };

		line_key = row;											# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

		text =  case (nl::find (textlines, line_key))
			    #
			    THE line => line;
			    NULL     => "\n";
			esac;

		text = string::chomp text;

		(string::expand_tabs_and_control_chars
		  {
		    utf8text	=> text,
		    startcol	=>  0,
		    screencol1	=>  col,
		    screencol2	=>  0,
		    utf8byte	=>  0
		  })
		  ->
		  { screencol1_firstcol_on_screen:	Int,
		    screencol1_colcount_on_screen:	Int,
		    ...
		  };

		col =  screencol1_firstcol_on_screen - 1;							# The point of this is that if we're on a control-char or tab (which both display on multiple screen columns) we want to move to the previous char, which may mean moving multiple screen columns.

		result =    if   (col >= 0)  WORK [ mj::POINT { row, col } ];					# Normal case: moved back a char within current line.
			    elif (row == 1)  FAIL "Start of buffer";						# Abnormal case:  Was at start of buffer, couldn't move back.
			    else										# Moved back beyond start of current line so move cursor to end of previous line.
				text =  case (nl::find (textlines, line_key - 1))
					    #
					    THE line => line;
					    NULL     => "\n";							# 
					esac;

				text = string::chomp text;

				(string::expand_tabs_and_control_chars
				  {
				    utf8text	=> text,
				    startcol	=>  0,
				    screencol1	=>  0,
				    screencol2	=>  0,
				    utf8byte	=>  0
				  })
				  ->
				  { screentext_length_in_screencols:	Int,
				    ...
				  };

				WORK [ mj::POINT { row => row - 1, col => screentext_length_in_screencols } ];
			    fi;

		result;
	    };
	previous_char__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "previous_char",
		  doc	 =>  "Move point (cursor) to previous char.",
		  args	 =>  [],
		  editfn =>  previous_char
		}
	      );


	fun forward_char (was:	mj::Editfn_In)
	    :			mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };
		point -> { row, col };

		line_key = row;											# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

		text =  case (nl::find (textlines, line_key))
			    #
			    THE line => line;
			    NULL     => "\n";
			esac;

		text =  string::chomp  text;

		(string::expand_tabs_and_control_chars
		  {
		    utf8text	=> text,
		    startcol	=>  0,
		    screencol1	=>  col,
		    screencol2	=>  0,
		    utf8byte	=>  0
		  })
		  ->
		  { screencol1_firstcol_on_screen:	Int,
		    screencol1_colcount_on_screen:	Int,
		    screentext_length_in_screencols:	Int,
		    ...
		  };

		col =  screencol1_firstcol_on_screen + screencol1_colcount_on_screen;				# The point of this is that if we're on a control-char or tab (which both display on multiple screen columns) we want to move to the next char, which may mean moving multiple screen columns.

		point =     if (col <= screentext_length_in_screencols)
				#
				{ row, col };									# Move right within line.
			    else
				{ row => row + 1, col => 0 };							# Wrap around at end of line to start of next line.
			    fi;

		WORK [ mj::POINT point ];
	    };
	forward_char__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "forward_char",
		  doc	 =>  "Move point (cursor) to next char.",
		  args	 =>  [],
		  editfn =>  forward_char
		}
	      );


	fun move_beginning_of_line (was:	mj::Editfn_In)
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };
		point -> { row, col };

		point =  { row, col => 0 };

		WORK [ mj::POINT point ];
	    };
	move_beginning_of_line__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "move_beginning_of_line",
		  doc	 =>  "Move point (cursor) to start of current line.",
		  args	 =>  [],
		  editfn =>  move_beginning_of_line
		}
	      );


	fun move_end_of_line (was:		mj::Editfn_In)
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };
		point -> { row, col };

		line_key = row;											# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

		text =  case (nl::find (textlines, line_key))
			    #
			    THE line => line;
			    NULL     => "\n";
			esac;

		text =  string::chomp  text;

		(string::expand_tabs_and_control_chars
		  {
		    utf8text	=> text,
		    startcol	=>  0,
		    screencol1	=>  0,
		    screencol2	=>  0,
		    utf8byte	=>  0
		  })
		  ->
		  { screentext_length_in_screencols:	Int,
		    ...
		  };

		point =  { row, col => screentext_length_in_screencols };

		WORK [ mj::POINT point ];
	    };
	move_end_of_line__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "move_end_of_line",
		  doc	 =>  "Move point (cursor) to start of current line.",
		  args	 =>  [],
		  editfn =>  move_end_of_line
		}
	      );


	fun delete_one_char											# Implements functionality common to delete_char and delete_backward_char.
	      (
		textlines:	mj::Textlines,
		point:		g2d::Point,
		mark:		Null_Or(g2d::Point)								# 
	      )
	    :					mj::Editfn_Out
	    =
	    {	point -> { row, col };
		#
		line_key = row;											# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

		result
		    =
		    case (nl::find (textlines, line_key))
			#
			THE text => {   chomped_text =  string::chomp  text;

					(string::expand_tabs_and_control_chars
					  {
					    utf8text	=>  chomped_text,
					    startcol	=>  0,
					    screencol1	=>  col,
					    screencol2	=>  0,
					    utf8byte	=>  0
					  })
					  ->
					  { screentext_length_in_screencols:	Int,
					    #
					    screencol1_byteoffset_in_utf8text:	Int,
					    screencol1_bytescount_in_utf8text:	Int,
					    ...
					  };

					if (col >= screentext_length_in_screencols)
					    #
					    WORK [ ];									# Cursor is on non-existent char past end of existing line.  Don't fail, but don't do anything either. (emacs deletes the end-of-line newline here, but I prefer to have only kill_line do that.)
					else
															# Cursor is on an existing char, possibly a multibyte utf8 char.  Excise it by replacing the line with the concatenation of the substrings preceding and following the char.
					    text_before_point
						=
						string::substring
						  (
						    text,								# String from which to extract substring.
						    0,									# The substring we want starts at offset 0.
						    screencol1_byteoffset_in_utf8text					# The substring we want runs to location of cursor.  Treating cursor offset as length works (only) because we're starting substring at offset zero.
						  );

					    text_beyond_point
						=
						string::extract
						  (
						    text,								# String from which to extract substring.
						    screencol1_byteoffset_in_utf8text + screencol1_bytescount_in_utf8text,	# Substring starts immediately after the byte(s) under the cursor.  (Cursor will mark multiple bytes only if it is on a multibyte utf8 char.)
						    NULL								# Substring runs to end of 'text'.
						  );

					    updated_text	=  string::cat [ text_before_point,
										 text_beyond_point
									       ];

					    updated_textlines 								# First remove existing line -- nl::set does NOT remove any previous line at that key.
						=
						(nl::remove (textlines, line_key))
						except _ = textlines;							# This will happen if there is no line 'line_key' in textlines.

					    updated_textlines								# Now insert updated line.
						=
						nl::set (updated_textlines, line_key, updated_text);

					    WORK  [ mj::TEXTLINES updated_textlines,
						    mj::POINT { row, col }						# Needed for delete_backward_char, where cursor position changes.
						  ];
					fi; 	
				    };

			NULL     => WORK [ ];										# Cursor is on non-existent line.  Don't fail, but don't do anything either.
		    esac;

		result;
	    };

	fun delete_char (was:			mj::Editfn_In)
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,							# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),						# 
			    lastmark:			Null_Or(g2d::Point),						# 
			    readonly:			Bool,								# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,								# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),							# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		if readonly
		    #
		    FAIL "Buffer is read-only.";
		else
		    point -> { row, col };

		    delete_one_char (textlines, point, mark);								# Code shared with delete_backward_char.
		fi;
	    };
	delete_char__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "delete_char",
		  doc	 =>  "Delete char under point (cursor).",
		  args	 =>  [],
		  editfn =>  delete_char
		}
	      );

	fun delete_backward_char (was:		mj::Editfn_In)
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,							# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),						# 
			    lastmark:			Null_Or(g2d::Point),						# 
			    readonly:			Bool,								# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,								# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),							# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		if readonly
		    #
		    FAIL "Buffer is read-only";
		else	
		    point -> { row, col };

		    if (col > 0)
			#
			col = col - 1;

			point = { row, col };

			delete_one_char (textlines, point, mark);								# Code shared with delete_char.
			#
		    elif (row > 1)												# Delete preceding newline, appending current line to previous line.
			#
			point -> { row, col };

			line_key2 =        row;											# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).
			line_key1 =  line_key2 - 1;										# 

			result =	case (nl::find (textlines, line_key1), nl::find (textlines, line_key2))
					#
					(THE line1, THE line2)
					    =>
					    {   chomped_line1 =  string::chomp  line1;
						#
						(string::expand_tabs_and_control_chars
						  {
						    utf8text   =>  chomped_line1,
						    startcol   =>  0,
						    screencol1 =>  col,
						    screencol2 =>  0,
						    utf8byte   =>  0
						  })
						  ->
						  { screentext_length_in_screencols:		Int,
						    ...
						  };

						line12 = string::cat [ chomped_line1, line2 ];					# Prepend line1 (sans newline) to line2 to produce replacement for the pair of them.

						updated_textlines 								# First remove existing two lines -- nl::set does NOT remove any previous line at that key.
						    =
						    {   updated_textlines = nl::remove (textlines,         line_key1);
							updated_textlines = nl::remove (updated_textlines, line_key1);

							updated_textlines;
						    }	
						    except _ = textlines;							# This will happen if there is no line 'line_key' in textlines.

						updated_textlines								# Now insert updated line.
						    =
						    nl::set (updated_textlines, line_key1, line12);

						WORK  [ mj::TEXTLINES updated_textlines,
						        mj::POINT { row => row - 1, col => screentext_length_in_screencols }	# Position cursor at end of previous line1 -- start of contents of merged-in former line2.
						      ];
					    };

					_  => FAIL "<???>";									# Should maybe think harder about how/if this case can happen and if it can, what we should be doing. XXX SUCKO FIXME.
				    esac;

			result;
		    else
			FAIL "No preceding char in line to delete";								# Fail: No preceding char to delete in line.
		    fi;
		fi;
	    };
	delete_backward_char__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "delete_backward_char",
		  doc	 =>  "Delete char to left of point (cursor).",
		  args	 =>  [],
		  editfn =>  delete_backward_char
		}
	      );


	fun self_insert_command (was:		mj::Editfn_In)
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,							# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),						# 
			    lastmark:			Null_Or(g2d::Point),						# 
			    readonly:			Bool,								# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,								# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),							# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss
			  };

		if readonly
		    #
		    FAIL "Buffer is read-only";
		else
		    point -> { row, col };

		    line_key = row;												# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

		    text =  case (nl::find (textlines, line_key))
				#
				THE line => line;
    # XXX SUCKO FIXME: TBD 
				NULL     => "\n";
			    esac;

		    chomped_text =  string::chomp  text;

		    (string::expand_tabs_and_control_chars
		      {
			utf8text	=>  chomped_text,
			startcol	=>  0,
			screencol1	=>  col,
			screencol2	=>  0,
			utf8byte	=>  0
		      })
		      ->
		      { screentext_length_in_screencols:	Int,
			screencol1_byteoffset_in_utf8text:	Int,
			...
		      };

		    if (col >= screentext_length_in_screencols)
			#
    # XXX SUCKO FIXME: TBD 
			WORK [ ];												# Cursor is on non-existent char past end of existing line.  Don't fail, but don't do anything either. (emacs deletes the end-of-line newline here, but I prefer to have only kill_line do that.)
		    else
															    # Cursor is on an existing char, possibly a multibyte utf8 char.  Excise it by replacing the line with the concatenation of the substrings preceding and following the char.
			text_before_point
			    =
			    string::substring
			      (
				text,											# String from which to extract substring.
				0,												# The substring we want starts at offset 0.
				screencol1_byteoffset_in_utf8text								# The substring we want runs to location of point.  Treating cursor offset as length works (only) because we're starting substring at offset zero.
			      );

			text_beyond_point
			    =
			    string::extract
			      (
				text,											# String from which to extract substring.
				screencol1_byteoffset_in_utf8text,								# Substring starts at the byte(s) under the cursor.  (Cursor will mark multiple bytes only if it is on a multibyte utf8 char.)
				NULL											# Substring runs to end of 'text'.
			      );

			updated_text	=  string::cat [ text_before_point,
							     keystring,
							     text_beyond_point
							   ];

			updated_textlines 											# First remove existing line -- nl::set does NOT remove any previous line at that key.
			    =
			    (nl::remove (textlines, line_key))
			    except _ = textlines;										# This will happen if there is no line 'line_key' in textlines.

			updated_textlines											# Now insert updated line.
			    =
			    nl::set (updated_textlines, line_key, updated_text);

			point = { row, col => col + 1 };	

			WORK  [ mj::TEXTLINES updated_textlines,
				mj::POINT point
			      ];
		    fi; 	
		fi;
	    };
	self_insert_command__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "self_insert_command",
		  doc	 =>  "Insert keystroke at point (cursor).",
		  args	 =>  [],
		  editfn =>  self_insert_command
		}
	      );

	fun newline 		(was:		mj::Editfn_In)								# Split line at cursor, leave cursor at start of new line.
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,							# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),						# 
			    lastmark:			Null_Or(g2d::Point),						# 
			    readonly:			Bool,								# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,								# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),							# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };
		if readonly
		    #
		    FAIL "Buffer is read-only";
		else
		    point -> { row, col };

		    line_key = row;												# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

		    text =  case (nl::find (textlines, line_key))
				#
				THE line => line;
# XXX SUCKO FIXME: TBD 
				NULL     => "\n";
			    esac;

		    chomped_text =  string::chomp  text;

		    (string::expand_tabs_and_control_chars
		      {
			utf8text	=>  chomped_text,
			startcol	=>  0,
			screencol1	=>  col,
			screencol2	=>  0,
			utf8byte	=>  0
		      })
		      ->
		      { screentext_length_in_screencols:	Int,
			screencol1_byteoffset_in_utf8text:	Int,
			...
		      };

		    if (col >= screentext_length_in_screencols)
			#
# XXX SUCKO FIXME: TBD 
			WORK [ ];												# Cursor is on non-existent char past end of existing line.  Don't fail, but don't do anything either. (emacs deletes the end-of-line newline here, but I prefer to have only kill_line do that.)
		    else
															    # Cursor is on an existing char, possibly a multibyte utf8 char.  Excise it by replacing the line with the concatenation of the substrings preceding and following the char.
			text_before_point
			    =
			    string::substring
			      (
				text,											# String from which to extract substring.
				0,												# The substring we want starts at offset 0.
				screencol1_byteoffset_in_utf8text								# The substring we want runs to location of cursor.  Treating cursor offset as length works (only) because we're starting substring at offset zero.
			      );

			text_beyond_point
			    =
			    string::extract
			      (
				text,											# String from which to extract substring.
				screencol1_byteoffset_in_utf8text,								# Substring starts at the byte(s) under the cursor.  (Cursor will mark multiple bytes only if it is on a multibyte utf8 char.)
				NULL											# Substring runs to end of 'text'.
			      );

			# We're splitting the current line into two.
			# Synthesize those two lines:
			#
			line1 =  string::cat [ text_before_point, "\n" ];
			line2 =                text_beyond_point;

			updated_textlines 											# First remove existing line -- nl::set does NOT remove any previous line at that key.
			    =
			    (nl::remove (textlines, line_key))
			    except _ = textlines;										# This will happen if there is no line 'line_key' in textlines.

			updated_textlines = nl::set (updated_textlines, line_key, line2);					# Now insert the two new lines.
			updated_textlines = nl::set (updated_textlines, line_key, line1);					# 

			WORK  [ mj::TEXTLINES updated_textlines,
				mj::POINT { row => row + 1, col => 0 }							# Leave cursor at start of second line.
			      ];
		    fi; 	
		fi;
	    };
	newline__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "newline",
		  doc	 =>  "Split line at point (cursor), leave point at start of new line.",
		  args	 =>  [],
		  editfn =>  newline
		}
	      );


	fun kill_whole_line 	(was:		mj::Editfn_In)								# Remove complete line under cursor, leave cursor at same column on next line.
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,							# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),						# 
			    lastmark:			Null_Or(g2d::Point),						# 
			    readonly:			Bool,								# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,								# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),							# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };
		if readonly
		    #
		    FAIL "Buffer is read-only";
		else
		    point -> { row, col };

		    line_key = row;												# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

		    oldline = (nl::get (textlines, line_key))
			      except _ = "\n";										# This will happen if there is no line 'line_key' in textlines.

		    updated_textlines		 									# Remove line.
			=
			(nl::remove (textlines, line_key))
			except _ = textlines;										# This will happen if there is no line 'line_key' in textlines.

		    gadget_to_editboss
			->
			mj::GADGET_TO_EDITBOSS  eb;

		    eb.set_cutbuffer_contents (ct::WHOLELINE oldline);

		    WORK  [ mj::TEXTLINES updated_textlines ];
		fi;
	    };
	kill_whole_line__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "kill_whole_line",
		  doc	 =>  "Remove complete line under point (cursor), leave point at same column on next line.",
		  args	 =>  [],
		  editfn =>  kill_whole_line
		}
	      );


	fun yank 		(was:		mj::Editfn_In)								# Insert contents of cutbuffer at cursor. Insertion style depends on cutbuffer contents type.
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,							# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),						# 
			    lastmark:			Null_Or(g2d::Point),						# 
			    readonly:			Bool,								# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,								# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),							# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		if readonly
		    #
		    FAIL "Buffer is read-only";
		else
		    point -> { row, col };

		    line_key = row;												# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

		    gadget_to_editboss
			->
			mj::GADGET_TO_EDITBOSS  eb;

		    case (eb.get_cutbuffer_contents())
			#
			ct::PARTLINE  text_to_insert									# Used for vanilla cut operations confined to a single line.
			    =>
			    {
				line_key = point.row;									# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

				text =  case (nl::find (textlines, line_key))
					    #
					    THE line => line;
					    NULL     => "\n";
					esac;

				chomped_text =  string::chomp  text;

				(string::expand_tabs_and_control_chars
				  {
				    utf8text	=>  chomped_text,
				    startcol	=>  0,
				    screencol1	=>  point.col,
				    screencol2	=>  0,
				    utf8byte	=>  0
				  })
				  ->
				  { screencol1_byteoffset_in_utf8text:	Int,
				    ...
				  };

				textlen = string::length_in_chars  chomped_text;							# This logic is cut-and-pasted from default_redraw_fn in screenline.pkg -- possibly it should be shared via some package.
																    # 
				my  { text_before_point,										# 
				      text_beyond_point										# 
				    }												#
				    =												#
				    if (point.col >= textlen)									#
					#
					{ text_before_point =>  chomped_text + (string::repeat(" ", point.col-textlen   )),		# 
					  text_beyond_point =>  ""
					};
				    else												# Region lies entirely within input string.

					{ text_before_point =>  string::substring (chomped_text, 0			      ,  screencol1_byteoffset_in_utf8text),
					  text_beyond_point =>  string::extract   (chomped_text, screencol1_byteoffset_in_utf8text,  NULL	                 )	except INDEX_OUT_OF_BOUNDS = ""
					};
				    fi;

				updated_line = text_before_point + text_to_insert + text_beyond_point + "\n";			# XXX BUGGO FIXME This assumes the original line ended with a newline, which is not a given.

				updated_textlines
				    =
				    (nl::remove (textlines, line_key));

				updated_textlines
				    =
				    nl::set (updated_textlines, line_key, updated_line);

				(string::expand_tabs_and_control_chars								# Now to compute screen column of end of text_to_insert.
				  {
				    utf8text	=>  text_before_point + text_to_insert,
				    startcol	=>  0,
				    screencol1	=>  point.col,
				    screencol2	=>  0,
				    utf8byte	=>  0
				  })
				  ->
				  { screentext_length_in_screencols:	Int,
				    ...
				  };

				WORK  [ mj::TEXTLINES updated_textlines,
					mj::POINT    { row => point.row,  col => screentext_length_in_screencols },
					mj::MARK     NULL,
					mj::LASTMARK (THE point)
				      ];
			    };

			ct::WHOLELINE string											# Used for special cut operations which cut complete lines even if point (cursor) is in middle of line.
			    =>
			    {   updated_textlines
				    =
				    nl::set (textlines, line_key, string);

				WORK  [ mj::TEXTLINES updated_textlines ];
			    };

			ct::MULTILINE strings											# Used for vanilla cut operations which happen to span more than one line.
			    =>
			    {
				line_key = point.row;										# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

				text =  case (nl::find (textlines, line_key))
					    #
					    THE line => line;
					    NULL     => "\n";
					esac;

				chomped_text =  string::chomp  text;

				(string::expand_tabs_and_control_chars
				  {
				    utf8text	=>  chomped_text,
				    startcol	=>  0,
				    screencol1	=>  point.col,
				    screencol2	=>  0,
				    utf8byte	=>  0
				  })
				  ->
				  { screencol1_byteoffset_in_utf8text:	Int,
				    ...
				  };

				textlen = string::length_in_chars  chomped_text;							# This logic is cut-and-pasted from default_redraw_fn in screenline.pkg -- possibly it should be shared via some package.
																    # 
				my  { text_before_point,										# 
				      text_beyond_point										# 
				    }												#
				    =												#
				    if (point.col >= textlen)									#
					#
					{ text_before_point =>  chomped_text + (string::repeat(" ", point.col-textlen   )),		# 
					  text_beyond_point =>  ""
					};
				    else												# Region lies entirely within input string.

					{ text_before_point =>  string::substring (chomped_text, 0			      ,  screencol1_byteoffset_in_utf8text),
					  text_beyond_point =>  string::extract   (chomped_text, screencol1_byteoffset_in_utf8text,  NULL	                 )	except INDEX_OUT_OF_BOUNDS = ""
					};
				    fi;

				my (firstline, remaininglines)
				    =
				    case strings
					#
					(firstline ! remaininglines) => (firstline, reverse remaininglines);
					[]				 => raise exception DIE "impossible";				# We never generate a ct::MULTILINE containing less than two lines.
				    esac;

				updated_firstline = text_before_point + firstline;


				my (lastline, remaininglines)
				    =
				    case remaininglines
					#
					(lastline ! remaininglines) => (lastline, remaininglines);
					[]				=> raise exception DIE "impossible";				# We never generate a ct::MULTILINE containing less than two lines.
				    esac;

				updated_textlines											# Drop existing firstline, which will be replaced by updated_firstline.
				    =
				    (nl::remove (textlines, line_key));

				updated_lastline
				    =
				    lastline + text_beyond_point + (chomped_text == text ?? "" :: "\n");


				updated_textlines
				    =
				    nl::set (updated_textlines, line_key, updated_lastline);

				updated_textlines
				    =
				    loop (remaininglines, updated_textlines)							# 
				    where
					fun loop ([], updated_textlines)
						=>
						updated_textlines;

					    loop (thisline ! remaininglines,  updated_textlines)
						=>
						loop (remaininglines,  nl::set (updated_textlines, line_key, thisline));
					end;
				    end;

				updated_textlines
				    =
				    nl::set (updated_textlines, line_key, updated_firstline);

				WORK  [ mj::TEXTLINES updated_textlines,
					mj::MARK      NULL,
					mj::LASTMARK (THE point),
					mj::POINT     { col => point.col,
							row => point.row + (list::length strings) - 1
						      }
				      ];
			    };
		    esac;
		fi;
	    };
	yank__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "yank",
		  doc	 =>  "Insert contents of cutbuffer at point (cursor). Insertion style depends on cutbuffer contents type.",
		  args	 =>  [],
		  editfn =>  yank
		}
	      );


	fun set_mark_command	(was:		mj::Editfn_In)							# Insert contents of cutbuffer at cursor. Insertion style depends on cutbuffer contents type.
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		WORK  [ mj::MARK (THE point) ];
	    };
	set_mark_command__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "set_mark_command",
		  doc	 =>  "Set 'mark' to location of point (cursor).",
		  args	 =>  [],
		  editfn =>  set_mark_command
		}
	      );


	fun keyboard_quit	(was:		mj::Editfn_In)							# This is emacs' stop-everything command.  For the moment it just clears the mark.
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		WORK  [ mj::MARK NULL,
			mj::QUIT										# Special hack just for keyboard_quit which instructs textpane.pkg to reset all ephemeral state etc.
		      ];
	    };
	keyboard_quit__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "keyboard_quit",
		  doc	 =>  "Stop everything, clear mark, reset to stable quiescient state.",
		  args	 =>  [],
		  editfn =>  keyboard_quit
		}
	      );


	fun kill_line	(was:			mj::Editfn_In)							# 
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };
		if readonly
		    #
		    FAIL "Buffer is read-only";
		else
# XXX SUCKO FIXME:  TBD 
		    WORK  [ 
			  ];
		fi;
	    };
	kill_line__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "kill_line",
		  doc	 =>  "Kill to end of line. If at end of line, delete end of line. With numeric prefix, kill multiple lines starting at point.",
		  args	 =>  [],
		  editfn =>  kill_line
		}
	      );


	fun transpose_chars (was:			mj::Editfn_In)							# 
	    :						mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		if readonly
		    #
		    FAIL "Buffer is read-only";
		else
# XXX SUCKO FIXME:  TBD 
		    WORK  [ 
			  ];
		fi;
	    };
	transpose_chars__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "transpose_chars",
		  doc	 =>  "Interchange current and previous char.",
		  args	 =>  [],
		  editfn =>  transpose_chars
		}
	      );


	fun exchange_point_and_mark (was:		mj::Editfn_In)						# 
	    :						mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		mark   =    case (mark, lastmark)
				#
				(THE _, _) =>     mark;								# Use 'mark' if it is set.
				_	   => lastmark;								# Use 'lastmark' otherwise.  (In this case lastmark will always be set unless no mark has ever been set in this buffer.)
			    esac;

		result =    case mark
				#
				NULL => FAIL "Mark is not set";							# Can't exchange point and mark when mark isn't set!

				THE mark
				    =>
				    if (mark.row <  point.row
				    or (mark.row == point.row  and  mark.col < point.col))
					#
					WORK  [ mj::MARK  (THE { row => point.row, col => point.col - 1 }),
						mj::POINT mark
					      ];
				    else									# mark > point
					WORK  [ mj::MARK   (THE point),
						mj::POINT  { row => mark.row, col => mark.col + 1 }
					      ];
				    fi;
			    esac;

		result;
	    };
	exchange_point_and_mark__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "exchange_point_and_mark",
		  doc	 =>  "Exchange mark and point (cursor) if mark is set.  Fail if mark is not set.",
		  args	 =>  [],
		  editfn =>  exchange_point_and_mark
		}
	      );


	fun beginning_of_buffer (was:		mj::Editfn_In)							# 
	    :						mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		result =    WORK  [ mj::POINT { row => 0, col => 0 }
				  ];

		result;
	    };
	beginning_of_buffer__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "beginning_of_buffer",
		  doc	 =>  "Move point to first char of first line of buffer.",
		  args	 =>  [],
		  editfn =>  beginning_of_buffer
		}
	      );


	fun end_of_buffer (was:				mj::Editfn_In)						# Move 'point' to end of buffer.  That means last line in buffer, just past last char (other than newline).
	    :						mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		row =   case (nl::max_key textlines)								# Finding number of last row is fairly easy.
			    #
			    THE row => row;
			    NULL    => 0;									# Shouldn't happen.
			esac;
														# Now we find screencol of last char in line. That's harder.  Following code is duplicated from move_end_of_line(), probably we should move it into a shared fn.


		line =  case (nl::find (textlines, row))							# Get last line.
			    #
			    THE line => line;
			    NULL     => "\n";
			esac;

		chomped_line =  string::chomp  line;								# Drop terminal newline if any.

		(string::expand_tabs_and_control_chars								# Count number of screencols in last line.
		  {
		    utf8text	=>  chomped_line,
		    startcol	=>  0,
		    screencol1	=>  0,										# Don't care.
		    screencol2	=>  0,										# Don't care.
		    utf8byte	=>  0										# Don't care.
		  })
		  ->
		  { screentext_length_in_screencols,
		    ...
		  };

		col    =  screentext_length_in_screencols;

		result =  WORK  [ mj::POINT { row, col }
				];
		result;
	    };
	end_of_buffer__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "end_of_buffer",
		  doc	 =>  "Move point to last char of last line of buffer.",
		  args	 =>  [],
		  editfn =>  end_of_buffer
		}
	      );

														# NB: emacs called panes "windows", which was a mistake because when X came along emacs had to call windows "frames".  We call panes "panes" and windows "windows". :-)
	fun split_pane_vertically (was:			mj::Editfn_In)						# Replace the current textpane by two textpanes half as high.
	    :						mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

# XXX SUCKO FIXME:  TBD 

		result =  WORK  [ 
				];
		result;
	    };
	split_pane_vertically__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "split_pane_vertically",
		  doc	 =>  "Replace current textpane by two textpanes half as high.",
		  args	 =>  [],
		  editfn =>  split_pane_vertically
		}
	      );


	fun split_pane_horizontally (was:		mj::Editfn_In)						# Replace the current textpane by two textpanes half as high
	    :						mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

# XXX SUCKO FIXME:  TBD 

		result =  WORK  [ 
				];
		result;
	    };
	split_pane_horizontally__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "split_pane_horizontally",
		  doc	 =>  "Replace current textpane by two textpanes half as wide.",
		  args	 =>  [],
		  editfn =>  split_pane_horizontally
		}
	      );


	fun delete_other_panes (was:			mj::Editfn_In)						# Delete all but current textpane.
	    :						mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

# XXX SUCKO FIXME:  TBD 

		result =  WORK  [ 
				];
		result;
	    };
	delete_other_panes__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "delete_other_panes",
		  doc	 =>  "Delete all but current textpane.",
		  args	 =>  [],
		  editfn =>  delete_other_panes
		}
	      );


	fun kill_region (was:				mj::Editfn_In)						# 
	    :						mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		if readonly
		    #
		    FAIL "Buffer is read-only";
		else
		    gadget_to_editboss
			->
			mj::GADGET_TO_EDITBOSS  eb;

		    fun normalize_point (p: g2d::Point)								# Returned point guaranteed to be positioned on the first screen column of its char (which, like a tab or control char, may occupy multiple screen columns).
			=
			{	line_key = p.row;									# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).
			    #
			    text =  case (nl::find (textlines, line_key))
					#
					THE line => line;
					NULL     => "\n";
				    esac;

			    chomped_text =  string::chomp  text;
					    (string::expand_tabs_and_control_chars
					      {
						utf8text	=>  chomped_text,
						startcol	=>  0,
						screencol1	=>  p.col,
						screencol2	=>  0,							# Don't-care.
						utf8byte	=>  0
					      })
					      ->
					      { screencol1_firstcol_on_screen:	Int,				# First screen column for 'point'.
    #					    screencol1_colcount_on_screen:	Int,
						...
					      };
			    { row => p.row, col => screencol1_firstcol_on_screen};
			};

		    result =    case mark
				    #
				    NULL => FAIL "Mark is not set";									# Can't kill region when mark isn't set!

				    THE mark
					=>
					{
					    # The columns for 'mark' and 'point' may be
					    # somewhere odd in the middle of (e.g.) tabs,
					    # so start by deriving normalized versions:
					    #
					    mark'  = normalize_point mark;
					    point' = normalize_point point;

					    if (mark'.row == point'.row)
						#
						line_key = mark'.row;											# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

						text =  case (nl::find (textlines, line_key))
							    #
							    THE line => line;
							    NULL     => "\n";
							esac;

						chomped_text =  string::chomp  text;

						my (col1, col2)												# First screen cols for first and last chars in selected region.
						    =													# NB: We interpret point'==mark' as designating a single-char region.  This preserves the invariant that "C-x C-x" (exchange_point_and_mark) does not change the selected region.
						    if  (point'.col <= mark'.col)
							(point'.col,   mark'.col);
						    else													# point.col > mark.col
							# When point is beyond mark, don't include
							# point's char (screen column(s)) in the region:
							#
							(string::expand_tabs_and_control_chars
							  {
							    utf8text	=>  chomped_text,
							    startcol	=>  0,
							    screencol1	=>  point'.col - 1,								# Since point'.col is guaranteed to be first col for char, subtracting one is guaranteed to put us on previous char.
							    screencol2	=>  0,										# Don't-care.
							    utf8byte	=>  0
							  })
							  ->
							  { screencol1_firstcol_on_screen:		Int,							# First screen column of last char in selected region. Note that screencol1 is guaranteed to be nonnegative because point'.col > mark'.col and both are normalized and on same line.
							    ...
							  };

							(mark'.col,  screencol1_firstcol_on_screen);
						    fi;

																			    # NB: We may have col1==col2 here.  That's OK, and indicates a one-char region to be moved to the cutbuffer -- remember, col1,col2 are both included in the region.
						(string::expand_tabs_and_control_chars									# Map screencols col1,col2 to byteoffsets in chomped_text.
						  {
						    utf8text	=>  chomped_text,
						    startcol	=>  0,
						    screencol1	=>  col1,
						    screencol2	=>  col2,
						    utf8byte	=>  0
						  })
						  ->
						  { screencol1_byteoffset_in_utf8text:	Int,
						    screencol2_byteoffset_in_utf8text:	Int,
						    screencol2_bytescount_in_utf8text:	Int,
						    ...
						  };

    #						    utf8_len_in_chars = string::length_in_chars  chomped_text;						# 
						utf8_len_in_bytes = string::length_in_bytes  chomped_text;							# 
																			    # 
						my  { text_before_region,											# 
						      text_within_region,											# 
						      text_beyond_region											# 
						    }													#
						    =													#
						    if (screencol1_byteoffset_in_utf8text >= utf8_len_in_bytes)						# If region lies entirely beyond actual end of line in utf8text.
							#
							{ text_before_region =>  chomped_text + (string::repeat(" ",  screencol1_byteoffset_in_utf8text-utf8_len_in_bytes )),
							  text_within_region =>                 (string::repeat(" ", (screencol2_byteoffset_in_utf8text-screencol1_byteoffset_in_utf8text) + 1)),		# 
							  text_beyond_region =>  ""										#
							};
						    elif (col2 >= utf8_len_in_bytes)									# Region starts within utf8text string but extends beyond actual end of line in utf8text.
							#
							{ text_before_region =>   string::substring(chomped_text, 0,  screencol1_byteoffset_in_utf8text),
							  text_within_region =>  (string::extract  (chomped_text, screencol1_byteoffset_in_utf8text,  NULL)) + (string::repeat(" ", (screencol1_byteoffset_in_utf8text-utf8_len_in_bytes) + 1)),
							  text_beyond_region =>  ""
							};
						    else													# Region lies entirely within input string.
							{ text_before_region =>  string::substring (chomped_text, 0			                                                  ,   screencol1_byteoffset_in_utf8text),
							  text_within_region =>  string::substring (chomped_text, screencol1_byteoffset_in_utf8text                                   ,  (screencol2_byteoffset_in_utf8text + screencol2_bytescount_in_utf8text) - screencol1_byteoffset_in_utf8text),
							  text_beyond_region =>  string::extract   (chomped_text, screencol2_byteoffset_in_utf8text + screencol2_bytescount_in_utf8text,  NULL	                )
							};
						    fi;

						eb.set_cutbuffer_contents (ct::PARTLINE text_within_region);

						updated_line = text_before_region + text_beyond_region + (chomped_text==text ?? "" :: "\n");		# Add back terminal newline, if original line had one.

						updated_textlines
						    =
						    (nl::remove (textlines, line_key));

						updated_textlines
						    =
						    nl::set (updated_textlines, line_key, updated_line);

						WORK  [ mj::TEXTLINES updated_textlines,
							mj::POINT { row => point.row,  col => col1 },
							mj::MARK     NULL,
							mj::LASTMARK NULL
						      ];

					    else														# mark'.row != point'.row, so this will be a cb::MULTILINE cut. 

						my (first, final)												# Sort point and mark and implement the convention that if point is last, it points to first char BEYOND region, but if mark is last it points to last char IN region.
						    =
						    if (point'.row < mark'.row)										# NB: We know from above that mark.row != point.row.
							#
							(point', mark');

						    elif (point'.col == 0)											# Specialcase check to keep following clause from yielding a negative final.col value.

							(mark', point');
						    else													# point.row > mark.row
							# When point is beyond mark, don't include
							# point's char (screen column(s)) in the region:
							#
							finalline_key = mark'.row;										# Internally lines are numbered 0->(N-1) (but we display them to user as 1-N).

							finaltext =     case (nl::find (textlines, finalline_key))
									    #
									    THE line => line;
									    NULL     => "\n";
									esac;

							chomped_finaltext =  string::chomp  finaltext;

							(string::expand_tabs_and_control_chars
							  {
							    utf8text	=>  chomped_finaltext,
							    startcol	=>  0,
							    screencol1	=>  point'.col - 1,								# Since point' is normalized and point'.col is nonzero, subtracting one is guaranteed to put us on a valid previous char.
							    screencol2	=>  0,										# Don't-care.
							    utf8byte	=>  0
							  })
							  ->
							  { screencol1_firstcol_on_screen:		Int,							# First screen column of last char in selected region.
							    ...
							  };

							(mark', { row => point'.row, col => screencol1_firstcol_on_screen } );
						    fi;

						first' = normalize_point first;										# Construct normalized versions of first and final, where screencol is at start of char each is on.
						final' = normalize_point final;

						firstline_key = first'.row;											# 

						firsttext =     case (nl::find (textlines, firstline_key))
								    #
								    THE line => line;
								    NULL     => "\n";
								esac;

						chomped_firsttext =  string::chomp  firsttext;

						firsttext_len_in_bytes = string::length_in_bytes  chomped_firsttext;					# 


						finalline_key = final'.row;											# 

						finaltext =     case (nl::find (textlines, finalline_key))
								    #
								    THE line => line;
								    NULL     => "\n";
								esac;

						chomped_finaltext =  string::chomp  finaltext;

						finaltext_len_in_bytes = string::length_in_bytes  chomped_finaltext;					# 


						(string::expand_tabs_and_control_chars
						  {
						    utf8text	=>  chomped_firsttext,
						    startcol	=>  0,
						    screencol1	=>  first'.col,										# Since point' is normalized and point'.col is nonzero, subtracting one is guaranteed to put us on a valid previous char.
						    screencol2	=>  0,											# Don't-care.
						    utf8byte	=>  0
						  })
						  ->
						  { screencol1_byteoffset_in_utf8text => firstcol_byteoffset_in_firsttext,					# Byteoffset in firsttext corresponding to first char in selected region.
						    ...
						  };

						(string::expand_tabs_and_control_chars
						  {
						    utf8text	=>  chomped_finaltext,
						    startcol	=>  0,
						    screencol1	=>  final'.col,										# Since point' is normalized and point'.col is nonzero, subtracting one is guaranteed to put us on a valid previous char.
						    screencol2	=>  0,											# Don't-care.
						    utf8byte	=>  0
						  })
						  ->
						  { screencol1_byteoffset_in_utf8text => finalcol_byteoffset_in_finaltext,					# Byteoffset in finaltext corresponding to final char in selected region.
						    screencol1_bytescount_in_utf8text => finalcol_bytescount_in_finaltext,					# Number of bytes in final char.
						    ...
						  };



						my  { text_before_firstline_region,										# 
						      text_within_firstline_region
						    }													#
						    =													#
						    if (firstcol_byteoffset_in_firsttext >= firsttext_len_in_bytes)						# If start of region lies beyond actual end of line in firsttext.
							#
							{ text_before_firstline_region =>  chomped_firsttext + (string::repeat(" ",  firstcol_byteoffset_in_firsttext - firsttext_len_in_bytes)),
							  text_within_firstline_region =>  ""
							};
						    else													# If start of region lies within firsttext.
							#
							{ text_before_firstline_region =>  string::substring (chomped_firsttext, 0,   firstcol_byteoffset_in_firsttext),
							  text_within_firstline_region =>  string::extract   (chomped_firsttext, firstcol_byteoffset_in_firsttext,  NULL)
							};
						    fi;


						my  { text_within_finalline_region,										# 
						      text_beyond_finalline_region
						    }													#
						    =													#
						    {   beyondregion_byteoffset = finalcol_byteoffset_in_finaltext						# Compute first byteoffset BEYOND region.
										+ finalcol_bytescount_in_finaltext
										;
							if (beyondregion_byteoffset >= finaltext_len_in_bytes)						# If end of region lies beyond actual end of line in finaltext.
							    #
							    { text_within_finalline_region =>  chomped_finaltext + (string::repeat(" ", beyondregion_byteoffset - finaltext_len_in_bytes)),
							      text_beyond_finalline_region =>  ""								#
							    };
							else												# If end of region lies within finaltext.
							    #
							    { text_within_finalline_region =>  string::substring (chomped_finaltext, 0,   beyondregion_byteoffset),
							      text_beyond_finalline_region =>  string::extract   (chomped_finaltext, beyondregion_byteoffset,  NULL)
							    };
							fi;
						    };

						whole_lines_in_cut												# Collect all lines strictly between firstline and finalline (== first'.row and final'.row).
						    =
						    loop (first'.row + 1, [])
						    where
							lastrow = final'.row - 1;

							fun loop (thisrow, result)
							    =
							    if (thisrow > lastrow)
								#
								reverse  result;
							    else
								line_key = thisrow;

								text =	case (nl::find (textlines, line_key))
										#
										THE line => line;
										NULL     => "\n";
									    esac;

								loop (thisrow + 1, text ! result);
							    fi;
						    end;

						text_within_region
						    #
						    =  [ text_within_firstline_region + "\n" ]								# We know firstline had a terminal newline, since there was at least one later line (finalline).
						    @  whole_lines_in_cut
						    @  [ text_within_finalline_region ]
						    ;

						eb.set_cutbuffer_contents (ct::MULTILINE text_within_region);


						updated_textlines												# Drop firstline.
						    =
						    (nl::remove (textlines, first'.row));

						updated_textlines												# Drop lines between firstline and finalline.
						    =
						    {   lastrow = final'.row - 1;
							#
							loop (first'.row + 1, updated_textlines)
							where
							    fun loop (thisrow, updated_textlines)
								=
								if (thisrow > lastrow)
								    #
								    updated_textlines;
								else
								    updated_textlines
									=
									nl::remove (updated_textlines, first'.row);

								    loop (thisrow + 1,  updated_textlines);
								fi;
							end;
						    };

						updated_textlines												# Drop finalline.
						    =
						    nl::remove (updated_textlines, first'.row);

						replacement_line
						    #
						    = text_before_firstline_region
						    + text_beyond_finalline_region
						    + (chomped_finaltext==finaltext ?? "" :: "\n");								# Add back terminal newline, if original finalline had one.

						updated_textlines
						    =
						    nl::set (updated_textlines, first'.row, replacement_line);

						WORK  [ mj::TEXTLINES updated_textlines,
							mj::POINT { row => first.row,  col => first.col },
							mj::MARK     NULL,
							mj::LASTMARK NULL
						      ];
					    fi;
					};
				esac;

		    result;
		fi;
	    };
	kill_region__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "kill_region",
		  doc	 =>  "Remove contents of region from buffer, saving in cutbuffer.  Fail if mark is not set.",
		  args	 =>  [],
		  editfn =>  kill_region
		}
	      );


	fun find_file	(was:		mj::Editfn_In)								# 
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		case args
		    #
		    [ mj::STRING_ARG filepath ]
			=>
			{   dirname  =  sj::dirname  filepath;							# Directory part of path, with no trailing slash.
			    basename =  sj::basename filepath;							# Filename  part of path, with no directory component.

			    textpane_to_textmill
				=
				eb.get_or_make_filebuffer { dirname, basename };

			    textpane_to_textmill
				->
				mj::TEXTPANE_TO_TEXTMILL  tb;

#			    tb.reload_from_file ();								# editboss-imp.pkg does this in get_or_make_filebuffer.

			    (tb.get_textstate ())
				->
				{ textlines, editcount };

			    WORK  [ mj::TEXTMILL  textpane_to_textmill,						# Tell textpane to switch to displaying this textmill.
				    mj::TEXTLINES   textlines,							# Tell textpane current contents of that textmill.
				    mj::POINT	    { row => 0,  col => 0 },
				    mj::MARK	    NULL,
				    mj::LASTMARK    NULL
				  ];
			};

		    _ => FAIL "<impossible>";									# Fail -- bad arglist.  This shouldn't be possible, textpane.pkg should always construct a good 'args' list before calling us.
		esac;
	    };
	find_file__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "find_file",
		  doc	 =>  "Load file given its full path.",
		  args	 =>  [ mj::FILENAME { prompt => "Find file", doc => "Full path for file to read" }  ],
		  editfn =>  find_file
		}
	      );


	fun save_buffer	(was:		mj::Editfn_In)								# 
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		WORK  [ mj::SAVE										# Signal   src/lib/x-kit/widget/edit/textpane.pkg  to call  save_to_file()  in  src/lib/x-kit/widget/edit/textmill-imp.pkg
		      ];
	    };
	save_buffer__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "save_buffer",
		  doc	 =>  "Save current buffer to disk if modified.",
		  args	 =>  [ ],
		  editfn =>  save_buffer
		}
	      );


	fun switch_to_buffer (was:	mj::Editfn_In)								# 
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

nb {. sprintf "switch_to_buffer not implemented   -- fundamental-mode.pkg"; };
		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		WORK  [ 
		      ];
	    };
	switch_to_buffer__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "switch_to_buffer",
		  doc	 =>  "Switch to different buffer.",
		  args	 =>  [ ],
		  editfn =>  switch_to_buffer
		}
	      );


	fun mark_whole_buffer (was:	mj::Editfn_In)								# 
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

nb {. sprintf "mark_whole_buffer not implemented   -- fundamental-mode.pkg"; };
		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		WORK [ 
		     ];
	    };
	mark_whole_buffer__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "mark_whole_buffer",
		  doc	 =>  "Set region to include entire buffer.",
		  args	 =>  [ ],
		  editfn =>  mark_whole_buffer
		}
	      );


	fun other_pane (was:		mj::Editfn_In)								# 
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

nb {. sprintf "other_pane not implemented   -- fundamental-mode.pkg"; };
		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		WORK  [ 
		      ];
	    };
	other_pane__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "other_pane",
		  doc	 =>  "Switch keyboard focus to another textpane.",
		  args	 =>  [ ],
		  editfn =>  other_pane
		}
	      );


	fun scroll_up (was:		mj::Editfn_In)								# 
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

nb {. sprintf "scroll_up not implemented   -- fundamental-mode.pkg"; };
		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		WORK  [ 
		      ];
	    };
	scroll_up__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "scroll_up",
		  doc	 =>  "Scroll textpane contents up one page.",
		  args	 =>  [ ],
		  editfn =>  scroll_up
		}
	      );


	fun scroll_down (was:		mj::Editfn_In)								# 
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

nb {. sprintf "scroll_down not implemented   -- fundamental-mode.pkg"; };
		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		WORK [ 
		     ];
	    };
	scroll_down__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "scroll_down",
		  doc	 =>  "Scroll textpane contents down one page.",
		  args	 =>  [ ],
		  editfn =>  scroll_down
		}
	      );


	fun count_lines_region (was:	mj::Editfn_In)								# 
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

nb {. sprintf "count_lines_region not implemented   -- fundamental-mode.pkg"; };
		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		WORK  [ 
		      ];
	    };
	count_lines_region__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "count_lines_region",
		  doc	 =>  "Count number of lines in region.",
		  args	 =>  [ ],
		  editfn =>  count_lines_region
		}
	      );


	fun undo	 (was:		mj::Editfn_In)								# 
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

nb {. sprintf "undo not implemented   -- fundamental-mode.pkg"; };
		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		WORK  [ 
		      ];
	    };
	undo__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "undo",
		  doc	 =>  "Undo one edit operation.",
		  args	 =>  [ ],
		  editfn =>  undo
		}
	      );


	fun just_one_space (was:	mj::Editfn_In)								# 
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

nb {. sprintf "just_one_space not implemented   -- fundamental-mode.pkg"; };
		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		WORK  [ 
		      ];
	    };
	just_one_space__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "just_one_space",
		  doc	 =>  "Replace whitespace string with a single blank.",
		  args	 =>  [ ],
		  editfn =>  just_one_space
		}
	      );


	fun delete_horizontal_space (was:	mj::Editfn_In)								# 
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

nb {. sprintf "delete_horizontal_space not implemented   -- fundamental-mode.pkg"; };
		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		WORK  [ 
		      ];
	    };
	delete_horizontal_space__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "delete_horizontal_space",
		  doc	 =>  "Kill all whitespace under cursor.",
		  args	 =>  [ ],
		  editfn =>  delete_horizontal_space
		}
	      );


	fun execute_extended_command (was:	mj::Editfn_In)							# 
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

nb {. sprintf "execute_extended_command not implemented   -- fundamental-mode.pkg"; };
		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		WORK  [ 
		      ];
	    };
	execute_extended_command__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "execute_extended_command",
		  doc	 =>  "Execute a command, reading its name from the minibuffer.",
		  args	 =>  [ ],
		  editfn =>  execute_extended_command
		}
	      );


	fun indent_rigidly (was:		mj::Editfn_In)							# 
	    :					mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

nb {. sprintf "indent_rigidly not implemented   -- fundamental-mode.pkg"; };
		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		WORK  [ 
		      ];
	    };
	indent_rigidly__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "indent_rigidly",
		  doc	 =>  "Indent region.",
		  args	 =>  [ ],
		  editfn =>  indent_rigidly
		}
	      );


	fun toggle_readonly (was:	mj::Editfn_In)								# Emacs uses "read-only" not "readonly" but I prefer to collapse it because "toggle_readonly" parses obviously bug "toggle_read_only" requires more work to read.
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		WORK  [ mj::READONLY (not readonly)								# 
		      ];
	    };
	toggle_readonly__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "toggle_readonly",
		  doc	 =>  "Reverse readonly flag on current buffer.",
		  args	 =>  [ ],
		  editfn =>  toggle_readonly
		}
	      );


	fun isearch_forward (was:	mj::Editfn_In)								# 
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		case args
		    #
		    [ mj::INCREMENTAL_STRING_ARG (stage, searchstring) ]
			=>
			{
			    search_start									# On mj::INITIAL call 'point' is unchanged. On subsequent calls 'point' is updated per incremental search, but original 'point' value is saved in 'lastmark'.
				=
				case (stage, lastmark)
				    #
				    (mj::INITIAL,  _)	=>  point;
				    (_, THE lastmark)	=>  lastmark;
				    _			=>  point;						# Shouldn't happen.
				esac;
														# See if we can find 'searchstring in 'textlines' starting at 'search_start'.

			    lastline =  case (nl::max_key textlines)
					    #
					    THE maxkey => maxkey;
					    NULL       => -1;
					esac;

			    thisline =  search_start.row;

			    my (newmark, newpoint)
				=
				find_match search_start
				where
				    search_line =  string::find_substring'  searchstring;			# Set up for Knuth-Morris-Pratt searching for 'searchstring'.  Internally, this preconstructs the required table.
														# Note that our approach here won't match a string spanning more than one line -- i.e., one with embedded newlines. I can't remember the last time I wanted to do such a search, so I'm not sweating that right now. -- 2015-06-20 CrT

				    searchstring_length_in_bytes
					=
					string::length_in_bytes  searchstring;

				    fun find_match (point: g2d::Point)						# Search through 'textlines' for first match to 'searchstring', starting at 'point'.
					=
					{   line_number = point.row;
					    #
					    if (line_number > lastline)  (NULL,NULL);				# Didn't find searchstring anywhere, leave 'point' where it started.
					    else
						line =	case (nl::find (textlines, line_number))
								#
								THE line => line;
								NULL     => "\n";				# Shouldn't happen.
							    esac;

						byteoffset							# Screen col point.col as a byte offset into utf8-encoded 'line'.
						    =
						    case point.col
							#
							0 => 0;							# Screen column zero is always byte offset zero.  This is worth special-casing because it is the typical case and the alternative is expensive.

							c =>    {   (string::expand_tabs_and_control_chars
								      {
									utf8text	=>  line,
									startcol	=>  0,
									screencol1	=>  c,			# This is the one we care about.
									screencol2	=>  0,			# Don't-care.
									utf8byte	=>  0			# Don't-care.
								      })
								      ->
								      { screencol1_byteoffset_in_utf8text,	# 
									...
								      };

								    screencol1_byteoffset_in_utf8text;
								};
						    esac;

						case (search_line (line, byteoffset))
						    #	
						    NULL => find_match  { row => point.row + 1,			# Didn't find 'searchstring' on this line, so try next line (if any).
									  col => 0
									};

						    THE byteoffset						# Success -- found 'searchstring" within 'line'.
							=>
							{   (string::expand_tabs_and_control_chars		# Now we need to convert the 'byteoffset' into utf8-encoded 'line' into a screen column suitable for 'mark'.
							      {
								utf8text	=>  line,
								startcol	=>  0,
								screencol1	=>  0,				# Don't-care.
								screencol2	=>  0,				# Don't-care.
								utf8byte	=>  byteoffset
							      })
							      ->
							      { utf8byte_firstcol_on_screen => markcol,		# Screen column at which utf8text byteoffset 'utf8byte' begins.  Note that utf8byte may be (e.g.) somewhere in the middle of a tab, so computing this value is nontrivial. 
								...
							      };

							    (string::expand_tabs_and_control_chars		# Now we need to convert the 'byteoffset' into utf8-encoded 'line' into a screen column suitable for 'point'.
							      {
								utf8text	=>  line,
								startcol	=>  0,
								screencol1	=>  0,
								screencol2	=>  0,
								utf8byte	=>  byteoffset + searchstring_length_in_bytes
							      })
							      ->
							      { utf8byte_firstcol_on_screen => pointcol,
								...
							      };

							    ( THE { row => line_number,				# newmark
							            col => markcol
							          },
							      THE { row => line_number,				# newpoint
							            col => pointcol
							          }
							    );	
							};
						esac;
					    fi;
					};
				end;

			    result =    [ ];

			    result =    case newpoint
					    #
					    THE point	=>  (mj::POINT         point ) !   result;		# Move 'point' (==cursor) to screen address just past end of string match.
					    NULL	=>				   result;
					esac;

			    result =    case newmark
					    #
					    THE mark	=>  (mj::MARK     (THE mark )) !   result;		# Move 'mark' to screen address corresponding to start of string match.
					    NULL	=>				   result;
					esac;

			    result =    case stage								# If this is our mj::INITIAL call, save 'point' in 'lastmark' because we need to know initial value of 'point' in later calls.
					    #
					    mj::INITIAL =>  (mj::LASTMARK (THE point))  !  result;
					    _		=>				   result;
					esac; 

			    WORK  result;
			};

		    _ => FAIL "<impossible>";									# Fail -- bad arglist.  This shouldn't be possible, textpane.pkg should always construct a good 'args' list before calling us.
		esac;
	    };
	isearch_forward__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "isearch_forward",
		  doc	 =>  "Incrementally search forward for search string as entered.",
		  args	 =>  [ mj::INCREMENTAL_STRING { prompt => "I-search", doc => "String to search for" }  ],
		  editfn =>  isearch_forward
		}
	      );


	fun isearch_backward (was:	mj::Editfn_In)								# 
	    :				mj::Editfn_Out
	    =
	    {   was -> 	  { args:			List( mj::Prompted_Arg ),
			    textlines:			mj::Textlines,
			    point:			g2d::Point,						# As in Point_And_Mark.
			    mark:			Null_Or(g2d::Point),					# 
			    lastmark:			Null_Or(g2d::Point),					# 
			    readonly:			Bool,							# TRUE iff contents of textmill are currently marked as read-only.
			    keystring:			String,							# User keystroke that invoked this editfn.
			    numeric_prefix:		Null_Or( Int ),						# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			    gadget_to_editboss:		mj::Gadget_To_Editboss	
			  };

		gadget_to_editboss
		    ->
		    mj::GADGET_TO_EDITBOSS  eb;

		case args
		    #
		    [ mj::INCREMENTAL_STRING_ARG (stage, searchstring) ]
			=>
			{
			    search_start									# On mj::INITIAL call 'point' is unchanged. On subsequent calls 'point' is updated per incremental search, but original 'point' value is saved in 'lastmark'.
				=
				case (stage, lastmark)
				    #
				    (mj::INITIAL,  _)	=>  point;
				    (_, THE lastmark)	=>  lastmark;
				    _			=>  point;						# Shouldn't happen.
				esac;
														# See if we can find 'searchstring in 'textlines' starting at 'search_start'.

			    lastline =  case (nl::max_key textlines)
					    #
					    THE maxkey => maxkey;
					    NULL       => -1;
					esac;

			    thisline =  search_start.row;

			    my (newmark, newpoint)
				=
				find_match (search_start.row, THE search_start.col)
				where
				    search_line =  string::find_substring_backward'  searchstring;		# Set up for Knuth-Morris-Pratt searching for 'searchstring'.  Internally, this preconstructs the required table.
														# Note that our approach here won't match a string spanning more than one line -- i.e., one with embedded newlines. I can't remember the last time I wanted to do such a search, so I'm not sweating that right now. -- 2015-06-20 CrT
				    searchstring_length_in_bytes
					=
					string::length_in_bytes  searchstring;

				    fun find_match								# Search through 'textlines' for first PRECEDING match to 'searchstring'.
					  (
					    line_number:	Int,						# Next line to search, as an index into 'textlines'.
					    column:		Null_Or(Int)					# Screen column at which to start searching line.  We take NULL to mean start search at end of line.
					  )
					=
					{   if (line_number < 0)  (NULL,NULL);					# Didn't find searchstring anywhere, leave 'point' where it started.
					    else
						line =	case (nl::find (textlines, line_number))
								#
								THE line => line;
								NULL     => "\n";				# Shouldn't happen.
							    esac;

						eol =	string::length_in_bytes line				# Compute last byteoffset in 'line' at which a match is possible.
							-
							searchstring_length_in_bytes;

						col =	case column
							    #
							    NULL =>	eol;					# Start searching at end of line.

							    THE c =>	{   (string::expand_tabs_and_control_chars
									      {
										utf8text	=>  line,
										startcol	=>  0,
										screencol1	=>  c,		# This is the one we care about.
										screencol2	=>  0,		# Don't-care.
										utf8byte	=>  0		# Don't-care.
									      })
									      ->
									      { screencol1_byteoffset_in_utf8text,
										...
									      };

									    screencol1_byteoffset_in_utf8text;	# 
									};
							esac;

						col =	min (col, eol);						# Keep search within actual available bytes. :-)   (We allow the screen cursor to wander off beyond the current physical end of line.)

						case (search_line (line, col))
						    #	
						    NULL => find_match  ( line_number - 1,			# Didn't find 'searchstring' on this line, so try previous line (if any).
									  NULL					# Search previous line starting at end.
									);

						    THE byteoffset						# Success -- found 'searchstring" within 'line'.
							=>
							{   (string::expand_tabs_and_control_chars		# Now we need to convert the 'byteoffset' into utf8-encoded 'line' into a screen column suitable for 'mark'.
							      {
								utf8text	=>  line,
								startcol	=>  0,
								screencol1	=>  0,				# Don't-care.
								screencol2	=>  0,				# Don't-care.
								utf8byte	=>  byteoffset
							      })
							      ->
							      { utf8byte_firstcol_on_screen => markcol,		# Screen column at which utf8text byteoffset 'utf8byte' begins.  Note that utf8byte may be (e.g.) somewhere in the middle of a tab, so computing this value is nontrivial. 
								...
							      };

							    (string::expand_tabs_and_control_chars		# Now we need to convert the 'byteoffset' into utf8-encoded 'line' into a screen column suitable for 'point'.
							      {
								utf8text	=>  line,
								startcol	=>  0,
								screencol1	=>  0,
								screencol2	=>  0,
								utf8byte	=>  byteoffset + searchstring_length_in_bytes
							      })
							      ->
							      { utf8byte_firstcol_on_screen => pointcol,
								...
							      };

							    ( THE { row => line_number,				# newmark
							            col => markcol
							          },
							      THE { row => line_number,				# newpoint
							            col => pointcol
							          }
							    );	
							};
						esac;
					    fi;
					};
				end;

			    result =    [ ];

			    result =    case newpoint
					    #
					    THE point	=>  (mj::POINT         point ) !   result;		# Move 'point' (==cursor) to screen address just past end of string match.
					    NULL	=>				   result;
					esac;

			    result =    case newmark
					    #
					    THE mark	=>  (mj::MARK     (THE mark )) !   result;		# Move 'mark' to screen address corresponding to start of string match.
					    NULL	=>				   result;
					esac;

			    result =    case stage								# If this is our mj::INITIAL call, save 'point' in 'lastmark' because we need to know initial value of 'point' in later calls.
					    #
					    mj::INITIAL =>  (mj::LASTMARK (THE point))  !  result;
					    _		=>				   result;
					esac; 

			    WORK   result;
			};

		    _ => FAIL "<impossible>";									# Fail -- bad arglist.  This shouldn't be possible, textpane.pkg should always construct a good 'args' list before calling us.
		esac;
	    };
	isearch_backward__editfn
	    =
	    mj::EDITFN (
	      mj::PLAIN_EDITFN
		{
		  name	 =>  "isearch_backward",
		  doc	 =>  "Incrementally search backward for search string as entered.",
		  args	 =>  [ mj::INCREMENTAL_STRING { prompt => "I-search", doc => "String to search for" }  ],
		  editfn =>  isearch_backward
		}
	      );


	# Conventions on writing keymap strings:
	#
	# The prefixes
	#
	#     Super = 's-'
	#     Meta  = 'M-'
	#     Ctrl  = 'C-'
	#     Shift = 'S-'
	#
	# should always be written in the order
	#
	#     s-C-M-S-x
	#
	# Write "SPC" instead of " ".
	# Write "TAB" instead of "C-i".
	# Write "RET" instead of "C-m".
	# Write "ESC" instead of "C-[".
	#
	# Don't try to define    "C-u": Its meaning is hardwired in   src/lib/x-kit/widget/edit/textpane.pkg
	# Similarly, "ESC" will usually be interpreted as Meta.
	#
	# Use "S-" only with keys whose names are in angle brackets.
	#
	# The list of such keys is defined in
	#     src/lib/x-kit/xclient/src/window/keysym-to-ascii.pkg
	# viz:
	#     "<backspace>";		# Backspace key.
	#     "<pause>";		# 
	#     "<scrollLock>";		# Scroll Lock key.
	#     "<sysReq>";		# SysReq key.
	#     "<home>";			# Home key.		# We use all-lowercase all through here to match emacs tradition.
	#     "<left>";			# Left-arrow key.
	#     "<up>";			# Up-arrow key.
	#     "<right>";		# Right-arrow key.
	#     "<down>";			# Down-arrow key.
	#     "<pageUp>";		# Page Up key.
	#     "<pageDown>";		# Page Down key.
	#     "<end>";			# End key.
	#     "<begin>";		# Begin key.
	#     "<select>";		# Select key.
	#     "<printScr>";		# Print-screen key.
	#     "<execute>";		# Execute key.
	#     "<insert>";		# Insert key.
	#     "<undo>";			# Undo key.
	#     "<redo>";			# Redo key.
	#     "<menu>";			# Menu key.
	#     "<find>";			# Find key.
	#     "<cancel>";		# Cancel key.
	#     "<help>";			# Help key.
	#     "<break>";		# Break key.
	#     "<numLock>";		# Num Lock key.
	#     "<f1>";			# F1 key.
	#     "<f2>";			# F2 key.
	#     "<f3>";			# F3 key.
	#     "<f4>";			# F4 key.
	#     "<f5>";			# F5 key.
	#     "<f6>";			# F6 key.
	#     "<f7>";			# F7 key.
	#     "<f8>";			# F8 key.
	#     "<f9>";			# F9 key.
	#     "<f10>";			# F10 key.
	#     "<f11>";			# F11 key.
	#     "<f12>";			# F12 key.
	#     "<f13>";			# F13 key.
	#     "<f14>";			# F14 key.
	#     "<f15>";			# F15 key.
	#     "<f16>";			# F16 key.
	#     "<f17>";			# F17 key.
	#     "<f18>";			# F18 key.
	#     "<f19>";			# F19 key.
	#     "<f20>";			# F20 key.
	#     "<f21>";			# F21 key.
	#     "<f22>";			# F22 key.
	#     "<f23>";			# F23 key.
	#     "<f24>";			# F24 key.
	#     "<f25>";			# F25 key.
	#     "<f26>";			# F26 key.
	#     "<f27>";			# F27 key.
	#     "<f28>";			# F28 key.
	#     "<f29>";			# F29 key.
	#     "<f30>";			# F30 key.
	#     "<f31>";			# F31 key.
	#     "<f32>";			# F32 key.
	#     "<f33>";			# F33 key.
	#     "<f34>";			# F34 key.
	#     "<f35>";			# F35 key.
	#     "<leftShift>";		# Left Shift key.
	#     "<rightShift>";		# Right Shift key.
	#     "<leftCtrl>";		# Left Ctrl key.
	#     "<rightCtrl>";		# Right Ctrl key.
	#     "<capsLock>";		# Caps Lock key.
	#     "<leftMeta>";		# Left Meta key.
	#     "<rightMeta>";		# Right Meta key.
	#     "<leftAlt>";		# Left Alt key.
	#     "<rightAlt>";		# Right Alt key.
	#     "<cmd>";			# Windows/Apple key.
	#     "<delete>";		# Delete key.


	fundamental_mode_keymap
	    =
	    keymap
	    where
		keymap = mj::empty_keymap;
		#
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-@"		],	set_mark_command__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-SPC"		],	set_mark_command__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-a"		],	move_beginning_of_line__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-b"		],	previous_char__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-d"		],	delete_char__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-e"		],	move_end_of_line__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-f"		],	forward_char__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-g"		],	keyboard_quit__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-k"		],	kill_line__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-n"		],	next_line__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-o"		],	kill_whole_line__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-p"		],	previous_line__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-r"		],	isearch_backward__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-s"		],	isearch_forward__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-t"		],	transpose_chars__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-v"		],	scroll_up__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-w"		],	kill_region__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-x", "1"		],	delete_other_panes__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-x", "2"		],	split_pane_vertically__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-x", "3"		],	split_pane_horizontally__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-x", "C-f"	],	find_file__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-x", "C-q"	],	toggle_readonly__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-x", "C-s"	],	save_buffer__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-x", "C-x"	],	exchange_point_and_mark__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-x", "b"		],	switch_to_buffer__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-x", "h"		],	mark_whole_buffer__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-x", "o"		],	other_pane__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-x", "TAB"	],	indent_rigidly__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-y"		],	yank__editfn			);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-_"		],	undo__editfn			);
		keymap = mj::add_editfn_to_keymap (keymap, [ "C-/"		],	undo__editfn			);
		keymap = mj::add_editfn_to_keymap (keymap, [ "M-SPC"		],	beginning_of_buffer__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "M-v"		],	just_one_space__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "M-x"		],	execute_extended_command__editfn);
		keymap = mj::add_editfn_to_keymap (keymap, [ "M-x", "="		],	count_lines_region__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "M-\\"		],	delete_horizontal_space__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "M-<"		],	beginning_of_buffer__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "M->"		],	end_of_buffer__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "RET"		],	newline__editfn			);
		#
		keymap = mj::add_editfn_to_keymap (keymap, [ "<backspace>"	],	delete_backward_char__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "<delete>"		],	delete_char__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "<down>"		],	next_line__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "<end>"		],	move_end_of_line__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "<home>"		],	move_beginning_of_line__editfn	);
		keymap = mj::add_editfn_to_keymap (keymap, [ "<left>"		],	previous_char__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "<right>"		],	forward_char__editfn		);
		keymap = mj::add_editfn_to_keymap (keymap, [ "<up>"		],	previous_line__editfn		);

		keymap =    mj::add_editfn_to_keymap_throughout_char_range
			      {
				keymap,
				keymap_node =>  self_insert_command__editfn,
				#
				firstchar   =>  ' ',
				lastchar    =>	'~'
			      };	
	    end;

	fundamental_mode
	    =
	    mj::BUFFERMODE
	      {
		name   =>	"Fundamental",
		doc    =>	"Root unspecialized textmill mode.",
		#
		keymap =>	REF fundamental_mode_keymap,
		parent =>	NULL
	      };
    };
end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
