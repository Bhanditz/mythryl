## editboss-imp.pkg
#
# See overview comments in:
#
#     src/lib/x-kit/widget/edit/editboss-imp.api

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package ct  =  cutbuffer_types;				# cutbuffer_types		is from   src/lib/x-kit/widget/edit/cutbuffer-types.pkg
#   package ct  =  gui_to_object_theme;				# gui_to_object_theme		is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
#   package bt  =  gui_to_sprite_theme;				# gui_to_sprite_theme		is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
#   package wt  =  widget_theme;				# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

#   package os  =  guiboss_to_spritespace;			# guiboss_to_spritespace	is from   src/lib/x-kit/widget/space/sprite/guiboss-to-spritespace.pkg
#   package cs  =  guiboss_to_objectspace;			# guiboss_to_objectspace	is from   src/lib/x-kit/widget/space/object/guiboss-to-objectspace.pkg


    package boi =  spritespace_imp;				# spritespace_imp		is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;				# objectspace_imp		is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;				# widgetspace_imp		is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;				# guiboss_to_guishim		is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2s =  spritespace_to_sprite;			# spritespace_to_sprite		is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;			# objectspace_to_object		is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2b =  sprite_to_spritespace;			# sprite_to_spritespace		is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2c =  object_to_objectspace;			# object_to_objectspace		is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg

    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg
    package sm  =  string_map;					# string_map			is from   src/lib/src/string-map.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

    package ebt =  editboss_types;				# editboss_types		is from   src/lib/x-kit/widget/edit/editboss-types.pkg

    package mj  =  mode_junk;					# mode_junk			is from   src/lib/x-kit/widget/edit/mode-junk.pkg

#   package g2b =  gadget_to_editboss;				# gadget_to_editboss		is from   src/lib/x-kit/widget/edit/gadget-to-editboss.pkg
    package e2g =  editboss_to_guiboss;				# editboss_to_guiboss		is from   src/lib/x-kit/widget/edit/editboss-to-guiboss.pkg

    package tbi =  textmill_imp;				# textmill_imp			is from   src/lib/x-kit/widget/edit/textmill-imp.pkg
#   package t2t =  textpane_to_textmill;			# textpane_to_textmill		is from   src/lib/x-kit/widget/edit/textpane-to-textmill.pkg

    package p2l =  textpane_to_screenline;			# textpane_to_screenline	is from   src/lib/x-kit/widget/edit/textpane-to-screenline.pkg

    package l2p =  screenline_to_textpane;			# screenline_to_textpane	is from   src/lib/x-kit/widget/edit/screenline-to-textpane.pkg

    package b2l =  editboss_to_screenline;			# editboss_to_screenline	is from   src/lib/x-kit/widget/edit/editboss-to-screenline.pkg

    package e2p =  editboss_to_textpane;			# editboss_to_textpane		is from   src/lib/x-kit/widget/edit/editboss-to-pane.pkg
# Below is intended to replace above:
    package b2p =  editboss_to_pane;				# editboss_to_pane		is from   src/lib/x-kit/widget/edit/editboss-to-pane.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

herein

    package editboss_imp
    :       Editboss_Imp												# Editboss_Imp		is from   src/lib/x-kit/widget/edit/editboss-imp.api
    {
	Editboss_Option
	  #
	  =  MICROTHREAD_NAME	String											# 
	  |  ID			Id											# Stable, unique id for imp.
	  ;	

	Editboss_Arg =  List(Editboss_Option);										# Currently no required component.

	Imports = {													# Ports we use, provided by other imps.
		    editboss_to_guiboss:	e2g::Editboss_To_Guiboss
		  };
															# editboss should probably not know so much about textmill/screenline/textpane.
	Textmill_Info
	  =
	  { id:					Id,
	    #
	    textpane_to_textmill:		mj::Textpane_To_Textmill,
	    #
	    name:				Ref( String ),
	    filespec:				Ref( Null_Or( mj::Filespec ) ),
	    end_gun':				End_Gun
	  };


	Pane_Info
	  =
	  { pane_id:				Id,
	    pane_tag:				Ref( Int ),								# We assign each pane a tag in the dense range 1-N, to be displayed on modeline and used by "C-x o" (other_pane) in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
	    editboss_to_pane:			Ref( Null_Or( b2p::Editboss_To_Pane ) ),				# Our port to the pane, once it registers with us.
	    crypt_queue:			Ref( List( Crypt ) )							# Messages to be delivered to pane once it registers with us via Gadget_To_Editboss.note_pane().	We reverse this queue before delivering it to preserve message order.
	  };

	Textpane_Info
	  =
	  { textpane_id:			Id,
	    pane_tag:				Ref( Int ),								# We assign each pane a tag in the dense range 1-N, to be displayed on modeline and used by "C-x o" (other_pane) in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
	    #														# Name is 'pane_tag' rather than 'textpane_tag' in anticipation of eventually extending the mechanism to other panes as well.
	      editboss_to_textpane:		e2p::Editboss_To_Textpane,
	    screenline_to_textpane:		l2p::Screenline_To_Textpane
	  };
 
	Editboss_State													# Holds all nonephemeral mutable state maintained by package.
	  =
	  {
	    textmills_by_name:			Ref( sm::Map( Textmill_Info   ) ),					# All currently active textmills, by name.
	    textmills_by_id:			Ref( im::Map( Textmill_Info   ) ),					# All currently active textmills, by id.
	    textmills_by_filepath:		Ref( sm::Map( Textmill_Info   ) ),					# All currently active textmills WHICH ARE OPEN ON A FILE, by filepath. (We expect this to typically be a full pathname like "/home/jayne/foo.txt", so as to help avoid having multiple buffers open on one file.)
	    textpanes_by_id:			Ref( im::Map( Textpane_Info   ) ),					# All currently active textpanes, by id.
	    panes_by_id:			Ref( im::Map( Pane_Info	      ) )
	  };

	Me_Slot = Mailslot( { imports:		Imports,
			      me:		Editboss_State,
			      editboss_arg:	Editboss_Arg,
			      run_gun':		Run_Gun,
			      end_gun':		End_Gun
			    }
			  );

	Exports	= {													# Ports we provide for use by other imps.
		    gadget_to_editboss:		Crypt									# The Crypt encapsulates type gadget_to_editboss::Gadget_To_Editboss. (We don't want to drag that typecomplex into guiboss.)
		  };


	Editboss_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);


	Runstate =    {													# These values will be statically globally visible throughout the code body for the imp.
			me:			Editboss_State,								# State which is preserved across imp shutdown/restart cycles.
			editboss_arg:		Editboss_Arg,
			imports:		Imports,								# Imps to which we send requests.
			to:			Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
			end_gun':		End_Gun,								# We shut down the microthread when this fires.
			id:			Id
		      };

	Editboss_Q    = Mailqueue( Runstate -> Void );




	fun run ( editboss_q:			Editboss_Q,								# 
		  #
		  runstate as
		  {													# These values will be statically globally visible throughout the code body for the imp.
		    me:				Editboss_State,								# State which is preserved across imp shutdown/restart cycles.
		    editboss_arg:		Editboss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# 
		    id:				Id
		  }
		)
	    =
	    {	loop ();
	    }
	    where


		#
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    end_gun'                        ==>  shut_down_editboss_imp',
			    take_from_mailqueue' editboss_q ==>  do_editboss_plea
			];

			loop ();
		    }	
		    where
			fun do_editboss_plea  thunk
			    =
			    thunk runstate;
			#
			fun shut_down_editboss_imp' ()
			    =
			    {
				thread_exit { success => TRUE };							# Will not return.	
			    };
		    end;
	    end;	



	#
	fun startup   (id: Id,   reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()				# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		gadget_to_editboss
		    =
		    mj::GADGET_TO_EDITBOSS
		      {
			id,
			get_textmill,
			get_or_make_textmill,
			get_or_make_filebuffer,
			#
			get_cutbuffer_contents,
			set_cutbuffer_contents,
			#
			note_pane,
			drop_pane,
			mail_pane
		      };

		exports	    = { gadget_to_editboss => crypt }
				where
				    crypt = { key => "gadget_to_editboss::GADGET_TO_EDITBOSS",
					      doc => "src/lib/x-kit/widget/edit/gadget-to-editboss.pkg",
					      val =>  mj::GADGET_TO_EDITBOSS__CRYPT  gadget_to_editboss
					    };	
				end;

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, exports));							# Return value from editboss_egg'().

		(take_from_mailslot  me_slot)										# Imports from editboss_egg'().
		    ->
		    { me, editboss_arg, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		run ( editboss_q,		 									# Will not return.
		      { me,
			editboss_arg,
			imports,
			to,
			end_gun',
			id
		      }
		);
	    }
	    where
		editboss_q     =  make_mailqueue (get_current_microthread()):  Editboss_Q;


		fun note_textmill_statechange (id: Id,  statechange: mj::Textmill_Statechange)
		    =
		    case statechange
			#
			mj::NAME_CHANGED { was: String, now: String }
			    =>
			    put_in_mailqueue  (editboss_q,
				#
				\\ ({ me, ... }: Runstate)
				    =
				    case (im::get  (*me.textmills_by_id,  id_to_int id))
					#
					THE textmill_info
					    =>
					    {	textmill_info.name 	:= now;								# Remember new name of textmill.
						me.textmills_by_name	:= sm::drop (*me.textmills_by_name, was);			# Forget   old name of textmill.
						me.textmills_by_name	:= sm::set  (*me.textmills_by_name, now, textmill_info);	# Remember textmill under its new name.
					    };
					#
					NULL =>
					    {   msg =  sprintf "NAME.id (%d) not in *me.textmills_by_id!" (id_to_int id);
						log::fatal msg;
						raise exception DIE msg;
					    };
				    esac
			    );	


			mj::TEXTSTATE_CHANGED _ =>  ();											# List rest explicitly so as to draw a compile error if a new one gets added without us being updated.
			mj::UNDO 	      _ =>  ();
			mj::FILESPEC_CHANGED  _ =>  ();
			mj::READONLY_CHANGED  _ =>  ();
			mj::DIRTY_CHANGED     _ =>  ();
		    esac;

		#################################################################################
		# guiboss interface fns::
		#
		#

		fun get_or_make_pane_info
		      {
			me:		Editboss_State,
			pane_id:	Id
		      }:		Pane_Info
		    =
		    case (im::get  (*me.panes_by_id,  id_to_int pane_id))
			#
			THE pane_info
			    =>
			    pane_info;
			#
			NULL =>
			    {   pane_info
				  =
				  { pane_id,
				    pane_tag	     => REF 0,										# We assign each pane a tag in the dense range 1-N, to be displayed on modeline and used by "C-x o" (other_pane) in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
				    editboss_to_pane => REF NULL,									# Our port to the pane, once it registers with us.
				    crypt_queue	     => REF []										# Messages to be delivered to pane once it registers with us via Gadget_To_Editboss.note_pane().	We reverse this queue before delivering it to preserve message order.
				  };

				me.panes_by_id
				    :=
				    im::set  (*me.panes_by_id,  id_to_int pane_id,  pane_info);

				pane_info;
			    };
		    esac;


		fun renumber_panes											# Assign all active textpanes numeric tags in the range 1-N.  These are displayed on the modeline and used by "C-x o" (other_pane) in   src/lib/x-kit/widget/edit/fundamental-mode.pkg
		      (													# renumber_panes should be called whenever a textpane is noted or dropped.
			{ id, me, ... }: 	Runstate
		      )
		    =
		    {   panes =  im::vals_list  *me.panes_by_id;
			#
			renumber (panes, 1)
			    where
				fun renumber ((pane: Pane_Info) ! rest,  n)
					=>
					{   case *pane.editboss_to_pane
						#
						THE editboss_to_pane
						    =>
						    editboss_to_pane.note_tag  n;

						NULL => ();
					    esac;

					    renumber (rest, n+1);							# NB: We allocate a tag to panes which have not yet registered, the idea being to minimize the number of visible renumberings which the user must cope with.
					};

				    renumber ([], _) => ();
				end;
			    end;
		    };	

		fun note_pane
		      (
			editboss_to_pane:			b2p::Editboss_To_Pane
		      )
		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ (r as { id, me, ... }: Runstate)
			    =
			    {   pane_id   =  editboss_to_pane.pane_id;
				pane_info =  get_or_make_pane_info { me, pane_id };

				pane_info.editboss_to_pane
				    :=
				    THE editboss_to_pane;

 				renumber_panes r;									# This should be called whenever a pane is noted or dropped.

 				apply	do_crypt   (reverse *pane_info.crypt_queue)					# We reverse to restore original message ordering.
					#
					where
					    fun do_crypt (crypt: Crypt)
						=
						editboss_to_pane.note_crypt  crypt;
					end;

				pane_info.crypt_queue
				    :=
				    [];
			    }
		    );
		fun mail_pane												# Send something to a pane. If the pane is not yet registered with editboss, the crypt will be queued up and delivered when the pane registers. Used for linking up screenline.pkg instances to textpane.pkg instances at startup (etc).
		      (													# Using a Crypt here makes the mechanism general at a small cost in typesafety.  In particular, it buys us valuable modularity by keeping editboss from needing to know the types of the interfaces between textpane and screenline (etc).
			pane_id:	Id,										#
			crypt:		Crypt
		      )
		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ (r as { id, me, ... }: Runstate)
			    =
			    {	pane_info =  get_or_make_pane_info { me, pane_id };
				#
				case *pane_info.editboss_to_pane
				    #
				    THE editboss_to_pane								# Pane has registered, so we can send the crypt immediately.
					=>
					editboss_to_pane.note_crypt  crypt;

				    NULL =>										# Pane has not yet registered, so we queue the crypt up; we'll send it when the pane registers.
					pane_info.crypt_queue
					    :=
					    crypt ! *pane_info.crypt_queue;
				esac;
			    }
		    );
		fun drop_pane
		      {
			pane_id:		Id
		      }
		    =
		    put_in_mailqueue  (editboss_q,
			#
			\\ (r as { id, me, ... }: Runstate)
			    =
			    {	me.panes_by_id
				    :=
				    im::drop  (*me.panes_by_id,   id_to_int pane_id);

				renumber_panes r;									# This should be called whenever a pane is noted or dropped.
			    }
		    );


		stipulate
		    cutbuffer_contents =  REF (ct::PARTLINE "");
		herein
		    fun get_cutbuffer_contents ()
			=
			*cutbuffer_contents;										# We do this in caller's thread (not editboss thread) for speed and to reduce risk of deadlock.

		    fun set_cutbuffer_contents (new_contents:	ct::Cutbuffer_Contents)
			=
			put_in_mailqueue  (editboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				cutbuffer_contents :=  new_contents							# We do this in the editboss thread to ensure cutbuffer_contents value remains stable over any editboss_imp call, just as good practice.
			);
		end;

		fun uniquify_name											# Convert "foo" into "foo<1>" or "foo<2>" or such in order to avoid conflicting with any existing name.
		      (
			me:		Editboss_State,
			name:		String
		      )
		    :			String
		    =
		    case (sm::get (*me.textmills_by_name, name))
			#
			NULL => name;											# Name is already unique.

			THE _ =>
			    uniquify_name' 0
			    where
				fun uniquify_name' (i: Int)
				    =
				    {   name' = sprintf "%s<%d>" name i;
					#
					case (sm::get (*me.textmills_by_name, name'))
					    #
					    NULL  =>  name';								# Modified name is now unique.
					    THE _ =>  uniquify_name' (i + 1);						# Modified name already exists, try one number higher.
					esac;
				    };
			    end;
		    esac;



		fun get_textmill   (name: String)
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Null_Or( mj::Textpane_To_Textmill ) );
			#
			put_in_mailqueue  (editboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				case (sm::get (*me.textmills_by_name, name))
				    #
				    THE textmill_info =>  put_in_oneshot (reply_oneshot, THE textmill_info.textpane_to_textmill);
				    NULL 	      =>  put_in_oneshot (reply_oneshot, NULL);
				esac
			);

			get_from_oneshot  reply_oneshot;
		    };

		fun get_or_make_textmill										# Find a buffer by name; if no such buffer exists, create one.  Buffer may or may not have an associated file.
		      (
			textmill_arg
			as
			{ name:			String,
			  textmill_options:	List( mj::Textmill_Option )
			}:			mj::Textmill_Arg
		      )
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mj::Textpane_To_Textmill );
			#
			put_in_mailqueue  (editboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				case (sm::get (*me.textmills_by_name, name))
				    #
				    THE textmill_info
					=> 
					put_in_oneshot (reply_oneshot, textmill_info.textpane_to_textmill);
				    #
				    NULL =>
					{   egg =  tbi::make_textmill_egg  textmill_arg;
					    #
					    (egg ())
						->
						( textmill_exports:	tbi::Exports,
						  egg':		       (tbi::Imports, Run_Gun, End_Gun) -> Void
						);

					    textmill_imports
					      =
					      { };

					    (make_run_gun ()) ->   { run_gun', fire_run_gun };
					    (make_end_gun ()) ->   { end_gun', fire_end_gun };

					    egg' (textmill_imports, run_gun', end_gun');

					    fire_run_gun ();

					    textmill_exports
						->
						{ textpane_to_textmill as mj::TEXTPANE_TO_TEXTMILL tb };

					    textmill_info = { id         =>	tb.id,
							      name	 =>	REF name,
							      filespec   =>	REF NULL,
							      #
							      textpane_to_textmill,
							      end_gun'
							    };

					    me.textmills_by_name := sm::set (*me.textmills_by_name, name,                  	 textmill_info);
					    me.textmills_by_id   := im::set (*me.textmills_by_id,   id_to_int textmill_info.id,  textmill_info);

					    tb.note_statewatcher (id, note_textmill_statechange);

					    put_in_oneshot (reply_oneshot, textpane_to_textmill);
					};
				esac
			);

			get_from_oneshot  reply_oneshot;
		    };

		fun get_or_make_filebuffer										# Find buffer open on given file.  If no such buffer exists, create one.  NB: We do our best to avoid having more than one buffer open on a given file.  (Multiple textpanes may be open on one buffer; that is a separate issue.)
		      (	
			filespec:		mj::Filespec
		      )
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mj::Textpane_To_Textmill );
			#
			put_in_mailqueue  (editboss_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				{   name = uniquify_name (me, filespec.basename);
				    #
				    textmill_options =  [];
				    textmill_arg     =  { name, textmill_options };

				    egg =  tbi::make_textmill_egg  textmill_arg;
				    #
				    (egg ())
					->
					( textmill_exports:	tbi::Exports,
					  egg':		       (tbi::Imports, Run_Gun, End_Gun) -> Void
					);

				    textmill_imports
				      =
				      { };

				    (make_run_gun ()) ->   { run_gun', fire_run_gun };
				    (make_end_gun ()) ->   { end_gun', fire_end_gun };

				    egg' (textmill_imports, run_gun', end_gun');

				    fire_run_gun ();

				    textmill_exports ->  {  textpane_to_textmill  as  mj::TEXTPANE_TO_TEXTMILL tb  };

				    filepath = filespec.dirname + "/" + filespec.basename;

				    textmill_info =   { id         =>	tb.id,
							name 	   =>	REF name,
							filespec   =>	REF (THE filespec),
							#
							textpane_to_textmill,
							end_gun'
						      };

				    me.textmills_by_filepath	:=  sm::set (*me.textmills_by_filepath, filepath,			textmill_info);
				    me.textmills_by_name	:=  sm::set (*me.textmills_by_name,     name,				textmill_info);
				    me.textmills_by_id		:=  im::set (*me.textmills_by_id,       id_to_int textmill_info.id,	textmill_info);

				    tb.note_statewatcher (id, note_textmill_statechange);

				    tb.set_filespec (THE filespec);

				    tb.reload_from_file ();

				    put_in_oneshot (reply_oneshot, textpane_to_textmill);
				}
			);

			get_from_oneshot  reply_oneshot;
		    };
	    end;

	#
	fun process_options (options: List(Editboss_Option), { name, id })
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME	n) =>   my_name			:=  n;
			do_option (ID			i) =>   my_id                   :=  i;
		    end;
		end;

		{ name			=>  *my_name,
		  id 			=>   *my_id
		};
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_editboss_egg																# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	      (editboss_arg:		Editboss_Arg)													# Called (only) by startup()	in   src/lib/x-kit/widget/gui/guiboss-imp.pkg
	    =
	    {	editboss_arg ->  (editboss_options);													# Currently no guiboss_needs component, so this is a no-op.
		#
		(process_options
		  ( editboss_options,
		    { name		=> "editboss",
		      id		=>  id_zero
		    }
		) )
		    ->
		    { name,
		      id
		    };
	
		my (id, editboss_options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();														# Allocate unique imp id.
			(id, ID id ! editboss_options);													# Make our id stable across stop/restart cycles.
		    else
			(id, editboss_options);
		    fi;

		editboss_arg = (editboss_options);													# Currently no guiboss_needs component, so this is a no-op.

		me =  {	textmills_by_name	=>  REF sm::empty,											# All currently active textmills, by name.
			textmills_by_id		=>  REF im::empty,											# All currently active textmills, by id.
			textpanes_by_id		=>  REF im::empty,											# All currently active textpanes, by id.
			#
			textmills_by_filepath	=>  REF sm::empty,											# All currently active textmills WHICH ARE OPEN ON A FILE, by filename.
			panes_by_id		=>  REF im::empty											# All currently active panes, by id.
		      };

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );						# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));									# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3															# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, editboss_arg, imports, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
