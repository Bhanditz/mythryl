## textmill-imp.pkg						# emacs calls these 'buffers' but 'pile' is shorter and more parellel to 'pane'.  Also in programming 'buffer' is usually an I/O staging mechanism, but here we are dealing with a repository rather than a I/O flow.
#								# Also, I want to eventually generalize this to various other foopane <-> foopile pairs, and generalize editboss to not know or care about the differences between them.
# A textmill contains (typically) the contents
# of one file open for editing.  It is not a
# GUI widget;  display of the textmill contents
# is handled by
#
#     src/lib/x-kit/widget/edit/textpane.pkg
#
# In "Model/View/Controller" terms, textmill-imp.pkg
# is the Model and textpane.pkg is the View+Controller.
#
# See also:
#     src/lib/x-kit/widget/edit/textpane.pkg
#     src/lib/x-kit/widget/edit/editboss-imp.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package bt  =  gui_to_sprite_theme;				# gui_to_sprite_theme		is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
    package ct  =  gui_to_object_theme;				# gui_to_object_theme		is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
    package wt  =  widget_theme;				# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

#   package os  =  guiboss_to_spritespace;			# guiboss_to_spritespace	is from   src/lib/x-kit/widget/space/sprite/guiboss-to-spritespace.pkg
#   package cs  =  guiboss_to_objectspace;			# guiboss_to_objectspace	is from   src/lib/x-kit/widget/space/object/guiboss-to-objectspace.pkg


    package boi =  spritespace_imp;				# spritespace_imp		is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;				# objectspace_imp		is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;				# widgetspace_imp		is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;				# guiboss_to_guishim		is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2s =  spritespace_to_sprite;			# spritespace_to_sprite		is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;			# objectspace_to_object		is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2b =  sprite_to_spritespace;			# sprite_to_spritespace		is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2c =  object_to_objectspace;			# object_to_objectspace		is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg

#   package c2g =  gadget_to_editboss;				# gadget_to_editboss		is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

    package ebt =  editboss_types;				# editboss_types		is from   src/lib/x-kit/widget/edit/editboss-types.pkg

    package e2g =  editboss_to_guiboss;				# editboss_to_guiboss		is from   src/lib/x-kit/widget/edit/editboss-to-guiboss.pkg

    package sj  =  string_junk;					# string_junk			is from   src/lib/std/src/string-junk.pkg
    package que =  queue;					# queue				is from   src/lib/src/queue.pkg
    package nl  =  red_black_numbered_list;			# red_black_numbered_list	is from   src/lib/src/red-black-numbered-list.pkg
    package tbj =  textmill_junk;				# textmill_junk			is from   src/lib/x-kit/widget/edit/textmill-junk.pkg
    package tbt =  textmill_types;				# textmill_types		is from   src/lib/x-kit/widget/edit/textmill-types.pkg
    package mj  =  mode_junk;					# mode_junk			is from   src/lib/x-kit/widget/edit/mode-junk.pkg


    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

Dummy3 = mj::Textpane_To_Textmill;	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy4 = tbj::Foo;			# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy5 = tbt::Bar;			# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
herein

    package textmill_imp
    :       Textmill_Imp															# Textmill_Imp		is from   src/lib/x-kit/widget/edit/textmill-imp.api
    {
	Textmill_State																# Holds all nonephemeral mutable state maintained by package.
	  =
	  { state:		Ref( mj::Textstate		),										# Current visible state of textmill.
	    history:		Ref( que::Queue(mj::Undostate)	),										# Recent visible states of textmill, to support undo functionality.
	    history_len:	Ref( Int			),										# Max length of 'history' list.
	    history_max:	Ref( Int			),										# Max length of 'history' list.
	    filespec:		Ref( Null_Or( mj::Filespec )	),										# Name of file being edited in buffer, or NULL if no file is associated with buffer contents.
	    name:		Ref( String			),										# Name of buffer for display purposes, typically defaults to filename.
	    dirty:		Ref( Bool			),										# TRUE if buffer contents have been changed since being read from disk.
	    readonly:		Ref( Bool			),										# TRUE if buffer contents are currently marked as read-only.
	    textpane_hint:	Ref( Exception			)										# Point+mark etc info stored for textpane.pkg, in a format (only) textpane can decipher.
	  };


	Imports = {																# Ports we use, provided by other imps.
		  };


	Me_Slot = Mailslot( { imports:		Imports,
			      me:		Textmill_State,
			      textmill_arg:	mj::Textmill_Arg,
			      statewatchers:	Ref(im::Map( (Id, (Id, mj::Textmill_Statechange) -> Void) )),					# First 'Id' is (e.g.) textpane_id, second Id is textmill_id.
			      run_gun':		Run_Gun,
			      end_gun':		End_Gun
			    }
			  );

	Exports	= {																# Ports we provide for use by other imps.
		    textpane_to_textmill:	mj::Textpane_To_Textmill
		  };


	Textmill_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);

	Runstate =    {																# These values will be statically globally visible throughout the code body for the imp.
			id:			Id,
			me:			Textmill_State,											# State which is preserved across imp shutdown/restart cycles.
			textmill_arg:		mj::Textmill_Arg,
			imports:		Imports,											# Imps to which we send requests.
			to:			Replyqueue,											# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
			statewatchers:		Ref(im::Map( (Id, (Id, mj::Textmill_Statechange) -> Void ))),					# First 'Id' is (e.g.) textpane_id, second Id is textmill_id.
			end_gun':		End_Gun												# We shut down the microthread when this fires.
		      };

	Textmill_Q    = Mailqueue( Runstate -> Void );


	fun run ( textmill_q:			Textmill_Q,											# 
		  #
		  runstate as
		  {																# These values will be statically globally visible throughout the code body for the imp.
		    me:				Textmill_State,											# State which is preserved across imp shutdown/restart cycles.
		    textmill_arg:		mj::Textmill_Arg,
		    imports:			Imports,											# Imps to which we send requests.
		    to:				Replyqueue,											# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    statewatchers:		Ref(im::Map( (Id, (Id, mj::Textmill_Statechange) -> Void ))),					# First 'Id' is (e.g.) textpane_id, second Id is textmill_id.
		    end_gun':			End_Gun,											# 
		    id:				Id
		  }
		)
	    =
	    {	loop ();
	    }
	    where


		#
		fun loop ()															# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    end_gun'                        ==>  shut_down_textmill_imp',
			    take_from_mailqueue' textmill_q ==>  do_textmill_plea
			];

			loop ();
		    }	
		    where
			fun do_textmill_plea  thunk
			    =
			    thunk runstate;
			#
			fun shut_down_textmill_imp' ()
			    =
			    {
				thread_exit { success => TRUE };										# Will not return.	
			    };
		    end;
	    end;	



	#
	fun startup   (id: Id,   reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()							# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		textpane_to_textmill
		  =
		  mj::TEXTPANE_TO_TEXTMILL
		    {
		      id,
		      #
		      get_maxline,
		      pass_maxline,

		      get_line,
		      pass_line,

		      set_lines,
		      get_lines,
		      pass_lines,

		      get_textstate,
		      pass_textstate,

		      pass_edit_result,

		      undo,

		      get_dirty,
		      pass_dirty,

		      set_readonly,
		      get_readonly,
		      pass_readonly,

		      get_filespec,
		      set_filespec,
		      pass_filespec,

		      get_name,
		      set_name,
		      pass_name,

		      set_textpane_hint,
		      get_textpane_hint,

		      note_statewatcher,
		      drop_statewatcher,

		      reload_from_file,
		      save_to_file
		    };

		exports	    = { textpane_to_textmill
			      };
				
		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, exports));										# Return value from textmill_egg'().

		(take_from_mailslot  me_slot)													# Imports from textmill_egg'().
		    ->
		    { me, textmill_arg, imports, statewatchers, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';												# Wait for the starting gun.

		runstate =    { id,
				me,
				textmill_arg,
				imports,
				to,
				statewatchers,
				end_gun'
			      };

		tell_statewatchers_full_state  runstate;											# Make sure statewatchers start out with full update.

		run (textmill_q, runstate);		 											# Will not return.
	    }
	    where
		textmill_q     =  make_mailqueue (get_current_microthread()):  Textmill_Q;


		fun tell_statewatchers
		      (
			statewatchers:		im::Map( (Id, (Id, mj::Textmill_Statechange) -> Void) ),					# First 'Id' is (e.g.) textpane_id, second Id is textmill_id.
			statechange:		mj::Textmill_Statechange
		      )
		    =
		    im::keyed_apply   tell_watcher   statewatchers
		    where
			fun tell_watcher
			      (
				key:			Int,											# == (id_to_int id)
				( watcher_id:		Id,											# Unique id identifying this watcher.
				  statewatcher:		(Id, mj::Textmill_Statechange) -> Void							# Id is textmill_id.
				)
			      )
			    =
			    statewatcher  (id, statechange);
		    end;

		fun tell_statewatcher_full_state
		      (
			statewatcher:		(Id, mj::Textmill_Statechange) -> Void,
			r:			Runstate
		      )	
		    =
		    {   statewatcher  (r.id, mj::TEXTSTATE_CHANGED  { was => *r.me.state,	now => *r.me.state      });
			statewatcher  (r.id, mj::FILESPEC_CHANGED   { was => *r.me.filespec,	now => *r.me.filespec   });
			statewatcher  (r.id, mj::NAME_CHANGED	    { was => *r.me.name, 	now => *r.me.name	});
			statewatcher  (r.id, mj::READONLY_CHANGED   { was => *r.me.readonly,	now => *r.me.readonly	});
			statewatcher  (r.id, mj::DIRTY_CHANGED	    { was => *r.me.dirty,	now => *r.me.dirty	});
		    };

		fun tell_statewatchers_full_state
		      (
			r:			Runstate
		      )
		    =
		    im::keyed_apply   tell_watcher   *r.statewatchers
		    where
			fun tell_watcher
			      (
				key:			 Int,											# == (id_to_int id)
				( id:			 Id,											# Unique id identifying this watcher -- typically textpane_id or editboss_id.
				  statewatcher:		(Id, mj::Textmill_Statechange) -> Void							# The 'Id' field here will be ours   -- textmill_id.
				)
			      )
			    =
			    tell_statewatcher_full_state (statewatcher, r);
		    end;

		fun line_range (textlines: mj::Textlines,  firstline: Int,  lastline: Int):  List(String)
		    =
		    lines (lastline, [])
		    where
			fun lines (i: Int, result: List(String))
			    =
			    if (i < firstline)    result;
			    else
				result =    case (nl::find (textlines, i))
						#
						THE line => line ! result;
						NULL	 =>        result;
					    esac;

				lines  (i - 1,  result);
			    fi;
		    end;


		fun changed_textlines ([]:  List(mj::Editfn_Out_Option)) =>  NULL;
		    changed_textlines (mj::TEXTLINES textlines ! _)	 =>  THE textlines;
		    changed_textlines (_ ! rest)			 =>  changed_textlines rest;
		end;

		fun changed_readonly  ([]:  List(mj::Editfn_Out_Option)) =>  NULL;
		    changed_readonly  (mj::READONLY readonly ! _)	 =>  THE readonly;
		    changed_readonly  (_ ! rest)			 =>  changed_readonly rest;
		end;


		fun do_pass_edit_result
		      (
			{ id, me, statewatchers, ... }:	Runstate,
			#
			arg as
			{ keystring:		String,								# User keystroke that invoked this editfn.
			  numeric_prefix:	Null_Or(Int),							# ^U "Universal numeric prefix" value for this editfn if supplied by user, else NULL.
			  prompted_args:	List( mj::Prompted_Arg ),					# Args read interactively from user.
			  point_and_mark:	mj::Point_And_Mark,						# 'point' is the visible cursor. 'mark' (if set) is the other end of the selected region. (Emacs nomenclature.)
			  lastmark:		Null_Or( g2d::Point ),
			  log_undo_info:	Bool,
			  #
			  pane_id:		Id,
			  editfn_node:		mj::Editfn_Node,
			  widget_to_guiboss:	gt::Widget_To_Guiboss,						# Mainly for access to get_cutbuffer_contents/set_cutbuffer_contents in gadget_to_editboss.  NB: Passing gadget_to_editboss here instead results in a package cycle.
			  mainmill_mode:	mj::Millmode,
			  minimill_mode:	mj::Millmode,
			  textpane_to_textmill:	mj::Textpane_To_Textmill
			}
		      )
		    =
		    {
			was = *me.state;
			#
			gadget_to_editboss
			    =
			    mj::find__gadget_to_editboss
			      (
				widget_to_guiboss.g,
				"textmill_imp::do_pass_edit_result"
			      );

			gadget_to_editboss
			    ->
			    mj::GADGET_TO_EDITBOSS eb;								# We don't currently use 'eb' here.
 
			editfn_in =   { args			=>  prompted_args,
					textlines		=>  was.textlines,
					point  			=>  point_and_mark.point,
					mark			=>  point_and_mark.mark,
					readonly		=> *me.readonly,
					lastmark,
					pane_id,
					widget_to_guiboss,
					gadget_to_editboss,
					keystring,
					numeric_prefix,
					mainmill_mode,
					minimill_mode,
					textpane_to_textmill
				      };	

			plain_editfn
			    =
			    case editfn_node
				#
				mj::PLAIN_EDITFN  plain_editfn => plain_editfn;

				mj::FANCY_EDITFN => {	msg = "FANCY_EDITFN not supported -- do_pass_edit_result in textmill-imp.pkg";
							log::fatal msg;
							raise exception DIE msg;
						    };
			    esac;

			editfn_out =	(plain_editfn.editfn editfn_in)
					except _ = FAIL "<uncaught exception in editfn>";								# Handle any uncaught exceptions in editfn. (Shouldn't happen.)

			case editfn_out
			    #
			    FAIL _ => ();															# Editfn aborted, no changes to process.

			    WORK editfn_out_options													# Editfn did not abort ...
				=>
				{
				    case (changed_readonly  editfn_out_options)
					#
					NULL => ();													# 

					THE readonly
					    =>
					    {	was = *me.readonly;
						now =     readonly;

						me.readonly :=  readonly;

						tell_statewatchers  (*statewatchers,  mj::READONLY_CHANGED  { was, now });
					    };
				    esac;

				    case (changed_textlines  editfn_out_options)
					#
					NULL => ();													# Editfn did NOT change contents of textmill, so we're done.

					THE new_textlines												# Editfn DID change contents of textmill.
					    =>
					    {   now     = { textlines =>  new_textlines,
							    editcount =>  was.editcount + 1
							  };

						was_dirty    =  *me.dirty;

						me.state    :=  now;
						me.dirty    :=  TRUE;
						me.readonly :=  FALSE;

						if log_undo_info
						    #
						    me.history :=  que::push (*me.history, was);							# Add previous state to history.

						    if(*me.history_len <  *me.history_max)								# Maybe we should have a bounded-queue.pkg that handles all this stuff internally?
							me.history_len := *me.history_len + 1;								# History is under max allowed, so let it get one longer.
						    else
							(que::pull *me.history) -> (newhistory, _);							# History is at max allowed, pull an entry to keep it under limit.
							#
							me.history     := newhistory;
						    fi;
						fi;

						tell_statewatchers  (*statewatchers,  mj::TEXTSTATE_CHANGED  { was, now });

						if (was_dirty != *me.dirty)
						    #
						    tell_statewatchers
						      (
							*statewatchers,

							mj::DIRTY_CHANGED
							  { was => was_dirty,
							    now => *me.dirty
							  }
						    );
						fi;

					    };
				    esac;
				};
			esac;

			editfn_out;															# Return all updates to caller.
		    };

		fun do_undo ({ id, me, statewatchers, ... }:	Runstate)
		    =
		    if (*me.history_len > 0)
			#
			(*me.state)             -> (             was);
			(que::pull *me.history) -> (new_history, now);

			now 	= the now;														# Should not be NULL because we checked for history_len==0 above.

			me.history	:=  new_history;
			me.history_len  := *me.history_len - 1;
			me.state	:=  now;

			tell_statewatchers  (*statewatchers,  mj::UNDO { was, now });
		    fi;



		#################################################################################
		# editboss interface fns::
		#
		#

		#################################################################################
		# texteditor interface fns::
		#
		#

		fun get_maxline ()														# PUBLIC.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Int );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				{   state = *me.state;
				    #
				    put_in_oneshot (reply_oneshot, the (nl::max_key state.textlines));
				}
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #
		fun pass_maxline  (replyqueue: Replyqueue)  (reply_handler: Int -> Void)							# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Int );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				{   state = *me.state;
				    #
				    put_in_oneshot (reply_oneshot, the (nl::max_key state.textlines));
				}
			);
 
			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };


		fun get_line (i: Int)														# PUBLIC.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Null_Or(String) );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				{   state = *me.state;
				    #
				    put_in_oneshot (reply_oneshot, (nl::find (state.textlines, i)));
				}
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #		
		fun pass_line  (replyqueue: Replyqueue)  (i: Int)  (reply_handler: Null_Or(String) -> Void)					# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Null_Or(String) );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				{   state = *me.state;
				    #
				    put_in_oneshot (reply_oneshot, (nl::find (state.textlines, i)));
				}
			);
 
			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };



		fun set_lines  (lines: List(String))												# PUBLIC.
		    =
		    {   put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, statewatchers, ... }: Runstate)
				=
				{   (*me.state) ->    { textlines, editcount };
				    #
				    me.state :=	      { textlines =>  nl::from_list  lines,
							editcount =>  editcount + 1
						      };
				}
			);
		    };
		    #
		fun get_lines (first: Int,  last: Int)												# PUBLIC.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( List(String) );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				{   state = *me.state;
				    #
				    put_in_oneshot (reply_oneshot, (line_range (state.textlines, first, last)));
				}
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #		
		fun pass_lines  (replyqueue: Replyqueue)  (first: Int, last: Int)  (reply_handler: List(String) -> Void)			# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( List(String) );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				{   state = *me.state;
				    #
				    put_in_oneshot (reply_oneshot, (line_range (state.textlines, first, last)));
				}
			);
 
			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };


		fun get_textstate ()														# PUBLIC.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mj::Textstate );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.state)
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #
		fun pass_textstate  (replyqueue: Replyqueue)  (reply_handler: mj::Textstate -> Void)						# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mj::Textstate );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.state)
			);
 
			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };

		fun pass_edit_result														# PUBLIC.
		      #		
		      (arg:		mj::Edit_Arg)
		      #		
		      (replyqueue:	Replyqueue)
		      #		
		      (reply_handler:	mj::Editfn_Out -> Void)
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( mj::Editfn_Out );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ (r: Runstate)
				=
				put_in_oneshot (reply_oneshot, do_pass_edit_result (r, arg))
			);

			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };

		fun undo ()															# PUBLIC.
		    =
		    {   put_in_mailqueue  (textmill_q,
			    #
			    \\ (r: Runstate)
				=
				do_undo r
			);
		    };


		fun get_dirty ()														# PUBLIC.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Bool );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.dirty)
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #
		fun pass_dirty  (replyqueue: Replyqueue)  (reply_handler: Bool -> Void)								# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Bool );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.dirty)
			);
 
			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };


		fun set_readonly (readonly: Bool)												# PUBLIC.
		    =
		    {	put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, statewatchers, ... }: Runstate)
				=
				{   was = *me.readonly;
				    now =     readonly;

				    me.readonly := readonly;

				    tell_statewatchers  (*statewatchers, mj::READONLY_CHANGED { was, now });
				}
			);
		    };
		    #
		fun get_readonly ()														# PUBLIC.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Bool );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.readonly)
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #
		fun pass_readonly  (replyqueue: Replyqueue)  (reply_handler: Bool -> Void)							# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Bool );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.readonly)
			);
 
			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };


		fun set_filespec (filespec: Null_Or( mj::Filespec ))										# PUBLIC.
		    =
		    {	put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, statewatchers, ... }: Runstate)
				=
				{   tell_statewatchers  (*statewatchers, mj::FILESPEC_CHANGED { now => filespec, was => *me.filespec });
				    #
				    me.filespec := filespec;
				}
			);

		    };
		    #
		fun get_filespec ()														# PUBLIC.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Null_Or( mj::Filespec ) );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, statewatchers, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.filespec)
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #
		fun pass_filespec  (replyqueue: Replyqueue)  (reply_handler: Null_Or(mj::Filespec) -> Void)					# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Null_Or( mj::Filespec ) );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.filespec)
			);
 
			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };


		fun set_name (name: String)												# PUBLIC.
		    =
		    {	put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, statewatchers, ... }: Runstate)
				=
				{   tell_statewatchers  (*statewatchers,  mj::NAME_CHANGED { now => name, was => *me.name });
				    #
				    me.name := name;
				}
			);
		    };
		    #
		fun get_name ()														# PUBLIC.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( String );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.name)
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #
		fun pass_name  (replyqueue: Replyqueue)  (reply_handler: String -> Void)							# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( String );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.name)
			);
 
			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };


		fun set_textpane_hint (hint: Exception)												# PUBLIC.
		    =
		    {	put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, statewatchers, ... }: Runstate)
				=
				me.textpane_hint := hint
			);

		    };
		    #
		fun get_textpane_hint ()													# PUBLIC.
		    =
		    {	reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Exception );
			#
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, statewatchers, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, *me.textpane_hint)
			);

			get_from_oneshot  reply_oneshot;
		    };
		    #


		fun note_statewatcher														# PUBLIC.
		      (
			statewatcher_id:	Id,												# This Id is typically editboss_id or textpane_id.
			statewatcher:		(Id, mj::Textmill_Statechange) -> Void								# The  Id here will be ours (textmill_id).
		      )	
		    =
		    {   put_in_mailqueue  (textmill_q,
			    #
			    \\ (runstate as { id, me, statewatchers, ... }: Runstate)
				=
				{   statewatchers :=  im::set( *statewatchers,
								id_to_int  statewatcher_id,
								(statewatcher_id, statewatcher)
							      );
				    tell_statewatcher_full_state (statewatcher, runstate);							# Make sure new statewatcher starts out with full update.
				}
			);
		    };
		    #
		fun drop_statewatcher  (statewatcher_id:  Id)											# PUBLIC.
		    =
		    {   
			put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, statewatchers, ... }: Runstate)
				=
				statewatchers :=  im::drop (*statewatchers,  id_to_int statewatcher_id)
			);
		    };


		fun reload_from_file  ()													# PUBLIC.
		    =
		    {   put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, statewatchers, ... }: Runstate)
				=
				case (*me.filespec)
				    #
				    NULL   =>  ();

				    THE fs =>
					{   filepath =  fs.dirname
						     + "/"
						     +  fs.basename
						     ;

					    as_lines = 	file::as_lines;
					    #
					    lines = as_lines filepath
						    except _ =
							{
							    [ "\n" ];
							};

					    textlines = nl::from_list  lines;

					    me.state :=	{ textlines,
							  editcount =>  1
							};
					};
				esac
			);
		    };
		    #
		fun save_to_file  ()														# PUBLIC.
		    =
		    {   put_in_mailqueue  (textmill_q,
			    #
			    \\ ({ id, me, statewatchers, ... }: Runstate)
				=
				case (*me.filespec)
				    #
				    NULL   =>  ();

				    THE fs =>
					if *me.dirty												# No point saving buffer contents to disk unless they have been modified.
					    #
					    filepath =  fs.dirname
						     + "/"
						     +  fs.basename
						     ;

# XXX SUCKO FIXME We're not doing any handling of errors like failure to open or write or close here.  We probably should also be writing to a tempfile and then renaming to the actual filename only if the complete write+close sequence succeeds.
					    (file::open_for_write filepath)
						->
						outstream;

					    apply  do_line  (nl::vals_list (*me.state).textlines)
						where
						    fun do_line (line: String)
							=
							file::write (outstream, line);
						end;

					    file::close_output  outstream;

					    me.dirty := FALSE;

					    tell_statewatchers  (*statewatchers,  mj::DIRTY_CHANGED { was => TRUE, now => FALSE });
					fi;
				esac
			);
		    };
	    end;

	#
	fun process_options
	      (
		options: List(mj::Textmill_Option),
		#
		{ name,
		  id,
		  statewatchers,
		  filename,
		  text
		}
	      )
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		my_statewatchers	=      statewatchers;											# Already has a REF on it.
		my_filename		=  REF filename;	
		my_text			=  REF text;

		apply  do_option  options
		where
		    fun do_option (mj::MICROTHREAD_NAME		n)  =>  my_name		 :=  n;
			do_option (mj::ID			i)  =>  my_id		 :=  i;
			do_option (mj::STATEWATCHER       (id, w)) =>	my_statewatchers :=  im::set (*my_statewatchers, id_to_int id, (id, w));
			do_option (mj::INITIAL_FILENAME		n)  =>	my_filename      :=  n;
			do_option (mj::UTF8			n)  =>	my_text		 :=  n;
		    end;
		end;

		{ name		 =>  *my_name,
		  id 		 =>  *my_id,
		  statewatchers  =>   my_statewatchers,												# Leave the REF on it.
		  filename       =>  *my_filename,
		  text	         =>  *my_text
		};
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_textmill_egg
	      (textmill_arg:		mj::Textmill_Arg)											# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	    =
	    {	textmill_arg ->  { name, textmill_options };
		#
		(process_options
		  ( textmill_options,
		    { name		=>  name,
		      id		=>  id_zero,
		      statewatchers	=>  REF im::empty,
		      filename		=>  "",
		      text		=>  "\n"
		    }
		) )
		    ->
		    { name,
		      id,
		      statewatchers,
		      filename,
		      text
		    };
	
		filespec =  if (filename == "")
				NULL;
			    else
				dirname  = sj::dirname  filename;
				basename = sj::basename filename;
				#
				THE { dirname, basename };
			    fi;

		my (id, textmill_options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();													# Allocate unique imp id.
			(id, mj::ID id ! textmill_options);											# Make our id stable across stop/restart cycles.
		    else
			(id, textmill_options);
		    fi;

		me =	{ state		=>  REF textstate,
			  history	=>  REF que::empty_queue,
			  history_len	=>  REF   0,
			  history_max	=>  REF 100,
			  filespec	=>  REF filespec,
# XXX BUGGO FIXME We need to ensure here that name is unique.  (Or is that an upstream responsibility? Anyhow, someone needs to be doing that.)  LATER: There is now a uniquify_name() to help out with this in  src/lib/x-kit/widget/edit/editboss-imp.pkg
			  name		=>  REF name,
			  dirty		=>  REF FALSE,
			  readonly	=>  REF FALSE,
			  textpane_hint	=>  REF IMPOSSIBLE											# Randomly selected exception; just trying to be type-correct here. It is up to textpane.pkg to set a reasonable value via set_textpane_hint().
			}
			where
			    textstate =   { textlines =>  nl::from_list (string::lines text),
					    editcount =>  0
					  };
			end;

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );					# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));								# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3														# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, textmill_arg, imports, statewatchers, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
