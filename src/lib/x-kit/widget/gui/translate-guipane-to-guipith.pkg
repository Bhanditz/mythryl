## translate-guipane-to-guipith.pkg
#
# Editing running GUIs.
# For motivation, overview and background see Note[1] at bottom of file.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;							# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    include package   threadkit;							# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package evt =  gui_event_types;							# gui_event_types			is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;							# gui_event_to_string			is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;							# guiboss_types				is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;					# windowsystem_to_xevent_router		is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;							# gui_displaylist			is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;						# standard_prettyprint_mill		is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;							# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package bt  =  gui_to_sprite_theme;							# gui_to_sprite_theme			is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
    package ct  =  gui_to_object_theme;							# gui_to_object_theme			is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
    package wt  =  widget_theme;							# widget_theme				is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

    package boi =  spritespace_imp;							# spritespace_imp			is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;							# objectspace_imp			is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;							# widgetspace_imp			is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;							# guiboss_to_guishim			is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg
    package gtj =  guiboss_types_junk;							# guiboss_types_junk			is from   src/lib/x-kit/widget/gui/guiboss-types-junk.pkg

    package b2s =  spritespace_to_sprite;						# spritespace_to_sprite			is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;						# objectspace_to_object			is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2s =  sprite_to_spritespace;						# sprite_to_spritespace			is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2o =  object_to_objectspace;						# object_to_objectspace			is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg

#   package s2g =   space_to_gui;							# space_to_gui				is from   src/lib/x-kit/widget/gui/space-to-gui.pkg
    package g2p =  gadget_to_pixmap;							# gadget_to_pixmap			is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package frm =  frame;								# frame					is from   src/lib/x-kit/widget/leaf/frame.pkg
    package lts =  list_to_string;							# list_to_string			is from   src/lib/src/list-to-string.pkg

    package iul =  issue_unique_look_id;						# issue_unique_look_id			is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    package im  =  int_red_black_map;							# int_red_black_map			is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;							# int_red_black_set			is from   src/lib/src/int-red-black-set.pkg

    package r8  =  rgb8;								# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;									# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;								# geometry2d				is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;							# geometry2d_junk			is from   src/lib/std/2d/geometry2d-junk.pkg

    package ebi =  editboss_imp;							# editboss_imp				is from   src/lib/x-kit/widget/edit/editboss-imp.pkg
    package e2g =  editboss_to_guiboss;							# editboss_to_guiboss			is from   src/lib/x-kit/widget/edit/editboss-to-guiboss.pkg

    package t2t =  texteditor_to_textbuffer;						# texteditor_to_textbuffer		is from   src/lib/x-kit/widget/edit/texteditor-to-textbuffer.pkg
#   package tbi =  textbuffer_imp;							# textbuffer_imp			is from   src/lib/x-kit/widget/edit/textbuffer-imp.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;								# log					is from   src/lib/std/src/log.pkg
herein

    package translate_guipane_to_guipith
    :       Translate_Guipane_To_Guipith						# Translate_Guipane_To_Guipith		is from   src/lib/x-kit/widget/gui/translate-guipane-to-guipith.api
    {
	fun guipane_to_guipith
	    # 
	    ( me:		gt::Guiboss_State
	    )
	    :
	    im::Map( gt::Xi_Topwindow_Info )
	    =
	    {   xi_topwindow_infos
		    =
		    map do_topwindow_info  (im::vals_list *me.topwindows)
			where
			    fun do_topwindow_info (topwindow_info: gt::Topwindow_Info):  gt::Xi_Topwindow_Info
				=
				{   id = topwindow_info.guiboss_to_topwindow.id;
				    #
				    subwindow_info
					=
					case *topwindow_info.subwindow_info
					    #
					    THE (gt::SUBWINDOW_DATA subwindow_info)
						=>
						THE  (gt::XI_SUBWINDOW_DATA  (do_subwindow_info  subwindow_info));

					    NULL => NULL;
					esac;

				    xi_topwindow_info
				      =
				      { id, subwindow_info };

				    xi_topwindow_info;
				};
			end;

		result =    (list::fold_forward  add_topwindow_info  im::empty  xi_topwindow_infos)
			    where
				fun add_topwindow_info
				      (
					xi_topwindow_info:	gt::Xi_Topwindow_Info,
					result_so_far:		im::Map(gt::Xi_Topwindow_Info)
				      )
				    =
				    im::set ( result_so_far,
					      id_to_int  xi_topwindow_info.id,
					      xi_topwindow_info
					    );
			    end;

		result;
	    }

	where

	    fun do_rg_widget  (rg_widget: gt::Rg_Widget)
		=
		case rg_widget
		    #
		    gt::RG_ROW  { id:			Id,
				  widgets:		List(  gt::Rg_Widget ),
				  widget_layout_hint:	Ref( gt::Widget_Layout_Hint ),
				  site:			Ref(g2d::Box)
				}
			=>
			gt::XI_ROW { id,  widgets =>  map  do_rg_widget  widgets  };

		    gt::RG_COL  { id:		Id,
				  widgets:		List( gt::Rg_Widget ),
				  widget_layout_hint:	Ref( gt::Widget_Layout_Hint ),
				  site:			Ref(g2d::Box)
				}
			=>
			gt::XI_COL { id, widgets =>   map  do_rg_widget widgets  };


		    gt::RG_GRID { id:			Id,
				  widgets:		List( List( gt::Rg_Widget ) ),
				  widget_layout_hint:	Ref( gt::Widget_Layout_Hint ),
				  site:			Ref(g2d::Box)
				}
			=>
			gt::XI_GRID { id,
				      widgets =>  map  do_row  widgets
				    }
			where
			    fun do_row (widgets: List(gt::Rg_Widget))
				=
				(map  do_rg_widget  widgets);

			end;

		    gt::RG_SCROLLPORT
			    { id:		Id,
			      upperleft:	Ref(g2d::Point),							# Origin of view's subwindow_or_view in scrollport coordinates, used for scrolling pixmap in scrollport.
			      scroller:		Ref(gt::Scroller),							# Client-code interface for controlling view_upperleft. This is a ref to resolve mutual recursion issues at creation, not because we expect to update it.
			      callback:		gt::Scroller_Callback,							# This is how we pass our Scroller to app client code, which basically lets it set 'pixmap_upperleft' above.
			      site:		Ref(g2d::Box),								# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

			      rg_widget:	Ref( gt::Rg_Widget ),							# Widget-tree visible in this viewable, which gets rendered onto 'pixmap' here.
			      #												# rg_widget is a Ref not because we intend to change it, but to work around a technical difficulty in guiboss-imp.pkg:do_pg_widget:PG_SCROLLPORT where  viewable_data and rg_widget each want to be created first.
			      pixmap:		g2p::Gadget_To_Rw_Pixmap,						# 
															# 
															#		                      
			      parent_subwindow_or_view:	gt::Subwindow_Or_View						# This can be a SCROLLABLE_INFO if we have a scrollport located on a scrollport.
			    }
			=>
			{
			    xi_widget   =  do_rg_widget  *rg_widget;

#			    pixmap_size =  gadget_to_rw_pixmap.size;
			    #
			    gt::XI_SCROLLPORT
			      { id,
				xi_widget
			      };
			};

		    gt::RG_TABPORT    { id:		Id,
					tabs:		List( gt::Tabbable_Info),
					visible_tab:	Ref( Int ),
					callback:	gt::Tab_Picker_Callback,
					site:		Ref(g2d::Box)
				      }
			=>
			{
			    #
			    gt::XI_TABPORT { id, widgets =>  map  do_tab  tabs }
				    where
					fun do_tab (tab: gt::Tabbable_Info)
					    =
					    do_rg_widget  tab.rg_widget;
				    end;
			};

		    gt::RG_FRAME
			    { id:			Id,
			      frame_widget:		gt::Rg_Widget,							# Widget which will draw the frame surround.
			      widget:			gt::Rg_Widget,							# Widget-tree to draw surrounded by frame.
			      widget_layout_hint:	Ref( gt::Widget_Layout_Hint ),
			      site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
			    }
			=>
			{   gt::XI_FRAME { id, frame_widget, widget }							# 
			    where
				fun do_widget (r: gt::Rg_Widget)
				    =
				    ( do_rg_widget  r
				    );

				frame_widget =  do_widget  frame_widget;
				widget       =  do_widget  widget;
			    end;
			};

		    gt::RG_WIDGET r
			=>
			{   id		=  r.guiboss_to_widget.id;
			    i		=  iul::id_to_int  id;
			    #
			    gadget_imp_info =  gtj::get_gadget_imp_info  (me.gadget_imps, id);

			    widget_layout_hint
				=
				case  (im::get (*me.widget_layout_hints, i))
				    #
				    THE hint => hint;
				    #
				    NULL     => {   msg = "widget not in *me.widget_layout_hints?! -- guipane_to_guipith in translate-guipane-to-guipith.pkg";
						    log::fatal msg;
						    raise exception FAIL msg;
						};
				esac;

			    gt::XI_WIDGET
			      {
				widget_id => r.guiboss_to_widget.id,
				widget_layout_hint
			      };
			};

		    #
		    gt::RG_OBJECTSPACE  objectspace
			=>
			do_objectspace  objectspace;

		    gt::RG_SPRITESPACE  spritespace
			=>
			do_spritespace  spritespace;

		    gt::RG_NULL_WIDGET
			=>
			gt::XI_NULL_WIDGET;
		esac


	    also
	    fun do_spritespace r
		=
		{
		    guiboss_to_spritespace_id
			=
			r.guiboss_to_spritespace.id;

		    xi_sprites =  do_rg_sprites  r.sprites;
		    #
#		    (im::get_or_raise_exception_not_found (*topwindow_info.spritespace_imps, (id_to_int r.spritespace_id)))
#			->
#			{ guiboss_to_spritespace, sprite_to_spritespace, shutdown_oneshot };
#
#		    arg =  get_from_oneshot  shutdown_oneshot;

		    gt::XI_SPRITESPACE { guiboss_to_spritespace_id, xi_sprites };
		}

	    also
	    fun do_rg_sprites (sprites:  List (gt::Rg_Sprite))
		=
		{
		    sprites'' = map  do_sprite  sprites
				where
				    fun do_sprite (sprite: gt::Rg_Sprite)
					=
					case sprite
					    #
					    gt::RG_SPRITE r
						=>
						gt::XI_SPRITE { sprite_id => r.guiboss_to_gadget.id };		# Read and return final state of sprite-imp -- incidentally confirming that it has completed its shutdown.
					esac;
				    #
#				    fun do_sprite (sprite': gt::Rg_Sprite)
#					=
#					{   sprite'' = do_sprite'  sprite';
#					    #
#					    sprite'';
#					};

				end;

		    sprites'';
		}


	    also
	    fun do_objectspace r
		=
		{
		    guiboss_to_objectspace_id
			=
			r.guiboss_to_objectspace.id;

		    xi_objects =  do_rg_objects  r.objects;
		    #
#		    (im::get_or_raise_exception_not_found (*topwindow_info.objectspace_imps, (id_to_int r.objectspace_id)))
#			->
#			{ guiboss_to_objectspace, object_to_objectspace, shutdown_oneshot };
#
#		    arg =  get_from_oneshot  shutdown_oneshot;

		    gt::XI_OBJECTSPACE { guiboss_to_objectspace_id, xi_objects };
		}

	    also
	    fun do_rg_objects (objects:  List (gt::Rg_Object))
		=
		{
		    objects'' = map  do_object  objects
				where
				    fun do_object (object: gt::Rg_Object)
					=
					case object
					    #
					    gt::RG_OBJECT r
						=>
						gt::XI_OBJECT { object_id => r.guiboss_to_gadget.id };		# Read and return final state of object-imp -- incidentally confirming that it has completed its shutdown.

					    gt::RG_WIDGETSPACE
						  { guiboss_to_widgetspace: 	gt::Guiboss_To_Widgetspace,
						    rg_widget:			gt::Rg_Widget
						  }
						=>
						{   xi_widget =  do_rg_widget  rg_widget;
						    #
						    gt::XI_WIDGETSPACE
						      {
							widgetspace_id => guiboss_to_widgetspace.id, 
							xi_widget
						      };
						};
					esac;
				    #
#				    fun do_object (object': gt::Rg_Object)
#					=
#					{   object'' = do_object'  object';
#					    #
#					    object'';
#					};
				end;

		    objects'';
		}												# fun do_rg_objects

	    also	
	    fun	do_subwindow_info (subwindow_info: gt::Subwindow_Info):  gt::Xi_Subwindow_Info
		=
		{   subwindow_info
		      ->
		      { guipane:		Ref( Null_Or( gt::Guipane ) ),
			pixmap:			Ref( g2p::Gadget_To_Rw_Pixmap ),							# Main backing store for this running gui.
			popups:			Ref(List(gt::Subwindow_Data)),								# These will all be SUBWINDOW_INFO, so 'Ref(List(Subwindow_Info))' would be a better type here.
			parent:			Null_Or( gt::Subwindow_Data ),								# For popups this points to the parent; for the original non-popup window it is NULL.
			stacking_order:		Int,											# Assigned in increasing order starting at 1;  these determine who overlies who visually on the screen in case of overlaps. (Popups must be entirely within parent, but sibling popups can overlap.)
			upperleft:		Ref(g2d::Point)										# If we have a parent, this gives our location on it. Note that pixmap.size gives our size.
		      };

		    guipane =	case *guipane
				    #
				    THE guipane =>  THE (do_guipane  guipane);
				    NULL	=>  NULL;
				esac;

		    popups  =   map do_popup  *popups;

		    id	    =   (*pixmap).id;

		    { id, guipane, popups };
		}

	    also
	    fun do_guipane (guipane: gt::Guipane):  gt::Xi_Guipane
		=
		{   guipane -> 	{ guiboss_to_widgetspace: 	gt::Guiboss_To_Widgetspace,
				  rg_widget:			gt::Rg_Widget,							# The widget (or more commonly, tree of widgets) managed by the gui-tree's toplevel widgetspace-imp.
				  topwindow:			gtg::Guiboss_To_Topwindow,					# The topwindow on which to draw our widgets. This represents the X-server window holding our tree of running guis.
				  subwindow_info:		gt::Subwindow_Data,						# The subwindow on which this running gui is drawn. This will be a sub-rectangle of the topwindow, except for the root running gui of the popups tree. It hosts the actual backing pixmap on which rg_widget will be drawn first.
				  needs_layout_and_redraw:	Ref( Bool )
				};

		    guiboss_to_widgetspace_id
			=
			guiboss_to_widgetspace.id;

		    xi_widget
			=
			do_rg_widget rg_widget;

 		    { guiboss_to_widgetspace_id,  xi_widget };
		}

	    also
	    fun do_popup (popup: gt::Subwindow_Data):  gt::Xi_Subwindow_Data
		=
		{   popup -> gt::SUBWINDOW_DATA subwindow_info;
		    #
		    xi_subwindow_info
			=
			do_subwindow_info  subwindow_info;

		    gt::XI_SUBWINDOW_DATA  xi_subwindow_info;
		};
	end;



	fun guipith_to_guipane
	    (
	      me:		gt::Guiboss_State,
	      new_guipith:	im::Map( gt::Xi_Topwindow_Info )			# This is a new GUI configuration constructed by application, submitted via Gadget_To_Guiboss.morph_guipane, which is to replace the current running GUI configuration.
	    )
	    :
	    im::Map( gt::Topwindow_Info )
	    =
	    {   validate_guipith ();

		dying_widgets = widgets_to_shut_down ();

		bogus_result  = build_new_guipanes ();

# XXX BUGGO FIXME Completely bogus value pending actual coding here:
		bogus_result;
	    }
	where
	    old_guipith =  guipane_to_guipith  me;    

	    fun find_all_widgets_in_guipith (guipith:	im::Map( gt::Xi_Topwindow_Info ))
		=
		{   widgets =  REF  (im::empty:  im::Map( gt::Xiwidget ));
		    #
		    gtj::guipith_apply   (new_guipith,   [ gtj::XI_WIDGET_FN  do_xi_widget ])
			where
			    fun do_xi_widget  (xi_widget:  gt::Xiwidget)
				=
				{   i =  iul::id_to_int  xi_widget.widget_id;
				    #
				    case (im::get (*widgets, iul::id_to_int xi_widget.widget_id))
					#
					NULL  =>    widgets :=  im::set (*widgets, i, xi_widget);

					THE _ =>    {   msg =  sprintf "Xiwidget %d appears more than once in guipith!" i;
							log::fatal msg;
							raise exception FAIL msg;
						    };
				    esac;
				};
			end;

		    *widgets;
		};

	    fun validate_guipith ()
		=
		{   # The idea here is that
		    #     Gadget_To_Guiboss.morph_guipane
		    # is intended to move widgets around between guipanes,
		    # not (yet?) to create or destroy topwindows or guipanes,
		    # so we want to check that the app-supplied 'guipith'
		    # arg has the same basic topology as the currently running
		    # gui in terms of existing topwindows and tree of popups
		    # on each topwindow.

		    verify_same_list_of_topwindows ();
		    verify_popup_trees_match       ();

		    verify_no_widgets_are_duplicated ();
		    verify_all_widgets_exist	     ();

# Eventually we'll probably want stuff like the following, but for now
# object and sprite support is more notional than actual, so I'm wimping
# out on this stuff:
# 		    verify_no_objects_are_duplicated             new_guipith ;
# 		    verify_all_objects_exist	   (old_guipith, new_guipith);
# 
# 		    verify_no_sprites_are_duplicated             new_guipith ;
# 		    verify_all_sprites_exist	   (old_guipith, new_guipith);
# 
# 		    verify_no_objectspace_imps_are_duplicated                new_guipith ;
# 		    verify_all_objectspace_imps_exist          (old_guipith, new_guipith);
# 
# 		    verify_no_spritespace_imps_are_duplicated                new_guipith ;
# 		    verify_all_spritespace_imps_exist          (old_guipith, new_guipith);
		}
		where

		    fun verify_no_widgets_are_duplicated ()
			=
			find_all_widgets_in_guipith  new_guipith;




		    fun verify_all_widgets_exist ()
			=
			{   old_widgets =  find_all_widgets_in_guipith  old_guipith;
			    new_widgets =  find_all_widgets_in_guipith  new_guipith;

			    apply check_widget_existence (im::keys_list new_widgets)
				where
				    fun check_widget_existence  (i: Int)
					=
					case (im::get (old_widgets, i))
					    #
					    THE _ =>    ();

					    NULL  =>    {   msg =  sprintf "guipith widget %d is not present in original gui!" i;
							    log::fatal msg;
							    raise exception FAIL msg;
							};
					esac;
				end;
			};


		    fun verify_same_list_of_topwindows ()
			=
			{   old_topwindows = 	int::sort (im::keys_list old_guipith);
			    new_topwindows = 	int::sort (im::keys_list new_guipith);

			    ints_to_string =    lts::list_to_string  int::to_string; 

			    if (old_topwindows != new_topwindows)
				#
				old =  ints_to_string  old_topwindows;
				new =  ints_to_string  new_topwindows;

				msg =  sprintf "new guipith topwindows list does not match running gui: running = %s  new = %s" old new;
				log::fatal msg;
				raise exception FAIL msg;
			    fi;
			};


		    fun verify_popup_trees_match ()							# We know list of topwindows match, check that each has the same popup structure.
			=
			{   apply check_topwindow  (im::keyvals_list old_guipith)
				where
				    fun verify_popup_trees_match'							# Check recursively that old and new guipiths have the same tree of popups.
					  (
					    old_subwindow_info:		gt::Xi_Subwindow_Info,
					    new_subwindow_info:		gt::Xi_Subwindow_Info
					  )
					=
					{   fun note_info (gt::XI_SUBWINDOW_DATA info,  r: im::Map(gt::Xi_Subwindow_Info))
						=
						{   i =  id_to_int  info.id;
						    #
						    case (im::get (r, i))
							#
							NULL  =>    im::set (r, i, info);
							#
							THE _ =>    {   msg = sprintf  "guipith contains two references to popup %d!" i;  log::fatal msg;  raise exception FAIL msg;  };
						    esac;
						};

					    old_subwindow_infos =  list::fold_forward  note_info  im::empty  old_subwindow_info.popups;
					    new_subwindow_infos =  list::fold_forward  note_info  im::empty  old_subwindow_info.popups;

					    apply check_old_info (im::keys_list old_subwindow_infos)			# Verify that all old popups are present in new guipith.
						where
						    fun check_old_info (i: Int)
							=
							case (im::get (new_subwindow_infos, i))
							    #
							    THE _ =>    ();
							    NULL  =>    {   msg =  sprintf "old popup %d is missing in guipith!" i;  log::fatal msg;  raise exception FAIL msg;  };
							esac;
						end;

					    apply check_new_info (im::keys_list new_subwindow_infos)			# Verify that all new popups are present in old guipith.
						where
						    fun check_new_info (i: Int)
							=
							case (im::get (new_subwindow_infos, i))
							    #
							    THE _ =>    ();
							    NULL  =>    {   msg =  sprintf "popup %d in new guipith is not in original guipith!" i;  log::fatal msg;  raise exception FAIL msg;  };
							esac;
						end;

					    apply  check_recursively  (im::keys_list old_subwindow_infos)
						where
						    fun check_recursively (i: Int)
							=
							{   old =  the (im::get (old_subwindow_infos, i));		# 'the' is safe because i is known to be a key in old_subwindow_infos.
							    new =  the (im::get (new_subwindow_infos, i));		# 'the' is safe because new_subwindow_infos is known to have the same keys as old_subwindow_infos.

							    verify_popup_trees_match' (old, new);
							};
						end;
					};


				    fun check_topwindow
					  (
					    key:		Int,
					    old_topwindow:	gt::Xi_Topwindow_Info
					  )
					=
					{   new_topwindow =   im::get_or_raise_exception_not_found (new_guipith, key);		# We know it is there from verify_same_list_of_topwindows check.
					    #
					    #
					    case  (old_topwindow.subwindow_info,   new_topwindow.subwindow_info)
						#
					        ( THE (gt::XI_SUBWINDOW_DATA old_data),
						  THE (gt::XI_SUBWINDOW_DATA new_data)
						)
						    =>
						    verify_popup_trees_match' (old_data, new_data);

						(THE _, NULL) => {   msg =  sprintf  "New guipith topwindow %d lacks subwindow info present in original topwindow %d"  (id_to_int new_topwindow.id)  (id_to_int old_topwindow.id);  log::fatal msg;  raise exception FAIL msg;  };
						(NULL, THE _) => {   msg =  sprintf  "New guipith topwindow %d   has subwindow info absent  in original topwindow %d"  (id_to_int new_topwindow.id)  (id_to_int old_topwindow.id);  log::fatal msg;  raise exception FAIL msg;  };
						(NULL, NULL ) => ();
					    esac;
					};
				end;

			};

		end;


	    fun	widgets_to_shut_down ()
		=
		{   old_widgets =  find_all_widgets_in_guipith  old_guipith;
		    new_widgets =  find_all_widgets_in_guipith  new_guipith;

		    dying_widgets =  REF (im::empty:  im::Map( gt::Xiwidget ));

		    apply check_widget_existence (im::keyvals_list old_widgets)
			where
			    fun check_widget_existence  (i: Int,  r: gt::Xiwidget)
				=
				case (im::get (new_widgets, i))
				    #
				    THE _ =>    ();

				    NULL  =>    dying_widgets :=  im::set (*dying_widgets, i, r);
				esac;
			end;

		    *dying_widgets;
		};

	    fun build_new_guipanes ()
		=
# XXX BUGGO FIXME This fn is current totally bogus pending actual coding here:
		im::empty:    im::Map( gt::Topwindow_Info );

# XXX BUGGO FIXME This fn is current totally bogus pending actual coding here:
	    fun do_xi_widget  (xi_widget: gt::Xi_Widget):   gt::Rg_Widget
		=
		case xi_widget
		    #
		    gt::XI_ROW  { id:		Id,
				  widgets:	List(  gt::Xi_Widget )
				}
			=>
			{   widgets =  map  do_xi_widget  widgets;
			    #
			    widget_layout_hint = REF gt::default_widget_layout_hint;

			    gt::RG_ROW  { id,
					  widgets,
					  widget_layout_hint,
					  site			=> REF  g2d::box::zero						# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					};
			};

		    gt::XI_COL  { id:			Id,
				  widgets:		List( gt::Xi_Widget )
				}
			=>
			{   widgets =  map  do_xi_widget  widgets;
			    #
			    widget_layout_hint = REF gt::default_widget_layout_hint;

			    gt::RG_COL  { id,
					  widgets,
					  widget_layout_hint,
					  site			=> REF  g2d::box::zero						# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					};
			};

		    gt::XI_GRID { id:			Id,
				  widgets:		List( List( gt::Xi_Widget ) )
				}
			=>
			{   widgets =   map  do_row  widgets
					where
					    fun do_row (widgets: List(gt::Xi_Widget))
						=
						(map  do_xi_widget  widgets);

					end;
			    widget_layout_hint = REF gt::default_widget_layout_hint;

			    #
			    gt::RG_GRID { id,
					  widgets,
					  widget_layout_hint,
					  site			=> REF  g2d::box::zero						# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					};
			};


		    gt::XI_SCROLLPORT
			    { id:				Id,
			      xi_widget:			gt::Xi_Widget
			    }
			=>
			{
			    gt::RG_NULL_WIDGET;

#			    rg_widget =   do_xi_widget  xi_widget;
#
#			    RG_SCROLLPORT
#			      {	id:				Id,								# Here we provide support for widgets visible through a scrollable scrollport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
#			        rg_widget:			Rg_Widget,							# Tree of widgets partially visible in scrollport.
#			        gadget_to_rw_pixmap:		g2p::Gadget_To_Rw_Pixmap,					# This is the pixmap visible through the scrollport. It holds a full image of above 'widget' tree.
#			        upperleft:			Ref(g2d::Point),						# Upperleft of view's subwindow_or_view in scrollport coordinates, used for scrolling pixmap in scrollport.
#			        subwindow_or_view:		Subwindow_Or_View,						# This is the parent pixmap holding the scrollport.
#			        scroller:			Scroller,
#			        callback:			Scroller_Callback,						# This is how we pass our Scroller to app client code, which basically lets it set 'pixmap_upperleft' above.
#			        site:				Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
#			      };
			};

		    gt::XI_TABPORT
			    { id:			Id,
			      widgets:			List( gt::Xi_Widget )
			    }
			=>
			gt::RG_NULL_WIDGET;

		    gt::XI_FRAME
			    { id:			Id,
			      frame_widget:		gt::Xi_Widget,									# Widget which will draw the frame surround.
			      widget:			gt::Xi_Widget									# Widget-tree to draw surrounded by frame.
			    }
			=>
			gt::RG_NULL_WIDGET;

		    gt::XI_WIDGET r
			=>
			gt::RG_NULL_WIDGET;

		    #
		    gt::XI_OBJECTSPACE  objectspace
			=>
			gt::RG_NULL_WIDGET;

		    gt::XI_SPRITESPACE  spritespace
			=>
			gt::RG_NULL_WIDGET;

		    gt::XI_NULL_WIDGET
			=>
			gt::RG_NULL_WIDGET;

		    gt::XI_GUIPLAN guiplan
			=>
			gt::RG_NULL_WIDGET;
		esac;
	end;
    };
end;

##########################################################################
# Note[1]
#
# The basic Client_To_Guiboss.start_gui() facility provides a simple						# Client_To_Guiboss	is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
# way to start up a running GUI sub/application from a reasonably
# concise Guiplan specification.
#
# What it does not provide is a way to morph that GUI while it is running.
#
# The Client_To_Guiwindow.pause_gui() + Client_To_Guiboss.restart_gui()						# Client_To_Guiwindow	is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
# combination is intended to provide a way to completely shut down a
# running gui, pickle the state of all its gadgets, and then revive it
# later, but this is heroic and seems prone to problems due to (e.g.)
# custom widgets failing to preserve and restore state properly or
# environmental changes making the revivification process difficult to
# impossible.  As a result of these anticipated problems, the restart_ui()
# functionality has never really been completed and tested.
#
# The export/import facility implemented here is intended to provide a
# a way to implement limited but useful topological changes in a running
# gui in a clean, safe, client-friendly fashion.
#
# The motivating example is an emacs-style editor wanting to add an
# additional edit pane. (C-x 2 or C-x 3 functionality.)
#
# The design idea is to allow client code to ask for an abstracted
# Xi_Widget of guiboss_imp's current Guipane datastructure,							# Guipane		is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
# edit it, then submit the edited version to guiboss_imp to be
# expanded into a full Guipane to replace the previous one.
#
# The intended advantages of this approach are:
#
#  o  The abstracted Xi_Widget version will be stripped of all mutable
#     values of interest to guiboss_imp, eliminating risk of client code
#     doing weird things to guiboss_imp's state behind its back, producing
#     hard-to-debug problems.
#
#  o  The abstracted Xi_Widget version will be easier for client code
#     to process, and less likely to change (breaking client code) than
#     the full Guipane datastructure.
#
#  o  The client-code rewrites of the Xi_Widget version will meet all
#     anticipated client needs for moving widgets around on a pane,
#     without allowing topological changes in the current popup-window
#     hierarchy which would introduce additional implementation difficulty
#     no good purpose.
#
#  o  The Xi_Widget version allows introducing new gadgets into the running
#     GUI via an escape mechanism (Xi_Widget.XI_GUIPLAN) allowing inclusion
#     of raw Guiplan nodes or subtrees.
#
#  o  Widgets can be deleted from the running gui just by eliding them from
#     the Xi_Widget tree before returning the result to guiboss_imp.
#
#  o  The export-import sequence provides guiboss_imp the opportunity to
#     thoroughly validate the replacement Xi_Widget tree before installing
#     it as the replacement running gui.



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\|### \\)"		 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.

