## translate-guipane-to-guipith.pkg
#
# Editing running GUIs.
# For motivation, overview and background see Note[1] at bottom of file.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;							# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    include package   threadkit;							# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package evt =  gui_event_types;							# gui_event_types			is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;							# gui_event_to_string			is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;							# guiboss_types				is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;					# windowsystem_to_xevent_router		is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;							# gui_displaylist			is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;						# standard_prettyprint_mill		is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;							# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package bt  =  gui_to_sprite_theme;							# gui_to_sprite_theme			is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
    package ct  =  gui_to_object_theme;							# gui_to_object_theme			is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
    package wt  =  widget_theme;							# widget_theme				is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

    package boi =  spritespace_imp;							# spritespace_imp			is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;							# objectspace_imp			is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;							# widgetspace_imp			is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;							# guiboss_to_guishim			is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2s =  spritespace_to_sprite;						# spritespace_to_sprite			is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;						# objectspace_to_object			is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2s =  sprite_to_spritespace;						# sprite_to_spritespace			is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2o =  object_to_objectspace;						# object_to_objectspace			is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg

#   package s2g =   space_to_gui;							# space_to_gui				is from   src/lib/x-kit/widget/gui/space-to-gui.pkg
    package g2p =  gadget_to_pixmap;							# gadget_to_pixmap			is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package frm =  frame;								# frame					is from   src/lib/x-kit/widget/leaf/frame.pkg

#   package iul =  issue_unique_look_id;						# issue_unique_look_id			is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    package im  =  int_red_black_map;							# int_red_black_map			is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;							# int_red_black_set			is from   src/lib/src/int-red-black-set.pkg

    package r8  =  rgb8;								# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;									# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;								# geometry2d				is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;							# geometry2d_junk			is from   src/lib/std/2d/geometry2d-junk.pkg

    package ebi =  editboss_imp;							# editboss_imp				is from   src/lib/x-kit/widget/edit/editboss-imp.pkg
    package e2g =  editboss_to_guiboss;							# editboss_to_guiboss			is from   src/lib/x-kit/widget/edit/editboss-to-guiboss.pkg

    package t2t =  texteditor_to_textbuffer;						# texteditor_to_textbuffer		is from   src/lib/x-kit/widget/edit/texteditor-to-textbuffer.pkg
#   package tbi =  textbuffer_imp;							# textbuffer_imp			is from   src/lib/x-kit/widget/edit/textbuffer-imp.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;								# log					is from   src/lib/std/src/log.pkg
herein

    package translate_guipane_to_guipith
    :       Translate_Guipane_To_Guipith						# Translate_Guipane_To_Guipith		is from   src/lib/x-kit/widget/gui/translate-guipane-to-guipith.api
    {
	fun guipith__to__guipane
	      (
		guipith:		gt::Guipith,
		topwindow_info:		gt::Topwindow_Info,
		guipane:		gt::Guipane
	      )
	    :
	    gt::Guipane
	    =
	    {   xi_widget = guipith;											# At present gt::guipith is just a synonym for gt::Xi_Widget with no extra baggage included.
		#
		rg_widget
		    =
		    do_xi_widget  xi_widget;

# XXX BUGGO FIXME Completely bogus value pending actual coding here:
		guipane;
	    }
	where
# XXX BUGGO FIXME This fn is current totally bogus pending actual coding here:
	    fun do_xi_widget  (xi_widget: gt::Xi_Widget):   gt::Rg_Widget
		=
		case xi_widget
		    #
		    gt::XI_ROW  { id:		Id,
				  widgets:	List(  gt::Xi_Widget )
				}
			=>
			{   widgets =  map  do_xi_widget  widgets;
			    #
			    widget_layout_hint = REF gt::default_widget_layout_hint;

			    gt::RG_ROW  { id,
					  widgets,
					  widget_layout_hint,
					  site			=> REF  g2d::box::zero						# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					};
			};

		    gt::XI_COL  { id:			Id,
				  widgets:		List( gt::Xi_Widget )
				}
			=>
			{   widgets =  map  do_xi_widget  widgets;
			    #
			    widget_layout_hint = REF gt::default_widget_layout_hint;

			    gt::RG_COL  { id,
					  widgets,
					  widget_layout_hint,
					  site			=> REF  g2d::box::zero						# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					};
			};

		    gt::XI_GRID { widgets:		List( List( gt::Xi_Widget ) )
				}
			=>
			{   widgets =   map  do_row  widgets
					where
					    fun do_row (widgets: List(gt::Xi_Widget))
						=
						(map  do_xi_widget  widgets);

					end;
			    widget_layout_hint = REF gt::default_widget_layout_hint;

			    #
			    gt::RG_GRID { widgets,
					  widget_layout_hint,
					  site			=> REF  g2d::box::zero						# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					};
			};


		    gt::XI_SCROLLPORT
			    { xi_widget:			gt::Xi_Widget,
#			      gadget_to_rw_pixmap:		g2p::Gadget_To_Rw_Pixmap,					# This is the pixmap visible through the scrollport. It holds a full image of above 'widget' tree.
			      upperleft:			g2d::Point,							# Upperleft of view's subwindow_or_view in scrollport coordinates, used for scrolling pixmap in scrollport.
#			      subwindow_or_view:		Subwindow_Or_View,						# This is the parent pixmap holding the scrollport.
			      scroller:				gt::Scroller,
			      callback:				gt::Scroller_Callback						# This is how we pass our Scroller to app client code, which basically lets it set 'pixmap_upperleft' above.
			    }
			=>
			{
			    gt::RG_NULL_WIDGET;

#			    rg_widget =   do_xi_widget  xi_widget;
#
#			    RG_SCROLLPORT
#			      {													# Here we provide support for widgets visible through a scrollable scrollport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
#			        rg_widget:			Rg_Widget,							# Tree of widgets partially visible in scrollport.
#			        gadget_to_rw_pixmap:		g2p::Gadget_To_Rw_Pixmap,					# This is the pixmap visible through the scrollport. It holds a full image of above 'widget' tree.
#			        upperleft:			Ref(g2d::Point),						# Upperleft of view's subwindow_or_view in scrollport coordinates, used for scrolling pixmap in scrollport.
#			        subwindow_or_view:		Subwindow_Or_View,						# This is the parent pixmap holding the scrollport.
#			        scroller:			Scroller,
#			        callback:			Scroller_Callback,						# This is how we pass our Scroller to app client code, which basically lets it set 'pixmap_upperleft' above.
#			        site:				Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
#			      };
			};

		    gt::XI_TABPORT
			    { widgets:			List( gt::Xi_Widget )
			    }
			=>
			gt::RG_NULL_WIDGET;

		    gt::XI_FRAME
			    {
			      frame_widget:		gt::Xi_Widget,									# Widget which will draw the frame surround.
			      widget:			gt::Xi_Widget									# Widget-tree to draw surrounded by frame.
			    }
			=>
			gt::RG_NULL_WIDGET;

		    gt::XI_WIDGET r
			=>
			gt::RG_NULL_WIDGET;

		    #
		    gt::XI_OBJECTSPACE  objectspace
			=>
			gt::RG_NULL_WIDGET;

		    gt::XI_SPRITESPACE  spritespace
			=>
			gt::RG_NULL_WIDGET;

		    gt::XI_NULL_WIDGET
			=>
			gt::RG_NULL_WIDGET;

		    gt::XI_GUIPLAN guiplan
			=>
			gt::RG_NULL_WIDGET;
		esac;
	end;


#	also														# 
#	Xi_Subwindow_Or_View												# 
#	  #														# 
#	  = XI_SUBWINDOW_INFO  Xi_Subwindow_Info									# 
#	  #	
#	  | XI_SCROLLABLE_INFO  												# 
#
#	also
#	Xi_Subwindow_Info												# Used in XI_SUBWINDOW_INFO.
#	  =
#	  { xi_widget:		Xi_Widget,
#	    popups:		List(Xi_Subwindow_Or_View)								# 
#	  }
#
##	also
##	Xi_Tabview													# 
##	  =
##	  { widget:			 Xi_Widget									#
##	  }														#
#
#	also
#	Xi_Row														# Used in RG_ROW
#	  =
#	  {														# A horizontal row of widget widgets.
#	    id:				Id,
#	    widgets:			List( Xi_Widget )								# The list of widgets to be laid out and displayed in this row.
#	  }
#
#	also
#	Xi_Col = Xi_Row
#
#	also
#	Xi_Grid														# Used in RG_GRID
#	  =
#	  {														# A grid widget widgets.
#	    widgets:			List(	List( Xi_Widget )   )
#	  }
#
#	also
#	Xi_Scrollable_View												# 
#	  =
#	  {														# 
#	    xi_widget:			Xi_Widget									# Tree of widgets partially visible in scrollport.
#	  }
#
#	also
#	Xi_Tabbed_Views													# 
#	  =
#	  {														# 
#	    widgets:			List( Xi_Widget )
#	  }
#
#	also
#	Xi_Framed_Widgets
#	  =
#	  {
#	    frame_widget:		Xi_Widget,									# Widget which will draw the frame surround.
#	    widget:			Xi_Widget									# Widget-tree to draw surrounded by frame.
#	  }
#
#	also
#	Xiwidget													# Used in XI_WIDGET
#	  =
#	  {														# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
#	    widget_id:			iul::Id
#	  }
#
#	also
#	Xi_Sprite													# This datatype has only one alternative, but will presumably eventually have multiple variants just like Rg_Object and Rg_Widget, so converting it to a simple type is probably a bad idea.
#	    #
#	    = XI_SPRITE	      {
#				sprite_id:		iul::Id
#			      }
#			
#	also
#	Xi_Object
#	    #
#	    = XI_WIDGETSPACE  {	widgetspace_id:		Id,								# 
#				xi_widget:		Xi_Widget
#			      }
#	    | XI_OBJECT	      {
#				object_id:		iul::Id
#			      }
#
#	also
#	Xi_Widget
#	    #
#	    = XI_ROW		    Xi_Row
#	    | XI_COL		    Xi_Col
#	    #
#	    | XI_GRID		    Xi_Grid										# A rectangular grid of widget widgets.
#	    | XI_SCROLLPORT    Xi_Scrollable_View									# Here we provide support for widgets visible through a scrollable scrollport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
#	    | XI_TABPORT	    Xi_Tabbed_Views									# Here we provide support for selection between alternate views in scrollport.  Actually providing tabs happens at a higher level; here we handle pixmap state maintenance and redraw support.
#	    #
#	    | XI_FRAME		    Xi_Framed_Widgets
#	    | XI_WIDGET	            Xiwidget										# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
#	    #
#	    | XI_OBJECTSPACE	    List(Xi_Object)
#	    | XI_SPRITESPACE	    List(Xi_Sprite)
#	    #
#	    | XI_NULL_WIDGET												# We need this because Guipane requires an Rg_Widget value, and sometimes we may not have anything else.
#	    | XI_GUIPLAN	    Guiplan										# To allow starting up new widgets as part of a running-gui update.
#
#





	fun guipane__to__guipith
	    # 
	    ( guipane: 		gt::Guipane,
	      topwindow_info:	gt::Topwindow_Info
	    )
	    :
	    gt::Xi_Widget
	    =
	    {
		guipane ->    { # fire_end_gun:		Void -> Void,					# Signal which will shut down the GUI impnet.
				    #
				    guiboss_to_widgetspace: 	gt::Guiboss_To_Widgetspace,
				    rg_widget:			gt::Rg_Widget,					# "                                       ".
				    topwindow:			gtg::Guiboss_To_Topwindow,
				    subwindow_info:		gt::Subwindow_Data,				# Holds toplevel gt::SUBWINDOW_DATA for gui.
				    needs_layout_and_redraw:	Ref( Bool )
				    #
				  };

		xi_widget
		    =
		    do_rg_widget  rg_widget;

#		(im::get_or_raise_exception_not_found (*topwindow_info.widgetspace_imps, (id_to_int widgetspace_id)))
#		    ->
#		    { widget_to_guiboss, guiboss_to_widgetspace, endstate_oneshot };	

#		( get_from_oneshot   endstate_oneshot,								# Read final state of widgetspace-imp -- incidentally confirming that it has completed its shutdown.
#		  rg_widget''
#		);

		xi_widget;
	    }

	where
	    fun do_rg_widget  (rg_widget: gt::Rg_Widget)
		=
		case rg_widget
		    #
		    gt::RG_ROW  { id:			Id,
				  widgets:		List(  gt::Rg_Widget ),
				  widget_layout_hint:	Ref( gt::Widget_Layout_Hint ),
				  site:			Ref(g2d::Box)
				}
			=>
			gt::XI_ROW { id,  widgets =>  map  do_rg_widget  widgets  };

		    gt::RG_COL  { id:		Id,
				  widgets:		List( gt::Rg_Widget ),
				  widget_layout_hint:	Ref( gt::Widget_Layout_Hint ),
				  site:			Ref(g2d::Box)
				}
			=>
			gt::XI_COL { id, widgets =>   map  do_rg_widget widgets  };


		    gt::RG_GRID { widgets:		List( List( gt::Rg_Widget ) ),
				  widget_layout_hint:	Ref( gt::Widget_Layout_Hint ),
				  site:			Ref(g2d::Box)
				}
			=>
			gt::XI_GRID { widgets =>  map  do_row  widgets }
			where
			    fun do_row (widgets: List(gt::Rg_Widget))
				=
				(map  do_rg_widget  widgets);

			end;

		    gt::RG_SCROLLPORT
			    {
			      upperleft:	Ref(g2d::Point),							# Origin of view's subwindow_or_view in scrollport coordinates, used for scrolling pixmap in scrollport.
			      scroller:		Ref(gt::Scroller),							# Client-code interface for controlling view_upperleft. This is a ref to resolve mutual recursion issues at creation, not because we expect to update it.
			      callback:		gt::Scroller_Callback,							# This is how we pass our Scroller to app client code, which basically lets it set 'pixmap_upperleft' above.
			      site:		Ref(g2d::Box),								# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

			      rg_widget:		Ref( gt::Rg_Widget ),						# Widget-tree visible in this viewable, which gets rendered onto 'pixmap' here.
			      #												# rg_widget is a Ref not because we intend to change it, but to work around a technical difficulty in guiboss-imp.pkg:do_pg_widget:PG_SCROLLPORT where  viewable_data and rg_widget each want to be created first.
			      pixmap:		g2p::Gadget_To_Rw_Pixmap,						# 
															# 
															#		                      
			      parent_subwindow_or_view:	gt::Subwindow_Or_View						# This can be a SCROLLABLE_INFO if we have a scrollport located on a scrollport.
			    }
			=>
			{
			    xi_widget   =  do_rg_widget  *rg_widget;

#			    pixmap_size =  gadget_to_rw_pixmap.size;
			    #
			    gt::XI_SCROLLPORT
			      { xi_widget,
				upperleft		=> *upperleft,
				scroller		=> *scroller,
				callback		=>  callback
			      };
			};

		    gt::RG_TABPORT    { tabs:		List( gt::Tabbable_Info),
					visible_tab:	Ref( Int ),
					callback:	gt::Tab_Picker_Callback,
					site:		Ref(g2d::Box)
				      }
			=>
			{
			    #
			    gt::XI_TABPORT { widgets =>  map  do_tab  tabs }
				    where
					fun do_tab (tab: gt::Tabbable_Info)
					    =
					    do_rg_widget  tab.rg_widget;
				    end;
			};

		    gt::RG_FRAME
			    {
			      frame_widget:		gt::Rg_Widget,							# Widget which will draw the frame surround.
			      widget:			gt::Rg_Widget,							# Widget-tree to draw surrounded by frame.
			      widget_layout_hint:	Ref( gt::Widget_Layout_Hint ),
			      site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
			    }
			=>
			{   gt::XI_FRAME { frame_widget, widget }							# 
			    where
				fun do_widget (r: gt::Rg_Widget)
				    =
				    ( do_rg_widget  r
				    );

				frame_widget =  do_widget  frame_widget;
				widget       =  do_widget  widget;
			    end;
			};

		    gt::RG_WIDGET r
			=>
			gt::XI_WIDGET { widget_id => r.guiboss_to_widget.id };						# Read and return final state of widget-imp -- incidentally confirming that it has completed its shutdown.


		    #
		    gt::RG_OBJECTSPACE  objectspace
			=>
			do_objectspace  objectspace;

		    gt::RG_SPRITESPACE  spritespace
			=>
			do_spritespace  spritespace;

		    gt::RG_NULL_WIDGET
			=>
			gt::XI_NULL_WIDGET;
		esac


	    also
	    fun do_spritespace r
		=
		{
		    xi_sprites =  do_rg_sprites  r.sprites;
		    #
#		    (im::get_or_raise_exception_not_found (*topwindow_info.spritespace_imps, (id_to_int r.spritespace_id)))
#			->
#			{ guiboss_to_spritespace, sprite_to_spritespace, endstate_oneshot };
#
#		    arg =  get_from_oneshot  endstate_oneshot;

		    gt::XI_SPRITESPACE xi_sprites;
		}

	    also
	    fun do_rg_sprites (sprites:  List (gt::Rg_Sprite))
		=
		{
		    sprites'' = map  do_sprite  sprites
				where
				    fun do_sprite (sprite: gt::Rg_Sprite)
					=
					case sprite
					    #
					    gt::RG_SPRITE r
						=>
						gt::XI_SPRITE { sprite_id => r.guiboss_to_gadget.id };		# Read and return final state of sprite-imp -- incidentally confirming that it has completed its shutdown.
					esac;
				    #
#				    fun do_sprite (sprite': gt::Rg_Sprite)
#					=
#					{   sprite'' = do_sprite'  sprite';
#					    #
#					    sprite'';
#					};

				end;

		    sprites'';
		}


	    also
	    fun do_objectspace r
		=
		{   xi_objects =  do_rg_objects  r.objects;
		    #
#		    (im::get_or_raise_exception_not_found (*topwindow_info.objectspace_imps, (id_to_int r.objectspace_id)))
#			->
#			{ guiboss_to_objectspace, object_to_objectspace, endstate_oneshot };
#
#		    arg =  get_from_oneshot  endstate_oneshot;

		    gt::XI_OBJECTSPACE xi_objects;
		}

	    also
	    fun do_rg_objects (objects:  List (gt::Rg_Object))
		=
		{
		    objects'' = map  do_object  objects
				where
				    fun do_object (object: gt::Rg_Object)
					=
					case object
					    #
					    gt::RG_OBJECT r
						=>
						gt::XI_OBJECT { object_id => r.guiboss_to_gadget.id };		# Read and return final state of object-imp -- incidentally confirming that it has completed its shutdown.

					    gt::RG_WIDGETSPACE
						  { guiboss_to_widgetspace: 	gt::Guiboss_To_Widgetspace,
						    rg_widget:			gt::Rg_Widget
						  }
						=>
						{   xi_widget =  do_rg_widget  rg_widget;
						    #
						    gt::XI_WIDGETSPACE
						      {
							widgetspace_id => guiboss_to_widgetspace.id, 
							xi_widget
						      };
						};
					esac;
				    #
#				    fun do_object (object': gt::Rg_Object)
#					=
#					{   object'' = do_object'  object';
#					    #
#					    object'';
#					};
				end;

		    objects'';
		};												# fun do_rg_objects

	end;
    };
end;

##########################################################################
# Note[1]
#
# The basic Client_To_Guiboss.start_gui() facility provides a simple						# Client_To_Guiboss	is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
# way to start up a running GUI sub/application from a reasonably
# concise Guiplan specification.
#
# What it does not provide is a way to morph that GUI while it is running.
#
# The Client_To_Guiwindow.pause_gui() + Client_To_Guiboss.restart_gui()						# Client_To_Guiwindow	is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
# combination is intended to provide a way to completely shut down a
# running gui, pickle the state of all its gadgets, and then revive it
# later, but this is heroic and seems prone to problems due to (e.g.)
# custom widgets failing to preserve and restore state properly or
# environmental changes making the revivification process difficult to
# impossible.  As a result of these anticipated problems, the restart_ui()
# functionality has never really been completed and tested.
#
# The export/import facility implemented here is intended to provide a
# a way to implement limited but useful topological changes in a running
# gui in a clean, safe, client-friendly fashion.
#
# The motivating example is an emacs-style editor wanting to add an
# additional edit pane. (C-x 2 or C-x 3 functionality.)
#
# The design idea is to allow client code to ask for an abstracted
# Xi_Widget of guiboss_imp's current Guipane datastructure,							# Guipane		is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
# edit it, then submit the edited version to guiboss_imp to be
# expanded into a full Guipane to replace the previous one.
#
# The intended advantages of this approach are:
#
#  o  The abstracted Xi_Widget version will be stripped of all mutable
#     values of interest to guiboss_imp, eliminating risk of client code
#     doing weird things to guiboss_imp's state behind its back, producing
#     hard-to-debug problems.
#
#  o  The abstracted Xi_Widget version will be easier for client code
#     to process, and less likely to change (breaking client code) than
#     the full Guipane datastructure.
#
#  o  The client-code rewrites of the Xi_Widget version will meet all
#     anticipated client needs for moving widgets around on a pane,
#     without allowing topological changes in the current popup-window
#     hierarchy which would introduce additional implementation difficulty
#     no good purpose.
#
#  o  The Xi_Widget version allows introducing new gadgets into the running
#     GUI via an escape mechanism (Xi_Widget.XI_GUIPLAN) allowing inclusion
#     of raw Guiplan nodes or subtrees.
#
#  o  Widgets can be deleted from the running gui just by eliding them from
#     the Xi_Widget tree before returning the result to guiboss_imp.
#
#  o  The export-import sequence provides guiboss_imp the opportunity to
#     thoroughly validate the replacement Xi_Widget tree before installing
#     it as the replacement running gui.



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\|### \\)"		 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.

