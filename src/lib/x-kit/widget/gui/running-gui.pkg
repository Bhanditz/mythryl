## running-gui.pkg
#
# A stopped_gui is an abstract gui specification.  Client
# code constructs a stopped_gui to describe a desired gui
# and hands it to guiboss-imp to run.
#
# When guiboss::restart_gui is called, guiboss converts
# the stopped_gui it is given into a running_gui tree which
# contains running widget imps and records all runtime-
# relevant information.
#
# When guiboss::stop_gui is called, the runtime running_gui
# is converted back into a stopped_gui which preserves the
# state of the GUI at shutdown time, for possible later
# resumption via guiboss::restart_gui.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


# NB: To avoid circular package dependencies, in this file
#     we avoid referencing any of the *-imp.pkg files,
#     since (some of) them need to refer to us.  To make
#     this work, we moved the *_Arg types -- which we must
#     reference -- out of the *-imp.pkg files.

stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package sg  =  stopped_gui;					# stopped_gui			is from   src/lib/x-kit/widget/gui/stopped-gui.pkg

    # These imps need to be passed Running_Gui instances,
    # so referring directly to them here would create
    # circular package dependencies:
    #
#   package os  =  guiboss_to_bouncespace;			# guiboss_to_bouncespace	is from   src/lib/x-kit/widget/space/bounce/guiboss-to-bouncespace.pkg
#   package cs  =  guiboss_to_canvasspace;			# guiboss_to_canvasspace	is from   src/lib/x-kit/widget/space/canvas/guiboss-to-canvasspace.pkg
#   package ps  =  guiboss_to_packedspace;			# guiboss_to_packedspace	is from   src/lib/x-kit/widget/space/packed/guiboss-to-packedspace.pkg
    
    package b2s =  bouncespace_to_sprite;			# bouncespace_to_sprite		is from   src/lib/x-kit/widget/space/bounce/bouncespace-to-sprite.pkg
    package c2o =  canvasspace_to_object;			# canvasspace_to_object		is from   src/lib/x-kit/widget/space/canvas/canvasspace-to-object.pkg
    package p2w =  packedspace_to_widget;			# packedspace_to_widget		is from   src/lib/x-kit/widget/space/packed/packedspace-to-widget.pkg
    package b2g =  guiboss_to_gadget;				# guiboss_to_gadget		is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg
    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package gws =  guiboss_to_windowsystem;			# guiboss_to_windowsystem	is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package xt  =  xtypes;					# xtypes			is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package s2g =  space_to_gui;				# space_to_gui			is from   src/lib/x-kit/widget/gui/space-to-gui.pkg

    package blh =  bouncespace_layout_hint;			# bouncespace_layout_hint	is from   src/lib/x-kit/widget/space/bounce/bouncespace-layout-hint.pkg
    package clh =  canvasspace_layout_hint;			# canvasspace_layout_hint	is from   src/lib/x-kit/widget/space/canvas/canvasspace-layout-hint.pkg
    package plh =  packedspace_layout_hint;			# packedspace_layout_hint	is from   src/lib/x-kit/widget/space/packed/packedspace-layout-hint.pkg

    # Some abbreviations because line length was getting out of hand below:
    #
    Bs_Layout =  blh::Bouncespace_Layout_Hint;
    Cs_Layout =  clh::Canvasspace_Layout_Hint;
    Ps_Layout =  plh::Packedspace_Layout_Hint; 
    #
    Once(X) = Oneshot_Maildrop(X);

    package gt  = gui_types;					# gui_types			is from   src/lib/x-kit/widget/gui/gui-types.pkg
herein

    package running_gui
    {
	# Storing instances of
	#     os::guiboss_to_bouncespace, 
	#     cs::guiboss_to_canvasspace, 
	# or  ps::guiboss_to_packedspace
	# directly in Running_Gui leads to package circularity,
	# so instead we store their integer id here, and
	# in guiboss-imp.pkg look them up as needed in
	# (respectively):	
	#     bouncespaces
	#     canvasspaces
	#     packedspaces
	# 
	Bouncespace_Id = Id;
	Canvasspace_Id = Id;
	Packedspace_Id = Id;

	Packed_Layout_Hints												# Predigested form of   List( plh::Packedspace_Layout_Hint ); 
	  =
	  { cut:	Null_Or(Float),											# Controls this widget's share of available pixels. We force this to be positive. Default is 1.0 if not specified.
	    min:	Null_Or(Int)
	  };

	Bounce_Widget
	    #
	    = SPRITE	      {
				bouncespace_to_sprite:	b2s::Bouncespace_To_Sprite,					# 
				guiboss_to_gadget:	b2g::Guiboss_To_Gadget,						# 

				endstate_oneshot:	Once( ( 							# The sprite-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
								gt::Bounce_Sprite_Start_Fn,				# 
								Null_Or(Exception)					# saved_sprite_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							    ) )	
			      }
			
	also
	Canvas_Widget
	    #
	    = PACKEDSPACE    {	packedspace_id:		Packedspace_Id,							# A packed space embedded in a canvas, to allow all packedspace widgets to be used also on a canvas.
				packed_widget:		Packed_Widget
			      }
	    | OBJECT	      {
				canvasspace_to_object:	c2o::Canvasspace_To_Object,					# 
				guiboss_to_gadget:	b2g::Guiboss_To_Gadget,						# 

				endstate_oneshot:	Once( (								# The sprite-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
								gt::Canvas_Object_Start_Fn,
								Null_Or(Exception)					# saved_object_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							    ) )

			      }
	also
	Packed_Widget
	    #
	    = ROW	      {												# A horizontal row of packed widgets.
				widgets:		List(								# The list of widgets to be laid out and displayed in this row.
							      { widget:	 	Packed_Widget,				# One widget in the row. Note that it could be a COL or SCROLLABLE_VIEW or such containing multiple subwidgets.
								raw_hints:	List(plh::Packedspace_Layout_Hint),	# Layout hints provided by client code.
								cooked_hints:	Packed_Layout_Hints			# Digested version of previous.
							      }								#
							    ),
				pixels_high_min: 	Ref(Int),							# Minimum            vertical   pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				pixels_wide_min: 	Ref(Int),							# Minimum            horizontal pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				#
				pixels_high_cut: 	Ref(Float),							# Share of remaining vertical   pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				pixels_wide_cut: 	Ref(Float),							# Share of remaining horizontal pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				#
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }

	    | COL	      {												# A vertical column of packed widgets.
				widgets:		List(								# The list of widgets to be laid out and displayed in this column.
							      { widget:		Packed_Widget,				# One widget in the column. Note that it could be a ROW or SCROLLABLE_VIEW or such containing multiple subwidgets.
								raw_hints:	List(plh::Packedspace_Layout_Hint),	# Layout hints provided by client code.
								cooked_hints:	Packed_Layout_Hints			# Digested version of next
							      }								#
							    ),
				pixels_high_min: 	Ref(Int),							# Minimum            vertical   pixels to allocate for this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				pixels_wide_min: 	Ref(Int),							# Minimum            horizontal pixels to allocate for this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				#
				pixels_high_cut: 	Ref(Float),							# Share of remaining vertical   pixels to allocate to  this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				pixels_wide_cut: 	Ref(Float),							# Share of remaining horizontal pixels to allocate to  this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				#
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }

	    | SCROLLABLE_VIEW {												# Here we provide support for widgets visible through a scrollable viewport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
				widget:			Packed_Widget,							# Tree of widgets partially visible in viewport.
				gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,					# This is the pixmap visible through the viewport. It holds a full image of above 'widget' tree.
				view_origin:		Ref(g2d::Point),						# Origin of view's backing_pixmap in viewport coordinates, used for scrolling pixmap in viewport.
				backing_pixmap:		s2g::Backing_Pixmap,						# This is the parent pixmap holding the viewport.
				scroller:		gt::Viewport_Scroller,
				callback:		gt::Viewport_Scroller_Callback,					# This is how we pass our Viewport_Scroller to app client code, which basically lets it set 'pixmap_origin' above.
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }

	    | TABBED_VIEWS    {												# Here we provide support for selection between alternate views in viewport.  Actually providing tabs happens at a higher level; here we handle pixmap state maintenance and redraw support.
				pixmap_size:		g2d::Size,							# Size of alternate pixmaps visible in viewport.  We require them to all be the same size; we intend that the viewport be the same size.
				widgets:		List(								# This record holds one of the alternate views which may be made visible in the viewport.  *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST! *** 
							      { widget:			Packed_Widget,			# Tree of widgets visible in this tab.
								gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,	# This pixmap holds the current visible state of the above widget-tree.
								backing_pixmap:		s2g::Backing_Pixmap		# This is the parent pixmap holding the viewport through which we are visible (when we're visible).
							      }								# This record is type Tabview; we can't use that name here because records and datatypes cannot be mutually recursive.
							    ),
				visible_widget:		Ref (								# Which of 'widgets' is currently visible?  This refcell holds one element from 'widgets';  it supports switching between the tabbed views.
							      { widget:			Packed_Widget,			#
								gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,	#
								backing_pixmap:		s2g::Backing_Pixmap		# 
							      }								# This record is type Tabview; we can't use that name here because records and datatypes cannot be mutually recursive.
							    ),
				callback:		gt::Tabbed_View_Picker_Callback,				# This is how we pass our Tabbed_View_Picker to app client code, which basically lets it set 'visible_widget' above.
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }
	    #
	    | WIDGET	      {												# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg
				guiboss_to_gadget:	b2g::Guiboss_To_Gadget,						# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/gui/guiboss-imp.pkg
				packedspace_to_widget:	p2w::Packedspace_To_Widget,					# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

				endstate_oneshot:	Once( (								# The widget-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
								gt::Packed_Widget_Start_Fn,				#
								Null_Or(Exception)					# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							    ) ),
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }

	    #
	    | CANVASSPACE     {	canvasspace_id:		Canvasspace_Id,							# guiboss-imp indexes this value into *canvas_stuff to obtain (e.g.) a Guiboss_To_Canvasspace port to the canvasspace-imp.
				widgets:		List ((List(Cs_Layout), Canvas_Widget)),			# The list of widgets to be drawn on the canvas. These can be placed arbitrarily, including possible overlaps.
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }
	    | BOUNCESPACE     { bouncespace_id:		Bouncespace_Id,							# guiboss-imp indexes this value into *bounce_stuff to obtain (e.g.) a Guiboss_To_Bouncespace port to the bouncespace-imp.
				widgets:		List ((List(Bs_Layout), Bounce_Widget)),			# The list of widgets to be drawn on the bouncespace. These can be placed arbitrarily.
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }
	    #
	    | NULL_PACKED_WIDGET											# We need this because Running_Gui requires a Packed_Widget value, and sometimes we may not have anything else.
	    ;


	Running_Gui =	      {	fire_end_gun:		Void -> Void,							# Calling this fn will cause all state and look imps in the gui to exit, saving their state to their oneshots.
				packedspace_id:		Packedspace_Id,							# guiboss-imp indexes this value into *packed_stuff to obtain (e.g.) a Guiboss_To_Packedspace port to the packedspace-imp.
				packed_widget:		Packed_Widget,							# The widget (or more commonly, tree of widgets) managed by the gui-tree's toplevel packedspace-imp.
				topwindow:		gws::Guiboss_To_Topwindow,					# The topwindow on which to draw our widgets.
				topwindow_pixmap:	s2g::Backing_Pixmap						# Holds toplevel s2g::TOPWINDOW_PIXMAP for gui.
			      };



	Row_Widget													# This is intended to match the ROW declaration above.
	  =														# We can't use this definition there because plain types cannot be mutually recursive.
	  { widget:	 	Packed_Widget,										#
	    cooked_hints:	Packed_Layout_Hints,									# Digested version of next
	    raw_hints:		List(plh::Packedspace_Layout_Hint)							# Layout hints provided by client code.
	  };														#

	Col_Widget													# This is intended to match the COL declaration above.
	  =														# We can't use this definition there because plain types cannot be mutually recursive.
	  { widget:		Packed_Widget,										#
	    cooked_hints:	Packed_Layout_Hints,									# Digested version of next
	    raw_hints:		List(plh::Packedspace_Layout_Hint)							# Layout hints provided by client code.
	  };														#

	Tabview														# Something visible in a Packed_Widget.TABBED_VIEWS.  It is convenient to have a name for this type.
	  =
	  { widget:		 Packed_Widget,										#
	    gadget_to_rw_pixmap: g2p::Gadget_To_Rw_Pixmap,
	    backing_pixmap:	 s2g::Backing_Pixmap									# 
	  }														#
	  ;

															# This section gives names to the implicit record types above used by ROW, COL ...
															# It really sucks that records cannot be included in recursive definitions.
	Row
	  =
	  {														# A horizontal row of packed widgets.
	    widgets:		List(											# The list of widgets to be laid out and displayed in this row.
					  { widget:	 	Packed_Widget,						# One widget in the row. Note that it could be a COL or SCROLLABLE_VIEW or such containing multiple subwidgets.
					    raw_hints:	List(plh::Packedspace_Layout_Hint),				# Layout hints provided by client code.
					    cooked_hints:	Packed_Layout_Hints					# Digested version of previous.
					  }										#
					),
	    pixels_high_min: 	Ref(Int),										# Minimum            vertical   pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    pixels_wide_min: 	Ref(Int),										# Minimum            horizontal pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    #
	    pixels_high_cut: 	Ref(Float),										# Share of remaining vertical   pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    pixels_wide_cut: 	Ref(Float),										# Share of remaining horizontal pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    #
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };

	Col
	  =
	  {														# A vertical column of packed widgets.
	    widgets:		List(											# The list of widgets to be laid out and displayed in this column.
					  { widget:		Packed_Widget,						# One widget in the column. Note that it could be a ROW or SCROLLABLE_VIEW or such containing multiple subwidgets.
					    raw_hints:	List(plh::Packedspace_Layout_Hint),				# Layout hints provided by client code.
					    cooked_hints:	Packed_Layout_Hints					# Digested version of next
					  }										#
					),
	    pixels_high_min: 	Ref(Int),										# Minimum            vertical   pixels to allocate for this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    pixels_wide_min: 	Ref(Int),										# Minimum            horizontal pixels to allocate for this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    #
	    pixels_high_cut: 	Ref(Float),										# Share of remaining vertical   pixels to allocate to  this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    pixels_wide_cut: 	Ref(Float),										# Share of remaining horizontal pixels to allocate to  this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    #
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };


	Scrollable_View
	  =
	  {														# Here we provide support for widgets visible through a scrollable viewport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
	    widget:			Packed_Widget,									# Tree of widgets partially visible in viewport.
	    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,							# This is the pixmap visible through the viewport. It holds a full image of above 'widget' tree.
	    view_origin:		Ref(g2d::Point),								# Origin of view's backing_pixmap in viewport coordinates, used for scrolling pixmap in viewport.
	    backing_pixmap:		s2g::Backing_Pixmap,								# This is the parent pixmap holding the viewport.
	    scroller:			gt::Viewport_Scroller,
	    callback:			gt::Viewport_Scroller_Callback,							# This is how we pass our Viewport_Scroller to app client code, which basically lets it set 'pixmap_origin' above.
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };

	Tabbed_Views
	  =
	  {														# Here we provide support for selection between alternate views in viewport.  Actually providing tabs happens at a higher level; here we handle pixmap state maintenance and redraw support.
	    pixmap_size:		g2d::Size,									# Size of alternate pixmaps visible in viewport.  We require them to all be the same size; we intend that the viewport be the same size.
	    widgets:		List(											# This record holds one of the alternate views which may be made visible in the viewport.  *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST! *** 
					  { widget:			Packed_Widget,					# Tree of widgets visible in this tab.
					    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,			# This pixmap holds the current visible state of the above widget-tree.
					    backing_pixmap:		s2g::Backing_Pixmap				# This is the parent pixmap holding the viewport through which we are visible (when we're visible).
					  }										# This record is type Tabview; we can't use that name here because records and datatypes cannot be mutually recursive.
					),
	    visible_widget:		Ref (										# Which of 'widgets' is currently visible?  This refcell holds one element from 'widgets';  it supports switching between the tabbed views.
					  { widget:			Packed_Widget,					#
					    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,			#
					    backing_pixmap:		s2g::Backing_Pixmap				# 
					  }										# This record is type Tabview; we can't use that name here because records and datatypes cannot be mutually recursive.
					),
	    callback:		gt::Tabbed_View_Picker_Callback,							# This is how we pass our Tabbed_View_Picker to app client code, which basically lets it set 'visible_widget' above.
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };

	Widget
	  =
	  {														# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg
	    guiboss_to_gadget:		b2g::Guiboss_To_Gadget,								# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/gui/guiboss-imp.pkg
	    packedspace_to_widget:	p2w::Packedspace_To_Widget,							# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

	    endstate_oneshot:	Once( (											# The widget-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
					    gt::Packed_Widget_Start_Fn,							#
					    Null_Or(Exception)								# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
					) ),
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };

															# We'll eventually want canvas and bounce stuff here, but that isn't really operational yet.

	fun packed_widget_site (packed_widget: Packed_Widget)
	    =
	    case packed_widget
		#
		ROW r			=>  *r.site;
		COL r			=>  *r.site;
		SCROLLABLE_VIEW r	=>  *r.site;
		TABBED_VIEWS r		=>  *r.site;
		WIDGET r		=>  *r.site;
		CANVASSPACE r		=>  *r.site;
		BOUNCESPACE r		=>  *r.site;
		NULL_PACKED_WIDGET	=>  g2d::box::zero;
	    esac;


	Running_Gui_Postorder_Apply_Option										# The following running_gui_postorder_apply() facility allows clients to iterate over nodes in a Running_Gui tree without having to write out the whole recursion.
	  #
	  = ROW_FN		(Row		 -> Void)								# Call this fn on ROW             nodes in Running_Gui. Defaults to null fn.
	  | COL_FN		(Col		 -> Void)								# Call this fn on COL             nodes in Running_Gui. Defaults to null fn.
	  | SCROLLABLE_VIEW_FN	(Scrollable_View -> Void)								# Call this fn on SCROLLABLE_VIEW nodes in Running_Gui. Defaults to null fn.
	  | TABBED_VIEWS_FN	(Tabbed_Views	 -> Void)								# Call this fn on TABBED_VIEWS    nodes in Running_Gui. Defaults to null fn.
	  | WIDGET_FN		(Widget		 -> Void)								# Call this fn on WIDGET          nodes in Running_Gui. Defaults to null fn.
	  | DO_INVISIBLE_VIEWS  Bool											# Defaults to TRUE.  If FALSE, recursion will not enter de-selected views in a TABBED_VIEWS node.
	  ;

	fun running_gui_postorder_apply
	      (
		running_gui:	Running_Gui,
		options:	List( Running_Gui_Postorder_Apply_Option )
	      )
	    =
	    do_packed_widget  running_gui.packed_widget
	    where

		fun process_options  (options:  List(Running_Gui_Postorder_Apply_Option))
		    =
		    {   null_fn = (\\ (x: X) = ());
			#
			my_row_fn			=  REF  null_fn;
			my_col_fn			=  REF  null_fn;
			my_scrollable_view_fn		=  REF  null_fn;
			my_tabbed_views_fn		=  REF  null_fn;
			my_widget_fn			=  REF  null_fn;
			my_do_invisible_views		=  REF  TRUE;

			apply  do_option  options
			where
			    fun do_option (ROW_FN			fn) =>  my_row_fn			:=  fn;
				do_option (COL_FN			fn) =>  my_col_fn			:=  fn;
				do_option (SCROLLABLE_VIEW_FN		fn) =>  my_scrollable_view_fn		:=  fn;
				do_option (TABBED_VIEWS_FN		fn) =>  my_tabbed_views_fn		:=  fn;
				do_option (WIDGET_FN			fn) =>  my_widget_fn			:=  fn;
				do_option (DO_INVISIBLE_VIEWS		b ) =>  my_do_invisible_views		:=  b ;
			    end;
			end;

			{ row_fn			=>  *my_row_fn,
			  col_fn			=>  *my_col_fn,
			  scrollable_view_fn		=>  *my_scrollable_view_fn,
			  tabbed_views_fn		=>  *my_tabbed_views_fn,
			  widget_fn			=>  *my_widget_fn,
			  do_invisible_views		=>  *my_do_invisible_views
			};
		    };

		options =  process_options  options;

		fun do_packed_widget (packed_widget: Packed_Widget)
		    =
		    case packed_widget
			#
			ROW row =>	{   apply do_widget row.widgets
						where
						    fun do_widget (row_widget: Row_Widget)
							=
							do_packed_widget row_widget.widget;
						end;

					    options.row_fn row;
					};

			COL col =>	{   apply do_widget col.widgets
						where
						    fun do_widget (col_widget: Col_Widget)
							=
							do_packed_widget col_widget.widget;
						end;

					    options.col_fn  col;
					};

			SCROLLABLE_VIEW view
			    =>		{   do_packed_widget  view.widget;
					    #
					    options.scrollable_view_fn  view;
					};

			TABBED_VIEWS views
			    =>		{   fun do_tabview (tabview: Tabview)
						=
						do_packed_widget tabview.widget;

					    if options.do_invisible_views
						#
						apply do_tabview views.widgets;
					    else
						do_tabview *views.visible_widget;
					    fi;

					    options.tabbed_views_fn views;
					};

			WIDGET widget
			    =>		{   options.widget_fn widget;
					};

			CANVASSPACE space
			    =>		{   ();											# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
					};
			BOUNCESPACE space
			    =>		{   ();											# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
					};
			NULL_PACKED_WIDGET
			    =>		{   ();
					};
		    esac;
	    end;
    };

end;






##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
