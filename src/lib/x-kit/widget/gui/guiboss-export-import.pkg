## guiboss-export-import.pkg
#
# Editing running GUIs.
# For motivation, overview and background see Note[1] at bottom of file.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;							# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    include package   threadkit;							# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package evt =  gui_event_types;							# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;							# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;							# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;					# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;							# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;						# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;							# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package bt  =  gui_to_sprite_theme;							# gui_to_sprite_theme		is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
    package ct  =  gui_to_object_theme;							# gui_to_object_theme		is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
    package wt  =  widget_theme;							# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

    package boi =  spritespace_imp;							# spritespace_imp		is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;							# objectspace_imp		is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;							# widgetspace_imp		is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;							# guiboss_to_guishim		is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2s =  spritespace_to_sprite;						# spritespace_to_sprite		is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;						# objectspace_to_object		is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg
    package p2w =  widgetspace_to_widget;						# widgetspace_to_widget		is from   src/lib/x-kit/widget/space/widget/widgetspace-to-widget.pkg

    package s2s =  sprite_to_spritespace;						# sprite_to_spritespace		is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2o =  object_to_objectspace;						# object_to_objectspace		is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg
    package w2w =  widget_to_widgetspace;						# widget_to_widgetspace		is from   src/lib/x-kit/widget/space/widget/widget-to-widgetspace.pkg

#   package s2g =   space_to_gui;							# space_to_gui			is from   src/lib/x-kit/widget/gui/space-to-gui.pkg
    package g2p =  gadget_to_pixmap;							# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package frm =  frame;								# frame				is from   src/lib/x-kit/widget/leaf/frame.pkg

#   package iul =  issue_unique_look_id;						# issue_unique_look_id		is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    package im  =  int_red_black_map;							# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;							# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg

    package r8  =  rgb8;								# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;									# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;								# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;							# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

    package ebi =  editboss_imp;							# editboss_imp			is from   src/lib/x-kit/widget/edit/editboss-imp.pkg
    package e2g =  editboss_to_guiboss;							# editboss_to_guiboss		is from   src/lib/x-kit/widget/edit/editboss-to-guiboss.pkg

    package t2t =  texteditor_to_textbuffer;						# texteditor_to_textbuffer	is from   src/lib/x-kit/widget/edit/texteditor-to-textbuffer.pkg
#   package tbi =  textbuffer_imp;							# textbuffer_imp		is from   src/lib/x-kit/widget/edit/textbuffer-imp.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;								# log				is from   src/lib/std/src/log.pkg
herein

    package guiboss_export_import
    :       Guiboss_Export_Import							# Guiboss_Export_Import		is from   src/lib/x-kit/widget/gui/guiboss-export-import.api
    {
	fun running_gui__to__export_gui
	    # 
	    ( running_gui: 	gt::Running_Gui,
	      topwindow_info:	gt::Topwindow_Info
	    )
	    :
	    gt::Xi_Widget
	    =
	    {
		running_gui ->    { fire_end_gun:		Void -> Void,					# Signal which will shut down the GUI impnet.
				    #
				    widgetspace_id:		gt::Widgetspace_Id,				# Runtime GUI state synthesized locally per client spec.
				    rg_widget:			gt::Rg_Widget,					# "                                       ".
				    topwindow:			gtg::Guiboss_To_Topwindow,
				    subwindow_info:		gt::Subwindow_Or_Viewport_Info,			# Holds toplevel gt::SUBWINDOW_INFO for gui.
				    #
				    gadget_imps_for_gui:	gt::Gadget_Imps,				# Holds our gt::Gadget_Imp_Info        instances for this running gui (i.e., base gui for topwindow, else one of the popup guis for that topwindow).
				    spritespace_imps_for_gui:	gt::Spritespace_Imps,				# Holds our gt::Guiboss_To_Spritespace instances for this running gui (i.e., base gui for topwindow, else one of the popup guis for that topwindow).
				    objectspace_imps_for_gui:	gt::Objectspace_Imps,				# Holds our gt::Guiboss_To_Objectspace instances for this running gui (i.e., base gui for topwindow, else one of the popup guis for that topwindow).
				    widgetspace_imps_for_gui:	gt::Widgetspace_Imps				# Holds our gt::Guiboss_To_Widgetspace instances for this running gui (i.e., base gui for topwindow, else one of the popup guis for that topwindow).
				  };

		xi_widget
		    =
		    do_rg_widget  rg_widget;

#		(im::get_or_raise_exception_not_found (*topwindow_info.widgetspace_imps, (id_to_int widgetspace_id)))
#		    ->
#		    { widget_to_widgetspace, guiboss_to_widgetspace, endstate_oneshot };	

#		( get_from_oneshot   endstate_oneshot,								# Read final state of widgetspace-imp -- incidentally confirming that it has completed its shutdown.
#		  rg_widget''
#		);

		xi_widget;
	    }

	where
	    fun do_rg_widget  (rg_widget: gt::Rg_Widget)
		=
		case rg_widget
		    #
		    gt::RG_ROW  { id:		Id,
				  widgets:		List(  gt::Rg_Widget ),
				  pixels_high_min:	Ref(Int),
				  pixels_wide_min:	Ref(Int),
				  #
				  pixels_high_cut:	Ref(Float),
				  pixels_wide_cut:	Ref(Float),
				  #
				  site:			Ref(g2d::Box)
				}
			=>
			gt::XI_ROW { id,  widgets =>  map  do_rg_widget  widgets  };

		    gt::RG_COL  { id:		Id,
				  widgets:		List( gt::Rg_Widget ),
				  pixels_high_min:	Ref(Int),
				  pixels_wide_min:	Ref(Int),
				  #
				  pixels_high_cut:	Ref(Float),
				  pixels_wide_cut:	Ref(Float),
				  #
				  site:			Ref(g2d::Box)
				}
			=>
			gt::XI_COL { id, widgets =>   map  do_rg_widget widgets  };


		    gt::RG_GRID { widgets:		List( List( gt::Rg_Widget ) ),
				  pixels_high_min:	Ref(Int),
				  pixels_wide_min:	Ref(Int),
				  #
				  pixels_high_cut:	Ref(Float),
				  pixels_wide_cut:	Ref(Float),
				  #
				  site:			Ref(g2d::Box)
				}
			=>
			gt::XI_GRID { widgets =>  map  do_row  widgets }
			where
			    fun do_row (widgets: List(gt::Rg_Widget))
				=
				(map  do_rg_widget  widgets);

			end;

		    gt::RG_SCROLLABLE_VIEW
			    { rg_widget:			gt::Rg_Widget,
			      gadget_to_rw_pixmap:		g2p::Gadget_To_Rw_Pixmap,
			      view_origin:			Ref(g2d::Point),					# Origin of subwindow_or_viewport_info in viewport coordinates, used for scrolling pixmap in viewport.
			      scroller:			gt::Viewport_Scroller,
			      callback:			gt::Viewport_Scroller_Callback,
			      subwindow_or_viewport_info:	gt::Subwindow_Or_Viewport_Info,				# 
			      site:				Ref(g2d::Box)
			    }
			=>
			{	callback NULL;										# Tell app code that our viewport_scroller is no longer active.
			    #
			    xi_widget      =  do_rg_widget  rg_widget;

#			    pixmap_size =  gadget_to_rw_pixmap.size;
			    #
			    gt::XI_SCROLLABLE_VIEW { xi_widget };
			};

		    gt::RG_TABBED_VIEWS
			    { callback:		gt::Tabbed_View_Picker_Callback,
			      widgets:		List(gt::Tabview),
			      pixmap_size:		g2d::Size,
			      visible_widget:	Ref(  gt::Tabview ),
    #				  viewport:		Ref(g2d::Box),							# The actual site assigned to the viewport on its home pixmap.  This gets set by   assign_sites_to_all_widgets()   in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
			      site:			Ref(g2d::Box)
			    }
			=>
			{
#   callback NULL;										# Tell app code that our tabbed_view_picker is no longer active.
			    #
			    gt::XI_TABBED_VIEWS { widgets =>  map  do_widget  widgets }
				    where
					fun do_widget { widget: 			gt::Rg_Widget,
							gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,	# Should we delete this at this point?  If not, when does it get recycled?
							subwindow_or_viewport_info:	gt::Subwindow_Or_Viewport_Info	# 
						      }

					    =
					    do_rg_widget  widget;
				    end;
			};

		    gt::RG_FRAME
			    {
			      frame_widget:		gt::Rg_Widget,						# Widget which will draw the frame surround.
			      widget:		gt::Rg_Widget,							# Widget-tree to draw surrounded by frame.
			      #
			      pixels_high_min: 	Ref(Int),							# Minimum            vertical   pixels to allocate for this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
			      pixels_wide_min:	Ref(Int),							# Minimum            horizontal pixels to allocate for this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
			      #
			      pixels_high_cut: 	Ref(Float),							# Share of remaining vertical   pixels to allocate to  this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
			      pixels_wide_cut: 	Ref(Float),							# Share of remaining horizontal pixels to allocate to  this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
			      #
			      site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
			    }
			=>
			{   gt::XI_FRAME { frame_widget, widget }								# 
			    where
				fun do_widget (r: gt::Rg_Widget)
				    =
				    ( do_rg_widget  r
				    );

				frame_widget =  do_widget  frame_widget;
				widget       =  do_widget  widget;
			    end;
			};

		    gt::RG_WIDGET r
			=>
			gt::XI_WIDGET { widget_id => r.guiboss_to_gadget.id };					# Read and return final state of widget-imp -- incidentally confirming that it has completed its shutdown.


		    #
		    gt::RG_OBJECTSPACE  objectspace
			=>
			do_objectspace  objectspace;

		    gt::RG_SPRITESPACE  spritespace
			=>
			do_spritespace  spritespace;

		    gt::RG_NULL_WIDGET
			=>
			gt::XI_NULL_WIDGET;
		esac


	    also
	    fun do_spritespace r
		=
		{
		    xi_sprites =  do_rg_sprites  r.sprites;
		    #
#		    (im::get_or_raise_exception_not_found (*topwindow_info.spritespace_imps, (id_to_int r.spritespace_id)))
#			->
#			{ guiboss_to_spritespace, sprite_to_spritespace, endstate_oneshot };
#
#		    arg =  get_from_oneshot  endstate_oneshot;

		    gt::XI_SPRITESPACE xi_sprites;
		}

	    also
	    fun do_rg_sprites (sprites:  List (gt::Rg_Sprite))
		=
		{
		    sprites'' = map  do_sprite  sprites
				where
				    fun do_sprite (sprite: gt::Rg_Sprite)
					=
					case sprite
					    #
					    gt::RG_SPRITE r
						=>
						gt::XI_SPRITE { sprite_id => r.guiboss_to_gadget.id };		# Read and return final state of sprite-imp -- incidentally confirming that it has completed its shutdown.
					esac;
				    #
#				    fun do_sprite (sprite': gt::Rg_Sprite)
#					=
#					{   sprite'' = do_sprite'  sprite';
#					    #
#					    sprite'';
#					};

				end;

		    sprites'';
		}


	    also
	    fun do_objectspace r
		=
		{   xi_objects =  do_rg_objects  r.objects;
		    #
#		    (im::get_or_raise_exception_not_found (*topwindow_info.objectspace_imps, (id_to_int r.objectspace_id)))
#			->
#			{ guiboss_to_objectspace, object_to_objectspace, endstate_oneshot };
#
#		    arg =  get_from_oneshot  endstate_oneshot;

		    gt::XI_OBJECTSPACE xi_objects;
		}

	    also
	    fun do_rg_objects (objects:  List (gt::Rg_Object))
		=
		{
		    objects'' = map  do_object  objects
				where
				    fun do_object (object: gt::Rg_Object)
					=
					case object
					    #
					    gt::RG_OBJECT r
						=>
						gt::XI_OBJECT { object_id => r.guiboss_to_gadget.id };		# Read and return final state of object-imp -- incidentally confirming that it has completed its shutdown.

					    gt::RG_WIDGETSPACE
						  { widgetspace_id:	gt::Widgetspace_Id,
						    rg_widget:		gt::Rg_Widget
						  }
						=>
						{   xi_widget =  do_rg_widget  rg_widget;
						    #
#						    (im::get_or_raise_exception_not_found (*topwindow_info.widgetspace_imps, (id_to_int widgetspace_id)))
#							->
#							{ widget_to_widgetspace, guiboss_to_widgetspace, endstate_oneshot };

						    gt::XI_WIDGETSPACE
						      {
							widgetspace_id, 
							xi_widget
						      };
						};
					esac;
				    #
#				    fun do_object (object': gt::Rg_Object)
#					=
#					{   object'' = do_object'  object';
#					    #
#					    object'';
#					};
				end;

		    objects'';
		};												# fun do_rg_objects

	end;
    };
end;

##########################################################################
# Note[1]
#
# The basic Client_To_Guiboss.start_gui() facility provides a simple						# Client_To_Guiboss	is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
# way to start up a running GUI sub/application from a reasonably
# concise Gui_Plan specification.
#
# What it does not provide is a way to morph that GUI while it is running.
#
# The Client_To_Guiwindow.pause_gui() + Client_To_Guiboss.restart_gui()						# Client_To_Guiwindow	is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
# combination is intended to provide a way to completely shut down a
# running gui, pickle the state of all its gadgets, and then revive it
# later, but this is heroic and seems prone to problems due to (e.g.)
# custom widgets failing to preserve and restore state properly or
# environmental changes making the revivification process difficult to
# impossible.  As a result of these anticipated problems, the restart_ui()
# functionality has never really been completed and tested.
#
# The export/import facility implemented here is intended to provide a
# a way to implement limited but useful topological changes in a running
# gui in a clean, safe, client-friendly fashion.
#
# The motivating example is an emacs-style editor wanting to add an
# additional edit pane. (C-x 2 or C-x 3 functionality.)
#
# The design idea is to allow client code to ask for an abstracted
# Xi_Widget of guiboss_imp's current Running_Gui datastructure,							# Running_Gui		is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
# edit it, then submit the edited version to guiboss_imp to be
# expanded into a full Running_Gui to replace the previous one.
#
# The intended advantages of this approach are:
#
#  o  The abstracted Xi_Widget version will be stripped of all mutable
#     values of interest to guiboss_imp, eliminating risk of client code
#     doing weird things to guiboss_imp's state behind its back, producing
#     hard-to-debug problems.
#
#  o  The abstracted Xi_Widget version will be easier for client code
#     to process, and less likely to change (breaking client code) than
#     the full Running_Gui datastructure.
#
#  o  The client-code rewrites of the Xi_Widget version will meet all
#     anticipated client needs for moving widgets around on a pane,
#     without allowing topological changes in the current popup-window
#     hierarchy which would introduce additional implementation difficulty
#     no good purpose.
#
#  o  The Xi_Widget version allows introducing new gadgets into the running
#     GUI via an escape mechanism (Xi_Widget.XI_GUI_PLAN) allowing inclusion
#     of raw Gui_Plan nodes or subtrees.
#
#  o  Widgets can be deleted from the running gui just by eliding them from
#     the Xi_Widget tree before returning the result to guiboss_imp.
#
#  o  The export-import sequence provides guiboss_imp the opportunity to
#     thoroughly validate the replacement Xi_Widget tree before installing
#     it as the replacement running gui.



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\|### \\)"		 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.

