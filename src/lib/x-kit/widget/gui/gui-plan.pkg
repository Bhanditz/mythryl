## gui-plan.pkg
#
# A stopped_gui is an abstract gui specification.  Client
# code constructs a stopped_gui to describe a desired gui
# and hands it to gui-boss-imp to run.
#
# When gui_boss::restart_gui is called, gui_boss converts
# the stopped_gui it is given into a running_gui tree which
# contains running widget imps and records all runtime-
# relevant information.
#
# When gui_boss::stop_gui is called, the runtime running_gui
# is converted back into a stopped_gui which preserves the
# state of the GUI at shutdown time, for possible later
# resumption via gui_boss::restart_gui.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    package os  =  bounce_space;				# bounce_space				is from   src/lib/x-kit/widget/space/bounce/bounce-space.pkg
    package osi =  bounce_space_imp;				# bounce_space_imp			is from   src/lib/x-kit/widget/space/bounce/bounce-space-imp.pkg

    package cs  =  canvas_space;				# canvas_space				is from   src/lib/x-kit/widget/space/canvas/canvas-space.pkg
    package csi =  canvas_space_imp;				# canvas_space_imp			is from   src/lib/x-kit/widget/space/canvas/canvas-space-imp.pkg

    package ps  =  packed_space;				# packed_space				is from   src/lib/x-kit/widget/space/packed/packed-space.pkg
    package psi =  packed_space_imp;				# packed_space_imp			is from   src/lib/x-kit/widget/space/packed/packed-space-imp.pkg

    package pwe =  packed_widget_egg;				# packed_widget_egg			is from   src/lib/x-kit/widget/space/packed/packed-widget-egg.pkg

#   package ks  =  label_look_state;				# label_look_state			is from   src/lib/x-kit/widget/look/label-look-state.pkg
    #
    package c2f =  client_to_float_state;			# client_to_float_state			is from   src/lib/x-kit/widget/space/packed/client-to-float-state.pkg
    package c2i =  client_to_int_state;				# client_to_int_state			is from   src/lib/x-kit/widget/space/packed/client-to-int-state.pkg
    package c2m =  client_to_image_state;			# client_to_image_state			is from   src/lib/x-kit/widget/space/packed/client-to-image-state.pkg
    package c2s =  client_to_string_state;			# client_to_string_state		is from   src/lib/x-kit/widget/space/packed/client-to-string-state.pkg
    package c2t =  client_to_bool_state;	/* t==TRUE */	# client_to_bool_state			is from   src/lib/x-kit/widget/space/packed/client-to-bool-state.pkg
    package c2x =  client_to_exception_state;			# client_to_exception_state		is from   src/lib/x-kit/widget/space/packed/client-to-exception-state.pkg

    package fsi =  float_state_imp;				# float_state_imp			is from   src/lib/x-kit/widget/space/packed/float-state-imp.pkg
    package isi =  int_state_imp;				# int_state_imp				is from   src/lib/x-kit/widget/space/packed/int-state-imp.pkg
    package msi =  image_state_imp;				# image_state_imp			is from   src/lib/x-kit/widget/space/packed/image-state-imp.pkg
    package ssi =  string_state_imp;				# string_state_imp			is from   src/lib/x-kit/widget/space/packed/string-state-imp.pkg
    package tsi =  bool_state_imp;				# bool_state_imp			is from   src/lib/x-kit/widget/space/packed/string-state-imp.pkg
    package xsi =  exception_state_imp;				# exception_state_imp			is from   src/lib/x-kit/widget/space/packed/exception-state-imp.pkg

    package flx =  float_look_imp_for_x;			# float_look_imp_for_x			is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/float-look-imp-for-x.pkg
    package ilx =  int_look_imp_for_x;				# int_look_imp_for_x			is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/int-look-imp-for-x.pkg
    package mlx =  image_look_imp_for_x;			# image_look_imp_for_x			is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/image-look-imp-for-x.pkg
    package slx =  string_look_imp_for_x;			# string_look_imp_for_x			is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/string-look-imp-for-x.pkg
    package tlx =  bool_look_imp_for_x;				# bool_look_imp_for_x			is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/bool-look-imp-for-x.pkg
    package xlx =  exception_look_imp_for_x;			# exception_look_imp_for_x		is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/exception-look-imp-for-x.pkg

    package pl  =   packed_look;				# packed_look				is from   src/lib/x-kit/widget/theme/packed/look/packed-look.pkg
    package nl  =    node_look;					#  node_look				is from   src/lib/x-kit/widget/theme/canvas/look/node-look.pkg

    package bl  =  ball_look;					# ball_look				is from   src/lib/x-kit/widget/theme/bounce/look/ball-look.pkg
    package bs  =  ball_state;					# ball_state				is from   src/lib/x-kit/widget/space/bounce/ball/ball-state.pkg
    package bsi =  ball_state_imp;				# ball_state_imp			is from   src/lib/x-kit/widget/space/bounce/ball/ball-state-imp.pkg

    package ns  =  node_state;					# node_state				is from   src/lib/x-kit/widget/space/canvas/node/node-state.pkg
    package nsi =  node_state_imp;				# node_state_imp			is from   src/lib/x-kit/widget/space/canvas/node/node-state-imp.pkg

    package blx =  default_ball_look_imp_for_x;			# default_ball_look_imp_for_x		is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/default-ball-look-imp-for-x.pkg
    package nlx =  default_node_look_imp_for_x;			# default_node_look_imp_for_x		is from   src/lib/x-kit/widget/xkit/theme/packed/default/look/default-node-look-imp-for-x.pkg


    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill		is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg

    package blh =  bounce_space_layout_hint;			# bounce_space_layout_hint		is from   src/lib/x-kit/widget/space/bounce/bounce-space-layout-hint.pkg
    package clh =  canvas_space_layout_hint;			# canvas_space_layout_hint		is from   src/lib/x-kit/widget/space/canvas/canvas-space-layout-hint.pkg
    package plh =  packed_space_layout_hint;			# packed_space_layout_hint		is from   src/lib/x-kit/widget/space/packed/packed-space-layout-hint.pkg

    package xg  =  xgeometry;					# xgeometry				is from   src/lib/std/2d/xgeometry.pkg
    package xt  =  xtypes;					# xtypes				is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package r8  =  rgb8;					# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
#   package xtr =  xlogger;					# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package err =  error_message;				# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    #
herein

    package gui_plan
    {
	package checkbox {
	    #
	    Value = c2t::Value;										# Bool.

	    Is_Bad_Value =  Value -> Null_Or( (Void -> String, Null_Or (Void -> Value) ));		# Given a Value, return NULL if it is valid, else a thunk returning a diagnostic
													# string explaining why it is not, plus optionally thunk computing 'nearby' valid value.
													# usable in place of the invalid value.
	    Checkbox_Option
	      #
	      = MICROTHREAD_NAME		String							# 
	      | ID				Id							# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	      | IS_BAD_VALUE			Is_Bad_Value
	      | CHANGE_CALLBACK			Value -> Void						# We'll call each of these callbacks each time our value changes.
	      | CLIENT_TO_STATE_CALLBACK	c2t::Client_To_State -> Void				# Client code registers this callback to get a port to us once we start up.
	      ;

	    Checkbox_Arg
	      =
	      {	value:				Value,
		options:			List( Checkbox_Option )
	      };

	    fun pprint_checkbox_arg
		  (pp:		pp::Prettyprint_Mill)
		  (checkbox_arg:	Checkbox_Arg)
		=
		{
		    checkbox_arg
		      ->
		      { value:			Value,
			options:		List( Checkbox_Option )
		      };

		    pp.box {.
			pp.txt (sprintf " { value => %s," (c2t::value_to_string value));
			pp.txt " options => [";
			pp::seq {. pp.txt ", "; }
				pprint_option
				options
				;	
			pp.txt " ]";
			pp.txt " }";
		    };
		}
		where
		    fun pprint_option option
			=
			case option
			    #
			    MICROTHREAD_NAME name	=>  {  pp.lit (sprintf "MICROTHREAD_NAME \"%s\"" name);		};
			    ID			id	=>  {  pp.lit (sprintf "ID %d" (id_to_int id)        );		};
			    IS_BAD_VALUE _		=>  {  pp.lit          "IS_BAD_VALUE (fn)";			};
			    CHANGE_CALLBACK _		=>  {  pp.lit          "CHANGE_CALLBACK (callback)";		};
			    CLIENT_TO_STATE_CALLBACK _	=>  {  pp.lit          "CLIENT_TO_STATE_CALLBACK (callback)";	};
			esac;
		end;
	};

	package image {
	    #
	    Value = c2m::Value;										# rw_matrix::Rw_Matrix(rgb8::Rgb8)

	    Is_Bad_Value =  Value -> Null_Or( (Void -> String, Null_Or (Void -> Value) ));		# Given a Value, return NULL if it is valid, else a thunk returning a diagnostic
													# string explaining why it is not, plus optionally thunk computing 'nearby' valid value.
													# usable in place of the invalid value.
	    Image_Option
	      #
	      = MICROTHREAD_NAME		String							# 
	      | ID				Id							# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	      | IS_BAD_VALUE			Is_Bad_Value
	      | CHANGE_CALLBACK			Value -> Void						# We'll call each of these callbacks each time our value changes.
	      | CLIENT_TO_STATE_CALLBACK	c2m::Client_To_State -> Void				# Client code registers this callback to get a port to us once we start up.
	      ;

	    Image_Arg
	      =
	      {	value:				Value,
		options:			List( Image_Option )
	      };

	    fun pprint_image_arg
		  (pp:		pp::Prettyprint_Mill)
		  (image_arg:	Image_Arg)
		=
		{
		    image_arg
		      ->
		      { value:			Value,
			options:		List( Image_Option )
		      };

		    pp.box {.
			pp.txt (sprintf " { value => %s," (c2m::value_to_string value));
			pp.txt " options => [";
			pp::seq {. pp.txt ", "; }
				pprint_option
				options
				;	
			pp.txt " ]";
			pp.txt " }";
		    };
		}
		where
		    fun pprint_option option
			=
			case option
			    #
			    MICROTHREAD_NAME name	=>  {  pp.lit (sprintf "MICROTHREAD_NAME \"%s\"" name);		};
			    ID			id	=>  {  pp.lit (sprintf "ID %d" (id_to_int id)        );		};
			    IS_BAD_VALUE _		=>  {  pp.lit          "IS_BAD_VALUE (fn)";			};
			    CHANGE_CALLBACK _		=>  {  pp.lit          "CHANGE_CALLBACK (callback)";		};
			    CLIENT_TO_STATE_CALLBACK _	=>  {  pp.lit          "CLIENT_TO_STATE_CALLBACK (callback)";	};
			esac;
		end;
	};

	package label {
	    #
	    Value = c2s::Value;										# String.

	    Is_Bad_Value =  Value -> Null_Or( (Void -> String, Null_Or (Void -> Value) ));		# Given a Value, return NULL if it is valid, else a thunk returning a diagnostic
													# string explaining why it is not, plus optionally thunk computing 'nearby' valid value.
													# usable in place of the invalid value.
	    Label_Option
	      #
	      = MICROTHREAD_NAME		String							# 
	      | ID				Id							# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	      | IS_BAD_VALUE			Is_Bad_Value
	      | CHANGE_CALLBACK			Value -> Void						# We'll call each of these callbacks each time our value changes.
	      | CLIENT_TO_STATE_CALLBACK	c2s::Client_To_State -> Void				# Client code registers this callback to get a port to us once we start up.
	      ;

	    Label_Arg
	      =
	      {	value:				Value,
		options:			List( Label_Option )
	      };

	    fun pprint_label_arg
		  (pp:		pp::Prettyprint_Mill)
		  (label_arg:	Label_Arg)
		=
		{
		    label_arg
		      ->
		      { value:			Value,
			options:		List( Label_Option )
		      };

		    pp.box {.
			pp.txt (sprintf " { value => %s," (c2s::value_to_string value));
			pp.txt " options => [";
			pp::seq {. pp.txt ", "; }
				pprint_option
				options
				;	
			pp.txt " ]";
			pp.txt " }";
		    };
		}
		where
		    fun pprint_option option
			=
			case option
			    #
			    MICROTHREAD_NAME name	=>  {  pp.lit (sprintf "MICROTHREAD_NAME \"%s\"" name);		};
			    ID			id	=>  {  pp.lit (sprintf "ID %d" (id_to_int id)        );		};
			    IS_BAD_VALUE _		=>  {  pp.lit          "IS_BAD_VALUE (fn)";			};
			    CHANGE_CALLBACK _		=>  {  pp.lit          "CHANGE_CALLBACK (callback)";		};
			    CLIENT_TO_STATE_CALLBACK _	=>  {  pp.lit          "CLIENT_TO_STATE_CALLBACK (callback)";	};
			esac;
		end;
	};


	package select {
	    #
	    Value = c2i::Value;										# Int.

	    Is_Bad_Value =  Value -> Null_Or( (Void -> String, Null_Or (Void -> Value) ));		# Given a Value, return NULL if it is valid, else a thunk returning a diagnostic
													# string explaining why it is not, plus optionally thunk computing 'nearby' valid value.
													# usable in place of the invalid value.
	    Select_Option
	      #
	      = MICROTHREAD_NAME		String							# 
	      | ID				Id							# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	      | IS_BAD_VALUE			Is_Bad_Value
	      | CHANGE_CALLBACK			Value -> Void						# We'll call each of these callbacks each time our value changes.
	      | CLIENT_TO_STATE_CALLBACK	c2i::Client_To_State -> Void				# Client code registers this callback to get a port to us once we start up.
	      ;

	    Select_Arg
	      =
	      {	value:				Value,
		options:			List( Select_Option )
	      };

	    fun pprint_select_arg
		  (pp:		pp::Prettyprint_Mill)
		  (select_arg:	Select_Arg)
		=
		{
		    select_arg
		      ->
		      { value:			Value,
			options:		List( Select_Option )
		      };

		    pp.box {.
			pp.txt (sprintf " { value => %s," (c2i::value_to_string value));
			pp.txt " options => [";
			pp::seq {. pp.txt ", "; }
				pprint_option
				options
				;	
			pp.txt " ]";
			pp.txt " }";
		    };
		}
		where
		    fun pprint_option option
			=
			case option
			    #
			    MICROTHREAD_NAME name	=>  {  pp.lit (sprintf "MICROTHREAD_NAME \"%s\"" name);		};
			    ID			id	=>  {  pp.lit (sprintf "ID %d" (id_to_int id)        );		};
			    IS_BAD_VALUE _		=>  {  pp.lit          "IS_BAD_VALUE (fn)";			};
			    CHANGE_CALLBACK _		=>  {  pp.lit          "CHANGE_CALLBACK (callback)";		};
			    CLIENT_TO_STATE_CALLBACK _	=>  {  pp.lit          "CLIENT_TO_STATE_CALLBACK (callback)";	};
			esac;
		end;
	};

	package knob {
	    #
	    Value = c2f::Value;										# Float.

	    Is_Bad_Value =  Value -> Null_Or( (Void -> String, Null_Or (Void -> Value) ));		# Given a Value, return NULL if it is valid, else a thunk returning a diagnostic
													# string explaining why it is not, plus optionally thunk computing 'nearby' valid value.
													# usable in place of the invalid value.
	    Knob_Option
	      #
	      = MICROTHREAD_NAME		String							# 
	      | ID				Id							# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	      | IS_BAD_VALUE			Is_Bad_Value
	      | CHANGE_CALLBACK			Value -> Void						# We'll call each of these callbacks each time our value changes.
	      | CLIENT_TO_STATE_CALLBACK	c2f::Client_To_State -> Void				# Client code registers this callback to get a port to us once we start up.
	      ;

	    Knob_Arg
	      =
	      {	value:				Value,
		options:			List( Knob_Option )
	      };

	    fun pprint_knob_arg
		  (pp:		pp::Prettyprint_Mill)
		  (knob_arg:	Knob_Arg)
		=
		{
		    knob_arg
		      ->
		      { value:			Value,
			options:		List( Knob_Option )
		      };

		    pp.box {.
			pp.txt (sprintf " { value => %s," (c2f::value_to_string value));
			pp.txt " options => [";
			pp::seq {. pp.txt ", "; }
				pprint_option
				options
				;	
			pp.txt " ]";
			pp.txt " }";
		    };
		}
		where
		    fun pprint_option option
			=
			case option
			    #
			    MICROTHREAD_NAME name	=>  {  pp.lit (sprintf "MICROTHREAD_NAME \"%s\"" name);		};
			    ID			id	=>  {  pp.lit (sprintf "ID %d" (id_to_int id)        );		};
			    IS_BAD_VALUE _		=>  {  pp.lit          "IS_BAD_VALUE (fn)";			};
			    CHANGE_CALLBACK _		=>  {  pp.lit          "CHANGE_CALLBACK (callback)";		};
			    CLIENT_TO_STATE_CALLBACK _	=>  {  pp.lit          "CLIENT_TO_STATE_CALLBACK (callback)";	};
			esac;
		end;
	};

	package xslider {
	    #
	    Value = c2f::Value;										# Float.

	    Is_Bad_Value =  Value -> Null_Or( (Void -> String, Null_Or (Void -> Value) ));		# Given a Value, return NULL if it is valid, else a thunk returning a diagnostic
													# string explaining why it is not, plus optionally thunk computing 'nearby' valid value.
													# usable in place of the invalid value.
	    Xslider_Option
	      #
	      = MICROTHREAD_NAME		String							# 
	      | ID				Id							# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	      | IS_BAD_VALUE			Is_Bad_Value
	      | CHANGE_CALLBACK			Value -> Void						# We'll call each of these callbacks each time our value changes.
	      | CLIENT_TO_STATE_CALLBACK	c2f::Client_To_State -> Void				# Client code registers this callback to get a port to us once we start up.
	      ;

	    Xslider_Arg
	      =
	      {	value:				Value,
		options:			List( Xslider_Option )
	      };

	    fun pprint_xslider_arg
		  (pp:		pp::Prettyprint_Mill)
		  (xslider_arg:	Xslider_Arg)
		=
		{
		    xslider_arg
		      ->
		      { value:			Value,
			options:		List( Xslider_Option )
		      };

		    pp.box {.
			pp.txt (sprintf " { value => %s," (c2f::value_to_string value));
			pp.txt " options => [";
			pp::seq {. pp.txt ", "; }
				pprint_option
				options
				;	
			pp.txt " ]";
			pp.txt " }";
		    };
		}
		where
		    fun pprint_option option
			=
			case option
			    #
			    MICROTHREAD_NAME name	=>  {  pp.lit (sprintf "MICROTHREAD_NAME \"%s\"" name);		};
			    ID			id	=>  {  pp.lit (sprintf "ID %d" (id_to_int id)        );		};
			    IS_BAD_VALUE _		=>  {  pp.lit          "IS_BAD_VALUE (fn)";			};
			    CHANGE_CALLBACK _		=>  {  pp.lit          "CHANGE_CALLBACK (callback)";		};
			    CLIENT_TO_STATE_CALLBACK _	=>  {  pp.lit          "CLIENT_TO_STATE_CALLBACK (callback)";	};
			esac;
		end;
	};

	package yslider {
	    #
	    Value = c2f::Value;										# Float.

	    Is_Bad_Value =  Value -> Null_Or( (Void -> String, Null_Or (Void -> Value) ));		# Given a Value, return NULL if it is valid, else a thunk returning a diagnostic
													# string explaining why it is not, plus optionally thunk computing 'nearby' valid value.
													# usable in place of the invalid value.
	    Yslider_Option
	      #
	      = MICROTHREAD_NAME		String							# 
	      | ID				Id							# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	      | IS_BAD_VALUE			Is_Bad_Value
	      | CHANGE_CALLBACK			Value -> Void						# We'll call each of these callbacks each time our value changes.
	      | CLIENT_TO_STATE_CALLBACK	c2f::Client_To_State -> Void				# Client code registers this callback to get a port to us once we start up.
	      ;

	    Yslider_Arg
	      =
	      {	value:				Value,
		options:			List( Yslider_Option )
	      };

	    fun pprint_yslider_arg
		  (pp:		pp::Prettyprint_Mill)
		  (yslider_arg:	Yslider_Arg)
		=
		{
		    yslider_arg
		      ->
		      { value:			Value,
			options:		List( Yslider_Option )
		      };

		    pp.box {.
			pp.txt (sprintf " { value => %s," (c2f::value_to_string value));
			pp.txt " options => [";
			pp::seq {. pp.txt ", "; }
				pprint_option
				options
				;	
			pp.txt " ]";
			pp.txt " }";
		    };
		}
		where
		    fun pprint_option option
			=
			case option
			    #
			    MICROTHREAD_NAME name	=>  {  pp.lit (sprintf "MICROTHREAD_NAME \"%s\"" name);		};
			    ID			id	=>  {  pp.lit (sprintf "ID %d" (id_to_int id)        );		};
			    IS_BAD_VALUE _		=>  {  pp.lit          "IS_BAD_VALUE (fn)";			};
			    CHANGE_CALLBACK _		=>  {  pp.lit          "CHANGE_CALLBACK (callback)";		};
			    CLIENT_TO_STATE_CALLBACK _	=>  {  pp.lit          "CLIENT_TO_STATE_CALLBACK (callback)";	};
			esac;
		end;
	};

	#
	Bounce_Widget
	    #
	    = BALL		(bs::Ball_Arg, bl::Ball_Look_Arg)

	also
	Canvas_Widget
	    #
	    = PACKED_SPACE	(ps::Packed_Space_Arg,  Packed_Widget)
	    #
	    | NODE		(ns::Node_Arg, nl::Node_Look_Arg)

	also
	Packed_Widget
	    #
	    = ROW		 List( (Packed_Widget, List(plh::Packed_Space_Layout_Hint)) )
	    | COL		 List( (Packed_Widget, List(plh::Packed_Space_Layout_Hint)) )
	    #	
	    | CHECKBOX		checkbox::Checkbox_Arg
	    #	
	    | KNOB		knob::Knob_Arg
	    | XSLIDER		xslider::Xslider_Arg
	    | YSLIDER		yslider::Yslider_Arg
	    #	
	    | SELECT		select::Select_Arg
	    | LABEL		label::Label_Arg
	    | IMAGE		image::Image_Arg
	    #	
	    | OTHER		(c2x::Make_Arg,  pl::Packed_Look_Arg)
	    #
	    | CANVAS_SPACE	(cs::Canvas_Space_Arg,  List((Canvas_Widget, List(clh::Canvas_Space_Layout_Hint))))
	    | BOUNCE_SPACE	(os::Bounce_Space_Arg,  List((Bounce_Widget, List(blh::Bounce_Space_Layout_Hint))))
	    #
	    | NULL_PACKED_WIDGET									# Note[1]
	    ;

	Gui_Plan =  (ps::Packed_Space_Arg,  Packed_Widget);

	fun pprint_gui_plan (gui_plan: Gui_Plan)							# "pprint" == "prettyprint".
	    =
	    pp::with_standard_prettyprint_mill
		#
		(err::default_plaint_sink ())	[]
		#
		(fn pp:   pp::Prettyprint_Mill
		    =
		    do_gui_plan  gui_plan
		    where
			fun do_gui_plan  gui_plan
			    =
			    do_packed_space  gui_plan

			also
			fun do_packed_space
			      ( packed_space_arg:	ps::Packed_Space_Arg,
				packed_widget:		Packed_Widget
			      )
			    =
			    {   pp.box {.
				    do_packed_space_arg  packed_space_arg;
				    do_packed_widget     packed_widget;
				};
				pp.newline();
			    }

			also
			fun do_bounce_space
			      (
				bounce_space_arg:	os::Bounce_Space_Arg,
				bounce_widgets:		List(  (Bounce_Widget, List(blh::Bounce_Space_Layout_Hint))  )
			      )
			    =
			    {   pp.box {.
				    do_bounce_space_arg  bounce_space_arg;
				    do_bounce_widgets    bounce_widgets;
				};
				pp.newline();
			    }

			also
			fun do_bounce_space_arg  (bounce_space_arg:	os::Bounce_Space_Arg)
			    =
			    {
				osi::pprint_bounce_space_arg  pp  bounce_space_arg;
				pp.newline();
			    }


			also
			fun do_bounce_space_layout_hints  (layout_hints: List(blh::Bounce_Space_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  blh::Bounce_Space_Layout_Hint)
				    =
				    osi::pprint_bounce_space_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_bounce_widgets  (bounce_widgets:		List(  (Bounce_Widget, List(blh::Bounce_Space_Layout_Hint))  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";

				    fun do_widget (bounce_widget: Bounce_Widget,  layout_hints: List(blh::Bounce_Space_Layout_Hint))
					=
					pp.box {.
					    do_bounce_widget			bounce_widget;
					    pp.endlit ",";
					    pp.txt " ";
					    do_bounce_space_layout_hints	layout_hints;
					};

				    pp::seq
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					bounce_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_bounce_widget  (bounce_widget:	Bounce_Widget)
			    =
			    case bounce_widget
				#
			        BALL	( ball_arg:		bs::Ball_Arg,
					  ball_look_arg:	bl::Ball_Look_Arg
					)
				    =>
				    {
					pp.box {.
					    pp.lit  "BALL (";		pp.txt " ";
					    bsi::pprint_ball_arg  pp  ball_arg;
					    pp.txt ", ";
					    blx::pprint_ball_look_arg  pp  ball_look_arg;
					    pp.lit  ")";
					};
					pp.newline();
				    };
			    esac

			also
			fun do_canvas_space
			      (
				canvas_space_arg:	cs::Canvas_Space_Arg,
				canvas_widgets:		List(  (Canvas_Widget, List(clh::Canvas_Space_Layout_Hint))  )
			      )
			    =
			    {   pp.box {.
				    do_canvas_space_arg  canvas_space_arg;
				    do_canvas_widgets    canvas_widgets;
				};
				pp.newline();
			    }

			also
			fun do_canvas_space_arg  (canvas_space_arg:	cs::Canvas_Space_Arg)
			    =
			    {
				csi::pprint_canvas_space_arg  pp  canvas_space_arg;
				pp.newline();
			    }

			also
			fun do_canvas_space_layout_hints  (layout_hints: List(clh::Canvas_Space_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  clh::Canvas_Space_Layout_Hint)
				    =
				    csi::pprint_canvas_space_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_canvas_widgets  (canvas_widgets:		List(  (Canvas_Widget, List(clh::Canvas_Space_Layout_Hint))  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";


				    fun do_widget (canvas_widget: Canvas_Widget,  layout_hints: List(clh::Canvas_Space_Layout_Hint))
					=
					pp.box {.
					    do_canvas_widget			canvas_widget;
					    pp.endlit ",";
					    pp.txt " ";
					    do_canvas_space_layout_hints	layout_hints;
					};

				    pp::seq
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					canvas_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_canvas_widget  (canvas_widget:	Canvas_Widget)
			    =
			    case canvas_widget
				#
			        NODE	( node_arg:		ns::Node_Arg,
					  node_look_arg:	nl::Node_Look_Arg
					)
				    =>
				    {
					pp.box {.
					    pp.lit  "NODE (";		pp.txt " ";
					    nsi::pprint_node_arg  pp  node_arg;
					    pp.txt ", ";
					    nlx::pprint_node_look_arg  pp  node_look_arg;
					    pp.lit  ")";
					};
					pp.newline();
				    };

			        PACKED_SPACE  packed_space
				    =>
				    {
					pp.lit  "PACKED_SPACE ";
					pp.newline();
					do_packed_space packed_space;
					pp.newline();
				    };
			    esac

			also
			fun do_packed_space_arg  (packed_space_arg:	ps::Packed_Space_Arg)
			    =
			    {
				psi::pprint_packed_space_arg  pp  packed_space_arg;
				pp.newline();
			    }

			also
			fun do_packed_space_layout_hints  (layout_hints: List(plh::Packed_Space_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  plh::Packed_Space_Layout_Hint)
				    =
				    psi::pprint_packed_space_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_packed_widget  (packed_widget:	Packed_Widget)
			    =
			    case packed_widget
				#
			        ROW	(widgets:	 List( (Packed_Widget, List(plh::Packed_Space_Layout_Hint)) ))
				    =>
				    {
					pp.box' 0 -1 {.
					    pp.lit  "ROW [";
					    pp.ind 2;
					    pp.txt " ";

					    fun do_widget (packed_widget: Packed_Widget,  layout_hints: List(plh::Packed_Space_Layout_Hint))
						=
						pp.box {.
						    do_packed_widget			packed_widget;
						    pp.endlit ",";
						    pp.txt " ";
						    do_packed_space_layout_hints	layout_hints;
						};

					    pp::seq
						{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
						do_widget				# Print one list element.
						widgets;				# List of elements.

					    pp.ind 0;
					    pp.txt " ";
					    pp.lit "]";
					};
				    };

			        COL	(a:	 List( (Packed_Widget, List(plh::Packed_Space_Layout_Hint)) ))
				    =>
				    {
					pp.lit  "COL";
					pp.newline();
				    };

			        OTHER
					( label_arg:		c2x::Make_Arg,
					  label_look_arg:	pl::Packed_Look_Arg
					)
				    =>
				    {
					pp.box {.
					    pp.lit  "OTHER (";		pp.txt " ";
					    xsi::pprint_make_arg  pp  label_arg;
					    pp.txt ", ";
					    xlx::pprint_packed_look_arg  pp  label_look_arg;
					    pp.lit  ")";
					};
					pp.newline();
				    };

			        IMAGE (arg: image::Image_Arg)
				    =>
				    {
					pp.box {.
					    pp.lit  "IMAGE (";	pp.txt " ";
					    image::pprint_image_arg  pp  arg;
					    pp.txt ", ";
#					    flx::pprint_packed_look_arg  pp  image_look_arg;
					    pp.lit  ")";
					};
					pp.newline();
				    };

			        LABEL (arg: label::Label_Arg)
				    =>
				    {
					pp.box {.
					    pp.lit  "LABEL (";	pp.txt " ";
					    label::pprint_label_arg  pp  arg;
					    pp.txt ", ";
#					    flx::pprint_packed_look_arg  pp  label_look_arg;
					    pp.lit  ")";
					};
					pp.newline();
				    };

			        SELECT (arg: select::Select_Arg)
				    =>
				    {
					pp.box {.
					    pp.lit  "SELECT (";	pp.txt " ";
					    select::pprint_select_arg  pp  arg;
					    pp.txt ", ";
#					    flx::pprint_packed_look_arg  pp  select_look_arg;
					    pp.lit  ")";
					};
					pp.newline();
				    };

			        CHECKBOX (arg: checkbox::Checkbox_Arg)
				    =>
				    {
					pp.box {.
					    pp.lit  "CHECKBOX (";	pp.txt " ";
					    checkbox::pprint_checkbox_arg  pp  arg;
					    pp.txt ", ";
#					    flx::pprint_packed_look_arg  pp  checkbox_look_arg;
					    pp.lit  ")";
					};
					pp.newline();
				    };

			        KNOB	(arg: knob::Knob_Arg)
				    =>
				    {
					pp.box {.
					    pp.lit  "KNOB (";	pp.txt " ";
					    knob::pprint_knob_arg  pp  arg;
					    pp.txt ", ";
#					    flx::pprint_packed_look_arg  pp  knob_look_arg;
					    pp.lit  ")";
					};
					pp.newline();
				    };

			       XSLIDER (arg: xslider::Xslider_Arg)
				    =>
				    {
					pp.box {.
					    pp.lit  "XSLIDER (";	pp.txt " ";
					    xslider::pprint_xslider_arg  pp  arg;
					    pp.txt ", ";
#					    flx::pprint_packed_look_arg  pp  knob_look_arg;
					    pp.lit  ")";
					};
					pp.newline();
				    };

			       YSLIDER (arg: yslider::Yslider_Arg)
				    =>
				    {
					pp.box {.
					    pp.lit  "YSLIDER (";	pp.txt " ";
					    yslider::pprint_yslider_arg  pp  arg;
					    pp.txt ", ";
#					    flx::pprint_packed_look_arg  pp  knob_look_arg;
					    pp.lit  ")";
					};
					pp.newline();
				    };

			        CANVAS_SPACE (canvas_space:	(cs::Canvas_Space_Arg,  List((Canvas_Widget, List(clh::Canvas_Space_Layout_Hint)))))
				    =>
				    {
					pp.lit  "CANVAS_SPACE";
					do_canvas_space  canvas_space;
					pp.newline();
				    };

			        BOUNCE_SPACE (bounce_space:	(os::Bounce_Space_Arg,  List((Bounce_Widget, List(blh::Bounce_Space_Layout_Hint)))))
				    =>
				    {
					pp.lit  "BOUNCE_SPACE";
					do_bounce_space  bounce_space;
					pp.newline();
				    };
			      
			        NULL_PACKED_WIDGET
				    =>
				    {
					pp.lit  "NULL_PACKED_WIDGET";
					pp.newline();
				    };
			    esac;
		    end
		);
    };

end;


####################################################################################
# Note[1]
#    We need a NULL_PACKED_WIDGET but not a NULL_CANVAS_WIDGET or NULL_BOUNCE_WIDGET
#    because a Packed_Widget is a mandatory part of Gui_Plan, but Bounce_Widget and
#    Canvas_Widget are always optional (an empty list is always permissible).