## gui-boss-imp.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include threadkit;						# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  atom_port;					# atom_port			is from   src/lib/x-kit/xclient/src/iccc/atom-port.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package et  =  event_types;					# event_types			is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package kp  =  keymap;					# keymap			is from   src/lib/x-kit/xclient/src/window/keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
#   package rgb =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package s2p =  xevent_to_window;				# xevent_to_window		is from   src/lib/x-kit/xclient/src/window/xevent-to-window.pkg
#   package sep =  selection_port;				# selection_port		is from   src/lib/x-kit/xclient/src/window/selection-port.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package sp  =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  window_watcher;				# window_watcher		is from   src/lib/x-kit/xclient/src/window/window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package x2s =  xevent_to_string;				# xevent_to_string		is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xt  =  xtypes;					# xtypes			is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #
    package aw  =  appwindow;					# appwindow			is from   src/lib/x-kit/widget/theme/appwindow.pkg

    package gp  =  gui_plan;					# gui_plan			is from   src/lib/x-kit/widget/gui/gui-plan.pkg
    package gt  =  gui_tree;					# gui_tree			is from   src/lib/x-kit/widget/gui/gui-tree.pkg

    package bt  =  bounce_theme;				# bounce_theme			is from   src/lib/x-kit/widget/theme/bounce/bounce-theme.pkg
    package ct  =  canvas_theme;				# canvas_theme			is from   src/lib/x-kit/widget/theme/canvas/canvas-theme.pkg
    package tp  =  packed_theme;				# packed_theme			is from   src/lib/x-kit/widget/theme/packed/packed-theme.pkg

    package os  =  bounce_space;				# bounce_space			is from   src/lib/x-kit/widget/space/bounce/bounce-space.pkg
    package cs  =  canvas_space;				# canvas_space			is from   src/lib/x-kit/widget/space/canvas/canvas-space.pkg
    package ps  =  packed_space;				# packed_space			is from   src/lib/x-kit/widget/space/packed/packed-space.pkg

    package bs  =    ball_state;				# ball_state			is from   src/lib/x-kit/widget/space/bounce/ball/ball-state.pkg
    package ns  =    node_state;				# node_state			is from   src/lib/x-kit/widget/space/canvas/node/node-state.pkg

    package boi =  bounce_space_imp;				# bounce_space_imp		is from   src/lib/x-kit/widget/space/bounce/bounce-space-imp.pkg
    package cai =  canvas_space_imp;				# canvas_space_imp		is from   src/lib/x-kit/widget/space/canvas/canvas-space-imp.pkg
    package pai =  packed_space_imp;				# packed_space_imp		is from   src/lib/x-kit/widget/space/packed/packed-space-imp.pkg

    package bsi =    ball_state_imp;				#   ball_state_imp		is from   src/lib/x-kit/widget/space/bounce/ball/ball-state-imp.pkg
    package lsi =   label_state_imp;				#  label_state_imp		is from   src/lib/x-kit/widget/space/packed/label/label-state-imp.pkg
    package nsi =    node_state_imp;				#   node_state_imp		is from   src/lib/x-kit/widget/space/canvas/node/node-state-imp.pkg
    package ssi =  slider_state_imp;				# slider_state_imp		is from   src/lib/x-kit/widget/space/packed/slider/slider-state-imp.pkg

    package bl  =    ball_look;					#   ball_look			is from   src/lib/x-kit/widget/theme/bounce/look/ball-look.pkg
    package kl  =    knob_look;					#   knob_look			is from   src/lib/x-kit/widget/theme/packed/knob/knob-look.pkg
    package ll  =   label_look;					#  label_look			is from   src/lib/x-kit/widget/theme/packed/look/label-look.pkg
    package nl  =    node_look;					#   node_look			is from   src/lib/x-kit/widget/theme/canvas/look/node-look.pkg
    package xl  = xslider_look;					# xslider_look			is from   src/lib/x-kit/widget/theme/packed/look/xslider-look.pkg
    package yl  = yslider_look;					# yslider_look			is from   src/lib/x-kit/widget/theme/packed/look/yslider-look.pkg

    package bs  =    ball_state;				#   ball_state			is from   src/lib/x-kit/widget/space/bounce/ball/ball-state.pkg
    package ls  =   label_state;				#  label_state			is from   src/lib/x-kit/widget/space/packed/label/label-state.pkg
    package ns  =    node_state;				#   node_state			is from   src/lib/x-kit/widget/space/canvas/node/node-state.pkg
    package ss  =  slider_state;				# slider_state			is from   src/lib/x-kit/widget/space/packed/slider/slider-state.pkg

    package g2l =  gui_to_look;					# gui_to_look			is from   src/lib/x-kit/widget/gui/gui-to-look.pkg

    package blh =  bounce_space_layout_hint;			# bounce_space_layout_hint	is from   src/lib/x-kit/widget/space/bounce/bounce-space-layout-hint.pkg
    package clh =  canvas_space_layout_hint;			# canvas_space_layout_hint	is from   src/lib/x-kit/widget/space/canvas/canvas-space-layout-hint.pkg
    package plh =  packed_space_layout_hint;			# packed_space_layout_hint	is from   src/lib/x-kit/widget/space/packed/packed-space-layout-hint.pkg

    package b2l =  bounce_to_look;				# bounce_to_look		is from   src/lib/x-kit/widget/space/bounce/bounce-to-look.pkg
    package c2l =  canvas_to_look;				# canvas_to_look		is from   src/lib/x-kit/widget/space/canvas/canvas-to-look.pkg
    package p2l =  packed_to_look;				# packed_to_look		is from   src/lib/x-kit/widget/space/packed/packed-to-look.pkg

    package l2b =  look_to_bounce;				# look_to_bounce		is from   src/lib/x-kit/widget/space/bounce/look-to-bounce.pkg
    package l2c =  look_to_canvas;				# look_to_canvas		is from   src/lib/x-kit/widget/space/canvas/look-to-canvas.pkg
    package l2p =  look_to_packed;				# look_to_packed		is from   src/lib/x-kit/widget/space/packed/look-to-packed.pkg

    package s2g =  space_to_gui;				# space_to_gui			is from   src/lib/x-kit/widget/gui/space-to-gui.pkg
    package l2g =  look_to_gui;					# look_to_gui			is from   src/lib/x-kit/widget/gui/look-to-gui.pkg
    package c2g =  client_to_gui;				# client_to_gui			is from   src/lib/x-kit/widget/gui/client-to-gui.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg

    package xg  =  xgeometry;					# xgeometry			is from   src/lib/std/2d/xgeometry.pkg

    package exp =  xserver;					# xserver			is from   src/lib/x-kit/xclient/src/window/xserver.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg
herein

    package gui_boss_imp
    :       Gui_Boss_Imp												# Gui_Boss_Imp		is from   src/lib/x-kit/widget/gui/gui-boss-imp.api
    {
	#
	include client_to_gui;												# client_to_gui		is from   src/lib/x-kit/widget/gui/client-to-gui.pkg
	#
	Gui_Boss_State													# Holds all nonephemeral mutable state maintained by shape.
	  =
	  {
	    gui_tree:		Ref( Null_Or( gt::Gui_Tree ) )
	  };

	Imports = {													# Ports we use, provided by other imps.
		    int_sink:			Int -> Void,
		    appwindow:			aw::Appwindow,	
		    bounce_theme:		bt::Bounce_Theme,
		    canvas_theme:		ct::Canvas_Theme,
		    packed_theme:		tp::Packed_Theme
		  };

	Me_Slot = Mailslot( { imports:		Imports,
			      me:		Gui_Boss_State,
			      gui_boss_arg:	Gui_Boss_Arg,
			      run_gun':		Run_Gun,
			      end_gun':		End_Gun
			    }
			  );

	Exports	= {													# Ports we provide for use by other imps.
		    client_to_gui:	Client_To_Gui
		  };


	Gui_Boss_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);

	Bounce_Imps
	  =
	  Ref( im::Map( { look_to_bounce:	l2b::Look_To_Bounce,							# Possibly this should be stored in Gui_Tree rather than here; time will tell. This is a good first try.
			  bounce_space:		os::Bounce_Space,
			  endstate_oneshot:	Oneshot_Maildrop( os::Bounce_Space_Arg )
			}
	     )        );

	Canvas_Imps
	  =
	  Ref( im::Map( { look_to_canvas:	l2c::Look_To_Canvas,							# Possibly this should be stored in Gui_Tree rather than here; time will tell. This is a good first try.
			  canvas_space: 	cs::Canvas_Space,
			  endstate_oneshot:	Oneshot_Maildrop( cs::Canvas_Space_Arg )
			}
	     )        );

	Packed_Imps
	  =
	  Ref( im::Map( { look_to_packed:	l2p::Look_To_Packed,							# Possibly this should be stored in Gui_Tree rather than here; time will tell. This is a good first try.
			  packed_space: 	ps::Packed_Space,
			  endstate_oneshot:	Oneshot_Maildrop( ps::Packed_Space_Arg )
			}
	     )        );


	Site = Ref( xg::Box );												# Pixel-rectangle assigned to the widget, in window coordinates.

	Iostate = { wants_keystrokes:	Ref(Bool),
		    wants_mouseclicks:	Ref(Bool)
		  };

	Look_Imp_Info
	  =
	  { gui_to_look:		g2l::Gui_To_Look,								# We use this to make requests of visible widgets.
	    foreground:			Ref(Null_Or(List(exp::Draw_Op))),
	    background:			Ref(Null_Or(List(exp::Draw_Op))),
	    site:			Site,
	    iostate:			Iostate
	  };

	Look_Imps
	  =
	  Ref( im::Map( Look_Imp_Info ) );										# We use this to make requests of visible widgets.

	Runstate =    {													# These values will be statically globally visible throughout the code body for the imp.
			me:			Gui_Boss_State,								# State which is preserved across imp shutdown/restart cycles.
			gui_boss_arg:		Gui_Boss_Arg,
			imports:		Imports,								# Imps to which we send requests.
			to:			Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
			end_gun':		End_Gun,								# We shut down the microthread when this fires.
			bounce_imps:		Bounce_Imps,								# Holds our os::Bounce_Space instances -- can't put them directly in Gui_Tree due to circularity.
			canvas_imps:		Canvas_Imps,								# Holds our cs::Canvas_Space instances -- can't put them directly in Gui_Tree due to circularity.
			packed_imps:		Packed_Imps,								# Holds our ps::Packed_Space instances -- can't put them directly in Gui_Tree due to circularity.
			look_imps:		Look_Imps,								# Holds look-imps for all the widgets in our gui.
			look_to_gui:		l2g::Look_To_Gui,							# Interface for look-imps to contact us.
			space_to_gui:		s2g::Space_To_Gui,							# Interface for space-imps to contact us.
			current_frame_number:	Ref(Int),								# We count frames for convenience of widgets and debugging.
			seconds_per_frame:	Ref(Float)								# Primarily so widgets can do motion blurring if they wish.
		      };

	Gui_Boss_Q    = Mailqueue( Runstate -> Void );

	fun run ( gui_boss_q:		Gui_Boss_Q,									# 
		  #
		  runstate as
		  {													# These values will be statically globally visible throughout the code body for the imp.
		    me:				Gui_Boss_State,								# State which is preserved across imp shutdown/restart cycles.
		    gui_boss_arg:		Gui_Boss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# We shut down the microthread when this fires.
		    bounce_imps:		Bounce_Imps,								# Holds our os::Bounce_Space instances -- can't put them directly in Gui_Tree due to circularity.
		    canvas_imps:		Canvas_Imps,								# Holds our cs::Canvas_Space instances -- can't put them directly in Gui_Tree due to circularity.
		    packed_imps:		Packed_Imps,								# Holds our ps::Packed_Space instances -- can't put them directly in Gui_Tree due to circularity.
		    look_imps:			Look_Imps,								# Holds look-imps for all the widgets in our gui.
		    look_to_gui:		l2g::Look_To_Gui,							# Interface for look-imps to contact us.
		    space_to_gui:		s2g::Space_To_Gui,							# Interface for space-imps to contact us.
		    current_frame_number:	Ref(Int),								# We count frames for convenience of widgets and debugging.
		    seconds_per_frame:		Ref(Float)								# Primarily so widgets can do motion blurring if they wish.
		  }
		)
	    =
	    {	make_thread'  [ THREAD_NAME "frameclock" ]  frameclock  end_gun';					# Start up frameclock thread which tells us when it is time to draw a new frame.
		#
		loop ();
	    }
	    where

foo = REF 19;
		fun display_one_frame ({ me, look_imps, ... }: Runstate)
		    =
		    {
foo := *foo + 1;
nb {. sprintf "(display_one_frame called %d...  -- gui-boss-imp.pkg)" *foo;};
if (*foo == 20)
nb {. sprintf "display_one_frame called %d...  -- gui-boss-imp.pkg" *foo;};
foo := 1;
fi;
			imps =  im::vals_list  *look_imps;

			fun draw_foreground_or_background  null_or_displaylist
			    =
			    case null_or_displaylist
				#
				NULL =>
				    {
					();
				    };

				THE draw_ops
				    =>
				    {
					imports.appwindow.draw_ops  draw_ops;
				    };
			    esac;

			apply' imps  {.
			    #imp -> { foreground, background, ... };
			    #
			    draw_foreground_or_background  *background;
			    draw_foreground_or_background  *foreground;
			};
		    };	

		# This fn provides the body for a little microthread which just
		# loops ten times a second telling our main thread to disply frame:
		#
		fun frameclock end_gun'
		    =
		    loop ()
		    where
			count = REF 19;

			fun loop ()
			    =
			    {
				do_one_mailop [
				    #
				    end_gun'
					==>
					{.
nb {. sprintf "clock microthread calling thread_exit.  -- gui-boss-imp.pkg" ;};
					    thread_exit { success => TRUE };
					},
				    #
				    timeout_in' *seconds_per_frame
					==>
					{.
count := *count + 1;
if (*count == 20)
nb {. sprintf "clock microthread calling display_one_frame  -- gui-boss-imp.pkg" ;};
count := 1;
fi;
					    put_in_mailqueue  (gui_boss_q, display_one_frame);
					}
				];

				loop ();
			    };
		    end;


		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    end_gun'                        ==>  shut_down_gui_boss_imp',
			    take_from_mailqueue' gui_boss_q ==>  do_gui_boss_plea
			];

			loop ();
		    }	
		    where
			fun do_gui_boss_plea  thunk
			    =
			    thunk runstate;

			fun shut_down_gui_boss_imp' ()
			    =
			    {
				thread_exit { success => TRUE };							# Will not return.	
			    };
		    end;
	    end;	

	fun end_gui'
	      (
		{ me:			Gui_Boss_State,									# State which is preserved across imp shutdown/restart cycles.
		  gui_boss_arg:		Gui_Boss_Arg,
		  imports:		Imports,									# Imps to which we send requests.
		  to:			Replyqueue,									# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		  end_gun':		End_Gun,									# We shut down the microthread when this fires.
		  bounce_imps:		Bounce_Imps,									# Holds our os::Bounce_Space instances -- can't put them directly in Gui_Tree due to circularity.
		  canvas_imps:		Canvas_Imps,									# Holds our cs::Canvas_Space instances -- can't put them directly in Gui_Tree due to circularity.
		  packed_imps:		Packed_Imps,									# Holds our ps::Packed_Space instances -- can't put them directly in Gui_Tree due to circularity.
		  look_imps:		Look_Imps,									# Holds look-imps for all the widgets in our gui.
		  look_to_gui:		l2g::Look_To_Gui,								# Interface for look-imps to contact us.
		  space_to_gui:		s2g::Space_To_Gui,								# Interface for space-imps to contact us.
		  current_frame_number:	Ref(Int),									# We count frames for convenience of widgets and debugging.
		  seconds_per_frame:	Ref(Float)									# Primarily so widgets can do motion blurring if they wish.
		}:			Runstate
	      )
	    =
	    case *me.gui_tree
		#
		THE gui_tree
		    =>
		    {
nb {. sprintf "end_gui' doing fire_end_gun() -- gui-boss-imp.pkg" ;};
			gui_tree.fire_end_gun ();									# Shut down GUI impnet.
nb {. sprintf "end_gui' done  fire_end_gun() -- gui-boss-imp.pkg" ;};
			result = gui_tree__to__gui_plan  gui_tree;							# Return sufficient information to recreate the GUI.

			bounce_imps		:=  im::empty;
			canvas_imps		:=  im::empty;
			packed_imps		:=  im::empty;
			look_imps		:=  im::empty;
nb {. sprintf "end_gui': packed_imps := im::empty   -- gui-boss-imp.pkg" ;};

			result;
		    };													#

		NULL =>
		    {   msg = "end_gui called before run_gui?!\n";
			print msg;
			raise exception FAIL msg;
		    };
	    esac
	    where
		fun gui_tree__to__gui_plan
		    # 
		    (gui_tree: 	gt::Gui_Tree)
		    :
		    ( ps::Packed_Space_Arg,
		      gp::Packed_Widget
		    )
		    =
		    {
nb {. sprintf "gui_tree__to__gui_plan/AAA" ;};
			gui_tree -> { fire_end_gun:	Void -> Void,							# Signal which will shut down the GUI impnet.
				      #
				      packed_space_id:	gt::Packed_Space_Id,						# Runtime GUI state synthesized locally per client spec.
				      packed_widget:	gt::Packed_Widget						# "                                       ".
				    };

nb {. sprintf "gui_tree__to__gui_plan/BBB -- calling do_packed_widget..." ;};
			packed_widget''
			    =
			    do_packed_widget  packed_widget;

			(im::get_or_raise_exception_not_found (*packed_imps, (id_to_int packed_space_id)))
			    ->
			    { look_to_packed, packed_space, endstate_oneshot };	

nb {. sprintf "gui_tree__to__gui_plan/ZZZ -- called  do_packed_widget..." ;};
			( get_from_oneshot   endstate_oneshot,								# Read final state of packed-space-imp -- incidentally confirming that it has completed its shutdown.
			  packed_widget''
			);
		    }

		also
		fun do_packed_widget  (packed_widget: gt::Packed_Widget)
		    =
		    case packed_widget
			#
			gt::ROW	{ widgets: List( (gt::Packed_Widget, gt::Packed_Layout_Hints, List(plh::Packed_Space_Layout_Hint)) ) }
			    =>
			    gp::ROW (map  do_widget  widgets)
				    where
					fun do_widget ( packed_widget:	gt::Packed_Widget,
							hints: 		gt::Packed_Layout_Hints,
							raw_hints:	List(plh::Packed_Space_Layout_Hint)
						      )
					    =
					    ( do_packed_widget  packed_widget,
					      raw_hints
					    );
				    end;	

			gt::COL	{ widgets: List( (gt::Packed_Widget, gt::Packed_Layout_Hints, List(plh::Packed_Space_Layout_Hint)) ) }
			    =>
			    gp::COL (map  do_widget  widgets)
				    where
					fun do_widget ( packed_widget:	gt::Packed_Widget,
							hints:	 	gt::Packed_Layout_Hints,
							raw_hints:	List(plh::Packed_Space_Layout_Hint)
						      )
					    =
					    ( do_packed_widget  packed_widget,
					      raw_hints
					    );
				    end;	

			gt::LABEL r
			    =>
			    gp::LABEL ( get_from_oneshot   r.endstate_oneshot,			# Read and return final state of state-imp -- incidentally confirming that it has completed its shutdown.
					get_from_oneshot    r.endlook_oneshot			# Read and return final state of  look-imp -- incidentally confirming that it has completed its shutdown.
				      );

			gt::KNOB  r
			    =>
			    gp::KNOB  ( get_from_oneshot   r.endstate_oneshot,			# Read and return final state of state-imp -- incidentally confirming that it has completed its shutdown.
					get_from_oneshot    r.endlook_oneshot			# Read and return final state of  look-imp -- incidentally confirming that it has completed its shutdown.
				      );

			gt::XSLIDER r
			    =>
			    gp::XSLIDER ( get_from_oneshot   r.endstate_oneshot,		# Read and return final state of state-imp -- incidentally confirming that it has completed its shutdown.
					  get_from_oneshot    r.endlook_oneshot			# Read and return final state of  look-imp -- incidentally confirming that it has completed its shutdown.
					);


			gt::YSLIDER r
			    =>
			    gp::YSLIDER ( get_from_oneshot   r.endstate_oneshot,		# Read and return final state of state-imp -- incidentally confirming that it has completed its shutdown.
					  get_from_oneshot    r.endlook_oneshot			# Read and return final state of  look-imp -- incidentally confirming that it has completed its shutdown.
					);

			#
			gt::CANVAS_SPACE  canvas_space
			    =>
{
nb {. sprintf "gui_tree__to__gui_plan: do_packed_widget: gt::CANVAS_SPACE..." ;};
result =
			    do_canvas_space  canvas_space;
result; };

			gt::BOUNCE_SPACE  bounce_space
			    =>
{
nb {. sprintf "gui_tree__to__gui_plan: do_packed_widget: gt::BOUNCE_SPACE..." ;};
result =
			    do_bounce_space  bounce_space;
result; };

			gt::NULL_PACKED_WIDGET
			    =>
			    gp::NULL_PACKED_WIDGET;
		    esac


		also
		fun do_bounce_space r
		    =
		    {
			widgets =  do_bounce_widgets  r.widgets;
			#
			(im::get_or_raise_exception_not_found (*bounce_imps, (id_to_int r.bounce_space_id)))
			    ->
			    { bounce_space, look_to_bounce, endstate_oneshot };

			arg =  get_from_oneshot  endstate_oneshot;

		        gp::BOUNCE_SPACE (arg, widgets);
		    }

		also
		fun do_bounce_widgets (widgets':  List ((gt::Bounce_Widget, List(blh::Bounce_Space_Layout_Hint))))
		    =
		    {
			widgets'' = map  do_widget  widgets'
				    where
					fun do_widget' (widget': gt::Bounce_Widget)
					    =
					    case widget'
						#
						gt::BALL r
						    =>
						    gp::BALL ( get_from_oneshot   r.endstate_oneshot,	# Read and return final state of state-imp -- incidentally confirming that it has completed its shutdown.
							       get_from_oneshot    r.endlook_oneshot	# Read and return final state of  look-imp -- incidentally confirming that it has completed its shutdown.
							     );
					    esac;

					fun do_widget (widget': gt::Bounce_Widget,  layout_hints:  List(blh::Bounce_Space_Layout_Hint))
					    =
					    {   widget'' = do_widget'  widget';
						#
						(widget'', layout_hints);
					    };
				    end;

			widgets'';
		    }


		also
		fun do_canvas_space r
		    =
		    {	widgets =  do_canvas_widgets  r.widgets;
			#
			(im::get_or_raise_exception_not_found (*canvas_imps, (id_to_int r.canvas_space_id)))
			    ->
			    { canvas_space, look_to_canvas, endstate_oneshot };

			arg =  get_from_oneshot  endstate_oneshot;

		        gp::CANVAS_SPACE (arg, widgets);
		    }

		also
		fun do_canvas_widgets (widgets':  List ((gt::Canvas_Widget, List(clh::Canvas_Space_Layout_Hint))))
		    =
		    {
			widgets'' = map  do_widget  widgets'
				    where
					fun do_widget' (widget': gt::Canvas_Widget)
					    =
					    case widget'
						#
						gt::NODE r
						    =>
						    gp::NODE ( get_from_oneshot   r.endstate_oneshot,	# Read and return final state of state-imp -- incidentally confirming that it has completed its shutdown.
							       get_from_oneshot    r.endlook_oneshot	# Read and return final state of  look-imp -- incidentally confirming that it has completed its shutdown.
							     );

						gt::PACKED_SPACE
						      { packed_space_id:	gt::Packed_Space_Id,
							packed_widget:		gt::Packed_Widget
						      }
						    =>
						    {	packed_widget'' =  do_packed_widget packed_widget;
							#
							(im::get_or_raise_exception_not_found (*packed_imps, (id_to_int packed_space_id)))
							    ->
							    { look_to_packed, packed_space, endstate_oneshot };

							gp::PACKED_SPACE
							  (
							    get_from_oneshot   endstate_oneshot,		# Read and return final state of packed-space-imp -- incidentally confirming that it has completed its shutdown.
							    packed_widget''
							  );
						    };
					    esac;

					fun do_widget (widget': gt::Canvas_Widget,  layout_hints:  List(clh::Canvas_Space_Layout_Hint))
					    =
					    {   widget'' = do_widget'  widget';
						#
						(widget'', layout_hints);
					    };
				    end;

			widgets'';
		    };													# fun do_canvas_widgets
	    end;

	fun run_gui'
	      (
		{ me:			Gui_Boss_State,									# State which is preserved across imp shutdown/restart cycles.
		  gui_boss_arg:		Gui_Boss_Arg,
		  imports:		Imports,									# Imps to which we send requests.
		  to:			Replyqueue,									# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		  end_gun':		End_Gun,									# We shut down the microthread when this fires.
		  bounce_imps:		Bounce_Imps,									# Holds our os::Bounce_Space instances -- can't put them directly in Gui_Tree due to circularity.
		  canvas_imps:		Canvas_Imps,									# Holds our cs::Canvas_Space instances -- can't put them directly in Gui_Tree due to circularity.
		  packed_imps:		Packed_Imps,									# Holds our ps::Packed_Space instances -- can't put them directly in Gui_Tree due to circularity.
		  look_imps:		Look_Imps,									# Holds look-imps for all the widgets in our gui.
		  look_to_gui:		l2g::Look_To_Gui,								# Interface for look-imps to contact us.
		  space_to_gui:		s2g::Space_To_Gui,								# Interface for space-imps to contact us.
		  current_frame_number:	Ref(Int),									# We count frames for convenience of widgets and debugging.
		  seconds_per_frame:	Ref(Float)									# Primarily so widgets can do motion blurring if they wish.
		}:			Runstate,
	
		gui_plan:		gp::Gui_Plan,

		gui_startup_complete':	Oneshot_Maildrop(Void)
	      )
	    =
	    {
		

nb {. sprintf "gui-boss/run_gui' constructing gui_tree from gui_plan..." ;};
		gui_tree = gui_plan__to__gui_tree  gui_plan;
nb {. sprintf "gui-boss/run_gui' done constructing gui_tree from gui_plan..." ;};
		me.gui_tree := THE gui_tree;
nb {. sprintf "gui-boss/run_gui' firing run gun..." ;};
		fire_run_gun ();
nb {. sprintf "gui-boss/run_gui' fired  run gun..." ;};

		imports.packed_theme.pass_window_site
		    to
		    (fn ({ size => { high, wide }, ... }: xg::Window_Site)
			=
			{

nb {. sprintf "run_gui': (high,wide) = (%d,%d)  -- gui-boss-imp.pkg" high wide ;};
nb {. sprintf "run_gui': gui_tree.packed_space_id d=%d -- gui-boss-imp.pkg" (id_to_int gui_tree.packed_space_id); };

case (im::get (*packed_imps, (id_to_int gui_tree.packed_space_id)))
THE _ => nb {. sprintf "run_gui': packed_imps(packed_space_id %d) is SET"   (id_to_int gui_tree.packed_space_id); };
NULL  => nb {. sprintf "run_gui': packed_imps(packed_space_id %d) is CLEAR" (id_to_int gui_tree.packed_space_id); };
esac;

			    (im::get_or_raise_exception_not_found (*packed_imps, (id_to_int gui_tree.packed_space_id)))
				->
				{ look_to_packed, packed_space, endstate_oneshot };


nb {. sprintf "run_gui': (high,wide) MAYBE = (%d,%d)  -- gui-boss-imp.pkg" high wide ;};
			    site =  { col => 0,  high,								# Allocate all of window pixel area to widgets in gui_tree.packed_widget widget-tree.
				      row => 0,  wide
				    }
				    : xg::Box;

nb {. sprintf "run_gui': (high,wide) STILL = (%d,%d)  -- gui-boss-imp.pkg" high wide ;};
			    packed_space.pass_re_siting_done_flag (site, gui_tree.packed_widget)
				to
				{.
nb {. sprintf "gui-boss/run_gui' firing gui_startup_complete'" ;};
			    put_in_oneshot  (gui_startup_complete', ());
nb {. sprintf "gui-boss/run_gui' fired  gui_startup_complete'" ;};

nb {. sprintf "run_gui': re-siting of packed-space %d is complete" (id_to_int gui_tree.packed_space_id); };
				}; 
			    
			}
		    );
	    }
	    where
		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		fun digest_packed_space_layout_hints  (options: List(plh::Packed_Space_Layout_Hint))  { share }
		    =
		    {   my_share	=  REF share;
			#
			apply  do_option  options
			where
			    fun do_option (plh::SHARE	f) =   if (f > 0.0)   my_share := f;   fi;		# Ignore nonsensical values like 0.0 or negative. This eliminates divide-by-zero risks later.
			end;

			{ share			=>  *my_share
			};
		    };

		fun gui_plan__to__gui_tree
		    (
		      packed_space_arg:		ps::Packed_Space_Arg,
		      packed_widget:		gp::Packed_Widget
		    )
		    : gt::Gui_Tree
		    =
		    {
			(do_packed_space  packed_space_arg)
			    ->
			    stuff as { look_to_packed, packed_space, endstate_oneshot };

			packed_space_id = packed_space.id;

nb {. sprintf "gui_plan__to__gui_tree: doing packed_imps := ... %d" (id_to_int packed_space.id); };
			packed_imps :=  im::set (*packed_imps, (id_to_int packed_space_id), stuff);
nb {. sprintf "gui_plan__to__gui_tree: done  packed_imps := ... %d" (id_to_int packed_space.id); };
case (im::get (*packed_imps, (id_to_int packed_space_id)))
THE _ => nb {. sprintf "gui_plan__to__gui_tree: im::set TOOK" ;};
NULL  => nb {. sprintf "gui_plan__to__gui_tree: im::set FAILED" ;};
esac;

			(do_packed_widget (packed_widget, look_to_packed))
			    ->
			    packed_widget;

			{ fire_end_gun,
			  packed_space_id,
			  packed_widget
			};
		    }
		    where
			fun make_look_imp_info
			      (
				gui_to_look:	g2l::Gui_To_Look
			      )
			      =
			      { gui_to_look,
				#
				foreground	=>  REF NULL,
				background	=>  REF NULL,
				#
				site		=>  REF { row => 0, col => 0, high => 0, wide => 0 },
				#
				iostate		=>  { wants_keystrokes  => REF FALSE,								# The remaining lines construct the gui-tree node for the widget.
						      wants_mouseclicks => REF FALSE
						    }
			      };

			fun do_packed_space  (packed_space_arg: ps::Packed_Space_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( ps::Packed_Space_Arg  );		# When endgun fires we'll read back final packed_space_imp state via this oneshot.
				#
				packed_space_egg
				    =
				    pai::make_packed_space_egg  packed_space_arg  (THE endstate_oneshot);

				(packed_space_egg ())
				    ->
				    (exports, packed_space_egg');

				exports ->  { look_to_packed, packed_space };

nb {. sprintf "do_packed_space: doing packed_imps := ... %d   II" (id_to_int packed_space.id) ;};
				packed_imps :=  im::set (*packed_imps, (id_to_int packed_space.id), { look_to_packed, packed_space, endstate_oneshot });
nb {. sprintf "do_packed_space: done  packed_imps := ... %d   II" (id_to_int packed_space.id) ;};
case (im::get (*packed_imps, (id_to_int packed_space.id)))
THE _ => nb {. sprintf "do_packed_space: im::set TOOK" ;};
NULL  => nb {. sprintf "do_packed_space: im::set FAILED" ;};
esac;

# NOT VERY SOON add look_to_gui to imports:
				packed_space_imports =  { int_sink => fn (i: Int) = (), space_to_gui };

				packed_space_egg' (packed_space_imports, run_gun', end_gun');

				{ look_to_packed, packed_space, endstate_oneshot };
			    }

			also
			fun do_bounce_space  (bounce_space_arg: os::Bounce_Space_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( os::Bounce_Space_Arg  );		# When endgun fires we'll read back final bounce_space_imp state via this oneshot.
				#
				bounce_space_egg
				    =
				    boi::make_bounce_space_egg  bounce_space_arg  (THE endstate_oneshot);

				(bounce_space_egg ())
				    ->
				    (exports, bounce_space_egg');

				exports -> { bounce_space, look_to_bounce };

				bounce_imps :=  im::set (*bounce_imps,  id_to_int bounce_space.id,  { bounce_space, look_to_bounce, endstate_oneshot });

# NOT VERY SOON add look_to_gui to imports:
				bounce_space_imports =  { int_sink => fn (i: Int) = () };

				bounce_space_egg' (bounce_space_imports, run_gun', end_gun');

				{ bounce_space, look_to_bounce, endstate_oneshot };
			    }

			also
			fun do_canvas_space  (canvas_space_arg: cs::Canvas_Space_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( cs::Canvas_Space_Arg  );		# When endgun fires we'll read back final canvas_space_imp state via this oneshot.
				#
				canvas_space_egg
				    =
				    cai::make_canvas_space_egg  canvas_space_arg  (THE endstate_oneshot);

				(canvas_space_egg ())
				    ->
				    (exports, canvas_space_egg');

				exports -> { canvas_space, look_to_canvas };

				canvas_imps :=  im::set (*canvas_imps,  id_to_int canvas_space.id,  { canvas_space, look_to_canvas, endstate_oneshot });

# NOT VERY SOON add look_to_gui to imports:
				canvas_space_imports =  { int_sink => fn (i: Int) = () };

				canvas_space_egg' (canvas_space_imports, run_gun', end_gun');

				{ canvas_space, look_to_canvas, endstate_oneshot };
			    }

			also
			fun do_bounce_widget (bounce_widget: gp::Bounce_Widget,  look_to_bounce: l2b::Look_To_Bounce)
			    =
			    case bounce_widget
				#
				gp::BALL
				    ( ball_arg as (ball_state_needs, ball_state_options):		bs::Ball_Arg,
				      ball_look_arg:							bl::Ball_Look_Arg
				    )
				    =>
				    {   endstate_oneshot     =  make_oneshot_maildrop():  Oneshot_Maildrop( bs::Ball_Arg       );		# When endgun fires we'll read back final ball_state state via this oneshot.
					endlook_oneshot	     =  make_oneshot_maildrop():  Oneshot_Maildrop( bl::Ball_Look_Arg  );		# When endgun fires we'll read back final ball_state state via this oneshot.

					ball_state_oneshot   =  make_oneshot_maildrop():  Oneshot_Maildrop( bs::Ball_State );			# We'll get our ball_state port via this at ball-state-imp startup.
					ball_look_oneshot    =  make_oneshot_maildrop():  Oneshot_Maildrop( bl::Ball_Look  );			# We'll get our ball_look  port via this at ball-look-imp startup.

					ball_state_thunk     =   (fn ball_state = put_in_oneshot (ball_state_oneshot, ball_state));		# These two paragraphs just arrange for the above to be called.
					ball_look_thunk      =   (fn ball_look  = put_in_oneshot (ball_look_oneshot,  ball_look));

					ball_state_options   =   (bs::BALL_STATE_CALLBACK ball_state_thunk)  !  ball_state_options;
					ball_look_arg	     =   (bl::BALL_LOOK_CALLBACK   ball_look_thunk)  !  ball_look_arg;
					ball_arg	     =   (ball_state_needs, ball_state_options);



					# Start up the 'state' + 'look' imp-pair for the widget:

					(imports.bounce_theme.ball
					    (ball_arg, ball_look_arg, look_to_bounce)
					    ( THE endstate_oneshot,
					      THE endlook_oneshot
					)   )
					    ->
					    bounce_widget_egg;

					(bounce_widget_egg ()) -> (exports, bounce_widget_egg');

					exports -> { gui_to_look, bounce_to_look };
					imports =  { look_to_gui, int_sink => (fn (i: Int) = ()) };

					bounce_widget_egg' (imports, run_gun', end_gun');
					#
					state   =  get_from_oneshot   ball_state_oneshot;
					look    =  get_from_oneshot   ball_look_oneshot;

					look_imp_info  =  make_look_imp_info  gui_to_look;
					look_imps    :=   im::set (*look_imps,  id_to_int look_to_gui.id,  look_imp_info );

					gt::BALL { bounce_to_look, state, look, endstate_oneshot, endlook_oneshot };
				    };
			    esac


			also
			fun do_canvas_widget (canvas_widget: gp::Canvas_Widget,  look_to_canvas: l2c::Look_To_Canvas)
			    =
			    case canvas_widget
				#
				gp::PACKED_SPACE  (packed_space_arg:  ps::Packed_Space_Arg,  packed_widget: gp::Packed_Widget)
				    =>
				    {
					(do_packed_space  packed_space_arg)
					    ->
					    stuff as { look_to_packed, packed_space, endstate_oneshot };

nb {. sprintf "do_canvas_widget: doing packed_imps := ... %d   III" (id_to_int packed_space.id); };
					packed_imps :=  im::set (*packed_imps, (id_to_int packed_space.id), stuff);
nb {. sprintf "do_canvas_widget: done  packed_imps := ... %d   III" (id_to_int packed_space.id); };
case (im::get (*packed_imps, (id_to_int packed_space.id)))
THE _ => nb {. sprintf "do_canvas_widget: im::set TOOK" ;};
NULL  => nb {. sprintf "do_canvas_widget: im::set FAILED" ;};
esac;

					(do_packed_widget (packed_widget, look_to_packed))
					    ->
					    packed_widget;

					gt::PACKED_SPACE { packed_space_id => packed_space.id,  packed_widget };
				    };

				gp::NODE
				    ( node_arg as (node_state_needs, node_state_options):		ns::Node_Arg,
				      node_look_arg:							nl::Node_Look_Arg
				    )
				    =>
				    {   endstate_oneshot     =  make_oneshot_maildrop():  Oneshot_Maildrop( ns::Node_Arg       );		# When endgun fires we'll read back final nodel_state state via this oneshot.
					endlook_oneshot      =  make_oneshot_maildrop():  Oneshot_Maildrop( nl::Node_Look_Arg  );		# When endgun fires we'll read back final nodel_state state via this oneshot.

					node_state_oneshot   =  make_oneshot_maildrop():  Oneshot_Maildrop( ns::Node_State );			# We'll get our node_state port via this at node-state-imp startup.
					node_look_oneshot    =  make_oneshot_maildrop():  Oneshot_Maildrop( nl::Node_Look  );			# We'll get our node_look  port via this at node-look-imp startup.

					node_state_thunk     =   (fn node_state = put_in_oneshot (node_state_oneshot, node_state));		# These two paragraphs just arrange for the above to be called.
					node_look_thunk      =   (fn node_look  = put_in_oneshot (node_look_oneshot,  node_look));

					node_state_options   =   (ns::NODE_STATE_CALLBACK node_state_thunk)  !  node_state_options;
					node_look_arg	     =   (nl::NODE_LOOK_CALLBACK   node_look_thunk)  !  node_look_arg;
					node_arg	     =   (node_state_needs, node_state_options);



					# Start up the 'state' + 'look' imp-pair for the widget:

					(imports.canvas_theme.node
					    (node_arg, node_look_arg, look_to_canvas)
					    ( THE endstate_oneshot,
					      THE endlook_oneshot
					)   )
					    ->
					    canvas_widget_egg;

					(canvas_widget_egg ()) -> (exports, canvas_widget_egg');

					exports -> { gui_to_look, canvas_to_look };
					imports =  { look_to_gui, int_sink => (fn (i: Int) = ()) };

					canvas_widget_egg' (imports, run_gun', end_gun');
					#
					state = get_from_oneshot   node_state_oneshot;
					look  = get_from_oneshot   node_look_oneshot;

					look_imp_info  =  make_look_imp_info  gui_to_look;
					look_imps     :=  im::set (*look_imps,  id_to_int look_to_gui.id,  look_imp_info );

					gt::NODE { canvas_to_look,  state, look, endstate_oneshot, endlook_oneshot };
				    };
			    esac

			also
			fun do_packed_widget (packed_widget: gp::Packed_Widget, look_to_packed: l2p::Look_To_Packed)				# 'packed_widget' can be a tree of widgets with ROW and COL internal nodes.
			    =
			    case packed_widget
				#
			        gp::ROW	(packed_widgets:	 List( (gp::Packed_Widget, List(plh::Packed_Space_Layout_Hint)) ))		# A row of widgets. The ROW itself is not a widget (given no microthread).
				    =>
				    {
					widgets =   map  do_widget  packed_widgets
						    where
							fun do_widget
							    (
							      packed_widget:	gp::Packed_Widget,
							      layout_hints:	List( plh::Packed_Space_Layout_Hint )
							    )
							    =
							    ( do_packed_widget  (packed_widget, look_to_packed),
							      digest_packed_space_layout_hints  layout_hints  { share => 1.0 },
							      layout_hints	
							    );
						    end;

					gt::ROW { widgets };
				    };

			        gp::COL	(packed_widgets:	 List( (gp::Packed_Widget, List(plh::Packed_Space_Layout_Hint)) ))		# A column of widgets. The COL itself is not a widget (given no microthread).
				    =>
				    {
					widgets =   map  do_widget  packed_widgets
						    where
							fun do_widget
							    (
							      packed_widget:	gp::Packed_Widget,
							      layout_hints:	List( plh::Packed_Space_Layout_Hint )
							    )
							    =
							    ( do_packed_widget  (packed_widget, look_to_packed),
							      digest_packed_space_layout_hints  layout_hints  { share => 1.0 },
							      layout_hints	
							    );
						    end;

					gt::COL { widgets };
				    };

			        gp::LABEL
				    ( label_arg      as (label_state_needs, label_state_options):		ls::Label_Arg,
				      label_look_arg as (		    label_look_options):		ll::Label_Look_Arg
				    )
				    =>
				    {   endstate_oneshot     =  make_oneshot_maildrop():  Oneshot_Maildrop( ls::Label_Arg       );		# When endgun fires we'll read back final label_state state via this oneshot.
					endlook_oneshot      =  make_oneshot_maildrop():  Oneshot_Maildrop( ll::Label_Look_Arg  );		# When endgun fires we'll read back final label_state state via this oneshot.

					label_state_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( ls::Label_State );			# We'll get our label_state port via this at label-state-imp startup.
					label_look_oneshot   =  make_oneshot_maildrop():  Oneshot_Maildrop( ll::Label_Look  );			# We'll get our label_look  port via this at label-look-imp startup.

					label_state_thunk    =   (fn label_state = put_in_oneshot (label_state_oneshot, label_state));		# These two paragraphs just arrange for the above to be called.
					label_look_thunk     =   (fn label_look  = put_in_oneshot (label_look_oneshot,  label_look));

					label_state_options  =   (ls::LABEL_STATE_CALLBACK label_state_thunk)  !  label_state_options;

					label_look_options   =   (ll::LABEL_LOOK_CALLBACK  label_look_thunk )  !  label_look_options;

					
					label_look_arg	     =   (                   label_look_options );
					label_arg	     =   (label_state_needs, label_state_options);



					# Start up the 'state' + 'look' imp-pair for the widget:

					(imports.packed_theme.label
					    (label_arg, label_look_arg, look_to_packed)
					    ( THE endstate_oneshot,
					      THE endlook_oneshot
					) )
					    ->
					    packed_widget_egg;

					(packed_widget_egg ()) -> (exports, packed_widget_egg');

					exports -> { gui_to_look, packed_to_look };
					imports =  { look_to_gui, int_sink => (fn (i: Int) = ()) };

					packed_widget_egg' (imports, run_gun', end_gun');
					#
					state = get_from_oneshot   label_state_oneshot;
					look  = get_from_oneshot   label_look_oneshot;

					look_imp_info  =  make_look_imp_info  gui_to_look;
					look_imps     :=  im::set (*look_imps,  id_to_int look_to_gui.id,  look_imp_info );

					gt::LABEL { packed_to_look, state, look, endstate_oneshot,endlook_oneshot };
				    };

			        gp::KNOB
				    ( slider_arg as (slider_state_needs, slider_state_options):		ss::Slider_Arg,
				      knob_look_arg:							kl::Knob_Look_Arg
				    )
				    =>
				    {   endstate_oneshot     =  make_oneshot_maildrop():  Oneshot_Maildrop( ss::Slider_Arg     );		# When endgun fires we'll read back final slider_state state via this oneshot.
					endlook_oneshot      =  make_oneshot_maildrop():  Oneshot_Maildrop( kl::Knob_Look_Arg  );		# When endgun fires we'll read back final   look_state state via this oneshot.

					slider_state_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( ss::Slider_State );			# We'll get our slider_state port via this at slider-state-imp startup.
					knob_look_oneshot    =  make_oneshot_maildrop():  Oneshot_Maildrop( kl::Knob_Look  );			# We'll get our knob_look    port via this at knob-look-imp startup.

					slider_state_thunk   =   (fn slider_state = put_in_oneshot (slider_state_oneshot, slider_state));	# These two paragraphs just arrange for the above to be called.
					knob_look_thunk      =   (fn knob_look    = put_in_oneshot (knob_look_oneshot,  knob_look));

					slider_state_options =   (ss::SLIDER_STATE_CALLBACK slider_state_thunk)  !  slider_state_options;
					knob_look_arg	     =   (kl::KNOB_LOOK_CALLBACK       knob_look_thunk)  !  knob_look_arg;
					slider_arg	     =   (slider_state_needs, slider_state_options);



					# Start up the 'state' and 'look' imp-pair for the widget:

					(imports.packed_theme.knob
					    (slider_arg, knob_look_arg, look_to_packed)
					    ( THE endstate_oneshot,
					      THE endlook_oneshot
					)   )
					    ->
					    packed_widget_egg;

					(packed_widget_egg ()) -> (exports, packed_widget_egg');

					exports -> { gui_to_look, packed_to_look };
					imports =  { look_to_gui, int_sink => (fn (i: Int) = ()) };

					packed_widget_egg' (imports, run_gun', end_gun');
					#
					state = get_from_oneshot   slider_state_oneshot;
					look  = get_from_oneshot   knob_look_oneshot;

					look_imp_info  =  make_look_imp_info  gui_to_look;
					look_imps     :=  im::set (*look_imps,  id_to_int look_to_gui.id,  look_imp_info );

					gt::KNOB { packed_to_look,  state, look, endstate_oneshot, endlook_oneshot };
				    };

			        gp::XSLIDER
				    ( slider_arg as (slider_state_needs, slider_state_options):		ss::Slider_Arg,
				      xslider_look_arg:							xl::Xslider_Look_Arg
				    )
				    =>
				    {   endstate_oneshot     =  make_oneshot_maildrop():  Oneshot_Maildrop( ss::Slider_Arg      );		# When endgun fires we'll read back final state-imp state via this oneshot.
					endlook_oneshot      =  make_oneshot_maildrop():  Oneshot_Maildrop(xl::Xslider_Look_Arg );		# When endgun fires we'll read back final  look-imp state via this oneshot.

					slider_state_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( ss::Slider_State );			# We'll get our slider_state port via this at slider-state-imp startup.
					xslider_look_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( xl::Xslider_Look  );		# We'll get our xslider_look port via this at xslider-look-imp startup.

					slider_state_thunk   =   (fn slider_state = put_in_oneshot (slider_state_oneshot, slider_state));	# These two paragraphs just arrange for the above to be called.
					xslider_look_thunk   =   (fn xslider_look = put_in_oneshot (xslider_look_oneshot, xslider_look));

					slider_state_options =   (ss::SLIDER_STATE_CALLBACK slider_state_thunk)  !  slider_state_options;
					xslider_look_arg     =   (xl::XSLIDER_LOOK_CALLBACK xslider_look_thunk)  !  xslider_look_arg;
					slider_arg	     =   (slider_state_needs, slider_state_options);



					# Start up the 'state' and 'look' imp-pair for the widget:

					(imports.packed_theme.xslider
					    (slider_arg, xslider_look_arg, look_to_packed)
					    ( THE endstate_oneshot,
					      THE endlook_oneshot
					)   )
					    ->
					    packed_widget_egg;

					(packed_widget_egg ()) -> (exports, packed_widget_egg');

					exports -> { gui_to_look, packed_to_look };
					imports =  { look_to_gui, int_sink => (fn (i: Int) = ()) };

					packed_widget_egg' (imports, run_gun', end_gun');
					#
					state = get_from_oneshot   slider_state_oneshot;
					look  = get_from_oneshot   xslider_look_oneshot;

					look_imp_info  =  make_look_imp_info  gui_to_look;
					look_imps     :=  im::set (*look_imps,  id_to_int look_to_gui.id,  look_imp_info );

					gt::XSLIDER { packed_to_look,  state, look, endstate_oneshot, endlook_oneshot };
				    };

			        gp::YSLIDER
				    ( slider_arg as (slider_state_needs, slider_state_options):		ss::Slider_Arg,
				      yslider_look_arg:							yl::Yslider_Look_Arg
				    )
				    =>
				    {   endstate_oneshot     =  make_oneshot_maildrop():  Oneshot_Maildrop( ss::Slider_Arg      );		# When endgun fires we'll read back final state-imp state via this oneshot.
					endlook_oneshot      =  make_oneshot_maildrop():  Oneshot_Maildrop(yl::Yslider_Look_Arg );		# When endgun fires we'll read back final  look-imp state via this oneshot.

					slider_state_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( ss::Slider_State );			# We'll get our slider_state port via this at slider-state-imp startup.
					yslider_look_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( yl::Yslider_Look  );		# We'll get our yslider_look port via this at yslider-look-imp startup.

					slider_state_thunk   =   (fn slider_state = put_in_oneshot (slider_state_oneshot, slider_state));	# These two paragraphs just arrange for the above to be called.
					yslider_look_thunk   =   (fn yslider_look = put_in_oneshot (yslider_look_oneshot, yslider_look));

					slider_state_options =   (ss::SLIDER_STATE_CALLBACK slider_state_thunk)  !  slider_state_options;
					yslider_look_arg     =   (yl::YSLIDER_LOOK_CALLBACK yslider_look_thunk)  !  yslider_look_arg;
					slider_arg	     =   (slider_state_needs, slider_state_options);


					# Start up the 'state' + 'look' imp-pair for the widget:

					(imports.packed_theme.yslider
					    (slider_arg, yslider_look_arg, look_to_packed)
					    ( THE endstate_oneshot,
					      THE endlook_oneshot
					)   )
					    ->
					    packed_widget_egg;

					(packed_widget_egg ()) -> (exports, packed_widget_egg');

					exports -> { gui_to_look, packed_to_look };
					imports =  { look_to_gui, int_sink => (fn (i: Int) = ()) };

					packed_widget_egg' (imports, run_gun', end_gun');
					#
					state =  get_from_oneshot   slider_state_oneshot;
					look  =  get_from_oneshot   yslider_look_oneshot;

					look_imp_info  =  make_look_imp_info  gui_to_look;
					look_imps     :=  im::set (*look_imps,  id_to_int look_to_gui.id,  look_imp_info );

					gt::YSLIDER { packed_to_look,  state, look, endstate_oneshot, endlook_oneshot };
				    };

			        gp::CANVAS_SPACE
				    ( canvas_space_arg:	cs::Canvas_Space_Arg,
				      canvas_widgets:	List((gp::Canvas_Widget, List(clh::Canvas_Space_Layout_Hint)))
				    )
				    =>
				    {
					(do_canvas_space  canvas_space_arg)
					    ->
					    stuff as { canvas_space, look_to_canvas, endstate_oneshot };

					canvas_space_id =  canvas_space.id;

					canvas_imps :=  im::set (*canvas_imps, (id_to_int canvas_space_id), stuff);

					#
					widgets	=   map  do_widget  canvas_widgets
						    where
							fun do_widget (canvas_widget: gp::Canvas_Widget,  hints: List(clh::Canvas_Space_Layout_Hint))
							    =
							    ( do_canvas_widget  (canvas_widget, look_to_canvas),
							      hints
							    );	
						    end;

					gt::CANVAS_SPACE { canvas_space_id,  widgets };
				    };

			        gp::BOUNCE_SPACE
				    ( bounce_space_arg:	os::Bounce_Space_Arg,
				      bounce_widgets:	List((gp::Bounce_Widget, List(blh::Bounce_Space_Layout_Hint)))
				    )
				    =>
				    {
					(do_bounce_space  bounce_space_arg)
					    ->
					    stuff as { bounce_space, look_to_bounce, endstate_oneshot };

					bounce_imps :=  im::set (*bounce_imps, (id_to_int bounce_space.id), stuff);

					#
					widgets	=   map  do_widget  bounce_widgets
						    where
							fun do_widget (bounce_widget: gp::Bounce_Widget,  hints: List(blh::Bounce_Space_Layout_Hint))
							    =
							    ( do_bounce_widget  (bounce_widget, look_to_bounce),
							      hints
							    );	
						    end;

					bounce_space_id =  bounce_space.id;

					gt::BOUNCE_SPACE { bounce_space_id, widgets };
				    };

			        gp::NULL_PACKED_WIDGET
				    =>
				    gt::NULL_PACKED_WIDGET;
			    esac;
		    end;	
	    end;


	fun startup   (id: Id,   reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		client_to_gui =	      { id,
					exercise_appwindow,
					run_gui,
					end_gui,
					get_bounce_theme,
					get_canvas_theme,
					get_packed_theme
				      };

		look_to_gui =	      { id,
					#
					note_changed_widget_foreground,
					note_changed_widget_background
				      };	

		space_to_gui =	      { id,
					#
					note_widget_site
				      };	

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, { client_to_gui }));						# Return value from gui_boss_egg'().

		(take_from_mailslot  me_slot)										# Imports from gui_boss_egg'().
		    ->
		    { me, gui_boss_arg, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		bounce_imps		=  REF im::empty;								# Holds our os::Bounce_Space instances -- can't put them directly in Gui_Tree due to circularity.
		canvas_imps		=  REF im::empty;								# Holds our cs::Canvas_Space instances -- can't put them directly in Gui_Tree due to circularity.
		packed_imps		=  REF im::empty;								# Holds our ps::Packed_Space instances -- can't put them directly in Gui_Tree due to circularity.
		look_imps		=  REF im::empty;								# Holds look-imps for all the widgets in our gui.

		current_frame_number	=  REF 1;
		seconds_per_frame	=  REF 0.1;									# Let's initially assume a nominal ten frames per second.


		run ( gui_boss_q,		 									# Will not return.
		      { me, gui_boss_arg, imports, to, end_gun',
			bounce_imps,
			canvas_imps,
			packed_imps,
			look_imps,
			look_to_gui,
			space_to_gui,
			current_frame_number,
			seconds_per_frame
		      }
		);
	    }
	    where
		gui_boss_q     =  make_mailqueue (get_current_microthread()):  Gui_Boss_Q;




		#################################################################################
		# space_to_gui interface fns:


		fun note_widget_site { id: Id, site: xg::Box }								# PUBLIC.
		    =	
		    # This fn is called by
		    #
		    #   src/lib/x-kit/widget/space/bounce/bounce-space-imp.pkg
		    #   src/lib/x-kit/widget/space/canvas/canvas-space-imp.pkg
		    #   src/lib/x-kit/widget/space/packed/packed-space-imp.pkg  
		    #
		    # when they assign a widget a new site in response to our call
		    #
		    #     packed_space.pass_re_siting_done_flag
		    #
		    put_in_mailqueue  (gui_boss_q,
			#
			fn ({ me, look_imps, ... }: Runstate)
			    =
			    case (im::get (*look_imps,  id_to_int id))
				#
				THE i =>    if (site != *i.site)							# Has the window site of this widget changed?
						#									# Yes.
						i.site :=                    site;					# Remember new site of widget.
#						i.gui_to_look.note_new_site  site;					# Tell widget's look-imp about its new site.
					    fi;

				NULL => 	{   msg = sprintf "imp %d not found in look_imps?!" (id_to_int id);	# Should be impossible -- all look widgets should be in look_imps.
						log::note_on_stderr {. msg; };
						raise exception FAIL msg;
					    };
			    esac
		    );

		#################################################################################
		# look_to_gui interface fns:

		fun note_changed_widget_foreground									# PUBLIC.
		      {
			id:		Id,
			foreground:	List(exp::Draw_Op)
		      }
		    =	
		    {   put_in_mailqueue  (gui_boss_q,
			    #
			    fn (runstate: Runstate)
				=
				{
nb {. "note_changed_widget_foreground called -- gui-boss-imp.pkg"; };
				}
		        );
		    };

		fun note_changed_widget_background									# PUBLIC.
		      {
			id:		Id,
			background:	List(exp::Draw_Op)
		      }
		    =	
		    {   put_in_mailqueue  (gui_boss_q,
			    #
			    fn (runstate: Runstate)
				=
				{
nb {. "note_changed_widget_background called -- gui-boss-imp.pkg"; };
				}
		        );
		    };


		#################################################################################
		# gui_boss interface fns::

		fun exercise_appwindow ()										# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Int );
			#
			put_in_mailqueue  (gui_boss_q,
			    #
			    fn ({ imports, to, ... }: Runstate)
				=
				imports.packed_theme.pass_appwindow_exercise_results
				    to
				    {.  put_in_oneshot (reply_oneshot, #i);   }
			);

			fn () =  get_from_oneshot reply_oneshot;
		    };


		fun run_gui (gui_plan: gp::Gui_Plan)									# PUBLIC.
		    =	
		    {   gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop(Void);
			#
			put_in_mailqueue  (gui_boss_q,
			    #
			    fn (runstate: Runstate)
				=
				run_gui' (runstate, gui_plan, gui_startup_complete')
		        );

			{.   get_from_oneshot  gui_startup_complete';   };
		    };


		fun end_gui ()												# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( gp::Gui_Plan );
			#
			put_in_mailqueue  (gui_boss_q,
			    #
			    fn (runstate: Runstate)
				=
				put_in_oneshot  (reply_oneshot,  end_gui' runstate)
				
			);

			get_from_oneshot reply_oneshot;
		    };

		fun get_bounce_theme ()											# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( bt::Bounce_Theme );
			#
			put_in_mailqueue  (gui_boss_q,
			    #
			    fn ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.bounce_theme)
			);

			get_from_oneshot reply_oneshot;
		    };

		fun get_canvas_theme ()											# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( ct::Canvas_Theme );
			#
			put_in_mailqueue  (gui_boss_q,
			    #
			    fn ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.canvas_theme)
			);

			get_from_oneshot reply_oneshot;
		    };

		fun get_packed_theme ()											# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( tp::Packed_Theme );
			#
			put_in_mailqueue  (gui_boss_q,
			    #
			    fn ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.packed_theme)
			);

			get_from_oneshot reply_oneshot;
		    };
	    end;


	fun process_options (options: List(Gui_Boss_Option), { name, id })
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME	n) =>   my_name			:=  n;
			do_option (ID			i) =>   my_id                   :=  i;
		    end;
		end;

		{ name			=>  *my_name,
		  id 			=>   *my_id
		};
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_gui_boss_egg
	      (gui_boss_arg:		Gui_Boss_Arg)									# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	    =
	    {	gui_boss_arg ->  (gui_boss_options);									# Currently no gui_boss_needs component, so this is a no-op.
		#
		(process_options
		  ( gui_boss_options,
		    { name		=> "gui_boss",
		      id		=>  id_zero
		    }
		) )
		    ->
		    { name,
		      id
		    };
	
		my (id, gui_boss_options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();										# Allocate unique imp id.
			(id, ID id ! gui_boss_options);									# Make our id stable across stop/restart cycles.
		    else
			(id, gui_boss_options);
		    fi;

		gui_boss_arg = (gui_boss_options);									# Currently no gui_boss_needs component, so this is a no-op.

		me =  { gui_tree	=>  REF NULL
		      };

		fn () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );		# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));					# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3											# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, gui_boss_arg, imports, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
