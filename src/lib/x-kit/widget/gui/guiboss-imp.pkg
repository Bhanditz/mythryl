## guiboss-imp.pkg
#
# For the big picture see the imp dataflow diagrams in
#
#     src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
#
# The vision here is to implement a simple, flexible, easy-to-customize
# GUI widget infrastructure portable to various rendering layers like
# X, OpenGL and javascript.  The allow small teams to efficiently develop
# (for example) GUI-driven custom scientific, stock-trading and programming
# support apps.  As such, the emphasis is on simplicity, portability,
# cleanliness, smooth integration with Mythryl facilities such as the
# type system, garbage collector and package system.  Competing with
# commercial GUI toolkits for glitter factor is NOT a priority.
#
# guiboss_imp is the master imp responsible for starting up and shutting
# down running GUIs.
#
# Most of its major types and supporting code for handling them is in
#     src/lib/x-kit/widget/gui/guiboss-types.pkg
#
# guiboss_imp GUIs divide into three types of spaces:
#     widgetspace, for conventional row/column widget layout.
#     objectsapce, for draw and paint functionality and also
#                  free-form drop-and-drag knob-and-tube GUIs.
#     spritespace, for 2D (and eventually 3D) animation.
#
# At the moment (2014-11-20) only widgetspace is at all well developed.
#
# guiboss_imp delegates management of these three kinds of spaces
# (in particular widget layout) to
#     src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
#     src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
#     src/lib/x-kit/widget/space/object/objectspace-imp.pkg
#  
# guiboss_imp is designed to be portable, but at the moment the only
# rendering layer implemented is for X, using the interface exported by
#     src/lib/x-kit/widget/xkit/app/windowsystem-imp-for-x.pkg
#  
# We refer to mouse-sensitive controls as "gadgets".
# Each of our three spaces has its own flavor of gadget:
#     widgetspace: Widgets, base implementation being   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
#     objectsapce: Objects, base implementation being   src/lib/x-kit/widget/xkit/theme/widget/default/look/object-imp.pkg
#     spritespace: Sprites, base implementation being   src/lib/x-kit/widget/xkit/theme/widget/default/look/sprite-imp.pkg
#     

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package bt  =  gui_to_sprite_theme;				# gui_to_sprite_theme		is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
    package ct  =  gui_to_object_theme;				# gui_to_object_theme		is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
    package wt  =  widget_theme;				# widget_theme			is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

#   package os  =  guiboss_to_spritespace;			# guiboss_to_spritespace	is from   src/lib/x-kit/widget/space/sprite/guiboss-to-spritespace.pkg
#   package cs  =  guiboss_to_objectspace;			# guiboss_to_objectspace	is from   src/lib/x-kit/widget/space/object/guiboss-to-objectspace.pkg


    package boi =  spritespace_imp;				# spritespace_imp		is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;				# objectspace_imp		is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;				# widgetspace_imp		is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gws =  guiboss_to_windowsystem;			# guiboss_to_windowsystem	is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg
#   package b2g =  guiboss_to_gadget;				# guiboss_to_gadget		is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg

    package b2s =  spritespace_to_sprite;			# spritespace_to_sprite		is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;			# objectspace_to_object		is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg
    package p2w =  widgetspace_to_widget;			# widgetspace_to_widget		is from   src/lib/x-kit/widget/space/widget/widgetspace-to-widget.pkg

    package s2b =  sprite_to_spritespace;			# sprite_to_spritespace		is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2c =  object_to_objectspace;			# object_to_objectspace		is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg
    package w2p =  widget_to_widgetspace;			# widget_to_widgetspace		is from   src/lib/x-kit/widget/space/widget/widget-to-widgetspace.pkg

    package s2g =   space_to_gui;				# space_to_gui			is from   src/lib/x-kit/widget/gui/space-to-gui.pkg
#   package g2g =  gadget_to_guiboss;				# gadget_to_guiboss		is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
#    package c2g =  client_to_guiboss;				# client_to_guiboss		is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package frm =  frame;					# frame				is from   src/lib/x-kit/widget/leaf/frame.pkg

    package iul =  issue_unique_look_id;			# issue_unique_look_id		is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

#    dummy1 = evt::t::bin_op;		# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
#    dummy2 = gts::gui_event_name;	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
herein

    package guiboss_imp
    :       Guiboss_Imp													# Guiboss_Imp		is from   src/lib/x-kit/widget/gui/guiboss-imp.api
    {
	Client_To_Guiboss
	  =
	  { id:			Id,											# Unique id to facilitate storing guiboss instances in indexed datastructures like red-black trees.
	    #
	    get_sprite_theme:	Void -> bt::Gui_To_Sprite_Theme,
	    get_object_theme:	Void -> ct::Gui_To_Object_Theme,
	    get_widget_theme:	Void -> wt::Widget_Theme,
	    #
	    make_topwindow:	 gws::Topwindow_Hints			    ->  gws::Guiboss_To_Topwindow,		# 
	    #
	    start_gui:		(gws::Guiboss_To_Topwindow, gt::Gui_Plan)   -> (Void -> gt::Client_To_Guiwindow),	# Calling return value will block microthread until gui-plan    startup is complete.
	    restart_gui:	(gws::Guiboss_To_Topwindow, gt::Paused_Gui) -> (Void -> gt::Client_To_Guiwindow)	# Calling return value will block microthread until stopped-gui restart is complete.
	  };

	Guiboss_Option
	  #
	  =  MICROTHREAD_NAME	String											# 
	  |  ID			Id											# Stable, unique id for imp.
	  ;	

	Guiboss_Arg =  List(Guiboss_Option);										# Currently no required component.

	Imports = {													# Ports we use, provided by other imps.
		    int_sink:			Int -> Void,
		    guiboss_to_windowsystem:	gws::Guiboss_To_Windowsystem,	
		    gui_to_sprite_theme:	bt::Gui_To_Sprite_Theme,
		    gui_to_object_theme:	ct::Gui_To_Object_Theme,
		    theme:			wt::Widget_Theme
		  };


	Site = Ref( g2d::Box );												# Pixel-rectangle assigned to the widget, in backing-pixmap coordinates.

	Mouse_Is													# Support for mouse drag operations.
	  #
	  = CROSSING_NONGADGET												# Mouse is not currently to be on any gadget.
	  #
	  | CROSSING_GADGET												# Mouse is currently on a gadget. Eventually we should issue ENTER and LEAVE events based on this. 	
	      { gadget_info:		gt::Gadget_Info									# This is the gadget on which the mouse is currently located. We send a LEAVE event when the mouse leaves it.
	      }
	  #
	  | DRAGGING_IN_GADGET												# Mouse is being dragged on this gadget.
	      { gadget_info:		gt::Gadget_Info,								# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
		start_point:		g2d::Point,									# This is the window coordinate of the downclick which started this drag.
		last_point:		g2d::Point									# This is the window coordinate of the last motion event for this drag.
	      }
	  ;

	Topwindow_Info
	  =
	  { # These three are valid throughout
	    # the lifetime of the topwindow:
	    #
	    guiboss_to_topwindow:			gws::Guiboss_To_Topwindow,
	    current_frame_number:			Ref(Int),							# We count frames for convenience of widgets and debugging.
	    seconds_per_frame:				Ref(Float),							# Primarily so widgets can do motion blurring if they wish.

	    done_extra_redraw_request_this_frame:	Ref(Bool),							# See Note[3].

	    next_stacking_order:			Ref(Int),							# Next Backing_Pixmap.stacking_order value to issue.
	    

															# The remainder are valid only while a gui is running,
															# which is to say, between restart_gui' and kill_gui' (or pause_gui', once we get it checked out).

	    mouse_is:					Ref( Mouse_Is ),						# Support for mouse drag operations.

	    backing_pixmap:				Ref( Null_Or( gt::Backing_Pixmap ) ),

	    gadget_imps:				gt::Gadget_Imps,						# Holds our gt::Gadget_Info            instances -- basically, all running widgets, sprites and objects in topwindow.
	    sprite_imps:				gt::Sprite_Imps,						# Holds our gt::Guiboss_To_Spritespace instances -- can't put them directly in Running_Gui due to circularity.
	    object_imps:				gt::Object_Imps,						# Holds our gt::Guiboss_To_Objectspace instances -- can't put them directly in Running_Gui due to circularity.
	    widget_imps:				gt::Widget_Imps							# Holds our gt::Guiboss_To_Widgetspace instances -- can't put them directly in Running_Gui due to circularity.
	  };

	Guiboss_State													# Holds all nonephemeral mutable state maintained by package.
	  =
	  {
	    topwindows:			Ref( im::Map( Topwindow_Info  ) )						# Each call to client_to_guiboss.make_topwindow() adds one entry to this.  Indexed by guiboss_to_topwindow.id.
	  };

	Me_Slot = Mailslot( { imports:		Imports,
			      me:		Guiboss_State,
			      guiboss_arg:	Guiboss_Arg,
			      run_gun':		Run_Gun,
			      end_gun':		End_Gun
			    }
			  );

	Exports	= {													# Ports we provide for use by other imps.
		    client_to_guiboss:	Client_To_Guiboss
		  };


	Guiboss_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);


	Runstate =    {													# These values will be statically globally visible throughout the code body for the imp.
			me:			Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
			guiboss_arg:		Guiboss_Arg,
			imports:		Imports,								# Imps to which we send requests.
			to:			Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
			end_gun':		End_Gun,								# We shut down the microthread when this fires.
			id:			Id
		      };

	Guiboss_Q    = Mailqueue( Runstate -> Void );


	fun pprint_gadget_info (gadget_info: gt::Gadget_Info)
	    =
	    pp::with_standard_prettyprint_mill
		#
		(err::default_plaint_sink ())	[]
		#
		(\\ pp:   pp::Prettyprint_Mill
		    =
		    do_gadget_info gadget_info
		    where
			fun do_gadget_info
			      (
				{
				  site:				Site,										# Where to draw this gadget, in topwindow coordinates.
				  backing_pixmap:		Ref(gt::Backing_Pixmap),
				  #
				  guiboss_to_gadget:		gt::Guiboss_To_Gadget,								# We use this to make requests of visible gadgets.
				  gadget_mode:			Ref( gt::Gadget_Mode ),
				  #
				  needs_redraw_request:		Ref( Bool ),									# 
				  sent__initialize_gadget:	Ref( Bool ),
				  #
				  point_in_gadget:		Ref( Null_Or( g2d::Point -> Bool ))						# Optional fn to decide if a mouseclick actually hit the gadget itself, or just somewhere near it in the screenspace assigned to it.
				}:				gt::Gadget_Info
			      )
			    =
			    {   pp.box {.
				    pp.lit  "Gadget_Info {";
				    pp.ind 2;
				    pp.txt " ";

				    pp.lit  (sprintf "site => %s" (g2j::box_to_string *site));
				    pp.endlit ",";

				    pp.lit  (sprintf "backing_pixmap => %s" (gt::backing_pixmap_id *backing_pixmap));
				    pp.endlit ",";
				    
				    guiboss_to_gadget -> gt::GUIBOSS_TO_GADGET { id, ... };
				    pp.lit (sprintf "GUIBOSS_TO_GADGET.id => %d" (iul::id_to_int id));

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "}";
				};
				pp.newline();
			    };	
		    end
		);

	fun clear_box_in_pixmap												# Clear a box to black, mostly to avoid undefined values etc.
	      (
		pixmap:			gt::Backing_Pixmap,								# pixmap holding the viewport.
		box:			g2d::Box									# Box in view coordinates.
	      )
	    =
	    case pixmap
		#
		gt::TOPWINDOW_PIXMAP { pixmap:	g2p::Gadget_To_Rw_Pixmap, ... } => pixmap.draw_displaylist [ gd::COLOR (r64::black,  [ gd::FILLED_BOXES [ box ]]) ];
		gt::VIEWPORT_PIXMAP  { pixmap:	g2p::Gadget_To_Rw_Pixmap, ... } => pixmap.draw_displaylist [ gd::COLOR (r64::black,  [ gd::FILLED_BOXES [ box ]]) ];
	    esac;

															# The high-level architectural ideas here are:
															#  o  Every running gui has an associated offscreen backing_pixmap containing a complete image of its window.
															#     We have one running gui for the main visible window plus one for each visible popup.
															#     (Popups do not have separate X windows; they are implemented entirely client-side, drawing into the main window.)
															#     The popups cover less screen space than the main visible window, so they have smaller offscreen backing_pixmaps.
															#  o  Gadgets always draw to the offscreen backing_pixmap for the running gui with which they are associated.
															#  o  We update the visible window by copying rectangles from the backing_pixmaps to the visible window.
															#     These copies need to respect the popup hierarchy, e.g. the main running_gui must not write over screenspace belonging to any popup.
															#     We never do text drawing ops or such directly onto the visible window.
															#  o  Scrollable views introduce an additional level of indirection:
															#      *  Each scrollable view has its own offscreen backing_pixmap.
															#      *  Widgets located on a scrollable view draw to its backing_pixmap.
															#      *  We copy rectangles from the scrollable-view backing_pixmap to its parent backing_pixmap.
															#         (We never copy directly from the scrollable-view backing_pixmap to the visible window.)
															#      *  Scrollable-view stuff then becomes visible when the parent backing_pixmap is copied to the visible window.
															#      *  It is reasonable for a scrollable view to contain another scrollable view, so the above should be understood recursively.
															#
															# Nomenclature: "blit" is from "BitBLT" == "bit-boundary block transfer" -- originally a Xerox Alto graphics op, now informal jargon term. For more info:   http://en.wikipedia.org/wiki/Bit_blit
															# Because we allow nested scrollable subwindows of main topwindow for app,
															# it is nontrivial to figure out where on the topwindow a given gadget is
															# visible -- if it is visible at all! -- and how much is visible, and what
		 													# pixel rectangle to copy from where to where to update the gadget's on-
															# screen image.  That's our job here.
	fun update_offscreen_parent_pixmaps_and_then_topwindow
	      (
		pixmap:				gt::Backing_Pixmap,
		from_box:			g2d::Box,								# From-box in source pixmap coordinates.
		topwindow_for_gui:		gws::Guiboss_To_Topwindow
	      )
	    =
	    {
		propagate_frombox_changes_to_all_parents_in_which_they_are_visible
		    #
		    (pixmap, from_box);											# Copy visible part of gadget to the backing pixmap for the viewport containing it, the backing pixmap for the viewport containing that viewport etc and finally the visible topwindow itself.
	    }														# Typically there will be no viewports involved, so this will be just a blit to the topwindow.
	    where
		fun find_frombox_parts_not_hidden_by_popups
		      (
			backing_pixmap:		gt::Backing_Pixmap,
			from_box:		g2d::Box								# We assume this is in local backing_pixmap coordinates (not basewindow coordinates).
		      )
		    =
		    {
															# The redraw logic expects the from_box info to be in 'backing_pixmap' coordinates, not basewindow coords.
															# But to compare from_box with the possibly shading running-gui pixmaps, they must all be in the samme coordinate system.
															# Consequently we transform the possibly_shading_pixmaps into our local 'backing_pixmap' coordinates.
			# Now we figure out which parts of 'from_box'
			# are not hidden by popup windows:

			bp = gt::topwindow_pixmap_of_backing_pixmap  backing_pixmap;					# This returns 'r' from   backing_pixmap as (TOPWINDOW_PIXMAP r).   "bp" == "backing_pixmap".

			possibly_shadowing_pixmaps									# Get the popup windows which are maybe shadowing us (that is, which we might clobber if we drew all of from_box)
			    =
			    gt::find_all_topwindow_pixmaps_above_given_backing_pixmap_in_stacking_order
				#
				backing_pixmap;

			possibly_shadowing_sites									# Convert the possibly_shadowing_pixmaps to boxes in basewindow coordinates.
			    =
			    (map gt::topwindow_pixmap_site_in_basewindow_coordinates					# This adds in the 'origin' fields of all our parents.
				#
				possibly_shadowing_pixmaps
			    )
			    :   List( g2d::Box );

			bp_origin_in_basewindow_coordinates
			    =
			    g2d::box::upperleft
			      (
				gt::topwindow_pixmap_site_in_basewindow_coordinates  bp
			      );

			possibly_shadowing_sites									# Convert shadowing sites from basewindow coords to 'backing_pixmap' coords.
			    =
			    (map translate_site_to_our_coordinate_system
				#
				possibly_shadowing_sites								# 
			    )
			    where
				fun translate_site_to_our_coordinate_system (box: g2d::Box)
				    =
				    {   (g2d::box::upperleft_and_size  box)
					    ->
					    (box_origin, size);

					g2d::box::make  (box_origin - bp_origin_in_basewindow_coordinates,  size);
				    };
			    end;

			visible_parts_of_frombox									# Subtract the boxes from from_box to see what parts of from_box it is actually safe to draw (if any).
			    =
			    g2d::box::subtract_boxes_b_from_boxes_a
			      {
				a => [ from_box ],
				b => possibly_shadowing_sites
			      };

			visible_parts_of_frombox;									# 
		    };													# fun find_frombox_parts_not_hidden_by_popups

		fun propagate_frombox_changes_to_all_parents_in_which_they_are_visible					# Caller has just changed contents of from_box in backing_pixmap:  We need to propagate these changes to all parents in which it is visible.
		      (
			backing_pixmap											# A gt::TOPWINDOW_PIXMAP contains the complete offscreen image of one running gui, either the main window one or a popup.
			as												# Consequently in the gt::TOPWINDOW_PIXMAP case we are always copying from the offscreen backing_pixmap to the visible screen,
			gt::TOPWINDOW_PIXMAP bp,									# never from one offscreen backing_pixmap to another.  When copying to the visible screen we do need to be careful not to
															# overwrite screen space belonging to any popup which is above us in the stacking order.
			from_box:	g2d::Box									# From-box in source pixmap coordinates.
		      )
			=>
			{
			    frombox_fragments_to_draw									# These are in local pixmap coordinates (not basewindow coordinates).
				=
				find_frombox_parts_not_hidden_by_popups (backing_pixmap,  from_box);

			    pixmap_site
				=
				gt::topwindow_pixmap_site_in_basewindow_coordinates   bp;

			    pixmap_origin = g2d::box::upperleft  pixmap_site;

			    from_id   =  gt::backing_pixmap_id_of  backing_pixmap;					# This is the pixmap holding the source pixels for the blit.
			    #
			    apply  draw_fragment  frombox_fragments_to_draw						# For each part of from_box which is not hidden by overlying popups....
				where
				    fun draw_fragment (from_box: g2d::Box)
					=
					{
					    to_point  =  (g2d::box::upperleft  from_box) + pixmap_origin;		# Where should we copy pixels to, on the visible topwindow?   If we are a popup, we need to add in the popup origin (pixmap_origin) in basewindow coordinates.

					    topwindow_for_gui.draw_displaylist						# ... blit that part to on-screen window for user to see.
					      [
						gd::COPY_FROM_RW_PIXMAP { from_box, to_point, from_id }
					      ];
					};
				end;
			};

		    propagate_frombox_changes_to_all_parents_in_which_they_are_visible
		      (
			backing_pixmap											# A gt::VIEWPORT_PIXMAP contains the offscreen image of one scrollable viewport embedded within a parent backing_pixmap.
			as												# Consequently in the gt::VIEWPORT_PIXMAP case we are always copying from one offscreen backing_pixmap to another.
			gt::VIEWPORT_PIXMAP  { is_visible:	Ref( Bool ),						# We do not have to worry about popups blocking our copies, since they are entirely internal to one running_gui.
						pixmap:		g2p::Gadget_To_Rw_Pixmap,
						viewports:	Ref( List( gt::Viewport ) )				# We make this a Ref(List(...)) to allow for adding additional viewports opening onto the same underlying pixmap.
					      },

			from_box:	g2d::Box											# From-box in source pixmap.
		      )
			=>
			if (*is_visible)												# Do not propagate if we are one of multiple TABBED_VIEWS and we are not visible.
			    #	
			    from_id   =  gt::backing_pixmap_id_of  backing_pixmap;							# The Id for the source pixmap for the copy.

			    apply   do_viewport  *viewports										# We may be visible in multiple viewports, each of which may be visible in multiple viewports, so potentially we need to update a tree of parents.
				    where
					fun do_viewport											# Handle update of our image as visible via one parent viewport.
					      {	parent_pixmap:	gt::Backing_Pixmap,
						viewport_site:	Ref(g2d::Box),								# Size and location of subwindow viewport in parent Backing_Pixmap coordinates.
						#
						view_origin:	Ref(g2d::Point)								# Used to scroll subwindow contents around in parent viewport: view origin in viewport coordinates.
					      }
					    =
					    {	viewport_origin_in_view									# If the from_box is not entirely visible in the viewport
						    =											# then we need to clip it to the viewport.  Since we want
						    g2d::point::zero - *view_origin;							# the clipped from_box to be in the gadget's home pixmap,
																	# the most straightforward approach is to transform the
																	# viewport into home pixmap space.  If *view_origin is
						viewport' = g2d::box::clone_box_at (*viewport_site, viewport_origin_in_view);		# 0,0 then viewport is at (0,0) in home pixmap, otherwise
																	# it is offset by -*view_origin, so in general we want
																	# the viewport cloned at -*view_origin.



						to_point  = g2d::box::upperleft  from_box;						# Where should we copy pixels to, on our parent pixmap?   We initialize this to the null transform -- we'll add in appropriate offsets to this momentarily.

						case (g2d::box::intersection (viewport', from_box))
						    #
						    NULL => ();										# No intersection between from_box and viewport' means no part of gadget is visible, so just return NULL.
						    #
						    THE from_box'
							=>
							{
							    my (to_point, from_box)							# Update to_point and from_box to account for clipping due
								=									# to intersection between viewport and old from_box value.
								if (g2d::box::eq (from_box', from_box))
								    #
								    (to_point, from_box);						# No actual clipping (from_box must be completely visible in viewport) so nothing to do here.

								elif (g2d::point::eq ( g2d::box::upperleft( from_box' ),		# Is origin of from_box' different from origin or from_box?
										       g2d::box::upperleft( from_box  )
								     ) 		   )

								    (to_point, from_box');						# No, so to_point stays the same, we just replace from_box with from_box'.
								else
																	# Yes, so we need to move to_point to reflect displacement between from_box and from_box'.
								    frombox_displacement
									=
									g2d::point::subtract( g2d::box::upperleft( from_box' ),		# Compute that displacement.
											      g2d::box::upperleft( from_box  )
											    );

								    to_point'   = g2d::point::add (to_point, frombox_displacement);	# Apply it.

								    (to_point', from_box');						# Done.
								fi;

																	# Now we just need to compute where from_box should be drawn in
																	# current sub/window, then update to_point and continue recursively.

							    to_point = g2d::point::add (to_point, *view_origin);			# Account for location of view  relative to viewport.
							    to_point = g2d::point::add (to_point, g2d::box::upperleft(*viewport_site));	# Account for location of viewport relative to parent pixmap.

							    parent_pixmap' =  gt::gadget_to_rw_pixmap__of  parent_pixmap;		# Find off-screen backing pixmap containing viewport onto us.
							    from_id	   =  pixmap.id;						# Pixmap to copy rectangle from (as Id).
							    gui_displayop  =  gd::COPY_FROM_RW_PIXMAP { from_box, to_point, from_id };	# The actual copy from our pixmap to viewport area in parent pixmap.
							    #										#
							    parent_pixmap'.draw_displaylist [ gui_displayop ];				# Draw updated gadget appearance into its off-screen backing-pixmap home site.

							    from_box = g2d::box::clone_box_at (from_box, to_point);			# Our to-box is from_box for the next level of recursion.

							    propagate_frombox_changes_to_all_parents_in_which_they_are_visible		# Continue recursively to next level of viewport nesting.
								#
								(parent_pixmap, from_box);
							};
						esac;

					    };
				    end;	
			fi;
		end;
	    end;

	fun remove_per_gui_imps_from_global_imp_indices_then_clear_per_gui_indices
	      {
		gadget_imps:		gt::Gadget_Imps,								# These four are the global indices.
		sprite_imps:		gt::Sprite_Imps,								# 
		object_imps:		gt::Object_Imps,								# 
		widget_imps:		gt::Widget_Imps,								# 
		#
		gadget_imps_for_gui:	gt::Gadget_Imps,								# These four are the per_gui indices.
		sprite_imps_for_gui:	gt::Sprite_Imps,								# 
		object_imps_for_gui:	gt::Object_Imps,								# 
		widget_imps_for_gui:	gt::Widget_Imps									# 
		#
	      }
	    =
	    {	apply do_imp (im::keys_list *gadget_imps_for_gui)  where fun do_imp (id: Int) =  gadget_imps := im::drop (*gadget_imps, id);  end;
		apply do_imp (im::keys_list *sprite_imps_for_gui)  where fun do_imp (id: Int) =  sprite_imps := im::drop (*sprite_imps, id);  end;
		apply do_imp (im::keys_list *object_imps_for_gui)  where fun do_imp (id: Int) =  object_imps := im::drop (*object_imps, id);  end;
		apply do_imp (im::keys_list *widget_imps_for_gui)  where fun do_imp (id: Int) =  widget_imps := im::drop (*widget_imps, id);  end;
		#
		gadget_imps_for_gui :=  im::empty;
		sprite_imps_for_gui :=  im::empty;
		object_imps_for_gui :=  im::empty;
		widget_imps_for_gui :=  im::empty;
	    };		

	fun redraw_all_running_guis											# Intended to be called after changing the popup structure -- killing a popup, moving a popup, whatever. (Not needed after just creating a new popup.)
	      (														# For our purposes here the base window is just one more popup, which happens to never go away.  I.e., for us, "popup" == "gt::TOPWINDOW_PIXMAP".
		backing_pixmap:		gt::Backing_Pixmap,								# This provides redraw_all_running_guis an entrypoint into the remaining Backing_Pixmap tree. Any Backing_Pixmap in the tree would do.
		topwindow_for_gui:	gws::Guiboss_To_Topwindow							# This provides redraw_all_running_guis with the window on which to do the redraw.
	      )
	    =
	    {
		backing_pixmaps_to_redraw
		    =
		    gt::find_all_backing_pixmaps_above_given_stacking_order
			#
			(backing_pixmap, 0);										# 'stacking_order' fields are always positive, so searching for all Backing_Pixmap instances with stacking_order > 0 gets us everything.	

		apply   redraw_backing_pixmap  backing_pixmaps_to_redraw
			where
			    fun redraw_backing_pixmap
				  (
				    backing_pixmap:	gt::Backing_Pixmap
				  )
				=
				{
				    topwindow_pixmap
					=
					gt::topwindow_pixmap_of_backing_pixmap
					    #
					    backing_pixmap;

				    size     =  topwindow_pixmap.pixmap.size;						# Redraw all of running gui.
				    origin   =  g2d::point::zero;							# We need from_box to be in backing_pixmap coordinate system, so origin will always be zero.
				    #
				    from_box =  g2d::box::make (origin, size);						# Our from_box covers the entire popup pixmap, so as to redraw all of it.

				    update_offscreen_parent_pixmaps_and_then_topwindow					# Redraw all visible parts of popup. (In our situation there is no offscreen updating to be done.)
					#
					(backing_pixmap, from_box, topwindow_for_gui);
				};
			end;
	    };	

	fun run ( guiboss_q:			Guiboss_Q,								# 
		  #
		  runstate as
		  {													# These values will be statically globally visible throughout the code body for the imp.
		    me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		    guiboss_arg:		Guiboss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# We shut down the microthread when this fires.
		    id:				Id
		  }
		)
	    =
	    {	loop ();
	    }
	    where


		#
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    end_gun'                       ==>  shut_down_guiboss_imp',
			    take_from_mailqueue' guiboss_q ==>  do_guiboss_plea
			];

			loop ();
		    }	
		    where
			fun do_guiboss_plea  thunk
			    =
			    thunk runstate;
			#
			fun shut_down_guiboss_imp' ()
			    =
			    {
				thread_exit { success => TRUE };							# Will not return.	
			    };
		    end;
	    end;	

	#
	fun kill_gui'
	      (
		runstate as
		{ me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		  guiboss_arg:			Guiboss_Arg,
		  imports:			Imports,								# Imps to which we send requests.
		  to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		  end_gun':			End_Gun,
		  id:				Id
		}:				Runstate,
		( running_gui:			gt::Running_Gui,
		  #
		  sprite_imps:			gt::Sprite_Imps,
		  object_imps:			gt::Object_Imps,
		  widget_imps:			gt::Widget_Imps,
		  gadget_imps:			gt::Gadget_Imps,
		  #
		  topwindow_info:		Topwindow_Info,
		  redraw_window_when_done:	Bool
		)
	      )
	    =
	    {	# Recursively kill off all running guis
		# which are children of current running gui:
		#
		case running_gui.topwindow_pixmap
		    #
		    gt::TOPWINDOW_PIXMAP r
			=>
			apply kill_one_subgui *r.popups
			where
			    fun kill_one_subgui (backing_pixmap: gt::Backing_Pixmap)
				=
				case backing_pixmap
				    #
				    gt::TOPWINDOW_PIXMAP r
					=>
					case *r.running_gui
					    #
					    THE running_gui => kill_gui' (runstate, (running_gui, sprite_imps, object_imps, widget_imps, gadget_imps, topwindow_info, FALSE));

					    NULL => ();
					esac;

				    gt::VIEWPORT_PIXMAP _
					=>
					{   msg = "kill_gui': backing_pixmap popups should never be gt::VIEWPORT_PIXMAP!";
					    log::fatal msg;
					    raise exception FAIL msg;
					};

				esac;
			end;

		    gt::VIEWPORT_PIXMAP _
			=>
			{   msg = "kill_gui': running_gui.topwindw_pixmap should never be gt::VIEWPORT_PIXMAP!";
			    log::fatal msg;
			    raise exception FAIL msg;
			};
		esac;
		

		running_gui.fire_end_gun ();										# Shut down GUI impnet.


		case running_gui.topwindow_pixmap
		    #
		    gt::TOPWINDOW_PIXMAP r
			=>
			{   # If we have a parent, remove ourself from parent's list of active popups:
			    #	
			    case r.parent
				#
				THE parent_backing_pixmap
				    =>
				    # We do have a parent -- remove ourself from parent's list of active popups:
				    #	
				    case parent_backing_pixmap
					#
					gt::VIEWPORT_PIXMAP _ => ();		# Shouldn't be possible.

					gt::TOPWINDOW_PIXMAP q
					    =>
					    q.popups := list::remove  is_us  *q.popups
							where
							    fun is_us (bp: gt::Backing_Pixmap)
								=
								case bp
								    #
								    gt::TOPWINDOW_PIXMAP r'
									=>
									same_id (r.pixmap.id, r'.pixmap.id);

								    gt::VIEWPORT_PIXMAP _ => FALSE;
								esac;
							end;
				    esac;

				NULL =>
				    {
					();
				    };
			    esac;

			    r.pixmap.free_rw_pixmap ();									# Free our main Xserver-side backing rw_pixmap for this running gui:

			    apply free_rw_pixmap (im::vals_list *r.pixmaps)			 			# Free all Xerver-side rw_pixmaps allocated by our widgets:
			    where
				fun free_rw_pixmap (rw_pixmap: g2p::Gadget_To_Rw_Pixmap)
				    =
				    rw_pixmap.free_rw_pixmap ();							# This is a no-op if the widget already freed the rw_pixmap.
			    end;
			};

		    gt::VIEWPORT_PIXMAP _
			=>
			{   msg = "kill_gui': running_gui.topwindw_pixmap should never be gt::VIEWPORT_PIXMAP!";
			    log::fatal msg;
			    raise exception FAIL msg;
			};
		esac;

		remove_per_gui_imps_from_global_imp_indices_then_clear_per_gui_indices
		  {
		    sprite_imps,
		    object_imps,
		    widget_imps,
		    gadget_imps,
		    #
		    sprite_imps_for_gui =>  running_gui.sprite_imps_for_gui,
		    object_imps_for_gui =>  running_gui.object_imps_for_gui,
		    widget_imps_for_gui =>  running_gui.widget_imps_for_gui,
		    gadget_imps_for_gui =>  running_gui.gadget_imps_for_gui
		  };

		case running_gui.topwindow_pixmap									# If we're the toplevel gui, remember we no longer have a gui running on this topwindow.
		    #
		    gt::TOPWINDOW_PIXMAP r
			=>
			case r.parent
			    #
			    NULL  =>    topwindow_info.backing_pixmap :=  NULL;						# We're killing the toplevel gui for this topwindow so remember that we no longer have a gui running on this topwindow.
			    THE _ =>    ();										# We're pausing a secondary popup gui for this topwindow.
			esac;

		    gt::VIEWPORT_PIXMAP _
			=>
			{   msg = "topwindow_pixmap should not be VIEWPORT_PIXMAP! -- restart_gui'";
			    log::fatal msg;
			    raise exception FAIL msg;
			};
		esac;

		case *topwindow_info.backing_pixmap									# Redraw the window if there are any running guis left to redraw.
		    #
		    THE backing_pixmap
			=>		
			{
			    redraw_all_running_guis
			      (
				backing_pixmap,										# This provides redraw_all_running_guis an entrypoint into the remaining Backing_Pixmap tree. Any Backing_Pixmap in the tree would do.
				topwindow_info.guiboss_to_topwindow
			      );
			};

		    NULL =>												# No running guis left on window so clear it to black.
			case running_gui.topwindow_pixmap
			    #
			    gt::TOPWINDOW_PIXMAP r
				=>
				{   entire_window =  g2d::box::make  (g2d::point::zero,  r.pixmap.size);
				    #	
				    midpoint      =  g2d::box::midpoint entire_window;

				    text	  =  [ gd::DRAW_TEXT (gd::CENTERED_ON_POINT, [ gd::TEXT (midpoint, "No GUI running.") ]) ];
				    text	  =  [ gd::FONT ([ "-*-courier-bold-r-*-*-20-*-*-*-*-*-*-*", "9x15" ], text) ];

				    topwindow_info.guiboss_to_topwindow.draw_displaylist
				      [
					gd::COLOR (r64::black,  [ gd::FILLED_BOXES [ entire_window ]] ),
					gd::COLOR (r64::white,  text)
				      ];
				};

			    gt::VIEWPORT_PIXMAP _
				=>
				{   msg = "kill_gui': running_gui.topwindw_pixmap should never be gt::VIEWPORT_PIXMAP!";
				    log::fatal msg;
				    raise exception FAIL msg;
				};
			esac;
		esac;
	    };


	#
	fun pause_gui'
	      (
		{ me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		  guiboss_arg:			Guiboss_Arg,
		  imports:			Imports,								# Imps to which we send requests.
		  to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		  end_gun':			End_Gun,
		  id:				Id
		}:				Runstate,
		( running_gui:			gt::Running_Gui,
		  #
		  sprite_imps:			gt::Sprite_Imps,
		  object_imps:			gt::Object_Imps,
		  widget_imps:			gt::Widget_Imps,
		  gadget_imps:			gt::Gadget_Imps,
		  #
		  topwindow_info:		Topwindow_Info
		)
	      )
	    =
	    {	running_gui.fire_end_gun ();										# Shut down GUI impnet.
		#
		result = running_gui__to__paused_gui  running_gui;							# Return sufficient information to recreate the GUI.

		remove_per_gui_imps_from_global_imp_indices_then_clear_per_gui_indices
		  {
		    sprite_imps,
		    object_imps,
		    widget_imps,
		    gadget_imps,
		    #
		    sprite_imps_for_gui =>  running_gui.sprite_imps_for_gui,
		    object_imps_for_gui =>  running_gui.object_imps_for_gui,
		    widget_imps_for_gui =>  running_gui.widget_imps_for_gui,
		    gadget_imps_for_gui =>  running_gui.gadget_imps_for_gui
		  };

		# Clear state which is only valid while a toplevel gui is running:
		#
		case running_gui.topwindow_pixmap
		    #
		    gt::TOPWINDOW_PIXMAP r
			=>												# running_gui is from
			{   case r.parent
				#
				NULL  =>    {   topwindow_info.backing_pixmap	    :=  NULL;				# We're pausing the toplevel gui for this topwindow so remember that we no longer have a gui running on this topwindow.
						#
						topwindow_info.sprite_imps	    :=  im::empty;			# We also have no more GUI imps running on this topwindow...
						topwindow_info.object_imps	    :=  im::empty;
						topwindow_info.widget_imps	    :=  im::empty;
						topwindow_info.gadget_imps	    :=  im::empty;
					    };

				THE _ =>    ();										# We're pausing a secondary popup gui for this topwindow.
			    esac;
			};

		    gt::VIEWPORT_PIXMAP _
			=>
			{   msg = "topwindow_pixmap should not be VIEWPORT_PIXMAP! -- restart_gui'";
			    log::fatal msg;
			    raise exception FAIL msg;
			};
		esac;

		result:				gt::Paused_Gui;
	    }														#
	    where
		fun running_gui__to__paused_gui
		    # 
		    (running_gui: 	gt::Running_Gui)
		    :
		    ( gt::Widgetspace_Arg,
		      gt::Pg_Widget
		    )
		    =
		    {
			running_gui ->    { fire_end_gun:		Void -> Void,					# Signal which will shut down the GUI impnet.
					    #
					    widgetspace_id:		gt::Widgetspace_Id,				# Runtime GUI state synthesized locally per client spec.
					    rg_widget:			gt::Rg_Widget,					# "                                       ".
					    topwindow:			gws::Guiboss_To_Topwindow,
					    topwindow_pixmap:		gt::Backing_Pixmap,				# Holds toplevel gt::TOPWINDOW_PIXMAP for gui.
					    #
					    gadget_imps_for_gui:	gt::Gadget_Imps,				# Holds our gt::Gadget_Info            instances for this running gui.
					    sprite_imps_for_gui:	gt::Sprite_Imps,				# Holds our gt::Guiboss_To_Spritespace instances for this running gui.
					    object_imps_for_gui:	gt::Object_Imps,				# Holds our gt::Guiboss_To_Objectspace instances for this running gui.
					    widget_imps_for_gui:	gt::Widget_Imps					# Holds our gt::Guiboss_To_Widgetspace instances for this running gui.
					  };

			rg_widget''
			    =
			    do_rg_widget  rg_widget;

			(im::get_or_raise_exception_not_found (*widget_imps, (id_to_int widgetspace_id)))
			    ->
			    { widget_to_widgetspace, guiboss_to_widgetspace, endstate_oneshot };	

			( get_from_oneshot   endstate_oneshot,								# Read final state of widgetspace-imp -- incidentally confirming that it has completed its shutdown.
			  rg_widget''
			);
		    }

		also
		fun do_rg_widget  (rg_widget: gt::Rg_Widget)
		    =
		    case rg_widget
			#
			gt::RG_ROW  { widgets:		List(  gt::Rg_Widget ),
				      pixels_high_min:	Ref(Int),
				      pixels_wide_min:	Ref(Int),
				      #
				      pixels_high_cut:	Ref(Float),
				      pixels_wide_cut:	Ref(Float),
				      #
				      site:			Ref(g2d::Box)
				    }
			    =>
			    gt::PG_ROW (map  do_rg_widget  widgets);

			gt::RG_COL  { widgets:		List( gt::Rg_Widget ),
				      pixels_high_min:	Ref(Int),
				      pixels_wide_min:	Ref(Int),
				      #
				      pixels_high_cut:	Ref(Float),
				      pixels_wide_cut:	Ref(Float),
				      #
				      site:			Ref(g2d::Box)
				    }
			    =>
			    gt::PG_COL (map  do_rg_widget widgets);


			gt::RG_GRID { widgets:		List( List( gt::Rg_Widget ) ),
				      pixels_high_min:	Ref(Int),
				      pixels_wide_min:	Ref(Int),
				      #
				      pixels_high_cut:	Ref(Float),
				      pixels_wide_cut:	Ref(Float),
				      #
				      site:			Ref(g2d::Box)
				    }
			    =>
			    gt::PG_GRID (map  do_row  widgets)
			    where
				fun do_row (widgets: List(gt::Rg_Widget))
				    =
				    (map  do_rg_widget  widgets);

			    end;

			gt::RG_SCROLLABLE_VIEW
				{ rg_widget:		gt::Rg_Widget,

# Should we delete packing_pixmap at this point?  If not, when does it get recycled? 			*** XXX QUERO FIXME ***

				  gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,
				  view_origin:		Ref(g2d::Point),						# Origin of backing_pixmap in viewport coordinates, used for scrolling pixmap in viewport.
				  scroller:		gt::Viewport_Scroller,
				  callback:		gt::Viewport_Scroller_Callback,
				  backing_pixmap:	gt::Backing_Pixmap,						# 
				  site:			Ref(g2d::Box)
				}
			    =>
			    {	callback NULL;										# Tell app code that our viewport_scroller is no longer active.
				#
				pg_widget      =  do_rg_widget  rg_widget;

				pixmap_size =  gadget_to_rw_pixmap.size;
				#
			        gt::PG_SCROLLABLE_VIEW (callback, pixmap_size, pg_widget);
			    };

			gt::RG_TABBED_VIEWS
				{ callback:		gt::Tabbed_View_Picker_Callback,
				  widgets:		List(gt::Tabview),
				  pixmap_size:		g2d::Size,
				  visible_widget:	Ref(  gt::Tabview ),
#				  viewport:		Ref(g2d::Box),							# The actual site assigned to the viewport on its home pixmap.  This gets set by   assign_sites_to_all_widgets()   in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
				  site:			Ref(g2d::Box)
				}
			    =>
			    {   callback NULL;										# Tell app code that our tabbed_view_picker is no longer active.
				#
				gt::PG_TABBED_VIEWS (callback,  pixmap_size,  map  do_widget  widgets)
					where
					    fun do_widget { widget: 			gt::Rg_Widget,
							    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,	# Should we delete this at this point?  If not, when does it get recycled?
							    backing_pixmap:		gt::Backing_Pixmap		# 
							  }

						=
						do_rg_widget  widget;
					end;
			    };

			gt::RG_FRAME
				{
				  frame_widget:		gt::Rg_Widget,						# Widget which will draw the frame surround.
				  widget:		gt::Rg_Widget,						# Widget-tree to draw surrounded by frame.
				  #
				  pixels_high_min: 	Ref(Int),							# Minimum            vertical   pixels to allocate for this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
				  pixels_wide_min:	Ref(Int),							# Minimum            horizontal pixels to allocate for this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
				  #
				  pixels_high_cut: 	Ref(Float),							# Share of remaining vertical   pixels to allocate to  this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
				  pixels_wide_cut: 	Ref(Float),							# Share of remaining horizontal pixels to allocate to  this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
				  #
				  site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
				}
			    =>
			    {	gt::PG_FRAME (fw, w)									# 
				where
				    fun do_widget (r: gt::Rg_Widget)
					=
					( do_rg_widget  r
					);

				    fw =  do_widget  frame_widget;
				    w  =  do_widget  widget;
				end;
			    };

			gt::RG_WIDGET r
			    =>
			    gt::PG_WIDGET (get_from_oneshot   r.endstate_oneshot);					# Read and return final state of widget-imp -- incidentally confirming that it has completed its shutdown.


			#
			gt::RG_OBJECTSPACE  objectspace
			    =>
			    do_objectspace  objectspace;

			gt::RG_SPRITESPACE  spritespace
			    =>
			    do_spritespace  spritespace;

			gt::RG_NULL_WIDGET
			    =>
			    gt::PG_NULL_WIDGET;
		    esac


		also
		fun do_spritespace r
		    =
		    {
			rg_sprites =  do_rg_sprites  r.sprites;
			#
			(im::get_or_raise_exception_not_found (*sprite_imps, (id_to_int r.spritespace_id)))
			    ->
			    { guiboss_to_spritespace, sprite_to_spritespace, endstate_oneshot };

			arg =  get_from_oneshot  endstate_oneshot;

		        gt::PG_SPRITESPACE (arg, rg_sprites);
		    }

		also
		fun do_rg_sprites (sprites':  List (gt::Rg_Sprite))
		    =
		    {
			sprites'' = map  do_sprite  sprites'
				    where
					fun do_sprite' (sprite': gt::Rg_Sprite)
					    =
					    case sprite'
						#
						gt::RG_SPRITE r
						    =>
						    gt::PG_SPRITE (get_from_oneshot   r.endstate_oneshot);		# Read and return final state of sprite-imp -- incidentally confirming that it has completed its shutdown.
					    esac;
					#
					fun do_sprite (sprite': gt::Rg_Sprite)
					    =
					    {   sprite'' = do_sprite'  sprite';
						#
						sprite'';
					    };
				    end;

			sprites'';
		    }


		also
		fun do_objectspace r
		    =
		    {	objects =  do_rg_objects  r.objects;
			#
			(im::get_or_raise_exception_not_found (*object_imps, (id_to_int r.objectspace_id)))
			    ->
			    { guiboss_to_objectspace, object_to_objectspace, endstate_oneshot };

			arg =  get_from_oneshot  endstate_oneshot;

		        gt::PG_OBJECTSPACE (arg, objects);
		    }

		also
		fun do_rg_objects (objects':  List (gt::Rg_Object))
		    =
		    {
			objects'' = map  do_object  objects'
				    where
					fun do_object' (object': gt::Rg_Object)
					    =
					    case object'
						#
						gt::RG_OBJECT r
						    =>
						    gt::PG_OBJECT (get_from_oneshot   r.endstate_oneshot);		# Read and return final state of object-imp -- incidentally confirming that it has completed its shutdown.

						gt::RG_WIDGETSPACE
						      { widgetspace_id:		gt::Widgetspace_Id,
							rg_widget:		gt::Rg_Widget
						      }
						    =>
						    {	rg_widget'' =  do_rg_widget  rg_widget;
							#
							(im::get_or_raise_exception_not_found (*widget_imps, (id_to_int widgetspace_id)))
							    ->
							    { widget_to_widgetspace, guiboss_to_widgetspace, endstate_oneshot };

							gt::PG_WIDGETSPACE
							  (
							    get_from_oneshot   endstate_oneshot,			# Read and return final state of widgetspace-imp -- incidentally confirming that it has completed its shutdown.
							    rg_widget''
							  );
						    };
					    esac;
					#
					fun do_object (object': gt::Rg_Object)
					    =
					    {   object'' = do_object'  object';
						#
						object'';
					    };
				    end;

			objects'';
		    };													# fun do_rg_objects
	    end;


	fun make_base_backing_pixmap (pixmap: g2p::Gadget_To_Rw_Pixmap): gt::Backing_Pixmap				# Make the base Backing_Pixmap instance for a GUI. (There will be an additional Backing_Pixmap for each viewport and active popup in the gui.)
	    =
	    gt::TOPWINDOW_PIXMAP
	      {
		running_gui	=>   REF NULL,
		pixmap,													# Main backing pixmap for this running gui.
		pixmaps		=>   REF im::empty,									# All other X-server side pixmaps created by/for this running gui.  (We need this to reliably recycle them when we kill the gui -- otherwise we'll be leaking X server memory.)
		popups		=>   REF ([]: List( gt::Backing_Pixmap)),
		parent		=>   NULL: Null_Or( gt::Backing_Pixmap ),
		origin		=>   REF { row => 0, col => 0 },
		#
		stacking_order => 1
	      };

	fun make_backing_pixmap_for_popup										# Create a g2p::Gadget_To_Rw_Pixmap instance, wrap it in a gt::TOPWINDOW_PIXMAP, and enter the latter into the tree of TOPWINDOW_PIXMAP.
	      (
		make_rw_pixmap:			g2d::Size -> g2p::Gadget_To_Rw_Pixmap,
		next_stacking_order: 		Ref(Int),
		parent:				gt::Backing_Pixmap,
		site:				g2d::Box
	      )	
	    =
	    {   p = case parent     gt::TOPWINDOW_PIXMAP p =>  p;
				    gt::VIEWPORT_PIXMAP _  =>  {   msg = "make_backing_pixmap_for_popup: parent == gt::VIEWPORT unsupported. -- guiboss-imp.pkg";
								    log::fatal msg;
								    raise exception FAIL msg;
								};
		    esac;
 

		(g2d::box::upperleft_and_size site)
		    ->
		    (origin as { row, col }, size as { high, wide }); 

		parent_size = p.pixmap.size;

		my (origin, size)											# Select actual site for popup.  We need it to fit entirely within parent.
		    =
		    {   row = max (row, 0);										# Let's start by ensuring that popup origin is not left of or above origin of parent coordinate system..
			col = max (col, 0);										#

			high = max (high, 1);										# Next let's make sure the requested size is positive...
			wide = max (wide, 1);										#

			high = min (high, parent_size.high);								# Now let's ensure that popup can in fact fit within parent.
			wide = min (wide, parent_size.wide);								# 

			row  = min (row, parent_size.high - high);							# Now slide the popup left and/or up as necessary to make it actually fit within parent.
			col  = min (col, parent_size.wide - wide);							#

			({ row, col },  { high, wide });								# That should do it!
		    };

		pixmap =  make_rw_pixmap  size;										# We're blocking for a round-trip here, which is not great.  We probably should implement imports.guiboss_to_windowsystem.pass_fresh_rw_pixmap to allow this to be nonblocking. XXX SUCKO FIXME

		stacking_order = *next_stacking_order;
		#
		next_stacking_order := stacking_order + 1;

		new_backing_pixmap
		    =
		    gt::TOPWINDOW_PIXMAP
		      {
			running_gui	=>   REF NULL,
			pixmap,												# Main backing store for this running gui.
			pixmaps		=>   REF im::empty,								# All other X-server side pixmaps created by/for this running gui.  (We need this to reliably recycle them when we kill the gui -- otherwise we'll be leaking X server memory.)
			popups		=>   REF ([]: List( gt::Backing_Pixmap)),
			parent		=>   THE parent,
			origin		=>   REF origin,
			#
			stacking_order
		      };

		p.popups :=  new_backing_pixmap ! *p.popups;								# Remember that parent Backing_Pixmap has a new child Backing_Pixmap.

		site = g2d::box::make (origin, size);

		(site, new_backing_pixmap);
	    };


	#
	fun restart_gui'
	      (
		runstate as
		  { me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		    guiboss_arg:		Guiboss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# We shut down the microthread when this fires.
		    id:				Id
		  }:				Runstate,
	
		topwindow_for_gui:		gws::Guiboss_To_Topwindow,
# SHOULD PROBABLY RENAME THIS TO base_pixmap or such, since it may be for a popup rather than the real base.
		topwindow_pixmap:		gt::Backing_Pixmap,
		paused_gui:			gt::Paused_Gui,

		gui_startup_complete':		Oneshot_Maildrop( gt::Client_To_Guiwindow ),
		guiboss_q:			Guiboss_Q,
		pause_gui:			(gt::Running_Gui, gt::Sprite_Imps, gt::Object_Imps, gt::Widget_Imps, gt::Gadget_Imps, Topwindow_Info) -> gt::Paused_Gui,
		kill_gui:			(gt::Running_Gui, gt::Sprite_Imps, gt::Object_Imps, gt::Widget_Imps, gt::Gadget_Imps, Topwindow_Info) -> Void
	      )
	    =
	    {
		case topwindow_pixmap
		    #
		    gt::TOPWINDOW_PIXMAP r
			=>												# running_gui is from
			{   r.running_gui := THE running_gui;								#      running_gui = paused_gui__to__running_gui  paused_gui;
			    #												# in below 'where' clause. so as to be available in make_popup().)
			    case r.parent
				#
				NULL  =>    topwindow_info.backing_pixmap :=  THE topwindow_pixmap;			# We're starting a toplevel gui for this topwindow so remember that we now have a gui running on this topwindow.
				THE _ =>    ();										# We're starting a secondary popup gui for this topwindow.
			    esac;
			};

		    gt::VIEWPORT_PIXMAP _
			=>
			{   msg = "topwindow_pixmap should not be VIEWPORT_PIXMAP! -- restart_gui'";
			    log::fatal msg;
			    raise exception FAIL msg;
			};
		esac;

		fire_run_gun ();

		topwindow_for_gui.pass_window_site to
		    #
		    (\\ ({ size => { high => topwindow_high, wide => topwindow_wide }, ... }: g2d::Window_Site)		# topwindow_high and topwindow_wide are currently unused, but you'd think we'd need them eventually.
			=
			{
			    my (high, wide)
				=
				case topwindow_pixmap
				    #
				    gt::TOPWINDOW_PIXMAP r
					=>
					{   r.pixmap.size -> { high, wide };
					    (high, wide);
					};

				    gt::VIEWPORT_PIXMAP r
					=>
					{   msg = "topwindow_pixmap may not be a VIEWPORT_PIXMAP -- restart_gui' in guiboss-imp.pkg";
					    log::fatal msg;
					    raise exception FAIL msg;
					};
				esac;

			    (im::get_or_raise_exception_not_found (*widget_imps, (id_to_int running_gui.widgetspace_id)))
				->
				{ widget_to_widgetspace, guiboss_to_widgetspace as gt::GUIBOSS_TO_WIDGETSPACE ps, endstate_oneshot };


			    site =  { col => 0,  high,									# Allocate all of window pixel area to widgets in running_gui.rg_widget widget-tree.
				      row => 0,  wide
				    }
				    : g2d::Box;

			    ps.pass_re_siting_done_flag
				( site,
				  running_gui.topwindow_pixmap,
				  running_gui.rg_widget
				)
				to
				{.
				    gt::running_gui_postorder_apply							# If a view pixmap is too small to fill its viewport there will be undefined pixels showing in the viewport.
				      (											# By setting the origin to its default 0,0 we trigger the logic to black out these undefined areas.
					running_gui,									# Does doing so result in a double-draw of views at GUI startup?  If so, that might someday prove problematic: XXX QUERO FIXME
					[ gt::SCROLLABLE_VIEW_FN
					    {.
						(#scrollable_view).scroller.set_viewport_origin
						    { row => 0, col => 0 };
					    }
					]
				      );

				    client_to_guiwindow
				      =
				      { id		=>  issue_unique_id (),
					pause_gui	=>  {. pause_gui (running_gui, sprite_imps, object_imps, widget_imps, gadget_imps, topwindow_info); },
					kill_gui	=>  {.  kill_gui (running_gui, sprite_imps, object_imps, widget_imps, gadget_imps, topwindow_info); }
				      }
				      : gt::Client_To_Guiwindow
				      ;

				    put_in_oneshot (gui_startup_complete', client_to_guiwindow);
				}; 

			}
		    );
	    }
	    where
		we_are_a_popup_gui
		    =
		    case topwindow_pixmap
			#
			gt::TOPWINDOW_PIXMAP r
			    =>
			    {   case r.parent
				    #
				    NULL  =>    FALSE;									# We're starting up the primary (toplevel) gui  for this topwindow.
				    THE _ =>    TRUE;									# We're starting a secondary popup gui for this topwindow.
				esac;
			    };
			gt::VIEWPORT_PIXMAP _
			    =>
			    {   msg = "topwindow_pixmap should not be VIEWPORT_PIXMAP! -- restart_gui'";
				log::fatal msg;
				raise exception FAIL msg;
			    };
		    esac;

		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		topwindow_info = im::get_or_raise_exception_not_found (*me.topwindows, id_to_int topwindow_for_gui.id)
				 except
				     NOT_FOUND = {   printf                "*me.topwindows contains no entry for topwindow %d?!   -- restart_gui' in guiboss-imp.pkg\n" (id_to_int topwindow_for_gui.id);
						     log::fatal (sprintf "*me.topwindows contains no entry for topwindow %d?!   -- restart_gui' in guiboss-imp.pkg" (id_to_int topwindow_for_gui.id));
						     raise exception NOT_FOUND;						# Execution will never reach this point, but the compiler doesn't know that log::fatal doesn't return.
						 };
		sprite_imps			=  topwindow_info.sprite_imps;						# Holds our gt::Guiboss_To_Spritespace instances -- can't put them directly in Running_Gui due to circularity.
		object_imps			=  topwindow_info.object_imps;						# Holds our gt::Guiboss_To_Objectspace instances -- can't put them directly in Running_Gui due to circularity.
		widget_imps			=  topwindow_info.widget_imps;						# Holds our gt::Guiboss_To_Widgetspace instances -- can't put them directly in Running_Gui due to circularity.
		gadget_imps			=  topwindow_info.gadget_imps;						# Holds look-imps for all the widgets in our gui.

		current_frame_number		=  topwindow_info.current_frame_number;
		seconds_per_frame		=  topwindow_info.seconds_per_frame;

		mouse_is			=  topwindow_info.mouse_is;						# Support for mouse drag operations.

		done_extra_redraw_request_this_frame
						=  topwindow_info.done_extra_redraw_request_this_frame;

		# We expect the following fns to capture the above values:
		# that is why we define them here rather than more globally.

		#
		fun get_gadget_info
		      (
			gadget_imps:	gt::Gadget_Imps,
			id:		iul::Id
		      )
		    =
		    case (im::get (*gadget_imps,  iul::id_to_int id))
			#
			THE gadget_info =>    gadget_info;

			NULL =>     {   msg = sprintf "imp %d not found in gadget_imps?! -- get_gadget_info in guiboss-imp.pkg" (iul::id_to_int id);	# Should be impossible -- all widgets, sprites and objects should be in gadget_imps.
					log::note_on_stderr {. msg; };
					raise exception FAIL msg;
				    };
		    esac;



		fun set__needs_redraw_request__flag (i: gt::Gadget_Info)
		    =
		    {
			i.needs_redraw_request :=  TRUE;
		    };

		#################################################################################
		# space_to_gui interface fns:

		#
		fun note_widget_site
		      {
			id:		iul::Id,
			backing_pixmap: gt::Backing_Pixmap,
			site:		g2d::Box
		      }													# PUBLIC.
		    =	
		    # This fn is called by
		    #
		    #   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
		    #   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
		    #   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg  
		    #
		    # when they assign a widget a new site in response to our call
		    #
		    #     guiboss_to_widgetspace.pass_re_siting_done_flag
		    #
		    put_in_mailqueue  (guiboss_q,
			#
			\\ ({ me, ... }: Runstate)
			    =
			    {   i = get_gadget_info (gadget_imps, id);
				#
				if (site != *i.site									# Has the window site of this widget changed?
				or   (not (same_id ( gt::backing_pixmap_id_of    backing_pixmap,
						     gt::backing_pixmap_id_of *i.backing_pixmap
				    ) )   )        )
				    #											# Yes.
				    i.site :=  site;									# Note site for widget.

				    i.backing_pixmap :=  backing_pixmap;						# Note pixmap for widget.

				    set__needs_redraw_request__flag i;
				fi;
			    }
		    );

		space_to_gui =	      { id => topwindow_for_gui.id,							# Since each topwindow has a unique id and we will have only one space_to_gui per topwindow, using topwindow_for_gui.id
					#										# here ensures a unique id per space_to_gui. It also makes space_to_gui.id stable across gui stop/restart cycles.
					note_widget_site
				      };


		#################################################################################
		# gadget_to_guiboss interface fns:
		#
		fun needs_redraw_gadget_request										# PUBLIC.
		      (
			id:		iul::Id
		      )
		    =	
		    # The point of this call is to alert us that the
		    # GUI display needs refreshing.
		    # If no widget calls this, we can stop the frame-
		    # redisplay cycle to conserve CPU cycles:
		    #
		    {
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate as { me, imports, ... }:	Runstate)
				=
				{   i = get_gadget_info (gadget_imps, id);
				    #
				    if *done_extra_redraw_request_this_frame
					#
					set__needs_redraw_request__flag i;						# This is the "normal" codepath -- we just remember that this gadget needs a redraw. We'll send it a redraw_gadget_request next time "frameclock" nudges us to run display_one_frame().
				    else
					#										# This is a special codepath intended to reduce user-input response latency in the common case of only one mouseclick or such per frametime (10-100 ms).  For background see Note[3].
					done_extra_redraw_request_this_frame := TRUE;					# Throttle this codepath to at most once per "frameclock" tick, to prevent runaway gadgets from overwhelming the CPU+GPU with redraw_gadget() calls.
					#
					i -> { guiboss_to_gadget
                                               as
                                               gt::GUIBOSS_TO_GADGET g2g, site, gadget_mode, needs_redraw_request, ...
                                             };

					g2g.redraw_gadget_request							# Give the gadget an instant redraw_gadget_request() in response to its needs_redraw_gadget_request() call to us, instead of making it wait until start of next frame (== next time "frameclock" microthread wakes up).
					  {
					    frame_number	=> *current_frame_number,
					    site		=> *site,
					    visible	 	=> TRUE,
					    duration_in_seconds => 0.0,
					    this_gadget_mode	=> *gadget_mode,
					    theme		=> imports.theme
					  };
				    fi;
				}
		        );
		    };

		fun draw_gadget (clip_box, gui_displaylist, gadget_info: gt::Gadget_Info)
		    =
		    {
			gui_displaylist = [ gd::CLIP_TO (clip_box, gui_displaylist) ];					# Clip gadget's displaylist to its assigned site so it won't traspass on neighboring gadgets if it gets sloppy.
			#
			gadget_to_rw_pixmap =  gt::gadget_to_rw_pixmap__of  *gadget_info.backing_pixmap;		# Find gadget's assigned off-screen backing pixmap.

			gadget_to_rw_pixmap.draw_displaylist  gui_displaylist;						# Draw updated gadget appearance into its off-screen backing-pixmap home site.

															# Now to update on-screen image of gadget (if it is visible).
															#
															# We'll update the gadget on the visible window by doing a rectangular blit
															# from offscreen backing pixmap to on-screen pixel refresh buffer.
															#
															# Just redrawing gui_displaylist a second time would be another strategy.
															# The blit has the advantage that the worst case is pretty fast, whereas
															# the worst case for redrawing gui_displaylist can be arbitrarily slow.
															#
															# Also, draw-offscreen-and-blit completely eliminates redraw flicker
															# where "flicker" == partly-redrawn widget being visible momentarily:
															# it is essentially a primitive form of double-buffering.

			from_box =  *gadget_info.site;									# Where should we copy pixels from, on gadget's home pixmap?  We initialize this to the full site for the gadget; later it may get clipped by viewports.
			pixmap	 =  *gadget_info.backing_pixmap;							
			#		
			update_offscreen_parent_pixmaps_and_then_topwindow  (pixmap, from_box, topwindow_for_gui);
		    };

		#
		fun redraw_gadget											# Update gadget appearance in response to a guiboss_to_gadget.redraw_gadget_request {...} call.
		      {
			id:			iul::Id,
			displaylist:		gd::Gui_Displaylist,
			point_in_gadget:	Null_Or( g2d::Point -> Bool )						# Optional function deciding if (e.g.) a mouseclick location is within the gadget. This allows more geometric accuracy than a simple bounding box or such.
		      }
		    =
		    # The point of this call is to update the appearance
		    # of the gadget.  This call is normally made in response
		    # to  guiboss_to_gadget.redraw_gadget_request {}							# guiboss_to_gadget	is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg
		    #
		    {
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{   i = get_gadget_info (gadget_imps, id);
				    #
				    i.point_in_gadget := point_in_gadget; 

				    draw_gadget (*i.site, displaylist, i);
				}
		        );
		    };



		#
		fun note_changed_gadget_activity									# PUBLIC.
		      {
			id:		iul::Id,
			is_active:	Bool
		      }
		    =	
		    # The point of this call is to mark gadget as not
		    # eligible for user input.  It will often be drawn grayed-out.
		    #
		    {   put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{
				    i = get_gadget_info (gadget_imps, id);
				    #
				  (*i.gadget_mode) -> { is_active => _, has_mouse_focus, has_keyboard_focus, mousebutton_is_down };
				    i.gadget_mode  := { is_active,      has_mouse_focus, has_keyboard_focus, mousebutton_is_down };
				}
		        );
		    };


		gadget_to_guiboss =     gt::GADGET_TO_GUIBOSS
					  { id => topwindow_for_gui.id,			# Since each topwindow has a unique id and we will have only one gadget_to_guiboss per topwindow, using topwindow_for_gui.id
					    #						# here ensures a unique id per gadget_to_guiboss. It also makes gadget_to_guiboss.id stable across gui stop/restart cycles.
					    needs_redraw_gadget_request,
					    #
					    redraw_gadget,
					    note_changed_gadget_activity
					  };	






		#################################################################################
		# frameclock microthread -- wakes us up 10 times/sec to draw a frame.
		#

		#
		fun paused_gui__to__running_gui
		    (
		      ( widgetspace_arg:	gt::Widgetspace_Arg,
		        pg_widget:		gt::Pg_Widget
		      )
		    )
		    : gt::Running_Gui
		    =
		    {
			(do_widgetspace  widgetspace_arg)
			    ->
			    stuff as { widget_to_widgetspace, guiboss_to_widgetspace as gt::GUIBOSS_TO_WIDGETSPACE ps, endstate_oneshot };

			widgetspace_id   =  ps.id;

			widget_imps     :=  im::set (*widget_imps, (id_to_int widgetspace_id), stuff);

			(do_pg_widget (pg_widget, widget_to_widgetspace, topwindow_pixmap))
			    ->
			    rg_widget;

			{ fire_end_gun,
			  widgetspace_id,
			  rg_widget,
			  topwindow_pixmap,
			  topwindow		=>  topwindow_for_gui,
			  #
			  gadget_imps_for_gui,
			  sprite_imps_for_gui,
			  object_imps_for_gui,
			  widget_imps_for_gui
			};
		    }
		    where
			gadget_imps_for_gui 	=  REF (im::empty: im::Map( gt::Gadget_Info     ));			# Holds our gt::Gadget_Info            instances for this running gui.
			sprite_imps_for_gui	=  REF (im::empty: im::Map( gt::Sprite_Imp_Info ));			# Holds our gt::Guiboss_To_Spritespace instances for this running gui.
			object_imps_for_gui	=  REF (im::empty: im::Map( gt::Object_Imp_Info ));			# Holds our gt::Guiboss_To_Objectspace instances for this running gui.
			widget_imps_for_gui	=  REF (im::empty: im::Map( gt::Widget_Imp_Info ));			# Holds our gt::Guiboss_To_Widgetspace instances for this running gui.

			fun make_gadget_info
			      (
				guiboss_to_gadget:	gt::Guiboss_To_Gadget,
				backing_pixmap:		gt::Backing_Pixmap
			      )
			      =
			      {
				guiboss_to_gadget,
				backing_pixmap		    =>  REF backing_pixmap,
				#
				needs_redraw_request	    =>	REF FALSE,								# We do not want to draw until we've sent initialize_gadget to gadget.
				sent__initialize_gadget     =>  REF FALSE,
				#
				gadget_mode		    =>  REF { is_active => TRUE,  has_mouse_focus => FALSE,  has_keyboard_focus => FALSE, mousebutton_is_down => FALSE },
				site			    =>  REF g2d::box::zero,
				#
				point_in_gadget		    =>  REF (NULL:  Null_Or( g2d::Point -> Bool ))				# Optional fn to decide if a mouseclick actually hit the gadget itself, or just somewhere near it.
			      };
			#
			fun do_widgetspace  (widgetspace_arg: gt::Widgetspace_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Widgetspace_Arg  );		# When endgun fires we'll read back final widgetspace_imp state via this oneshot.
				#
				widgetspace_egg
				    =
				    pai::make_widgetspace_egg  widgetspace_arg  (THE endstate_oneshot);

				(widgetspace_egg ())
				    ->
				    (exports, widgetspace_egg');

				exports ->  { widget_to_widgetspace, guiboss_to_widgetspace as gt::GUIBOSS_TO_WIDGETSPACE ps };

				widget_imps         :=  im::set (*widget_imps,         (id_to_int ps.id), { widget_to_widgetspace, guiboss_to_widgetspace, endstate_oneshot });
				widget_imps_for_gui :=  im::set (*widget_imps_for_gui, (id_to_int ps.id), { widget_to_widgetspace, guiboss_to_widgetspace, endstate_oneshot });

# NOT VERY SOON add gadget_to_guiboss to imports:
				widgetspace_imports =  { int_sink => \\ (i: Int) = (), space_to_gui };

				widgetspace_egg' (widgetspace_imports, run_gun', end_gun');

				{ widget_to_widgetspace, guiboss_to_widgetspace, endstate_oneshot };
			    }

			also
			fun do_spritespace  (spritespace_arg: gt::Spritespace_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Spritespace_Arg  );		# When endgun fires we'll read back final spritespace_imp state via this oneshot.
				#
				spritespace_egg
				    =
				    boi::make_spritespace_egg  spritespace_arg  (THE endstate_oneshot);

				(spritespace_egg ())
				    ->
				    (exports, spritespace_egg');

				exports -> { guiboss_to_spritespace as gt::GUIBOSS_TO_SPRITESPACE os, sprite_to_spritespace };

				sprite_imps         :=  im::set (*sprite_imps,          id_to_int os.id,  { guiboss_to_spritespace, sprite_to_spritespace, endstate_oneshot });
				sprite_imps_for_gui :=  im::set (*sprite_imps_for_gui,  id_to_int os.id,  { guiboss_to_spritespace, sprite_to_spritespace, endstate_oneshot });
# NOT VERY SOON add gadget_to_guiboss to imports:
				spritespace_imports =  { int_sink => \\ (i: Int) = () };

				spritespace_egg' (spritespace_imports, run_gun', end_gun');

				{ guiboss_to_spritespace, sprite_to_spritespace, endstate_oneshot };
			    }

			also
			fun do_objectspace  (objectspace_arg: gt::Objectspace_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Objectspace_Arg  );		# When endgun fires we'll read back final objectspace_imp state via this oneshot.
				#
				objectspace_egg
				    =
				    cai::make_objectspace_egg  objectspace_arg  (THE endstate_oneshot);

				(objectspace_egg ())
				    ->
				    (exports, objectspace_egg');

				exports -> { guiboss_to_objectspace as gt::GUIBOSS_TO_OBJECTSPACE cs, object_to_objectspace };

				object_imps         :=  im::set (*object_imps,          id_to_int cs.id,  { guiboss_to_objectspace, object_to_objectspace, endstate_oneshot });
				object_imps_for_gui :=  im::set (*object_imps_for_gui,  id_to_int cs.id,  { guiboss_to_objectspace, object_to_objectspace, endstate_oneshot });

# NOT VERY SOON add gadget_to_guiboss to imports:
				objectspace_imports =  { int_sink => \\ (i: Int) = () };

				objectspace_egg' (objectspace_imports, run_gun', end_gun');

				{ guiboss_to_objectspace, object_to_objectspace, endstate_oneshot };
			    }

			also
			fun do_pg_sprite												# XXX SUCKO FIXME should rename to do_sprite.
			      (
				pg_sprite:		gt::Pg_Sprite,
				sprite_to_spritespace:	s2b::Sprite_To_Spritespace,
				current_backing_pixmap:	gt::Backing_Pixmap
			      )
			    =
			    case pg_sprite
				#
			        gt::PG_SPRITE
				      (
					(gt::SPRITE_START_FN sprite_start_fn):	gt::Sprite_Start_Fn,
					saved_sprite_state:					Null_Or(Exception)			# Used by arrowbutton etc to preserve state across gui stop/restart cycles.
				      )
				    =>
				    {   endstate_oneshot										# When endgun fires we'll read back final widget state via this oneshot.
					    =
					    make_oneshot_maildrop()
					    :
					    Oneshot_Maildrop  ( ( gt::Sprite_Start_Fn,
								  Null_Or(Exception)							# saved_sprite_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							      ) );
					#
					(sprite_start_fn { gadget_to_guiboss, sprite_to_spritespace, run_gun', end_gun', endstate_oneshot, saved_sprite_state })
					    ->
					    { guiboss_to_gadget as gt::GUIBOSS_TO_GADGET b2g, spritespace_to_sprite };


					gadget_info  =  make_gadget_info  (guiboss_to_gadget, current_backing_pixmap);

					gadget_imps         :=  im::set (*gadget_imps,         iul::id_to_int b2g.id,  gadget_info );
					gadget_imps_for_gui :=  im::set (*gadget_imps_for_gui, iul::id_to_int b2g.id,  gadget_info );

					gt::RG_SPRITE { spritespace_to_sprite, guiboss_to_gadget, endstate_oneshot };
				    };

			    esac


			also
			fun do_pg_object
			      (
				pg_object:		gt::Pg_Object,
				object_to_objectspace:	o2c::Object_To_Objectspace,
				current_backing_pixmap:	gt::Backing_Pixmap
			      )
			    =
			    case pg_object
				#
				gt::PG_WIDGETSPACE  (widgetspace_arg:  gt::Widgetspace_Arg,  pg_widget: gt::Pg_Widget)
				    =>
				    {
					(do_widgetspace  widgetspace_arg)
					    ->
					    stuff as { widget_to_widgetspace, guiboss_to_widgetspace as gt::GUIBOSS_TO_WIDGETSPACE ps, endstate_oneshot };

					widget_imps         :=  im::set (*widget_imps,         (id_to_int ps.id), stuff);
					widget_imps_for_gui :=  im::set (*widget_imps_for_gui, (id_to_int ps.id), stuff);

					(do_pg_widget (pg_widget, widget_to_widgetspace, current_backing_pixmap))
					    ->
					    rg_widget;

					gt::RG_WIDGETSPACE { widgetspace_id => ps.id,  rg_widget };
				    };

				gt::PG_OBJECT
				      (
					(gt::OBJECT_START_FN object_start_fn):	gt::Object_Start_Fn,
					saved_object_state:					Null_Or(Exception)			# Used by arrowbutton etc to preserve state across gui stop/restart cycles.
				      )
				    =>
				    {   endstate_oneshot										# When endgun fires we'll read back final object state via this oneshot.
					    =
					    make_oneshot_maildrop()
					    :
					    Oneshot_Maildrop( ( gt::Object_Start_Fn,
								Null_Or(Exception)							# saved_object_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							      )
							    );
					#
					(object_start_fn { gadget_to_guiboss, object_to_objectspace, run_gun', end_gun', endstate_oneshot, saved_object_state })
					    ->
					    { guiboss_to_gadget as gt::GUIBOSS_TO_GADGET b2g, objectspace_to_object };


					gadget_info  =  make_gadget_info  (guiboss_to_gadget, current_backing_pixmap);

					gadget_imps         :=  im::set (*gadget_imps,         iul::id_to_int b2g.id,  gadget_info );
					gadget_imps_for_gui :=  im::set (*gadget_imps_for_gui, iul::id_to_int b2g.id,  gadget_info );

					gt::RG_OBJECT { objectspace_to_object, guiboss_to_gadget, endstate_oneshot };
				    };
			    esac

			also
			fun do_pg_widget
			      (
				pg_widget:		gt::Pg_Widget,							# 'pg_widget' can be a tree of widgets with ROW and COL internal nodes.
				widget_to_widgetspace:	w2p::Widget_To_Widgetspace,
				current_backing_pixmap:	gt::Backing_Pixmap
			      )
			    =
			    case pg_widget
				#
				gt::PG_ROW	(pg_widgets:	 List( gt::Pg_Widget ))					# A row of widgets. The ROW itself is not a widget (given no microthread).
				    =>
				    {
					widgets =   map  do_widget  pg_widgets
						    where
							fun do_widget
							    (
							      pg_widget:	gt::Pg_Widget
							    )
							    =
							    do_pg_widget  (pg_widget, widget_to_widgetspace, current_backing_pixmap);
						    end;

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

					gt::RG_ROW  { widgets,
						      #
						      pixels_high_min,
						      pixels_wide_min,
						      #
						      pixels_high_cut,
						      pixels_wide_cut,
						      #
						      site =>  REF  g2d::box::zero
						    };
				    };

				gt::PG_COL	(pg_widgets:	 List( gt::Pg_Widget ))					# A column of widgets. The COL itself is not a widget (given no microthread).
				    =>
				    {
					widgets =   map  do_widget  pg_widgets
						    where
							fun do_widget
							    (
							      pg_widget:	gt::Pg_Widget
							    )
							    =
							    do_pg_widget  (pg_widget, widget_to_widgetspace, current_backing_pixmap);
						    end;

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

					site		=  REF  g2d::box::zero;

					gt::RG_COL  { widgets,
						      #
						      pixels_high_min,
						      pixels_wide_min,
						      #
						      pixels_high_cut,
						      pixels_wide_cut,

						      site
						    };
				    };

				gt::PG_GRID	(pg_widgets:	List( List( gt::Pg_Widget )))		# A grid of widgets. The GRID itself is not a widget (given no microthread).
				    =>
				    {
					widgets =   map  do_row  pg_widgets
						    where
							fun do_row
							    (row:   List( ( gt::Pg_Widget) ))
							    =
							    map  do_widget  row
							    where
								fun do_widget
								    (
								      pg_widget:	gt::Pg_Widget
								    )
								    =
								    do_pg_widget  (pg_widget, widget_to_widgetspace, current_backing_pixmap);
							    end;
						    end;

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

					site		=  REF  g2d::box::zero;

					gt::RG_GRID { widgets,
						      #
						      pixels_high_min,
						      pixels_wide_min,
						      #
						      pixels_high_cut,
						      pixels_wide_cut,

						      site
						    };
				    };

				gt::PG_SCROLLABLE_VIEW									# A viewport onto a scrollable pixmap
				  (
				    w
				    as
				    ( callback:		gt::Viewport_Scroller_Callback,
				      pixmap_size:	g2d::Size,
				      pg_widget:	gt::Pg_Widget
				  ) )
				    =>
				    {
					gadget_to_rw_pixmap	=   imports.guiboss_to_windowsystem.make_rw_pixmap
									#
									pixmap_size;

					topwindow_pixmap.pixmaps							# Note new rw_pixmap associated with this running gui,
					    :=										# so that we can free it reliably at kill-gui time.
					    im::set ( *topwindow_pixmap.pixmaps,
						      id_to_int gadget_to_rw_pixmap.id,
						      gadget_to_rw_pixmap
						    )
					    where
						topwindow_pixmap
						    =
						    gt::topwindow_pixmap_of_backing_pixmap
							#
							current_backing_pixmap;
					    end;



					view_origin     =  REF { row => 0,						# View origin in viewport coordinates. Controls which part of view is visible in viewport.  guiboss-imp.pkg will update this in response to scrollbar motions etc.
								 col => 0
							       };

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

					viewport	=  REF g2d::box::zero;						# Dummy initial value -- real value will be set by   assign_sites_to_all_widgets()   in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

					viewport_record = { parent_pixmap  => current_backing_pixmap,			# The backing_pixmap we were doing before diving recursively into this view.
							    view_origin => view_origin,
							    viewport_site  => viewport					# Site of view on parent.
															# XXX SUCKO FIXME Currently we store 'site' both here and in gt::SCROLLABLE_VIEW.
															#           We'll probably wind up using only one;  (???)
															#		  we should delete the unused one.
							  };

					backing_pixmap  = gt::VIEWPORT_PIXMAP
							    {
							      pixmap     =>  gadget_to_rw_pixmap,			# The backing pixmap for this view.
							      viewports  =>  REF [ viewport_record ],			# Initially at least view_pixmap is visible through only this one viewport.
							      is_visible =>  REF TRUE	
							    };

					rg_widget = do_pg_widget  (pg_widget, widget_to_widgetspace, backing_pixmap);	# Process widget in new backing_pixmap not current_backing_pixmap!

					viewport_scroller									# Define the get/set fns client code uses to scroll the viewport.
					    =
					    { get_viewport_origin,
					      set_viewport_origin
					    }
					    where
						fun get_viewport_origin ()
						    =
						    *view_origin;								# Origin of gadget_to_rw_pixmap in viewport coordinates, used for scrolling pixmap in viewport.

						fun set_viewport_origin (view_origin_in_viewport_coordinates: g2d::Point)
						    =
						    {										# In this routine we must clearly distinguish three different coordinate systems.
																# We are dealing with a backing_pixmap for a scrollable view which is visible
																# through a viewport which is located on a parent backing_pixmap.
																# Thus, we have:
																#  o  The coordinate system of the view itself, with 0,0 at upper-left of the view's backing pixmap.
																#  o  The coordinate system of the parent,      with 0,0 at upper-left of its own    backing pixmap.
																#  o  The coordinate system of the viewport,    with 0,0 at upper-left of the viewport.
																# These three coordinate systems are related by
																#  o  viewport_site, which gives the viewport origin (and size) in parent   coordinates.
																#  o  view_origin,   which gives the view     origin            in viewport coordinates.
																# We have boxes in all three coordinate systems here, so we must track carefully which box is in which coordinate system.

							view_origin := view_origin_in_viewport_coordinates;			# Note new origin of gadget_to_rw_pixmap in viewport coordinates, used for scrolling pixmap in viewport.

							viewport_site_in_parent_coordinates
							    =
							    *viewport;

							viewport_origin_in_parent_coordinates
							    =
							    g2d::box::upperleft  viewport_site_in_parent_coordinates;

							view_site_in_parent_coordinates
							    =
							    g2d::box::make
							      (
								view_origin_in_viewport_coordinates + viewport_origin_in_parent_coordinates,
								gadget_to_rw_pixmap.size
							      );

							view_site_in_view_coordinates
							    =
							    g2d::box::make
							      (
								g2d::point::zero,
								gadget_to_rw_pixmap.size
							      );

							viewport_origin_in_view_coordinates
							    =
							    g2d::point::zero - view_origin_in_viewport_coordinates;

							viewport_site_in_view_coordinates
							    =
							    g2d::box::clone_box_at
							      (
								viewport_site_in_parent_coordinates,
								viewport_origin_in_view_coordinates
							      );

							if (not (g2d::box::box_a_in_box_b { a => viewport_site_in_view_coordinates,	# Does our pixmap fill the viewport on parent pixmap?
											    b => view_site_in_view_coordinates
											  }
							   )    )
							    #										# No, so we have to clear the remainder of the viewport.
							    #
							    boxes_to_clear =  g2d::box::subtract_box_b_from_box_a			# Express area to be cleared as a list of non-overlapping rectangles.
										{
										  a => viewport_site_in_parent_coordinates,
										  b => view_site_in_parent_coordinates
										};

							    apply do_box boxes_to_clear							# For each box to be cleared ...
								where
								    fun do_box (box: g2d::Box)
									=
									{
									    clear_box_in_pixmap (viewport_record.parent_pixmap, box);	# ... fill it with black, then ...
									    #
									    update_offscreen_parent_pixmaps_and_then_topwindow		# ... copy that blackness all the way up the viewport chain to visible topwindow.
										#
										(viewport_record.parent_pixmap, box, topwindow_for_gui);
									};
								end;
							fi;

							from_box = g2d::box::intersection						# We want to draw on parent only that part which is visible and which exists.
								      (
									viewport_site_in_view_coordinates,				# This is the part that is visible.
									view_site_in_view_coordinates					# This is what exists.
								      );	

							case from_box
							    #
							    NULL         => ();								# No intersection means nothing to draw. Pixmap must be scrolled completely out of sight...
							    #
							    THE from_box => update_offscreen_parent_pixmaps_and_then_topwindow		# Draw visible part pixmap on parent.
									        #
										(backing_pixmap, from_box, topwindow_for_gui);
							esac;
						    };	
					    end;

					callback (THE viewport_scroller);						# Give app client code a handle with which to gadget_to_rw_pixmap in viewport.

					gt::RG_SCROLLABLE_VIEW { scroller => viewport_scroller, callback, rg_widget, gadget_to_rw_pixmap, view_origin, backing_pixmap, site => viewport };
				    };

				gt::PG_TABBED_VIEWS									# A viewport onto a set of alternate pixmaps for tabbed viewing.
				      (
					callback:	gt::Tabbed_View_Picker_Callback,
					pixmap_size:	g2d::Size,
					widgets:	List( gt::Pg_Widget )
				      )
				    =>
				    {
					if ((list::length widgets) == 0)						# We could be more robust by supporting empty 'widgets', but that would give us special
					    log::fatal "TABBED_VIEWS needs at least one view! -- guiboss-imp.pkg";	# cases in the code every time we access visible_widget.  Maybe it is worth it?
					    ();										# We'd have to make visible_widgets be Ref(Null_Or(Tabview)) instead of just Ref(Tabview).
					fi;

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

					viewport	=  REF g2d::box::zero;						# Dummy initial value -- real value will be set by   assign_sites_to_all_widgets()   in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

					visible		=  REF TRUE;							# We'll default this to TRUE for first widget, FALSE for the rest.

					widgets =   map  do_widget  widgets
						    where
							fun do_widget
							    (
							      pg_widget:	gt::Pg_Widget
							    )
							    =
							    {	widget		= do_pg_widget  (pg_widget, widget_to_widgetspace, current_backing_pixmap);
								#
								gadget_to_rw_pixmap = imports.guiboss_to_windowsystem.make_rw_pixmap
										          #
										          pixmap_size;

								view_origin  =   REF { row => 0,					# View origin in viewport coordinates. Controls which part of view is visible in viewport.  For tabbed views this will never be changed.
										       col => 0
										     };

								backing_pixmap  = gt::VIEWPORT_PIXMAP
										    {
										      is_visible => REF *visible,
										      #		
										      pixmap     => gadget_to_rw_pixmap,				# The backing pixmap for this view.

										      viewports  => REF [						# Initially at least view_pixmap is visible through only this one viewport.
													  { parent_pixmap => current_backing_pixmap,	# The backing_pixmap we were doing before diving recursively into this view.
													    view_origin,
													    viewport_site => viewport			# Site of view on parent.
																			# XXX SUCKO FIXME Currently we store 'site' both here and in gt::SCROLLABLE_VIEW.
																			#           We'll probably wind up using only one;  (???)  BTW, SHOULDN'T THIS BE A REF so WE CAN UPDATE SITE WHEN DOING RE-LAYOUT?
																			#		  we should delete the unused one.

													  }
												        ]	
										    };

								visible   := FALSE;

								{ widget, gadget_to_rw_pixmap, backing_pixmap };
							    };
						    end;

					visible_widget	=  REF (head widgets);										# Default to displaying first view, if there is more than one.

					tabbed_view_picker
					    =
					    { get_active_view,
					      set_active_view
					    }
					    where
						fun number_of_active_widget  ([]: List(gt::Tabview),  i: Int)
							=>
							0;

						    number_of_active_widget ((widget ! rest), i)
						        =>
							if (id_to_int widget.gadget_to_rw_pixmap.id == id_to_int (*visible_widget).gadget_to_rw_pixmap.id)   i;
							else										                     number_of_active_widget (rest, i+1);
							fi;
						end;

						fun get_active_view ()
						    =
						    number_of_active_widget (widgets, 0);

						fun set_active_view (i: Int)
						    =
						    {   widget_count = list::length widgets;
							#
							if (i != get_active_view ())							# Do nothing if client code is re-selecting already-active tabview.
							    #
							    if (i >= 0  and  i < widget_count)
								#
								case ((*visible_widget).backing_pixmap)
								    #
								    gt::VIEWPORT_PIXMAP r =>   r.is_visible := FALSE;			# Remember previously visible view is now not visible.
								    _			  =>	();					# Shouldn't happen.
								esac;

								visible_widget :=  list::nth (widgets, i);

								case ((*visible_widget).backing_pixmap)
								    #
								    gt::VIEWPORT_PIXMAP r =>   r.is_visible := TRUE;			# Remember newly visible view is now visible.
								    _			   =>	();					# Shouldn't happen.
								esac;
							    else
								log::note_on_stderr {. sprintf "set_active_view: arg = %d not in range 0 -> %d\n" i widget_count; };
							    fi;

							    from_box =    g2d::box::make						# We want to update the whole pixmap. (A tabview should always be the same size as the viewport, and all of it needs updating.)
									    (
									      g2d::point::zero, 
									      (*visible_widget).gadget_to_rw_pixmap.size
									    );

							    update_offscreen_parent_pixmaps_and_then_topwindow				# Draw pixmap on parent.
								#
								((*visible_widget).backing_pixmap, from_box, topwindow_for_gui);

							fi;

							();
						    };	
					    end;

					callback (THE tabbed_view_picker);								# Give app client code a handle with which to gadget_to_rw_pixmap in viewport.

					gt::RG_TABBED_VIEWS { callback, pixmap_size, widgets, visible_widget, site => viewport };
				    };

				gt::PG_FRAME    ( frame_widget,
						  widget
						)
				    =>
				    {
					fun do_widget
					    (
					      pg_widget:	gt::Pg_Widget
					    )
					    =
					    do_pg_widget  (pg_widget, widget_to_widgetspace, current_backing_pixmap);

					widget		=  do_widget  widget;
					frame_widget	=  do_widget  frame_widget;

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_widget_tree() in  src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

					site		=  REF  g2d::box::zero;


					gt::RG_FRAME
					  {
					    frame_widget,
					    widget,
					    #
					    pixels_high_min,
					    pixels_wide_min,
					    #
					    pixels_high_cut,
					    pixels_wide_cut,

					    site
					  };
				    };

				gt::PG_WIDGET
				      (
					(gt::WIDGET_START_FN widget_start_fn):		gt::Widget_Start_Fn,	# widget_start_fn  was generated by  make_widget_start_fn  in  src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
					saved_widget_state:						Null_Or(Exception)		# Used by arrowbutton etc to preserve state across gui stop/restart cycles.
				      )
				    =>
				    {   endstate_oneshot										# When endgun fires we'll read back final widget state via this oneshot.
					    =
					    make_oneshot_maildrop()
					    :
					    Oneshot_Maildrop  ( ( gt::Widget_Start_Fn,
								  Null_Or(Exception)							# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							      ) );
					#
					(widget_start_fn { gadget_to_guiboss, widget_to_widgetspace, run_gun', end_gun', endstate_oneshot, saved_widget_state })
					    ->
					    { guiboss_to_gadget as gt::GUIBOSS_TO_GADGET b2g, widgetspace_to_widget };


					gadget_info  =  make_gadget_info  (guiboss_to_gadget, current_backing_pixmap);

					gadget_imps         :=  im::set (*gadget_imps,         iul::id_to_int b2g.id,  gadget_info );
					gadget_imps_for_gui :=  im::set (*gadget_imps_for_gui, iul::id_to_int b2g.id,  gadget_info );

					site =  REF  g2d::box::zero;

					gt::RG_WIDGET { widgetspace_to_widget, guiboss_to_gadget, endstate_oneshot, site };
				    };


				gt::PG_OBJECTSPACE
				    ( objectspace_arg:	gt::Objectspace_Arg,
				      pg_objects:	List( gt::Pg_Object )
				    )
				    =>
				    {
					(do_objectspace  objectspace_arg)
					    ->
					    stuff as { guiboss_to_objectspace as gt::GUIBOSS_TO_OBJECTSPACE cs, object_to_objectspace, endstate_oneshot };

					objectspace_id =  cs.id;

					object_imps         :=  im::set (*object_imps,         (id_to_int objectspace_id), stuff);
					object_imps_for_gui :=  im::set (*object_imps_for_gui, (id_to_int objectspace_id), stuff);

					#
					objects	=   map  do_object  pg_objects
						    where
							fun do_object (pg_object: gt::Pg_Object)
							    =
							    do_pg_object  (pg_object, object_to_objectspace, current_backing_pixmap);
						    end;

					site =  REF  g2d::box::zero;

					gt::RG_OBJECTSPACE { objectspace_id,  objects, site };
				    };

				gt::PG_SPRITESPACE
				    ( spritespace_arg:	gt::Spritespace_Arg,
				      pg_sprites:	List(gt::Pg_Sprite)
				    )
				    =>
				    {
					(do_spritespace  spritespace_arg)
					    ->
					    stuff as { guiboss_to_spritespace as gt::GUIBOSS_TO_SPRITESPACE os, sprite_to_spritespace, endstate_oneshot };

					sprite_imps         :=  im::set (*sprite_imps,         (id_to_int os.id), stuff);
					sprite_imps_for_gui :=  im::set (*sprite_imps_for_gui, (id_to_int os.id), stuff);

					#
					sprites	=   map  do_sprite  pg_sprites
						    where
							fun do_sprite (pg_sprite: gt::Pg_Sprite)
							    =
							    do_pg_sprite  (pg_sprite, sprite_to_spritespace, current_backing_pixmap);
						    end;

					spritespace_id =  os.id;

					site =  REF  g2d::box::zero;

					gt::RG_SPRITESPACE { spritespace_id, sprites, site };
				    };

				gt::PG_NULL_WIDGET
				    =>
				    gt::RG_NULL_WIDGET;
			    esac;
		    end;														# fun paused_gui__to__running_gui



		#
		running_gui = paused_gui__to__running_gui  paused_gui;									# Starts up all widget look-imps and state-imps plus the object- sprite- and widgetspace imps,
																	# and populates our sprite_imps, object_imps, widget_imps and gadget_imps maps.

		fun make_popup														# PUBLIC. Create popup pane on given window in given site.  Given site is adjusted to lie entirely within parent (if necessary) and returned.
		      (
			requested_site:		g2d::Box,
			gui_plan:		gt::Gui_Plan
		      )
		    : (
			g2d::Box,
			gt::Client_To_Guiwindow
		      )
		    =
		    {	gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Client_To_Guiwindow );
			#
			actual_site_and_backing_pixmap'
			    =
			    make_oneshot_maildrop():  Oneshot_Maildrop( (g2d::Box, gt::Backing_Pixmap) );
			#
			put_in_mailqueue  (guiboss_q,											# make_popup() is intended to be called by widget code, so our first task is to transition from caller's microthread to the guiboss-imp microthread.
			    #
			    \\ (runstate as { me, imports, ... }: Runstate)								# Once into the body of this fn we are running in the guiboss-imp microthread.
				=
				{
				    (make_backing_pixmap_for_popup									# Make a new rw_pixmap, wrap it in a TOPWINDOW_PIXMAP, enter latter into the TOPWINDOW_PIXMAP popup hierarchy for this gui.
				      (
					imports.guiboss_to_windowsystem.make_rw_pixmap,							# To allocate the actual rw_pimap for the Backing_Pixmap.
					topwindow_info.next_stacking_order,								# To allocate a 'stacking_order' value for Backing_Pixmap.
					topwindow_pixmap,										# Our parent Backing_Pixmap.
					requested_site											# Where to put popup on parent Backing_Pixmap.
				      )
				    ) -> (actual_site, backing_pixmap);

				    put_in_oneshot (actual_site_and_backing_pixmap', (actual_site, backing_pixmap));			# Pass actual site of popup back to calling microthread, plus backing pixmap for popup GUI.

				    start_gui'
				      (
					runstate: 		Runstate,
					#	
					topwindow_for_gui:	gws::Guiboss_To_Topwindow,
					backing_pixmap:		gt::Backing_Pixmap,
					gui_plan:		gt::Gui_Plan,

					gui_startup_complete':	Oneshot_Maildrop( gt::Client_To_Guiwindow ),
					guiboss_q:		Guiboss_Q,
					pause_gui:		(gt::Running_Gui, gt::Sprite_Imps, gt::Object_Imps, gt::Widget_Imps, gt::Gadget_Imps, Topwindow_Info) -> gt::Paused_Gui,
					kill_gui:		(gt::Running_Gui, gt::Sprite_Imps, gt::Object_Imps, gt::Widget_Imps, gt::Gadget_Imps, Topwindow_Info) -> Void
				      );
				}
			);

			(get_from_oneshot  actual_site_and_backing_pixmap')
			    ->
			    (actual_site, backing_pixmap);		  								# Read actual site of popup back from guiboss-imp microthread, also backing pixmap for popup GUI.

			client_to_guiwindow =  get_from_oneshot  gui_startup_complete'; 						# Wait until popup startup is complete.  We do this in caller's thread to reduce risk of lockup -- caller is typically a button that can afford to sleep a bit.

			( actual_site,
			  client_to_guiwindow												# Return port to the running popup.
			);
		    };

		if (not we_are_a_popup_gui)												# One frameclock microthread per topwindow is quite sufficient, so we avoid starting extra ones up each time we start up a secondary (popup) gui.
		    #
		    make_thread'  [ THREAD_NAME "frameclock" ]  frameclock  end_gun'							# Start up frameclock thread which tells us when it is time to draw a new frame.
			where
			    fun display_one_frame ({ me, imports, ... }: Runstate)							# THIS FUNCTION RUNS IN THE REGULAR GUIBOSS_IMP MICROTHREAD, NOT THE "frameclock" MICROTHREAD.
				=
				{
				    current_frame_number := *current_frame_number + 1;
				    #
				    done_extra_redraw_request_this_frame	:= FALSE;						# See Note[3].

				    imps =  im::vals_list  *gadget_imps;

				    apply' imps  {.
					#
					#imp -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, site, gadget_mode, needs_redraw_request, sent__initialize_gadget, backing_pixmap, ... };

					if (not *sent__initialize_gadget  and  *site != g2d::box::zero)					# If *site==g2d::box::zero then widgetspace_imp has not yet done layout and we cannot yet call initialize_gadget or redraw_gadget_request, since both require a valid site.
					    #
					    fun make_rw_pixmap (size: g2d::Size):  g2p::Gadget_To_Rw_Pixmap
						=
						{   rw_pixmap = imports.guiboss_to_windowsystem.make_rw_pixmap( size );
						    #
						    topwindow_pixmap
							=
							gt::topwindow_pixmap_of_topwindow_pixmap_or_viewport_pixmap
							    #
							    *backing_pixmap;

						    topwindow_pixmap.pixmaps
							:=  
							im::set ( *topwindow_pixmap.pixmaps,
								  id_to_int rw_pixmap.id,
								  rw_pixmap
								);

						    #
						    rw_pixmap;	
						};

					    guiboss_to_gadget.initialize_gadget  { site		=> *site,
										    theme		=>  imports.theme,
										     get_font		=>  topwindow_for_gui.get_font,
										    pass_font		=>  topwindow_for_gui.pass_font,
										    make_rw_pixmap,
										    make_popup
										  };

					    sent__initialize_gadget := TRUE;
					    needs_redraw_request    := TRUE;
					fi;
				    };

				    apply' imps  {.
					#imp -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, site, gadget_mode, needs_redraw_request, ... };
					    #

					if (*needs_redraw_request  and  *site != g2d::box::zero)					# If *site==g2d::box::zero then widgetspace_imp has not yet done layout and we cannot yet call redraw_gadget_request because it requires a valid site.
					    #
					    guiboss_to_gadget.redraw_gadget_request
					      {
						frame_number => *current_frame_number,
						site => *site,
						visible => TRUE,
						duration_in_seconds => 0.0,
						this_gadget_mode => *gadget_mode,
						theme => imports.theme
					      };

					    needs_redraw_request := FALSE;
					fi;
				    };
				};	


# XXX SUCKO FIXME we should probably just use the 50HZ timeslicing clock.
			    # This fn provides the body for a little microthread which just
			    # loops ten times a second telling our main thread to disply frame:
			    #
			    fun frameclock end_gun'													# THIS FUNCTION RUNS IN THE "frameclock" MICROTHREAD.
				=
				loop ()
				where
				    count = REF 19;
				    #
				    fun loop ()
					=
					{
					    do_one_mailop [
						#
						end_gun'
						    ==>
						    {.
							thread_exit { success => TRUE };
						    },
						#
						timeout_in' *seconds_per_frame
						    ==>
						    {.
							put_in_mailqueue  (guiboss_q, display_one_frame);
						    }
					    ];

					    loop ();
					};
				end;
			end;
		    ();
		fi;
	    end																		# fun restart_gui'

	#
	also																		# restart_gui'() and start_gui'() need to be mutually recursive so make_popup() can call start_gui'.
	fun start_gui'
	      (
		runstate: 		Runstate,
		#	
		topwindow_for_gui:	gws::Guiboss_To_Topwindow,
		topwindow_pixmap:	gt::Backing_Pixmap,
		gui_plan:		gt::Gui_Plan,

		gui_startup_complete':	Oneshot_Maildrop( gt::Client_To_Guiwindow ),
		guiboss_q:		Guiboss_Q,
		pause_gui:		(gt::Running_Gui, gt::Sprite_Imps, gt::Object_Imps, gt::Widget_Imps, gt::Gadget_Imps, Topwindow_Info) -> gt::Paused_Gui,
		kill_gui:		(gt::Running_Gui, gt::Sprite_Imps, gt::Object_Imps, gt::Widget_Imps, gt::Gadget_Imps, Topwindow_Info) -> Void
	      )
	    =
	    {	paused_gui =  gui_plan__to__paused_gui  gui_plan;
		#
	        restart_gui' (runstate, topwindow_for_gui, topwindow_pixmap, paused_gui, gui_startup_complete', guiboss_q, pause_gui, kill_gui);
	    }
	    where
		fun gui_plan__to__paused_gui  (gp_widget:	gt::Gp_Widget)
		    :
		    gt::Paused_Gui
		    =
		    {
			(do_gp_widget gp_widget)
			    ->
			    pg_widget;

			( []:				gt::Widgetspace_Arg,
			  pg_widget:			gt::Pg_Widget
			);
		    }
		    where
			fun do_gp_sprite (gp_sprite: gt::Gp_Sprite)
			    =
			    case gp_sprite
				#
			        gt::SPRITE a =>  gt::PG_SPRITE (a, NULL);										# SUBSTANTIVE CHANGE
			    esac

			also
			fun do_gp_object (gp_object: gt::Gp_Object)
			    =
			    case gp_object
				#
				gt::WIDGETSPACE  (widgetspace_arg:  gt::Widgetspace_Arg,  gp_widget: gt::Gp_Widget)
				    =>
				    {
					(do_gp_widget gp_widget)
					    ->
					    pg_widget;

					gt::PG_WIDGETSPACE (widgetspace_arg,  pg_widget);
				    };

			        gt::OBJECT a =>  gt::PG_OBJECT (a, NULL);										# SUBSTANTIVE CHANGE
			    esac

			also
			fun do_gp_widget (gp_widget: gt::Gp_Widget)											# 'gp_widget' can be a tree of widgets with ROW and COL internal nodes.
			    =
			    case gp_widget
				#
			        gt::ROW	(gp_widgets:	 List( gt::Gp_Widget ))										# A row of widgets. The ROW itself is not a widget (given no microthread).
				    =>
				    {
					pg_widgets
					    =
					    map  do_widget  gp_widgets
					    where
						fun do_widget
						    (
						      gp_widget:	gt::Gp_Widget
						    )
						    =
						    ( do_gp_widget  gp_widget
						    );
					    end;

					gt::PG_ROW  pg_widgets;
				    };

			        gt::COL	(gp_widgets:	 List( gt::Gp_Widget ))										# A column of widgets. The COL itself is not a widget (given no microthread).
				    =>
				    {
					pg_widgets
					    =
					    map  do_widget  gp_widgets
					    where
						fun do_widget
						    (
						      gp_widget:	gt::Gp_Widget
						    )
						    =
						    ( do_gp_widget  gp_widget
						    );
					    end;

					gt::PG_COL  pg_widgets;
				    };

			        gt::GRID (gp_widgets: List(	 List( gt::Gp_Widget )))								# A column of widgets. The COL itself is not a widget (given no microthread).
				    =>
				    {
					my { high, wide }												# 'wide' is used below in do_row;  'high' is unused.
					    =
					    grid_dimensions  gp_widgets
					    #
					    where
						fun grid_dimensions (grid:  List( List( gt::Gp_Widget )))
						    #
						    :   g2d::Size
						    =
						    {   high =  list::length grid;
							wide =  int::list_max (map list::length grid);
							#
							{ high, wide };
						    };
					    end;


					regularized_grid												# We should probably produce a 2D matrix of some sort as our result instead of another list of lists;
					    =														# the code using the list-of-lists representation gets pretty ugly. XXX SUCKO FIXME.
					    regularize_grid  gp_widgets											# Make all rows same length by padding with blank.pkg widgets as needed.
					    #
					    where
						fun regularize_grid (grid:	List( List( gt::Gp_Widget )))
						    =
						    map do_row grid
						    where
							fun do_row (row: 	List( gt::Gp_Widget ))
							    =
							    do_row' (row, wide, [])
							    where
								fun do_row' (w ! rest, i, result)
									=>
									do_row' (rest,  i - 1,  w ! result);

								    do_row' ([], 0, result)
									=>
									reverse result;

								    do_row' ([], i, result)
									=>
									do_row'  ([],  i - 1,  (blank::with []) ! result);
								end;
							    end;
						    end;
					    end;	



					pg_widgets
					    =
					    map  do_row  regularized_grid
					    where
						fun do_row   (widgets:	List( gt::Gp_Widget ))
						    =
						    map  do_widget  widgets
						    where
							fun do_widget
							    (
							      gp_widget:	gt::Gp_Widget
							    )
							    =
							    do_gp_widget  gp_widget;
						    end;
					    end;

					gt::PG_GRID  pg_widgets;
				    };

			        gt::SCROLLABLE_VIEW ( triple
						      as
							( callback:		gt::Viewport_Scroller_Callback,
							  pixmap_size:		g2d::Size,
							  gp_widget:		gt::Gp_Widget
						    )   )
				    =>
				    {
					triple = do_pair (callback, pixmap_size, gp_widget)
						where
						    fun do_pair
							(
							  callback:		gt::Viewport_Scroller_Callback,
							  pixmap_size:		g2d::Size,
							  gp_widget:		gt::Gp_Widget
							)
							=
							( callback,
							  pixmap_size,
							  do_gp_widget  gp_widget
							);
						end;
					
					gt::PG_SCROLLABLE_VIEW triple;
				    };

			        gt::TABBED_VIEWS
				      (
					callback:	gt::Tabbed_View_Picker_Callback,
					pixmap_size:	g2d::Size,
					widgets:	List( gt::Gp_Widget )
				      )
				    =>
				    {
					widgets = map do_widget widgets
						where
						    fun do_widget
							(
							  gp_widget:	gt::Gp_Widget
							)
							=
							do_gp_widget  gp_widget;
						end;
					
					gt::PG_TABBED_VIEWS (callback, pixmap_size, widgets);
				    };

			        gt::FRAME
				      (
					options:	List( gt::Frame_Option ),
					widget:		gt::Gp_Widget
				      )
				    =>
				    {
					frame_widget
					    =
					    case options
						#
						[ ]				  =>    frm::with [];						# Default to standard frame from   src/lib/x-kit/widget/leaf/frame.pkg

						[ gt::FRAME_WIDGET frame_widget ] =>    ( /* [], */ gt::WIDGET frame_widget);				# Custom frame widget. This won't work currently if margins are non-default, but changing relief is ok.

						_				  =>    {   msg = "Unsupported List(Frame_Option) arg in paused_gui__to__running_gui/gt::PG_FRAME -- guiboss-imp.pkg";
											    log::fatal msg;
											    raise exception FAIL msg;
											};
					    esac;

					widget	     =  do_gp_widget       widget;
					frame_widget =  do_gp_widget frame_widget;
					
					gt::PG_FRAME (( /* [], */ frame_widget), ( /* [], */ widget));
				    };

			        gt::WIDGET   a =>  gt::PG_WIDGET (a, NULL);									# SUBSTANTIVE CHANGE
																		# The NULL is the saved_widget_state: Null_Or(Exception) used by arrowbutton etc to preserve state across gui stop/restart cycles.
			        gt::OBJECTSPACE
				    ( objectspace_arg:	gt::Objectspace_Arg,
				      gp_objects:	List(gt::Gp_Object)
				    )
				    =>
				    {
					gp_objects
					    =
					    map  do_object  gp_objects
					    where
						fun do_object (gp_object: gt::Gp_Object)
						    =
						    do_gp_object  gp_object;
					    end;

					gt::PG_OBJECTSPACE (objectspace_arg, gp_objects);
				    };

			        gt::SPRITESPACE
				    ( spritespace_arg:	gt::Spritespace_Arg,
				      gp_sprites:	List(gt::Gp_Sprite)
				    )
				    =>
				    {
					pg_sprites
					    =
					    map  do_sprite  gp_sprites
					    where
						fun do_sprite (gp_sprite: gt::Gp_Sprite)
						    =
						    do_gp_sprite  gp_sprite;
					    end;

					gt::PG_SPRITESPACE (spritespace_arg, pg_sprites);
				    };

			        gt::NULL_WIDGET
				    =>
				    gt::PG_NULL_WIDGET;
			    esac;
		    end;	
	    end;

	#
	fun startup   (id: Id,   reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		client_to_guiboss =   { id,
					make_topwindow,
					start_gui,
					restart_gui,
					get_sprite_theme,
					get_object_theme,
					get_widget_theme
				      };

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, { client_to_guiboss }));						# Return value from guiboss_egg'().

		(take_from_mailslot  me_slot)											# Imports from guiboss_egg'().
		    ->
		    { me, guiboss_arg, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';										# Wait for the starting gun.

		run ( guiboss_q,		 										# Will not return.
		      { me,
			guiboss_arg,
			imports,
			to,
			end_gun',
			id
		      }
		);
	    }
	    where
		guiboss_q     =  make_mailqueue (get_current_microthread()):  Guiboss_Q;



		#################################################################################
		# guiboss interface fns::
		#
		#
		stipulate
		    Appropriate_Gadget_Info												# Return value type for    find_appropriate_gadget_info().
		      #
		      =    APPROPRIATE_GADGET (gt::Gadget_Info, g2d::Point)								# The g2d::Point is the query point transformed into the appropriate local coordinate system for the gadget.
		      | NO_APPROPRIATE_GADGET                   g2d::Point
		      ;

		    fun find_appropriate_gadget_info											# Which widget did the user click on?  This is usually easy but it might be in a scrollable view in a tabbed view in another scrollable view, say.
			  (
			    topwindow_info:		Topwindow_Info,
			    event_point
			  )
			=
			{
			    topwindow_pixmaps												#
				=
				gt::return_all_topwindow_pixmaps_in_descending_stacking_order  *topwindow_info.backing_pixmap;

			    search_topwindow_pixmaps_in_descending_stacking_order  topwindow_pixmaps
			    where
				fun search_topwindow_pixmaps_in_descending_stacking_order  []
				        =>
					NO_APPROPRIATE_GADGET event_point;								# Tried everything, no hits, give up.

				    search_topwindow_pixmaps_in_descending_stacking_order  (topwindow_pixmap ! rest)			# Try topmost remaining popup first.
					=>
					{   origin =  *topwindow_pixmap.origin;
					    size   =  	topwindow_pixmap.pixmap.size;

					    site   =  g2d::box::make (origin, size);

					    if (g2d::box::point_in_box (event_point, site))
						#
						find_appropriate_gadget_info_for_running_gui  topwindow_pixmap;				# Found the right popup (or base) running gui, see if we hit any widgets within it.
					    else
						search_topwindow_pixmaps_in_descending_stacking_order  rest;				# event_point is not within this running gui, so try next one.
					    fi;
					};
				end;
			    end;		
			}
			where
			    fun find_appropriate_gadget_info_for_running_gui								# Which widget did the user click on?  This is usually easy but it might be in a scrollable view in a tabbed view in another scrollable view, say.
				  (
				    topwindow_pixmap:		gt::Topwindow_Pixmap							# This will be the topwindow_pixmap for either the topllevel running gui on the topwindow, or else the running gui for one of its popups.
				  )
				=
				case (*topwindow_pixmap.running_gui)
				    #
				    THE (running_gui:	gt::Running_Gui)
					=>
					{   event_point
						=
						event_point
						-
						(gt::topwindow_pixmap_origin_in_base_window_coordinates topwindow_pixmap);		#
					    #
					    find_gadget_info (running_gui.rg_widget, event_point);
					}
					where
					    fun try_all_widgets ([]: List(gt::Rg_Widget),  point: g2d::Point)
						    =>
						    NO_APPROPRIATE_GADGET point;

						try_all_widgets (row_or_col_widget ! rest,  point)
						    =>
						    case (find_gadget_info  (row_or_col_widget, point))
							#
							NO_APPROPRIATE_GADGET _ =>  try_all_widgets (rest,  point);			# Try the remaining widgets in ROW/COL/FRAME/whatever.
							info =>  info;									# Got it.
						    esac;
					    end

					    also
					    fun try_all_rows ([]: List(List(gt::Rg_Widget)),  point: g2d::Point)
						    =>
						    NO_APPROPRIATE_GADGET point;

						try_all_rows (row ! rest,  point)
						    =>
						    case (try_all_widgets (row, point))
							#
							NO_APPROPRIATE_GADGET _ =>  try_all_rows (rest,  point);			# Try the remaining widgets in ROW/COL/FRAME/whatever.
							info =>  info;									# Got it.
						    esac;
					    end

					    also	
					    fun find_gadget_info
						  (
						    rg_widget:		gt::Rg_Widget,
						    point:		g2d::Point
						  )
						=
						if (g2d::box::point_in_box  (point,  gt::widget_site rg_widget))
						    #
						    case rg_widget
							#
							gt::RG_ROW  r =>   try_all_widgets (r.widgets, point);
							gt::RG_COL  r =>   try_all_widgets (r.widgets, point);
							gt::RG_GRID r =>   try_all_rows    (r.widgets, point);

							gt::RG_SCROLLABLE_VIEW r
							    =>
							    {   point = point - g2d::box::upperleft(*r.site);					# Transform mouseclick point into          view coordinate system.
								point = point - *r.view_origin;							# Transform mouseclick point into scrolled view coordinate system.
								#
								find_gadget_info (r.rg_widget, point);						# Recursively search for target widget of mouseclick among widgets in scrollable view.
							    };	

							gt::RG_TABBED_VIEWS r
							    =>
							    {   point = point - g2d::box::upperleft(*r.site);					# Transform mouseclick point into view coordinate system.
								#
								find_gadget_info ((*r.visible_widget).widget, point);				# Recursively search for target widget of mouseclick among widgets in current tabbed view.
							    };

							gt::RG_FRAME r
							    =>
							    try_all_widgets ([ r.widget, r.frame_widget ], point);

							gt::RG_WIDGET (r as { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... })
							    =>
							    {   imps = *topwindow_info.gadget_imps;
								#
								id   = iul::id_to_int guiboss_to_gadget.id;

								case (im::get (imps, id))
								    #
								    NULL =>  NO_APPROPRIATE_GADGET point ;
								    #
								    THE gadget_info								# Return 'point' transformed into correct coordinate system for widget.
									=>
									case (*gadget_info.point_in_gadget)
									    #
									    NULL   =>                 APPROPRIATE_GADGET (gadget_info, point);	# No   point_in_gadget fn supplied by gadget, so count mouseclick as having hit the gadget.
									    THE fn =>	if (fn point) APPROPRIATE_GADGET (gadget_info, point);	# Have point_in_gadget fn supplied by the gadget decide whether the mouseclick was close enough to count.
											else  	   NO_APPROPRIATE_GADGET (             point);
											fi;
									esac;
								esac;
							    };

							gt::RG_OBJECTSPACE r
							    =>
							    NO_APPROPRIATE_GADGET point; # TBD

							gt::RG_SPRITESPACE r
							    =>
							    NO_APPROPRIATE_GADGET point; # TBD

							gt::RG_NULL_WIDGET
							    =>
							    NO_APPROPRIATE_GADGET point;
						    esac;
						else
						    NO_APPROPRIATE_GADGET point;
						fi;
					end;
				    #	 
				    NULL => NO_APPROPRIATE_GADGET event_point;							# Maybe we should do:   log::fatal "find_appropriate_gadget_info' called while gui not running!";
				esac;
			end;
		herein

		    fun do_motion_notify										# Mouse has moved. Inform any relevant gadgets.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    motion_xevtinfo:		evt::Motion_Xevtinfo
			  )
			=
			case (find_appropriate_gadget_info (topwindow_info, motion_xevtinfo.event_point))
			    #
			    APPROPRIATE_GADGET (gadget_info, event_point)						# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				=>
				{   mouse_is = topwindow_info.mouse_is;
				    #
				    gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };

				    case *mouse_is
					#
					CROSSING_NONGADGET								# Here the mouse is crossing from non-gadget pixels into gadget pixels.
					    =>
					    {
					        guiboss_to_gadget.note_mouse_transit					# Notify gadget that mouse has entered its space.
						  {
						    transit		=> gt::CAME,
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_info.site,
						    theme		=>  imports.theme
						  };
						guiboss_to_gadget.note_mouse_transit					# Notify gadget that mouse has entered its space.
						  {
						    transit		=> gt::MOVE,					# We send a MOVE after every CAME, for the convenience of handlers interested only in coordinates -- they can process all MOVE events and ignore CAME and LEFT events.
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_info.site,
						    theme		=>  imports.theme
						  };

						mouse_is := CROSSING_GADGET { gadget_info };				# Remember which widget mouse is in.

					    };	

					CROSSING_GADGET  { gadget_info => (last_gadget_info as { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET last_guiboss_to_gadget, ... }) }
					    =>
					    if (gt::same_gadget_info (gadget_info, last_gadget_info))
						#									# Here mouse is continuing to move on same gadget it was on at last report.
						guiboss_to_gadget.note_mouse_transit					# Notify gadget that mouse has entered its space.
						  {
						    transit		=> gt::MOVE,								# 
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_info.site,
						    theme		=> imports.theme
						  };

					    else									# Here mouse has crossed from one gadget to another.

						last_guiboss_to_gadget.note_mouse_transit				# Notify last gadget that mouse has left its space.
						  {
						    transit		=> gt::LEFT,
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *last_gadget_info.site,
						    theme		=> imports.theme
						  };

						mouse_is := CROSSING_GADGET { gadget_info };				# Remember that we're now on the new gadget.
						#
						guiboss_to_gadget.note_mouse_transit					# Notify new gadget that mouse has entered its space.
						  {
						    transit		=> gt::CAME,
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_info.site,
						    theme		=> imports.theme
						  };
						guiboss_to_gadget.note_mouse_transit					# Notify gadget that mouse has entered its space.
						  {
						    transit		=> gt::MOVE,					# We send a MOVE after every CAME, for the convenience of handlers interested only in coordinates -- they can process all MOVE events and ignore CAME and LEFT events.
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_info.site,
						    theme		=> imports.theme
						  };
					    fi;

					DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
					    {
					      gadget_info => dragged_gadget_info,					# This is the gadget on which the drag started.  It gets all the MOVE events until drag terminates, even if mouse leaves the window area owned by the gadget. (But we only send DRAGs while cursor is in the dragged gadget.)
					      start_point,								# This is the window coordinate of the downclick which started this drag.
					      last_point								# This is the window coordinate of the last motion event for this drag.
					    }
					    =>
					    if (gt::same_gadget_info (gadget_info, dragged_gadget_info))		# If cursor is outside gadget in which drag started, we do absolutely nothing.
						#
						guiboss_to_gadget.note_mouse_drag_event					# 
						  {									# 
						    phase		=> gt::DRAG,
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    mousebuttons_state	=> motion_xevtinfo.mousebuttons_state,
						    event_point,
						    start_point,
						    last_point,
						    site		=> *gadget_info.site,
						    theme		=> imports.theme
						  };

						mouse_is := DRAGGING_IN_GADGET						# Remember location of last DRAG event.
							      {
								gadget_info,						# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
								start_point,						# This is the window coordinate of the downclick which started this drag.
								last_point => event_point				# This is the window coordinate of the last DRAG event for this drag.
							      };
					    fi;
				    esac;
				};

			    NO_APPROPRIATE_GADGET event_point
				=> 
				{
				    mouse_is = topwindow_info.mouse_is;
				    #
				    case *mouse_is
					#
					CROSSING_NONGADGET
					    =>
					    ();										# Nothing to do in this case.

					CROSSING_GADGET  { gadget_info }						# Should sent LEAVE event in this case.
					    =>
					    {	gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };
						#
						guiboss_to_gadget.note_mouse_transit					# Notify the gadget that we were on that mouse has left its space.
						  {
						    transit		=> gt::LEFT,
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_info.site,
						    theme		=> imports.theme
						  };

						mouse_is := CROSSING_NONGADGET;
					    };

					DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
					    {
					      gadget_info,								# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
					      start_point,								# This is the window coordinate of the downclick which started this drag.
					      last_point								# This is the window coordinate of the last motion event for this drag.
					    }
					    =>
					    ();										# Mouse is not in the gadget that was downclicked so we completely ignore the motion event.
				    esac;
				};
			esac;


		    fun do_button_press											# 
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    button_xevtinfo:		evt::Button_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_gadget_info (topwindow_info, button_xevtinfo.event_point))
				#
				APPROPRIATE_GADGET (gadget_info, event_point)						# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				    =>
				    {
					mouse_is = topwindow_info.mouse_is;
					#
					gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };

					case *mouse_is
					    #
					    CROSSING_NONGADGET
						=>
						{
						    guiboss_to_gadget.note_mouse_transit				# Tell gadget that mouse has entered its space.
						      {
							transit		    => gt::CAME,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    guiboss_to_gadget.note_mouse_drag_event				# Tell gadget that user just started a drag operation on it.
						      {									# 
							phase		    => gt::OPEN,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							event_point,
							start_point	    => event_point,
							last_point	    => event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    guiboss_to_gadget.note_mouse_drag_event				# We send a DRAG after every OPEN, for the convenience of handlers interested only in coordinates -- they can process all DRAG events and ignore OPEN and DONE events.
						      {									# 
							phase		    => gt::DRAG,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							event_point,
							start_point	    => event_point,
							last_point	    => event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    mouse_is := DRAGGING_IN_GADGET					# Remember which widget mouse is in. SHOULD GENERATE AN 'ENTER' HERE.
								  {
								    gadget_info,
								    start_point => event_point,
								    last_point  => event_point
								  };
						    #
						};	

					    CROSSING_GADGET  { gadget_info => (last_gadget_info as { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET last_guiboss_to_gadget, ... }) }
						=>
						{
						    if (not (gt::same_gadget_info (gadget_info, last_gadget_info)))	# If we just left a gadget, tell it so.
							#
							last_guiboss_to_gadget.note_mouse_transit			# Notify last gadget that we were on that mouse has left its space.
							  {
							    transit		=> gt::LEFT,
							    modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
							    event_point,
							    site		=> *last_gadget_info.site,
							    theme		=> imports.theme
							  };

							guiboss_to_gadget.note_mouse_transit				# Notify new gadget that mouse has entered its space.
							  {
							    transit		=> gt::CAME,
							    modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
							    event_point,
							    site		=> *gadget_info.site,
							    theme		=> imports.theme
							  };
						    fi;

						    guiboss_to_gadget.note_mouse_drag_event				# Tell gadget that user just started a drag operation on it.
						      {									# 
							phase		    => gt::OPEN,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							event_point,
							start_point	    => event_point,
							last_point	    => event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    guiboss_to_gadget.note_mouse_drag_event				# We send a DRAG after every OPEN, for the convenience of handlers interested only in coordinates -- they can process all DRAG events and ignore OPEN and DONE events.
						      {									# 
							phase		    => gt::DRAG,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							event_point,
							start_point	    => event_point,
							last_point	    => event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    mouse_is := DRAGGING_IN_GADGET					# Remember which widget mouse is in.
								  {
								    gadget_info,
								    start_point => event_point,
								    last_point  => event_point
								  };
						    #
						};	

					    DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
						{
						  gadget_info => dragged_gadget_info,					# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
						  start_point,								# This is the window coordinate of the downclick which started this drag.
						  last_point								# This is the window coordinate of the last motion event for this drag.
						}
						=>
						if (gt::same_gadget_info (gadget_info, dragged_gadget_info))		# If we are still on the gadget being dragged...
						    #
						    guiboss_to_gadget.note_mouse_drag_event				# Tell the gadget where the mouse now is.
						      {									# 
							phase		    => gt::DRAG,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							event_point,
							start_point,
							last_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    mouse_is := DRAGGING_IN_GADGET					# Remember new 'last_point' for dragged gadget.
								      {
									gadget_info,
									start_point,
									last_point  => event_point
								      };
						fi;
					esac;
					#	

					# Following note_mousebutton_event stuff is completely independent of drag/motion stuff.

					guiboss_to_gadget.note_mousebutton_event
					  {
					    mousebutton_event	=> gt::MOUSEBUTTON_PRESS,
					    mouse_button	=> button_xevtinfo.mouse_button,
					    modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
					    mousebuttons_state	=> button_xevtinfo.mousebuttons_state,
					    event_point,
					    site		=> *gadget_info.site,
					    theme		=> imports.theme
					  };
				    };

				NO_APPROPRIATE_GADGET event_point
				    =>
				    {
					mouse_is = topwindow_info.mouse_is;
					#
					case *mouse_is
					    #
					    CROSSING_NONGADGET
						=>
						();

					    CROSSING_GADGET  { gadget_info }
						=>
						{   gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };
						    #
						    guiboss_to_gadget.note_mouse_transit				# Notify last gadget that we were on that mouse has left its space.
						      {
							transit		    => gt::LEFT,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    mouse_is := CROSSING_NONGADGET;
						};	

					    DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
						{
						  gadget_info => dragged_gadget_info,					# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
						  start_point,								# This is the window coordinate of the downclick which started this drag.
						  last_point								# This is the window coordinate of the last motion event for this drag.
						}
						=>
						();									# When a drag is in progress, we do nothing if we are not on the dragged gadget.
					esac;
				    };
			    esac;
			};

		    fun do_button_release												# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    button_xevtinfo:		evt::Button_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_gadget_info (topwindow_info, button_xevtinfo.event_point))
				#
				APPROPRIATE_GADGET (gadget_info, event_point)						# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				    =>
				    {	gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };
					#
					mouse_is = topwindow_info.mouse_is;

					case *mouse_is
					    #
					    CROSSING_NONGADGET
						=>
						{   gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };
						    #
						    guiboss_to_gadget.note_mouse_transit				# Notify new gadget that mouse has entered its space.
						      {
							transit		    => gt::CAME,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    mouse_is := CROSSING_GADGET { gadget_info };
						    #
						};	

					    CROSSING_GADGET  { gadget_info => gadget_info2 }				# This case should not actually be possible...?  How can we be in CROSSING_GADGET mode with a mousebutton down?
						=>
						if (not (gt::same_gadget_info (gadget_info, gadget_info2)))		# If we just left a gadget, tell it so.
						    #
						    gadget_info2 -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget2, ... };

						    guiboss_to_gadget2.note_mouse_transit				# Notify last gadget that we were on that mouse has left its space.
						      {
							transit	        => gt::LEFT,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							event_point,
							site		=> *gadget_info2.site,
							theme		=> imports.theme
						      };

						    guiboss_to_gadget.note_mouse_transit				# Notify new gadget that mouse has entered its space.
						      {
							transit		=> gt::CAME,
							modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
							event_point,
							site		=> *gadget_info.site,
							theme		=> imports.theme
						      };

						    mouse_is := CROSSING_GADGET { gadget_info };
						fi;

					    DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
						{
						  gadget_info => gadget_info2,						# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
						  start_point,								# This is the window coordinate of the downclick which started this drag.
						  last_point								# This is the window coordinate of the last motion event for this drag.
						}
						=>
						{
						    buttons = button_xevtinfo.mousebuttons_state;
						    #
						    if (evt::pressed_mousebutton_count buttons == 1)			# 'buttons' is state BEFORE the release, so if pressed-button count is 1, all buttons are now released.
							#								# All mouse buttons are now released, so drag operation is over
							gadget_info2 -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget2, ... };

							guiboss_to_gadget2.note_mouse_drag_event			# Tell the drag gadget that drag operation is complete.
							  {								# 
							    phase		=> gt::DONE,
							    modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
							    mousebuttons_state	=> button_xevtinfo.mousebuttons_state,
							    event_point,
							    start_point,
							    last_point,
							    site		=> *gadget_info2.site,
							    theme		=> imports.theme
							  };

							if (not (gt::same_gadget_info (gadget_info, gadget_info2)))	# If we just left a gadget, tell it so.
							    #
							    guiboss_to_gadget2.note_mouse_transit			# Notify drag gadget that we were on that mouse has left its space.
							      {
								transit		    => gt::LEFT,
								modifier_keys_state => button_xevtinfo.modifier_keys_state,
								event_point,
							        site		    => *gadget_info2.site,
								theme		    => imports.theme
							      };

							    guiboss_to_gadget.note_mouse_transit			# Notify new gadget that mouse has entered its space.
							      {
								transit		    => gt::CAME,
								modifier_keys_state => button_xevtinfo.modifier_keys_state,
								event_point,
							        site		    => *gadget_info.site,
								theme		    => imports.theme
							      };
							fi;

							mouse_is := CROSSING_GADGET { gadget_info };			# Remember that drag operation is complete.

						    else								# We still have some mouse buttons down.

							if (gt::same_gadget_info (gadget_info, gadget_info2))		# If we are still on the drag gadget
							    #
							    guiboss_to_gadget.note_mouse_drag_event			# Update the drag gadget with mouse location and buttonstate.
							      {								# 
								phase		    => gt::DRAG,
								modifier_keys_state => button_xevtinfo.modifier_keys_state,
								mousebuttons_state  => button_xevtinfo.mousebuttons_state,
								event_point,
								start_point,
								last_point,
							        site		    => *gadget_info.site,
								theme		    => imports.theme
							      };
							fi;

							mouse_is := DRAGGING_IN_GADGET					# Remember new 'last_point' for dragged gadget.
									  {
									    gadget_info,
									    start_point,
									    last_point  => event_point
									  };
						    fi;
						};	
					esac;
					#	
					guiboss_to_gadget.note_mousebutton_event					# note_mousebutton_event is completely independent of drag/motion stuff.
					  {
					    mousebutton_event		=> gt::MOUSEBUTTON_RELEASE,
					    mouse_button		=> button_xevtinfo.mouse_button,
					    modifier_keys_state		=> button_xevtinfo.modifier_keys_state,
					    mousebuttons_state		=> button_xevtinfo.mousebuttons_state,
					    event_point,
					    site			=> *gadget_info.site,
					    theme			=> imports.theme
					  };
				    };

				NO_APPROPRIATE_GADGET event_point
				    =>
				    {
					mouse_is = topwindow_info.mouse_is;
					#
					case *mouse_is
					    #
					    CROSSING_NONGADGET
						=>
						();

					    CROSSING_GADGET  { gadget_info }
						=>
						{   gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };
						    #
						    guiboss_to_gadget.note_mouse_transit				# Notify last gadget that we were on that mouse has left its space.
						      {
							transit	        => gt::LEFT,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							event_point,
							site		=> *gadget_info.site,
							theme		=> imports.theme
						      };

						    mouse_is := CROSSING_NONGADGET;
						};	

					    DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
						{
						  gadget_info,								# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
						  start_point,								# This is the window coordinate of the downclick which started this drag.
						  last_point								# This is the window coordinate of the last motion event for this drag.
						}
						=>
						{   buttons = button_xevtinfo.mousebuttons_state;
						    #
						    gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };

						    if (evt::pressed_mousebutton_count buttons == 1)			# Tell the drag gadget that drag operation is complete.
							#
							guiboss_to_gadget.note_mouse_drag_event				# Notify the drag gadget that the drag operation is now complete.
							  {								# 
							    phase		=> gt::DONE,
							    modifier_keys_state => button_xevtinfo.modifier_keys_state,
							    mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							    event_point		=> last_point,				# event_point is not within drag gadget, so re-use old point here. Apps probably should not use this value, but some will likely ignore the OPEN/DRAG/DONE flag and blindly process all event_points.
							    start_point,
							    last_point,
							    site		=> *gadget_info.site,
							    theme		=> imports.theme
							  };

							guiboss_to_gadget.note_mouse_transit				# Notify drag gadget that mouse has left its space.
							  {
							    transit	        => gt::LEFT,
							    modifier_keys_state => button_xevtinfo.modifier_keys_state,
							    event_point,
							    site		=> *gadget_info.site,
							    theme		=> imports.theme
							  };

							mouse_is := CROSSING_NONGADGET;
						    fi;									# No 'else' here because as long as we're dragging we generate no Gadget_Transit events.
						};
					esac;
				    };											# NO_APPROPRIATE_GADGET case._
			    esac;
			};

		    fun do_key_press											# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    key_xevtinfo:		evt::Key_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_gadget_info (topwindow_info, key_xevtinfo.event_point))
				#
				APPROPRIATE_GADGET (gadget_info, event_point)						# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				    =>
				    {   printf "guievent_sink()/guiboss/do_key_press: FOUND CANDIDATE!\n";
					#	
					gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };

					guiboss_to_gadget.note_key_event
					  {
					    key_event		=> gt::KEY_PRESS,
					    keycode		=> key_xevtinfo.keycode,
					    keysym		=> key_xevtinfo.keysym,
					    string		=> key_xevtinfo.ascii,
					    modifier_keys_state	=> key_xevtinfo.modifier_keys_state,
	 		    		    mousebuttons_state	=> key_xevtinfo.mousebuttons_state,
					    event_point,
					    site		=> *gadget_info.site,
					    theme		=> imports.theme
					  };	
				    };

				NO_APPROPRIATE_GADGET _
				    =>
				    printf "guievent_sink()/guiboss/do_key_press: NO candidate found.\n";
			    esac;
			};

		    fun do_key_release											# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    key_xevtinfo:		evt::Key_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_gadget_info (topwindow_info, key_xevtinfo.event_point))
				#
				APPROPRIATE_GADGET (gadget_info, event_point)						# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				    =>
				    {   printf "guievent_sink()/guiboss/do_key_release: FOUND CANDIDATE!\n";
					#	
					gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };

					guiboss_to_gadget.note_key_event
					  {
					    key_event		=> gt::KEY_RELEASE,
					    keycode		=> key_xevtinfo.keycode,
					    keysym		=> key_xevtinfo.keysym,
					    string		=> key_xevtinfo.ascii,
					    modifier_keys_state	=> key_xevtinfo.modifier_keys_state,
	 		    		    mousebuttons_state	=> key_xevtinfo.mousebuttons_state,
					    event_point,
					    site		=> *gadget_info.site,
					    theme		=> imports.theme
					  };	
				    };

				NO_APPROPRIATE_GADGET _
				    =>
				    printf "guievent_sink()/guiboss/do_key_release: NO candidate found.\n";
			    esac;
			};


		end;



		fun make_guievent_sink
		      (
# XXX is this arg right? Or should it be a backing_pixmap?
			topwindow_info:		Topwindow_Info,
			saved_events:		Ref (List( (a2r::Envelope_Route, evt::x::Event) ) )				# Somewhere for initial_guievent_sink to save any events it gets.
		      )
		    =	
		    guievent_sink
		    where
			fun guievent_sink (arg as (route: a2r::Envelope_Route, event: evt::x::Event))				# The production Gui_Event handling routine, which locks in the value of 'topwindow_info'.
			    =													# This will run in client's thread.
			    put_in_mailqueue  (guiboss_q,									# Incoming Gui_Event values MUST be run through the guiboss_q to guarantee mutual exclusion on access to internal guiboss datastructures.
				#
				\\ (runstate as { me, imports, ... }: Runstate)							# Now we're running in our own thread, with mutual exclusion and access to our core datastructures.
				    =
				    {
					case *topwindow_info.backing_pixmap
					    #
					    NULL => {   saved_events := arg ! *saved_events;					# When no GUI is running, all we can do is save user input for later processing. (Or maybe discard it?)
printf "guievent_sink()/guiboss: received '%s' Gui_Event but saved it because *topwindow_info.running_gui is NULL.    -- guiboss-imp.pkg\n"
    (gts::gui_event_to_string event);
						    };
					    THE (gt::VIEWPORT_PIXMAP _)
						=>
						{   msg = "VIEWPORT_PIXMAP unsupported in make_guievent_sinkg";
						    log::fatal msg;
						    raise exception FAIL msg;
						};

					    THE (gt::TOPWINDOW_PIXMAP r)
						=>
						case *r.running_gui
						    #
						    NULL => {   saved_events := arg ! *saved_events;					# When no GUI is running, all we can do is save user input for later processing. (Or maybe discard it?)
printf "guievent_sink()/guiboss: received '%s' Gui_Event but saved it because *topwindow_info.running_gui is NULL.    -- guiboss-imp.pkg\n"
	    (gts::gui_event_to_string event);
							    };

						    THE running_gui
							 =>	{
								case *saved_events
								    #
								    [] =>   {
										case event
										    #
										    evt::x::KEY_PRESS       (key_xevtinfo: evt::Key_Xevtinfo)
											=>
											do_key_press (runstate, topwindow_info, /* running_gui, */ key_xevtinfo);

										    evt::x::KEY_RELEASE     (key_xevtinfo: evt::Key_Xevtinfo)
											=>
											do_key_release (runstate, topwindow_info, /* running_gui, */ key_xevtinfo);

										    evt::x::BUTTON_PRESS    (button_xevtinfo: evt::Button_Xevtinfo)
											=>
											do_button_press (runstate, topwindow_info, /* running_gui, */ button_xevtinfo);

										    evt::x::BUTTON_RELEASE  (button_xevtinfo: evt::Button_Xevtinfo)
											=>
											do_button_release (runstate, topwindow_info, /* running_gui, */ button_xevtinfo);

										    evt::x::MOTION_NOTIFY   (motion_xevtinfo: evt::Motion_Xevtinfo)
											=>
											do_motion_notify (runstate, topwindow_info, /* running_gui, */ motion_xevtinfo);

										    evt::x::ENTER_NOTIFY    (inout_xevtinfo: evt::Inout_Xevtinfo)
											=>
											{
#    												printf "guievent_sink()/ENTER_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
											};

										    evt::x::LEAVE_NOTIFY    (inout_xevtinfo: evt::Inout_Xevtinfo)
											=>
											{
#    												printf "guievent_sink()/LEAVE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
											};

										    evt::x::FOCUS_IN	(focus_xevtinfo: evt::Focus_Xevtinfo)
											=>
											printf "guievent_sink()/FOCUS_IN: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::FOCUS_OUT	(focus_xevtinfo:  evt::Focus_Xevtinfo)
											=>
											printf "guievent_sink()/FOCUS_OUT: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::KEYMAP_NOTIFY    { }
											=>
											printf "guievent_sink()/KEYMAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::EXPOSE           (expose_record:         evt::x::Expose_Record)
											=>
											printf "guievent_sink()/EXPOSE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::GRAPHICS_EXPOSE  (graphics_expose_record: evt::x::Graphics_Expose_Record)
											=>
											printf "guievent_sink()/GRAPHICS_EXPOSE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::NO_EXPOSE
										      { drawable:		evt::Drawable_Id,
											major_opcode:		Unt,						# The graphics operation code.
											minor_opcode:		Unt						# Always 0 for core protocol.
										      }
											=>
											printf "guievent_sink()/NO_EXPOSE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::VISIBILITY_NOTIFY
										      { changed_window_id:	evt::Window_Id,					# The window with changed visibility state.
											state:			evt::Visibility					# The new visibility state.
										      }
											=>
											printf "guievent_sink()/VISIBILITY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::CREATE_NOTIFY
										      { parent_window_id:	evt::Window_Id,					# The created window's parent.
											created_window_id:	evt::Window_Id,					# The created window.
											box:			g2d::Box,					# The window's rectangle.
											border_wid:		Int,						# The width of the border.
											override_redirect:	Bool						#  
										      }
											=>
											printf "guievent_sink()/CREATE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::DESTROY_NOTIFY
										      { event_window_id:	evt::Window_Id,					# The window on which this was generated.
											destroyed_window_id:	evt::Window_Id					# The destroyed window.
										      }
											=>
											printf "guievent_sink()/DESTROY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::UNMAP_NOTIFY
										      { event_window_id:	evt::Window_Id,					# The window on which this was generated.
											unmapped_window_id:	evt::Window_Id,					# The window being unmapped.
											from_config:		Bool						# TRUE if parent was resized.
										      }
											=>
											printf "guievent_sink()/UNMAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::MAP_NOTIFY
										      { event_window_id:	evt::Window_Id,					# The window on which this was generated.
											mapped_window_id:	evt::Window_Id,					# The window being mapped.
											override_redirect:	Bool						#  
										      }
											=>
											printf "guievent_sink()/MAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::MAP_REQUEST
										      { parent_window_id:	evt::Window_Id,					# The parent.
											mapped_window_id:	evt::Window_Id					# The mapped window.
										      }
											=>
											printf "guievent_sink()/MAP_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::REPARENT_NOTIFY
										      { event_window_id:	evt::Window_Id,					# The window on which this was generated.
											parent_window_id:      	evt::Window_Id,					# The new parent.
											rerooted_window_id:    	evt::Window_Id,					# The re-rooted window.
											upperleft_corner:	g2d::Point,					# The upper-left corner.
											override_redirect:	Bool						#  
										      }
											=>
											printf "guievent_sink()/REPARENT_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::CONFIGURE_NOTIFY
										      { event_window_id:       	evt::Window_Id,					# The window on which this was generated.
											configured_window_id:	evt::Window_Id,					# The reconfigured window.
											sibling_window_id:	Null_Or(evt::Window_Id),			# The sibling that window is above (if any).
											box:			g2d::Box,					# The window's rectangle.
											border_wid:  		Int,						# The width of the border.
											override_redirect:	Bool						#  
										      }
											=>
											{
											    printf "guievent_sink()/CONFIGURE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
											};

										    evt::x::CONFIGURE_REQUEST
										      { parent_window_id:	evt::Window_Id,					# The parent.
											configure_window_id:	evt::Window_Id,					# The window to reconfigure.
											sibling_window_id:  	Null_Or(evt::Window_Id),			# The new sibling (if any).
											x:           		Null_Or(Int),					# The window's rectangle.
											y:           		Null_Or(Int),
											wide:        		Null_Or(Int),
											high:        		Null_Or(Int),
											border_wid:  		Null_Or(Int),					# The width of the border.
											stack_mode: 		Null_Or(evt::Stack_Mode)			# The mode for stacking windows.
										      }
											=>
											printf "guievent_sink()/CONFIGURE_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::GRAVITY_NOTIFY
										      {
											event_window_id:	evt::Window_Id,					# The window on which this was generated.
											moved_window_id:   	evt::Window_Id,					# The window being moved.
											upperleft_corner:	g2d::Point					# Upper-left corner of window.
										      }		
											=>
											printf "guievent_sink()/GRAVITY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::RESIZE_REQUEST
										      {
											resize_window_id:	evt::Window_Id,					# The window to resize.
											req_size:		g2d::Size					# The requested new size.
										      }
											=>
											printf "guievent_sink()/RESIZE_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::CIRCULATE_NOTIFY
										      {
											event_window_id:	evt::Window_Id,					# The window on which this was generated.
											circulated_window_id:	evt::Window_Id,					# The window being circulated.
											parent_window_id:	evt::Window_Id,					# The parent.
											place:			evt::Stack_Pos					# The new place.
										      }
											=>
											printf "guievent_sink()/CIRCULATE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::CIRCULATE_REQUEST
										      {
											parent_window_id:	evt::Window_Id,					# The parent.
											circulate_window_id:	evt::Window_Id,					# The window to circulate.
											place:			evt::Stack_Pos					# The place to circulate the window to.
										      }
											=>
											printf "guievent_sink()/CIRCULATE_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::PROPERTY_NOTIFY
										      {
											changed_window_id:	evt::Window_Id,					# The window with the changed property.
											atom:        		evt::Atom,					# The affected property.
											timestamp:  		evt::t::Xserver_Timestamp,			# When the property was changed.
											deleted:     		Bool						# TRUE if the property was deleted.
										      }
											=>
											printf "guievent_sink()/PROPERTY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::SELECTION_CLEAR
										      {
											owning_window_id:	evt::Window_Id,					# The current owner of the selection.
											selection:		evt::Atom,					# The selection.
											timestamp:		evt::t::Xserver_Timestamp			# The last-change time.
										      }		
											=>
											printf "guievent_sink()/SELECTION_CLEAR: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::SELECTION_REQUEST
										      {
											owning_window_id:	evt::Window_Id,					# The owner of the selection.
											selection:		evt::Atom,					# The selection.
											target:			evt::Atom,					# The requested type for the selection.
											requesting_window_id:	evt::Window_Id,					# The requesting window.
											property:		Null_Or( evt::Atom ),				# The property to store the selection in. 
											timestamp:		evt::Timestamp					#  
										      }
											=>
											printf "guievent_sink()/SELECTION_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::SELECTION_NOTIFY
										      {
											requesting_window_id:	evt::Window_Id,					# The requestor of the selection.
											selection:		evt::Atom,					# The selection.
											target:			evt::Atom, 					# The requested type of the selection.
											property:		Null_Or( evt::Atom ),				# The property to store the selection in.
											timestamp:		evt::Timestamp  				#  
										      }
											=>
											printf "guievent_sink()/SELECTION_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::COLORMAP_NOTIFY
										      {
											window_id:		evt::Window_Id,					# The affected window.
											cmap:			Null_Or( evt::Colormap_Id ),			# The colormap.
											new:			Bool,						# TRUE, if the colormap attribute is changed.
											installed: 		Bool						# TRUE, if the colormap is installed.
										      }
											=>
											printf "guievent_sink()/COLORMAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::CLIENT_MESSAGE
										      {
											window_id:		evt::Window_Id,					#  
											type:			evt::Atom,					# The type of the message.
											value:			evt::Raw_Data					# The message value.
										      }
											=>
											printf "guievent_sink()/CLIENT_MESSAGE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::MODIFIER_MAPPING_NOTIFY						# Really a MappingNotify event.
											=>
											printf "guievent_sink()/MODIFIER_MAPPING_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::KEYBOARD_MAPPING_NOTIFY						# Really a MappingNotify event.
										      {
											first_keycode:  	evt::Keycode,
											count:          	Int
										      }
											=>
											printf "guievent_sink()/KEYBOARD_MAPPING_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::POINTER_MAPPING_NOTIFY						# Really a MappingNotify event.
											=>
											printf "guievent_sink()/POINTER_MAPPING_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										esac;										# NB: We avoid a '_' case here because if an event is added to evt::x::Event we want a compile error as a reminder to handle it.

									    };

								    _  =>   {											# Woops, we have prior events that came in before we were ready to process them.
										saved_events := arg ! *saved_events;						# Add latest event to saved-events list.
										events = reverse *saved_events;							# Reverse saved-events list so we process them in first-in-first-out order.
										saved_events := [];								# Clear saved-events so  we don't process any of them twice.
										apply guievent_sink events;							# Recursively process all saved events in order.  NB: Any new events that arrive during this will just accumulate on guiboss_q. That's fine.
									    };											# 
								esac;
							    };

						esac;
					esac;
				    }															# In-private-thread part of fun guievent_sink.
			    );																# fun guievent_sink
		    end;

		fun make_topwindow  (hints:	gws::Topwindow_Hints)											# PUBLIC.
		    :				gws::Guiboss_To_Topwindow
		    =																	# This will run in client's thread.
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( gws::Guiboss_To_Topwindow );
# reply_oneshot is NOT locked into guievent_sink.
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ me, imports, ... }: Runstate)												# Now we're running in our own thread, with mutual exclusion and access to our core datastructures.
				=
				{   # We have to do an awkward little dance here because we
				    # must hand a guievent_sink() TO make_topwindow() but we
				    # want guievent_sink() to lock in the 'topwindow' result
				    # FROM make_topwindow():

# saved_events IS directly locked into guievent_sink 
				    saved_events = REF ([]: List( (a2r::Envelope_Route, evt::x::Event) ) );						# Somewhere for initial_guievent_sink to save any events it gets.

# guievent_sink_fn is NOT directly locked into  guievent_sink()  (but it is indirectly locked via topwindow_info -> guiboss_to_topwindow).
				    guievent_sink_fn
					=
					REF initial_guievent_sink
					where
					    fun initial_guievent_sink (arg as (route: a2r::Envelope_Route, event: evt::x::Event))			# An initial version which just saves events in 'saved_events' until we're ready to process them, since we don't yet have 'topwindow' available.
						=													# This will run in client's thread.
						saved_events :=  arg ! *saved_events;
				        end;


				    guiboss_to_topwindow
					=
					imports.guiboss_to_windowsystem.make_topwindow									# XXX SUCKO FIXME we're blocking until we get the result from windowsystem.
					    #
					    (hints, guievent_sink_wrapper)
					    where
						fun guievent_sink_wrapper (arg as (route: a2r::Envelope_Route, event: evt::x::Event))			# A wrapper which initially calls initial_guievent_sink but almost immediately switches to calling the production guievent_sink.
						    =													# This will run in client's thread.
						    *guievent_sink_fn  arg;
				    	    end;


				    topwindow_info       =    { guiboss_to_topwindow,									# Remember our handle for the topwindow.
								backing_pixmap				=>   REF NULL,					# Remember that we do not yet have a GUI running on the topwindow.
								#
								sprite_imps				=>  (REF im::empty): gt::Sprite_Imps,		# Holds our gt::Guiboss_To_Spritespace instances -- can't put them directly in Running_Gui due to circularity.
								object_imps				=>  (REF im::empty): gt::Object_Imps,		# Holds our gt::Guiboss_To_Objectspace instances -- can't put them directly in Running_Gui due to circularity.
								widget_imps				=>  (REF im::empty): gt::Widget_Imps,		# Holds our gt::Guiboss_To_Widgetspace instances -- can't put them directly in Running_Gui due to circularity.
								gadget_imps				=>  (REF im::empty): gt::Gadget_Imps,		# Holds look-imps for all the widgets in our gui.
								#
								current_frame_number			=>  (REF 1),					# We count frames for convenience of widgets and debugging.
								seconds_per_frame			=>  (REF 0.01),					# Let's initially assume a nominal ten frames per second. Passed to widgets primarily so widgets can do motion blurring if they wish.
								#
								mouse_is				=>  (REF CROSSING_NONGADGET), 			# Mouse is not currently dragging, and in fact not currently known to be on any particular widget.
								#
								done_extra_redraw_request_this_frame	=>  (REF FALSE),
								#
								next_stacking_order			=>  (REF 2)
							      };

				    me.topwindows													# Remember that we have a new topwindow to manage.
					:=
					im::set ( *me.topwindows,
						  id_to_int guiboss_to_topwindow.id,
						  topwindow_info
						);

				    guievent_sink
					=
					make_guievent_sink (topwindow_info, saved_events);

				    guievent_sink_fn  :=  guievent_sink;										# Switch guievent_sink_wrapper() over from using initial_guievent_sink() to using guievent_sink().


				    put_in_oneshot (reply_oneshot, guiboss_to_topwindow);
				}															# In-private-thread part of fun make_topwindow.
		        );																# put_in_mailqueue call.

			get_from_oneshot  reply_oneshot;
		    };																	# fun make_topwindow

		#
		fun pause_gui
		      (
			running_gui:		gt::Running_Gui,											# Private
			#
			sprite_imps:		gt::Sprite_Imps,
			object_imps:		gt::Object_Imps,
			widget_imps:		gt::Widget_Imps,
			gadget_imps:		gt::Gadget_Imps,
			#
			topwindow_info:		Topwindow_Info
		      )
		      : gt::Paused_Gui
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Paused_Gui );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				put_in_oneshot  (reply_oneshot,  pause_gui' (runstate, (running_gui, sprite_imps, object_imps, widget_imps, gadget_imps, topwindow_info)))
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun kill_gui
		      (
			running_gui:		gt::Running_Gui,											# Private
			#
			sprite_imps:		gt::Sprite_Imps,
			object_imps:		gt::Object_Imps,
			widget_imps:		gt::Widget_Imps,
			gadget_imps:		gt::Gadget_Imps,
			#
			topwindow_info:		Topwindow_Info
		      )
		      : Void
		    =	
		    {
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				kill_gui' (runstate, (running_gui, sprite_imps, object_imps, widget_imps, gadget_imps, topwindow_info, TRUE))
			);

			();
		    };
		#
		fun start_gui																# PUBLIC.
		      (
			topwindow_for_gui:	gws::Guiboss_To_Topwindow,
			gui_plan:		gt::Gui_Plan
		      )
		    : (Void -> gt::Client_To_Guiwindow)
		    =	
		    {   gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Client_To_Guiwindow );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{   topwindow_pixmap =  make_base_backing_pixmap  topwindow_for_gui.backing_pixmap;
				    #
				    start_gui' (runstate, topwindow_for_gui, topwindow_pixmap, gui_plan, gui_startup_complete', guiboss_q, pause_gui, kill_gui);
				}
		        );

			{.   get_from_oneshot  gui_startup_complete';   };
		    };

		#
		fun restart_gui																# PUBLIC.
		      (
			topwindow_for_gui:	gws::Guiboss_To_Topwindow,
			paused_gui: 		gt::Paused_Gui
		      )
		    : (Void -> gt::Client_To_Guiwindow)
		    =	
		    {   gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Client_To_Guiwindow );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{   topwindow_pixmap =  make_base_backing_pixmap topwindow_for_gui.backing_pixmap;
				    #
				    restart_gui' (runstate, topwindow_for_gui, topwindow_pixmap, paused_gui, gui_startup_complete', guiboss_q, pause_gui, kill_gui);
				}
		        );

			{.   get_from_oneshot  gui_startup_complete';   };
		    };

		#
		fun get_sprite_theme ()															# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( bt::Gui_To_Sprite_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.gui_to_sprite_theme)
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun get_object_theme ()															# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( ct::Gui_To_Object_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.gui_to_object_theme)
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun get_widget_theme ()															# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( wt::Widget_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.theme)
			);

			get_from_oneshot reply_oneshot;
		    };
	    end;

	#
	fun process_options (options: List(Guiboss_Option), { name, id })
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME	n) =>   my_name			:=  n;
			do_option (ID			i) =>   my_id                   :=  i;
		    end;
		end;

		{ name			=>  *my_name,
		  id 			=>   *my_id
		};
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_guiboss_egg
	      (guiboss_arg:		Guiboss_Arg)													# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	    =
	    {	guiboss_arg ->  (guiboss_options);													# Currently no guiboss_needs component, so this is a no-op.
		#
		(process_options
		  ( guiboss_options,
		    { name		=> "guiboss",
		      id		=>  id_zero
		    }
		) )
		    ->
		    { name,
		      id
		    };
	
		my (id, guiboss_options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();														# Allocate unique imp id.
			(id, ID id ! guiboss_options);													# Make our id stable across stop/restart cycles.
		    else
			(id, guiboss_options);
		    fi;

		guiboss_arg = (guiboss_options);													# Currently no guiboss_needs component, so this is a no-op.

		me =  {
			topwindows	=>  REF im::empty												# Track all topwindows created by our make_topwindow() entrypoint.
		      };

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );						# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));									# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3															# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, guiboss_arg, imports, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;


##########################################################################
# Note[2]  Pop-up Design Considerations:
#
# o As a practical matter we expect typically just one
#   popup at a time, either a tooltip or a dialog, so
#   we try to avoid adding too much semantic and implementation
#   complexity in service of the remaining rarer cases.
#
#   Also, we don't worry much about the efficiency of the
#   complex cases which we expect to be vanishingly rare:
#   we use simple O(N**2) algorithms for our overlapping-
#   update cases rather than implementing and using
#   sophisticated spatial datastructures.
#
# o For simplicity and portability we do popups entirely
#   within guiboss-imp, as opposed to using one separate
#   X window per popup.  This leaves the door open to
#   ports to non-X substrates which do not naturally
#   support extra windows, perhaps OpenGL or simple
#   hardware framebuffers.
#
# o We support multiple simultaneous popups on a given
#   topwindow because this has the simplest, most natural
#   semantics:  on a big GUI on a 30" monitor there is no
#   reason that a popup or tooltip in one corner should
#   block a popup or tooltip in another corner.
#
# o We expect each popup to fit entirely within its parent,
#   but it seems unnatural and inconvenient to insist that
#   sibling popups sharing a parent not overlap, so for
#   simplest semantics we allow such overlaps.  
#
# o For similar considerations of clean semantics we support
#   popups on popups:  We want each popup to support the same
#   GUI semantics as the underlying parent gui window.
#
# o We resolve sibling overlaps via a global stacking order,
#   with younger windows overlaying older ones.  At some point
#   we may want to support popping windows to the top of the
#   stacking order:  In that case we'll have to make stacking_order
#   fields mutuable and trigger a redraw after updating them.
#
# o I do not see any need to have pop-ups belong to views and
#   thus be partially visible through a viewport.  The point
#   of a popup is to be attention-getting and visible, so having
#   hidden popups seems counterproductive.  Consequently we do not
#   (further!) complicate the implementation problem by requiring
#   support for that.

##########################################################################
# Note[3]  Gadget Redraw Protocol Design Considerations:
#
# A core idea here is that if a gadget updates its state say 100,000
# times a second (counting incoming ethernet packets, perhaps),
# we do NOT want it redrawing that often because it would overwhelm
# the rendering subsystem (and anyhow waste a lot of CPU + CPU time).
#
# Rather than have each gadget (most likely FAIL to) include redraw
# frequency throttling logic, we centralize this functionality here
# in guiboss_imp:
#
#  o  When a gadget updates its state, it calls							# See for example   src/lib/x-kit/gadget/leaf/arrowbutton.pkg
#         gadget_to_guiboss.needs_redraw_gadget_request
#     which results in guiboss_imp setting the gadget's
#         gadget_info.needs_redraw_request := TRUE;
#
#  o  Each time guiboss_imp's   "frameclock"  thread wakes up					#   As a special tweak, once per frame guiboss_imp will send a
#     (10-100 times per second, say), it sends a						#	guiboss_to_gadget.redraw_gadget_request
#         guiboss_to_gadget.redraw_gadget_request						#   immediately upon receiving a
#     all to each gadget with gadget_info.needs_redraw_request == TRUE;				#	gadget_to_guiboss.needs_redraw_gadget_request
#												#   The intention here is to reduce GUI user-response latency
#  o  When (and only when) a gadget receives a redraw_gadget_request				#   by ten to a hundred milliseconds in the common case of only
#     call, it does a										#   one user mouselick (or other input) per frameclock tick,
#         gadget_to_guiboss.redraw_gadget							#   without risking runaway redraws.
#     call to actually redraw itself.								#   This mechanism is implemented via
#												#       done_extra_redraw_request_this_frame:	Ref(Bool),
# In general it is the gadget's responsibility to call
#     gadget_to_guiboss.needs_redraw_gadget_request
# when it needs to be redrawn.  There are exactly two
# situations in which guiboss_imp will send a
#     guiboss_to_gadget.redraw_gadget_request
# without such prompting:
#
#  1) At GUI startup guiboss_imp sends a redraw_gadget_request
#     to every gadget in the GUI, to establish the initial
#     visual appearance of the GUI.
#
#  2) When a widget's assigned site changes (say, due to the					# Window resizing is actually not supported as of 2014-11-28
#     user resizing the window).
# 
# Originally, to be helpful, guiboss_imp would spontaneously send a
# a redraw_gadget_request() to any gadget receiving a mouse event
# or such, but I eventually concluded that this was more confusing
# than helpful, and retreated to the above simple, easy-to-remember
# policy.  (Also, spontaneous redraw_gadget_requests() could cause
# needless redraws, which for some gadgets might be quite expensive.)
#
# Note that there is no actual logic or interlock in place to
# prevent a gadget from ignoring the 
#     gadget_to_guiboss.needs_redraw_gadget_request
#     guiboss_to_gadget.redraw_gadget_request
# handshake and simply sending
#     gadget_to_guiboss.redraw_gadget
# There may be widget implementation problems for which this is
# actually a good solution, but it should be done only occasionally,
# after careful consideration of the alternatives and risks.
#
#                                      -- CrT 2014-11-28



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
