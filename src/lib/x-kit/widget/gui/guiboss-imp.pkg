## guiboss-imp.pkg
#
# For the big picture see the imp dataflow diagrams in
#
#     src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
#
# The vision here is to implement a simple, flexible, easy-to-customize
# GUI widget infrastructure portable to various rendering layers like
# X, OpenGL and javascript.  The allow small teams to efficiently develop
# (for example) GUI-driven custom scientific, stock-trading and programming
# support apps.  As such, the emphasis is on simplicity, portability,
# cleanliness, smooth integration with Mythryl facilities such as the
# type system, garbage collector and package system.  Competing with
# commercial GUI toolkits for glitter factor is NOT a priority.
#
# guiboss_imp is the master imp responsible for starting up and shutting
# down running GUIs.
#
# Most of its major types and supporting code for handling them is in
#     src/lib/x-kit/widget/gui/guiboss-types.pkg
#
# guiboss_imp GUIs divide into three types of spaces:
#     packedspace, for conventional row/column widget layout.
#     canvassapce, for draw and paint functionality and also
#                  free-form drop-and-drag knob-and-tube GUIs.
#     bouncespace, for 2D (and eventually 3D) animation.
#
# At the moment (2014-11-20) only packedspace is at all well developed.
#
# guiboss_imp delegates management of these three kinds of spaces
# (in particular widget layout) to
#     src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
#     src/lib/x-kit/widget/space/bounce/bouncespace-imp.pkg
#     src/lib/x-kit/widget/space/canvas/canvasspace-imp.pkg
#  
# guiboss_imp is designed to be portable, but at the moment the only
# rendering layer implemented is for X, using the interface exported by
#     src/lib/x-kit/widget/xkit/app/windowsystem-imp-for-x.pkg
#  
# We refer to mouse-sensitive controls as "gadgets".
# Each of our three spaces has its own flavor of gadget:
#     packedspace: Widgets, base implementation being   src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg
#     canvassapce: Objects, base implementation being   src/lib/x-kit/widget/xkit/theme/packed/default/look/object-imp.pkg
#     bouncespace: Sprites, base implementation being   src/lib/x-kit/widget/xkit/theme/packed/default/look/sprite-imp.pkg
#     

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;				# guiboss_types			is from   src/lib/x-kit/widget/gui/guiboss-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package bt  =  gui_to_bounce_theme;				# gui_to_bounce_theme		is from   src/lib/x-kit/widget/theme/bounce/gui-to-bounce-theme.pkg
    package ct  =  gui_to_canvas_theme;				# gui_to_canvas_theme		is from   src/lib/x-kit/widget/theme/canvas/gui-to-canvas-theme.pkg
    package pt  =  packed_theme;				# packed_theme			is from   src/lib/x-kit/widget/theme/packed/packed-theme.pkg

#   package os  =  guiboss_to_bouncespace;			# guiboss_to_bouncespace	is from   src/lib/x-kit/widget/space/bounce/guiboss-to-bouncespace.pkg
#   package cs  =  guiboss_to_canvasspace;			# guiboss_to_canvasspace	is from   src/lib/x-kit/widget/space/canvas/guiboss-to-canvasspace.pkg


    package boi =  bouncespace_imp;				# bouncespace_imp		is from   src/lib/x-kit/widget/space/bounce/bouncespace-imp.pkg
    package cai =  canvasspace_imp;				# canvasspace_imp		is from   src/lib/x-kit/widget/space/canvas/canvasspace-imp.pkg
    package pai =  packedspace_imp;				# packedspace_imp		is from   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

    #    
    package gws =  guiboss_to_windowsystem;			# guiboss_to_windowsystem	is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg
#   package b2g =  guiboss_to_gadget;				# guiboss_to_gadget		is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg

    package blh =  bouncespace_layout_hint;			# bouncespace_layout_hint	is from   src/lib/x-kit/widget/space/bounce/bouncespace-layout-hint.pkg
    package clh =  canvasspace_layout_hint;			# canvasspace_layout_hint	is from   src/lib/x-kit/widget/space/canvas/canvasspace-layout-hint.pkg
    package plh =  packedspace_layout_hint;			# packedspace_layout_hint	is from   src/lib/x-kit/widget/space/packed/packedspace-layout-hint.pkg

    package b2s =  bouncespace_to_sprite;			# bouncespace_to_sprite		is from   src/lib/x-kit/widget/space/bounce/bouncespace-to-sprite.pkg
    package c2o =  canvasspace_to_object;			# canvasspace_to_object		is from   src/lib/x-kit/widget/space/canvas/canvasspace-to-object.pkg
    package p2w =  packedspace_to_widget;			# packedspace_to_widget		is from   src/lib/x-kit/widget/space/packed/packedspace-to-widget.pkg

    package s2b =  sprite_to_bouncespace;			# sprite_to_bouncespace		is from   src/lib/x-kit/widget/space/bounce/sprite-to-bouncespace.pkg
    package o2c =  object_to_canvasspace;			# object_to_canvasspace		is from   src/lib/x-kit/widget/space/canvas/object-to-canvasspace.pkg
    package w2p =  widget_to_packedspace;			# widget_to_packedspace		is from   src/lib/x-kit/widget/space/packed/widget-to-packedspace.pkg

    package s2g =   space_to_gui;				# space_to_gui			is from   src/lib/x-kit/widget/gui/space-to-gui.pkg
#   package g2g =  gadget_to_guiboss;				# gadget_to_guiboss		is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
#    package c2g =  client_to_guiboss;				# client_to_guiboss		is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package iul =  issue_unique_look_id;			# issue_unique_look_id		is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;				# geometry2d_junk		is from   src/lib/std/2d/geometry2d-junk.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

    dummy1 = evt::t::bin_op;		# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
    dummy2 = gts::gui_event_name;	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
herein

    package guiboss_imp
    :       Guiboss_Imp													# Guiboss_Imp		is from   src/lib/x-kit/widget/gui/guiboss-imp.api
    {
	Client_To_Guiboss
	  =
	  { id:			Id,											# Unique id to facilitate storing guiboss instances in indexed datastructures like red-black trees.
	    #
	    get_bounce_theme:	Void -> bt::Gui_To_Bounce_Theme,
	    get_canvas_theme:	Void -> ct::Gui_To_Canvas_Theme,
	    get_packed_theme:	Void -> pt::Packed_Theme,
	    #
	    make_topwindow:	 gws::Topwindow_Hints			    ->  gws::Guiboss_To_Topwindow,		# 
	    #
	    start_gui:		(gws::Guiboss_To_Topwindow, gt::Gui_Plan)   -> (Void -> gt::Client_To_Guiwindow),	# Calling return value will block microthread until gui-plan    startup is complete.
	    restart_gui:	(gws::Guiboss_To_Topwindow, gt::Paused_Gui) -> (Void -> gt::Client_To_Guiwindow)	# Calling return value will block microthread until stopped-gui restart is complete.
	  };

	Guiboss_Option
	  #
	  =  MICROTHREAD_NAME	String											# 
	  |  ID			Id											# Stable, unique id for imp.
	  ;	

	Guiboss_Arg =  List(Guiboss_Option);										# Currently no required component.

	Imports = {													# Ports we use, provided by other imps.
		    int_sink:			Int -> Void,
		    guiboss_to_windowsystem:	gws::Guiboss_To_Windowsystem,	
		    gui_to_bounce_theme:	bt::Gui_To_Bounce_Theme,
		    gui_to_canvas_theme:	ct::Gui_To_Canvas_Theme,
		    theme:			pt::Packed_Theme
		  };

	Bounce_Imps
	  =
	  Ref( im::Map( { sprite_to_bouncespace:	s2b::Sprite_To_Bouncespace,					# Possibly this should be stored in Running_Gui rather than here; time will tell. This is a good first try.
			  guiboss_to_bouncespace:	gt::Guiboss_To_Bouncespace,
			  endstate_oneshot:		Oneshot_Maildrop( gt::Bouncespace_Arg )
			}
	     )        );

	Canvas_Imps
	  =
	  Ref( im::Map( { object_to_canvasspace:	o2c::Object_To_Canvasspace,					# Possibly this should be stored in Running_Gui rather than here; time will tell. This is a good first try.
			  guiboss_to_canvasspace: 	gt::Guiboss_To_Canvasspace,
			  endstate_oneshot:		Oneshot_Maildrop( gt::Canvasspace_Arg )
			}
	     )        );

	Packed_Imps
	  =
	  Ref( im::Map( { widget_to_packedspace:	w2p::Widget_To_Packedspace,					# Possibly this should be stored in Running_Gui rather than here; time will tell. This is a good first try.
			  guiboss_to_packedspace: 	gt::Guiboss_To_Packedspace,
			  endstate_oneshot:		Oneshot_Maildrop( gt::Packedspace_Arg )
			}
	     )        );

	Site = Ref( g2d::Box );												# Pixel-rectangle assigned to the widget, in backing-pixmap coordinates.

	Gadget_Info													# The per-gadget information we track.  (This is private to guiboss-imp.)
	  =														# Here 'gadget' refers indifferently to widget-imps, sprite-imps and object-imps.
	  {
	    site:			Site,										# Where to draw this gadget, in topwindow coordinates.
	    backing_pixmap:		Ref(gt::Backing_Pixmap),
	    #
	    guiboss_to_gadget:		gt::Guiboss_To_Gadget,								# We use this to make requests of visible gadgets.
	    gadget_mode:		Ref( gt::Gadget_Mode ),
	    #
	    may_have_visibly_changed:	Ref( Bool ),									# 
	    sent__before_first_frame:	Ref( Bool ),
	    #
	    point_in_gadget:		Ref( Null_Or( g2d::Point -> Bool ))						# Optional fn to decide if a mouseclick actually hit the gadget itself, or just somewhere near it in the screenspace assigned to it.
	  };  

	fun same_gadget_info
	      (
		{ guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget1, ... }:	Gadget_Info,	
		{ guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget2, ... }:	Gadget_Info
	      )
	    =
	    iul::same_id ( guiboss_to_gadget1.id,
			   guiboss_to_gadget2.id
			 );

	Gadget_Imps
	  =
	  Ref( im::Map( Gadget_Info ) );										# We use this to make requests of visible gadgets.	Index is  (id_to_int guiboss_to_gadget.id).

	Mouse_Is													# Support for mouse drag operations.
	  #
	  = CROSSING_NONGADGET												# Mouse is not currently to be on any gadget.
	  #
	  | CROSSING_GADGET												# Mouse is currently on a gadget. Eventually we should issue ENTER and LEAVE events based on this. 	
	      { gadget_info:		Gadget_Info									# This is the gadget on which the mouse is currently located. We send a LEAVE event when the mouse leaves it.
	      }
	  #
	  | DRAGGING_IN_GADGET												# Mouse is being dragged on this gadget.
	      { gadget_info:		Gadget_Info,									# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
		start_point:		g2d::Point,									# This is the window coordinate of the downclick which started this drag.
		last_point:		g2d::Point									# This is the window coordinate of the last motion event for this drag.
	      }
	  ;

	Topwindow_Info
	  =
	  { # These three are valid throughout
	    # the lifetime of the topwindow:
	    #
	    guiboss_to_topwindow:		gws::Guiboss_To_Topwindow,
	    current_frame_number:		Ref(Int),								# We count frames for convenience of widgets and debugging.
	    seconds_per_frame:			Ref(Float),								# Primarily so widgets can do motion blurring if they wish.

	    done_extra_startframe_this_frame:	Ref(Bool),								# See Note[1].

	    next_stacking_order:		Ref(Int),								# Next Backing_Pixmap.stacking_order value to issue.
	    

	    # The remainder are valid only while a gui is running,
	    # which is to say, between restart_gui' and pause_gui':

	    mouse_is:			Ref( Mouse_Is ),								# Support for mouse drag operations.

	    # These are set by restart_gui'()
	    # and reset to NULL by pause_gui'     
	    #
	    backing_pixmap:		Ref( Null_Or( gt::Backing_Pixmap ) ),

	    # These four are reset to im::empty by pause_gui';
	    #
	    gadget_imps:		Gadget_Imps,									# Holds our     Gadget_Info            instances -- basically, all running widgets, sprites and objects in topwindow.
	    bounce_imps:		Bounce_Imps,									# Holds our gt::Guiboss_To_Bouncespace instances -- can't put them directly in Running_Gui due to circularity.
	    canvas_imps:		Canvas_Imps,									# Holds our gt::Guiboss_To_Canvasspace instances -- can't put them directly in Running_Gui due to circularity.
	    packed_imps:		Packed_Imps									# Holds our gt::Guiboss_To_Packedspace instances -- can't put them directly in Running_Gui due to circularity.
	  };

	Guiboss_State													# Holds all nonephemeral mutable state maintained by package.
	  =
	  {
	    topwindows:			Ref( im::Map( Topwindow_Info  ) )						# Each call to client_to_guiboss.make_topwindow() adds one entry to this.  Indexed by guiboss_to_topwindow.id.
	  };

	Me_Slot = Mailslot( { imports:		Imports,
			      me:		Guiboss_State,
			      guiboss_arg:	Guiboss_Arg,
			      run_gun':		Run_Gun,
			      end_gun':		End_Gun
			    }
			  );

	Exports	= {													# Ports we provide for use by other imps.
		    client_to_guiboss:	Client_To_Guiboss
		  };


	Guiboss_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);


	Runstate =    {													# These values will be statically globally visible throughout the code body for the imp.
			me:			Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
			guiboss_arg:		Guiboss_Arg,
			imports:		Imports,								# Imps to which we send requests.
			to:			Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
			end_gun':		End_Gun,								# We shut down the microthread when this fires.
			id:			Id
		      };

	Guiboss_Q    = Mailqueue( Runstate -> Void );


	fun pprint_gadget_info (gadget_info: Gadget_Info)
	    =
	    pp::with_standard_prettyprint_mill
		#
		(err::default_plaint_sink ())	[]
		#
		(\\ pp:   pp::Prettyprint_Mill
		    =
		    do_gadget_info gadget_info
		    where
			fun do_gadget_info
			      (
				{
				  site:				Site,										# Where to draw this gadget, in topwindow coordinates.
				  backing_pixmap:		Ref(gt::Backing_Pixmap),
				  #
				  guiboss_to_gadget:		gt::Guiboss_To_Gadget,								# We use this to make requests of visible gadgets.
				  gadget_mode:			Ref( gt::Gadget_Mode ),
				  #
				  may_have_visibly_changed:	Ref( Bool ),									# 
				  sent__before_first_frame:	Ref( Bool ),
				  #
				  point_in_gadget:		Ref( Null_Or( g2d::Point -> Bool ))						# Optional fn to decide if a mouseclick actually hit the gadget itself, or just somewhere near it in the screenspace assigned to it.
				}:				Gadget_Info
			      )
			    =
			    {   pp.box {.
				    pp.lit  "Gadget_Info {";
				    pp.ind 2;
				    pp.txt " ";

				    pp.lit  (sprintf "site => %s" (g2j::box_to_string *site));
				    pp.endlit ",";

				    pp.lit  (sprintf "backing_pixmap => %s" (gt::backing_pixmap_id *backing_pixmap));
				    pp.endlit ",";
				    
				    guiboss_to_gadget -> gt::GUIBOSS_TO_GADGET { id, ... };
				    pp.lit (sprintf "GUIBOSS_TO_GADGET.id => %d" (iul::id_to_int id));

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "}";
				};
				pp.newline();
			    };	
		    end
		);

	fun clear_box_in_pixmap												# Clear a box to black, mostly to avoid undefined values etc.
	      (
		pixmap:			gt::Backing_Pixmap,								# pixmap holding the viewport.
		box:			g2d::Box									# Box in view coordinates.
	      )
	    =
	    {
# PLUGH
# nb {. sprintf "clear_box_in_pixmap/AAA box = %s -- guiboss-imp.pkg" (g2j::box_to_string box); };
		#
		case pixmap
		    #
		    gt::TOPWINDOW_PIXMAP { pixmap:	g2p::Gadget_To_Rw_Pixmap, ... } => pixmap.draw_displaylist [ gd::COLOR (r64::black,  [ gd::FILLED_BOXES [ box ]]) ];
		    gt::VIEWPORT_PIXMAP  { pixmap:	g2p::Gadget_To_Rw_Pixmap, ... } => pixmap.draw_displaylist [ gd::COLOR (r64::black,  [ gd::FILLED_BOXES [ box ]]) ];
		esac;
	    };
															# The high-level architectural ideas here are:
															#  o  Every running gui has an associated offscreen backing_pixmap containing a complete image of its window.
															#     We have one running gui for the main visible window plus one for each visible popup.
															#     (Popups do not have separate X windows; they are implemented entirely client-side, drawing into the main window.)
															#     The popups cover less screen space than the main visible window, so they have smaller offscreen backing_pixmaps.
															#  o  Gadgets always draw to the offscreen backing_pixmap for the running gui with which they are associated.
															#  o  We update the visible window by copying rectangles from the backing_pixmaps to the visible window.
															#     These copies need to respect the popup hierarchy, e.g. the main running_gui must not write over screenspace belonging to any popup.
															#     We never do text drawing ops or such directly onto the visible window.
															#  o  Scrollable views introduce an additional level of indirection:
															#      *  Each scrollable view has its own offscreen backing_pixmap.
															#      *  Widgets located on a scrollable view draw to its backing_pixmap.
															#      *  We copy rectangles from the scrollable-view backing_pixmap to its parent backing_pixmap.
															#         (We never copy directly from the scrollable-view backing_pixmap to the visible window.)
															#      *  Scrollable-view stuff then becomes visible when the parent backing_pixmap is copied to the visible window.
															#      *  It is reasonable for a scrollable view to contain another scrollable view, so the above should be understood recursively.
															#
															# Nomenclature: "blit" is from "BitBLT" == "bit-boundary block transfer" -- originally a Xerox Alto graphics op, now informal jargon term. For more info:   http://en.wikipedia.org/wiki/Bit_blit
															# Because we allow nested scrollable subwindows of main topwindow for app,
															# it is nontrivial to figure out where on the topwindow a given gadget is
															# visible -- if it is visible at all! -- and how much is visible, and what
		 													# pixel rectangle to copy from where to where to update the gadget's on-
															# screen image.  That's our job here.
	fun update_offscreen_parent_pixmaps_and_then_topwindow
	      (
		pixmap:				gt::Backing_Pixmap,
		from_box:			g2d::Box,								# From-box in source pixmap coordinates.
		topwindow_for_gui:		gws::Guiboss_To_Topwindow
	      )
	    =
	    {
		propagate_frombox_changes_to_all_parents_in_which_they_are_visible
		    #
		    (pixmap, from_box);											# Copy visible part of gadget to the backing pixmap for the viewport containing it, the backing pixmap for the viewport containing that viewport etc and finally the visible topwindow itself.
	    }														# Typically there will be no viewports involved, so this will be just a blit to the topwindow.
	    where
# PLUGH
# nb {. sprintf "update_offscreen_parent_pixmaps_and_then_topwindow/AAA from_box = %s  pixmap id = %s-- guiboss-imp.pkg" (g2j::box_to_string from_box) (gt::backing_pixmap_id pixmap); };
# nb {. sprintf "update_offscreen_parent_pixmaps_and_then_topwindow/BBB: pprinting (gt::root_pixmap pixmap)"; };
# gt::pprint_backing_pixmap  (gt::root_pixmap pixmap);
# nb {. sprintf "update_offscreen_parent_pixmaps_and_then_topwindow/BBB': pprinting pixmap"; };
# gt::pprint_backing_pixmap  pixmap;

		fun find_frombox_parts_not_hidden_by_popups
		      (
			backing_pixmap:		gt::Backing_Pixmap,
			from_box:		g2d::Box								# We assume this is in local backing_pixmap coordinates (not basewindow coordinates).
		      )
		    =
		    {
															# The redraw logic expects the from_box info to be in 'backing_pixmap' coordinates, not basewindow coords.
															# But to compare from_box with the possibly shading running-gui pixmaps, they must all be in the samme coordinate system.
															# Consequently we transform the possibly_shading_pixmaps into our local 'backing_pixmap' coordinates.
# PLUGH
# nb {. sprintf "find_frombox_parts_not_hidden_by_popups/CCC from_box = %s -- guiboss-imp.pkg" (g2j::box_to_string from_box); };
			# Now we figure out which parts of 'from_box'
			# are not hidden by popup windows:

			bp = gt::topwindow_pixmap_of_backing_pixmap  backing_pixmap;					# This returns 'r' from   backing_pixmap as (TOPWINDOW_PIXMAP r).   "bp" == "backing_pixmap".

			possibly_shadowing_pixmaps									# Get the popup windows which are maybe shadowing us (that is, which we might clobber if we drew all of from_box)
			    =
			    gt::find_all_topwindow_pixmaps_above_given_backing_pixmap_in_stacking_order
				#
				backing_pixmap;

			possibly_shadowing_sites									# Convert the possibly_shadowing_pixmaps to boxes in basewindow coordinates.
			    =
			    (map gt::topwindow_pixmap_site_in_basewindow_coordinates					# This adds in the 'origin' fields of all our parents.
				#
				possibly_shadowing_pixmaps
			    )
			    :   List( g2d::Box );

#			our_site = topwindow_pixmap_site_in_basewindow_coordinates bp;

# PLUGH
# nb {. sprintf "find_frombox_parts_not_hidden_by_popups/DDD possibly_shadowing_sites = %s -- guiboss-imp.pkg" (g2j::boxes_to_string ("",possibly_shadowing_sites)); };

#			from_box
#			    =
#			    translate_frombox_to_basewindow_coordinates
#				#
#				(bp, from_box);
# nb {. sprintf "find_frombox_parts_not_hidden_by_popups/EEE translated from_box = %s -- guiboss-imp.pkg" (g2j::box_to_string from_box); };

			bp_origin_in_basewindow_coordinates
			    =
			    g2d::box::upperleft
			      (
				gt::topwindow_pixmap_site_in_basewindow_coordinates  bp
			      );

			possibly_shadowing_sites									# Convert shadowing sites from basewindow coords to 'backing_pixmap' coords.
			    =
			    (map translate_site_to_our_coordinate_system
				#
				possibly_shadowing_sites								# 
			    )
			    where
				fun translate_site_to_our_coordinate_system (box: g2d::Box)
				    =
				    {   (g2d::box::upperleft_and_size  box)
					    ->
					    (box_origin, size);

					g2d::box::make  (box_origin - bp_origin_in_basewindow_coordinates,  size);
				    };
			    end;

# PLUGH
# nb {. sprintf "find_frombox_parts_not_hidden_by_popups/FFF possibly_shadowing_sites = %s -- guiboss-imp.pkg" (g2j::boxes_to_string ("",possibly_shadowing_sites)); };

# case possibly_shadowing_sites
#     #
#     [ shadowbox ]
# 	=>
# 	{    visible_parts
# 		=
# 		g2d::box::subtract_box_b_from_box_a
# 		  {
# 		    a => from_box,
# 		    b => shadowbox
# 		  }; 
# # nb {. sprintf "find_frombox_parts_not_hidden_by_popups/XXX visible_parts = %s -- guiboss-imp.pkg" (g2j::boxes_to_string ("",visible_parts)); };
# 	};
#     _ => ();	
# esac;

			visible_parts_of_frombox									# Subtract the boxes from from_box to see what parts of from_box it is actually safe to draw (if any).
			    =
			    g2d::box::subtract_boxes_b_from_boxes_a
			      {
				a => [ from_box ],
				b => possibly_shadowing_sites
			      };
# PLUGH
# nb {. sprintf "find_frombox_parts_not_hidden_by_popups/FFF visible_parts_of_frombox = %s -- guiboss-imp.pkg" (g2j::boxes_to_string ("",visible_parts_of_frombox)); };

			visible_parts_of_frombox;									# 
		    };													# fun find_frombox_parts_not_hidden_by_popups

		fun propagate_frombox_changes_to_all_parents_in_which_they_are_visible					# Caller has just changed contents of from_box in backing_pixmap:  We need to propagate these changes to all parents in which it is visible.
		      (
			backing_pixmap											# A gt::TOPWINDOW_PIXMAP contains the complete offscreen image of one running gui, either the main window one or a popup.
			as												# Consequently in the gt::TOPWINDOW_PIXMAP case we are always copying from the offscreen backing_pixmap to the visible screen,
			gt::TOPWINDOW_PIXMAP bp,									# never from one offscreen backing_pixmap to another.  When copying to the visible screen we do need to be careful not to
															# overwrite screen space belonging to any popup which is above us in the stacking order.
			from_box:	g2d::Box									# From-box in source pixmap coordinates.
		      )
			=>
			{
# PLUGH
# nb {. sprintf "propagate_frombox_changes_to_all_parents_in_which_they_are_visible/AAA from_box = %s -- guiboss-imp.pkg" (g2j::box_to_string from_box); };
			    frombox_fragments_to_draw									# These are in local pixmap coordinates (not basewindow coordinates).
				=
				find_frombox_parts_not_hidden_by_popups (backing_pixmap,  from_box);
# PLUGH
# nb {. sprintf "propagate_frombox_changes_to_all_parents_in_which_they_are_visible/BBB: from_box = %s frombox_fragments_to_draw = \n%s -- guiboss-imp.pkg" (g2j::box_to_string from_box) (g2j::boxes_to_string ("", frombox_fragments_to_draw)); };

			    pixmap_site
				=
				gt::topwindow_pixmap_site_in_basewindow_coordinates   bp;

			    pixmap_origin = g2d::box::upperleft  pixmap_site;

			    from_id   =  gt::backing_pixmap_id_of  backing_pixmap;					# This is the pixmap holding the source pixels for the blit.
			    #
			    apply  draw_fragment  frombox_fragments_to_draw						# For each part of from_box which is not hidden by overlying popups....
				where
				    fun draw_fragment (from_box: g2d::Box)
					=
					{
					    to_point  =  (g2d::box::upperleft  from_box) + pixmap_origin;		# Where should we copy pixels to, on the visible topwindow?   If we are a popup, we need to add in the popup origin (pixmap_origin) in basewindow coordinates.

# PLUGH
# nb {. sprintf "draw_fragment/AAA from_box = %s to_point %s from_id %d -- guiboss-imp.pkg" (g2j::box_to_string from_box) (g2j::point_to_string to_point) (id_to_int from_id); };
					    topwindow_for_gui.draw_displaylist						# ... blit that part to on-screen window for user to see.
					      [
						gd::COPY_FROM_RW_PIXMAP { from_box, to_point, from_id }
					      ];
# PLUGH
# nb {. sprintf "draw_fragment/ZZZ -- guiboss-imp.pkg"; };
					};
				end;
# PLUGH
# nb {. sprintf "propagate_frombox_changes_to_all_parents_in_which_they_are_visible/ZZZ -- guiboss-imp.pkg"; };
			};

		    propagate_frombox_changes_to_all_parents_in_which_they_are_visible
		      (
			backing_pixmap											# A gt::VIEWPORT_PIXMAP contains the offscreen image of one scrollable viewport embedded within a parent backing_pixmap.
			as												# Consequently in the gt::VIEWPORT_PIXMAP case we are always copying from one offscreen backing_pixmap to another.
			gt::VIEWPORT_PIXMAP  { is_visible:	Ref( Bool ),						# We do not have to worry about popups blocking our copies, since they are entirely internal to one running_gui.
						pixmap:		g2p::Gadget_To_Rw_Pixmap,
						viewports:	Ref( List( gt::Viewport ) )				# We make this a Ref(List(...)) to allow for adding additional viewports opening onto the same underlying pixmap.
					      },

			from_box:	g2d::Box											# From-box in source pixmap.
		      )
			=>
{
# PLUGH
# nb {. sprintf "propagate_frombox_changes_to_all_parents_in_which_they_are_visible/AAA from_box = %s -- guiboss-imp.pkg" (g2j::box_to_string from_box); };
			if (*is_visible)												# Do not propagate if we are one of multiple TABBED_VIEWS and we are not visible.
			    #	
			    from_id   =  gt::backing_pixmap_id_of  backing_pixmap;							# The Id for the source pixmap for the copy.

			    apply   do_viewport  *viewports										# We may be visible in multiple viewports, each of which may be visible in multiple viewports, so potentially we need to update a tree of parents.
				    where
					fun do_viewport											# Handle update of our image as visible via one parent viewport.
					      {	parent_pixmap:	gt::Backing_Pixmap,
						viewport_site:	Ref(g2d::Box),								# Size and location of subwindow viewport in parent Backing_Pixmap coordinates.
						#
						view_origin:	Ref(g2d::Point)								# Used to scroll subwindow contents around in parent viewport: view origin in viewport coordinates.
					      }
					    =
					    {	viewport_origin_in_view									# If the from_box is not entirely visible in the viewport
						    =											# then we need to clip it to the viewport.  Since we want
						    g2d::point::zero - *view_origin;							# the clipped from_box to be in the gadget's home pixmap,
																	# the most straightforward approach is to transform the
																	# viewport into home pixmap space.  If *view_origin is
						viewport' = g2d::box::clone_box_at (*viewport_site, viewport_origin_in_view);		# 0,0 then viewport is at (0,0) in home pixmap, otherwise
																	# it is offset by -*view_origin, so in general we want
																	# the viewport cloned at -*view_origin.



						to_point  = g2d::box::upperleft  from_box;						# Where should we copy pixels to, on our parent pixmap?   We initialize this to the null transform -- we'll add in appropriate offsets to this momentarily.

# PLUGH
# nb {. sprintf "propagate_frombox_changes_to_all_parents_in_which_they_are_visible/do_viewport/AAA viewport' = %s -- guiboss-imp.pkg" (g2j::box_to_string viewport'); };
						case (g2d::box::intersection (viewport', from_box))
						    #
						    NULL => ();										# No intersection between from_box and viewport' means no part of gadget is visible, so just return NULL.
						    #
						    THE from_box'
							=>
							{
							    my (to_point, from_box)							# Update to_point and from_box to account for clipping due
								=									# to intersection between viewport and old from_box value.
								if (g2d::box::eq (from_box', from_box))
								    #
								    (to_point, from_box);						# No actual clipping (from_box must be completely visible in viewport) so nothing to do here.

								elif (g2d::point::eq ( g2d::box::upperleft( from_box' ),		# Is origin of from_box' different from origin or from_box?
										       g2d::box::upperleft( from_box  )
								     ) 		   )

								    (to_point, from_box');						# No, so to_point stays the same, we just replace from_box with from_box'.
								else
																	# Yes, so we need to move to_point to reflect displacement between from_box and from_box'.
								    frombox_displacement
									=
									g2d::point::subtract( g2d::box::upperleft( from_box' ),		# Compute that displacement.
											      g2d::box::upperleft( from_box  )
											    );

								    to_point'   = g2d::point::add (to_point, frombox_displacement);	# Apply it.

								    (to_point', from_box');						# Done.
								fi;

																	# Now we just need to compute where from_box should be drawn in
																	# current sub/window, then update to_point and continue recursively.

							    to_point = g2d::point::add (to_point, *view_origin);			# Account for location of view  relative to viewport.
							    to_point = g2d::point::add (to_point, g2d::box::upperleft(*viewport_site));	# Account for location of viewport relative to parent pixmap.

							    parent_pixmap' =  gt::gadget_to_rw_pixmap__of  parent_pixmap;		# Find off-screen backing pixmap containing viewport onto us.
							    from_id	   =  pixmap.id;						# Pixmap to copy rectangle from (as Id).
							    gui_displayop  =  gd::COPY_FROM_RW_PIXMAP { from_box, to_point, from_id };	# The actual copy from our pixmap to viewport area in parent pixmap.
							    #										#
							    parent_pixmap'.draw_displaylist [ gui_displayop ];				# Draw updated gadget appearance into its off-screen backing-pixmap home site.

							    from_box = g2d::box::clone_box_at (from_box, to_point);			# Our to-box is from_box for the next level of recursion.

# PLUGH
# nb {. sprintf "propagate_frombox_changes_to_all_parents_in_which_they_are_visible/do_viewport/MMM from_box = %s -- guiboss-imp.pkg" (g2j::box_to_string from_box); };
							    propagate_frombox_changes_to_all_parents_in_which_they_are_visible		# Continue recursively to next level of viewport nesting.
								#
								(parent_pixmap, from_box);
							};
						esac;

					    };
				    end;	
			fi;
};
		end;
	    end;

	fun redraw_all_running_guis											# Intended to be called after changing the popup structure -- killing a popup, moving a popup, whatever. (Not needed after just creating a new popup.)
	      (														# For our purposes here the base window is just one more popup, which happens to never go away.  I.e., for us, "popup" == "gt::TOPWINDOW_PIXMAP".
		backing_pixmap:		gt::Backing_Pixmap,								# This provides redraw_all_running_guis an entrypoint into the remaining Backing_Pixmap tree. Any Backing_Pixmap in the tree would do.
		topwindow_for_gui:	gws::Guiboss_To_Topwindow							# This provides redraw_all_running_guis with the window on which to do the redraw.
	      )
	    =
	    {
		backing_pixmaps_to_redraw
		    =
		    gt::find_all_backing_pixmaps_above_given_stacking_order
			#
			(backing_pixmap, 0);										# 'stacking_order' fields are always positive, so searching for all Backing_Pixmap instances with stacking_order > 0 gets us everything.	

		apply   redraw_backing_pixmap  backing_pixmaps_to_redraw
			where
			    fun redraw_backing_pixmap
				  (
				    backing_pixmap:	gt::Backing_Pixmap
				  )
				=
				{
				    topwindow_pixmap
					=
					gt::topwindow_pixmap_of_backing_pixmap
					    #
					    backing_pixmap;

				    size     =  topwindow_pixmap.pixmap.size;						# Redraw all of running gui.
				    origin   =  g2d::point::zero;							# We need from_box to be in backing_pixmap coordinate system, so origin will always be zero.
				    #
				    from_box =  g2d::box::make (origin, size);						# Our from_box covers the entire popup pixmap, so as to redraw all of it.

				    update_offscreen_parent_pixmaps_and_then_topwindow					# Redraw all visible parts of popup. (In our situation there is no offscreen updating to be done.)
					#
					(backing_pixmap, from_box, topwindow_for_gui);
				};
			end;
	    };	

	fun run ( guiboss_q:			Guiboss_Q,								# 
		  #
		  runstate as
		  {													# These values will be statically globally visible throughout the code body for the imp.
		    me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		    guiboss_arg:		Guiboss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# We shut down the microthread when this fires.
		    id:				Id
		  }
		)
	    =
	    {	loop ();
	    }
	    where


		#
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    end_gun'                       ==>  shut_down_guiboss_imp',
			    take_from_mailqueue' guiboss_q ==>  do_guiboss_plea
			];

			loop ();
		    }	
		    where
			fun do_guiboss_plea  thunk
			    =
			    thunk runstate;
			#
			fun shut_down_guiboss_imp' ()
			    =
			    {
				thread_exit { success => TRUE };							# Will not return.	
			    };
		    end;
	    end;	

	#
	fun kill_gui'
	      (
		runstate as
		{ me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		  guiboss_arg:			Guiboss_Arg,
		  imports:			Imports,								# Imps to which we send requests.
		  to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		  end_gun':			End_Gun,
		  id:				Id
		}:				Runstate,
		( running_gui:			gt::Running_Gui,
		  bounce_imps:			Bounce_Imps,
		  canvas_imps:			Canvas_Imps,
		  packed_imps:			Packed_Imps,
		  gadget_imps:			Gadget_Imps,
		  topwindow_info:		Topwindow_Info,
		  redraw_window_when_done:	Bool
		)
	      )
	    =
	    {	# Recursively kill off all running guis
		# which are children of current running gui:
		#
nb {. sprintf "kill_gui'/AAA: (%s): doing recursive kills of children if any" (gt::backing_pixmap_id running_gui.topwindow_pixmap); };
		case running_gui.topwindow_pixmap
		    #
		    gt::TOPWINDOW_PIXMAP r
			=>
			apply kill_one_subgui *r.popups
			where
			    fun kill_one_subgui (backing_pixmap: gt::Backing_Pixmap)
				=
				case backing_pixmap
				    #
				    gt::TOPWINDOW_PIXMAP r
					=>
					case *r.running_gui
					    #
					    THE running_gui => kill_gui' (runstate, (running_gui, bounce_imps, canvas_imps, packed_imps, gadget_imps, topwindow_info, FALSE));

					    NULL => ();
					esac;

				    gt::VIEWPORT_PIXMAP _
					=>
					{   msg = "kill_gui': backing_pixmap popups should never be gt::VIEWPORT_PIXMAP!";
					    log::fatal msg;
					    raise exception FAIL msg;
					};

				esac;
			end;

		    gt::VIEWPORT_PIXMAP _
			=>
			{   msg = "kill_gui': running_gui.topwindw_pixmap should never be gt::VIEWPORT_PIXMAP!";
			    log::fatal msg;
			    raise exception FAIL msg;
			};
		esac;
		

nb {. sprintf "kill_gui'/BBB: (%s): firing end gun" (gt::backing_pixmap_id running_gui.topwindow_pixmap); };
		running_gui.fire_end_gun ();										# Shut down GUI impnet.
		#

nb {. sprintf "kill_gui'/CCC: (%s): removing us from parent, if any" (gt::backing_pixmap_id running_gui.topwindow_pixmap); };
case *topwindow_info.backing_pixmap
    #
    THE backing_pixmap
	=>
	{
nb {. sprintf "kill_gui'/CCCC: (%s): , first printing out BEFORE backing_pixmap hierarchy" (gt::backing_pixmap_id running_gui.topwindow_pixmap); };
gt::pprint_backing_pixmap (backing_pixmap);
	};

    NULL => ();
esac;

nb {. sprintf "kill_gui'/CCCD: running_gui.topwindow_pixmap == %s" (gt::backing_pixmap_id running_gui.topwindow_pixmap); };
		case running_gui.topwindow_pixmap
		    #
		    gt::TOPWINDOW_PIXMAP r
			=>
			{   # If we have a parent, remove ourself from parent's list of active popups:
			    #	
			    case r.parent
				#
				THE parent_backing_pixmap
				    =>
				    # We do have a parent -- remove ourself from parent's list of active popups:
				    #	
				    case parent_backing_pixmap
					#
					gt::VIEWPORT_PIXMAP _ => ();		# Shouldn't be possible.

					gt::TOPWINDOW_PIXMAP q
					    =>
{
nb {. sprintf "kill_gui'/CCCE: #q.popups=%d running_gui.topwindow_pixmap=%s  THE parent_backing_pixmap w parent_backing_pixmap=%s" (list::length *q.popups) (gt::backing_pixmap_id running_gui.topwindow_pixmap) (gt::backing_pixmap_id parent_backing_pixmap); };
					    q.popups := list::remove  is_us  *q.popups
							where
							    fun is_us (bp: gt::Backing_Pixmap)
								=
								case bp
								    #
								    gt::TOPWINDOW_PIXMAP r'
									=>
{
nb {. sprintf "kill_gui'/is_us: r.pixmap.id=%d r'.pixmap.id=%d" (id_to_int r.pixmap.id) (id_to_int r'.pixmap.id); };
									same_id (r.pixmap.id, r'.pixmap.id);
};

								    gt::VIEWPORT_PIXMAP _ => FALSE;
								esac;
							end;
nb {. sprintf "kill_gui'/CCCEE: #q.popups=%d" (list::length *q.popups); };
};
				    esac;

				NULL =>
				    {
nb {. sprintf "kill_gui'/CCCE: (%s) NULL case" (gt::backing_pixmap_id running_gui.topwindow_pixmap); };
					();
				    };
			    esac;

			    r.pixmap.free_rw_pixmap ();									# Free our main Xserver-side backing rw_pixmap for this running gui:

			    apply free_rw_pixmap (im::vals_list *r.pixmaps)			 			# Free all Xerver-side rw_pixmaps allocated by our widgets:
			    where
				fun free_rw_pixmap (rw_pixmap: g2p::Gadget_To_Rw_Pixmap)
				    =
				    rw_pixmap.free_rw_pixmap ();							# This is a no-op if the widget already freed the rw_pixmap.
			    end;
			};

		    gt::VIEWPORT_PIXMAP _
			=>
			{   msg = "kill_gui': running_gui.topwindw_pixmap should never be gt::VIEWPORT_PIXMAP!";
			    log::fatal msg;
			    raise exception FAIL msg;
			};
		esac;
case *topwindow_info.backing_pixmap
    #
    THE backing_pixmap
	=>
	{
nb {. sprintf "kill_gui'/CCCCC: (%s): , now printing out AFTER backing_pixmap hierarchy" (gt::backing_pixmap_id running_gui.topwindow_pixmap); };
gt::pprint_backing_pixmap (backing_pixmap);
	};
    NULL => ();
esac;

		case running_gui.topwindow_pixmap
		    #
		    gt::TOPWINDOW_PIXMAP r
			=>
			case r.parent
			    #
			    NULL  =>    topwindow_info.backing_pixmap :=  NULL;						# We're killing the toplevel gui for this topwindow so remember that we no longer have a gui running on this topwindow.
			    THE _ =>    ();										# We're pausing a secondary popup gui for this topwindow.
			esac;

		    gt::VIEWPORT_PIXMAP _
			=>
			{   msg = "topwindow_pixmap should not be VIEWPORT_PIXMAP! -- restart_gui'";
			    log::fatal msg;
			    raise exception FAIL msg;
			};
		esac;

nb {. sprintf "kill_gui'/DDD: (%s): redrawing entire screen" (gt::backing_pixmap_id running_gui.topwindow_pixmap); };
		case *topwindow_info.backing_pixmap									# Redraw the window if there are any running guis left to redraw.
		    #
		    THE backing_pixmap
			=>		
			redraw_all_running_guis
			  (
			    backing_pixmap,										# This provides redraw_all_running_guis an entrypoint into the remaining Backing_Pixmap tree. Any Backing_Pixmap in the tree would do.
			    topwindow_info.guiboss_to_topwindow
			  );

		    NULL =>												# No running guis left on window so clear it to black.
			case running_gui.topwindow_pixmap
			    #
			    gt::TOPWINDOW_PIXMAP r
				=>
				{   site =  g2d::box::make  (g2d::point::zero,  r.pixmap.size);
				    #
				    clear_box_in_pixmap (running_gui.topwindow_pixmap, site);
				};

			    gt::VIEWPORT_PIXMAP _
				=>
				{   msg = "kill_gui': running_gui.topwindw_pixmap should never be gt::VIEWPORT_PIXMAP!";
				    log::fatal msg;
				    raise exception FAIL msg;
				};
			esac;
		esac;

nb {. sprintf "kill_gui'/EEE: (%s): NOT YET recycling server-side resources associated with killed gui" (gt::backing_pixmap_id running_gui.topwindow_pixmap); };
# XXX BUGGO FIXME Need to recycle all server-side pixmaps associated with
# the running_gui just killed. 


	    };


# 		result = running_gui__to__paused_gui  running_gui;							# Return sufficient information to recreate the GUI.
# 
# 		# Clear state which is only valid while the gui is running:
# 		#
# # XXX SUCKO FIXME This stuff needs to change to support popups!!
# 
# # This needs to move into Backing_Pixmap/TOPWINDOW_PIXMAP
# #		topwindow_info.running_gui	    := NULL;
# 		topwindow_info.backing_pixmap	    := NULL;
# 
# # These two need to be nulled out only if we're shuttind down the base running_gui:
# 		#
# # These four need to go away (except maybe when shutting down the base running_gui)
# # in favor of one-by-one removals as we traverse the running_gui tree in
# #     running_gui__to__paused_gui
# #
# 		topwindow_info.bounce_imps	    := im::empty;
# 		topwindow_info.canvas_imps	    := im::empty;
# 		topwindow_info.packed_imps	    := im::empty;
# 		topwindow_info.gadget_imps	    := im::empty;
# 
# 		result:				gt::Paused_Gui;
# 	    }														#
# 	    where
# 		fun running_gui__to__paused_gui
# 		    # 
# 		    (running_gui: 	gt::Running_Gui)
# 		    :
# 		    ( gt::Packedspace_Arg,
# 		      gt::Sg_Packed_Widget
# 		    )
# 		    =
# 		    {
# 			running_gui ->    { fire_end_gun:		Void -> Void,					# Signal which will shut down the GUI impnet.
# 					    #
# 					    packedspace_id:		gt::Packedspace_Id,				# Runtime GUI state synthesized locally per client spec.
# 					    packed_widget:		gt::Rg_Packed_Widget,				# "                                       ".
# 					    topwindow:			gws::Guiboss_To_Topwindow,
# 					    topwindow_pixmap:		gt::Backing_Pixmap				# Holds toplevel gt::TOPWINDOW_PIXMAP for gui.
# 					  };
# 
# 			packed_widget''
# 			    =
# 			    do_packed_widget  packed_widget;
# 
# 			(im::get_or_raise_exception_not_found (*packed_imps, (id_to_int packedspace_id)))
# 			    ->
# 			    { widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot };	
# 
# 			( get_from_oneshot   endstate_oneshot,								# Read final state of packedspace-imp -- incidentally confirming that it has completed its shutdown.
# 			  packed_widget''
# 			);
# 		    }
# 
# 		also
# 		fun do_packed_widget  (packed_widget: gt::Rg_Packed_Widget)
# 		    =
# 		    case packed_widget
# 			#
# 			gt::RG_ROW  { widgets: List(  { widget:		gt::Rg_Packed_Widget,
# 							cooked_hints:	gt::Packed_Layout_Hints,
# 							raw_hints:	List(plh::Packedspace_Layout_Hint)
# 						      }
# 						   ),
# 				  pixels_high_min:	Ref(Int),
# 				  pixels_wide_min:	Ref(Int),
# 				  #
# 				  pixels_high_cut:	Ref(Float),
# 				  pixels_wide_cut:	Ref(Float),
# 				  #
# 				  site:			Ref(g2d::Box)
# 				}
# 			    =>
# 			    gt::SG_ROW (map  do_widget  widgets)
# 				    where
# 					fun do_widget (r: gt::Row_Widget)
# 					    =
# 					    ( r.raw_hints,
# 					      do_packed_widget  r.widget
# 					    );
# 				    end;	
# 
# 			gt::RG_COL  { widgets: List(  { widget:		gt::Rg_Packed_Widget,
# 							cooked_hints:	gt::Packed_Layout_Hints,
# 							raw_hints:	List(plh::Packedspace_Layout_Hint)
# 						      }
# 						   ),
# 				  pixels_high_min:	Ref(Int),
# 				  pixels_wide_min:	Ref(Int),
# 				  #
# 				  pixels_high_cut:	Ref(Float),
# 				  pixels_wide_cut:	Ref(Float),
# 				  #
# 				  site:			Ref(g2d::Box)
# 				}
# 			    =>
# 			    gt::SG_COL (map  do_widget  widgets)
# 				    where
# 					fun do_widget (r: gt::Col_Widget)
# 					    =
# 					    ( r.raw_hints,
# 					      do_packed_widget  r.widget
# 					    );
# 				    end;	
# 
# 			gt::RG_SCROLLABLE_VIEW
# 				{ widget:		gt::Rg_Packed_Widget,
# 
# # Should we delete packing_pixmap at this point?  If not, when does it get recycled? 			*** XXX QUERO FIXME ***
# 
# 				  gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,
# 				  view_origin:		Ref(g2d::Point),						# Origin of backing_pixmap in viewport coordinates, used for scrolling pixmap in viewport.
# 				  scroller:		gt::Viewport_Scroller,
# 				  callback:		gt::Viewport_Scroller_Callback,
# 				  backing_pixmap:	gt::Backing_Pixmap,						# 
# 				  site:			Ref(g2d::Box)
# 				}
# 			    =>
# 			    {	callback NULL;										# Tell app code that our viewport_scroller is no longer active.
# 				#
# 				widget      =  do_packed_widget  widget;
# 
# 				pixmap_size =  gadget_to_rw_pixmap.size;
# 				#
# 			        gt::SG_SCROLLABLE_VIEW (callback, pixmap_size, widget);
# 			    };
# 
# 			gt::RG_TABBED_VIEWS
# 				{ callback:		gt::Tabbed_View_Picker_Callback,
# 				  widgets:		List(gt::Tabview),
# 				  pixmap_size:		g2d::Size,
# 				  visible_widget:	Ref(  gt::Tabview ),
# #				  viewport:		Ref(g2d::Box),							# The actual site assigned to the viewport on its home pixmap.  This gets set by   assign_sites_to_all_widgets()   in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
# 				  site:			Ref(g2d::Box)
# 				}
# 			    =>
# 			    {   callback NULL;										# Tell app code that our tabbed_view_picker is no longer active.
# 				#
# 				gt::SG_TABBED_VIEWS (callback,  pixmap_size,  map  do_widget  widgets)
# 					where
# 					    fun do_widget { widget: 			gt::Rg_Packed_Widget,
# 							    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,	# Should we delete this at this point?  If not, when does it get recycled?
# 							    backing_pixmap:		gt::Backing_Pixmap		# 
# 							  }
# 
# 						=
# 						do_packed_widget  widget;
# 					end;
# 			    };
# 
# 			gt::RG_WIDGET r
# 			    =>
# 			    gt::SG_WIDGET (get_from_oneshot   r.endstate_oneshot);					# Read and return final state of widget-imp -- incidentally confirming that it has completed its shutdown.
# 
# 
# 			#
# 			gt::RG_CANVASSPACE  canvasspace
# 			    =>
# 			    do_canvasspace  canvasspace;
# 
# 			gt::RG_BOUNCESPACE  bouncespace
# 			    =>
# 			    do_bouncespace  bouncespace;
# 
# 			gt::RG_NULL_PACKED_WIDGET
# 			    =>
# 			    gt::SG_NULL_PACKED_WIDGET;
# 		    esac
# 
# 
# 		also
# 		fun do_bouncespace r
# 		    =
# 		    {
# 			widgets =  do_bounce_widgets  r.widgets;
# 			#
# 			(im::get_or_raise_exception_not_found (*bounce_imps, (id_to_int r.bouncespace_id)))
# 			    ->
# 			    { guiboss_to_bouncespace, sprite_to_bouncespace, endstate_oneshot };
# 
# 			arg =  get_from_oneshot  endstate_oneshot;
# 
# 		        gt::SG_BOUNCESPACE (arg, widgets);
# 		    }
# 
# 		also
# 		fun do_bounce_widgets (widgets':  List ((List(blh::Bouncespace_Layout_Hint), gt::Rg_Bounce_Widget)))
# 		    =
# 		    {
# 			widgets'' = map  do_widget  widgets'
# 				    where
# 					fun do_widget' (widget': gt::Rg_Bounce_Widget)
# 					    =
# 					    case widget'
# 						#
# 						gt::RG_SPRITE r
# 						    =>
# 						    gt::SG_SPRITE (get_from_oneshot   r.endstate_oneshot);		# Read and return final state of sprite-imp -- incidentally confirming that it has completed its shutdown.
# 					    esac;
# 					#
# 					fun do_widget (layout_hints:  List(blh::Bouncespace_Layout_Hint), widget': gt::Rg_Bounce_Widget)
# 					    =
# 					    {   widget'' = do_widget'  widget';
# 						#
# 						(layout_hints, widget'');
# 					    };
# 				    end;
# 
# 			widgets'';
# 		    }
# 
# 
# 		also
# 		fun do_canvasspace r
# 		    =
# 		    {	widgets =  do_canvas_widgets  r.widgets;
# 			#
# 			(im::get_or_raise_exception_not_found (*canvas_imps, (id_to_int r.canvasspace_id)))
# 			    ->
# 			    { guiboss_to_canvasspace, object_to_canvasspace, endstate_oneshot };
# 
# 			arg =  get_from_oneshot  endstate_oneshot;
# 
# 		        gt::SG_CANVASSPACE (arg, widgets);
# 		    }
# 
# 		also
# 		fun do_canvas_widgets (widgets':  List ((List(clh::Canvasspace_Layout_Hint), gt::Rg_Canvas_Widget)))
# 		    =
# 		    {
# 			widgets'' = map  do_widget  widgets'
# 				    where
# 					fun do_widget' (widget': gt::Rg_Canvas_Widget)
# 					    =
# 					    case widget'
# 						#
# 						gt::RG_OBJECT r
# 						    =>
# 						    gt::SG_OBJECT (get_from_oneshot   r.endstate_oneshot);		# Read and return final state of object-imp -- incidentally confirming that it has completed its shutdown.
# 
# 						gt::RG_PACKEDSPACE
# 						      { packedspace_id:		gt::Packedspace_Id,
# 							packed_widget:		gt::Rg_Packed_Widget
# 						      }
# 						    =>
# 						    {	packed_widget'' =  do_packed_widget packed_widget;
# 							#
# 							(im::get_or_raise_exception_not_found (*packed_imps, (id_to_int packedspace_id)))
# 							    ->
# 							    { widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot };
# 
# 							gt::SG_PACKEDSPACE
# 							  (
# 							    get_from_oneshot   endstate_oneshot,			# Read and return final state of packedspace-imp -- incidentally confirming that it has completed its shutdown.
# 							    packed_widget''
# 							  );
# 						    };
# 					    esac;
# 					#
# 					fun do_widget (layout_hints:  List(clh::Canvasspace_Layout_Hint), widget': gt::Rg_Canvas_Widget)
# 					    =
# 					    {   widget'' = do_widget'  widget';
# 						#
# 						(layout_hints, widget'');
# 					    };
# 				    end;
# 
# 			widgets'';
# 		    };													# fun do_canvas_widgets
# 	    end;


	#
	fun pause_gui'
	      (
		{ me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		  guiboss_arg:			Guiboss_Arg,
		  imports:			Imports,								# Imps to which we send requests.
		  to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		  end_gun':			End_Gun,
		  id:				Id
		}:				Runstate,
		( running_gui:			gt::Running_Gui,
		  bounce_imps:			Bounce_Imps,
		  canvas_imps:			Canvas_Imps,
		  packed_imps:			Packed_Imps,
		  gadget_imps:			Gadget_Imps,
		  topwindow_info:		Topwindow_Info
		)
	      )
	    =
	    {	running_gui.fire_end_gun ();										# Shut down GUI impnet.
		#
		result = running_gui__to__paused_gui  running_gui;							# Return sufficient information to recreate the GUI.

		# Clear state which is only valid while a toplevel gui is running:
		#
		case running_gui.topwindow_pixmap
		    #
		    gt::TOPWINDOW_PIXMAP r
			=>												# running_gui is from
			{   case r.parent
				#
				NULL  =>    {   topwindow_info.backing_pixmap	    :=  NULL;				# We're pausing the toplevel gui for this topwindow so remember that we no longer have a gui running on this topwindow.
						#
						topwindow_info.bounce_imps	    :=  im::empty;			# We also have no more GUI imps running on this topwindow...
						topwindow_info.canvas_imps	    :=  im::empty;
						topwindow_info.packed_imps	    :=  im::empty;
						topwindow_info.gadget_imps	    :=  im::empty;
					    };

				THE _ =>    ();										# We're pausing a secondary popup gui for this topwindow.
			    esac;
			};

		    gt::VIEWPORT_PIXMAP _
			=>
			{   msg = "topwindow_pixmap should not be VIEWPORT_PIXMAP! -- restart_gui'";
			    log::fatal msg;
			    raise exception FAIL msg;
			};
		esac;

		result:				gt::Paused_Gui;
	    }														#
	    where
		fun running_gui__to__paused_gui
		    # 
		    (running_gui: 	gt::Running_Gui)
		    :
		    ( gt::Packedspace_Arg,
		      gt::Sg_Packed_Widget
		    )
		    =
		    {
			running_gui ->    { fire_end_gun:		Void -> Void,					# Signal which will shut down the GUI impnet.
					    #
					    packedspace_id:		gt::Packedspace_Id,				# Runtime GUI state synthesized locally per client spec.
					    packed_widget:		gt::Rg_Packed_Widget,				# "                                       ".
					    topwindow:			gws::Guiboss_To_Topwindow,
					    topwindow_pixmap:		gt::Backing_Pixmap				# Holds toplevel gt::TOPWINDOW_PIXMAP for gui.
					  };

			packed_widget''
			    =
			    do_packed_widget  packed_widget;

			(im::get_or_raise_exception_not_found (*packed_imps, (id_to_int packedspace_id)))
			    ->
			    { widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot };	

			( get_from_oneshot   endstate_oneshot,								# Read final state of packedspace-imp -- incidentally confirming that it has completed its shutdown.
			  packed_widget''
			);
		    }

		also
		fun do_packed_widget  (packed_widget: gt::Rg_Packed_Widget)
		    =
		    case packed_widget
			#
			gt::RG_ROW  { widgets: List(  { widget:		gt::Rg_Packed_Widget,
							cooked_hints:	gt::Packed_Layout_Hints,
							raw_hints:	List(plh::Packedspace_Layout_Hint)
						      }
						   ),
				  pixels_high_min:	Ref(Int),
				  pixels_wide_min:	Ref(Int),
				  #
				  pixels_high_cut:	Ref(Float),
				  pixels_wide_cut:	Ref(Float),
				  #
				  site:			Ref(g2d::Box)
				}
			    =>
			    gt::SG_ROW (map  do_widget  widgets)
				    where
					fun do_widget (r: gt::Row_Widget)
					    =
					    ( r.raw_hints,
					      do_packed_widget  r.widget
					    );
				    end;	

			gt::RG_COL  { widgets: List(  { widget:		gt::Rg_Packed_Widget,
							cooked_hints:	gt::Packed_Layout_Hints,
							raw_hints:	List(plh::Packedspace_Layout_Hint)
						      }
						   ),
				  pixels_high_min:	Ref(Int),
				  pixels_wide_min:	Ref(Int),
				  #
				  pixels_high_cut:	Ref(Float),
				  pixels_wide_cut:	Ref(Float),
				  #
				  site:			Ref(g2d::Box)
				}
			    =>
			    gt::SG_COL (map  do_widget  widgets)
				    where
					fun do_widget (r: gt::Col_Widget)
					    =
					    ( r.raw_hints,
					      do_packed_widget  r.widget
					    );
				    end;	

			gt::RG_SCROLLABLE_VIEW
				{ widget:		gt::Rg_Packed_Widget,

# Should we delete packing_pixmap at this point?  If not, when does it get recycled? 			*** XXX QUERO FIXME ***

				  gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,
				  view_origin:		Ref(g2d::Point),						# Origin of backing_pixmap in viewport coordinates, used for scrolling pixmap in viewport.
				  scroller:		gt::Viewport_Scroller,
				  callback:		gt::Viewport_Scroller_Callback,
				  backing_pixmap:	gt::Backing_Pixmap,						# 
				  site:			Ref(g2d::Box)
				}
			    =>
			    {	callback NULL;										# Tell app code that our viewport_scroller is no longer active.
				#
				widget      =  do_packed_widget  widget;

				pixmap_size =  gadget_to_rw_pixmap.size;
				#
			        gt::SG_SCROLLABLE_VIEW (callback, pixmap_size, widget);
			    };

			gt::RG_TABBED_VIEWS
				{ callback:		gt::Tabbed_View_Picker_Callback,
				  widgets:		List(gt::Tabview),
				  pixmap_size:		g2d::Size,
				  visible_widget:	Ref(  gt::Tabview ),
#				  viewport:		Ref(g2d::Box),							# The actual site assigned to the viewport on its home pixmap.  This gets set by   assign_sites_to_all_widgets()   in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				  site:			Ref(g2d::Box)
				}
			    =>
			    {   callback NULL;										# Tell app code that our tabbed_view_picker is no longer active.
				#
				gt::SG_TABBED_VIEWS (callback,  pixmap_size,  map  do_widget  widgets)
					where
					    fun do_widget { widget: 			gt::Rg_Packed_Widget,
							    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,	# Should we delete this at this point?  If not, when does it get recycled?
							    backing_pixmap:		gt::Backing_Pixmap		# 
							  }

						=
						do_packed_widget  widget;
					end;
			    };

			gt::RG_WIDGET r
			    =>
			    gt::SG_WIDGET (get_from_oneshot   r.endstate_oneshot);					# Read and return final state of widget-imp -- incidentally confirming that it has completed its shutdown.


			#
			gt::RG_CANVASSPACE  canvasspace
			    =>
			    do_canvasspace  canvasspace;

			gt::RG_BOUNCESPACE  bouncespace
			    =>
			    do_bouncespace  bouncespace;

			gt::RG_NULL_PACKED_WIDGET
			    =>
			    gt::SG_NULL_PACKED_WIDGET;
		    esac


		also
		fun do_bouncespace r
		    =
		    {
			widgets =  do_bounce_widgets  r.widgets;
			#
			(im::get_or_raise_exception_not_found (*bounce_imps, (id_to_int r.bouncespace_id)))
			    ->
			    { guiboss_to_bouncespace, sprite_to_bouncespace, endstate_oneshot };

			arg =  get_from_oneshot  endstate_oneshot;

		        gt::SG_BOUNCESPACE (arg, widgets);
		    }

		also
		fun do_bounce_widgets (widgets':  List ((List(blh::Bouncespace_Layout_Hint), gt::Rg_Bounce_Widget)))
		    =
		    {
			widgets'' = map  do_widget  widgets'
				    where
					fun do_widget' (widget': gt::Rg_Bounce_Widget)
					    =
					    case widget'
						#
						gt::RG_SPRITE r
						    =>
						    gt::SG_SPRITE (get_from_oneshot   r.endstate_oneshot);		# Read and return final state of sprite-imp -- incidentally confirming that it has completed its shutdown.
					    esac;
					#
					fun do_widget (layout_hints:  List(blh::Bouncespace_Layout_Hint), widget': gt::Rg_Bounce_Widget)
					    =
					    {   widget'' = do_widget'  widget';
						#
						(layout_hints, widget'');
					    };
				    end;

			widgets'';
		    }


		also
		fun do_canvasspace r
		    =
		    {	widgets =  do_canvas_widgets  r.widgets;
			#
			(im::get_or_raise_exception_not_found (*canvas_imps, (id_to_int r.canvasspace_id)))
			    ->
			    { guiboss_to_canvasspace, object_to_canvasspace, endstate_oneshot };

			arg =  get_from_oneshot  endstate_oneshot;

		        gt::SG_CANVASSPACE (arg, widgets);
		    }

		also
		fun do_canvas_widgets (widgets':  List ((List(clh::Canvasspace_Layout_Hint), gt::Rg_Canvas_Widget)))
		    =
		    {
			widgets'' = map  do_widget  widgets'
				    where
					fun do_widget' (widget': gt::Rg_Canvas_Widget)
					    =
					    case widget'
						#
						gt::RG_OBJECT r
						    =>
						    gt::SG_OBJECT (get_from_oneshot   r.endstate_oneshot);		# Read and return final state of object-imp -- incidentally confirming that it has completed its shutdown.

						gt::RG_PACKEDSPACE
						      { packedspace_id:		gt::Packedspace_Id,
							packed_widget:		gt::Rg_Packed_Widget
						      }
						    =>
						    {	packed_widget'' =  do_packed_widget packed_widget;
							#
							(im::get_or_raise_exception_not_found (*packed_imps, (id_to_int packedspace_id)))
							    ->
							    { widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot };

							gt::SG_PACKEDSPACE
							  (
							    get_from_oneshot   endstate_oneshot,			# Read and return final state of packedspace-imp -- incidentally confirming that it has completed its shutdown.
							    packed_widget''
							  );
						    };
					    esac;
					#
					fun do_widget (layout_hints:  List(clh::Canvasspace_Layout_Hint), widget': gt::Rg_Canvas_Widget)
					    =
					    {   widget'' = do_widget'  widget';
						#
						(layout_hints, widget'');
					    };
				    end;

			widgets'';
		    };													# fun do_canvas_widgets
	    end;


	fun make_base_backing_pixmap (pixmap: g2p::Gadget_To_Rw_Pixmap): gt::Backing_Pixmap				# Make the base Backing_Pixmap instance for a GUI. (There will be an additional Backing_Pixmap for each viewport and active popup in the gui.)
	    =
	    gt::TOPWINDOW_PIXMAP
	      {
		running_gui	=> REF NULL,
		pixmap,													# Main backing pixmap for this running gui.
		pixmaps		=>   REF im::empty,									# All other X-server side pixmaps created by/for this running gui.  (We need this to reliably recycle them when we kill the gui -- otherwise we'll be leaking X server memory.)
		popups		=>   REF ([]: List( gt::Backing_Pixmap)),
		parent		=>   NULL: Null_Or( gt::Backing_Pixmap ),
		origin		=>   REF { row => 0, col => 0 },
		#
		stacking_order => 1
	      };

	fun make_backing_pixmap_for_popup										# Create a g2p::Gadget_To_Rw_Pixmap instance, wrap it in a gt::TOPWINDOW_PIXMAP, and enter the latter into the tree of TOPWINDOW_PIXMAP.
	      (
		make_rw_pixmap:			g2d::Size -> g2p::Gadget_To_Rw_Pixmap,
		next_stacking_order: 		Ref(Int),
		parent:				gt::Backing_Pixmap,
		site:				g2d::Box
	      )	
	    =
	    {   p = case parent     gt::TOPWINDOW_PIXMAP p =>  p;
				    gt::VIEWPORT_PIXMAP _  =>  {   msg = "make_backing_pixmap_for_popup: parent == gt::VIEWPORT unsupported. -- guiboss-imp.pkg";
								    log::fatal msg;
								    raise exception FAIL msg;
								};
		    esac;
 

		(g2d::box::upperleft_and_size site)
		    ->
		    (origin as { row, col }, size as { high, wide }); 
# nb {. sprintf "make_backing_pixmap_for_popup/CCC origin s=%s size = %s-- guiboss-imp.pkg" (g2j::point_to_string origin) (g2j::size_to_string size); };

		parent_size = p.pixmap.size;

		my (origin, size)											# Select actual site for popup.  We need it to fit entirely within parent.
		    =
		    {   row = max (row, 0);										# Let's start by ensuring that popup origin is not left of or above origin of parent coordinate system..
# nb {. sprintf "make_backing_pixmap_for_popup/DDD row d=%d  -- guiboss-imp.pkg" row; };
			col = max (col, 0);										#
# nb {. sprintf "make_backing_pixmap_for_popup/EEE col d=%d  -- guiboss-imp.pkg" col; };

			high = max (high, 1);										# Next let's make sure the requested size is positive...
# nb {. sprintf "make_backing_pixmap_for_popup/FFF high d=%d  -- guiboss-imp.pkg" high; };
			wide = max (wide, 1);										#
# nb {. sprintf "make_backing_pixmap_for_popup/GGG wide d=%d  -- guiboss-imp.pkg" wide; };

			high = min (high, parent_size.high);								# Now let's ensure that popup can in fact fit within parent.
# nb {. sprintf "make_backing_pixmap_for_popup/HHH high d=%d  -- guiboss-imp.pkg" high; };
			wide = min (wide, parent_size.wide);								# 
# nb {. sprintf "make_backing_pixmap_for_popup/III wide d=%d  -- guiboss-imp.pkg" wide; };

			row  = min (row, parent_size.high - high);							# Now slide the popup left and/or up as necessary to make it actually fit within parent.
# nb {. sprintf "make_backing_pixmap_for_popup/JJJ row d=%d   parent_size.high - high d=%d -- guiboss-imp.pkg" high (parent_size.high - high); };
			col  = min (col, parent_size.wide - wide);							#
# nb {. sprintf "make_backing_pixmap_for_popup/KKK col d=%d   parent_size.wide - wide d=%d -- guiboss-imp.pkg" wide (parent_size.wide - wide); };

			({ row, col },  { high, wide });								# That should do it!
		    };

# nb {. sprintf "make_backing_pixmap_for_popup/MMM origin s=%s size = %s-- guiboss-imp.pkg" (g2j::point_to_string origin) (g2j::size_to_string size); };
		pixmap =  make_rw_pixmap  size;										# We're blocking for a round-trip here, which is not great.  We probably should implement imports.guiboss_to_windowsystem.pass_fresh_rw_pixmap to allow this to be nonblocking. XXX SUCKO FIXME

		stacking_order = *next_stacking_order;
		#
		next_stacking_order := stacking_order + 1;

		new_backing_pixmap
		    =
		    gt::TOPWINDOW_PIXMAP
		      {
			running_gui	=> REF NULL,
			pixmap,												# Main backing store for this running gui.
			pixmaps		=>   REF im::empty,								# All other X-server side pixmaps created by/for this running gui.  (We need this to reliably recycle them when we kill the gui -- otherwise we'll be leaking X server memory.)
			popups		=>   REF ([]: List( gt::Backing_Pixmap)),
			parent		=>   THE parent,
			origin		=>   REF origin,
			#
			stacking_order
		      };

		p.popups :=  new_backing_pixmap ! *p.popups;								# Remember that parent Backing_Pixmap has a new child Backing_Pixmap.

		site = g2d::box::make (origin, size);

		(site, new_backing_pixmap);
	    };


	#
	fun restart_gui'
	      (
		runstate as
		  { me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		    guiboss_arg:		Guiboss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# We shut down the microthread when this fires.
		    id:				Id
		  }:				Runstate,
	
		topwindow_for_gui:		gws::Guiboss_To_Topwindow,
# SHOULD PROBABLY RENAME THIS TO base_pixmap or such, since it may be for a popup rather than the real base.
		topwindow_pixmap:		gt::Backing_Pixmap,
		paused_gui:			gt::Paused_Gui,

		gui_startup_complete':		Oneshot_Maildrop( gt::Client_To_Guiwindow ),
		guiboss_q:			Guiboss_Q,
		pause_gui:			(gt::Running_Gui, Bounce_Imps, Canvas_Imps, Packed_Imps, Gadget_Imps, Topwindow_Info) -> gt::Paused_Gui,
		kill_gui:			(gt::Running_Gui, Bounce_Imps, Canvas_Imps, Packed_Imps, Gadget_Imps, Topwindow_Info) -> Void
	      )
	    =
	    {
		case topwindow_pixmap
		    #
		    gt::TOPWINDOW_PIXMAP r
			=>												# running_gui is from
			{   r.running_gui := THE running_gui;								#      running_gui = paused_gui__to__running_gui  paused_gui;
			    #												# in below 'where' clause. so as to be available in make_popup().)
			    case r.parent
				#
				NULL  =>    topwindow_info.backing_pixmap :=  THE topwindow_pixmap;			# We're starting a toplevel gui for this topwindow so remember that we now have a gui running on this topwindow.
				THE _ =>    ();										# We're starting a secondary popup gui for this topwindow.
			    esac;
			};

		    gt::VIEWPORT_PIXMAP _
			=>
			{   msg = "topwindow_pixmap should not be VIEWPORT_PIXMAP! -- restart_gui'";
			    log::fatal msg;
			    raise exception FAIL msg;
			};
		esac;

		fire_run_gun ();

# if we_are_a_popup_gui   nb {. sprintf "popup: restart_gui'/MMM -- guiboss-imp.pkg"; }; fi;
		topwindow_for_gui.pass_window_site to
		    #
		    (\\ ({ size => { high => topwindow_high, wide => topwindow_wide }, ... }: g2d::Window_Site)		# topwindow_high and topwindow_wide are currently unused, but you'd think we'd need them eventually.
			=
			{
# if we_are_a_popup_gui   nb {. sprintf "popup: restart_gui'/NNN -- guiboss-imp.pkg"; }; fi;
			    my (high, wide)
				=
				case topwindow_pixmap
				    #
				    gt::TOPWINDOW_PIXMAP r
					=>
					{   r.pixmap.size -> { high, wide };
					    (high, wide);
					};

				    gt::VIEWPORT_PIXMAP r
					=>
					{   msg = "topwindow_pixmap may not be a VIEWPORT_PIXMAP -- restart_gui' in guiboss-imp.pkg";
					    log::fatal msg;
					    raise exception FAIL msg;
					};
				esac;

			    (im::get_or_raise_exception_not_found (*packed_imps, (id_to_int running_gui.packedspace_id)))
				->
				{ widget_to_packedspace, guiboss_to_packedspace as gt::GUIBOSS_TO_PACKEDSPACE ps, endstate_oneshot };


			    site =  { col => 0,  high,									# Allocate all of window pixel area to widgets in running_gui.packed_widget widget-tree.
				      row => 0,  wide
				    }
				    : g2d::Box;

# if we_are_a_popup_gui   nb {. sprintf "popup: restart_gui'/OOO site = %s -- guiboss-imp.pkg" (g2j::box_to_string site); }; fi;
			    ps.pass_re_siting_done_flag
				( site,
				  running_gui.topwindow_pixmap,
				  running_gui.packed_widget
				)
				to
				{.
# if we_are_a_popup_gui   nb {. sprintf "popup: restart_gui'/PPP -- guiboss-imp.pkg"; }; fi;
				    gt::running_gui_postorder_apply							# If a view pixmap is too small to fill its viewport there will be undefined pixels showing in the viewport.
				      (											# By setting the origin to its default 0,0 we trigger the logic to black out these undefined areas.
					running_gui,									# Does doing result in a double-draw of views at GUI startup?  If so, that might someday prove problematic: XXX QUERO FIXME
					[ gt::SCROLLABLE_VIEW_FN
					    {.
						(#scrollable_view).scroller.set_viewport_origin
						    { row => 0, col => 0 };
					    }
					]
				      );

# if we_are_a_popup_gui   nb {. sprintf "popup: restart_gui'/QQQ -- guiboss-imp.pkg"; }; fi;
				    client_to_guiwindow
				      =
				      { id		=>  issue_unique_id (),
					pause_gui	=>  {. pause_gui (running_gui, bounce_imps, canvas_imps, packed_imps, gadget_imps, topwindow_info); },
					kill_gui	=>  {.  kill_gui (running_gui, bounce_imps, canvas_imps, packed_imps, gadget_imps, topwindow_info); }
				      }
				      : gt::Client_To_Guiwindow
				      ;
nb {. sprintf "popup: restart_gui'/RRR -- client_to_guiwindow.id=%d running_gui.topwindow_pixmap=%s, pprints so:" (id_to_int client_to_guiwindow.id) (gt::backing_pixmap_id running_gui.topwindow_pixmap); };
gt::pprint_backing_pixmap (running_gui.topwindow_pixmap);

# if we_are_a_popup_gui   nb {. sprintf "popup: restart_gui'/ZZZ -- guiboss-imp.pkg"; }; fi;
				    put_in_oneshot (gui_startup_complete', client_to_guiwindow);
				}; 

			}
		    );
	    }
	    where
nb {. sprintf "restart_gui'/AAA: (%s): , now printing out topwindow_pixmap" (gt::backing_pixmap_id topwindow_pixmap); };
gt::pprint_backing_pixmap (topwindow_pixmap);
		we_are_a_popup_gui
		    =
		    case topwindow_pixmap
			#
			gt::TOPWINDOW_PIXMAP r
			    =>
			    {   case r.parent
				    #
				    NULL  =>    FALSE;									# We're starting up the primary (toplevel) gui  for this topwindow.
				    THE _ =>    TRUE;									# We're starting a secondary popup gui for this topwindow.
				esac;
			    };
			gt::VIEWPORT_PIXMAP _
			    =>
			    {   msg = "topwindow_pixmap should not be VIEWPORT_PIXMAP! -- restart_gui'";
				log::fatal msg;
				raise exception FAIL msg;
			    };
		    esac;

		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

# if we_are_a_popup_gui   nb {. sprintf "popup: restart_gui'/AAA -- guiboss-imp.pkg"; }; fi;
		topwindow_info = im::get_or_raise_exception_not_found (*me.topwindows, id_to_int topwindow_for_gui.id)
				 except
				     NOT_FOUND = {   printf                "*me.topwindows contains no entry for topwindow %d?!   -- restart_gui' in guiboss-imp.pkg\n" (id_to_int topwindow_for_gui.id);
						     log::fatal (sprintf "*me.topwindows contains no entry for topwindow %d?!   -- restart_gui' in guiboss-imp.pkg" (id_to_int topwindow_for_gui.id));
						     raise exception NOT_FOUND;						# Execution will never reach this point, but the compiler doesn't know that log::fatal doesn't return.
						 };
# if we_are_a_popup_gui   nb {. sprintf "popup: restart_gui'/BBB -- guiboss-imp.pkg"; }; fi;
		bounce_imps			=  topwindow_info.bounce_imps;						# Holds our gt::Guiboss_To_Bouncespace instances -- can't put them directly in Running_Gui due to circularity.
		canvas_imps			=  topwindow_info.canvas_imps;						# Holds our gt::Guiboss_To_Canvasspace instances -- can't put them directly in Running_Gui due to circularity.
		packed_imps			=  topwindow_info.packed_imps;						# Holds our gt::Guiboss_To_Packedspace instances -- can't put them directly in Running_Gui due to circularity.
		gadget_imps			=  topwindow_info.gadget_imps;						# Holds look-imps for all the widgets in our gui.

		current_frame_number		=  topwindow_info.current_frame_number;
		seconds_per_frame		=  topwindow_info.seconds_per_frame;

		mouse_is			=  topwindow_info.mouse_is;						# Support for mouse drag operations.

		done_extra_startframe_this_frame=  topwindow_info.done_extra_startframe_this_frame;

		# We expect the following fns to capture the above values:
		# that is why we define them here rather than more globally.

		#
		fun get_gadget_info
		      (
			gadget_imps:	Gadget_Imps,
			id:		iul::Id
		      )
		    =
		    case (im::get (*gadget_imps,  iul::id_to_int id))
			#
			THE gadget_info =>    gadget_info;

			NULL =>     {   msg = sprintf "imp %d not found in gadget_imps?! -- get_gadget_info in guiboss-imp.pkg" (iul::id_to_int id);	# Should be impossible -- all widgets, sprites and objects should be in gadget_imps.
					log::note_on_stderr {. msg; };
					raise exception FAIL msg;
				    };
		    esac;



		fun gadget_may_need_redraw (i: Gadget_Info)
		    =
		    {
			i.may_have_visibly_changed :=  TRUE;
		    };

		#################################################################################
		# space_to_gui interface fns:

		#
		fun note_widget_site
		      {
			id:		iul::Id,
			backing_pixmap: gt::Backing_Pixmap,
			site:		g2d::Box
		      }													# PUBLIC.
		    =	
		    # This fn is called by
		    #
		    #   src/lib/x-kit/widget/space/bounce/bouncespace-imp.pkg
		    #   src/lib/x-kit/widget/space/canvas/canvasspace-imp.pkg
		    #   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg  
		    #
		    # when they assign a widget a new site in response to our call
		    #
		    #     guiboss_to_packedspace.pass_re_siting_done_flag
		    #
		    put_in_mailqueue  (guiboss_q,
			#
			\\ ({ me, ... }: Runstate)
			    =
			    {   i = get_gadget_info (gadget_imps, id);
				#
				if (site != *i.site									# Has the window site of this widget changed?
				or   (not (same_id ( gt::backing_pixmap_id_of    backing_pixmap,
						     gt::backing_pixmap_id_of *i.backing_pixmap
				    ) )   )        )
				    #											# Yes.
				    i.site :=  site;									# Note site for widget.

				    i.backing_pixmap :=  backing_pixmap;						# Note pixmap for widget.

				    gadget_may_need_redraw i;
				fi;
			    }
		    );

		space_to_gui =	      { id => topwindow_for_gui.id,							# Since each topwindow has a unique id and we will have only one space_to_gui per topwindow, using topwindow_for_gui.id
					#										# here ensures a unique id per space_to_gui. It also makes space_to_gui.id stable across gui stop/restart cycles.
					note_widget_site
				      };


		#################################################################################
		# gadget_to_guiboss interface fns:
		#
		fun gadget_may_have_visibly_changed									# PUBLIC.
		      (
			id:		iul::Id
		      )
		    =	
		    # The point of this call is to alert us that the
		    # GUI display needs refreshing.
		    # If no widget calls this, we can stop the frame-
		    # redisplay cycle to conserve CPU cycles:
		    #
		    {   put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{
				    i = get_gadget_info (gadget_imps, id);
				    #
				    gadget_may_need_redraw i;

# Actually, I don't think this is a good idea,
# I just want to do this on mouseclick and keypress.
#
#				    if (not *done_extra_startframe_this_frame)
#					#
#					# Send a startframe to the gadget:
#
#					i -> { guiboss_to_gadget, site, gadget_mode, may_have_visibly_changed, ... };
#
#					guiboss_to_gadget.start_of_frame  { frame_number => *current_frame_number,
#									    site	 => *site,
#									    visible	 	=> TRUE,
#									    duration_in_seconds => 0.0,
#									    this_gadget_mode => *gadget_mode,
#									    theme => imports.theme
#									  };
#				    fi;
				}
		        );
		    };

		fun draw_gadget (clip_box, gui_displaylist, gadget_info: Gadget_Info)
		    =
		    {
# nb {. sprintf "draw_gadget setting clipping box -- guiboss-imp.pkg"; };
			gui_displaylist = [ gd::CLIP_TO (clip_box, gui_displaylist) ];					# Clip gadget's displaylist to its assigned site so it won't traspass on neighboring gadgets if it gets sloppy.
			#
			gadget_to_rw_pixmap =  gt::gadget_to_rw_pixmap__of  *gadget_info.backing_pixmap;		# Find gadget's assigned off-screen backing pixmap.

			gadget_to_rw_pixmap.draw_displaylist  gui_displaylist;						# Draw updated gadget appearance into its off-screen backing-pixmap home site.

															# Now to update on-screen image of gadget (if it is visible).
															#
															# We'll update the gadget on the visible window by doing a rectangular blit
															# from offscreen backing pixmap to on-screen pixel refresh buffer.
															#
															# Just redrawing gui_displaylist a second time would be another strategy.
															# The blit has the advantage that the worst case is pretty fast, whereas
															# the worst case for redrawing gui_displaylist can be arbitrarily slow.
															#
															# Also, draw-offscreen-and-blit completely eliminates redraw flicker
															# where "flicker" == partly-redrawn widget being visible momentarily:
															# it is essentially a primitive form of double-buffering.

			from_box =  *gadget_info.site;									# Where should we copy pixels from, on gadget's home pixmap?  We initialize this to the full site for the gadget; later it may get clipped by viewports.
			pixmap	 =  *gadget_info.backing_pixmap;							
			#		
# nb {. sprintf "draw_gadget calling update_offscreen_parent_pixmaps_and_then_topwindow -- guiboss-imp.pkg"; };
			update_offscreen_parent_pixmaps_and_then_topwindow  (pixmap, from_box, topwindow_for_gui);
		    };

		#
		fun update_gadget_appearance										# Update gadget appearance in response to a guiboss_to_gadget.start_of_frame {...} call.
		      {
			id:			iul::Id,
			displaylist:		gd::Gui_Displaylist,
			point_in_gadget:	Null_Or( g2d::Point -> Bool )						# Optional function deciding if (e.g.) a mouseclick location is within the gadget. This allows more geometric accuracy than a simple bounding box or such.
		      }
		    =
		    # The point of this call is to update the appearance
		    # of the gadget.  This call is normally made in response
		    # to  guiboss_to_gadget.start_of_frame {}								# guiboss_to_gadget	is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg
		    #
		    {
# nb {. sprintf "update_gadget_appearance called id=%d -- guiboss-imp.pkg" (iul::id_to_int id); };
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{
				    i = get_gadget_info (gadget_imps, id);
# nb {. sprintf "update_gadget_appearance (id=%d) pprinting gadget info -- guiboss-imp.pkg" (iul::id_to_int id); };
# pprint_gadget_info i;
# nb {. sprintf "update_gadget_appearance (id=%d) pprinting all gadget info -- guiboss-imp.pkg" (iul::id_to_int id); };
# apply pprint_it (im::keyvals_list *gadget_imps)
# where
#     fun pprint_it (i, gadget_info)
# 	=
# 	{
# 	    pprint_gadget_info gadget_info;
# 	};
# end; 

				    #
				    i.point_in_gadget := point_in_gadget; 
				    #
# nb {. sprintf "update_gadget_appearance (id=%d) calling draw_gadget -- guiboss-imp.pkg" (iul::id_to_int id); };
				    draw_gadget (*i.site, displaylist, i);
				}
		        );
		    };



		#
		fun note_changed_gadget_activity									# PUBLIC.
		      {
			id:		iul::Id,
			is_active:	Bool
		      }
		    =	
		    # The point of this call is to mark gadget as not
		    # eligible for user input.  It will often be drawn grayed-out.
		    #
		    {   put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{
				    i = get_gadget_info (gadget_imps, id);
				    #
				  (*i.gadget_mode) -> { is_active => _, has_mouse_focus, has_keyboard_focus, mousebutton_is_down };
				    i.gadget_mode  := { is_active,      has_mouse_focus, has_keyboard_focus, mousebutton_is_down };
				}
		        );
		    };


		gadget_to_guiboss =     gt::GADGET_TO_GUIBOSS
					  { id => topwindow_for_gui.id,			# Since each topwindow has a unique id and we will have only one gadget_to_guiboss per topwindow, using topwindow_for_gui.id
					    #						# here ensures a unique id per gadget_to_guiboss. It also makes gadget_to_guiboss.id stable across gui stop/restart cycles.
					    gadget_may_have_visibly_changed,
					    #
					    update_gadget_appearance,
					    note_changed_gadget_activity
					  };	






		#################################################################################
		# frameclock microthread -- wakes us up 10 times/sec to draw a frame.
		#

		#
		fun digest_packedspace_layout_hints  (options: List(plh::Packedspace_Layout_Hint))  { cut, min }
		    =
		    {   my_cut =  REF cut;
		  	my_min =  REF min;
			#
			apply  do_option  options
			where
			    fun do_option (plh::WIDGET_PIXELS_CUT f) =>   if (f >= 0.0)   my_cut := THE f;   fi;	# We ignore negative values because they make no sense. Maybe should raise an exception.
				do_option (plh::WIDGET_PIXELS_MIN i) =>   if (i >=   0)   my_min := THE i;   fi;	# We ignore negative values because they make no sense. Maybe should raise an exception.
			    end;
			end;

			{ cut =>  *my_cut,
			  min =>  *my_min
			};
		    };

		#


		#
		fun paused_gui__to__running_gui
		    (
		      ( packedspace_arg:	gt::Packedspace_Arg,
		        packed_widget:		gt::Sg_Packed_Widget
		      )
		    )
		    : gt::Running_Gui
		    =
		    {
			(do_packedspace  packedspace_arg)
			    ->
			    stuff as { widget_to_packedspace, guiboss_to_packedspace as gt::GUIBOSS_TO_PACKEDSPACE ps, endstate_oneshot };

			packedspace_id   =  ps.id;

# XXX SUCKO FIXME We need a counterpart of this at running_gui shutdown time.
			packed_imps     :=  im::set (*packed_imps, (id_to_int packedspace_id), stuff);

			(do_packed_widget (packed_widget, widget_to_packedspace, topwindow_pixmap))
			    ->
			    packed_widget;

			{ fire_end_gun,
			  packedspace_id,
			  packed_widget,
			  topwindow_pixmap,
			  topwindow	      =>  topwindow_for_gui
			};
		    }
		    where
			fun make_gadget_info
			      (
				guiboss_to_gadget:	gt::Guiboss_To_Gadget,
				backing_pixmap:		gt::Backing_Pixmap
			      )
			      =
			      {
				guiboss_to_gadget,
				backing_pixmap		    =>  REF backing_pixmap,
				#
				may_have_visibly_changed    =>	REF FALSE,								# We do not want to draw until we've sent before_first_frame to gadget.
				sent__before_first_frame    =>  REF FALSE,
				#
				gadget_mode		    =>  REF { is_active => TRUE,  has_mouse_focus => FALSE,  has_keyboard_focus => FALSE, mousebutton_is_down => FALSE },
				site			    =>  REF g2d::box::zero,
				#
				point_in_gadget		    =>  REF (NULL:  Null_Or( g2d::Point -> Bool ))				# Optional fn to decide if a mouseclick actually hit the gadget itself, or just somewhere near it.
			      };
			#
			fun do_packedspace  (packedspace_arg: gt::Packedspace_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Packedspace_Arg  );		# When endgun fires we'll read back final packedspace_imp state via this oneshot.
				#
				packedspace_egg
				    =
				    pai::make_packedspace_egg  packedspace_arg  (THE endstate_oneshot);

				(packedspace_egg ())
				    ->
				    (exports, packedspace_egg');

				exports ->  { widget_to_packedspace, guiboss_to_packedspace as gt::GUIBOSS_TO_PACKEDSPACE ps };

# XXX SUCKO FIXME We need a counterpart of this at running_gui shutdown time.
				packed_imps :=  im::set (*packed_imps, (id_to_int ps.id), { widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot });

# NOT VERY SOON add gadget_to_guiboss to imports:
				packedspace_imports =  { int_sink => \\ (i: Int) = (), space_to_gui };

				packedspace_egg' (packedspace_imports, run_gun', end_gun');

				{ widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot };
			    }

			also
			fun do_bouncespace  (bouncespace_arg: gt::Bouncespace_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Bouncespace_Arg  );		# When endgun fires we'll read back final bouncespace_imp state via this oneshot.
				#
				bouncespace_egg
				    =
				    boi::make_bouncespace_egg  bouncespace_arg  (THE endstate_oneshot);

				(bouncespace_egg ())
				    ->
				    (exports, bouncespace_egg');

				exports -> { guiboss_to_bouncespace as gt::GUIBOSS_TO_BOUNCESPACE os, sprite_to_bouncespace };

# XXX SUCKO FIXME We need a counterpart of this at running_gui shutdown time.
				bounce_imps :=  im::set (*bounce_imps,  id_to_int os.id,  { guiboss_to_bouncespace, sprite_to_bouncespace, endstate_oneshot });

# NOT VERY SOON add gadget_to_guiboss to imports:
				bouncespace_imports =  { int_sink => \\ (i: Int) = () };

				bouncespace_egg' (bouncespace_imports, run_gun', end_gun');

				{ guiboss_to_bouncespace, sprite_to_bouncespace, endstate_oneshot };
			    }

			also
			fun do_canvasspace  (canvasspace_arg: gt::Canvasspace_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Canvasspace_Arg  );		# When endgun fires we'll read back final canvasspace_imp state via this oneshot.
				#
				canvasspace_egg
				    =
				    cai::make_canvasspace_egg  canvasspace_arg  (THE endstate_oneshot);

				(canvasspace_egg ())
				    ->
				    (exports, canvasspace_egg');

				exports -> { guiboss_to_canvasspace as gt::GUIBOSS_TO_CANVASSPACE cs, object_to_canvasspace };

# XXX SUCKO FIXME We need a counterpart of this at running_gui shutdown time.
				canvas_imps :=  im::set (*canvas_imps,  id_to_int cs.id,  { guiboss_to_canvasspace, object_to_canvasspace, endstate_oneshot });

# NOT VERY SOON add gadget_to_guiboss to imports:
				canvasspace_imports =  { int_sink => \\ (i: Int) = () };

				canvasspace_egg' (canvasspace_imports, run_gun', end_gun');

				{ guiboss_to_canvasspace, object_to_canvasspace, endstate_oneshot };
			    }

			also
			fun do_bounce_widget												# XXX SUCKO FIXME should rename to do_sprite.
			      (
				bounce_widget:		gt::Sg_Bounce_Widget,
				sprite_to_bouncespace:	s2b::Sprite_To_Bouncespace,
				current_backing_pixmap:	gt::Backing_Pixmap
			      )
			    =
			    case bounce_widget
				#
			        gt::SG_SPRITE
				      (
					(gt::BOUNCE_SPRITE_START_FN bounce_sprite_start_fn):	gt::Bounce_Sprite_Start_Fn,
					saved_sprite_state:					Null_Or(Exception)			# Used by arrowbutton etc to preserve state across gui stop/restart cycles.
				      )
				    =>
				    {   endstate_oneshot										# When endgun fires we'll read back final widget state via this oneshot.
					    =
					    make_oneshot_maildrop()
					    :
					    Oneshot_Maildrop  ( ( gt::Bounce_Sprite_Start_Fn,
								  Null_Or(Exception)							# saved_sprite_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							      ) );
					#
					(bounce_sprite_start_fn { gadget_to_guiboss, sprite_to_bouncespace, run_gun', end_gun', endstate_oneshot, saved_sprite_state })
					    ->
					    { guiboss_to_gadget as gt::GUIBOSS_TO_GADGET b2g, bouncespace_to_sprite };


					gadget_info  =  make_gadget_info  (guiboss_to_gadget, current_backing_pixmap);

# XXX SUCKO FIXME We need a counterpart of this at running_gui shutdown time.
					gadget_imps     :=  im::set (*gadget_imps,     iul::id_to_int b2g.id,  gadget_info );

					gt::RG_SPRITE { bouncespace_to_sprite, guiboss_to_gadget, endstate_oneshot };
				    };

			    esac


			also
			fun do_canvas_widget												# XXX SUCKO FIXME should rename to do_object
			      (
				canvas_widget:		gt::Sg_Canvas_Widget,
				object_to_canvasspace:	o2c::Object_To_Canvasspace,
				current_backing_pixmap:	gt::Backing_Pixmap
			      )
			    =
			    case canvas_widget
				#
				gt::SG_PACKEDSPACE  (packedspace_arg:  gt::Packedspace_Arg,  packed_widget: gt::Sg_Packed_Widget)
				    =>
				    {
					(do_packedspace  packedspace_arg)
					    ->
					    stuff as { widget_to_packedspace, guiboss_to_packedspace as gt::GUIBOSS_TO_PACKEDSPACE ps, endstate_oneshot };

# XXX SUCKO FIXME We need a counterpart of this at running_gui shutdown time.
					packed_imps :=  im::set (*packed_imps, (id_to_int ps.id), stuff);

					(do_packed_widget (packed_widget, widget_to_packedspace, current_backing_pixmap))
					    ->
					    packed_widget;

					gt::RG_PACKEDSPACE { packedspace_id => ps.id,  packed_widget };
				    };

				gt::SG_OBJECT
				      (
					(gt::CANVAS_OBJECT_START_FN canvas_object_start_fn):	gt::Canvas_Object_Start_Fn,
					saved_object_state:					Null_Or(Exception)			# Used by arrowbutton etc to preserve state across gui stop/restart cycles.
				      )
				    =>
				    {   endstate_oneshot										# When endgun fires we'll read back final object state via this oneshot.
					    =
					    make_oneshot_maildrop()
					    :
					    Oneshot_Maildrop( ( gt::Canvas_Object_Start_Fn,
								Null_Or(Exception)							# saved_object_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							      )
							    );
					#
					(canvas_object_start_fn { gadget_to_guiboss, object_to_canvasspace, run_gun', end_gun', endstate_oneshot, saved_object_state })
					    ->
					    { guiboss_to_gadget as gt::GUIBOSS_TO_GADGET b2g, canvasspace_to_object };


					gadget_info  =  make_gadget_info  (guiboss_to_gadget, current_backing_pixmap);

# XXX SUCKO FIXME We need a counterpart of this at running_gui shutdown time.
					gadget_imps     :=  im::set (*gadget_imps,     iul::id_to_int b2g.id,  gadget_info );

					gt::RG_OBJECT { canvasspace_to_object, guiboss_to_gadget, endstate_oneshot };
				    };
			    esac

			also
			fun do_packed_widget
			      (
				packed_widget:		gt::Sg_Packed_Widget,				# 'packed_widget' can be a tree of widgets with ROW and COL internal nodes.
				widget_to_packedspace:	w2p::Widget_To_Packedspace,
				current_backing_pixmap:	gt::Backing_Pixmap
			      )
			    =
			    case packed_widget
				#
				gt::SG_ROW	(packed_widgets:	 List( (List(plh::Packedspace_Layout_Hint), gt::Sg_Packed_Widget) ))		# A row of widgets. The ROW itself is not a widget (given no microthread).
				    =>
				    {
					widgets =   map  do_widget  packed_widgets
						    where
							fun do_widget
							    (
							      layout_hints:	List( plh::Packedspace_Layout_Hint ),
							      packed_widget:	gt::Sg_Packed_Widget
							    )
							    =
							    { widget		=>  do_packed_widget  (packed_widget, widget_to_packedspace, current_backing_pixmap),
							      cooked_hints	=>  digest_packedspace_layout_hints  layout_hints  { cut => NULL, min => NULL },
							      raw_hints		=>  layout_hints
							    };
						    end;

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

					gt::RG_ROW  { widgets,
						      #
						      pixels_high_min,
						      pixels_wide_min,
						      #
						      pixels_high_cut,
						      pixels_wide_cut,
						      #
						      site =>  REF  g2d::box::zero
						    };
				    };

				gt::SG_COL	(packed_widgets:	 List( (List(plh::Packedspace_Layout_Hint), gt::Sg_Packed_Widget) ))		# A column of widgets. The COL itself is not a widget (given no microthread).
				    =>
				    {
					widgets =   map  do_widget  packed_widgets
						    where
							fun do_widget
							    (
							      layout_hints:	List( plh::Packedspace_Layout_Hint ),
							      packed_widget:	gt::Sg_Packed_Widget
							    )
							    =
							    { widget		=>  do_packed_widget  (packed_widget, widget_to_packedspace, current_backing_pixmap),
							      cooked_hints	=>  digest_packedspace_layout_hints  layout_hints  { cut => NULL, min => NULL },
							      raw_hints		=>  layout_hints
							    };
						    end;

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

					gt::RG_COL  { widgets,
						      #
						      pixels_high_min,
						      pixels_wide_min,
						      #
						      pixels_high_cut,
						      pixels_wide_cut,

						      site =>  REF  g2d::box::zero
						    };
				    };

				gt::SG_SCROLLABLE_VIEW									# A viewport onto a scrollable pixmap
				  (
				    w
				    as
				    ( callback:		gt::Viewport_Scroller_Callback,
				      pixmap_size:	g2d::Size,
				      packed_widget:	gt::Sg_Packed_Widget
				  ) )
				    =>
				    {
					gadget_to_rw_pixmap	=   imports.guiboss_to_windowsystem.make_rw_pixmap
									#
									pixmap_size;


					view_origin     =  REF { row => 0,						# View origin in viewport coordinates. Controls which part of view is visible in viewport.  guiboss-imp.pkg will update this in response to scrollbar motions etc.
								 col => 0
							       };

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

					viewport	=  REF g2d::box::zero;						# Dummy initial value -- real value will be set by   assign_sites_to_all_widgets()   in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

					viewport_record = { parent_pixmap  => current_backing_pixmap,			# The backing_pixmap we were doing before diving recursively into this view.
							    view_origin => view_origin,
							    viewport_site  => viewport					# Site of view on parent.
															# XXX SUCKO FIXME Currently we store 'site' both here and in gt::SCROLLABLE_VIEW.
															#           We'll probably wind up using only one;  (???)
															#		  we should delete the unused one.
							  };

					backing_pixmap  = gt::VIEWPORT_PIXMAP
							    {
							      pixmap     =>  gadget_to_rw_pixmap,			# The backing pixmap for this view.
							      viewports  =>  REF [ viewport_record ],			# Initially at least view_pixmap is visible through only this one viewport.
							      is_visible =>  REF TRUE	
							    };

					widget		= do_packed_widget  (packed_widget, widget_to_packedspace, backing_pixmap);	# Process widget in new backing_pixmap not current_backing_pixmap!

					viewport_scroller									# Define the get/set fns client code uses to scroll the viewport.
					    =
					    { get_viewport_origin,
					      set_viewport_origin
					    }
					    where
						fun get_viewport_origin ()
						    =
						    *view_origin;								# Origin of gadget_to_rw_pixmap in viewport coordinates, used for scrolling pixmap in viewport.

						fun set_viewport_origin (view_origin_in_viewport_coordinates: g2d::Point)
						    =
						    {										# In this routine we must clearly distinguish three different coordinate systems.
																# We are dealing with a backing_pixmap for a scrollable view which is visible
																# through a viewport which is located on a parent backing_pixmap.
																# Thus, we have:
																#  o  The coordinate system of the view itself, with 0,0 at upper-left of the view's backing pixmap.
																#  o  The coordinate system of the parent,      with 0,0 at upper-left of its own    backing pixmap.
																#  o  The coordinate system of the viewport,    with 0,0 at upper-left of the viewport.
																# These three coordinate systems are related by
																#  o  viewport_site, which gives the viewport origin (and size) in parent   coordinates.
																#  o  view_origin,   which gives the view     origin            in viewport coordinates.
																# We have boxes in all three coordinate systems here, so we must track carefully which box is in which coordinate system.

							view_origin := view_origin_in_viewport_coordinates;			# Note new origin of gadget_to_rw_pixmap in viewport coordinates, used for scrolling pixmap in viewport.

							viewport_site_in_parent_coordinates
							    =
							    *viewport;

							viewport_origin_in_parent_coordinates
							    =
							    g2d::box::upperleft  viewport_site_in_parent_coordinates;

							view_site_in_parent_coordinates
							    =
							    g2d::box::make
							      (
								view_origin_in_viewport_coordinates + viewport_origin_in_parent_coordinates,
								gadget_to_rw_pixmap.size
							      );

							view_site_in_view_coordinates
							    =
							    g2d::box::make
							      (
								g2d::point::zero,
								gadget_to_rw_pixmap.size
							      );

							viewport_origin_in_view_coordinates
							    =
							    g2d::point::zero - view_origin_in_viewport_coordinates;

							viewport_site_in_view_coordinates
							    =
							    g2d::box::clone_box_at
							      (
								viewport_site_in_parent_coordinates,
								viewport_origin_in_view_coordinates
							      );

							if (not (g2d::box::box_a_in_box_b { a => viewport_site_in_view_coordinates,	# Does our pixmap fill the viewport on parent pixmap?
											    b => view_site_in_view_coordinates
											  }
							   )    )
							    #										# No, so we have to clear the remainder of the viewport.
							    #
							    boxes_to_clear =  g2d::box::subtract_box_b_from_box_a			# Express area to be cleared as a list of non-overlapping rectangles.
										{
										  a => viewport_site_in_parent_coordinates,
										  b => view_site_in_parent_coordinates
										};

							    apply do_box boxes_to_clear							# For each box to be cleared ...
								where
								    fun do_box (box: g2d::Box)
									=
									{
									    clear_box_in_pixmap (viewport_record.parent_pixmap, box);	# ... fill it with black, then ...
									    #
									    update_offscreen_parent_pixmaps_and_then_topwindow		# ... copy that blackness all the way up the viewport chain to visible topwindow.
										#
										(viewport_record.parent_pixmap, box, topwindow_for_gui);
									};
								end;
							fi;

							from_box = g2d::box::intersection						# We want to draw on parent only that part which is visible and which exists.
								      (
									viewport_site_in_view_coordinates,				# This is the part that is visible.
									view_site_in_view_coordinates					# This is what exists.
								      );	

							case from_box
							    #
							    NULL         => ();								# No intersection means nothing to draw. Pixmap must be scrolled completely out of sight...
							    #
							    THE from_box => update_offscreen_parent_pixmaps_and_then_topwindow		# Draw visible part pixmap on parent.
									        #
										(backing_pixmap, from_box, topwindow_for_gui);
							esac;
						    };	
					    end;

					callback (THE viewport_scroller);						# Give app client code a handle with which to gadget_to_rw_pixmap in viewport.

					gt::RG_SCROLLABLE_VIEW { scroller => viewport_scroller, callback, widget, gadget_to_rw_pixmap, view_origin, backing_pixmap, site => viewport };
				    };

				gt::SG_TABBED_VIEWS									# A viewport onto a set of alternate pixmaps for tabbed viewing.
				      (
					callback:	gt::Tabbed_View_Picker_Callback,
					pixmap_size:	g2d::Size,
					widgets:	List( gt::Sg_Packed_Widget )
				      )
				    =>
				    {
					if ((list::length widgets) == 0)						# We could be more robust by supporting empty 'widgets', but that would give us special
					    log::fatal "TABBED_VIEWS needs at least one view! -- guiboss-imp.pkg";	# cases in the code every time we access visible_widget.  Maybe it is worth it?
					    ();										# We'd have to make visible_widgets be Ref(Null_Or(Tabview)) instead of just Ref(Tabview).
					fi;

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

					viewport	=  REF g2d::box::zero;						# Dummy initial value -- real value will be set by   assign_sites_to_all_widgets()   in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

					visible		=  REF TRUE;							# We'll default this to TRUE for first widget, FALSE for the rest.

					widgets =   map  do_widget  widgets
						    where
							fun do_widget
							    (
							      packed_widget:	gt::Sg_Packed_Widget
							    )
							    =
							    {	widget		= do_packed_widget  (packed_widget, widget_to_packedspace, current_backing_pixmap);
								#
								gadget_to_rw_pixmap = imports.guiboss_to_windowsystem.make_rw_pixmap
										          #
										          pixmap_size;

								view_origin  =   REF { row => 0,					# View origin in viewport coordinates. Controls which part of view is visible in viewport.  For tabbed views this will never be changed.
											  col => 0
											};

								backing_pixmap  = gt::VIEWPORT_PIXMAP
										    {
										      is_visible => REF *visible,
										      #		
										      pixmap     => gadget_to_rw_pixmap,				# The backing pixmap for this view.

										      viewports  => REF [						# Initially at least view_pixmap is visible through only this one viewport.
													  { parent_pixmap => current_backing_pixmap,	# The backing_pixmap we were doing before diving recursively into this view.
													    view_origin,
													    viewport_site => viewport			# Site of view on parent.
																			# XXX SUCKO FIXME Currently we store 'site' both here and in gt::SCROLLABLE_VIEW.
																			#           We'll probably wind up using only one;  (???)  BTW, SHOULDN'T THIS BE A REF so WE CAN UPDATE SITE WHEN DOING RE-LAYOUT?
																			#		  we should delete the unused one.

													  }
												        ]	
										    };

								visible   := FALSE;

								{ widget, gadget_to_rw_pixmap, backing_pixmap };
							    };
						    end;

					visible_widget	=  REF (head widgets);										# Default to displaying first view, if there is more than one.

					tabbed_view_picker
					    =
					    { get_active_view,
					      set_active_view
					    }
					    where
						fun number_of_active_widget  ([]: List(gt::Tabview),  i: Int)
							=>
							0;

						    number_of_active_widget ((widget ! rest), i)
						        =>
							if (id_to_int widget.gadget_to_rw_pixmap.id == id_to_int (*visible_widget).gadget_to_rw_pixmap.id)   i;
							else										                     number_of_active_widget (rest, i+1);
							fi;
						end;

						fun get_active_view ()
						    =
						    number_of_active_widget (widgets, 0);

						fun set_active_view (i: Int)
						    =
						    {   widget_count = list::length widgets;
							#
							if (i != get_active_view ())							# Do nothing if client code is re-selecting already-active tabview.
							    #
							    if (i >= 0  and  i < widget_count)
								#
								case ((*visible_widget).backing_pixmap)
								    #
								    gt::VIEWPORT_PIXMAP r =>   r.is_visible := FALSE;			# Remember previously visible view is now not visible.
								    _			  =>	();					# Shouldn't happen.
								esac;

								visible_widget :=  list::nth (widgets, i);

								case ((*visible_widget).backing_pixmap)
								    #
								    gt::VIEWPORT_PIXMAP r =>   r.is_visible := TRUE;			# Remember newly visible view is now visible.
								    _			   =>	();					# Shouldn't happen.
								esac;
							    else
								log::note_on_stderr {. sprintf "set_active_view: arg = %d not in range 0 -> %d\n" i widget_count; };
							    fi;

							    from_box =    g2d::box::make						# We want to update the whole pixmap. (A tabview should always be the same size as the viewport, and all of it needs updating.)
									    (
									      g2d::point::zero, 
									      (*visible_widget).gadget_to_rw_pixmap.size
									    );

							    update_offscreen_parent_pixmaps_and_then_topwindow				# Draw pixmap on parent.
								#
								((*visible_widget).backing_pixmap, from_box, topwindow_for_gui);

							fi;

							();
						    };	
					    end;

					callback (THE tabbed_view_picker);								# Give app client code a handle with which to gadget_to_rw_pixmap in viewport.

					gt::RG_TABBED_VIEWS { callback, pixmap_size, widgets, visible_widget, site => viewport };
				    };

				gt::SG_WIDGET
				      (
					(gt::PACKED_WIDGET_START_FN packed_widget_start_fn):		gt::Packed_Widget_Start_Fn,	# packed_widget_start_fn  was generated by  make_packed_widget_start_fn  in  src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg
					saved_widget_state:						Null_Or(Exception)		# Used by arrowbutton etc to preserve state across gui stop/restart cycles.
				      )
				    =>
				    {   endstate_oneshot										# When endgun fires we'll read back final widget state via this oneshot.
					    =
					    make_oneshot_maildrop()
					    :
					    Oneshot_Maildrop  ( ( gt::Packed_Widget_Start_Fn,
								  Null_Or(Exception)							# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							      ) );
					#
					(packed_widget_start_fn { gadget_to_guiboss, widget_to_packedspace, run_gun', end_gun', endstate_oneshot, saved_widget_state })
					    ->
					    { guiboss_to_gadget as gt::GUIBOSS_TO_GADGET b2g, packedspace_to_widget };


					gadget_info  =  make_gadget_info  (guiboss_to_gadget, current_backing_pixmap);

# XXX SUCKO FIXME We need a counterpart of this at running_gui shutdown time.
					gadget_imps     :=  im::set (*gadget_imps,     iul::id_to_int b2g.id,  gadget_info );
# nb {. sprintf "gt::SG_WIDGET entered widget %d into gadget_imps (iul::id_to_int b2g.id)" (iul::id_to_int b2g.id); };
# nb {. sprintf "gt::SG_WIDGET pprinting all gadget info -- guiboss-imp.pkg"; };
# apply pprint_it (im::keyvals_list *gadget_imps)
# where
#     fun pprint_it (i, gadget_info)
# 	=
# 	{
# 	    pprint_gadget_info gadget_info;
# 	};
# end; 



					site =  REF  g2d::box::zero;

					gt::RG_WIDGET { packedspace_to_widget, guiboss_to_gadget, endstate_oneshot, site };
				    };


				gt::SG_CANVASSPACE
				    ( canvasspace_arg:	gt::Canvasspace_Arg,
				      canvas_widgets:	List((List(clh::Canvasspace_Layout_Hint),  gt::Sg_Canvas_Widget))
				    )
				    =>
				    {
					(do_canvasspace  canvasspace_arg)
					    ->
					    stuff as { guiboss_to_canvasspace as gt::GUIBOSS_TO_CANVASSPACE cs, object_to_canvasspace, endstate_oneshot };

					canvasspace_id =  cs.id;

# XXX SUCKO FIXME We need a counterpart of this at running_gui shutdown time.
					canvas_imps :=  im::set (*canvas_imps, (id_to_int canvasspace_id), stuff);

					#
					widgets	=   map  do_widget  canvas_widgets
						    where
							fun do_widget (hints: List(clh::Canvasspace_Layout_Hint), canvas_widget: gt::Sg_Canvas_Widget)
							    =
							    ( hints,
							      do_canvas_widget  (canvas_widget, object_to_canvasspace, current_backing_pixmap)
							    );	
						    end;

					site =  REF  g2d::box::zero;

					gt::RG_CANVASSPACE { canvasspace_id,  widgets, site };
				    };

				gt::SG_BOUNCESPACE
				    ( bouncespace_arg:	gt::Bouncespace_Arg,
				      bounce_widgets:	List((List(blh::Bouncespace_Layout_Hint), gt::Sg_Bounce_Widget))
				    )
				    =>
				    {
					(do_bouncespace  bouncespace_arg)
					    ->
					    stuff as { guiboss_to_bouncespace as gt::GUIBOSS_TO_BOUNCESPACE os, sprite_to_bouncespace, endstate_oneshot };

# XXX SUCKO FIXME We need a counterpart of this at running_gui shutdown time.
					bounce_imps :=  im::set (*bounce_imps, (id_to_int os.id), stuff);

					#
					widgets	=   map  do_widget  bounce_widgets
						    where
							fun do_widget (hints: List(blh::Bouncespace_Layout_Hint),  bounce_widget: gt::Sg_Bounce_Widget)
							    =
							    ( hints,
							      do_bounce_widget  (bounce_widget, sprite_to_bouncespace, current_backing_pixmap)
							    );	
						    end;

					bouncespace_id =  os.id;

					site =  REF  g2d::box::zero;

					gt::RG_BOUNCESPACE { bouncespace_id, widgets, site };
				    };

				gt::SG_NULL_PACKED_WIDGET
				    =>
				    gt::RG_NULL_PACKED_WIDGET;
			    esac;
		    end;														# fun paused_gui__to__running_gui



		#
		running_gui = paused_gui__to__running_gui  paused_gui;									# Starts up all widget look-imps and state-imps plus the canvas- bounce- and packedspace imps,
																	# and populates our bounce_imps, canvas_imps, packed_imps and gadget_imps maps.

		fun make_popup														# PUBLIC. Create popup pane on given window in given site.  Given site is adjusted to lie entirely within parent (if necessary) and returned.
		      (
			requested_site:		g2d::Box,
			gui_plan:		gt::Gui_Plan
		      )
		    : (
			g2d::Box,
			gt::Client_To_Guiwindow
		      )
		    =
		    {
# nb {. sprintf "make_popup/AAA  requested_site == { row => %d, col => %d, high => %d, wide => %d } -- guiboss-imp.pkg" requested_site.row requested_site.col requested_site.high requested_site.wide; };
			gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Client_To_Guiwindow );
# nb {. sprintf "make_popup/BBB -- guiboss-imp.pkg"; };
			actual_site_and_backing_pixmap'
			    =
			    make_oneshot_maildrop():  Oneshot_Maildrop( (g2d::Box, gt::Backing_Pixmap) );
			#
			put_in_mailqueue  (guiboss_q,											# make_popup() is intended to be called by widget code, so our first task is to transition from caller's microthread to the guiboss-imp microthread.
			    #
			    \\ (runstate as { me, imports, ... }: Runstate)								# Once into the body of this fn we are running in the guiboss-imp microthread.
				=
				{
# nb {. sprintf "make_popup/CCC -- guiboss-imp.pkg"; };
				    (make_backing_pixmap_for_popup									# Make a new rw_pixmap, wrap it in a TOPWINDOW_PIXMAP, enter latter into the TOPWINDOW_PIXMAP popup hierarchy for this gui.
				      (
					imports.guiboss_to_windowsystem.make_rw_pixmap,							# To allocate the actual rw_pimap for the Backing_Pixmap.
					topwindow_info.next_stacking_order,								# To allocate a 'stacking_order' value for Backing_Pixmap.
					topwindow_pixmap,										# Our parent Backing_Pixmap.
					requested_site											# Where to put popup on parent Backing_Pixmap.
				      )
				    ) -> (actual_site, backing_pixmap);
nb {. sprintf "make_popup/CCCC: (%s): , now printing out popup's backing_pixmap" (gt::backing_pixmap_id backing_pixmap); };
gt::pprint_backing_pixmap (backing_pixmap);

# nb {. sprintf "make_popup/DDD -- guiboss-imp.pkg"; };
				    put_in_oneshot (actual_site_and_backing_pixmap', (actual_site, backing_pixmap));			# Pass actual site of popup back to calling microthread, plus backing pixmap for popup GUI.

# nb {. sprintf "make_popup/EEE -- guiboss-imp.pkg"; };
				    start_gui'
				      (
					runstate: 		Runstate,
					#	
					topwindow_for_gui:	gws::Guiboss_To_Topwindow,
					backing_pixmap:		gt::Backing_Pixmap,
					gui_plan:		gt::Gui_Plan,

					gui_startup_complete':	Oneshot_Maildrop( gt::Client_To_Guiwindow ),
					guiboss_q:		Guiboss_Q,
					pause_gui:		(gt::Running_Gui, Bounce_Imps, Canvas_Imps, Packed_Imps, Gadget_Imps, Topwindow_Info) -> gt::Paused_Gui,
					kill_gui:		(gt::Running_Gui, Bounce_Imps, Canvas_Imps, Packed_Imps, Gadget_Imps, Topwindow_Info) -> Void
				      );
				}
			);

# nb {. sprintf "make_popup/UUU -- guiboss-imp.pkg"; };
			(get_from_oneshot  actual_site_and_backing_pixmap')
			    ->
			    (actual_site, backing_pixmap);		  								# Read actual site of popup back from guiboss-imp microthread, also backing pixmap for popup GUI.

# nb {. sprintf "make_popup/VVV -- guiboss-imp.pkg"; };
			client_to_guiwindow =  get_from_oneshot  gui_startup_complete'; 						# Wait until popup startup is complete.  We do this in caller's thread to reduce risk of lockup -- caller is typically a button that can afford to sleep a bit.

# nb {. sprintf "make_popup/WWW -- guiboss-imp.pkg"; };
# 			put_in_mailqueue  (guiboss_q,											# make_popup() is intended to be called by widget code, so our first task is to transition from caller's microthread to the guiboss-imp microthread.
# 			    #
# 			    \\ (runstate as { me, imports, ... }: Runstate)								# Once into the body of this fn we are running in the guiboss-imp microthread.
# 				=
# 				{
# nb {. sprintf "make_popup/XXX calling redraw_all_running_guis() -- guiboss-imp.pkg"; };
# #				    redraw_all_running_guis (backing_pixmap, topwindow_for_gui);						# Update user's on-screen window to show new popup GUI.
# 				    redraw_all_running_guis (topwindow_pixmap, topwindow_for_gui);						# Update user's on-screen window to show new popup GUI.
# nb {. sprintf "make_popup/YYY called  redraw_all_running_guis() -- guiboss-imp.pkg"; };
# 				}
# 			);
# actual_site = requested_site;
# client_to_guiwindow # Dummy
# 	  =
# 	  { id => issue_unique_id (),
# 	    pause_gui => {. ([], gt::SG_NULL_PACKED_WIDGET); },
# 	    kill_gui  => {. (); }
# 	  }; 
# nb {. sprintf "make_popup/ZZZ actual_site == { row => %d, col => %d, high => %d, wide => %d } -- guiboss-imp.pkg" actual_site.row actual_site.col actual_site.high actual_site.wide; };

			( actual_site,
			  client_to_guiwindow												# Return port to the running popup.
			);
		    };

		if (not we_are_a_popup_gui)												# One frameclock microthread per topwindow is quite sufficient, so we avoid starting extra ones up each time we start up a secondary (popup) gui.
		    #
# nb {. sprintf "restart_gui' starting up frameclock thread -- we_are_a_popup_gui B=%B -- guiboss-imp.pkg" we_are_a_popup_gui; };
		    make_thread'  [ THREAD_NAME "frameclock" ]  frameclock  end_gun'							# Start up frameclock thread which tells us when it is time to draw a new frame.
			where
			    fun display_one_frame ({ me, imports, ... }: Runstate)
				=
				{
				    current_frame_number := *current_frame_number + 1;
				    #
				    done_extra_startframe_this_frame	:= FALSE;							# See Note[1].

				    imps =  im::vals_list  *gadget_imps;

				    apply' imps  {.
					#
#	Gadget_Info													# The per-gadget information we track.  (This is private to guiboss-imp.)
#	  =														# Here 'gadget' refers indifferently to widget-imps, sprite-imps and object-imps.
#	  {
#	    site:			Site,										# Where to draw this gadget, in topwindow coordinates.
#	    backing_pixmap:		Ref(gt::Backing_Pixmap),
#	    #
#	    guiboss_to_gadget:		gt::Guiboss_To_Gadget,								# We use this to make requests of visible gadgets.
#	    gadget_mode:		Ref( gt::Gadget_Mode ),
#	    #
#	    may_have_visibly_changed:	Ref( Bool ),									# 
#	    sent__before_first_frame:	Ref( Bool ),
#	    #
#	    point_in_gadget:		Ref( Null_Or( g2d::Point -> Bool ))						# Optional fn to decide if a mouseclick actually hit the gadget itself, or just somewhere near it in the screenspace assigned to it.
#	  };  
					#imp -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, site, gadget_mode, may_have_visibly_changed, sent__before_first_frame, backing_pixmap, ... };

					if (not *sent__before_first_frame  and  *site != g2d::box::zero)				# If *site==g2d::box::zero then packedspace_imp has not yet done layout and we cannot yet call before_first_frame or start_of_frame, since both require a valid site.
					    #
					    fun make_rw_pixmap (size: g2d::Size):  g2p::Gadget_To_Rw_Pixmap
						=
						{   rw_pixmap = imports.guiboss_to_windowsystem.make_rw_pixmap( size );
# XXX BUGGO FIXME We still need to actually record rw_pixmap in *TOPWINDOW_PIXMAP.pixmaps.
						    #
						    topwindow_pixmap
							=
							gt::topwindow_pixmap_of_topwindow_pixmap_or_viewport_pixmap
							    #
							    *backing_pixmap;

						    topwindow_pixmap.pixmaps
							:=  
							im::set ( *topwindow_pixmap.pixmaps,
								  id_to_int rw_pixmap.id,
								  rw_pixmap
								);

						    #
						    rw_pixmap;	
						};
# nb {. sprintf "display_one_frame sending before_first_frame call -- guiboss-imp.pkg"; };
					    guiboss_to_gadget.before_first_frame  { site		=> *site,
										    theme		=>  imports.theme,
										     get_font		=>  topwindow_for_gui.get_font,
										    pass_font		=>  topwindow_for_gui.pass_font,
										    make_rw_pixmap,
										    make_popup
										  };

					    sent__before_first_frame  := TRUE;
					    may_have_visibly_changed  := TRUE;
					fi;
				    };

				    apply' imps  {.
					#imp -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, site, gadget_mode, may_have_visibly_changed, ... };
					    #

					if (*may_have_visibly_changed  and  *site != g2d::box::zero)
					    #
# nb {. sprintf "display_one_frame sending start_of_frame call -- guiboss-imp.pkg"; };
					    guiboss_to_gadget.start_of_frame
					      {
						frame_number => *current_frame_number,
						site => *site,
						visible => TRUE,
						duration_in_seconds => 0.0,
						this_gadget_mode => *gadget_mode,
						theme => imports.theme
					      };

					    may_have_visibly_changed := FALSE;
					fi;
				    };

	    #			apply' imps  {.
	    #			    #
	    #			    #imp -> { may_have_visibly_changed,
	    #				      guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget,
	    #				      site,	
	    #				      ...
	    #                                    };
	    #			};
				};	


    # XXX SUCKO FIXME we should probably just use the 50HZ timeslicing clock.
			    # This fn provides the body for a little microthread which just
			    # loops ten times a second telling our main thread to disply frame:
			    #
			    fun frameclock end_gun'
				=
				loop ()
				where
				    count = REF 19;
				    #
				    fun loop ()
					=
					{
					    do_one_mailop [
						#
						end_gun'
						    ==>
						    {.
							thread_exit { success => TRUE };
						    },
						#
						timeout_in' *seconds_per_frame
						    ==>
						    {.
							put_in_mailqueue  (guiboss_q, display_one_frame);
						    }
					    ];

					    loop ();
					};
				end;
			end;
		    ();
		fi;
	    end																		# fun restart_gui'

	#
	also																		# restart_gui'() and start_gui'() need to be mutually recursive so make_popup() can call start_gui'.
	fun start_gui'
	      (
		runstate: 		Runstate,
		#	
		topwindow_for_gui:	gws::Guiboss_To_Topwindow,
		topwindow_pixmap:	gt::Backing_Pixmap,
		gui_plan:		gt::Gui_Plan,

		gui_startup_complete':	Oneshot_Maildrop( gt::Client_To_Guiwindow ),
		guiboss_q:		Guiboss_Q,
		pause_gui:		(gt::Running_Gui, Bounce_Imps, Canvas_Imps, Packed_Imps, Gadget_Imps, Topwindow_Info) -> gt::Paused_Gui,
		kill_gui:		(gt::Running_Gui, Bounce_Imps, Canvas_Imps, Packed_Imps, Gadget_Imps, Topwindow_Info) -> Void
	      )
	    =
	    {	paused_gui =  gui_plan__to__paused_gui  gui_plan;
		#
	        restart_gui' (runstate, topwindow_for_gui, topwindow_pixmap, paused_gui, gui_startup_complete', guiboss_q, pause_gui, kill_gui);
	    }
	    where
nb {. sprintf "start_gui'/AAA: (%s): , now printing out topwindow_pixmap" (gt::backing_pixmap_id topwindow_pixmap); };
gt::pprint_backing_pixmap (topwindow_pixmap);
		fun gui_plan__to__paused_gui
		    (
		      packedspace_arg:		gt::Packedspace_Arg,
		      packed_widget:		gt::Packed_Widget
		    )
		    : gt::Paused_Gui
		    =
		    {
			(do_packed_widget packed_widget)
			    ->
			    packed_widget;

			( packedspace_arg:		gt::Packedspace_Arg,
			  packed_widget:		gt::Sg_Packed_Widget
			);
		    }
		    where
			fun do_bounce_widget (bounce_widget: gt::Bounce_Widget)
			    =
			    case bounce_widget
				#
			        gt::SPRITE a =>  gt::SG_SPRITE (a, NULL);										# SUBSTANTIVE CHANGE
			    esac

			also
			fun do_canvas_widget (canvas_widget: gt::Canvas_Widget)
			    =
			    case canvas_widget
				#
				gt::PACKEDSPACE  (packedspace_arg:  gt::Packedspace_Arg,  packed_widget: gt::Packed_Widget)
				    =>
				    {
					(do_packed_widget packed_widget)
					    ->
					    packed_widget;

					gt::SG_PACKEDSPACE (packedspace_arg,  packed_widget);
				    };

			        gt::OBJECT a =>  gt::SG_OBJECT (a, NULL);										# SUBSTANTIVE CHANGE
			    esac

			also
			fun do_packed_widget (packed_widget: gt::Packed_Widget)									# 'packed_widget' can be a tree of widgets with ROW and COL internal nodes.
			    =
			    case packed_widget
				#
			        gt::ROW	(packed_widgets:	 List( (List(plh::Packedspace_Layout_Hint), gt::Packed_Widget) ))		# A row of widgets. The ROW itself is not a widget (given no microthread).
				    =>
				    {
					packed_widgets
					    =
					    map  do_widget  packed_widgets
					    where
						fun do_widget
						    (
						      layout_hints:	List( plh::Packedspace_Layout_Hint ),
						      packed_widget:	gt::Packed_Widget
						    )
						    =
						    ( layout_hints,
						      do_packed_widget  packed_widget
						    );
					    end;

					gt::SG_ROW  packed_widgets;
				    };

			        gt::COL	(packed_widgets:	 List( (List(plh::Packedspace_Layout_Hint), gt::Packed_Widget) ))		# A column of widgets. The COL itself is not a widget (given no microthread).
				    =>
				    {
					packed_widgets
					    =
					    map  do_widget  packed_widgets
					    where
						fun do_widget
						    (
						      layout_hints:	List( plh::Packedspace_Layout_Hint ),
						      packed_widget:	gt::Packed_Widget
						    )
						    =
						    ( layout_hints,
						      do_packed_widget  packed_widget
						    );
					    end;

					gt::SG_COL  packed_widgets;
				    };

			        gt::SCROLLABLE_VIEW ( triple
						      as
							( callback:		gt::Viewport_Scroller_Callback,
							  pixmap_size:		g2d::Size,
							  packed_widget:	gt::Packed_Widget
						    )   )
				    =>
				    {
					triple = do_pair (callback, pixmap_size, packed_widget)
						where
						    fun do_pair
							(
							  callback:		gt::Viewport_Scroller_Callback,
							  pixmap_size:		g2d::Size,
							  packed_widget:	gt::Packed_Widget
							)
							=
							( callback,
							  pixmap_size,
							  do_packed_widget  packed_widget
							);
						end;
					
					gt::SG_SCROLLABLE_VIEW triple;
				    };

			        gt::TABBED_VIEWS
				      (
					callback:	gt::Tabbed_View_Picker_Callback,
					pixmap_size:	g2d::Size,
					widgets:	List( gt::Packed_Widget )
				      )
				    =>
				    {
					widgets = map do_pair widgets
						where
						    fun do_pair
							(
							  packed_widget:	gt::Packed_Widget
							)
							=
							do_packed_widget  packed_widget;
						end;
					
					gt::SG_TABBED_VIEWS (callback, pixmap_size, widgets);
				    };

			        gt::WIDGET   a =>  gt::SG_WIDGET (a, NULL);									# SUBSTANTIVE CHANGE
																		# The NULL is the saved_widget_state: Null_Or(Exception) used by arrowbutton etc to preserve state across gui stop/restart cycles.
			        gt::CANVASSPACE
				    ( canvasspace_arg:	gt::Canvasspace_Arg,
				      canvas_widgets:	List((List(clh::Canvasspace_Layout_Hint),  gt::Canvas_Widget))
				    )
				    =>
				    {
					canvas_widgets
					    =
					    map  do_widget  canvas_widgets
					    where
						fun do_widget (hints: List(clh::Canvasspace_Layout_Hint),  canvas_widget: gt::Canvas_Widget)
						    =
						    ( hints,
						      do_canvas_widget  canvas_widget
						    );	
					    end;

					gt::SG_CANVASSPACE (canvasspace_arg, canvas_widgets);
				    };

			        gt::BOUNCESPACE
				    ( bouncespace_arg:	gt::Bouncespace_Arg,
				      bounce_widgets:	List((List(blh::Bouncespace_Layout_Hint),  gt::Bounce_Widget))
				    )
				    =>
				    {
					bounce_widgets
					    =
					    map  do_widget  bounce_widgets
					    where
						fun do_widget (hints: List(blh::Bouncespace_Layout_Hint),  bounce_widget: gt::Bounce_Widget)
						    =
						    ( hints,
						      do_bounce_widget  bounce_widget
						    );	
					    end;

					gt::SG_BOUNCESPACE (bouncespace_arg, bounce_widgets);
				    };

			        gt::NULL_PACKED_WIDGET
				    =>
				    gt::SG_NULL_PACKED_WIDGET;
			    esac;
		    end;	
	    end;

	#
	fun startup   (id: Id,   reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		client_to_guiboss =   { id,
					make_topwindow,
					start_gui,
					restart_gui,
					get_bounce_theme,
					get_canvas_theme,
					get_packed_theme
				      };

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, { client_to_guiboss }));						# Return value from guiboss_egg'().

		(take_from_mailslot  me_slot)											# Imports from guiboss_egg'().
		    ->
		    { me, guiboss_arg, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';										# Wait for the starting gun.

		run ( guiboss_q,		 										# Will not return.
		      { me,
			guiboss_arg,
			imports,
			to,
			end_gun',
			id
		      }
		);
	    }
	    where
		guiboss_q     =  make_mailqueue (get_current_microthread()):  Guiboss_Q;



		#################################################################################
		# guiboss interface fns::
		#
		#
		stipulate
		    Appropriate_Gadget_Info												# Return value type for    find_appropriate_gadget_info().
		      #
		      =    APPROPRIATE_GADGET (Gadget_Info, g2d::Point)									# The g2d::Point is the query point transformed into the appropriate local coordinate system for the gadget.
		      | NO_APPROPRIATE_GADGET               g2d::Point
		      ;

		    fun find_appropriate_gadget_info											# Which widget did the user click on?  This is usually easy but it might be in a scrollable view in a tabbed view in another scrollable view, say.
			  (
			    topwindow_info:		Topwindow_Info,
			    event_point
			  )
			=
			{
# nb {. "find_appropriate_gadget_info/AAA: calling gt::return_all_topwindow_pixmaps_in_reverse_stacking_order -- guiboss-imp.pkg"; };
			    topwindow_pixmaps												#
				=
				gt::return_all_topwindow_pixmaps_in_descending_stacking_order  *topwindow_info.backing_pixmap;
# nb {. "find_appropriate_gadget_info/BBB: called  gt::return_all_topwindow_pixmaps_in_reverse_stacking_order -- guiboss-imp.pkg"; };

			    search_topwindow_pixmaps_in_descending_stacking_order  topwindow_pixmaps
			    where
				fun search_topwindow_pixmaps_in_descending_stacking_order  []
				        =>
					NO_APPROPRIATE_GADGET event_point;								# Tried everything, no hits, give up.

				    search_topwindow_pixmaps_in_descending_stacking_order  (topwindow_pixmap ! rest)			# Try topmost remaining popup first.
					=>
					{   origin =  *topwindow_pixmap.origin;
					    size   =  	topwindow_pixmap.pixmap.size;

					    site   =  g2d::box::make (origin, size);

					    if (g2d::box::point_in_box (event_point, site))
						#
						find_appropriate_gadget_info_for_running_gui  topwindow_pixmap;				# Found the right popup (or base) running gui, see if we hit any widgets within it.
					    else
						search_topwindow_pixmaps_in_descending_stacking_order  rest;				# event_point is not within this running gui, so try next one.
					    fi;
					};
				end;
			    end;		
			}
			where
			    fun find_appropriate_gadget_info_for_running_gui								# Which widget did the user click on?  This is usually easy but it might be in a scrollable view in a tabbed view in another scrollable view, say.
				  (
				    topwindow_pixmap:		gt::Topwindow_Pixmap							# This will be the topwindow_pixmap for either the topllevel running gui on the topwindow, or else the running gui for one of its popups.
				  )
				=
				case (*topwindow_pixmap.running_gui)
				    #
				    THE (running_gui:	gt::Running_Gui)
					=>
					{   event_point
						=
						event_point
						-
						(gt::topwindow_pixmap_origin_in_base_window_coordinates topwindow_pixmap);		#
					    #
					    find_gadget_info (running_gui.packed_widget, event_point);
					}
					where
					    fun try_all_row_or_col_widgets ([]: List(gt::Row_Widget),  point: g2d::Point)
						    =>
						    NO_APPROPRIATE_GADGET point;

						try_all_row_or_col_widgets (row_or_col_widget ! rest,  point)
						    =>
						    case (find_gadget_info  (row_or_col_widget.widget, point))
							#
							NO_APPROPRIATE_GADGET _ =>  try_all_row_or_col_widgets (rest,  point);		# Try the remaining widgets in ROW/COL.
							info =>  info;							# Got it.
						    esac;
					    end

					    also	
					    fun find_gadget_info
						  (
						    packed_widget:	gt::Rg_Packed_Widget,
						    point:		g2d::Point
						  )
						=
						if (g2d::box::point_in_box (point, gt::packed_widget_site packed_widget))
						    #
						    case packed_widget
							#
							gt::RG_ROW r =>   try_all_row_or_col_widgets (r.widgets, point);
							gt::RG_COL r =>   try_all_row_or_col_widgets (r.widgets, point);

							gt::RG_SCROLLABLE_VIEW r
							    =>
							    {   point = point - g2d::box::upperleft(*r.site);					# Transform mouseclick point into          view coordinate system.
								point = point - *r.view_origin;							# Transform mouseclick point into scrolled view coordinate system.
								#
								find_gadget_info (r.widget, point);						# Recursively search for target widget of mouseclick among widgets in scrollable view.
							    };	

							gt::RG_TABBED_VIEWS r
							    =>
							    {   point = point - g2d::box::upperleft(*r.site);					# Transform mouseclick point into view coordinate system.
								#
								find_gadget_info ((*r.visible_widget).widget, point);				# Recursively search for target widget of mouseclick among widgets in current tabbed view.
							    };

							gt::RG_WIDGET (r as { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... })
							    =>
							    {   imps = *topwindow_info.gadget_imps;
								#
								id   = iul::id_to_int guiboss_to_gadget.id;

								case (im::get (imps, id))
								    #
								    NULL =>  NO_APPROPRIATE_GADGET point ;
								    #
								    THE gadget_info								# Return 'point' transformed into correct coordinate system for widget.
									=>
									case (*gadget_info.point_in_gadget)
									    #
									    NULL   =>                 APPROPRIATE_GADGET (gadget_info, point);	# No   point_in_gadget fn supplied by gadget, so count mouseclick as having hit the gadget.
									    THE fn =>	if (fn point) APPROPRIATE_GADGET (gadget_info, point);	# Have point_in_gadget fn supplied by the gadget decide whether the mouseclick was close enough to count.
											else  	   NO_APPROPRIATE_GADGET (             point);
											fi;
									esac;
								esac;
							    };

							gt::RG_CANVASSPACE r
							    =>
	NO_APPROPRIATE_GADGET point; # TBD

							gt::RG_BOUNCESPACE r
							    =>
	NO_APPROPRIATE_GADGET point; # TBD

							gt::RG_NULL_PACKED_WIDGET
							    =>
							    NO_APPROPRIATE_GADGET point;
						    esac;
						else
						    NO_APPROPRIATE_GADGET point;
						fi;
					end;
				    #	 
				    NULL => NO_APPROPRIATE_GADGET event_point;							# Maybe we should do:   log::fatal "find_appropriate_gadget_info' called while gui not running!";
				esac;
			end;
		herein

		    fun do_motion_notify										# Mouse has moved. Inform any relevant gadgets.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
# This arg probably should not be here (because we have multiple running_guis now and passing just one cannot be right)
# but it appears unused: 
			    running_gui:		gt::Running_Gui,
			    motion_xevtinfo:		evt::Motion_Xevtinfo
			  )
			=
{
# nb {. sprintf "do_motion_notify/AAA -- guiboss-imp.pkg"; };

			case (find_appropriate_gadget_info (topwindow_info, motion_xevtinfo.event_point))
			    #
			    APPROPRIATE_GADGET (gadget_info, event_point)						# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				=>
				{   mouse_is = topwindow_info.mouse_is;
				    #
				    gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };

				    case *mouse_is
					#
					CROSSING_NONGADGET								# Here the mouse is crossing from non-gadget pixels into gadget pixels.
					    =>
					    {
					        guiboss_to_gadget.note_mouse_transit					# Notify gadget that mouse has entered its space.
						  {
						    transit		=> gt::CAME,
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_info.site,
						    theme		=>  imports.theme
						  };
						guiboss_to_gadget.note_mouse_transit					# Notify gadget that mouse has entered its space.
						  {
						    transit		=> gt::MOVE,					# We send a MOVE after every CAME, for the convenience of handlers interested only in coordinates -- they can process all MOVE events and ignore CAME and LEFT events.
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_info.site,
						    theme		=>  imports.theme
						  };

						mouse_is := CROSSING_GADGET { gadget_info };				# Remember which widget mouse is in.

					    };	

					CROSSING_GADGET  { gadget_info => (last_gadget_info as { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET last_guiboss_to_gadget, ... }) }
					    =>
					    if (same_gadget_info (gadget_info, last_gadget_info))
						#									# Here mouse is continuing to move on same gadget it was on at last report.
						guiboss_to_gadget.note_mouse_transit					# Notify gadget that mouse has entered its space.
						  {
						    transit		=> gt::MOVE,								# 
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_info.site,
						    theme		=> imports.theme
						  };

					    else									# Here mouse has crossed from one gadget to another.

						last_guiboss_to_gadget.note_mouse_transit				# Notify last gadget that mouse has left its space.
						  {
						    transit		=> gt::LEFT,
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *last_gadget_info.site,
						    theme		=> imports.theme
						  };

						mouse_is := CROSSING_GADGET { gadget_info };				# Remember that we're now on the new gadget.
						#
						guiboss_to_gadget.note_mouse_transit					# Notify new gadget that mouse has entered its space.
						  {
						    transit		=> gt::CAME,
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_info.site,
						    theme		=> imports.theme
						  };
						guiboss_to_gadget.note_mouse_transit					# Notify gadget that mouse has entered its space.
						  {
						    transit		=> gt::MOVE,					# We send a MOVE after every CAME, for the convenience of handlers interested only in coordinates -- they can process all MOVE events and ignore CAME and LEFT events.
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_info.site,
						    theme		=> imports.theme
						  };
					    fi;

					DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
					    {
					      gadget_info => dragged_gadget_info,					# This is the gadget on which the drag started.  It gets all the MOVE events until drag terminates, even if mouse leaves the window area owned by the gadget. (But we only send DRAGs while cursor is in the dragged gadget.)
					      start_point,								# This is the window coordinate of the downclick which started this drag.
					      last_point								# This is the window coordinate of the last motion event for this drag.
					    }
					    =>
					    if (same_gadget_info (gadget_info, dragged_gadget_info))			# If cursor is outside gadget in which drag started, we do absolutely nothing.
						#
						guiboss_to_gadget.note_mouse_drag_event					# 
						  {									# 
						    phase		=> gt::DRAG,
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    mousebuttons_state	=> motion_xevtinfo.mousebuttons_state,
						    event_point,
						    start_point,
						    last_point,
						    site		=> *gadget_info.site,
						    theme		=> imports.theme
						  };

						mouse_is := DRAGGING_IN_GADGET						# Remember location of last DRAG event.
							      {
								gadget_info,						# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
								start_point,						# This is the window coordinate of the downclick which started this drag.
								last_point => event_point				# This is the window coordinate of the last DRAG event for this drag.
							      };
					    fi;
				    esac;
				};

			    NO_APPROPRIATE_GADGET event_point
				=> 
				{
				    mouse_is = topwindow_info.mouse_is;
				    #
				    case *mouse_is
					#
					CROSSING_NONGADGET
					    =>
					    ();										# Nothing to do in this case.

					CROSSING_GADGET  { gadget_info }						# Should sent LEAVE event in this case.
					    =>
					    {	gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };
						#
						guiboss_to_gadget.note_mouse_transit					# Notify the gadget that we were on that mouse has left its space.
						  {
						    transit		=> gt::LEFT,
						    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_info.site,
						    theme		=> imports.theme
						  };

						mouse_is := CROSSING_NONGADGET;
					    };

					DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
					    {
					      gadget_info,								# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
					      start_point,								# This is the window coordinate of the downclick which started this drag.
					      last_point								# This is the window coordinate of the last motion event for this drag.
					    }
					    =>
					    ();										# Mouse is not in the gadget that was downclicked so we completely ignore the motion event.
				    esac;
				};
			esac;
# nb {. sprintf "do_motion_notify/ZZZ -- guiboss-imp.pkg"; };
};


		    fun do_button_press											# 
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
# This arg probably should not be here (because we have multiple running_guis now and passing just one cannot be right)
# but it is apparently unused at present anyhow:
			    running_gui:		gt::Running_Gui,
			    button_xevtinfo:		evt::Button_Xevtinfo
			  )
			=
			{
# nb {. sprintf "do_button_press/AAA -- guiboss-imp.pkg"; };
# { button_xevtinfo.mouse_button -> evt::MOUSEBUTTON mousebutton;
#   nb {. sprintf "do_button_press mousebutton %d pressed" mousebutton; };
#   buttons = button_xevtinfo.mousebuttons_state;
#   nb {. sprintf "do_button_press mousebutton_1_was_down = %B" buttons.mousebutton_1_was_down; };
#   nb {. sprintf "do_button_press mousebutton_2_was_down = %B" buttons.mousebutton_2_was_down; };
#   nb {. sprintf "do_button_press mousebutton_3_was_down = %B" buttons.mousebutton_3_was_down; };
#   nb {. sprintf "do_button_press mousebutton_4_was_down = %B" buttons.mousebutton_4_was_down; };
#   nb {. sprintf "do_button_press mousebutton_5_was_down = %B" buttons.mousebutton_5_was_down; };
# };
			    case (find_appropriate_gadget_info (topwindow_info, button_xevtinfo.event_point))
				#
				APPROPRIATE_GADGET (gadget_info, event_point)						# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				    =>
				    {
					mouse_is = topwindow_info.mouse_is;
					#
					gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };

					case *mouse_is
					    #
					    CROSSING_NONGADGET
						=>
						{
						    guiboss_to_gadget.note_mouse_transit				# Tell gadget that mouse has entered its space.
						      {
							transit		    => gt::CAME,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    guiboss_to_gadget.note_mouse_drag_event				# Tell gadget that user just started a drag operation on it.
						      {									# 
							phase		    => gt::OPEN,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							event_point,
							start_point	    => event_point,
							last_point	    => event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };
						    guiboss_to_gadget.note_mouse_drag_event				# We send a DRAG after every OPEN, for the convenience of handlers interested only in coordinates -- they can process all DRAG events and ignore OPEN and DONE events.
						      {									# 
							phase		    => gt::DRAG,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							event_point,
							start_point	    => event_point,
							last_point	    => event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    mouse_is := DRAGGING_IN_GADGET					# Remember which widget mouse is in. SHOULD GENERATE AN 'ENTER' HERE.
								  {
								    gadget_info,
								    start_point => event_point,
								    last_point  => event_point
								  };
						    #
						};	

					    CROSSING_GADGET  { gadget_info => (last_gadget_info as { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET last_guiboss_to_gadget, ... }) }
						=>
						{
						    if (not (same_gadget_info (gadget_info, last_gadget_info)))		# If we just left a gadget, tell it so.
							#
							last_guiboss_to_gadget.note_mouse_transit			# Notify last gadget that we were on that mouse has left its space.
							  {
							    transit		=> gt::LEFT,
							    modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
							    event_point,
							    site		=> *last_gadget_info.site,
							    theme		=> imports.theme
							  };

							guiboss_to_gadget.note_mouse_transit				# Notify new gadget that mouse has entered its space.
							  {
							    transit		=> gt::CAME,
							    modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
							    event_point,
							    site		=> *gadget_info.site,
							    theme		=> imports.theme
							  };
						    fi;

						    guiboss_to_gadget.note_mouse_drag_event				# Tell gadget that user just started a drag operation on it.
						      {									# 
							phase		    => gt::OPEN,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							event_point,
							start_point	    => event_point,
							last_point	    => event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };
						    guiboss_to_gadget.note_mouse_drag_event				# We send a DRAG after every OPEN, for the convenience of handlers interested only in coordinates -- they can process all DRAG events and ignore OPEN and DONE events.
						      {									# 
							phase		    => gt::DRAG,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							event_point,
							start_point	    => event_point,
							last_point	    => event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    mouse_is := DRAGGING_IN_GADGET					# Remember which widget mouse is in.
								  {
								    gadget_info,
								    start_point => event_point,
								    last_point  => event_point
								  };
						    #
						};	

					    DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
						{
						  gadget_info => dragged_gadget_info,					# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
						  start_point,								# This is the window coordinate of the downclick which started this drag.
						  last_point								# This is the window coordinate of the last motion event for this drag.
						}
						=>
						if (same_gadget_info (gadget_info, dragged_gadget_info))		# If we are still on the gadget being dragged...
						    #
						    guiboss_to_gadget.note_mouse_drag_event				# Tell the gadget where the mouse now is.
						      {									# 
							phase		    => gt::DRAG,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							event_point,
							start_point,
							last_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    mouse_is := DRAGGING_IN_GADGET					# Remember new 'last_point' for dragged gadget.
								      {
									gadget_info,
									start_point,
									last_point  => event_point
								      };
						fi;
					esac;
					#	

					# Following note_mousebutton_event stuff is completely independent of drag/motion stuff.

					guiboss_to_gadget.note_mousebutton_event
					  {
					    mousebutton_event	=> gt::MOUSEBUTTON_PRESS,
					    mouse_button	=> button_xevtinfo.mouse_button,
					    modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
					    mousebuttons_state	=> button_xevtinfo.mousebuttons_state,
					    event_point,
					    site		=> *gadget_info.site,
					    theme		=> imports.theme
					  };	

					gadget_info.may_have_visibly_changed :=  TRUE;

					if (not *topwindow_info.done_extra_startframe_this_frame)			# In general we try to draw only one frame per 50HZ SIGALRM clock tick, but to reduce latency we allow one exceptional gadget redraw per tick.
					    #										# 
					    topwindow_info.done_extra_startframe_this_frame := TRUE;

					    # Send a startframe to the gadget:						# See Note[1]
					    #	
					    topwindow_info -> { current_frame_number, ... };
					    gadget_info    -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, site, gadget_mode, may_have_visibly_changed, ... };
					    #
					    guiboss_to_gadget.start_of_frame  { frame_number => *current_frame_number,
										site => *site,
										visible => TRUE,
										duration_in_seconds => 0.0,
										this_gadget_mode => *gadget_mode,
										theme => imports.theme
									      };
					fi;
				    };

				NO_APPROPRIATE_GADGET event_point
				    =>
				    {
					mouse_is = topwindow_info.mouse_is;
					#
					case *mouse_is
					    #
					    CROSSING_NONGADGET
						=>
						();

					    CROSSING_GADGET  { gadget_info }
						=>
						{   gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };
						    #
						    guiboss_to_gadget.note_mouse_transit				# Notify last gadget that we were on that mouse has left its space.
						      {
							transit		    => gt::LEFT,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    mouse_is := CROSSING_NONGADGET;
						};	

					    DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
						{
						  gadget_info => dragged_gadget_info,					# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
						  start_point,								# This is the window coordinate of the downclick which started this drag.
						  last_point								# This is the window coordinate of the last motion event for this drag.
						}
						=>
						();									# When a drag is in progress, we do nothing if we are not on the dragged gadget.
					esac;
				    };
			    esac;
# nb {. sprintf "do_button_press/ZZZ -- guiboss-imp.pkg"; };
			};

		    fun do_button_release												# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
# This arg probably should not be here (because we have multiple running_guis now and passing just one cannot be right) but it appears unused:
			    running_gui:		gt::Running_Gui,
			    button_xevtinfo:		evt::Button_Xevtinfo
			  )
			=
			{
# nb {. sprintf "do_button_release/AAA -- guiboss-imp.pkg"; };
# { button_xevtinfo.mouse_button -> evt::MOUSEBUTTON mousebutton;
#   nb {. sprintf "do_button_release mousebutton %d released" mousebutton; };
#   buttons = button_xevtinfo.mousebuttons_state;
#   nb {. sprintf "do_button_release mousebutton_1_was_down = %B" buttons.mousebutton_1_was_down; };
#   nb {. sprintf "do_button_release mousebutton_2_was_down = %B" buttons.mousebutton_2_was_down; };
#   nb {. sprintf "do_button_release mousebutton_3_was_down = %B" buttons.mousebutton_3_was_down; };
#   nb {. sprintf "do_button_release mousebutton_4_was_down = %B" buttons.mousebutton_4_was_down; };
#   nb {. sprintf "do_button_release mousebutton_5_was_down = %B" buttons.mousebutton_5_was_down; };
# };
			    case (find_appropriate_gadget_info (topwindow_info, button_xevtinfo.event_point))
				#
				APPROPRIATE_GADGET (gadget_info, event_point)						# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				    =>
				    {	gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };
					#
					mouse_is = topwindow_info.mouse_is;

					case *mouse_is
					    #
					    CROSSING_NONGADGET
						=>
						{   gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };
						    #
						    guiboss_to_gadget.note_mouse_transit				# Notify new gadget that mouse has entered its space.
						      {
							transit		    => gt::CAME,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							event_point,
						        site		    => *gadget_info.site,
							theme		    => imports.theme
						      };

						    mouse_is := CROSSING_GADGET { gadget_info };
						    #
						};	

					    CROSSING_GADGET  { gadget_info => gadget_info2 }				# This case should not actually be possible...?  How can we be in CROSSING_GADGET mode with a mousebutton down?
						=>
						if (not (same_gadget_info (gadget_info, gadget_info2)))			# If we just left a gadget, tell it so.
						    #
						    gadget_info2 -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget2, ... };

						    guiboss_to_gadget2.note_mouse_transit				# Notify last gadget that we were on that mouse has left its space.
						      {
							transit	        => gt::LEFT,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							event_point,
							site		=> *gadget_info2.site,
							theme		=> imports.theme
						      };

						    guiboss_to_gadget.note_mouse_transit				# Notify new gadget that mouse has entered its space.
						      {
							transit		=> gt::CAME,
							modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
							event_point,
							site		=> *gadget_info.site,
							theme		=> imports.theme
						      };

						    mouse_is := CROSSING_GADGET { gadget_info };
						fi;

					    DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
						{
						  gadget_info => gadget_info2,						# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
						  start_point,								# This is the window coordinate of the downclick which started this drag.
						  last_point								# This is the window coordinate of the last motion event for this drag.
						}
						=>
						{
						    buttons = button_xevtinfo.mousebuttons_state;
						    #
						    if (evt::pressed_mousebutton_count buttons == 1)			# 'buttons' is state BEFORE the release, so if pressed-button count is 1, all buttons are now released.
							#								# All mouse buttons are now released, so drag operation is over
							gadget_info2 -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget2, ... };

							guiboss_to_gadget2.note_mouse_drag_event			# Tell the drag gadget that drag operation is complete.
							  {								# 
							    phase		=> gt::DONE,
							    modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
							    mousebuttons_state	=> button_xevtinfo.mousebuttons_state,
							    event_point,
							    start_point,
							    last_point,
							    site		=> *gadget_info2.site,
							    theme		=> imports.theme
							  };

							if (not (same_gadget_info (gadget_info, gadget_info2)))		# If we just left a gadget, tell it so.
							    #
							    guiboss_to_gadget2.note_mouse_transit			# Notify drag gadget that we were on that mouse has left its space.
							      {
								transit		    => gt::LEFT,
								modifier_keys_state => button_xevtinfo.modifier_keys_state,
								event_point,
							        site		    => *gadget_info2.site,
								theme		    => imports.theme
							      };

							    guiboss_to_gadget.note_mouse_transit			# Notify new gadget that mouse has entered its space.
							      {
								transit		    => gt::CAME,
								modifier_keys_state => button_xevtinfo.modifier_keys_state,
								event_point,
							        site		    => *gadget_info.site,
								theme		    => imports.theme
							      };
							fi;

							mouse_is := CROSSING_GADGET { gadget_info };			# Remember that drag operation is complete.

						    else								# We still have some mouse buttons down.

							if (same_gadget_info (gadget_info, gadget_info2))		# If we are still on the drag gadget
							    #
							    guiboss_to_gadget.note_mouse_drag_event			# Update the drag gadget with mouse location and buttonstate.
							      {								# 
								phase		    => gt::DRAG,
								modifier_keys_state => button_xevtinfo.modifier_keys_state,
								mousebuttons_state  => button_xevtinfo.mousebuttons_state,
								event_point,
								start_point,
								last_point,
							        site		    => *gadget_info.site,
								theme		    => imports.theme
							      };
							fi;

							mouse_is := DRAGGING_IN_GADGET					# Remember new 'last_point' for dragged gadget.
									  {
									    gadget_info,
									    start_point,
									    last_point  => event_point
									  };
						    fi;
						};	
					esac;
					#	
					guiboss_to_gadget.note_mousebutton_event					# note_mousebutton_event is completely independent of drag/motion stuff.
					  {
					    mousebutton_event		=> gt::MOUSEBUTTON_RELEASE,
					    mouse_button		=> button_xevtinfo.mouse_button,
					    modifier_keys_state		=> button_xevtinfo.modifier_keys_state,
					    mousebuttons_state		=> button_xevtinfo.mousebuttons_state,
					    event_point,
					    site			=> *gadget_info.site,
					    theme			=> imports.theme
					  };

					gadget_info.may_have_visibly_changed :=  TRUE;
				    };

				NO_APPROPRIATE_GADGET event_point
				    =>
				    {
					mouse_is = topwindow_info.mouse_is;
					#
					case *mouse_is
					    #
					    CROSSING_NONGADGET
						=>
						();

					    CROSSING_GADGET  { gadget_info }
						=>
						{   gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };
						    #
						    guiboss_to_gadget.note_mouse_transit				# Notify last gadget that we were on that mouse has left its space.
						      {
							transit	        => gt::LEFT,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							event_point,
							site		=> *gadget_info.site,
							theme		=> imports.theme
						      };

						    mouse_is := CROSSING_NONGADGET;
						};	

					    DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
						{
						  gadget_info,								# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
						  start_point,								# This is the window coordinate of the downclick which started this drag.
						  last_point								# This is the window coordinate of the last motion event for this drag.
						}
						=>
						{   buttons = button_xevtinfo.mousebuttons_state;
						    #
						    gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };

						    if (evt::pressed_mousebutton_count buttons == 1)			# Tell the drag gadget that drag operation is complete.
							#
							guiboss_to_gadget.note_mouse_drag_event				# Notify the drag gadget that the drag operation is now complete.
							  {								# 
							    phase		=> gt::DONE,
							    modifier_keys_state => button_xevtinfo.modifier_keys_state,
							    mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							    event_point		=> last_point,				# event_point is not within drag gadget, so re-use old point here. Apps probably should not use this value, but some will likely ignore the OPEN/DRAG/DONE flag and blindly process all event_points.
							    start_point,
							    last_point,
							    site		=> *gadget_info.site,
							    theme		=> imports.theme
							  };

							guiboss_to_gadget.note_mouse_transit				# Notify drag gadget that mouse has left its space.
							  {
							    transit	        => gt::LEFT,
							    modifier_keys_state => button_xevtinfo.modifier_keys_state,
							    event_point,
							    site		=> *gadget_info.site,
							    theme		=> imports.theme
							  };

							mouse_is := CROSSING_NONGADGET;
						    fi;									# No 'else' here because as long as we're dragging we generate no Gadget_Transit events.
						};
					esac;
				    };											# NO_APPROPRIATE_GADGET case._
			    esac;
# nb {. sprintf "do_button_release/ZZZ -- guiboss-imp.pkg"; };
			};

		    fun do_key_press											# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
# This arg probably should not be here (because we have multiple running_guis now and passing just one cannot be right) but it appears unused:
			    running_gui:		gt::Running_Gui,
			    key_xevtinfo:		evt::Key_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_gadget_info (topwindow_info, key_xevtinfo.event_point))
				#
				APPROPRIATE_GADGET (gadget_info, event_point)						# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				    =>
				    {   printf "guievent_sink()/guiboss/do_key_press: FOUND CANDIDATE!\n";
					#	
					gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };

					guiboss_to_gadget.note_key_event
					  {
					    key_event		=> gt::KEY_PRESS,
					    keycode		=> key_xevtinfo.keycode,
					    keysym		=> key_xevtinfo.keysym,
					    string		=> key_xevtinfo.ascii,
					    modifier_keys_state	=> key_xevtinfo.modifier_keys_state,
	 		    		    mousebuttons_state	=> key_xevtinfo.mousebuttons_state,
					    event_point,
					    site		=> *gadget_info.site,
					    theme		=> imports.theme
					  };	

					gadget_info.may_have_visibly_changed :=  TRUE;
				    };

				NO_APPROPRIATE_GADGET _
				    =>
				    printf "guievent_sink()/guiboss/do_key_press: NO candidate found.\n";
			    esac;
			};

		    fun do_key_release											# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
# This arg probably should not be here (because we have multiple running_guis now and passing just one cannot be right) but it appears unused:
			    running_gui:		gt::Running_Gui,
			    key_xevtinfo:		evt::Key_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_gadget_info (topwindow_info, key_xevtinfo.event_point))
				#
				APPROPRIATE_GADGET (gadget_info, event_point)						# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				    =>
				    {   printf "guievent_sink()/guiboss/do_key_release: FOUND CANDIDATE!\n";
					#	
					gadget_info -> { guiboss_to_gadget => gt::GUIBOSS_TO_GADGET guiboss_to_gadget, ... };

					guiboss_to_gadget.note_key_event
					  {
					    key_event		=> gt::KEY_RELEASE,
					    keycode		=> key_xevtinfo.keycode,
					    keysym		=> key_xevtinfo.keysym,
					    string		=> key_xevtinfo.ascii,
					    modifier_keys_state	=> key_xevtinfo.modifier_keys_state,
	 		    		    mousebuttons_state	=> key_xevtinfo.mousebuttons_state,
					    event_point,
					    site		=> *gadget_info.site,
					    theme		=> imports.theme
					  };	

					gadget_info.may_have_visibly_changed :=  TRUE;
				    };

				NO_APPROPRIATE_GADGET _
				    =>
				    printf "guievent_sink()/guiboss/do_key_release: NO candidate found.\n";
			    esac;
			};


		end;



#		fun kill_popup													# Destroy popup created via make_popup. This is a no-op if arg was not created via make_popup or if popup was already killed.
#		      (
#			popup:			gws::Guiboss_To_Topwindow							# Popup pane.  
#		      )
#		    :				Void
#		    =
# XXX SUCKO FIXME TBD -- this is purely placeholder dummy code.
#		    ();
# 		    kill_popup' popup.backing_pixmap
# 		    where	
# 			fun kill_popup' (backing_pixmap: gt::Backing_Pixmap)
# 			    =
# 			    case backing_pixmap
# 				#
# 				gt::TOPWINDOW_PIXMAP
# 				  { pixmap:		g2p::Gadget_To_Rw_Pixmap,						# Main backing pixmap for this running gui.
#				    pixmaps:		Ref(im::Map(g2p::Gadget_To_Rw_Pixmap)),					# All other X-server side pixmaps allocated by/for this running gui.  We need this to reliably recycle them at gui shutdown -- if we don't, we'll be leaking X server memory.
# 				    popups:		Ref(List(g2p::Gadget_To_Rw_Pixmap)),					# These will all be TOPWINDOW_PIXMAP, but the type system does not let us say that.  	
# 				    parent:		Null_Or( g2p::Gadget_To_Rw_Pixmap ),					# For popups this points to the parent; for the original non-popup window it is NULL.
# 				    stacking_order:	Int,									# Assigned in increasing order starting at 1;  these determine who overlies who visually on the screen in case of overlaps. (Popups must be entirely within parent, but sibling popups can overlap.)
# 				    origin:		Ref(g2d::Point)								# If we have a parent, this gives our location on it. Note that pixmap.size gives our size.
# 				  }
# 				    =>
# 				    case parent
# 					#
# 					THE parent
# 					    =>
# 					    {
# #						new_parent_popups_list
# #						    =
# #						    list::remove  popup_is_us  *parent.popups
# #						    where
# #							fun popup_is_us (popup':	gws::Guiboss_To_Topwindow)
# #							    =
# #							    same_id (popup.id, popup'.id);
# #						    end;
# 
# #						if  (   list::length new_parent_popups_list					# If we've already been removed from parent's popups list then client already called kill_popup() on this popup (or an ancestor) so treat the call as a no-op.
# #							<
# #							list::length *parent.popups
# #						    )
# #						    parent.popups := new_parent_popups_list;					# Do this first to minimize race condition window.  Sloppy...
# 
# #						    apply  kill_popup''  *popup.popups						# Start by killing all of our descendent popups.  We don't expect this to hardly ever happen, so we don't worry about efficiency, just simplicity and correctness.
# #							where
# #							    fun kill_popup'' (x: g2p::Gadget_To_Rw_Pixmap)
# #								=
# #							end;
# 
# 						    pixmap.free_rw_pixmap ();
# #						fi;
# 					    };
# 
# 					NULL  =>    ();										# Client called us on a non-popup window, so just ignore it.
# 				    esac;
# 
# 				gt::VIEWPORT_PIXMAP _										# "Impossible."
# 				    =>
# 				    {   msg = "kill_popup: popup.backing_pixmap == VIEWPORT_PIXMAP unsupported.";
# 					log::fatal msg;										# Something is *really* wrong, so pull the plug.
# 					raise exception FAIL msg;
# 				    };
# 			    esac;
# 		    end;


		fun make_guievent_sink
		      (
# XXX is this arg right? Or should it be a backing_pixmap?
			topwindow_info:		Topwindow_Info,
			saved_events:		Ref (List( (a2r::Envelope_Route, evt::x::Event) ) )				# Somewhere for initial_guievent_sink to save any events it gets.
		      )
		    =	
		    guievent_sink
		    where
			fun guievent_sink (arg as (route: a2r::Envelope_Route, event: evt::x::Event))				# The production Gui_Event handling routine, which locks in the value of 'topwindow_info'.
			    =													# This will run in client's thread.
			    put_in_mailqueue  (guiboss_q,									# Incoming Gui_Event values MUST be run through the guiboss_q to guarantee mutual exclusion on access to internal guiboss datastructures.
				#
				\\ (runstate as { me, imports, ... }: Runstate)							# Now we're running in our own thread, with mutual exclusion and access to our core datastructures.
				    =
				    {
					case *topwindow_info.backing_pixmap
					    #
					    NULL => {   saved_events := arg ! *saved_events;					# When no GUI is running, all we can do is save user input for later processing. (Or maybe discard it?)
printf "guievent_sink()/guiboss: received '%s' Gui_Event but saved it because *topwindow_info.running_gui is NULL.    -- guiboss-imp.pkg\n"
    (gts::gui_event_to_string event);
						    };
					    THE (gt::VIEWPORT_PIXMAP _)
						=>
						{   msg = "VIEWPORT_PIXMAP unsupported in make_guievent_sinkg";
						    log::fatal msg;
						    raise exception FAIL msg;
						};

					    THE (gt::TOPWINDOW_PIXMAP r)
						=>
						case *r.running_gui
						    #
						    NULL => {   saved_events := arg ! *saved_events;					# When no GUI is running, all we can do is save user input for later processing. (Or maybe discard it?)
	printf "guievent_sink()/guiboss: received '%s' Gui_Event but saved it because *topwindow_info.running_gui is NULL.    -- guiboss-imp.pkg\n"
	    (gts::gui_event_to_string event);
							    };

						    THE running_gui
							 =>	{
								case *saved_events
								    #
								    [] =>   {
										case event
										    #
										    evt::x::KEY_PRESS       (key_xevtinfo: evt::Key_Xevtinfo)
											=>
											do_key_press (runstate, topwindow_info, running_gui, key_xevtinfo);

										    evt::x::KEY_RELEASE     (key_xevtinfo: evt::Key_Xevtinfo)
											=>
											do_key_release (runstate, topwindow_info, running_gui, key_xevtinfo);

										    evt::x::BUTTON_PRESS    (button_xevtinfo: evt::Button_Xevtinfo)
											=>
											do_button_press (runstate, topwindow_info, running_gui, button_xevtinfo);

										    evt::x::BUTTON_RELEASE  (button_xevtinfo: evt::Button_Xevtinfo)
											=>
											do_button_release (runstate, topwindow_info, running_gui, button_xevtinfo);

										    evt::x::MOTION_NOTIFY   (motion_xevtinfo: evt::Motion_Xevtinfo)
											=>
											do_motion_notify (runstate, topwindow_info, running_gui, motion_xevtinfo);

										    evt::x::ENTER_NOTIFY    (inout_xevtinfo: evt::Inout_Xevtinfo)
											=>
											{
	#    												printf "guievent_sink()/ENTER_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
											};

										    evt::x::LEAVE_NOTIFY    (inout_xevtinfo: evt::Inout_Xevtinfo)
											=>
											{
	#    												printf "guievent_sink()/LEAVE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
											};

										    evt::x::FOCUS_IN	(focus_xevtinfo: evt::Focus_Xevtinfo)
											=>
											printf "guievent_sink()/FOCUS_IN: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::FOCUS_OUT	(focus_xevtinfo:  evt::Focus_Xevtinfo)
											=>
											printf "guievent_sink()/FOCUS_OUT: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::KEYMAP_NOTIFY    { }
											=>
											printf "guievent_sink()/KEYMAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::EXPOSE           (expose_record:         evt::x::Expose_Record)
											=>
											printf "guievent_sink()/EXPOSE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::GRAPHICS_EXPOSE  (graphics_expose_record: evt::x::Graphics_Expose_Record)
											=>
											printf "guievent_sink()/GRAPHICS_EXPOSE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::NO_EXPOSE
										      { drawable:		evt::Drawable_Id,
											major_opcode:		Unt,						# The graphics operation code.
											minor_opcode:		Unt						# Always 0 for core protocol.
										      }
											=>
											printf "guievent_sink()/NO_EXPOSE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::VISIBILITY_NOTIFY
										      { changed_window_id:	evt::Window_Id,					# The window with changed visibility state.
											state:			evt::Visibility					# The new visibility state.
										      }
											=>
											printf "guievent_sink()/VISIBILITY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::CREATE_NOTIFY
										      { parent_window_id:	evt::Window_Id,					# The created window's parent.
											created_window_id:	evt::Window_Id,					# The created window.
											box:			g2d::Box,					# The window's rectangle.
											border_wid:		Int,						# The width of the border.
											override_redirect:	Bool						#  
										      }
											=>
											printf "guievent_sink()/CREATE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::DESTROY_NOTIFY
										      { event_window_id:	evt::Window_Id,					# The window on which this was generated.
											destroyed_window_id:	evt::Window_Id					# The destroyed window.
										      }
											=>
											printf "guievent_sink()/DESTROY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::UNMAP_NOTIFY
										      { event_window_id:	evt::Window_Id,					# The window on which this was generated.
											unmapped_window_id:	evt::Window_Id,					# The window being unmapped.
											from_config:		Bool						# TRUE if parent was resized.
										      }
											=>
											printf "guievent_sink()/UNMAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::MAP_NOTIFY
										      { event_window_id:	evt::Window_Id,					# The window on which this was generated.
											mapped_window_id:	evt::Window_Id,					# The window being mapped.
											override_redirect:	Bool						#  
										      }
											=>
											printf "guievent_sink()/MAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::MAP_REQUEST
										      { parent_window_id:	evt::Window_Id,					# The parent.
											mapped_window_id:	evt::Window_Id					# The mapped window.
										      }
											=>
											printf "guievent_sink()/MAP_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::REPARENT_NOTIFY
										      { event_window_id:	evt::Window_Id,					# The window on which this was generated.
											parent_window_id:      	evt::Window_Id,					# The new parent.
											rerooted_window_id:    	evt::Window_Id,					# The re-rooted window.
											upperleft_corner:	g2d::Point,					# The upper-left corner.
											override_redirect:	Bool						#  
										      }
											=>
											printf "guievent_sink()/REPARENT_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::CONFIGURE_NOTIFY
										      { event_window_id:       	evt::Window_Id,					# The window on which this was generated.
											configured_window_id:	evt::Window_Id,					# The reconfigured window.
											sibling_window_id:	Null_Or(evt::Window_Id),			# The sibling that window is above (if any).
											box:			g2d::Box,					# The window's rectangle.
											border_wid:  		Int,						# The width of the border.
											override_redirect:	Bool						#  
										      }
											=>
											{
											    printf "guievent_sink()/CONFIGURE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
											};

										    evt::x::CONFIGURE_REQUEST
										      { parent_window_id:	evt::Window_Id,					# The parent.
											configure_window_id:	evt::Window_Id,					# The window to reconfigure.
											sibling_window_id:  	Null_Or(evt::Window_Id),			# The new sibling (if any).
											x:           		Null_Or(Int),					# The window's rectangle.
											y:           		Null_Or(Int),
											wide:        		Null_Or(Int),
											high:        		Null_Or(Int),
											border_wid:  		Null_Or(Int),					# The width of the border.
											stack_mode: 		Null_Or(evt::Stack_Mode)			# The mode for stacking windows.
										      }
											=>
											printf "guievent_sink()/CONFIGURE_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::GRAVITY_NOTIFY
										      {
											event_window_id:	evt::Window_Id,					# The window on which this was generated.
											moved_window_id:   	evt::Window_Id,					# The window being moved.
											upperleft_corner:	g2d::Point					# Upper-left corner of window.
										      }		
											=>
											printf "guievent_sink()/GRAVITY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::RESIZE_REQUEST
										      {
											resize_window_id:	evt::Window_Id,					# The window to resize.
											req_size:		g2d::Size					# The requested new size.
										      }
											=>
											printf "guievent_sink()/RESIZE_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::CIRCULATE_NOTIFY
										      {
											event_window_id:	evt::Window_Id,					# The window on which this was generated.
											circulated_window_id:	evt::Window_Id,					# The window being circulated.
											parent_window_id:	evt::Window_Id,					# The parent.
											place:			evt::Stack_Pos					# The new place.
										      }
											=>
											printf "guievent_sink()/CIRCULATE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::CIRCULATE_REQUEST
										      {
											parent_window_id:	evt::Window_Id,					# The parent.
											circulate_window_id:	evt::Window_Id,					# The window to circulate.
											place:			evt::Stack_Pos					# The place to circulate the window to.
										      }
											=>
											printf "guievent_sink()/CIRCULATE_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::PROPERTY_NOTIFY
										      {
											changed_window_id:	evt::Window_Id,					# The window with the changed property.
											atom:        		evt::Atom,					# The affected property.
											timestamp:  		evt::t::Xserver_Timestamp,			# When the property was changed.
											deleted:     		Bool						# TRUE if the property was deleted.
										      }
											=>
											printf "guievent_sink()/PROPERTY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::SELECTION_CLEAR
										      {
											owning_window_id:	evt::Window_Id,					# The current owner of the selection.
											selection:		evt::Atom,					# The selection.
											timestamp:		evt::t::Xserver_Timestamp			# The last-change time.
										      }		
											=>
											printf "guievent_sink()/SELECTION_CLEAR: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::SELECTION_REQUEST
										      {
											owning_window_id:	evt::Window_Id,					# The owner of the selection.
											selection:		evt::Atom,					# The selection.
											target:			evt::Atom,					# The requested type for the selection.
											requesting_window_id:	evt::Window_Id,					# The requesting window.
											property:		Null_Or( evt::Atom ),				# The property to store the selection in. 
											timestamp:		evt::Timestamp					#  
										      }
											=>
											printf "guievent_sink()/SELECTION_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::SELECTION_NOTIFY
										      {
											requesting_window_id:	evt::Window_Id,					# The requestor of the selection.
											selection:		evt::Atom,					# The selection.
											target:			evt::Atom, 					# The requested type of the selection.
											property:		Null_Or( evt::Atom ),				# The property to store the selection in.
											timestamp:		evt::Timestamp  				#  
										      }
											=>
											printf "guievent_sink()/SELECTION_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::COLORMAP_NOTIFY
										      {
											window_id:		evt::Window_Id,					# The affected window.
											cmap:			Null_Or( evt::Colormap_Id ),			# The colormap.
											new:			Bool,						# TRUE, if the colormap attribute is changed.
											installed: 		Bool						# TRUE, if the colormap is installed.
										      }
											=>
											printf "guievent_sink()/COLORMAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::CLIENT_MESSAGE
										      {
											window_id:		evt::Window_Id,					#  
											type:			evt::Atom,					# The type of the message.
											value:			evt::Raw_Data					# The message value.
										      }
											=>
											printf "guievent_sink()/CLIENT_MESSAGE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::MODIFIER_MAPPING_NOTIFY						# Really a MappingNotify event.
											=>
											printf "guievent_sink()/MODIFIER_MAPPING_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::KEYBOARD_MAPPING_NOTIFY						# Really a MappingNotify event.
										      {
											first_keycode:  	evt::Keycode,
											count:          	Int
										      }
											=>
											printf "guievent_sink()/KEYBOARD_MAPPING_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    evt::x::POINTER_MAPPING_NOTIFY						# Really a MappingNotify event.
											=>
											printf "guievent_sink()/POINTER_MAPPING_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										esac;										# NB: We avoid a '_' case here because if an event is added to evt::x::Event we want a compile error as a reminder to handle it.

									    };

								    _  =>   {											# Woops, we have prior events that came in before we were ready to process them.
										saved_events := arg ! *saved_events;						# Add latest event to saved-events list.
										events = reverse *saved_events;							# Reverse saved-events list so we process them in first-in-first-out order.
										saved_events := [];								# Clear saved-events so  we don't process any of them twice.
										apply guievent_sink events;							# Recursively process all saved events in order.  NB: Any new events that arrive during this will just accumulate on guiboss_q. That's fine.
									    };											# 
								esac;
							    };

						esac;
					esac;
				    }															# In-private-thread part of fun guievent_sink.
			    );																# fun guievent_sink
		    end;

		fun make_topwindow  (hints:	gws::Topwindow_Hints)											# PUBLIC.
		    :				gws::Guiboss_To_Topwindow
		    =																	# This will run in client's thread.
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( gws::Guiboss_To_Topwindow );
# reply_oneshot is NOT locked into guievent_sink.
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ me, imports, ... }: Runstate)												# Now we're running in our own thread, with mutual exclusion and access to our core datastructures.
				=
				{   # We have to do an awkward little dance here because we
				    # must hand a guievent_sink() TO make_topwindow() but we
				    # want guievent_sink() to lock in the 'topwindow' result
				    # FROM make_topwindow():

# saved_events IS directly locked into guievent_sink 
				    saved_events = REF ([]: List( (a2r::Envelope_Route, evt::x::Event) ) );						# Somewhere for initial_guievent_sink to save any events it gets.

# guievent_sink_fn is NOT directly locked into  guievent_sink()  (but it is indirectly locked via topwindow_info -> guiboss_to_topwindow).
				    guievent_sink_fn
					=
					REF initial_guievent_sink
					where
					    fun initial_guievent_sink (arg as (route: a2r::Envelope_Route, event: evt::x::Event))			# An initial version which just saves events in 'saved_events' until we're ready to process them, since we don't yet have 'topwindow' available.
						=													# This will run in client's thread.
						saved_events :=  arg ! *saved_events;
				        end;


				    guiboss_to_topwindow
					=
					imports.guiboss_to_windowsystem.make_topwindow									# XXX SUCKO FIXME we're blocking until we get the result from windowsystem.
					    #
					    (hints, guievent_sink_wrapper)
					    where
						fun guievent_sink_wrapper (arg as (route: a2r::Envelope_Route, event: evt::x::Event))			# A wrapper which initially calls initial_guievent_sink but almost immediately switches to calling the production guievent_sink.
						    =													# This will run in client's thread.
						    *guievent_sink_fn  arg;
				    	    end;


				    topwindow_info       =    { guiboss_to_topwindow,									# Remember our handle for the topwindow.
								backing_pixmap			=>   REF NULL,						# Remember that we do not yet have a GUI running on the topwindow.
								#
								bounce_imps			=>  (REF im::empty): Bounce_Imps,			# Holds our gt::Guiboss_To_Bouncespace instances -- can't put them directly in Running_Gui due to circularity.
								canvas_imps			=>  (REF im::empty): Canvas_Imps,			# Holds our gt::Guiboss_To_Canvasspace instances -- can't put them directly in Running_Gui due to circularity.
								packed_imps			=>  (REF im::empty): Packed_Imps,			# Holds our gt::Guiboss_To_Packedspace instances -- can't put them directly in Running_Gui due to circularity.
								gadget_imps			=>  (REF im::empty): Gadget_Imps,			# Holds look-imps for all the widgets in our gui.
								#
								current_frame_number		=>  (REF 1),						# We count frames for convenience of widgets and debugging.
								seconds_per_frame		=>  (REF 0.01),						# Let's initially assume a nominal ten frames per second. Passed to widgets primarily so widgets can do motion blurring if they wish.
								#
								mouse_is			=>  (REF CROSSING_NONGADGET), 				# Mouse is not currently dragging, and in fact not currently known to be on any particular widget.
								#
								done_extra_startframe_this_frame=>  (REF FALSE),
								#
								next_stacking_order		=>  (REF 2)
							      };

				    me.topwindows													# Remember that we have a new topwindow to manage.
					:=
					im::set ( *me.topwindows,
						  id_to_int guiboss_to_topwindow.id,
						  topwindow_info
						);

				    guievent_sink
					=
					make_guievent_sink (topwindow_info, saved_events);

				    guievent_sink_fn  :=  guievent_sink;							# Switch guievent_sink_wrapper() over from using initial_guievent_sink() to using guievent_sink().


				    put_in_oneshot (reply_oneshot, guiboss_to_topwindow);
				}												# In-private-thread part of fun make_topwindow.
		        );													# put_in_mailqueue call.

			get_from_oneshot  reply_oneshot;
		    };														# fun make_topwindow

		#
		fun pause_gui
		      (
			running_gui:		gt::Running_Gui,							# Private
			bounce_imps:		Bounce_Imps,
			canvas_imps:		Canvas_Imps,
			packed_imps:		Packed_Imps,
			gadget_imps:		Gadget_Imps,
			topwindow_info:		Topwindow_Info
		      )
		      : gt::Paused_Gui
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Paused_Gui );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				put_in_oneshot  (reply_oneshot,  pause_gui' (runstate, (running_gui, bounce_imps, canvas_imps, packed_imps, gadget_imps, topwindow_info)))
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun kill_gui
		      (
			running_gui:		gt::Running_Gui,							# Private
			bounce_imps:		Bounce_Imps,
			canvas_imps:		Canvas_Imps,
			packed_imps:		Packed_Imps,
			gadget_imps:		Gadget_Imps,
			topwindow_info:		Topwindow_Info
		      )
		      : Void
		    =	
		    {
nb {. sprintf "kill_gui/AAA: (%s): , running_gui.topwindow_pixmap " (gt::backing_pixmap_id running_gui.topwindow_pixmap); };
gt::pprint_backing_pixmap (running_gui.topwindow_pixmap);
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				kill_gui' (runstate, (running_gui, bounce_imps, canvas_imps, packed_imps, gadget_imps, topwindow_info, TRUE))
			);

			();
		    };
		#
		fun start_gui												# PUBLIC.
		      (
			topwindow_for_gui:	gws::Guiboss_To_Topwindow,
			gui_plan:		gt::Gui_Plan
		      )
		    : (Void -> gt::Client_To_Guiwindow)
		    =	
		    {   gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Client_To_Guiwindow );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{   topwindow_pixmap =  make_base_backing_pixmap  topwindow_for_gui.backing_pixmap;
				    #
				    start_gui' (runstate, topwindow_for_gui, topwindow_pixmap, gui_plan, gui_startup_complete', guiboss_q, pause_gui, kill_gui);
				}
		        );

			{.   get_from_oneshot  gui_startup_complete';   };
		    };

		#
		fun restart_gui												# PUBLIC.
		      (
			topwindow_for_gui:	gws::Guiboss_To_Topwindow,
			paused_gui: 		gt::Paused_Gui
		      )
		    : (Void -> gt::Client_To_Guiwindow)
		    =	
		    {   gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Client_To_Guiwindow );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{   topwindow_pixmap =  make_base_backing_pixmap topwindow_for_gui.backing_pixmap;
				    #
				    restart_gui' (runstate, topwindow_for_gui, topwindow_pixmap, paused_gui, gui_startup_complete', guiboss_q, pause_gui, kill_gui);
				}
		        );

			{.   get_from_oneshot  gui_startup_complete';   };
		    };

		#
		fun get_bounce_theme ()											# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( bt::Gui_To_Bounce_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.gui_to_bounce_theme)
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun get_canvas_theme ()											# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( ct::Gui_To_Canvas_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.gui_to_canvas_theme)
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun get_packed_theme ()											# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( pt::Packed_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.theme)
			);

			get_from_oneshot reply_oneshot;
		    };
	    end;

	#
	fun process_options (options: List(Guiboss_Option), { name, id })
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME	n) =>   my_name			:=  n;
			do_option (ID			i) =>   my_id                   :=  i;
		    end;
		end;

		{ name			=>  *my_name,
		  id 			=>   *my_id
		};
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_guiboss_egg
	      (guiboss_arg:		Guiboss_Arg)									# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	    =
	    {	guiboss_arg ->  (guiboss_options);									# Currently no guiboss_needs component, so this is a no-op.
		#
		(process_options
		  ( guiboss_options,
		    { name		=> "guiboss",
		      id		=>  id_zero
		    }
		) )
		    ->
		    { name,
		      id
		    };
	
		my (id, guiboss_options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();										# Allocate unique imp id.
			(id, ID id ! guiboss_options);									# Make our id stable across stop/restart cycles.
		    else
			(id, guiboss_options);
		    fi;

		guiboss_arg = (guiboss_options);									# Currently no guiboss_needs component, so this is a no-op.

		me =  {
			topwindows	=>  REF im::empty								# Track all topwindows created by our make_topwindow() entrypoint.
		      };

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );		# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));					# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3											# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, guiboss_arg, imports, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;


##########################################################################
# Note[1]
#
# This package is not aimed at gaming where 120 frames per second is welcome,
# but rather at visualization apps etc where the background processing is the
# point and we don't want the display subsystem eating inordinate amounts of
# CPU power.  Consequently in general we throttle screen update to ten frames
# per second or so, controlled by 'seconds_per_frame' in frameclock().
#
# But we do want to minimize response latency to clicking on a widget, so
# we implement a special hack allowing one widget per frame to redraw
# immediately instead of having to wait for the next frame redraw time.
# This hack is controlled by
#	done_extra_startframe_this_frame:	Ref(Bool),


##########################################################################
# Note[2]  Pop-up Design Considerations:
#
# o As a practical matter we expect typically just one
#   popup at a time, either a tooltip or a dialog, so
#   we try to avoid adding too much semantic and implementation
#   complexity in service of the remaining rarer cases.
#
#   Also, we don't worry much about the efficiency of the
#   complex cases which we expect to be vanishingly rare:
#   we use simple O(N**2) algorithms for our overlapping-
#   update cases rather than implementing and using
#   sophisticated spatial datastructures.
#
# o For simplicity and portability we do popups entirely
#   within guiboss-imp, as opposed to using one separate
#   X window per popup.  This leaves the door open to
#   ports to non-X substrates which do not naturally
#   support extra windows, perhaps OpenGL or simple
#   hardware framebuffers.
#
# o We support multiple simultaneous popups on a given
#   topwindow because this has the simplest, most natural
#   semantics:  on a big GUI on a 30" monitor there is no
#   reason that a popup or tooltip in one corner should
#   block a popup or tooltip in another corner.
#
# o We expect each popup to fit entirely within its parent,
#   but it seems unnatural and inconvenient to insist that
#   sibling popups sharing a parent not overlap, so for
#   simplest semantics we allow such overlaps.  
#
# o For similar considerations of clean semantics we support
#   popups on popups:  We want each popup to support the same
#   GUI semantics as the underlying parent gui window.
#
# o We resolve sibling overlaps via a global stacking order,
#   with younger windows overlaying older ones.  At some point
#   we may want to support popping windows to the top of the
#   stacking order:  In that case we'll have to make stacking_order
#   fields mutuable and trigger a redraw after updating them.
#
# o I do not see any need to have pop-ups belong to views and
#   thus be partially visible through a viewport.  The point
#   of a popup is to be attention-getting and visible, so having
#   hidden popups seems counterproductive.  Consequently we do not
#   (further!) complicate the implementation problem by requiring
#   support for that.




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
