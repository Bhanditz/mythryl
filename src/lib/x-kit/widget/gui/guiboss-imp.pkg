## guiboss-imp.pkg
#
# For the big picture see the imp dataflow diagrams in
#
#     src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
#
# The master imp responbible for GUI window startup and shutdown,
# driven by   Stopped_Gui specs					# stopped_gui			is from   src/lib/x-kit/widget/gui/stopped-gui.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
#   package rgb =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    package bli =      ball_look_imp;				#     ball_look_imp		is from   src/lib/x-kit/widget/xkit/theme/bounce/default/look/ball-look-imp.pkg
    package nli =      node_look_imp;				#     node_look_imp		is from   src/lib/x-kit/widget/xkit/theme/canvas/default/look/node-look-imp.pkg
    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  gui_types;					# gui_types			is from   src/lib/x-kit/widget/gui/gui-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    package gp  =  gui_plan;					# gui_plan			is from   src/lib/x-kit/widget/gui/gui-plan.pkg
    package sg  =  stopped_gui;					# stopped_gui			is from   src/lib/x-kit/widget/gui/stopped-gui.pkg
    package rg  =  running_gui;					# running_gui			is from   src/lib/x-kit/widget/gui/running-gui.pkg

    package bt  =  gui_to_bounce_theme;				# gui_to_bounce_theme		is from   src/lib/x-kit/widget/theme/bounce/gui-to-bounce-theme.pkg
    package ct  =  gui_to_canvas_theme;				# gui_to_canvas_theme		is from   src/lib/x-kit/widget/theme/canvas/gui-to-canvas-theme.pkg
    package tp  =  gui_to_packed_theme;				# gui_to_packed_theme		is from   src/lib/x-kit/widget/theme/packed/gui-to-packed-theme.pkg

    package os  =  guiboss_to_bounce_space;			# guiboss_to_bounce_space	is from   src/lib/x-kit/widget/space/bounce/guiboss-to-bounce-space.pkg
    package cs  =  guiboss_to_canvas_space;			# guiboss_to_canvas_space	is from   src/lib/x-kit/widget/space/canvas/guiboss-to-canvas-space.pkg
    package ps  =  guiboss_to_packed_space;			# guiboss_to_packed_space	is from   src/lib/x-kit/widget/space/packed/guiboss-to-packed-space.pkg

    package bs  =    ball_state;				# ball_state			is from   src/lib/x-kit/widget/space/bounce/ball/ball-state.pkg
    package ns  =    node_state;				# node_state			is from   src/lib/x-kit/widget/space/canvas/node/node-state.pkg

    package boi =  bounce_space_imp;				# bounce_space_imp		is from   src/lib/x-kit/widget/space/bounce/bounce-space-imp.pkg
    package cai =  canvas_space_imp;				# canvas_space_imp		is from   src/lib/x-kit/widget/space/canvas/canvas-space-imp.pkg
    package pai =  packed_space_imp;				# packed_space_imp		is from   src/lib/x-kit/widget/space/packed/packed-space-imp.pkg

    package bsi =    ball_state_imp;				#   ball_state_imp		is from   src/lib/x-kit/widget/space/bounce/ball/ball-state-imp.pkg
    package nsi =    node_state_imp;				#   node_state_imp		is from   src/lib/x-kit/widget/space/canvas/node/node-state-imp.pkg

    package bs  =    ball_state;				#   ball_state			is from   src/lib/x-kit/widget/space/bounce/ball/ball-state.pkg
    package ns  =    node_state;				#   node_state			is from   src/lib/x-kit/widget/space/canvas/node/node-state.pkg

    
    package c2b =   client_to_ball_state;			# client_to_ball_state		is from   src/lib/x-kit/widget/space/bounce/client-to-ball-state.pkg
    package c2n =   client_to_node_state;			# client_to_node_state		is from   src/lib/x-kit/widget/space/canvas/client-to-node-state.pkg
    #    
    package g2w =  guiboss_to_windowsystem;			# guiboss_to_windowsystem	is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg
    package g2l =  gui_to_look;					# gui_to_look			is from   src/lib/x-kit/widget/gui/gui-to-look.pkg

    package blh =  bounce_space_layout_hint;			# bounce_space_layout_hint	is from   src/lib/x-kit/widget/space/bounce/bounce-space-layout-hint.pkg
    package clh =  canvas_space_layout_hint;			# canvas_space_layout_hint	is from   src/lib/x-kit/widget/space/canvas/canvas-space-layout-hint.pkg
    package plh =  packed_space_layout_hint;			# packed_space_layout_hint	is from   src/lib/x-kit/widget/space/packed/packed-space-layout-hint.pkg

    package b2l =  bounce_to_look;				# bounce_to_look		is from   src/lib/x-kit/widget/space/bounce/bounce-to-look.pkg
    package c2l =  canvas_to_look;				# canvas_to_look		is from   src/lib/x-kit/widget/space/canvas/canvas-to-look.pkg
    package p2l =  packed_to_look;				# packed_to_look		is from   src/lib/x-kit/widget/space/packed/packed-to-look.pkg

    package l2b =  look_to_bounce;				# look_to_bounce		is from   src/lib/x-kit/widget/space/bounce/look-to-bounce.pkg
    package l2c =  look_to_canvas;				# look_to_canvas		is from   src/lib/x-kit/widget/space/canvas/look-to-canvas.pkg
    package l2p =  widget_to_packedspace;			# widget_to_packedspace		is from   src/lib/x-kit/widget/space/packed/widget-to-packedspace.pkg

    package s2g =   space_to_gui;				# space_to_gui			is from   src/lib/x-kit/widget/gui/space-to-gui.pkg
    package l2g =    widget_to_guiboss;				# widget_to_guiboss			is from   src/lib/x-kit/widget/gui/widget-to-guiboss.pkg
    package c2g =  client_to_guiboss;				# client_to_guiboss		is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg

    package iul =  issue_unique_look_id;			# issue_unique_look_id		is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg

    package xg  =  xgeometry;					# xgeometry			is from   src/lib/std/2d/xgeometry.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

    dummy1 = evt::t::bin_op;		# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
    dummy2 = gts::gui_event_name;	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
herein

    package guiboss_imp
    :       Guiboss_Imp													# Guiboss_Imp		is from   src/lib/x-kit/widget/gui/guiboss-imp.api
    {
	include package   client_to_guiboss;										# client_to_guiboss	is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
	#

	Imports = {													# Ports we use, provided by other imps.
		    int_sink:			Int -> Void,
		    guiboss_to_windowsystem:	g2w::Guiboss_To_Windowsystem,	
		    gui_to_bounce_theme:	bt::Gui_To_Bounce_Theme,
		    gui_to_canvas_theme:	ct::Gui_To_Canvas_Theme,
		    gui_to_packed_theme:	tp::Gui_To_Packed_Theme
		  };

	Bounce_Imps
	  =
	  Ref( im::Map( { look_to_bounce:		l2b::Look_To_Bounce,						# Possibly this should be stored in Running_Gui rather than here; time will tell. This is a good first try.
			  guiboss_to_bounce_space:	os::Guiboss_To_Bounce_Space,
			  endstate_oneshot:		Oneshot_Maildrop( os::Bounce_Space_Arg )
			}
	     )        );

	Canvas_Imps
	  =
	  Ref( im::Map( { look_to_canvas:		l2c::Look_To_Canvas,						# Possibly this should be stored in Running_Gui rather than here; time will tell. This is a good first try.
			  guiboss_to_canvas_space: 	cs::Guiboss_To_Canvas_Space,
			  endstate_oneshot:		Oneshot_Maildrop( cs::Canvas_Space_Arg )
			}
	     )        );

	Packed_Imps
	  =
	  Ref( im::Map( { widget_to_packedspace:		l2p::Widget_To_Packedspace,						# Possibly this should be stored in Running_Gui rather than here; time will tell. This is a good first try.
			  guiboss_to_packed_space: 	ps::Guiboss_To_Packed_Space,
			  endstate_oneshot:		Oneshot_Maildrop( ps::Packed_Space_Arg )
			}
	     )        );


	Site = Ref( xg::Box );												# Pixel-rectangle assigned to the widget, in window coordinates.

	Look_Imp_Info
	  =
	  { gui_to_look:		g2l::Gui_To_Look,								# We use this to make requests of visible widgets.
	    foreground:			Ref( Null_Or( gd::Gui_Displaylist )),
	    background:			Ref( Null_Or( gd::Gui_Displaylist )),
	    site:			Site
	  };

	Look_Imps
	  =
	  Ref( im::Map( Look_Imp_Info ) );										# We use this to make requests of visible widgets.

	Topwindow_Info
	  =
	  { # These three are valid throughout
	    # the lifetime of the topwindow:
	    #
	    guiboss_to_topwindow:	g2w::Guiboss_To_Topwindow,
	    current_frame_number:	Ref(Int),									# We count frames for convenience of widgets and debugging.
	    seconds_per_frame:		Ref(Float),									# Primarily so widgets can do motion blurring if they wish.


	    # The remainder are valid only while a gui is running,
	    # which is to say, between restart_gui' and stop_gui':

	    # These three are set by restart_gui'()
	    # and reset to NULL by stop_gui'     
	    #
	    running_gui:		Ref( Null_Or( rg::Running_Gui  ) ),
	    widget_to_guiboss:		Ref( Null_Or( l2g::Widget_To_Guiboss ) ),						# Interface for look-imps to contact us.
	    space_to_gui:		Ref( Null_Or( s2g::Space_To_Gui) ),						# Interface for space-imps to contact us.

	    # These four are reset to im::empty by stop_gui';
	    #
	    look_imps:			Look_Imps,									# Holds our     Look_Imp_Info           instances -- basically, all running widgets in topwindow.
	    bounce_imps:		Bounce_Imps,									# Holds our os::Guiboss_To_Bounce_Space instances -- can't put them directly in Running_Gui due to circularity.
	    canvas_imps:		Canvas_Imps,									# Holds our cs::Guiboss_To_Canvas_Space instances -- can't put them directly in Running_Gui due to circularity.
	    packed_imps:		Packed_Imps									# Holds our ps::Guiboss_To_Packed_Space instances -- can't put them directly in Running_Gui due to circularity.
	  };

	Guiboss_State													# Holds all nonephemeral mutable state maintained by shape.
	  =
	  {
	    topwindows:			Ref( im::Map( Topwindow_Info  ) )						# Each call to client_to_guiboss.make_topwindow() adds one entry to this.  Indexed by guiboss_to_topwindow.id.
	  };

	Me_Slot = Mailslot( { imports:		Imports,
			      me:		Guiboss_State,
			      guiboss_arg:	Guiboss_Arg,
			      run_gun':		Run_Gun,
			      end_gun':		End_Gun
			    }
			  );

	Exports	= {													# Ports we provide for use by other imps.
		    client_to_guiboss:	Client_To_Guiboss
		  };


	Guiboss_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);


	Runstate =    {													# These values will be statically globally visible throughout the code body for the imp.
			me:			Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
			guiboss_arg:		Guiboss_Arg,
			imports:		Imports,								# Imps to which we send requests.
			to:			Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
			end_gun':		End_Gun,								# We shut down the microthread when this fires.
			id:			Id
		      };

	Guiboss_Q    = Mailqueue( Runstate -> Void );

	fun run ( guiboss_q:		Guiboss_Q,									# 
		  #
		  runstate as
		  {													# These values will be statically globally visible throughout the code body for the imp.
		    me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		    guiboss_arg:		Guiboss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# We shut down the microthread when this fires.
		    id:				Id
		  }
		)
	    =
	    {	loop ();
	    }
	    where


		#
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    end_gun'                       ==>  shut_down_guiboss_imp',
			    take_from_mailqueue' guiboss_q ==>  do_guiboss_plea
			];

			loop ();
		    }	
		    where
			fun do_guiboss_plea  thunk
			    =
			    thunk runstate;
			#
			fun shut_down_guiboss_imp' ()
			    =
			    {
				thread_exit { success => TRUE };							# Will not return.	
			    };
		    end;
	    end;	
	#
	fun stop_gui'
	      (
		{ me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		  guiboss_arg:			Guiboss_Arg,
		  imports:			Imports,								# Imps to which we send requests.
		  to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		  end_gun':			End_Gun,
		  id:				Id
		}:				Runstate,
		( running_gui:			rg::Running_Gui,
		  bounce_imps:			Bounce_Imps,
		  canvas_imps:			Canvas_Imps,
		  packed_imps:			Packed_Imps,
		  look_imps:			Look_Imps,
		  topwindow_info:		Topwindow_Info
		)
	      )
	    =
	    {
nb {. sprintf "top_gui' doing fire_end_gun() -- guiboss-imp.pkg" ;};
		running_gui.fire_end_gun ();									# Shut down GUI impnet.
nb {. sprintf "stop_gui' done  fire_end_gun() -- guiboss-imp.pkg" ;};
		result = running_gui__to__stopped_gui  running_gui;						# Return sufficient information to recreate the GUI.

		# Clear state which is only valid while the gui is running:
		#
		topwindow_info.running_gui  := NULL;
		topwindow_info.widget_to_guiboss  := NULL;
		topwindow_info.space_to_gui := NULL;
		#
		topwindow_info.bounce_imps  := im::empty;
		topwindow_info.canvas_imps  := im::empty;
		topwindow_info.packed_imps  := im::empty;
		topwindow_info.look_imps    := im::empty;

nb {. sprintf "stop_gui': packed_imps := im::empty   -- guiboss-imp.pkg" ;};

		result:				sg::Stopped_Gui;
	    }													#
	    where
		fun running_gui__to__stopped_gui
		    # 
		    (running_gui: 	rg::Running_Gui)
		    :
		    ( ps::Packed_Space_Arg,
		      sg::Packed_Widget
		    )
		    =
		    {
nb {. sprintf "running_gui__to__stopped_gui/AAA" ;};
			running_gui ->    { fire_end_gun:	Void -> Void,							# Signal which will shut down the GUI impnet.
					    #
					    packed_space_id:	rg::Packed_Space_Id,						# Runtime GUI state synthesized locally per client spec.
					    packed_widget:	rg::Packed_Widget,						# "                                       ".
					    topwindow:		g2w::Guiboss_To_Topwindow
					  };

nb {. sprintf "running_gui__to__stopped_gui/BBB -- calling do_packed_widget..." ;};
			packed_widget''
			    =
			    do_packed_widget  packed_widget;

			(im::get_or_raise_exception_not_found (*packed_imps, (id_to_int packed_space_id)))
			    ->
			    { widget_to_packedspace, guiboss_to_packed_space, endstate_oneshot };	

nb {. sprintf "running_gui__to__stopped_gui/ZZZ -- called  do_packed_widget..." ;};
			( get_from_oneshot   endstate_oneshot,								# Read final state of packed-space-imp -- incidentally confirming that it has completed its shutdown.
			  packed_widget''
			);
		    }

		also
		fun do_packed_widget  (packed_widget: rg::Packed_Widget)
		    =
		    case packed_widget
			#
			rg::ROW	{ widgets: List( (rg::Packed_Widget, rg::Packed_Layout_Hints, List(plh::Packed_Space_Layout_Hint)) ) }
			    =>
			    sg::ROW (map  do_widget  widgets)
				    where
					fun do_widget ( packed_widget:	rg::Packed_Widget,
							hints: 		rg::Packed_Layout_Hints,
							raw_hints:	List(plh::Packed_Space_Layout_Hint)
						      )
					    =
					    ( do_packed_widget  packed_widget,
					      raw_hints
					    );
				    end;	

			rg::COL	{ widgets: List( (rg::Packed_Widget, rg::Packed_Layout_Hints, List(plh::Packed_Space_Layout_Hint)) ) }
			    =>
			    sg::COL (map  do_widget  widgets)
				    where
					fun do_widget ( packed_widget:	rg::Packed_Widget,
							hints:	 	rg::Packed_Layout_Hints,
							raw_hints:	List(plh::Packed_Space_Layout_Hint)
						      )
					    =
					    ( do_packed_widget  packed_widget,
					      raw_hints
					    );
				    end;	

# SOON! (This is intended to replace the following six):
			rg::WIDGET r
			    =>
			    sg::WIDGET (get_from_oneshot   r.endstate_oneshot);			# Read and return final state of widget-imp -- incidentally confirming that it has completed its shutdown.


			#
			rg::CANVAS_SPACE  canvas_space
			    =>
{
nb {. sprintf "running_gui__to__stopped_gui: do_packed_widget: rg::CANVAS_SPACE..." ;};
result =
			    do_canvas_space  canvas_space;
result; };

			rg::BOUNCE_SPACE  bounce_space
			    =>
{
nb {. sprintf "running_gui__to__stopped_gui: do_packed_widget: rg::BOUNCE_SPACE..." ;};
result =
			    do_bounce_space  bounce_space;
result; };

			rg::NULL_PACKED_WIDGET
			    =>
			    sg::NULL_PACKED_WIDGET;
		    esac


		also
		fun do_bounce_space r
		    =
		    {
			widgets =  do_bounce_widgets  r.widgets;
			#
			(im::get_or_raise_exception_not_found (*bounce_imps, (id_to_int r.bounce_space_id)))
			    ->
			    { guiboss_to_bounce_space, look_to_bounce, endstate_oneshot };

			arg =  get_from_oneshot  endstate_oneshot;

		        sg::BOUNCE_SPACE (arg, widgets);
		    }

		also
		fun do_bounce_widgets (widgets':  List ((rg::Bounce_Widget, List(blh::Bounce_Space_Layout_Hint))))
		    =
		    {
			widgets'' = map  do_widget  widgets'
				    where
					fun do_widget' (widget': rg::Bounce_Widget)
					    =
					    case widget'
						#
						rg::BALL r
						    =>
						    sg::BALL ( get_from_oneshot   r.endstate_oneshot,	# Read and return final state of state-imp -- incidentally confirming that it has completed its shutdown.
							       get_from_oneshot    r.endlook_oneshot	# Read and return final state of  look-imp -- incidentally confirming that it has completed its shutdown.
							     );
					    esac;
					#
					fun do_widget (widget': rg::Bounce_Widget,  layout_hints:  List(blh::Bounce_Space_Layout_Hint))
					    =
					    {   widget'' = do_widget'  widget';
						#
						(widget'', layout_hints);
					    };
				    end;

			widgets'';
		    }


		also
		fun do_canvas_space r
		    =
		    {	widgets =  do_canvas_widgets  r.widgets;
			#
			(im::get_or_raise_exception_not_found (*canvas_imps, (id_to_int r.canvas_space_id)))
			    ->
			    { guiboss_to_canvas_space, look_to_canvas, endstate_oneshot };

			arg =  get_from_oneshot  endstate_oneshot;

		        sg::CANVAS_SPACE (arg, widgets);
		    }

		also
		fun do_canvas_widgets (widgets':  List ((rg::Canvas_Widget, List(clh::Canvas_Space_Layout_Hint))))
		    =
		    {
			widgets'' = map  do_widget  widgets'
				    where
					fun do_widget' (widget': rg::Canvas_Widget)
					    =
					    case widget'
						#
						rg::NODE r
						    =>
						    sg::NODE ( get_from_oneshot   r.endstate_oneshot,	# Read and return final state of state-imp -- incidentally confirming that it has completed its shutdown.
							       get_from_oneshot    r.endlook_oneshot	# Read and return final state of  look-imp -- incidentally confirming that it has completed its shutdown.
							     );

						rg::PACKED_SPACE
						      { packed_space_id:	rg::Packed_Space_Id,
							packed_widget:		rg::Packed_Widget
						      }
						    =>
						    {	packed_widget'' =  do_packed_widget packed_widget;
							#
							(im::get_or_raise_exception_not_found (*packed_imps, (id_to_int packed_space_id)))
							    ->
							    { widget_to_packedspace, guiboss_to_packed_space, endstate_oneshot };

							sg::PACKED_SPACE
							  (
							    get_from_oneshot   endstate_oneshot,		# Read and return final state of packed-space-imp -- incidentally confirming that it has completed its shutdown.
							    packed_widget''
							  );
						    };
					    esac;
					#
					fun do_widget (widget': rg::Canvas_Widget,  layout_hints:  List(clh::Canvas_Space_Layout_Hint))
					    =
					    {   widget'' = do_widget'  widget';
						#
						(widget'', layout_hints);
					    };
				    end;

			widgets'';
		    };													# fun do_canvas_widgets
	    end;
	#
	fun restart_gui'
	      (
		runstate as
		  { me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		    guiboss_arg:		Guiboss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# We shut down the microthread when this fires.
		    id:				Id
		  }:				Runstate,
	
		topwindow_for_gui:		g2w::Guiboss_To_Topwindow,
		stopped_gui:			sg::Stopped_Gui,

		gui_startup_complete':		Oneshot_Maildrop( c2g::Client_To_Guiwindow ),
		guiboss_q:			Guiboss_Q,
		stop_gui:			(rg::Running_Gui, Bounce_Imps, Canvas_Imps, Packed_Imps, Look_Imps, Topwindow_Info) -> sg::Stopped_Gui
	      )
	    =
	    {

		#
		running_gui = stopped_gui__to__running_gui  (stopped_gui, topwindow_for_gui);				# Starts up all widget look-imps and state-imps plus the canvas- bounce- and packed-space imps,
															# and populates our bounce_imps, canvas_imps, packed_imps and look_imps maps.

		topwindow_info.running_gui :=  THE running_gui;								# Remember that we now have a gui running on this topwindow.

		fire_run_gun ();

		topwindow_for_gui.pass_window_site to
		    #
		    (\\ ({ size => { high, wide }, ... }: xg::Window_Site)
			=
			{

																    nb {. sprintf "restart_gui': (high,wide) = (%d,%d)  -- guiboss-imp.pkg" high wide ;};
																    nb {. sprintf "restart_gui': running_gui.packed_space_id d=%d -- guiboss-imp.pkg" (id_to_int running_gui.packed_space_id); };

																    case (im::get (*packed_imps, (id_to_int running_gui.packed_space_id)))
																    THE _ => nb {. sprintf "restart_gui': packed_imps(packed_space_id %d) is SET"   (id_to_int running_gui.packed_space_id); };
																    NULL  => nb {. sprintf "restart_gui': packed_imps(packed_space_id %d) is CLEAR" (id_to_int running_gui.packed_space_id); };
																    esac;

			    (im::get_or_raise_exception_not_found (*packed_imps, (id_to_int running_gui.packed_space_id)))
				->
				{ widget_to_packedspace, guiboss_to_packed_space, endstate_oneshot };


																    nb {. sprintf "restart_gui': (high,wide) MAYBE = (%d,%d)  -- guiboss-imp.pkg" high wide ;};
			    site =  { col => 0,  high,									# Allocate all of window pixel area to widgets in running_gui.packed_widget widget-tree.
				      row => 0,  wide
				    }
				    : xg::Box;

																    nb {. sprintf "restart_gui': (high,wide) STILL = (%d,%d)  -- guiboss-imp.pkg" high wide ;};
			    guiboss_to_packed_space.pass_re_siting_done_flag (site, running_gui.packed_widget)
				to
				{.
																    nb {. sprintf "guiboss/restart_gui' firing gui_startup_complete'" ;};
				    client_to_guiwindow
				      =
				      { id       =>  topwindow_for_gui.id,
					stop_gui =>  (\\ () = { stop_gui (running_gui, bounce_imps, canvas_imps, packed_imps, look_imps, topwindow_info); })
				      }
				      : c2g::Client_To_Guiwindow
				      ;

				    put_in_oneshot (gui_startup_complete', client_to_guiwindow);
																    nb {. sprintf "guiboss/restart_gui' fired  gui_startup_complete'" ;};

																    nb {. sprintf "restart_gui': re-siting of packed-space %d is complete" (id_to_int running_gui.packed_space_id); };
				}; 
			    
			}
		    );
	    }
	    where
		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

printf "restart_gui'/AAA\n";
		topwindow_info = im::get_or_raise_exception_not_found (*me.topwindows, id_to_int topwindow_for_gui.id)
				 except
				     NOT_FOUND = {   printf                "*me.topwindows contains no entry for topwindow %d?!   -- restart_gui' in guiboss-imp.pkg\n" (id_to_int topwindow_for_gui.id);
						     log::fatal (sprintf "*me.topwindows contains no entry for topwindow %d?!   -- restart_gui' in guiboss-imp.pkg" (id_to_int topwindow_for_gui.id));
						     raise exception NOT_FOUND;						# Execution will never reach this point, but the compiler doesn't know that log::fatal doesn't return.
						 };
printf "restart_gui'/BBB\n";
		bounce_imps		=  topwindow_info.bounce_imps;							# Holds our os::Guiboss_To_Bounce_Space instances -- can't put them directly in Running_Gui due to circularity.
		canvas_imps		=  topwindow_info.canvas_imps;							# Holds our cs::Guiboss_To_Canvas_Space instances -- can't put them directly in Running_Gui due to circularity.
		packed_imps		=  topwindow_info.packed_imps;							# Holds our ps::Guiboss_To_Packed_Space instances -- can't put them directly in Running_Gui due to circularity.
		look_imps		=  topwindow_info.look_imps;							# Holds look-imps for all the widgets in our gui.

		current_frame_number	=  topwindow_info.current_frame_number;
		seconds_per_frame	=  topwindow_info.seconds_per_frame;

		# We expect the following fns to capture the above values:
		# that is why we define them here rather than more globally.

		#
		fun get_look_info
		      (
			look_imps:	Look_Imps,
			id:		iul::Id
		      )
		    =
		    case (im::get (*look_imps,  iul::id_to_int id))
			#
			THE look_info =>    look_info;

			NULL =>     {   msg = sprintf "imp %d not found in look_imps?! -- get_look_info in guiboss-imp.pkg" (iul::id_to_int id);	# Should be impossible -- all look widgets should be in look_imps.
					log::note_on_stderr {. msg; };
					raise exception FAIL msg;
				    };
		    esac;



		#################################################################################
		# space_to_gui interface fns:

		#
		fun note_widget_site { id: iul::Id, site: xg::Box }							# PUBLIC.
		    =	
		    # This fn is called by
		    #
		    #   src/lib/x-kit/widget/space/bounce/bounce-space-imp.pkg
		    #   src/lib/x-kit/widget/space/canvas/canvas-space-imp.pkg
		    #   src/lib/x-kit/widget/space/packed/packed-space-imp.pkg  
		    #
		    # when they assign a widget a new site in response to our call
		    #
		    #     guiboss_to_packed_space.pass_re_siting_done_flag
		    #
{															    nb {. sprintf "note_widget_site    { id => %d, site => { row => %d, col => %d, high => %d, wide => %d } } -- guiboss-imp.pkg" (iul::id_to_int id) site.row site.col site.high site.wide; };
		    put_in_mailqueue  (guiboss_q,
			#
			\\ ({ me, ... }: Runstate)
			    =
			    {   i = get_look_info (look_imps, id);
				#
				if (site != *i.site)									# Has the window site of this widget changed?
				    #											# Yes.
															    nb {. sprintf "note_widget_site/if { id => %d, site => { row => %d, col => %d, high => %d, wide => %d } } -- guiboss-imp.pkg" (iul::id_to_int id) site.row site.col site.high site.wide; };
				    i.site :=                    site;							# Remember new site of widget.
#				    i.gui_to_look.note_new_site  site;							# Tell widget's look-imp about its new site.
				fi;
			    }
		    );
};

		space_to_gui =	      { id => topwindow_for_gui.id,							# Since each topwindow has a unique id and we will have only one space_to_gui per topwindow, using topwindow_for_gui.id
					#										# here ensures a unique id per space_to_gui. It also makes space_to_gui.id stable across gui stop/restart cycles.
					note_widget_site
				      };

		topwindow_info.space_to_gui :=  THE space_to_gui;


		#################################################################################
		# widget_to_guiboss interface fns:
		#
		fun widget_has_visibly_changed										# PUBLIC.
		      {
			id:		iul::Id
		      }
		    =	
		    # The point of this call is to alert us that the
		    # GUI display needs refreshing.
		    # If no widget calls this, we can stop the frame-
		    # redisplay cycle to conserve CPU cycles:
		    #
		    {   put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{
																    nb {. sprintf "widget_has_visibly_changed(%d) called -- guiboss-imp.pkg" (iul::id_to_int id); };
				}
		        );
		    };
		#
		fun note_changed_widget_foreground									# PUBLIC.
		      {
			id:		iul::Id,
			foreground:	gd::Gui_Displaylist
		      }
		    =	
		    # The point of this call is to update the foreground
		    # appearance of the widget.  This call is normally
		    # made in response to  gui_to_look.start_of_frame {}						# gui_to_look	is from   src/lib/x-kit/widget/gui/gui-to-look.pkg
		    #
		    {   put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{
nb {. sprintf "note_changed_widget_foreground(%d) called -- guiboss-imp.pkg" (iul::id_to_int id); };
				    i = get_look_info (look_imps, id);
				    #
				    i.foreground := THE foreground;
				}
		        );
		    };
		#
		fun note_changed_widget_background									# PUBLIC.
		      {
			id:		iul::Id,
			background:	gd::Gui_Displaylist
		      }
		    =	
		    # The point of this call is to update the background
		    # appearance of the widget.  This call is normally
		    # made in response to  gui_to_look.start_of_frame {}						# gui_to_look	is from   src/lib/x-kit/widget/gui/gui-to-look.pkg
		    #
		    # The point of separating this call from
		    #     note_changed_widget_foreground {...}
		    # is that the background is presumed to
		    # be static, so guiboss_imp may reasonably
		    # render it into an offscreen X server drawable
		    # and then just copy it to the visible window
		    # each cycle.
		    #   
		    # Any widget background which is actually highly
		    # dynamic should be just rendered as part of the
		    # foreground.
		    #
		    {   put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{
nb {. sprintf "note_changed_widget_background(%d) called -- guiboss-imp.pkg" (iul::id_to_int id); };
				    i = get_look_info (look_imps, id);
				    #
				    i.background := THE background;							# Remember new background of widget.
				}
		        );
		    };

		#
		fun draw_widget	{ id: iul::Id }										# PUBLIC.
		    =	
		    # Widget request to redraw widget immediately.
		    # Typically called (only) in response to user
		    # input, e.g. dragging a slider.
		    #
		    {   put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{
nb {. "draw_widget called -- guiboss-imp.pkg"; };
				}
		        );
		    };

		widget_to_guiboss =	      { id => topwindow_for_gui.id,			# Since each topwindow has a unique id and we will have only one widget_to_guiboss per topwindow, using topwindow_for_gui.id
					#						# here ensures a unique id per widget_to_guiboss. It also makes widget_to_guiboss.id stable across gui stop/restart cycles.
					widget_has_visibly_changed,
					#
					note_changed_widget_foreground,
					note_changed_widget_background,
					#
					draw_widget
				      };	


		topwindow_info.widget_to_guiboss :=  THE widget_to_guiboss;




		#################################################################################
		# frameclock microthread -- wakes us up 10 times/sec to draw a frame.
		#



foo = REF 19;
		fun display_one_frame ({ me, ... }: Runstate)
		    =
		    {
			current_frame_number := *current_frame_number + 1;
foo := *foo + 1;
nb {. sprintf "(display_one_frame called %d...  -- guiboss-imp.pkg)" *foo;};
if (*foo == 20)
nb {. sprintf "display_one_frame called %d...  -- guiboss-imp.pkg" *foo;};
foo := 1;
fi;
			imps =  im::vals_list  *look_imps;
			#
			fun draw_foreground_or_background  null_or_displaylist
			    =
			    case null_or_displaylist
				#
				NULL =>
				    {
nb {. "(draw_foreground_or_background/NULL  -- guiboss-imp.pkg)"; };
					();
				    };

				THE gui_displaylist
				    =>
				    {
nb {. "(draw_foreground_or_background/THE gui_displaylist.  -- guiboss-imp.pkg)";};
					topwindow_for_gui.draw_displaylist  gui_displaylist;
				    };
			    esac;

			apply' imps  {.
			    #imp -> { gui_to_look, site, ... };
nb {. sprintf "(display_one_frame(imp %d) calling   gui_to_look.start_of_frame { frame_number => %d, site => { row => %d, col => %d, high => %d, wide => %d } }  ...  -- guiboss-imp.pkg)" (iul::id_to_int gui_to_look.id) *current_frame_number (*site).row (*site).col (*site).high (*site).wide; };
			    gui_to_look.start_of_frame { frame_number => *current_frame_number, site => *site, visible => TRUE, duration_in_seconds => 0.0 };
			};

			apply' imps  {.
			    #imp -> { foreground, background, gui_to_look, ... };
			    #
nb {. sprintf "(display_one_frame(imp %d) calling   draw_foreground_or_background  *background;   ...  -- guiboss-imp.pkg)" (iul::id_to_int gui_to_look.id); };
			    draw_foreground_or_background  *background;
nb {. sprintf "(display_one_frame(imp %d) calling   draw_foreground_or_background  *fireground;   ...  -- guiboss-imp.pkg)" (iul::id_to_int gui_to_look.id); };
			    draw_foreground_or_background  *foreground;
			};
		    };	

		# This fn provides the body for a little microthread which just
		# loops ten times a second telling our main thread to disply frame:
		#
		fun frameclock end_gun'
		    =
		    loop ()
		    where
			count = REF 19;
			#
			fun loop ()
			    =
			    {
				do_one_mailop [
				    #
				    end_gun'
					==>
					{.
nb {. sprintf "clock microthread calling thread_exit.  -- guiboss-imp.pkg" ;};
					    thread_exit { success => TRUE };
					},
				    #
				    timeout_in' *seconds_per_frame
					==>
					{.
count := *count + 1;
if (*count == 20)
nb {. sprintf "clock microthread calling display_one_frame  -- guiboss-imp.pkg" ;};
count := 1;
fi;
					    put_in_mailqueue  (guiboss_q, display_one_frame);
					}
				];

				loop ();
			    };
		    end;

		make_thread'  [ THREAD_NAME "frameclock" ]  frameclock  end_gun';					# Start up frameclock thread which tells us when it is time to draw a new frame.

		#
				#
		fun digest_packed_space_layout_hints  (options: List(plh::Packed_Space_Layout_Hint))  { share }
		    =
		    {   my_share =  REF share;
			#
			apply  do_option  options
			where
			    fun do_option (plh::SHARE	f) =   if (f > 0.0)   my_share := f;   fi;		# Ignore nonsensical values like 0.0 or negative. This eliminates divide-by-zero risks later.
			end;

			{ share =>  *my_share
			};
		    };
		#
		fun stopped_gui__to__running_gui
		    (
		      ( packed_space_arg:	ps::Packed_Space_Arg,
		        packed_widget:		sg::Packed_Widget
		      ),
		      topwindow:		g2w::Guiboss_To_Topwindow
		    )
		    : rg::Running_Gui
		    =
		    {
			(do_packed_space  packed_space_arg)
			    ->
			    stuff as { widget_to_packedspace, guiboss_to_packed_space, endstate_oneshot };

			packed_space_id =  guiboss_to_packed_space.id;

nb {. sprintf "stopped_gui__to__running_gui: doing packed_imps := ... %d" (id_to_int guiboss_to_packed_space.id); };

			packed_imps :=  im::set (*packed_imps, (id_to_int packed_space_id), stuff);

nb {. sprintf "stopped_gui__to__running_gui: done  packed_imps := ... %d" (id_to_int packed_space_id); };

case (im::get (*packed_imps, (id_to_int packed_space_id)))
THE _ => nb {. sprintf "stopped_gui__to__running_gui: im::set TOOK" ;};
NULL  => nb {. sprintf "stopped_gui__to__running_gui: im::set FAILED" ;};
esac;

			(do_packed_widget (packed_widget, widget_to_packedspace))
			    ->
			    packed_widget;

			{ fire_end_gun,
			  packed_space_id,
			  packed_widget,
			  topwindow
			};
		    }
		    where
			fun make_look_imp_info
			      (
				gui_to_look:	g2l::Gui_To_Look
			      )
			      =
			      { gui_to_look,
				#
				foreground	=>  REF NULL,
				background	=>  REF NULL,
				#
				site		=>  REF { row => 0, col => 0, high => 0, wide => 0 }
			      };
			#
			fun do_packed_space  (packed_space_arg: ps::Packed_Space_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( ps::Packed_Space_Arg  );		# When endgun fires we'll read back final packed_space_imp state via this oneshot.
				#
				packed_space_egg
				    =
				    pai::make_packed_space_egg  packed_space_arg  (THE endstate_oneshot);

				(packed_space_egg ())
				    ->
				    (exports, packed_space_egg');

				exports ->  { widget_to_packedspace, guiboss_to_packed_space };

nb {. sprintf "do_packed_space: doing packed_imps := ... %d   II" (id_to_int guiboss_to_packed_space.id) ;};
				packed_imps :=  im::set (*packed_imps, (id_to_int guiboss_to_packed_space.id), { widget_to_packedspace, guiboss_to_packed_space, endstate_oneshot });
nb {. sprintf "do_packed_space: done  packed_imps := ... %d   II" (id_to_int guiboss_to_packed_space.id) ;};
case (im::get (*packed_imps, (id_to_int guiboss_to_packed_space.id)))
THE _ => nb {. sprintf "do_packed_space: im::set TOOK" ;};
NULL  => nb {. sprintf "do_packed_space: im::set FAILED" ;};
esac;

# NOT VERY SOON add widget_to_guiboss to imports:
				packed_space_imports =  { int_sink => \\ (i: Int) = (), space_to_gui };

				packed_space_egg' (packed_space_imports, run_gun', end_gun');

				{ widget_to_packedspace, guiboss_to_packed_space, endstate_oneshot };
			    }

			also
			fun do_bounce_space  (bounce_space_arg: os::Bounce_Space_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( os::Bounce_Space_Arg  );		# When endgun fires we'll read back final bounce_space_imp state via this oneshot.
				#
				bounce_space_egg
				    =
				    boi::make_bounce_space_egg  bounce_space_arg  (THE endstate_oneshot);

				(bounce_space_egg ())
				    ->
				    (exports, bounce_space_egg');

				exports -> { guiboss_to_bounce_space, look_to_bounce };

				bounce_imps :=  im::set (*bounce_imps,  id_to_int guiboss_to_bounce_space.id,  { guiboss_to_bounce_space, look_to_bounce, endstate_oneshot });

# NOT VERY SOON add widget_to_guiboss to imports:
				bounce_space_imports =  { int_sink => \\ (i: Int) = () };

				bounce_space_egg' (bounce_space_imports, run_gun', end_gun');

				{ guiboss_to_bounce_space, look_to_bounce, endstate_oneshot };
			    }

			also
			fun do_canvas_space  (canvas_space_arg: cs::Canvas_Space_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( cs::Canvas_Space_Arg  );		# When endgun fires we'll read back final canvas_space_imp state via this oneshot.
				#
				canvas_space_egg
				    =
				    cai::make_canvas_space_egg  canvas_space_arg  (THE endstate_oneshot);

				(canvas_space_egg ())
				    ->
				    (exports, canvas_space_egg');

				exports -> { guiboss_to_canvas_space, look_to_canvas };

				canvas_imps :=  im::set (*canvas_imps,  id_to_int guiboss_to_canvas_space.id,  { guiboss_to_canvas_space, look_to_canvas, endstate_oneshot });

# NOT VERY SOON add widget_to_guiboss to imports:
				canvas_space_imports =  { int_sink => \\ (i: Int) = () };

				canvas_space_egg' (canvas_space_imports, run_gun', end_gun');

				{ guiboss_to_canvas_space, look_to_canvas, endstate_oneshot };
			    }

			also
			fun do_bounce_widget (bounce_widget: sg::Bounce_Widget, look_to_bounce: l2b::Look_To_Bounce)
			    =
			    case bounce_widget
				#
				sg::BALL
				    ( ball_arg      as (ball_state_needs, ball_state_options):		c2b::Make_Arg,
				      ball_look_arg as (                  ball_look_options):		bli::Bounce_Look_Arg
				    )
				    =>
				    {   endstate_oneshot     =  make_oneshot_maildrop():  Oneshot_Maildrop( c2b::Make_Arg       );		# When endgun fires we'll read back final ball_state state via this oneshot.
					endlook_oneshot	     =  make_oneshot_maildrop():  Oneshot_Maildrop( bli::Bounce_Look_Arg  );		# When endgun fires we'll read back final ball_state state via this oneshot.

					ball_state_oneshot   =  make_oneshot_maildrop():  Oneshot_Maildrop( c2b::Client_To_State );		# We'll get our ball_state port via this at ball-state-imp startup.
					ball_look_oneshot    =  make_oneshot_maildrop():  Oneshot_Maildrop( bli::Bounce_Look  );		# We'll get our ball_look  port via this at ball-look-imp startup.

					ball_state_thunk     =   (\\ ball_state  = put_in_oneshot (ball_state_oneshot, ball_state));		# These two paragraphs just arrange for the above to be called.
					ball_look_thunk      =   (\\ bounce_look = put_in_oneshot (ball_look_oneshot, bounce_look));

					ball_state_options   =   (c2b::CLIENT_TO_STATE_CALLBACK ball_state_thunk)  !  ball_state_options;

					ball_look_options    =   (bli::BOUNCE_LOOK_CALLBACK  ball_look_thunk )  !  ball_look_options;

					ball_look_arg	     =   (                  ball_look_options);
					ball_arg	     =   (ball_state_needs, ball_state_options);



					# Start up the 'state' + 'look' imp-pair for the widget:

					(imports.gui_to_bounce_theme.make_ball_widget_state_imp_egg
					    (ball_arg, ball_look_arg, look_to_bounce)
					    ( THE endstate_oneshot,
					      THE endlook_oneshot
					)   )
					    ->
					    bounce_widget_egg;

					(bounce_widget_egg ()) -> (exports, bounce_widget_egg');

					exports -> { gui_to_look, bounce_to_look };
					imports =  { widget_to_guiboss, int_sink => (\\ (i: Int) = ()) };

					bounce_widget_egg' (imports, run_gun', end_gun');
					#
					state   =  get_from_oneshot   ball_state_oneshot;
					look    =  get_from_oneshot   ball_look_oneshot;

					look_imp_info  =  make_look_imp_info  gui_to_look;
nb {. sprintf "do_bounce_widget doing look_imps += %d   -- guiboss-imp.pkg"  (iul::id_to_int gui_to_look.id); };
					look_imps    :=   im::set (*look_imps, iul::id_to_int gui_to_look.id,  look_imp_info );

					rg::BALL { bounce_to_look, state, look, endstate_oneshot, endlook_oneshot };	
			    };
			    esac


			also
			fun do_canvas_widget (canvas_widget: sg::Canvas_Widget, look_to_canvas: l2c::Look_To_Canvas)
			    =
			    case canvas_widget
				#
				sg::PACKED_SPACE  (packed_space_arg:  ps::Packed_Space_Arg,  packed_widget: sg::Packed_Widget)
				    =>
				    {
					(do_packed_space  packed_space_arg)
					    ->
					    stuff as { widget_to_packedspace, guiboss_to_packed_space, endstate_oneshot };

nb {. sprintf "do_canvas_widget: doing packed_imps := ... %d   III" (id_to_int guiboss_to_packed_space.id); };
					packed_imps :=  im::set (*packed_imps, (id_to_int guiboss_to_packed_space.id), stuff);
nb {. sprintf "do_canvas_widget: done  packed_imps := ... %d   III" (id_to_int guiboss_to_packed_space.id); };
case (im::get (*packed_imps, (id_to_int guiboss_to_packed_space.id)))
THE _ => nb {. sprintf "do_canvas_widget: im::set TOOK" ;};
NULL  => nb {. sprintf "do_canvas_widget: im::set FAILED" ;};
esac;

					(do_packed_widget (packed_widget, widget_to_packedspace))
					    ->
					    packed_widget;

					rg::PACKED_SPACE { packed_space_id => guiboss_to_packed_space.id,  packed_widget };
				    };

				sg::NODE
				    ( node_arg      as (node_state_needs, node_state_options):		c2n::Make_Arg,
				      node_look_arg as (                  node_look_options):		nli::Canvas_Look_Arg
				    )
				    =>
				    {   endstate_oneshot     =  make_oneshot_maildrop():  Oneshot_Maildrop( c2n::Make_Arg       );		# When endgun fires we'll read back final nodel_state state via this oneshot.
					endlook_oneshot      =  make_oneshot_maildrop():  Oneshot_Maildrop( nli::Canvas_Look_Arg  );		# When endgun fires we'll read back final nodel_state state via this oneshot.

					node_state_oneshot   =  make_oneshot_maildrop():  Oneshot_Maildrop( c2n::Client_To_State );		# We'll get our node_state port via this at node-state-imp startup.
					node_look_oneshot    =  make_oneshot_maildrop():  Oneshot_Maildrop( nli::Canvas_Look  );		# We'll get our node_look  port via this at node-look-imp startup.

					node_state_thunk     =   (\\ node_state = put_in_oneshot (node_state_oneshot, node_state));		# These two paragraphs just arrange for the above to be called.
					node_look_thunk      =   (\\ node_look  = put_in_oneshot (node_look_oneshot,  node_look));

					node_state_options   =   (c2n::CLIENT_TO_STATE_CALLBACK node_state_thunk)  !  node_state_options;

					node_look_options    =   (nli::CANVAS_LOOK_CALLBACK  node_look_thunk )  !  node_look_options;

					node_look_arg	     =   (                  node_look_options);
					node_arg	     =   (node_state_needs, node_state_options);



					# Start up the 'state' + 'look' imp-pair for the widget:

					(imports.gui_to_canvas_theme.make_node_widget_state_imp_egg
					    (node_arg, node_look_arg, look_to_canvas)
					    ( THE endstate_oneshot,
					      THE endlook_oneshot
					)   )
					    ->
					    canvas_widget_egg;

					(canvas_widget_egg ()) -> (exports, canvas_widget_egg');

					exports -> { gui_to_look, canvas_to_look };
					imports =  { widget_to_guiboss, int_sink => (\\ (i: Int) = ()) };

					canvas_widget_egg' (imports, run_gun', end_gun');
					#
					state = get_from_oneshot   node_state_oneshot;
					look  = get_from_oneshot   node_look_oneshot;

					look_imp_info  =  make_look_imp_info  gui_to_look;
nb {. sprintf "do_canvas_widget doing look_imps += %d   -- guiboss-imp.pkg"  (iul::id_to_int gui_to_look.id); };
					look_imps     :=  im::set (*look_imps, iul::id_to_int gui_to_look.id,  look_imp_info );

					rg::NODE { canvas_to_look,  state, look, endstate_oneshot, endlook_oneshot };
				    };
			    esac

			also
			fun do_packed_widget (packed_widget: sg::Packed_Widget, widget_to_packedspace: l2p::Widget_To_Packedspace)				# 'packed_widget' can be a tree of widgets with ROW and COL internal nodes.
			    =
{
nb {. sprintf "do_packed_widget/TOP widget_to_packedspace.id d=%d   -- guiboss-imp.pkg" (id_to_int widget_to_packedspace.id); };

			    case packed_widget
				#
			        sg::ROW	(packed_widgets:	 List( (sg::Packed_Widget, List(plh::Packed_Space_Layout_Hint)) ))		# A row of widgets. The ROW itself is not a widget (given no microthread).
				    =>
				    {
nb {. sprintf "do_packed_widget/ROW TOP: list::length(packed_widgets) d=%d  -- guiboss-imp.pkg" (list::length packed_widgets); };
					widgets =   map  do_widget  packed_widgets
						    where
							fun do_widget
							    (
							      packed_widget:	sg::Packed_Widget,
							      layout_hints:	List( plh::Packed_Space_Layout_Hint )
							    )
							    =
{
nb {. sprintf "do_packed_widget/ROW/do_widget TOP  widget_to_packedspace.id d=%d -- guiboss-imp.pkg" (id_to_int widget_to_packedspace.id); };
							    ( do_packed_widget  (packed_widget, widget_to_packedspace),
							      digest_packed_space_layout_hints  layout_hints  { share => 1.0 },
							      layout_hints	
							    );
};
						    end;

nb {. sprintf "do_packed_widget/ROW bottom  -- guiboss-imp.pkg"; };
					rg::ROW { widgets };
				    };

			        sg::COL	(packed_widgets:	 List( (sg::Packed_Widget, List(plh::Packed_Space_Layout_Hint)) ))		# A column of widgets. The COL itself is not a widget (given no microthread).
				    =>
				    {
					widgets =   map  do_widget  packed_widgets
						    where
							fun do_widget
							    (
							      packed_widget:	sg::Packed_Widget,
							      layout_hints:	List( plh::Packed_Space_Layout_Hint )
							    )
							    =
							    ( do_packed_widget  (packed_widget, widget_to_packedspace),
							      digest_packed_space_layout_hints  layout_hints  { share => 1.0 },
							      layout_hints	
							    );
						    end;

					rg::COL { widgets };
				    };

# SOON! (This is intended to replace the following six:)
			        sg::WIDGET   ((gt::START_PACKED_WIDGET_FN start_packed_widget_fn):		gt::Start_Packed_Widget_Fn)
				    =>
				    {   endstate_oneshot    =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Start_Packed_Widget_Fn );	# When endgun fires we'll read back final widget state via this oneshot.
					#
					(start_packed_widget_fn { widget_to_guiboss => widget_to_guiboss, widget_to_packedspace => widget_to_packedspace, run_gun', end_gun', endstate_oneshot })
					    ->
					    { guiboss_to_widget => gui_to_look, packedspace_to_widget => packed_to_look };


					look_imp_info  =  make_look_imp_info  gui_to_look;
nb {. sprintf "do_packed_widget/WIDGET doing look_imps += %d   -- guiboss-imp.pkg" (iul::id_to_int gui_to_look.id); };
					look_imps     :=  im::set (*look_imps,     iul::id_to_int gui_to_look.id,  look_imp_info );

					rg::WIDGET { packedspace_to_widget => packed_to_look, guiboss_to_widget => gui_to_look, endstate_oneshot };
				    };


			        sg::CANVAS_SPACE
				    ( canvas_space_arg:	cs::Canvas_Space_Arg,
				      canvas_widgets:	List((sg::Canvas_Widget, List(clh::Canvas_Space_Layout_Hint)))
				    )
				    =>
				    {
					(do_canvas_space  canvas_space_arg)
					    ->
					    stuff as { guiboss_to_canvas_space, look_to_canvas, endstate_oneshot };

					canvas_space_id =  guiboss_to_canvas_space.id;

					canvas_imps :=  im::set (*canvas_imps, (id_to_int canvas_space_id), stuff);

					#
					widgets	=   map  do_widget  canvas_widgets
						    where
							fun do_widget (canvas_widget: sg::Canvas_Widget,  hints: List(clh::Canvas_Space_Layout_Hint))
							    =
							    ( do_canvas_widget  (canvas_widget, look_to_canvas),
							      hints
							    );	
						    end;

					rg::CANVAS_SPACE { canvas_space_id,  widgets };
				    };

			        sg::BOUNCE_SPACE
				    ( bounce_space_arg:	os::Bounce_Space_Arg,
				      bounce_widgets:	List((sg::Bounce_Widget, List(blh::Bounce_Space_Layout_Hint)))
				    )
				    =>
				    {
					(do_bounce_space  bounce_space_arg)
					    ->
					    stuff as { guiboss_to_bounce_space, look_to_bounce, endstate_oneshot };

					bounce_imps :=  im::set (*bounce_imps, (id_to_int guiboss_to_bounce_space.id), stuff);

					#
					widgets	=   map  do_widget  bounce_widgets
						    where
							fun do_widget (bounce_widget: sg::Bounce_Widget,  hints: List(blh::Bounce_Space_Layout_Hint))
							    =
							    ( do_bounce_widget  (bounce_widget, look_to_bounce),
							      hints
							    );	
						    end;

					bounce_space_id =  guiboss_to_bounce_space.id;

					rg::BOUNCE_SPACE { bounce_space_id, widgets };
				    };

			        sg::NULL_PACKED_WIDGET
				    =>
				    rg::NULL_PACKED_WIDGET;
			    esac;
};
		    end;	
	    end;

	#
	fun start_gui'
	      (
		runstate: 		Runstate,
		#	
		topwindow_for_gui:	g2w::Guiboss_To_Topwindow,
		gui_plan:		gp::Gui_Plan,

		gui_startup_complete':	Oneshot_Maildrop( Client_To_Guiwindow ),
		guiboss_q:		Guiboss_Q,
		stop_gui:		(rg::Running_Gui, Bounce_Imps, Canvas_Imps, Packed_Imps, Look_Imps, Topwindow_Info) -> sg::Stopped_Gui
	      )
	    =
	    {   stopped_gui =  gui_plan__to__stopped_gui  gui_plan;
		#
	        restart_gui' (runstate, topwindow_for_gui, stopped_gui, gui_startup_complete', guiboss_q, stop_gui);
	    }
	    where
		fun gui_plan__to__stopped_gui
		    (
		      packed_space_arg:		ps::Packed_Space_Arg,
		      packed_widget:		gp::Packed_Widget
		    )
		    : sg::Stopped_Gui
		    =
		    {
			(do_packed_widget packed_widget)
			    ->
			    packed_widget;

			( packed_space_arg:		ps::Packed_Space_Arg,
			  packed_widget:		sg::Packed_Widget
			);
		    }
		    where
			fun do_bounce_widget (bounce_widget: gp::Bounce_Widget)
			    =
			    case bounce_widget
				#
				gp::BALL a =>  runstate.imports.gui_to_bounce_theme.make_ball_widget  a;
			    esac

			also
			fun do_canvas_widget (canvas_widget: gp::Canvas_Widget)
			    =
			    case canvas_widget
				#
				gp::PACKED_SPACE  (packed_space_arg:  ps::Packed_Space_Arg,  packed_widget: gp::Packed_Widget)
				    =>
				    {
					(do_packed_widget packed_widget)
					    ->
					    packed_widget;

					sg::PACKED_SPACE (packed_space_arg,  packed_widget);
				    };

				gp::NODE a =>  runstate.imports.gui_to_canvas_theme.make_node_widget  a;
			    esac

			also
			fun do_packed_widget (packed_widget: gp::Packed_Widget)				# 'packed_widget' can be a tree of widgets with ROW and COL internal nodes.
			    =
			    case packed_widget
				#
			        gp::ROW	(packed_widgets:	 List( (gp::Packed_Widget, List(plh::Packed_Space_Layout_Hint)) ))		# A row of widgets. The ROW itself is not a widget (given no microthread).
				    =>
				    {
					packed_widgets
					    =
					    map  do_widget  packed_widgets
					    where
						fun do_widget
						    (
						      packed_widget:	gp::Packed_Widget,
						      layout_hints:	List( plh::Packed_Space_Layout_Hint )
						    )
						    =
						    ( do_packed_widget  packed_widget,
						      layout_hints	
						    );
					    end;

					sg::ROW  packed_widgets;
				    };

			        gp::COL	(packed_widgets:	 List( (gp::Packed_Widget, List(plh::Packed_Space_Layout_Hint)) ))		# A column of widgets. The COL itself is not a widget (given no microthread).
				    =>
				    {
					packed_widgets
					    =
					    map  do_widget  packed_widgets
					    where
						fun do_widget
						    (
						      packed_widget:	gp::Packed_Widget,
						      layout_hints:	List( plh::Packed_Space_Layout_Hint )
						    )
						    =
						    ( do_packed_widget  packed_widget,
						      layout_hints	
						    );
					    end;

					sg::COL  packed_widgets;
				    };

			        gp::WIDGET   a =>  sg::WIDGET a;

			        gp::CANVAS_SPACE
				    ( canvas_space_arg:	cs::Canvas_Space_Arg,
				      canvas_widgets:	List((gp::Canvas_Widget, List(clh::Canvas_Space_Layout_Hint)))
				    )
				    =>
				    {
					canvas_widgets
					    =
					    map  do_widget  canvas_widgets
					    where
						fun do_widget (canvas_widget: gp::Canvas_Widget,  hints: List(clh::Canvas_Space_Layout_Hint))
						    =
						    ( do_canvas_widget  canvas_widget,
						      hints
						    );	
					    end;

					sg::CANVAS_SPACE (canvas_space_arg, canvas_widgets);
				    };

			        gp::BOUNCE_SPACE
				    ( bounce_space_arg:	os::Bounce_Space_Arg,
				      bounce_widgets:	List((gp::Bounce_Widget, List(blh::Bounce_Space_Layout_Hint)))
				    )
				    =>
				    {
					bounce_widgets
					    =
					    map  do_widget  bounce_widgets
					    where
						fun do_widget (bounce_widget: gp::Bounce_Widget,  hints: List(blh::Bounce_Space_Layout_Hint))
						    =
						    ( do_bounce_widget  bounce_widget,
						      hints
						    );	
					    end;

					sg::BOUNCE_SPACE (bounce_space_arg, bounce_widgets);
				    };

			        gp::NULL_PACKED_WIDGET
				    =>
				    sg::NULL_PACKED_WIDGET;
			    esac;
		    end;	
	    end;

	#
	fun startup   (id: Id,   reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		client_to_guiboss =   { id,
					make_topwindow,
					start_gui,
					restart_gui,
					get_bounce_theme,
					get_canvas_theme,
					get_packed_theme
				      };

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, { client_to_guiboss }));						# Return value from guiboss_egg'().

		(take_from_mailslot  me_slot)											# Imports from guiboss_egg'().
		    ->
		    { me, guiboss_arg, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';										# Wait for the starting gun.

		run ( guiboss_q,		 										# Will not return.
		      { me,
			guiboss_arg,
			imports,
			to,
			end_gun',
			id
		      }
		);
	    }
	    where
		guiboss_q     =  make_mailqueue (get_current_microthread()):  Guiboss_Q;



		#################################################################################
		# guiboss interface fns::
		#
		#
		stipulate
		    fun find_appropriate_look_imp_info
			  (
			    topwindow_info:		Topwindow_Info,
			    event_point
			  )
			=
			{
			    smallest_containing_look_imp = REF (NULL: Null_Or( Look_Imp_Info ));
											#
			    fun consider_look_imp (look_imp_info: Look_Imp_Info)
				=
				{   box = *look_imp_info.site;
				    #
				    box -> { row, col, high, wide };

				    point_is_in_box = xg::point::in_box (event_point, box);

printf "guievent_sink()/guiboss/do_button_press: considering widget at row %d col %d high %d wide %d  point_is_in_box=%B  wants_mouseclicks=%B -- guiboss-imp.pkg\n" row col high wide  point_is_in_box look_imp_info.gui_to_look.wants_mouseclicks;
				    if (point_is_in_box /* and look_imp_info.gui_to_look.wants_mouseclicks */)
					#
					smallest_containing_look_imp
					    :=
					    THE look_imp_info;
				    fi;
				};

			    apply  consider_look_imp  (im::vals_list *topwindow_info.look_imps);

			    *smallest_containing_look_imp;
			};
		herein

		    fun do_button_press												# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    running_gui:		rg::Running_Gui,
			    button_xevtinfo:	evt::Button_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_look_imp_info (topwindow_info, button_xevtinfo.event_point))
				#
				THE look_imp_info
				    =>
				    {   printf "guievent_sink()/guiboss/do_button_press: FOUND CANDIDATE!\n";
					#	
					look_imp_info.gui_to_look.note_mousebutton_press_event
					  (
					    button_xevtinfo.mouse_button,
					    button_xevtinfo.modifier_keys_state,
	 		    		    button_xevtinfo.mousebuttons_state,
					    button_xevtinfo.event_point,
					   *look_imp_info.site
					  );	
				    };

				NULL =>  printf "guievent_sink()/guiboss/do_button_press: NO candidate found.\n";
			    esac;
			};

		    fun do_button_release												# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    running_gui:		rg::Running_Gui,
			    button_xevtinfo:	evt::Button_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_look_imp_info (topwindow_info, button_xevtinfo.event_point))
				#
				THE look_imp_info
				    =>
				    {   printf "guievent_sink()/guiboss/do_button_release: FOUND CANDIDATE!\n";
					#	
					look_imp_info.gui_to_look.note_mousebutton_release_event
					  (
					    button_xevtinfo.mouse_button,
					    button_xevtinfo.modifier_keys_state,
	 		    		    button_xevtinfo.mousebuttons_state,
					    button_xevtinfo.event_point,
					   *look_imp_info.site
					  );	
				    };

				NULL =>  printf "guievent_sink()/guiboss/do_button_release: NO candidate found.\n";
			    esac;
			};

		    fun do_key_press												# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    running_gui:		rg::Running_Gui,
			    key_xevtinfo:		evt::Key_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_look_imp_info (topwindow_info, key_xevtinfo.event_point))
				#
				THE look_imp_info
				    =>
				    {   printf "guievent_sink()/guiboss/do_key_press: FOUND CANDIDATE!\n";
					#	
					look_imp_info.gui_to_look.note_key_press_event
					  (
					    key_xevtinfo.keycode,
					    key_xevtinfo.modifier_keys_state,
	 		    		    key_xevtinfo.mousebuttons_state,
					    key_xevtinfo.event_point,
					   *look_imp_info.site
					  );	
				    };

				NULL =>  printf "guievent_sink()/guiboss/do_key_press: NO candidate found.\n";
			    esac;
			};

		    fun do_key_release												# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    running_gui:		rg::Running_Gui,
			    key_xevtinfo:		evt::Key_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_look_imp_info (topwindow_info, key_xevtinfo.event_point))
				#
				THE look_imp_info
				    =>
				    {   printf "guievent_sink()/guiboss/do_key_release: FOUND CANDIDATE!\n";
					#	
					look_imp_info.gui_to_look.note_key_release_event
					  (
					    key_xevtinfo.keycode,
					    key_xevtinfo.modifier_keys_state,
	 		    		    key_xevtinfo.mousebuttons_state,
					    key_xevtinfo.event_point,
					   *look_imp_info.site
					  );	
				    };

				NULL =>  printf "guievent_sink()/guiboss/do_key_release: NO candidate found.\n";
			    esac;
			};


		end;


		fun make_topwindow  (hints: g2w::Topwindow_Hints)								# PUBLIC.
		    =														# This will run in client's thread.
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( g2w::Guiboss_To_Topwindow );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ me, imports, ... }: Runstate)									# Now we're running in our own thread, with mutual exclusion and access to our core datastructures.
				=
				{   # We have to do an awkward little dance here because we
				    # must hand a guievent_sink() TO make_topwindow() but we
				    # want guievent_sink() to lock in the 'topwindow' result
				    # FROM make_topwindow():

				    saved_events = REF ([]: List( (a2r::Envelope_Route, evt::x::Event) ) );			# Somewhere for initial_guievent_sink to save any events it gets.

				    fun initial_guievent_sink (arg as (route: a2r::Envelope_Route, event: evt::x::Event))	# An initial version which just saves events in 'saved_events' until we're ready to process them, since we don't yet have 'topwindow' available.
					=											# This will run in client's thread.
					saved_events :=  arg ! *saved_events;

				    guievent_sink_fn   = REF initial_guievent_sink;

				    fun guievent_sink_wrapper (arg as (route: a2r::Envelope_Route, event: evt::x::Event))	# A wrapper which initially calls initial_guievent_sink but almost immediately switches to calling the production guievent_sink.
					=											# This will run in client's thread.
					*guievent_sink_fn  arg;



				    # Do the actual work for this fn:
				    #
				    guiboss_to_topwindow =  imports.guiboss_to_windowsystem.make_topwindow  (hints, guievent_sink_wrapper);		# XXX SUCKO FIXME we're blocking until we get the result from windowsystem.



				    topwindow_info       =    { guiboss_to_topwindow,							# Remember our handle for the topwindow.
								running_gui		=>   REF NULL,					# Remember that we do not yet have a GUI running on the topwindow.
								bounce_imps		=>  (REF im::empty): Bounce_Imps,		# Holds our os::Guiboss_To_Bounce_Space instances -- can't put them directly in Running_Gui due to circularity.
								canvas_imps		=>  (REF im::empty): Canvas_Imps,		# Holds our cs::Guiboss_To_Canvas_Space instances -- can't put them directly in Running_Gui due to circularity.
								packed_imps		=>  (REF im::empty): Packed_Imps,		# Holds our ps::Guiboss_To_Packed_Space instances -- can't put them directly in Running_Gui due to circularity.
								look_imps		=>  (REF im::empty): Look_Imps,			# Holds look-imps for all the widgets in our gui.
								current_frame_number	=>  (REF 1),					# We count frames for convenience of widgets and debugging.
								seconds_per_frame	=>  (REF 0.1),					# Let's initially assume a nominal ten frames per second. Passed to widgets primarily so widgets can do motion blurring if they wish.
								widget_to_guiboss		=>  (REF (NULL: Null_Or( l2g::Widget_To_Guiboss ))),	# 
								space_to_gui		=>  (REF (NULL: Null_Or( s2g::Space_To_Gui)))
							      };

				    me.topwindows											# Remember that we have a new topwindow to manage.
					:=
					im::set ( *me.topwindows,
						  id_to_int guiboss_to_topwindow.id,
						  topwindow_info
						);

				    fun guievent_sink (arg as (route: a2r::Envelope_Route, event: evt::x::Event))			# The production Gui_Event handling routine, which locks in the value of 'guiboss_to_topwindow'.
					=												# This will run in client's thread.
					put_in_mailqueue  (guiboss_q,									# Incoming Gui_Event values MUST be run through the guiboss_q to guarantee mutual exclusion on access to internal guiboss datastructures.
					    #
					    \\ (runstate as { me, imports, ... }: Runstate)						# Now we're running in our own thread, with mutual exclusion and access to our core datastructures.
						=
						{
						    case *topwindow_info.running_gui
							#
							NULL => {   saved_events := arg ! *saved_events;				# When no GUI is running, all we can do is save user input for later processing. (Or maybe discard it?)
printf "guievent_sink()/guiboss: received '%s' Gui_Event but saved it because *topwindow_info.running_gui is NULL.    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
								};

							THE running_gui
							     =>	{
								    case *saved_events
									#
									[] =>   {
printf "guievent_sink()/guiboss: processing '%s' Gui_Event via *topwindow_info.running_gui.    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
										    case event
											#
										        evt::x::KEY_PRESS       (key_xevtinfo: evt::Key_Xevtinfo)
											    =>
											    do_key_press (runstate, topwindow_info, running_gui, key_xevtinfo);

										        evt::x::KEY_RELEASE     (key_xevtinfo: evt::Key_Xevtinfo)
											    =>
											    do_key_release (runstate, topwindow_info, running_gui, key_xevtinfo);

										        evt::x::BUTTON_PRESS    (button_xevtinfo: evt::Button_Xevtinfo)
											    =>
											    do_button_press (runstate, topwindow_info, running_gui, button_xevtinfo);

										        evt::x::BUTTON_RELEASE  (button_xevtinfo: evt::Button_Xevtinfo)
											    =>
											    do_button_release (runstate, topwindow_info, running_gui, button_xevtinfo);

										        evt::x::MOTION_NOTIFY   (motion_xevtinfo: evt::Motion_Xevtinfo)
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::ENTER_NOTIFY    (inout_xevtinfo: evt::Inout_Xevtinfo)
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::LEAVE_NOTIFY    (inout_xevtinfo: evt::Inout_Xevtinfo)
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::FOCUS_IN	(focus_xevtinfo: evt::Focus_Xevtinfo)
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::FOCUS_OUT	(focus_xevtinfo:  evt::Focus_Xevtinfo)
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::KEYMAP_NOTIFY    { }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::EXPOSE           (expose_record:         evt::x::Expose_Record)
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::GRAPHICS_EXPOSE  (graphics_expose_record: evt::x::Graphics_Expose_Record)
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::NO_EXPOSE
											  { drawable:			evt::Drawable_Id,
											    major_opcode:		Unt,				# The graphics operation code.
											    minor_opcode:		Unt				# Always 0 for core protocol.
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::VISIBILITY_NOTIFY
											  { changed_window_id:		evt::Window_Id,			# The window with changed visibility state.
											    state:			evt::Visibility			# The new visibility state.
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::CREATE_NOTIFY
											  { parent_window_id:		evt::Window_Id,			# The created window's parent.
											    created_window_id:		evt::Window_Id,			# The created window.
											    box:			xg::Box,			# The window's rectangle.
											    border_wid:			Int,				# The width of the border.
											    override_redirect:		Bool				#  
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::DESTROY_NOTIFY
											  { event_window_id:		evt::Window_Id,			# The window on which this was generated.
											    destroyed_window_id:	evt::Window_Id			# The destroyed window.
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::UNMAP_NOTIFY
											  { event_window_id:		evt::Window_Id,			# The window on which this was generated.
											    unmapped_window_id:		evt::Window_Id,			# The window being unmapped.
											    from_config:		Bool				# TRUE if parent was resized.
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::MAP_NOTIFY
											  { event_window_id:		evt::Window_Id,			# The window on which this was generated.
											    mapped_window_id:		evt::Window_Id,			# The window being mapped.
											    override_redirect:		Bool				#  
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::MAP_REQUEST
											  { parent_window_id:		evt::Window_Id,			# The parent.
											    mapped_window_id:		evt::Window_Id			# The mapped window.
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::REPARENT_NOTIFY
											  { event_window_id:		evt::Window_Id,			# The window on which this was generated.
											    parent_window_id:      	evt::Window_Id,			# The new parent.
											    rerooted_window_id:    	evt::Window_Id,			# The re-rooted window.
											    upperleft_corner:		xg::Point,			# The upper-left corner.
											    override_redirect:		Bool				#  
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::CONFIGURE_NOTIFY
											  { event_window_id:       	evt::Window_Id,			# The window on which this was generated.
											    configured_window_id:	evt::Window_Id,			# The reconfigured window.
											    sibling_window_id:	Null_Or(evt::Window_Id),		# The sibling that window is above (if any).
											    box:			xg::Box,			# The window's rectangle.
											    border_wid:  		Int,				# The width of the border.
											    override_redirect:		Bool				#  
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::CONFIGURE_REQUEST
											  { parent_window_id:		evt::Window_Id,			# The parent.
											    configure_window_id:	evt::Window_Id,			# The window to reconfigure.
											    sibling_window_id:  	Null_Or(evt::Window_Id),		# The new sibling (if any).
											    x:           		Null_Or(Int),			# The window's rectangle.
											    y:           		Null_Or(Int),
											    wide:        		Null_Or(Int),
											    high:        		Null_Or(Int),
											    border_wid:  		Null_Or(Int),			# The width of the border.
											    stack_mode: 		Null_Or(evt::Stack_Mode)		# The mode for stacking windows.
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::GRAVITY_NOTIFY
											  {
											    event_window_id:		evt::Window_Id,			# The window on which this was generated.
											    moved_window_id:   		evt::Window_Id,			# The window being moved.
											    upperleft_corner:		xg::Point			# Upper-left corner of window.
										          }		
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::RESIZE_REQUEST
											  {
											    resize_window_id:		evt::Window_Id,			# The window to resize.
											    req_size:			xg::Size			# The requested new size.
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::CIRCULATE_NOTIFY
											  {
											    event_window_id:		evt::Window_Id,			# The window on which this was generated.
											    circulated_window_id:	evt::Window_Id,			# The window being circulated.
											    parent_window_id:		evt::Window_Id,			# The parent.
											    place:			evt::Stack_Pos			# The new place.
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::CIRCULATE_REQUEST
											  {
											    parent_window_id:		evt::Window_Id,			# The parent.
											    circulate_window_id:	evt::Window_Id,			# The window to circulate.
											    place:			evt::Stack_Pos			# The place to circulate the window to.
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::PROPERTY_NOTIFY
											  {
											    changed_window_id:		evt::Window_Id,			# The window with the changed property.
											    atom:        		evt::Atom,			# The affected property.
											    timestamp:  		evt::t::Xserver_Timestamp,	# When the property was changed.
											    deleted:     		Bool				# TRUE if the property was deleted.
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::SELECTION_CLEAR
											  {
											    owning_window_id:		evt::Window_Id,			# The current owner of the selection.
											    selection:			evt::Atom,			# The selection.
											    timestamp:			evt::t::Xserver_Timestamp	# The last-change time.
											  }		
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::SELECTION_REQUEST
											  {
											    owning_window_id:		evt::Window_Id,			# The owner of the selection.
											    selection:			evt::Atom,			# The selection.
											    target:			evt::Atom,			# The requested type for the selection.
											    requesting_window_id:	evt::Window_Id,			# The requesting window.
											    property:			Null_Or( evt::Atom ),		# The property to store the selection in. 
											    timestamp:			evt::Timestamp			#  
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::SELECTION_NOTIFY
											  {
											    requesting_window_id:	evt::Window_Id,			# The requestor of the selection.
											    selection:			evt::Atom,			# The selection.
											    target:			evt::Atom, 			# The requested type of the selection.
											    property:			Null_Or( evt::Atom ),		# The property to store the selection in.
											    timestamp:			evt::Timestamp  		#  
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::COLORMAP_NOTIFY
											  {
											    window_id:			evt::Window_Id,			# The affected window.
											    cmap:			Null_Or( evt::Colormap_Id ),	# The colormap.
											    new:			Bool,				# TRUE, if the colormap attribute is changed.
											    installed: 			Bool				# TRUE, if the colormap is installed.
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::CLIENT_MESSAGE
											  {
											    window_id:			evt::Window_Id,			#  
											    type:			evt::Atom,			# The type of the message.
											    value:			evt::Raw_Data			# The message value.
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::MODIFIER_MAPPING_NOTIFY					# Really a MappingNotify event.
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::KEYBOARD_MAPPING_NOTIFY					# Really a MappingNotify event.
											  {
											    first_keycode:  evt::Keycode,
											    count:          Int
											  }
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::POINTER_MAPPING_NOTIFY					# Really a MappingNotify event.
											    =>
											    printf "guievent_sink()/guiboss: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    esac;								# NB: We avoid a '_' case here because if an event is added to evt::x::Event we want a compile error as a reminder to handle it.

										};

									_  =>   {						# Woops, we have prior events that came in before we were ready to process them.
										    saved_events := arg ! *saved_events;	# Add latest event to saved-events list.
										    events = reverse *saved_events;		# Reverse saved-events list so we process them in first-in-first-out order.
										    saved_events := [];				# Clear saved-events so  we don't process any of them twice.
										    apply guievent_sink events;			# Recursively process all saved events in order.  NB: Any new events that arrive during this will just accumulate on guiboss_q. That's fine.
										};						# 
								    esac;
								};
								
						    esac;
						}
					);

				    guievent_sink_fn  :=  guievent_sink;							# Switch guievent_sink_wrapper() over from using initial_guievent_sink() to using guievent_sink().


				    put_in_oneshot (reply_oneshot, guiboss_to_topwindow);
				}
		        );

			get_from_oneshot  reply_oneshot;
		    };

		#
		fun stop_gui
		      (
			running_gui:		rg::Running_Gui,							# Private
			bounce_imps:		Bounce_Imps,
			canvas_imps:		Canvas_Imps,
			packed_imps:		Packed_Imps,
			look_imps:		Look_Imps,
			topwindow_info:		Topwindow_Info
		      )
		      : sg::Stopped_Gui
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( sg::Stopped_Gui );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				put_in_oneshot  (reply_oneshot,  stop_gui' (runstate, (running_gui, bounce_imps, canvas_imps, packed_imps, look_imps, topwindow_info)))
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun start_gui												# PUBLIC.
		      (
			topwindow:	g2w::Guiboss_To_Topwindow,
			gui_plan:	gp::Gui_Plan
		      )
		    : (Void -> c2g::Client_To_Guiwindow)
		    =	
		    {   gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( c2g::Client_To_Guiwindow );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				start_gui' (runstate, topwindow, gui_plan, gui_startup_complete', guiboss_q, stop_gui)
		        );

			{.   get_from_oneshot  gui_startup_complete';   };
		    };

		#
		fun restart_gui												# PUBLIC.
		      (
			topwindow:	g2w::Guiboss_To_Topwindow,
			stopped_gui: 	sg::Stopped_Gui
		      )
		    : (Void -> c2g::Client_To_Guiwindow)
		    =	
		    {   gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( c2g::Client_To_Guiwindow );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				restart_gui' (runstate, topwindow, stopped_gui, gui_startup_complete', guiboss_q, stop_gui)
		        );

			{.   get_from_oneshot  gui_startup_complete';   };
		    };

		#
		fun get_bounce_theme ()											# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( bt::Gui_To_Bounce_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.gui_to_bounce_theme)
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun get_canvas_theme ()											# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( ct::Gui_To_Canvas_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.gui_to_canvas_theme)
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun get_packed_theme ()											# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( tp::Gui_To_Packed_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.gui_to_packed_theme)
			);

			get_from_oneshot reply_oneshot;
		    };
	    end;

	#
	fun process_options (options: List(Guiboss_Option), { name, id })
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME	n) =>   my_name			:=  n;
			do_option (ID			i) =>   my_id                   :=  i;
		    end;
		end;

		{ name			=>  *my_name,
		  id 			=>   *my_id
		};
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_guiboss_egg
	      (guiboss_arg:		Guiboss_Arg)									# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	    =
	    {	guiboss_arg ->  (guiboss_options);									# Currently no guiboss_needs component, so this is a no-op.
		#
		(process_options
		  ( guiboss_options,
		    { name		=> "guiboss",
		      id		=>  id_zero
		    }
		) )
		    ->
		    { name,
		      id
		    };
	
		my (id, guiboss_options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();										# Allocate unique imp id.
			(id, ID id ! guiboss_options);									# Make our id stable across stop/restart cycles.
		    else
			(id, guiboss_options);
		    fi;

		guiboss_arg = (guiboss_options);									# Currently no guiboss_needs component, so this is a no-op.

		me =  {
			topwindows	=>  REF im::empty								# Track all topwindows created by our make_topwindow() entrypoint.
		      };

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );		# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));					# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3											# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, guiboss_arg, imports, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
