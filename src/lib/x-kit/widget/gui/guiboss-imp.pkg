## guiboss-imp.pkg
#
# For the big picture see the imp dataflow diagrams in
#
#     src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
#
# The master imp responbible for GUI window startup and shutdown,
# driven by   Stopped_Gui specs					# stopped_gui			is from   src/lib/x-kit/widget/gui/stopped-gui.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  gui_types;					# gui_types			is from   src/lib/x-kit/widget/gui/gui-types.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    package gp  =  gui_plan;					# gui_plan			is from   src/lib/x-kit/widget/gui/gui-plan.pkg
    package sg  =  stopped_gui;					# stopped_gui			is from   src/lib/x-kit/widget/gui/stopped-gui.pkg
    package rg  =  running_gui;					# running_gui			is from   src/lib/x-kit/widget/gui/running-gui.pkg

    package bt  =  gui_to_bounce_theme;				# gui_to_bounce_theme		is from   src/lib/x-kit/widget/theme/bounce/gui-to-bounce-theme.pkg
    package ct  =  gui_to_canvas_theme;				# gui_to_canvas_theme		is from   src/lib/x-kit/widget/theme/canvas/gui-to-canvas-theme.pkg
    package tp  =  packed_theme;				# packed_theme			is from   src/lib/x-kit/widget/theme/packed/packed-theme.pkg

    package os  =  guiboss_to_bouncespace;			# guiboss_to_bouncespace	is from   src/lib/x-kit/widget/space/bounce/guiboss-to-bouncespace.pkg
    package cs  =  guiboss_to_canvasspace;			# guiboss_to_canvasspace	is from   src/lib/x-kit/widget/space/canvas/guiboss-to-canvasspace.pkg
    package ps  =  guiboss_to_packedspace;			# guiboss_to_packedspace	is from   src/lib/x-kit/widget/space/packed/guiboss-to-packedspace.pkg


    package boi =  bouncespace_imp;				# bouncespace_imp		is from   src/lib/x-kit/widget/space/bounce/bouncespace-imp.pkg
    package cai =  canvasspace_imp;				# canvasspace_imp		is from   src/lib/x-kit/widget/space/canvas/canvasspace-imp.pkg
    package pai =  packedspace_imp;				# packedspace_imp		is from   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

    #    
    package gws =  guiboss_to_windowsystem;			# guiboss_to_windowsystem	is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg
    package b2g =  guiboss_to_gadget;				# guiboss_to_gadget		is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg

    package blh =  bouncespace_layout_hint;			# bouncespace_layout_hint	is from   src/lib/x-kit/widget/space/bounce/bouncespace-layout-hint.pkg
    package clh =  canvasspace_layout_hint;			# canvasspace_layout_hint	is from   src/lib/x-kit/widget/space/canvas/canvasspace-layout-hint.pkg
    package plh =  packedspace_layout_hint;			# packedspace_layout_hint	is from   src/lib/x-kit/widget/space/packed/packedspace-layout-hint.pkg

    package b2s =  bouncespace_to_sprite;			# bouncespace_to_sprite		is from   src/lib/x-kit/widget/space/bounce/bouncespace-to-sprite.pkg
    package c2o =  canvasspace_to_object;			# canvasspace_to_object		is from   src/lib/x-kit/widget/space/canvas/canvasspace-to-object.pkg
    package p2w =  packedspace_to_widget;			# packedspace_to_widget		is from   src/lib/x-kit/widget/space/packed/packedspace-to-widget.pkg

    package s2b =  sprite_to_bouncespace;			# sprite_to_bouncespace		is from   src/lib/x-kit/widget/space/bounce/sprite-to-bouncespace.pkg
    package o2c =  object_to_canvasspace;			# object_to_canvasspace		is from   src/lib/x-kit/widget/space/canvas/object-to-canvasspace.pkg
    package w2p =  widget_to_packedspace;			# widget_to_packedspace		is from   src/lib/x-kit/widget/space/packed/widget-to-packedspace.pkg

    package s2g =   space_to_gui;				# space_to_gui			is from   src/lib/x-kit/widget/gui/space-to-gui.pkg
    package g2g =  gadget_to_guiboss;				# gadget_to_guiboss		is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
    package c2g =  client_to_guiboss;				# client_to_guiboss		is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap		is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package iul =  issue_unique_look_id;			# issue_unique_look_id		is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    package im  =  int_red_black_map;				# int_red_black_map		is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set		is from   src/lib/src/int-red-black-set.pkg

    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d			is from   src/lib/std/2d/geometry2d.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log				is from   src/lib/std/src/log.pkg

    dummy1 = evt::t::bin_op;		# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
    dummy2 = gts::gui_event_name;	# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
herein

    package guiboss_imp
    :       Guiboss_Imp													# Guiboss_Imp		is from   src/lib/x-kit/widget/gui/guiboss-imp.api
    {
	include package   client_to_guiboss;										# client_to_guiboss	is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
	#

	Imports = {													# Ports we use, provided by other imps.
		    int_sink:			Int -> Void,
		    guiboss_to_windowsystem:	gws::Guiboss_To_Windowsystem,	
		    gui_to_bounce_theme:	bt::Gui_To_Bounce_Theme,
		    gui_to_canvas_theme:	ct::Gui_To_Canvas_Theme,
		    theme:			tp::Packed_Theme
		  };

	Bounce_Imps
	  =
	  Ref( im::Map( { sprite_to_bouncespace:	s2b::Sprite_To_Bouncespace,					# Possibly this should be stored in Running_Gui rather than here; time will tell. This is a good first try.
			  guiboss_to_bouncespace:	os::Guiboss_To_Bouncespace,
			  endstate_oneshot:		Oneshot_Maildrop( os::Bouncespace_Arg )
			}
	     )        );

	Canvas_Imps
	  =
	  Ref( im::Map( { object_to_canvasspace:	o2c::Object_To_Canvasspace,					# Possibly this should be stored in Running_Gui rather than here; time will tell. This is a good first try.
			  guiboss_to_canvasspace: 	cs::Guiboss_To_Canvasspace,
			  endstate_oneshot:		Oneshot_Maildrop( cs::Canvasspace_Arg )
			}
	     )        );

	Packed_Imps
	  =
	  Ref( im::Map( { widget_to_packedspace:	w2p::Widget_To_Packedspace,					# Possibly this should be stored in Running_Gui rather than here; time will tell. This is a good first try.
			  guiboss_to_packedspace: 	ps::Guiboss_To_Packedspace,
			  endstate_oneshot:		Oneshot_Maildrop( ps::Packedspace_Arg )
			}
	     )        );


	Site = Ref( g2d::Box );												# Pixel-rectangle assigned to the widget, in backing-pixmap coordinates.

	Gadget_Info													# The per-gadget information we track.  (This is private to guiboss-imp.)
	  =														# Here 'gadget' refers indifferently to widget-imps, sprite-imps and object-imps.
	  {
	    site:			Site,										# Where to draw this gadget, in topwindow coordinates.
	    backing_pixmap:		Ref(s2g::Backing_Pixmap),
	    #
	    guiboss_to_gadget:		b2g::Guiboss_To_Gadget,								# We use this to make requests of visible gadgets.
	    gadget_mode:		Ref( g2g::Gadget_Mode ),
	    #
	    may_have_visibly_changed:	Ref( Bool ),									# 
	    #
	    point_in_gadget:		Ref( Null_Or( g2d::Point -> Bool ))						# Optional fn to decide if a mouseclick actually hit the gadget itself, or just somewhere near it in the screenspace assigned to it.
	  };  

	Gadget_Imps
	  =
	  Ref( im::Map( Gadget_Info ) );										# We use this to make requests of visible gadgets.	Index is  (id_to_int guiboss_to_gadget.id).

	Topwindow_Info
	  =
	  { # These three are valid throughout
	    # the lifetime of the topwindow:
	    #
	    guiboss_to_topwindow:		gws::Guiboss_To_Topwindow,
	    current_frame_number:		Ref(Int),								# We count frames for convenience of widgets and debugging.
	    seconds_per_frame:			Ref(Float),								# Primarily so widgets can do motion blurring if they wish.

	    done_extra_startframe_this_frame:	Ref(Bool),								# See Note[1].

	    # The remainder are valid only while a gui is running,
	    # which is to say, between restart_gui' and stop_gui':

	    # These three are set by restart_gui'()
	    # and reset to NULL by stop_gui'     
	    #
	    running_gui:		Ref( Null_Or( rg::Running_Gui  ) ),
	    gadget_to_guiboss:		Ref( Null_Or( g2g::Gadget_To_Guiboss ) ),					# Interface for gadget-imps to contact us.
	    space_to_gui:		Ref( Null_Or( s2g::Space_To_Gui) ),						# Interface for  space-imps to contact us.

	    # These four are reset to im::empty by stop_gui';
	    #
	    gadget_imps:		Gadget_Imps,									# Holds our     Gadget_Info            instances -- basically, all running widgets, sprites and objects in topwindow.
	    bounce_imps:		Bounce_Imps,									# Holds our os::Guiboss_To_Bouncespace instances -- can't put them directly in Running_Gui due to circularity.
	    canvas_imps:		Canvas_Imps,									# Holds our cs::Guiboss_To_Canvasspace instances -- can't put them directly in Running_Gui due to circularity.
	    packed_imps:		Packed_Imps									# Holds our ps::Guiboss_To_Packedspace instances -- can't put them directly in Running_Gui due to circularity.
	  };

	Guiboss_State													# Holds all nonephemeral mutable state maintained by shape.
	  =
	  {
	    topwindows:			Ref( im::Map( Topwindow_Info  ) )						# Each call to client_to_guiboss.make_topwindow() adds one entry to this.  Indexed by guiboss_to_topwindow.id.
	  };

	Me_Slot = Mailslot( { imports:		Imports,
			      me:		Guiboss_State,
			      guiboss_arg:	Guiboss_Arg,
			      run_gun':		Run_Gun,
			      end_gun':		End_Gun
			    }
			  );

	Exports	= {													# Ports we provide for use by other imps.
		    client_to_guiboss:	Client_To_Guiboss
		  };


	Guiboss_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);


	Runstate =    {													# These values will be statically globally visible throughout the code body for the imp.
			me:			Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
			guiboss_arg:		Guiboss_Arg,
			imports:		Imports,								# Imps to which we send requests.
			to:			Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
			end_gun':		End_Gun,								# We shut down the microthread when this fires.
			id:			Id
		      };

	Guiboss_Q    = Mailqueue( Runstate -> Void );


	fun clear_box_in_pixmap												# Clear a box to black, mostly to avoid undefined values etc.
	      (
		pixmap:			s2g::Backing_Pixmap,								# pixmap holding the viewport.
		box:			g2d::Box									# Box in view coordinates.
	      )
	    =
	    {
		#
		case pixmap
		    #
		    s2g::TOPWINDOW_PIXMAP { pixmap:	g2p::Gadget_To_Rw_Pixmap      } => pixmap.draw_displaylist [ gd::COLOR (r64::black,  [ gd::FILLED_BOXES [ box ]]) ];
		    s2g::VIEWPORT_PIXMAP  { pixmap:	g2p::Gadget_To_Rw_Pixmap, ... } => pixmap.draw_displaylist [ gd::COLOR (r64::black,  [ gd::FILLED_BOXES [ box ]]) ];
		esac;
	    };

															# Nomenclature: "blit" is from "BitBLT" == "bit-boundary block transfer" -- originally a Xerox Alto graphics op, now informal jargon term. For more info:   http://en.wikipedia.org/wiki/Bit_blit
															# Because we allow nested scrollable subwindows of main topwindow for app,
															# it is nontrivial to figure out where on the topwindow a given gadget is
															# visible -- if it is visible at all! -- and how much is visible, and what
		 													# pixel rectangle to copy from where to where to update the gadget's on-
															# screen image.  That's our job here.
	fun update_offscreen_parent_pixmaps_and_then_topwindow
	      (
		pixmap:				s2g::Backing_Pixmap,
		from_box:			g2d::Box,								# From-box in source pixmap.
		topwindow_for_gui:		gws::Guiboss_To_Topwindow
	      )
	    =
	    {
		propagate_frombox_changes_to_all_parents_in_which_they_are_visible
		    #
		    (pixmap, from_box);											# Copy visible part of gadget to the backing pixmap for the viewport containing it, the backing pixmap for the viewport containing that viewport etc and finally the visible topwindow itself.
	    }														# Typically there will be no viewports involved, so this will be just a blit to the topwindow.
	    where
		fun propagate_frombox_changes_to_all_parents_in_which_they_are_visible					# Caller has just changed contents of from_box in backing_pixmap:  We need to propagate these changes to all parents in which it is visible.
		      (
			backing_pixmap
			as
			s2g::TOPWINDOW_PIXMAP _,

			from_box:	g2d::Box									# From-box in source pixmap.
		      )
			=>
			{
			    from_id   =  s2g::backing_pixmap_id_of  backing_pixmap;					# This is the pixmap holding the source pixels for the blit.
			    #
			    to_point  = g2d::box::upperleft  from_box;							# Where should we copy pixels to, on the visible topwindow?   Since there is no viewport involved here, this is the null transform.

			    from_id =  s2g::backing_pixmap_id_of  backing_pixmap;					# The Id for the source pixmap for the copy.
			    #
			    topwindow_for_gui.draw_displaylist								# Blit visible part of gadget (maybe all) to visible window for user to see.
			      [
				gd::COPY_FROM_RW_PIXMAP { from_box, to_point, from_id }
			      ];
			};

		    propagate_frombox_changes_to_all_parents_in_which_they_are_visible
		      (
			backing_pixmap
			as
			s2g::VIEWPORT_PIXMAP  { is_visible:	Ref( Bool ),
						pixmap:		g2p::Gadget_To_Rw_Pixmap,
						viewports:	Ref( List( s2g::Viewport ) )				# We make this a Ref(List(...)) to allow for adding additional viewports opening onto the same underlying pixmap.
					      },

			from_box:	g2d::Box									# From-box in source pixmap.
		      )
			=>
			if (*is_visible)										# Do not propagate if we are one of multiple TABBED_VIEWS and we are not visible.
			    #	
			    from_id   =  s2g::backing_pixmap_id_of  backing_pixmap;					# The Id for the source pixmap for the copy.

			    to_point  = g2d::box::upperleft  from_box;							# Where should we copy pixels to, on our parent pixmap?   We initialize this to the null transform -- we'll add in appropriate offsets to this momentarily.

			    apply   do_viewport  *viewports								# We may be visible in multiple viewports, each of which may be visible in multiple viewports, so potentially we need to update a tree of parents.
				    where
					fun do_viewport											# Handle update of our image as visible via one parent viewport.
					      {	parent_pixmap:	s2g::Backing_Pixmap,
						viewport_site:	Ref(g2d::Box),								# Size and location of subwindow viewport in parent Backing_Pixmap coordinates.
						#
						view_origin:	Ref(g2d::Point)								# Used to scroll subwindow contents around in parent viewport: view origin in viewport coordinates.
					      }
					    =
					    {	viewport_origin_in_view									# If the from_box is not entirely visible in the viewport
						    =											# then we need to clip it to the viewport.  Since we want
						    g2d::point::zero - *view_origin;							# the clipped from_box to be in the gadget's home pixmap,
																	# the most straightforward approach is to transform the
																	# viewport into home pixmap space.  If *view_origin is
						viewport' = g2d::box::clone_box_at (*viewport_site, viewport_origin_in_view);		# 0,0 then viewport is at (0,0) in home pixmap, otherwise
																	# it is offset by -*view_origin, so in general we want
																	# the viewport cloned at -*view_origin.

						case (g2d::box::intersection (viewport', from_box))
						    #
						    NULL => ();										# No intersection between from_box and viewport' means no part of gadget is visible, so just return NULL.
						    #
						    THE from_box'
							=>
							{
							    my (to_point, from_box)							# Update to_point and from_box to account for clipping due
								=									# to intersection between viewport and old from_box value.
								if (g2d::box::eq (from_box', from_box))
								    #
								    (to_point, from_box);						# No actual clipping (from_box must be completely visible in viewport) so nothing to do here.

								elif (g2d::point::eq ( g2d::box::upperleft( from_box' ),		# Is origin of from_box' different from origin or from_box?
										       g2d::box::upperleft( from_box  )
								     ) 		   )

								    (to_point, from_box');						# No, so to_point stays the same, we just replace from_box with from_box'.
								else
																	# Yes, so we need to move to_point to reflect displacement between from_box and from_box'.
								    frombox_displacement
									=
									g2d::point::subtract( g2d::box::upperleft( from_box' ),		# Compute that displacement.
											      g2d::box::upperleft( from_box  )
											    );

								    to_point'   = g2d::point::add (to_point, frombox_displacement);	# Apply it.

								    (to_point', from_box');						# Done.
								fi;

																	# Now we just need to compute where from_box should be drawn in
																	# current sub/window, then update to_point and continue recursively.

							    to_point = g2d::point::add (to_point, *view_origin);			# Account for location of view  relative to viewport.
							    to_point = g2d::point::add (to_point, g2d::box::upperleft(*viewport_site));	# Account for location of viewport relative to parent pixmap.

							    parent_pixmap' =  s2g::gadget_to_rw_pixmap__of  parent_pixmap;		# Find off-screen backing pixmap containing viewport onto us.
							    from_id	   =  pixmap.id;						# Pixmap to copy rectangle from (as Id).
							    gui_displayop  =  gd::COPY_FROM_RW_PIXMAP { from_box, to_point, from_id };	# The actual copy from our pixmap to viewport area in parent pixmap.
							    #										#
							    parent_pixmap'.draw_displaylist [ gui_displayop ];				# Draw updated gadget appearance into its off-screen backing-pixmap home site.

							    from_box = g2d::box::clone_box_at (from_box, to_point);			# Our to-box is from_box for the next level of recursion.

							    propagate_frombox_changes_to_all_parents_in_which_they_are_visible		# Continue recursively to next level of viewport nesting.
								#
								(parent_pixmap, from_box);
							};
						esac;
					    };
				    end;	
			fi;
		end;
	    end;

	fun run ( guiboss_q:			Guiboss_Q,								# 
		  #
		  runstate as
		  {													# These values will be statically globally visible throughout the code body for the imp.
		    me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		    guiboss_arg:		Guiboss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# We shut down the microthread when this fires.
		    id:				Id
		  }
		)
	    =
	    {	loop ();
	    }
	    where


		#
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    end_gun'                       ==>  shut_down_guiboss_imp',
			    take_from_mailqueue' guiboss_q ==>  do_guiboss_plea
			];

			loop ();
		    }	
		    where
			fun do_guiboss_plea  thunk
			    =
			    thunk runstate;
			#
			fun shut_down_guiboss_imp' ()
			    =
			    {
				thread_exit { success => TRUE };							# Will not return.	
			    };
		    end;
	    end;	
	#
	fun stop_gui'
	      (
		{ me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		  guiboss_arg:			Guiboss_Arg,
		  imports:			Imports,								# Imps to which we send requests.
		  to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		  end_gun':			End_Gun,
		  id:				Id
		}:				Runstate,
		( running_gui:			rg::Running_Gui,
		  bounce_imps:			Bounce_Imps,
		  canvas_imps:			Canvas_Imps,
		  packed_imps:			Packed_Imps,
		  gadget_imps:			Gadget_Imps,
		  topwindow_info:		Topwindow_Info
		)
	      )
	    =
	    {	running_gui.fire_end_gun ();									# Shut down GUI impnet.
		#
		result = running_gui__to__stopped_gui  running_gui;						# Return sufficient information to recreate the GUI.

		# Clear state which is only valid while the gui is running:
		#
		topwindow_info.running_gui	    := NULL;
		topwindow_info.gadget_to_guiboss    := NULL;
		topwindow_info.space_to_gui	    := NULL;
		#
		topwindow_info.bounce_imps	    := im::empty;
		topwindow_info.canvas_imps	    := im::empty;
		topwindow_info.packed_imps	    := im::empty;
		topwindow_info.gadget_imps	    := im::empty;

		result:				sg::Stopped_Gui;
	    }													#
	    where
		fun running_gui__to__stopped_gui
		    # 
		    (running_gui: 	rg::Running_Gui)
		    :
		    ( ps::Packedspace_Arg,
		      sg::Packed_Widget
		    )
		    =
		    {
			running_gui ->    { fire_end_gun:	Void -> Void,							# Signal which will shut down the GUI impnet.
					    #
					    packedspace_id:	rg::Packedspace_Id,						# Runtime GUI state synthesized locally per client spec.
					    packed_widget:	rg::Packed_Widget,						# "                                       ".
					    topwindow:		gws::Guiboss_To_Topwindow,
					    topwindow_pixmap:	s2g::Backing_Pixmap						# Holds toplevel s2g::TOPWINDOW_PIXMAP for gui.
					  };

			packed_widget''
			    =
			    do_packed_widget  packed_widget;

			(im::get_or_raise_exception_not_found (*packed_imps, (id_to_int packedspace_id)))
			    ->
			    { widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot };	

			( get_from_oneshot   endstate_oneshot,								# Read final state of packedspace-imp -- incidentally confirming that it has completed its shutdown.
			  packed_widget''
			);
		    }

		also
		fun do_packed_widget  (packed_widget: rg::Packed_Widget)
		    =
		    case packed_widget
			#
			rg::ROW	{ widgets: List(  { widget:		rg::Packed_Widget,
						    cooked_hints:	rg::Packed_Layout_Hints,
						    raw_hints:		List(plh::Packedspace_Layout_Hint)
						  }
					       ),
				  pixels_high_min:	Ref(Int),
				  pixels_wide_min:	Ref(Int),
				  #
				  pixels_high_cut:	Ref(Float),
				  pixels_wide_cut:	Ref(Float),
				  #
				  site:			Ref(g2d::Box)
				}
			    =>
			    sg::ROW (map  do_widget  widgets)
				    where
					fun do_widget (r: rg::Row_Widget)
					    =
					    ( r.raw_hints,
					      do_packed_widget  r.widget
					    );
				    end;	

			rg::COL	{ widgets: List(  { widget:		rg::Packed_Widget,
						    cooked_hints:	rg::Packed_Layout_Hints,
						    raw_hints:		List(plh::Packedspace_Layout_Hint)
						  }
					       ),
				  pixels_high_min:	Ref(Int),
				  pixels_wide_min:	Ref(Int),
				  #
				  pixels_high_cut:	Ref(Float),
				  pixels_wide_cut:	Ref(Float),
				  #
				  site:			Ref(g2d::Box)
				}
			    =>
			    sg::COL (map  do_widget  widgets)
				    where
					fun do_widget (r: rg::Col_Widget)
					    =
					    ( r.raw_hints,
					      do_packed_widget  r.widget
					    );
				    end;	

			rg::SCROLLABLE_VIEW
				{ widget:		rg::Packed_Widget,

# Should we delete packing_pixmap at this point?  If not, when does it get recycled? 			*** XXX QUERO FIXME ***

				  gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,
				  view_origin:		Ref(g2d::Point),						# Origin of backing_pixmap in viewport coordinates, used for scrolling pixmap in viewport.
				  scroller:		gt::Viewport_Scroller,
				  callback:		gt::Viewport_Scroller_Callback,
				  backing_pixmap:	s2g::Backing_Pixmap,						# 
				  site:			Ref(g2d::Box)
				}
			    =>
			    {	callback NULL;										# Tell app code that our viewport_scroller is no longer active.
				#
				widget      =  do_packed_widget  widget;

				pixmap_size =  gadget_to_rw_pixmap.size;
				#
			        sg::SCROLLABLE_VIEW (callback, pixmap_size, widget);
			    };

			rg::TABBED_VIEWS
				{ callback:		gt::Tabbed_View_Picker_Callback,
				  widgets:		List(rg::Tabview),
				  pixmap_size:		g2d::Size,
				  visible_widget:	Ref(  rg::Tabview ),
#				  viewport:		Ref(g2d::Box),							# The actual site assigned to the viewport on its home pixmap.  This gets set by   assign_sites_to_all_widgets()   in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				  site:			Ref(g2d::Box)
				}
			    =>
			    {   callback NULL;										# Tell app code that our tabbed_view_picker is no longer active.
				#
				sg::TABBED_VIEWS (callback,  pixmap_size,  map  do_widget  widgets)
					where
					    fun do_widget { widget: 		rg::Packed_Widget,
							    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,		# Should we delete this at this point?  If not, when does it get recycled?
							    backing_pixmap:		s2g::Backing_Pixmap			# 
							  }

						=
						do_packed_widget  widget;
					end;
			    };

			rg::WIDGET r
			    =>
			    sg::WIDGET (get_from_oneshot   r.endstate_oneshot);						# Read and return final state of widget-imp -- incidentally confirming that it has completed its shutdown.


			#
			rg::CANVASSPACE  canvasspace
			    =>
			    do_canvasspace  canvasspace;

			rg::BOUNCESPACE  bouncespace
			    =>
			    do_bouncespace  bouncespace;

			rg::NULL_PACKED_WIDGET
			    =>
			    sg::NULL_PACKED_WIDGET;
		    esac


		also
		fun do_bouncespace r
		    =
		    {
			widgets =  do_bounce_widgets  r.widgets;
			#
			(im::get_or_raise_exception_not_found (*bounce_imps, (id_to_int r.bouncespace_id)))
			    ->
			    { guiboss_to_bouncespace, sprite_to_bouncespace, endstate_oneshot };

			arg =  get_from_oneshot  endstate_oneshot;

		        sg::BOUNCESPACE (arg, widgets);
		    }

		also
		fun do_bounce_widgets (widgets':  List ((List(blh::Bouncespace_Layout_Hint), rg::Bounce_Widget)))
		    =
		    {
			widgets'' = map  do_widget  widgets'
				    where
					fun do_widget' (widget': rg::Bounce_Widget)
					    =
					    case widget'
						#
						rg::SPRITE r
						    =>
						    sg::SPRITE (get_from_oneshot   r.endstate_oneshot);		# Read and return final state of sprite-imp -- incidentally confirming that it has completed its shutdown.
					    esac;
					#
					fun do_widget (layout_hints:  List(blh::Bouncespace_Layout_Hint), widget': rg::Bounce_Widget)
					    =
					    {   widget'' = do_widget'  widget';
						#
						(layout_hints, widget'');
					    };
				    end;

			widgets'';
		    }


		also
		fun do_canvasspace r
		    =
		    {	widgets =  do_canvas_widgets  r.widgets;
			#
			(im::get_or_raise_exception_not_found (*canvas_imps, (id_to_int r.canvasspace_id)))
			    ->
			    { guiboss_to_canvasspace, object_to_canvasspace, endstate_oneshot };

			arg =  get_from_oneshot  endstate_oneshot;

		        sg::CANVASSPACE (arg, widgets);
		    }

		also
		fun do_canvas_widgets (widgets':  List ((List(clh::Canvasspace_Layout_Hint), rg::Canvas_Widget)))
		    =
		    {
			widgets'' = map  do_widget  widgets'
				    where
					fun do_widget' (widget': rg::Canvas_Widget)
					    =
					    case widget'
						#
						rg::OBJECT r
						    =>
						    sg::OBJECT (get_from_oneshot   r.endstate_oneshot);	# Read and return final state of object-imp -- incidentally confirming that it has completed its shutdown.

						rg::PACKEDSPACE
						      { packedspace_id:		rg::Packedspace_Id,
							packed_widget:		rg::Packed_Widget
						      }
						    =>
						    {	packed_widget'' =  do_packed_widget packed_widget;
							#
							(im::get_or_raise_exception_not_found (*packed_imps, (id_to_int packedspace_id)))
							    ->
							    { widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot };

							sg::PACKEDSPACE
							  (
							    get_from_oneshot   endstate_oneshot,		# Read and return final state of packedspace-imp -- incidentally confirming that it has completed its shutdown.
							    packed_widget''
							  );
						    };
					    esac;
					#
					fun do_widget (layout_hints:  List(clh::Canvasspace_Layout_Hint), widget': rg::Canvas_Widget)
					    =
					    {   widget'' = do_widget'  widget';
						#
						(layout_hints, widget'');
					    };
				    end;

			widgets'';
		    };													# fun do_canvas_widgets
	    end;
	#
	fun restart_gui'
	      (
		runstate as
		  { me:				Guiboss_State,								# State which is preserved across imp shutdown/restart cycles.
		    guiboss_arg:		Guiboss_Arg,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# We shut down the microthread when this fires.
		    id:				Id
		  }:				Runstate,
	
		topwindow_for_gui:		gws::Guiboss_To_Topwindow,
		stopped_gui:			sg::Stopped_Gui,

		gui_startup_complete':		Oneshot_Maildrop( c2g::Client_To_Guiwindow ),
		guiboss_q:			Guiboss_Q,
		stop_gui:			(rg::Running_Gui, Bounce_Imps, Canvas_Imps, Packed_Imps, Gadget_Imps, Topwindow_Info) -> sg::Stopped_Gui
	      )
	    =
	    {

		#
		running_gui = stopped_gui__to__running_gui  stopped_gui;						# Starts up all widget look-imps and state-imps plus the canvas- bounce- and packedspace imps,
															# and populates our bounce_imps, canvas_imps, packed_imps and gadget_imps maps.

		topwindow_info.running_gui :=  THE running_gui;								# Remember that we now have a gui running on this topwindow.

		fire_run_gun ();

		topwindow_for_gui.pass_window_site to
		    #
		    (\\ ({ size => { high, wide }, ... }: g2d::Window_Site)
			=
			{
			    (im::get_or_raise_exception_not_found (*packed_imps, (id_to_int running_gui.packedspace_id)))
				->
				{ widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot };


			    site =  { col => 0,  high,									# Allocate all of window pixel area to widgets in running_gui.packed_widget widget-tree.
				      row => 0,  wide
				    }
				    : g2d::Box;

			    guiboss_to_packedspace.pass_re_siting_done_flag
				( site,
				  running_gui.topwindow_pixmap,
				  running_gui.packed_widget
				)
				to
				{.
				    rg::running_gui_postorder_apply								# If a view pixmap is too small to fill its viewport there will be undefined pixels showing in the viewport.
				      (												# By setting the origin to its default 0,0 we trigger the logic to black out these undefined areas.
					running_gui,										# Does doing result in a double-draw of views at GUI startup?  If so, that might someday prove problematic: XXX QUERO FIXME
					[ rg::SCROLLABLE_VIEW_FN
					    {.
						(#scrollable_view).scroller.set_viewport_origin
						    { row => 0, col => 0 };
					    }
					]
				      );
				    client_to_guiwindow
				      =
				      { id       =>  topwindow_for_gui.id,
					stop_gui =>  {. stop_gui (running_gui, bounce_imps, canvas_imps, packed_imps, gadget_imps, topwindow_info); }
				      }
				      : c2g::Client_To_Guiwindow
				      ;

				    put_in_oneshot (gui_startup_complete', client_to_guiwindow);
				}; 

			}
		    );
	    }
	    where
		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

printf "restart_gui'/AAA\n";
		topwindow_info = im::get_or_raise_exception_not_found (*me.topwindows, id_to_int topwindow_for_gui.id)
				 except
				     NOT_FOUND = {   printf                "*me.topwindows contains no entry for topwindow %d?!   -- restart_gui' in guiboss-imp.pkg\n" (id_to_int topwindow_for_gui.id);
						     log::fatal (sprintf "*me.topwindows contains no entry for topwindow %d?!   -- restart_gui' in guiboss-imp.pkg" (id_to_int topwindow_for_gui.id));
						     raise exception NOT_FOUND;						# Execution will never reach this point, but the compiler doesn't know that log::fatal doesn't return.
						 };
printf "restart_gui'/BBB\n";
		bounce_imps			=  topwindow_info.bounce_imps;						# Holds our os::Guiboss_To_Bouncespace instances -- can't put them directly in Running_Gui due to circularity.
		canvas_imps			=  topwindow_info.canvas_imps;						# Holds our cs::Guiboss_To_Canvasspace instances -- can't put them directly in Running_Gui due to circularity.
		packed_imps			=  topwindow_info.packed_imps;						# Holds our ps::Guiboss_To_Packedspace instances -- can't put them directly in Running_Gui due to circularity.
		gadget_imps			=  topwindow_info.gadget_imps;						# Holds look-imps for all the widgets in our gui.

		current_frame_number		=  topwindow_info.current_frame_number;
		seconds_per_frame		=  topwindow_info.seconds_per_frame;

		done_extra_startframe_this_frame=  topwindow_info.done_extra_startframe_this_frame;

		# We expect the following fns to capture the above values:
		# that is why we define them here rather than more globally.

		#
		fun get_gadget_info
		      (
			gadget_imps:	Gadget_Imps,
			id:		iul::Id
		      )
		    =
		    case (im::get (*gadget_imps,  iul::id_to_int id))
			#
			THE gadget_info =>    gadget_info;

			NULL =>     {   msg = sprintf "imp %d not found in gadget_imps?! -- get_gadget_info in guiboss-imp.pkg" (iul::id_to_int id);	# Should be impossible -- all widgets, sprites and objects should be in gadget_imps.
					log::note_on_stderr {. msg; };
					raise exception FAIL msg;
				    };
		    esac;



		fun gadget_may_need_redraw (i: Gadget_Info)
		    =
		    {
			i.may_have_visibly_changed :=  TRUE;
		    };

		#################################################################################
		# space_to_gui interface fns:

		#
		fun note_widget_site
		      {
			id:		iul::Id,
			backing_pixmap: s2g::Backing_Pixmap,
			site:		g2d::Box
		      }													# PUBLIC.
		    =	
		    # This fn is called by
		    #
		    #   src/lib/x-kit/widget/space/bounce/bouncespace-imp.pkg
		    #   src/lib/x-kit/widget/space/canvas/canvasspace-imp.pkg
		    #   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg  
		    #
		    # when they assign a widget a new site in response to our call
		    #
		    #     guiboss_to_packedspace.pass_re_siting_done_flag
		    #
		    put_in_mailqueue  (guiboss_q,
			#
			\\ ({ me, ... }: Runstate)
			    =
			    {   i = get_gadget_info (gadget_imps, id);
				#
				if (site != *i.site									# Has the window site of this widget changed?
				or   (not (same_id ( s2g::backing_pixmap_id_of    backing_pixmap,
						     s2g::backing_pixmap_id_of *i.backing_pixmap
				    ) )   )        )
				    #											# Yes.
				    i.site :=  site;									# Note site for widget.

				    i.backing_pixmap :=  backing_pixmap;						# Note pixmap for widget.

				    gadget_may_need_redraw i;
				fi;
			    }
		    );

		space_to_gui =	      { id => topwindow_for_gui.id,							# Since each topwindow has a unique id and we will have only one space_to_gui per topwindow, using topwindow_for_gui.id
					#										# here ensures a unique id per space_to_gui. It also makes space_to_gui.id stable across gui stop/restart cycles.
					note_widget_site
				      };

		topwindow_info.space_to_gui :=  THE space_to_gui;


		#################################################################################
		# gadget_to_guiboss interface fns:
		#
		fun gadget_may_have_visibly_changed									# PUBLIC.
		      (
			id:		iul::Id
		      )
		    =	
		    # The point of this call is to alert us that the
		    # GUI display needs refreshing.
		    # If no widget calls this, we can stop the frame-
		    # redisplay cycle to conserve CPU cycles:
		    #
		    {   put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{
				    i = get_gadget_info (gadget_imps, id);
				    #
				    gadget_may_need_redraw i;

# Actually, I don't think this is a good idea,
# I just want to do this on mouseclick and keypress.
#
#				    if (not *done_extra_startframe_this_frame)
#					#
#					# Send a startframe to the gadget:
#
#					i -> { guiboss_to_gadget, site, gadget_mode, may_have_visibly_changed, ... };
#
#					guiboss_to_gadget.start_of_frame  { frame_number => *current_frame_number,
#									    site	 => *site,
#									    visible	 	=> TRUE,
#									    duration_in_seconds => 0.0,
#									    this_gadget_mode => *gadget_mode,
#									    theme => imports.theme
#									  };
#				    fi;
				}
		        );
		    };

		fun draw_gadget (clip_box, gui_displaylist, gadget_info: Gadget_Info)
		    =
		    {	gui_displaylist = [ gd::CLIP_TO (clip_box, gui_displaylist) ];					# Clip gadget's displaylist to its assigned site so it won't traspass on neighboring gadgets if it gets sloppy.
			#
			gadget_to_rw_pixmap =  s2g::gadget_to_rw_pixmap__of  *gadget_info.backing_pixmap;		# Find gadget's assigned off-screen backing pixmap.

			gadget_to_rw_pixmap.draw_displaylist  gui_displaylist;						# Draw updated gadget appearance into its off-screen backing-pixmap home site.

															# Now to update on-screen image of gadget (if it is visible).
															#
															# We'll update the gadget on the visible window by doing a rectangular blit
															# from offscreen backing pixmap to on-screen pixel refresh buffer.
															#
															# Just redrawing gui_displaylist a second time would be another strategy.
															# The blit has the advantage that the worst case is pretty fast, whereas
															# the worst case for redrawing gui_displaylist can be arbitrarily slow.
															#
															# Also, draw-offscreen-and-blit completely eliminates redraw flicker
															# where "flicker" == partly-redrawn widget being visible momentarily:
															# it is essentially a primitive form of double-buffering.

			from_box =  *gadget_info.site;									# Where should we copy pixels from, on gadget's home pixmap?  We initialize this to the full site for the gadget; later it may get clipped by viewports.
			pixmap	 =  *gadget_info.backing_pixmap;							
			#		
			update_offscreen_parent_pixmaps_and_then_topwindow  (pixmap, from_box, topwindow_for_gui);
		    };

		#
		fun update_gadget_appearance										# Update gadget appearance in response to a guiboss_to_gadget.start_of_frame {...} call.
		      {
			id:			iul::Id,
			displaylist:		gd::Gui_Displaylist,
			point_in_gadget:	Null_Or( g2d::Point -> Bool )
		      }
		    =
		    # The point of this call is to update the appearance
		    # of the gadget.  This call is normally made in response
		    # to  guiboss_to_gadget.start_of_frame {}								# guiboss_to_gadget	is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg
		    #
		    {   put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{
				    i = get_gadget_info (gadget_imps, id);
				    #
				    i.point_in_gadget := point_in_gadget; 
				    #
				    draw_gadget (*i.site, displaylist, i);
				}
		        );
		    };



		#
		fun note_changed_gadget_activity									# PUBLIC.
		      {
			id:		iul::Id,
			is_active:	Bool
		      }
		    =	
		    # The point of this call is to mark gadget as not
		    # eligible for user input.  It will often be drawn grayed-out.
		    #
		    {   put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{
				    i = get_gadget_info (gadget_imps, id);
				    #
				  (*i.gadget_mode) -> { is_active => _, has_mouse_focus, has_keyboard_focus, mousebutton_is_down };
				    i.gadget_mode  := { is_active,      has_mouse_focus, has_keyboard_focus, mousebutton_is_down };
				}
		        );
		    };

		gadget_to_guiboss =   { id => topwindow_for_gui.id,			# Since each topwindow has a unique id and we will have only one gadget_to_guiboss per topwindow, using topwindow_for_gui.id
					#						# here ensures a unique id per gadget_to_guiboss. It also makes gadget_to_guiboss.id stable across gui stop/restart cycles.
					gadget_may_have_visibly_changed,
					#
					update_gadget_appearance,
					note_changed_gadget_activity
				      };	


		topwindow_info.gadget_to_guiboss
		    :=
		    THE gadget_to_guiboss;




		#################################################################################
		# frameclock microthread -- wakes us up 10 times/sec to draw a frame.
		#


		first_frame = REF TRUE;
																    foo = REF 19;
		fun display_one_frame ({ me, imports, ... }: Runstate)
		    =
		    {
			current_frame_number := *current_frame_number + 1;
			#
			done_extra_startframe_this_frame	:= FALSE;							# See Note[1].

			imps =  im::vals_list  *gadget_imps;

			if *first_frame
			    first_frame := FALSE;
			    apply' imps  {.
				#imp -> { guiboss_to_gadget, site, gadget_mode, may_have_visibly_changed, ... };

				guiboss_to_gadget.before_first_frame  { site		=> *site,
								        theme		=>  imports.theme,
									 get_font	=>  topwindow_for_gui.get_font,
									pass_font	=>  topwindow_for_gui.pass_font,
									make_rw_pixmap	=>  imports.guiboss_to_windowsystem.make_rw_pixmap
								      };

				may_have_visibly_changed  := TRUE;
			    };
			fi;

			apply' imps  {.
			    #imp -> { guiboss_to_gadget, site, gadget_mode, may_have_visibly_changed, ... };
				#

			    if (*may_have_visibly_changed)
				#
			        guiboss_to_gadget.start_of_frame
				  {
				    frame_number => *current_frame_number,
				    site => *site,
				    visible => TRUE,
				    duration_in_seconds => 0.0,
				    this_gadget_mode => *gadget_mode,
				    theme => imports.theme
				  };

				may_have_visibly_changed := FALSE;
			    fi;
			};

			apply' imps  {.
			    #
			    #imp -> { may_have_visibly_changed,
				      guiboss_to_gadget,
				      site,	
				      ...
                                    };
			};
		    };	

# XXX SUCKO FIXME we should probably just use the 50HZ timeslicing clock.
		# This fn provides the body for a little microthread which just
		# loops ten times a second telling our main thread to disply frame:
		#
		fun frameclock end_gun'
		    =
		    loop ()
		    where
			count = REF 19;
			#
			fun loop ()
			    =
			    {
				do_one_mailop [
				    #
				    end_gun'
					==>
					{.
					    thread_exit { success => TRUE };
					},
				    #
				    timeout_in' *seconds_per_frame
					==>
					{.
					    put_in_mailqueue  (guiboss_q, display_one_frame);
					}
				];

				loop ();
			    };
		    end;

		make_thread'  [ THREAD_NAME "frameclock" ]  frameclock  end_gun';					# Start up frameclock thread which tells us when it is time to draw a new frame.

		#
		fun digest_packedspace_layout_hints  (options: List(plh::Packedspace_Layout_Hint))  { cut, min }
		    =
		    {   my_cut =  REF cut;
		  	my_min =  REF min;
			#
			apply  do_option  options
			where
			    fun do_option (plh::WIDGET_PIXELS_CUT f) =>   if (f >= 0.0)   my_cut := THE f;   fi;	# We ignore negative values because they make no sense. Maybe should raise an exception.
				do_option (plh::WIDGET_PIXELS_MIN i) =>   if (i >=   0)   my_min := THE i;   fi;	# We ignore negative values because they make no sense. Maybe should raise an exception.
			    end;
			end;

			{ cut =>  *my_cut,
			  min =>  *my_min
			};
		    };

		#


		#
		fun stopped_gui__to__running_gui
		    (
		      ( packedspace_arg:	ps::Packedspace_Arg,
		        packed_widget:		sg::Packed_Widget
		      )
		    )
		    : rg::Running_Gui
		    =
		    {
			(do_packedspace  packedspace_arg)
			    ->
			    stuff as { widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot };

			packedspace_id =  guiboss_to_packedspace.id;

			packed_imps :=  im::set (*packed_imps, (id_to_int packedspace_id), stuff);

			topwindow_pixmap = s2g::TOPWINDOW_PIXMAP { pixmap => topwindow_for_gui.backing_pixmap };

			(do_packed_widget (packed_widget, widget_to_packedspace, topwindow_pixmap))
			    ->
			    packed_widget;

			{ fire_end_gun,
			  packedspace_id,
			  packed_widget,
			  topwindow	   => topwindow_for_gui,
			  topwindow_pixmap
			};
		    }
		    where
			fun make_gadget_info
			      (
				guiboss_to_gadget:	b2g::Guiboss_To_Gadget,
				backing_pixmap:		s2g::Backing_Pixmap
			      )
			      =
			      {
				guiboss_to_gadget,
				backing_pixmap		    =>  REF backing_pixmap,
				#
				may_have_visibly_changed    =>	REF TRUE,								# 
				#
				gadget_mode		    =>  REF { is_active => TRUE,  has_mouse_focus => FALSE,  has_keyboard_focus => FALSE, mousebutton_is_down => FALSE },
				site			    =>  REF { row => 0, col => 0, high => 0, wide => 0 },
				#
				point_in_gadget		    =>  REF (NULL:  Null_Or( g2d::Point -> Bool ))				# Optional fn to decide if a mouseclick actually hit the gadget itself, or just somewhere near it.
			      };
			#
			fun do_packedspace  (packedspace_arg: ps::Packedspace_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( ps::Packedspace_Arg  );		# When endgun fires we'll read back final packedspace_imp state via this oneshot.
				#
				packedspace_egg
				    =
				    pai::make_packedspace_egg  packedspace_arg  (THE endstate_oneshot);

				(packedspace_egg ())
				    ->
				    (exports, packedspace_egg');

				exports ->  { widget_to_packedspace, guiboss_to_packedspace };

				packed_imps :=  im::set (*packed_imps, (id_to_int guiboss_to_packedspace.id), { widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot });

# NOT VERY SOON add gadget_to_guiboss to imports:
				packedspace_imports =  { int_sink => \\ (i: Int) = (), space_to_gui };

				packedspace_egg' (packedspace_imports, run_gun', end_gun');

				{ widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot };
			    }

			also
			fun do_bouncespace  (bouncespace_arg: os::Bouncespace_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( os::Bouncespace_Arg  );		# When endgun fires we'll read back final bouncespace_imp state via this oneshot.
				#
				bouncespace_egg
				    =
				    boi::make_bouncespace_egg  bouncespace_arg  (THE endstate_oneshot);

				(bouncespace_egg ())
				    ->
				    (exports, bouncespace_egg');

				exports -> { guiboss_to_bouncespace, sprite_to_bouncespace };

				bounce_imps :=  im::set (*bounce_imps,  id_to_int guiboss_to_bouncespace.id,  { guiboss_to_bouncespace, sprite_to_bouncespace, endstate_oneshot });

# NOT VERY SOON add gadget_to_guiboss to imports:
				bouncespace_imports =  { int_sink => \\ (i: Int) = () };

				bouncespace_egg' (bouncespace_imports, run_gun', end_gun');

				{ guiboss_to_bouncespace, sprite_to_bouncespace, endstate_oneshot };
			    }

			also
			fun do_canvasspace  (canvasspace_arg: cs::Canvasspace_Arg)
			    =
			    {	endstate_oneshot  =  make_oneshot_maildrop():  Oneshot_Maildrop( cs::Canvasspace_Arg  );		# When endgun fires we'll read back final canvasspace_imp state via this oneshot.
				#
				canvasspace_egg
				    =
				    cai::make_canvasspace_egg  canvasspace_arg  (THE endstate_oneshot);

				(canvasspace_egg ())
				    ->
				    (exports, canvasspace_egg');

				exports -> { guiboss_to_canvasspace, object_to_canvasspace };

				canvas_imps :=  im::set (*canvas_imps,  id_to_int guiboss_to_canvasspace.id,  { guiboss_to_canvasspace, object_to_canvasspace, endstate_oneshot });

# NOT VERY SOON add gadget_to_guiboss to imports:
				canvasspace_imports =  { int_sink => \\ (i: Int) = () };

				canvasspace_egg' (canvasspace_imports, run_gun', end_gun');

				{ guiboss_to_canvasspace, object_to_canvasspace, endstate_oneshot };
			    }

			also
			fun do_bounce_widget												# XXX SUCKO FIXME should rename to do_sprite.
			      (
				bounce_widget:		sg::Bounce_Widget,
				sprite_to_bouncespace:	s2b::Sprite_To_Bouncespace,
				current_backing_pixmap:	s2g::Backing_Pixmap
			      )
			    =
			    case bounce_widget
				#
			        sg::SPRITE
				      (
					(gt::BOUNCE_SPRITE_START_FN bounce_sprite_start_fn):	gt::Bounce_Sprite_Start_Fn,
					saved_sprite_state:					Null_Or(Exception)				# Used by arrowbutton etc to preserve state across gui stop/restart cycles.
				      )
				    =>
				    {   endstate_oneshot											# When endgun fires we'll read back final widget state via this oneshot.
					    =
					    make_oneshot_maildrop()
					    :
					    Oneshot_Maildrop  ( ( gt::Bounce_Sprite_Start_Fn,
								  Null_Or(Exception)								# saved_sprite_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							      ) );
					#
					(bounce_sprite_start_fn { gadget_to_guiboss, sprite_to_bouncespace, run_gun', end_gun', endstate_oneshot, saved_sprite_state })
					    ->
					    { guiboss_to_gadget, bouncespace_to_sprite };


					gadget_info  =  make_gadget_info  (guiboss_to_gadget, current_backing_pixmap);

					gadget_imps     :=  im::set (*gadget_imps,     iul::id_to_int guiboss_to_gadget.id,  gadget_info );

					rg::SPRITE { bouncespace_to_sprite, guiboss_to_gadget, endstate_oneshot };
				    };

			    esac


			also
			fun do_canvas_widget												# XXX SUCKO FIXME should rename to do_object
			      (
				canvas_widget:		sg::Canvas_Widget,
				object_to_canvasspace:	o2c::Object_To_Canvasspace,
				current_backing_pixmap:	s2g::Backing_Pixmap
			      )
			    =
			    case canvas_widget
				#
				sg::PACKEDSPACE  (packedspace_arg:  ps::Packedspace_Arg,  packed_widget: sg::Packed_Widget)
				    =>
				    {
					(do_packedspace  packedspace_arg)
					    ->
					    stuff as { widget_to_packedspace, guiboss_to_packedspace, endstate_oneshot };

					packed_imps :=  im::set (*packed_imps, (id_to_int guiboss_to_packedspace.id), stuff);

					(do_packed_widget (packed_widget, widget_to_packedspace, current_backing_pixmap))
					    ->
					    packed_widget;

					rg::PACKEDSPACE { packedspace_id => guiboss_to_packedspace.id,  packed_widget };
				    };

				sg::OBJECT
				      (
					(gt::CANVAS_OBJECT_START_FN canvas_object_start_fn):	gt::Canvas_Object_Start_Fn,
					saved_object_state:					Null_Or(Exception)			# Used by arrowbutton etc to preserve state across gui stop/restart cycles.
				      )
				    =>
				    {   endstate_oneshot										# When endgun fires we'll read back final object state via this oneshot.
					    =
					    make_oneshot_maildrop()
					    :
					    Oneshot_Maildrop( ( gt::Canvas_Object_Start_Fn,
								Null_Or(Exception)							# saved_object_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							      )
							    );
					#
					(canvas_object_start_fn { gadget_to_guiboss, object_to_canvasspace, run_gun', end_gun', endstate_oneshot, saved_object_state })
					    ->
					    { guiboss_to_gadget, canvasspace_to_object };


					gadget_info  =  make_gadget_info  (guiboss_to_gadget, current_backing_pixmap);

					gadget_imps     :=  im::set (*gadget_imps,     iul::id_to_int guiboss_to_gadget.id,  gadget_info );

					rg::OBJECT { canvasspace_to_object, guiboss_to_gadget, endstate_oneshot };
				    };
			    esac

			also
			fun do_packed_widget
			      (
				packed_widget:		sg::Packed_Widget,				# 'packed_widget' can be a tree of widgets with ROW and COL internal nodes.
				widget_to_packedspace:	w2p::Widget_To_Packedspace,
				current_backing_pixmap:	s2g::Backing_Pixmap
			      )
			    =
			    case packed_widget
				#
				sg::ROW	(packed_widgets:	 List( (List(plh::Packedspace_Layout_Hint), sg::Packed_Widget) ))		# A row of widgets. The ROW itself is not a widget (given no microthread).
				    =>
				    {
					widgets =   map  do_widget  packed_widgets
						    where
							fun do_widget
							    (
							      layout_hints:	List( plh::Packedspace_Layout_Hint ),
							      packed_widget:	sg::Packed_Widget
							    )
							    =
							    { widget		=>  do_packed_widget  (packed_widget, widget_to_packedspace, current_backing_pixmap),
							      cooked_hints	=>  digest_packedspace_layout_hints  layout_hints  { cut => NULL, min => NULL },
							      raw_hints		=>  layout_hints
							    };
						    end;

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

					rg::ROW { widgets,
						  #
						  pixels_high_min,
						  pixels_wide_min,
						  #
						  pixels_high_cut,
						  pixels_wide_cut,
						  #
						  site =>  REF  g2d::box::zero
						};
				    };

				sg::COL	(packed_widgets:	 List( (List(plh::Packedspace_Layout_Hint), sg::Packed_Widget) ))		# A column of widgets. The COL itself is not a widget (given no microthread).
				    =>
				    {
					widgets =   map  do_widget  packed_widgets
						    where
							fun do_widget
							    (
							      layout_hints:	List( plh::Packedspace_Layout_Hint ),
							      packed_widget:	sg::Packed_Widget
							    )
							    =
							    { widget		=>  do_packed_widget  (packed_widget, widget_to_packedspace, current_backing_pixmap),
							      cooked_hints	=>  digest_packedspace_layout_hints  layout_hints  { cut => NULL, min => NULL },
							      raw_hints		=>  layout_hints
							    };
						    end;

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

					rg::COL { widgets,
						  #
						  pixels_high_min,
						  pixels_wide_min,
						  #
						  pixels_high_cut,
						  pixels_wide_cut,

						  site =>  REF  g2d::box::zero
						};
				    };

				sg::SCROLLABLE_VIEW									# A viewport onto a scrollable pixmap
				  (
				    w
				    as
				    ( callback:		gt::Viewport_Scroller_Callback,
				      pixmap_size:	g2d::Size,
				      packed_widget:	sg::Packed_Widget
				  ) )
				    =>
				    {
					gadget_to_rw_pixmap	=   imports.guiboss_to_windowsystem.make_rw_pixmap
									#
									pixmap_size;


					view_origin     =  REF { row => 0,						# View origin in viewport coordinates. Controls which part of view is visible in viewport.  guiboss-imp.pkg will update this in response to scrollbar motions etc.
								 col => 0
							       };

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

					viewport	=  REF g2d::box::zero;						# Dummy initial value -- real value will be set by   assign_sites_to_all_widgets()   in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

					viewport_record = { parent_pixmap  => current_backing_pixmap,			# The backing_pixmap we were doing before diving recursively into this view.
							    view_origin => view_origin,
							    viewport_site  => viewport					# Site of view on parent.
														      # XXX SUCKO FIXME Currently we store 'site' both here and in rg::SCROLLABLE_VIEW.
														      #           We'll probably wind up using only one;  (???)
														      #		  we should delete the unused one.
							  };

					backing_pixmap  = s2g::VIEWPORT_PIXMAP
							    {
							      pixmap     =>  gadget_to_rw_pixmap,			# The backing pixmap for this view.
							      viewports  =>  REF [ viewport_record ],			# Initially at least view_pixmap is visible through only this one viewport.
							      is_visible =>  REF TRUE	
							    };

					widget		= do_packed_widget  (packed_widget, widget_to_packedspace, backing_pixmap);	# Process widget in new backing_pixmap not current_backing_pixmap!

					viewport_scroller									# Define the get/set fns client code uses to scroll the viewport.
					    =
					    { get_viewport_origin,
					      set_viewport_origin
					    }
					    where
						fun get_viewport_origin ()
						    =
						    *view_origin;								# Origin of gadget_to_rw_pixmap in viewport coordinates, used for scrolling pixmap in viewport.

						fun set_viewport_origin (view_origin_in_viewport_coordinates: g2d::Point)
						    =
						    {										# In this routine we must clearly distinguish three different coordinate systems.
																# We are dealing with a backing_pixmap for a scrollable view which is visible
																# through a viewport which is located on a parent backing_pixmap.
																# Thus, we have:
																#  o  The coordinate system of the view itself, with 0,0 at upper-left of the view's backing pixmap.
																#  o  The coordinate system of the parent,      with 0,0 at upper-left of its own    backing pixmap.
																#  o  The coordinate system of the viewport,    with 0,0 at upper-left of the viewport.
																# These three coordinate systems are related by
																#  o  viewport_site, which gives the viewport origin (and size) in parent   coordinates.
																#  o  view_origin,   which gives the view     origin            in viewport coordinates.
																# We have boxes in all three coordinate systems here, so we must track carefully which box is in which coordinate system.

							view_origin := view_origin_in_viewport_coordinates;			# Note new origin of gadget_to_rw_pixmap in viewport coordinates, used for scrolling pixmap in viewport.

							viewport_site_in_parent_coordinates
							    =
							    *viewport;

							viewport_origin_in_parent_coordinates
							    =
							    g2d::box::upperleft  viewport_site_in_parent_coordinates;

							view_site_in_parent_coordinates
							    =
							    g2d::box::make
							      (
								view_origin_in_viewport_coordinates + viewport_origin_in_parent_coordinates,
								gadget_to_rw_pixmap.size
							      );

							view_site_in_view_coordinates
							    =
							    g2d::box::make
							      (
								g2d::point::zero,
								gadget_to_rw_pixmap.size
							      );

							viewport_origin_in_view_coordinates
							    =
							    g2d::point::zero - view_origin_in_viewport_coordinates;

							viewport_site_in_view_coordinates
							    =
							    g2d::box::clone_box_at
							      (
								viewport_site_in_parent_coordinates,
								viewport_origin_in_view_coordinates
							      );

							if (not (g2d::box::box_a_in_box_b { a => viewport_site_in_view_coordinates,	# Does our pixmap fill the viewport on parent pixmap?
											    b => view_site_in_view_coordinates
											  }
							   )    )
							    #										# No, so we have to clear the remainder of the viewport.
							    #
							    boxes_to_clear =  g2d::box::subtract_box_b_from_box_a			# Express area to be cleared as a list of non-overlapping rectangles.
										{
										  a => viewport_site_in_parent_coordinates,
										  b => view_site_in_parent_coordinates
										};

							    apply do_box boxes_to_clear							# For each box to be cleared ...
								where
								    fun do_box (box: g2d::Box)
									=
									{
									    clear_box_in_pixmap (viewport_record.parent_pixmap, box);	# ... fill it with black, then ...
									    #
									    update_offscreen_parent_pixmaps_and_then_topwindow		# ... copy that blackness all the way up the viewport chain to visible topwindow.
										#
										(viewport_record.parent_pixmap, box, topwindow_for_gui);
									};
								end;
							fi;

							from_box = g2d::box::intersection						# We want to draw on parent only that part which is visible and which exists.
								      (
									viewport_site_in_view_coordinates,				# This is the part that is visible.
									view_site_in_view_coordinates					# This is what exists.
								      );	

							case from_box
							    #
							    NULL         => ();								# No intersection means nothing to draw. Pixmap must be scrolled completely out of sight...
							    #
							    THE from_box => update_offscreen_parent_pixmaps_and_then_topwindow		# Draw visible part pixmap on parent.
									        #
										(backing_pixmap, from_box, topwindow_for_gui);
							esac;
						    };	
					    end;

					callback (THE viewport_scroller);						# Give app client code a handle with which to gadget_to_rw_pixmap in viewport.

					rg::SCROLLABLE_VIEW { scroller => viewport_scroller, callback, widget, gadget_to_rw_pixmap, view_origin, backing_pixmap, site => viewport };
				    };

				sg::TABBED_VIEWS									# A viewport onto a set of alternate pixmaps for tabbed viewing.
				      (
					callback:	gt::Tabbed_View_Picker_Callback,
					pixmap_size:	g2d::Size,
					widgets:	List( sg::Packed_Widget )
				      )
				    =>
				    {
					if ((list::length widgets) == 0)						# We could be more robust by supporting empty 'widgets', but that would give us special
					    log::fatal "TABBED_VIEWS needs at least one view! -- guiboss-imp.pkg";	# cases in the code every time we access visible_widget.  Maybe it is worth it?
					    ();										# We'd have to make visible_widgets be Ref(Null_Or(Tabview)) instead of just Ref(Tabview).
					fi;

					pixels_high_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_min	=  REF 0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					#
					pixels_high_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
					pixels_wide_cut	=  REF 1.0;							# We'll set the real value for this later in re_site_packed_widget_tree() in  src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

					viewport	=  REF g2d::box::zero;						# Dummy initial value -- real value will be set by   assign_sites_to_all_widgets()   in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

					visible		=  REF TRUE;							# We'll default this to TRUE for first widget, FALSE for the rest.

					widgets =   map  do_widget  widgets
						    where
							fun do_widget
							    (
							      packed_widget:	sg::Packed_Widget
							    )
							    =
							    {	widget		= do_packed_widget  (packed_widget, widget_to_packedspace, current_backing_pixmap);
								#
								gadget_to_rw_pixmap = imports.guiboss_to_windowsystem.make_rw_pixmap
										          #
										          pixmap_size;

								view_origin  =   REF { row => 0,					# View origin in viewport coordinates. Controls which part of view is visible in viewport.  For tabbed views this will never be changed.
											  col => 0
											};

								backing_pixmap  = s2g::VIEWPORT_PIXMAP
										    {
										      is_visible => REF *visible,
										      #		
										      pixmap     => gadget_to_rw_pixmap,				# The backing pixmap for this view.

										      viewports  => REF [					# Initially at least view_pixmap is visible through only this one viewport.
													  { parent_pixmap => current_backing_pixmap, # The backing_pixmap we were doing before diving recursively into this view.
													    view_origin,
													    viewport_site => viewport		# Site of view on parent.
																			# XXX SUCKO FIXME Currently we store 'site' both here and in rg::SCROLLABLE_VIEW.
																			#           We'll probably wind up using only one;  (???)  BTW, SHOULDN'T THIS BE A REF so WE CAN UPDATE SITE WHEN DOING RE-LAYOUT?
																			#		  we should delete the unused one.

													  }
												        ]	
										    };

								visible   := FALSE;

								{ widget, gadget_to_rw_pixmap, backing_pixmap };
							    };
						    end;

					visible_widget	=  REF (head widgets);								# Default to displaying first view, if there is more than one.

					tabbed_view_picker
					    =
					    { get_active_view,
					      set_active_view
					    }
					    where
						fun number_of_active_widget  ([]: List(rg::Tabview),  i: Int)
							=>
							0;

						    number_of_active_widget ((widget ! rest), i)
						        =>
							if (id_to_int widget.gadget_to_rw_pixmap.id == id_to_int (*visible_widget).gadget_to_rw_pixmap.id)   i;
							else										                     number_of_active_widget (rest, i+1);
							fi;
						end;

						fun get_active_view ()
						    =
						    number_of_active_widget (widgets, 0);

						fun set_active_view (i: Int)
						    =
						    {   widget_count = list::length widgets;
							#
							if (i != get_active_view ())							# Do nothing if client code is re-selecting already-active tabview.
							    #
							    if (i >= 0  and  i < widget_count)
								#
								case ((*visible_widget).backing_pixmap)
								    #
								    s2g::VIEWPORT_PIXMAP r =>   r.is_visible := FALSE;			# Remember previously visible view is now not visible.
								    _			   =>	();					# Shouldn't happen.
								esac;

								visible_widget :=  list::nth (widgets, i);

								case ((*visible_widget).backing_pixmap)
								    #
								    s2g::VIEWPORT_PIXMAP r =>   r.is_visible := TRUE;			# Remember newly visible view is now visible.
								    _			   =>	();					# Shouldn't happen.
								esac;
							    else
								log::note_on_stderr {. sprintf "set_active_view: arg = %d not in range 0 -> %d\n" i widget_count; };
							    fi;

							    from_box =    g2d::box::make							# We want to update the whole pixmap. (A tabview should always be the same size as the viewport, and all of it needs updating.)
									    (
									      g2d::point::zero, 
									      (*visible_widget).gadget_to_rw_pixmap.size
									    );

							    update_offscreen_parent_pixmaps_and_then_topwindow		# Draw pixmap on parent.
								#
								((*visible_widget).backing_pixmap, from_box, topwindow_for_gui);

							fi;

							();
						    };	
					    end;

					callback (THE tabbed_view_picker);						# Give app client code a handle with which to gadget_to_rw_pixmap in viewport.

					rg::TABBED_VIEWS { callback, pixmap_size, widgets, visible_widget, site => viewport };
				    };

				sg::WIDGET
				      (
					(gt::PACKED_WIDGET_START_FN packed_widget_start_fn):		gt::Packed_Widget_Start_Fn,
					saved_widget_state:						Null_Or(Exception)		# Used by arrowbutton etc to preserve state across gui stop/restart cycles.
				      )
				    =>
				    {   endstate_oneshot										# When endgun fires we'll read back final widget state via this oneshot.
					    =
					    make_oneshot_maildrop()
					    :
					    Oneshot_Maildrop  ( ( gt::Packed_Widget_Start_Fn,
								  Null_Or(Exception)							# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							      ) );
					#
					(packed_widget_start_fn { gadget_to_guiboss, widget_to_packedspace, run_gun', end_gun', endstate_oneshot, saved_widget_state })
					    ->
					    { guiboss_to_gadget, packedspace_to_widget };


					gadget_info  =  make_gadget_info  (guiboss_to_gadget, current_backing_pixmap);

					gadget_imps     :=  im::set (*gadget_imps,     iul::id_to_int guiboss_to_gadget.id,  gadget_info );

					site =  REF  g2d::box::zero;

					rg::WIDGET { packedspace_to_widget, guiboss_to_gadget, endstate_oneshot, site };
				    };


				sg::CANVASSPACE
				    ( canvasspace_arg:	cs::Canvasspace_Arg,
				      canvas_widgets:	List((List(clh::Canvasspace_Layout_Hint),  sg::Canvas_Widget))
				    )
				    =>
				    {
					(do_canvasspace  canvasspace_arg)
					    ->
					    stuff as { guiboss_to_canvasspace, object_to_canvasspace, endstate_oneshot };

					canvasspace_id =  guiboss_to_canvasspace.id;

					canvas_imps :=  im::set (*canvas_imps, (id_to_int canvasspace_id), stuff);

					#
					widgets	=   map  do_widget  canvas_widgets
						    where
							fun do_widget (hints: List(clh::Canvasspace_Layout_Hint), canvas_widget: sg::Canvas_Widget)
							    =
							    ( hints,
							      do_canvas_widget  (canvas_widget, object_to_canvasspace, current_backing_pixmap)
							    );	
						    end;

					site =  REF  g2d::box::zero;

					rg::CANVASSPACE { canvasspace_id,  widgets, site };
				    };

				sg::BOUNCESPACE
				    ( bouncespace_arg:	os::Bouncespace_Arg,
				      bounce_widgets:	List((List(blh::Bouncespace_Layout_Hint), sg::Bounce_Widget))
				    )
				    =>
				    {
					(do_bouncespace  bouncespace_arg)
					    ->
					    stuff as { guiboss_to_bouncespace, sprite_to_bouncespace, endstate_oneshot };

					bounce_imps :=  im::set (*bounce_imps, (id_to_int guiboss_to_bouncespace.id), stuff);

					#
					widgets	=   map  do_widget  bounce_widgets
						    where
							fun do_widget (hints: List(blh::Bouncespace_Layout_Hint),  bounce_widget: sg::Bounce_Widget)
							    =
							    ( hints,
							      do_bounce_widget  (bounce_widget, sprite_to_bouncespace, current_backing_pixmap)
							    );	
						    end;

					bouncespace_id =  guiboss_to_bouncespace.id;

					site =  REF  g2d::box::zero;

					rg::BOUNCESPACE { bouncespace_id, widgets, site };
				    };

				sg::NULL_PACKED_WIDGET
				    =>
				    rg::NULL_PACKED_WIDGET;
			    esac;
		    end;	
	    end;

	#
	fun start_gui'
	      (
		runstate: 		Runstate,
		#	
		topwindow_for_gui:	gws::Guiboss_To_Topwindow,
		gui_plan:		gp::Gui_Plan,

		gui_startup_complete':	Oneshot_Maildrop( Client_To_Guiwindow ),
		guiboss_q:		Guiboss_Q,
		stop_gui:		(rg::Running_Gui, Bounce_Imps, Canvas_Imps, Packed_Imps, Gadget_Imps, Topwindow_Info) -> sg::Stopped_Gui
	      )
	    =
	    {   stopped_gui =  gui_plan__to__stopped_gui  gui_plan;
		#
	        restart_gui' (runstate, topwindow_for_gui, stopped_gui, gui_startup_complete', guiboss_q, stop_gui);
	    }
	    where
		fun gui_plan__to__stopped_gui
		    (
		      packedspace_arg:		ps::Packedspace_Arg,
		      packed_widget:		gp::Packed_Widget
		    )
		    : sg::Stopped_Gui
		    =
		    {
			(do_packed_widget packed_widget)
			    ->
			    packed_widget;

			( packedspace_arg:		ps::Packedspace_Arg,
			  packed_widget:		sg::Packed_Widget
			);
		    }
		    where
			fun do_bounce_widget (bounce_widget: gp::Bounce_Widget)
			    =
			    case bounce_widget
				#
			        gp::SPRITE a =>  sg::SPRITE (a, NULL);										# SUBSTANTIVE CHANGE
			    esac

			also
			fun do_canvas_widget (canvas_widget: gp::Canvas_Widget)
			    =
			    case canvas_widget
				#
				gp::PACKEDSPACE  (packedspace_arg:  ps::Packedspace_Arg,  packed_widget: gp::Packed_Widget)
				    =>
				    {
					(do_packed_widget packed_widget)
					    ->
					    packed_widget;

					sg::PACKEDSPACE (packedspace_arg,  packed_widget);
				    };

			        gp::OBJECT a =>  sg::OBJECT (a, NULL);										# SUBSTANTIVE CHANGE
			    esac

			also
			fun do_packed_widget (packed_widget: gp::Packed_Widget)									# 'packed_widget' can be a tree of widgets with ROW and COL internal nodes.
			    =
			    case packed_widget
				#
			        gp::ROW	(packed_widgets:	 List( (List(plh::Packedspace_Layout_Hint), gp::Packed_Widget) ))		# A row of widgets. The ROW itself is not a widget (given no microthread).
				    =>
				    {
					packed_widgets
					    =
					    map  do_widget  packed_widgets
					    where
						fun do_widget
						    (
						      layout_hints:	List( plh::Packedspace_Layout_Hint ),
						      packed_widget:	gp::Packed_Widget
						    )
						    =
						    ( layout_hints,
						      do_packed_widget  packed_widget
						    );
					    end;

					sg::ROW  packed_widgets;
				    };

			        gp::COL	(packed_widgets:	 List( (List(plh::Packedspace_Layout_Hint), gp::Packed_Widget) ))		# A column of widgets. The COL itself is not a widget (given no microthread).
				    =>
				    {
					packed_widgets
					    =
					    map  do_widget  packed_widgets
					    where
						fun do_widget
						    (
						      layout_hints:	List( plh::Packedspace_Layout_Hint ),
						      packed_widget:	gp::Packed_Widget
						    )
						    =
						    ( layout_hints,
						      do_packed_widget  packed_widget
						    );
					    end;

					sg::COL  packed_widgets;
				    };

			        gp::SCROLLABLE_VIEW ( triple
						      as
							( callback:		gt::Viewport_Scroller_Callback,
							  pixmap_size:		g2d::Size,
							  packed_widget:	gp::Packed_Widget
						    )   )
				    =>
				    {
					triple = do_pair (callback, pixmap_size, packed_widget)
						where
						    fun do_pair
							(
							  callback:		gt::Viewport_Scroller_Callback,
							  pixmap_size:		g2d::Size,
							  packed_widget:	gp::Packed_Widget
							)
							=
							( callback,
							  pixmap_size,
							  do_packed_widget  packed_widget
							);
						end;
					
					sg::SCROLLABLE_VIEW triple;
				    };

			        gp::TABBED_VIEWS
				      (
					callback:	gt::Tabbed_View_Picker_Callback,
					pixmap_size:	g2d::Size,
					widgets:	List( gp::Packed_Widget )
				      )
				    =>
				    {
					widgets = map do_pair widgets
						where
						    fun do_pair
							(
							  packed_widget:	gp::Packed_Widget
							)
							=
							do_packed_widget  packed_widget;
						end;
					
					sg::TABBED_VIEWS (callback, pixmap_size, widgets);
				    };

			        gp::WIDGET   a =>  sg::WIDGET (a, NULL);									# SUBSTANTIVE CHANGE
																		# The NULL is the saved_widget_state: Null_Or(Exception) used by arrowbutton etc to preserve state across gui stop/restart cycles.
			        gp::CANVASSPACE
				    ( canvasspace_arg:	cs::Canvasspace_Arg,
				      canvas_widgets:	List((List(clh::Canvasspace_Layout_Hint),  gp::Canvas_Widget))
				    )
				    =>
				    {
					canvas_widgets
					    =
					    map  do_widget  canvas_widgets
					    where
						fun do_widget (hints: List(clh::Canvasspace_Layout_Hint),  canvas_widget: gp::Canvas_Widget)
						    =
						    ( hints,
						      do_canvas_widget  canvas_widget
						    );	
					    end;

					sg::CANVASSPACE (canvasspace_arg, canvas_widgets);
				    };

			        gp::BOUNCESPACE
				    ( bouncespace_arg:	os::Bouncespace_Arg,
				      bounce_widgets:	List((List(blh::Bouncespace_Layout_Hint),  gp::Bounce_Widget))
				    )
				    =>
				    {
					bounce_widgets
					    =
					    map  do_widget  bounce_widgets
					    where
						fun do_widget (hints: List(blh::Bouncespace_Layout_Hint),  bounce_widget: gp::Bounce_Widget)
						    =
						    ( hints,
						      do_bounce_widget  bounce_widget
						    );	
					    end;

					sg::BOUNCESPACE (bouncespace_arg, bounce_widgets);
				    };

			        gp::NULL_PACKED_WIDGET
				    =>
				    sg::NULL_PACKED_WIDGET;
			    esac;
		    end;	
	    end;

	#
	fun startup   (id: Id,   reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		client_to_guiboss =   { id,
					make_topwindow,
					start_gui,
					restart_gui,
					get_bounce_theme,
					get_canvas_theme,
					get_packed_theme
				      };

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, { client_to_guiboss }));						# Return value from guiboss_egg'().

		(take_from_mailslot  me_slot)											# Imports from guiboss_egg'().
		    ->
		    { me, guiboss_arg, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';										# Wait for the starting gun.

		run ( guiboss_q,		 										# Will not return.
		      { me,
			guiboss_arg,
			imports,
			to,
			end_gun',
			id
		      }
		);
	    }
	    where
		guiboss_q     =  make_mailqueue (get_current_microthread()):  Guiboss_Q;



		#################################################################################
		# guiboss interface fns::
		#
		#
		stipulate
		    fun find_appropriate_gadget_info											# Which widget did the user click on?  This is usually easy but it might be in a scrollable view in a tabbed view in another scrollable view, say.
			  (
			    topwindow_info:		Topwindow_Info,
			    event_point
			  )
			=
			case (*topwindow_info.running_gui)
			    #
			    THE (running_gui:	rg::Running_Gui)
				=>
				find_gadget_info (running_gui.packed_widget, event_point)
				where
				    fun try_all_row_or_col_widgets ([]: List(rg::Row_Widget),  point: g2d::Point)
					    =>
					    NULL;

					try_all_row_or_col_widgets (row_or_col_widget ! rest,  point)
					    =>
					    case (find_gadget_info  (row_or_col_widget.widget, point))
						#
						NULL =>  try_all_row_or_col_widgets (rest,  point);		# Try the remaining widgets in ROW/COL.
						info =>  info;							# Got it.
					    esac;
				    end

				    also	
				    fun find_gadget_info
					  (
					    packed_widget:	rg::Packed_Widget,
					    point:		g2d::Point
					  )
					=
					if (g2d::box::point_in_box (point, rg::packed_widget_site packed_widget))
					    #
					    case packed_widget
						#
						rg::ROW r =>   try_all_row_or_col_widgets (r.widgets, point);
						rg::COL r =>   try_all_row_or_col_widgets (r.widgets, point);

						rg::SCROLLABLE_VIEW r
						    =>
						    {   point = point - g2d::box::upperleft(*r.site);					# Transform mouseclick point into          view coordinate system.
							point = point - *r.view_origin;							# Transform mouseclick point into scrolled view coordinate system.
							#
							find_gadget_info (r.widget, point);						# Recursively search for target widget of mouseclick among widgets in scrollable view.
						    };	

						rg::TABBED_VIEWS r
						    =>
						    {   point = point - g2d::box::upperleft(*r.site);					# Transform mouseclick point into view coordinate system.
							#
							find_gadget_info ((*r.visible_widget).widget, point);				# Recursively search for target widget of mouseclick among widgets in current tabbed view.
						    };

						rg::WIDGET r
						    =>
						    {   imps = *topwindow_info.gadget_imps;
							#
							id   = iul::id_to_int r.guiboss_to_gadget.id;

						        case (im::get (imps, id))
							    #
							    THE gadget_info =>  THE (gadget_info, point);				# Return event_point transformed into correct coordinate system for widget.
							    NULL	    =>  NULL;
							esac;
						    };

						rg::CANVASSPACE r
						    =>
NULL; # TBD

						rg::BOUNCESPACE r
						    =>
NULL; # TBD

						rg::NULL_PACKED_WIDGET
						    =>
						    NULL;
					    esac;
					else
					    NULL;
					fi;
				end;
			    #	 
			    NULL => NULL;											# Maybe we should do:   log::fatal "find_appropriate_gadget_info' called while gui not running!";
			esac;
		herein

		    fun do_motion_notify												# 
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    running_gui:		rg::Running_Gui,
			    motion_xevtinfo:		evt::Motion_Xevtinfo
			  )
			=
			case (find_appropriate_gadget_info (topwindow_info, motion_xevtinfo.event_point))
			    #
			    THE (gadget_info, event_point)									# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				=>
				{
				    gadget_info.guiboss_to_gadget.note_mouse_move_event
				      (
					motion_xevtinfo.modifier_keys_state,
					motion_xevtinfo.mousebuttons_state,
					event_point,
				       *gadget_info.site,
					imports.theme
				      );
				};

			    NULL => {
#					nb {. "guievent_sink()/guiboss/do_motion_notify: NO candidate found."; };
					();
				    };
			esac;

		    fun do_button_press												# 
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    running_gui:		rg::Running_Gui,
			    button_xevtinfo:		evt::Button_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_gadget_info (topwindow_info, button_xevtinfo.event_point))
				#
				THE (gadget_info, event_point)									# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				    =>
				    {
#					printf "guievent_sink()/guiboss/do_button_press: FOUND CANDIDATE!\n";
					#	

					# The mouseclick hit the window site assigned to this gadget.
					# Now decide whether it counts as having hit the gadget itself:
					#
					good_click =    case (*gadget_info.point_in_gadget)
							    #
							    NULL   =>   TRUE;						# No   point_in_gadget fn supplied by gadget, so count mouseclick as having hit the gadget.
							    THE fn =>   fn event_point /* button_xevtinfo.event_point */;	# Have point_in_gadget fn supplied by the gadget decide whether the mouseclick was close enough to count.
							esac;

if (*log::debugging) log::note {. sprintf "do_button_press sending a note_mousebutton_press_event id=%d -- guiboss-imp.pkg" (iul::id_to_int gadget_info.guiboss_to_gadget.id); }; fi;
					if good_click								# If the mouseclick counts as having hit the gadget, forward it to the gadget and do associated processing.
					    #
					    gadget_info.guiboss_to_gadget.note_mousebutton_press_event
					      (
						button_xevtinfo.mouse_button,
						button_xevtinfo.modifier_keys_state,
						button_xevtinfo.mousebuttons_state,
#						button_xevtinfo.event_point,
						event_point,
					       *gadget_info.site,
						imports.theme
					      );	

					    gadget_info.may_have_visibly_changed :=  TRUE;

					    if (not *topwindow_info.done_extra_startframe_this_frame)				# In general we try to draw only one frame per 50HZ SIGALRM clock tick, but to reduce latency we allow one exceptional gadget redraw per tick.
						#
						topwindow_info.done_extra_startframe_this_frame := TRUE;

						# Send a startframe to the gadget:							# See Note[1]
						#	
						topwindow_info -> { current_frame_number, ... };
						gadget_info    -> { guiboss_to_gadget, site, gadget_mode, may_have_visibly_changed, ... };
						#
    if (*log::debugging) log::note {. sprintf "do_button_press sending an early startframe id=%d -- guiboss-imp.pkg" (iul::id_to_int guiboss_to_gadget.id); }; fi;
						guiboss_to_gadget.start_of_frame  { frame_number => *current_frame_number,
										    site => *site,
										    visible => TRUE,
										    duration_in_seconds => 0.0,
										    this_gadget_mode => *gadget_mode,
										    theme => imports.theme
										  };
					    fi;
					fi;
				    };

				NULL =>  printf "guievent_sink()/guiboss/do_button_press: NO candidate found.\n";
			    esac;
			};

		    fun do_button_release												# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    running_gui:		rg::Running_Gui,
			    button_xevtinfo:	evt::Button_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_gadget_info (topwindow_info, button_xevtinfo.event_point))
				#
				THE (gadget_info, event_point)									# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				    =>
				    {
#					printf "guievent_sink()/guiboss/do_button_release: FOUND CANDIDATE!\n";
					#	
					gadget_info.guiboss_to_gadget.note_mousebutton_release_event
					  (
					    button_xevtinfo.mouse_button,
					    button_xevtinfo.modifier_keys_state,
	 		    		    button_xevtinfo.mousebuttons_state,
#					    button_xevtinfo.event_point,
					    event_point,
					   *gadget_info.site,
					    imports.theme
					  );	

					gadget_info.may_have_visibly_changed :=  TRUE;
				    };

				NULL =>  printf "guievent_sink()/guiboss/do_button_release: NO candidate found.\n";
			    esac;
			};

		    fun do_key_press												# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    running_gui:		rg::Running_Gui,
			    key_xevtinfo:		evt::Key_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_gadget_info (topwindow_info, key_xevtinfo.event_point))
				#
				THE (gadget_info, event_point)									# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				    =>
				    {   printf "guievent_sink()/guiboss/do_key_press: FOUND CANDIDATE!\n";
					#	
					gadget_info.guiboss_to_gadget.note_key_press_event
					  (
					    key_xevtinfo.keycode,
					    key_xevtinfo.keysym,
					    key_xevtinfo.ascii,
					    key_xevtinfo.modifier_keys_state,
	 		    		    key_xevtinfo.mousebuttons_state,
#					    key_xevtinfo.event_point,
					    event_point,
					   *gadget_info.site,
					    imports.theme
					  );	

					gadget_info.may_have_visibly_changed :=  TRUE;
				    };

				NULL =>  printf "guievent_sink()/guiboss/do_key_press: NO candidate found.\n";
			    esac;
			};

		    fun do_key_release												# Private.
			  (
			    { me, imports, ... }:	Runstate,
			    topwindow_info:		Topwindow_Info,
			    running_gui:		rg::Running_Gui,
			    key_xevtinfo:		evt::Key_Xevtinfo
			  )
			=
			{
			    case (find_appropriate_gadget_info (topwindow_info, key_xevtinfo.event_point))
				#
				THE (gadget_info, event_point)									# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no viewports are involved).
				    =>
				    {   printf "guievent_sink()/guiboss/do_key_release: FOUND CANDIDATE!\n";
					#	
					gadget_info.guiboss_to_gadget.note_key_release_event
					  (
					    key_xevtinfo.keycode,
					    key_xevtinfo.keysym,
					    key_xevtinfo.ascii,
					    key_xevtinfo.modifier_keys_state,
	 		    		    key_xevtinfo.mousebuttons_state,
#					    key_xevtinfo.event_point,
					    event_point,
					   *gadget_info.site,
					    imports.theme
					  );	

					gadget_info.may_have_visibly_changed :=  TRUE;
				    };

				NULL =>  printf "guievent_sink()/guiboss/do_key_release: NO candidate found.\n";
			    esac;
			};


		end;


		fun make_topwindow  (hints: gws::Topwindow_Hints)								# PUBLIC.
		    =														# This will run in client's thread.
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( gws::Guiboss_To_Topwindow );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ me, imports, ... }: Runstate)									# Now we're running in our own thread, with mutual exclusion and access to our core datastructures.
				=
				{   # We have to do an awkward little dance here because we
				    # must hand a guievent_sink() TO make_topwindow() but we
				    # want guievent_sink() to lock in the 'topwindow' result
				    # FROM make_topwindow():

				    saved_events = REF ([]: List( (a2r::Envelope_Route, evt::x::Event) ) );			# Somewhere for initial_guievent_sink to save any events it gets.

				    fun initial_guievent_sink (arg as (route: a2r::Envelope_Route, event: evt::x::Event))	# An initial version which just saves events in 'saved_events' until we're ready to process them, since we don't yet have 'topwindow' available.
					=											# This will run in client's thread.
					saved_events :=  arg ! *saved_events;

				    guievent_sink_fn   = REF initial_guievent_sink;

				    fun guievent_sink_wrapper (arg as (route: a2r::Envelope_Route, event: evt::x::Event))	# A wrapper which initially calls initial_guievent_sink but almost immediately switches to calling the production guievent_sink.
					=											# This will run in client's thread.
					*guievent_sink_fn  arg;



				    # Do the actual work for this fn:
				    #
				    guiboss_to_topwindow =  imports.guiboss_to_windowsystem.make_topwindow  (hints, guievent_sink_wrapper);		# XXX SUCKO FIXME we're blocking until we get the result from windowsystem.



				    topwindow_info       =    { guiboss_to_topwindow,							# Remember our handle for the topwindow.
								running_gui			=>   REF NULL,				# Remember that we do not yet have a GUI running on the topwindow.
								#
								bounce_imps			=>  (REF im::empty): Bounce_Imps,	# Holds our os::Guiboss_To_Bouncespace instances -- can't put them directly in Running_Gui due to circularity.
								canvas_imps			=>  (REF im::empty): Canvas_Imps,	# Holds our cs::Guiboss_To_Canvasspace instances -- can't put them directly in Running_Gui due to circularity.
								packed_imps			=>  (REF im::empty): Packed_Imps,	# Holds our ps::Guiboss_To_Packedspace instances -- can't put them directly in Running_Gui due to circularity.
								gadget_imps			=>  (REF im::empty): Gadget_Imps,	# Holds look-imps for all the widgets in our gui.
								#
								current_frame_number		=>  (REF 1),				# We count frames for convenience of widgets and debugging.
								seconds_per_frame		=>  (REF 0.01),				# Let's initially assume a nominal ten frames per second. Passed to widgets primarily so widgets can do motion blurring if they wish.
								#
								done_extra_startframe_this_frame=>  (REF FALSE), 
								#
								gadget_to_guiboss		=>  (REF (NULL: Null_Or( g2g::Gadget_To_Guiboss ))),	# 
								space_to_gui			=>  (REF (NULL: Null_Or( s2g::Space_To_Gui)))
							      };

				    me.topwindows											# Remember that we have a new topwindow to manage.
					:=
					im::set ( *me.topwindows,
						  id_to_int guiboss_to_topwindow.id,
						  topwindow_info
						);

				    fun guievent_sink (arg as (route: a2r::Envelope_Route, event: evt::x::Event))			# The production Gui_Event handling routine, which locks in the value of 'guiboss_to_topwindow'.
					=												# This will run in client's thread.
					put_in_mailqueue  (guiboss_q,									# Incoming Gui_Event values MUST be run through the guiboss_q to guarantee mutual exclusion on access to internal guiboss datastructures.
					    #
					    \\ (runstate as { me, imports, ... }: Runstate)						# Now we're running in our own thread, with mutual exclusion and access to our core datastructures.
						=
						{
						    case *topwindow_info.running_gui
							#
							NULL => {   saved_events := arg ! *saved_events;				# When no GUI is running, all we can do is save user input for later processing. (Or maybe discard it?)
printf "guievent_sink()/guiboss: received '%s' Gui_Event but saved it because *topwindow_info.running_gui is NULL.    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
								};

							THE running_gui
							     =>	{
								    case *saved_events
									#
									[] =>   {
										    case event
											#
										        evt::x::KEY_PRESS       (key_xevtinfo: evt::Key_Xevtinfo)
											    =>
											    do_key_press (runstate, topwindow_info, running_gui, key_xevtinfo);

										        evt::x::KEY_RELEASE     (key_xevtinfo: evt::Key_Xevtinfo)
											    =>
											    do_key_release (runstate, topwindow_info, running_gui, key_xevtinfo);

										        evt::x::BUTTON_PRESS    (button_xevtinfo: evt::Button_Xevtinfo)
											    =>
											    do_button_press (runstate, topwindow_info, running_gui, button_xevtinfo);

										        evt::x::BUTTON_RELEASE  (button_xevtinfo: evt::Button_Xevtinfo)
											    =>
											    do_button_release (runstate, topwindow_info, running_gui, button_xevtinfo);

										        evt::x::MOTION_NOTIFY   (motion_xevtinfo: evt::Motion_Xevtinfo)
											    =>
											    do_motion_notify (runstate, topwindow_info, running_gui, motion_xevtinfo);

										        evt::x::ENTER_NOTIFY    (inout_xevtinfo: evt::Inout_Xevtinfo)
											    =>
											    {
#												printf "guievent_sink()/ENTER_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
											    };

										        evt::x::LEAVE_NOTIFY    (inout_xevtinfo: evt::Inout_Xevtinfo)
											    =>
											    {
#												printf "guievent_sink()/LEAVE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
											    };

										        evt::x::FOCUS_IN	(focus_xevtinfo: evt::Focus_Xevtinfo)
											    =>
											    printf "guievent_sink()/FOCUS_IN: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::FOCUS_OUT	(focus_xevtinfo:  evt::Focus_Xevtinfo)
											    =>
											    printf "guievent_sink()/FOCUS_OUT: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::KEYMAP_NOTIFY    { }
											    =>
											    printf "guievent_sink()/KEYMAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::EXPOSE           (expose_record:         evt::x::Expose_Record)
											    =>
											    printf "guievent_sink()/EXPOSE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::GRAPHICS_EXPOSE  (graphics_expose_record: evt::x::Graphics_Expose_Record)
											    =>
											    printf "guievent_sink()/GRAPHICS_EXPOSE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::NO_EXPOSE
											  { drawable:			evt::Drawable_Id,
											    major_opcode:		Unt,				# The graphics operation code.
											    minor_opcode:		Unt				# Always 0 for core protocol.
											  }
											    =>
											    printf "guievent_sink()/NO_EXPOSE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::VISIBILITY_NOTIFY
											  { changed_window_id:		evt::Window_Id,			# The window with changed visibility state.
											    state:			evt::Visibility			# The new visibility state.
											  }
											    =>
											    printf "guievent_sink()/VISIBILITY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::CREATE_NOTIFY
											  { parent_window_id:		evt::Window_Id,			# The created window's parent.
											    created_window_id:		evt::Window_Id,			# The created window.
											    box:			g2d::Box,			# The window's rectangle.
											    border_wid:			Int,				# The width of the border.
											    override_redirect:		Bool				#  
											  }
											    =>
											    printf "guievent_sink()/CREATE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::DESTROY_NOTIFY
											  { event_window_id:		evt::Window_Id,			# The window on which this was generated.
											    destroyed_window_id:	evt::Window_Id			# The destroyed window.
											  }
											    =>
											    printf "guievent_sink()/DESTROY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::UNMAP_NOTIFY
											  { event_window_id:		evt::Window_Id,			# The window on which this was generated.
											    unmapped_window_id:		evt::Window_Id,			# The window being unmapped.
											    from_config:		Bool				# TRUE if parent was resized.
											  }
											    =>
											    printf "guievent_sink()/UNMAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::MAP_NOTIFY
											  { event_window_id:		evt::Window_Id,			# The window on which this was generated.
											    mapped_window_id:		evt::Window_Id,			# The window being mapped.
											    override_redirect:		Bool				#  
											  }
											    =>
											    printf "guievent_sink()/MAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::MAP_REQUEST
											  { parent_window_id:		evt::Window_Id,			# The parent.
											    mapped_window_id:		evt::Window_Id			# The mapped window.
											  }
											    =>
											    printf "guievent_sink()/MAP_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::REPARENT_NOTIFY
											  { event_window_id:		evt::Window_Id,			# The window on which this was generated.
											    parent_window_id:      	evt::Window_Id,			# The new parent.
											    rerooted_window_id:    	evt::Window_Id,			# The re-rooted window.
											    upperleft_corner:		g2d::Point,			# The upper-left corner.
											    override_redirect:		Bool				#  
											  }
											    =>
											    printf "guievent_sink()/REPARENT_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::CONFIGURE_NOTIFY
											  { event_window_id:       	evt::Window_Id,			# The window on which this was generated.
											    configured_window_id:	evt::Window_Id,			# The reconfigured window.
											    sibling_window_id:	Null_Or(evt::Window_Id),		# The sibling that window is above (if any).
											    box:			g2d::Box,			# The window's rectangle.
											    border_wid:  		Int,				# The width of the border.
											    override_redirect:		Bool				#  
											  }
											    =>
											    {
												printf "guievent_sink()/CONFIGURE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
											    };

										        evt::x::CONFIGURE_REQUEST
											  { parent_window_id:		evt::Window_Id,			# The parent.
											    configure_window_id:	evt::Window_Id,			# The window to reconfigure.
											    sibling_window_id:  	Null_Or(evt::Window_Id),		# The new sibling (if any).
											    x:           		Null_Or(Int),			# The window's rectangle.
											    y:           		Null_Or(Int),
											    wide:        		Null_Or(Int),
											    high:        		Null_Or(Int),
											    border_wid:  		Null_Or(Int),			# The width of the border.
											    stack_mode: 		Null_Or(evt::Stack_Mode)		# The mode for stacking windows.
											  }
											    =>
											    printf "guievent_sink()/CONFIGURE_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::GRAVITY_NOTIFY
											  {
											    event_window_id:		evt::Window_Id,			# The window on which this was generated.
											    moved_window_id:   		evt::Window_Id,			# The window being moved.
											    upperleft_corner:		g2d::Point			# Upper-left corner of window.
										          }		
											    =>
											    printf "guievent_sink()/GRAVITY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::RESIZE_REQUEST
											  {
											    resize_window_id:		evt::Window_Id,			# The window to resize.
											    req_size:			g2d::Size			# The requested new size.
											  }
											    =>
											    printf "guievent_sink()/RESIZE_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::CIRCULATE_NOTIFY
											  {
											    event_window_id:		evt::Window_Id,			# The window on which this was generated.
											    circulated_window_id:	evt::Window_Id,			# The window being circulated.
											    parent_window_id:		evt::Window_Id,			# The parent.
											    place:			evt::Stack_Pos			# The new place.
											  }
											    =>
											    printf "guievent_sink()/CIRCULATE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::CIRCULATE_REQUEST
											  {
											    parent_window_id:		evt::Window_Id,			# The parent.
											    circulate_window_id:	evt::Window_Id,			# The window to circulate.
											    place:			evt::Stack_Pos			# The place to circulate the window to.
											  }
											    =>
											    printf "guievent_sink()/CIRCULATE_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										        evt::x::PROPERTY_NOTIFY
											  {
											    changed_window_id:		evt::Window_Id,			# The window with the changed property.
											    atom:        		evt::Atom,			# The affected property.
											    timestamp:  		evt::t::Xserver_Timestamp,	# When the property was changed.
											    deleted:     		Bool				# TRUE if the property was deleted.
											  }
											    =>
											    printf "guievent_sink()/PROPERTY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::SELECTION_CLEAR
											  {
											    owning_window_id:		evt::Window_Id,			# The current owner of the selection.
											    selection:			evt::Atom,			# The selection.
											    timestamp:			evt::t::Xserver_Timestamp	# The last-change time.
											  }		
											    =>
											    printf "guievent_sink()/SELECTION_CLEAR: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::SELECTION_REQUEST
											  {
											    owning_window_id:		evt::Window_Id,			# The owner of the selection.
											    selection:			evt::Atom,			# The selection.
											    target:			evt::Atom,			# The requested type for the selection.
											    requesting_window_id:	evt::Window_Id,			# The requesting window.
											    property:			Null_Or( evt::Atom ),		# The property to store the selection in. 
											    timestamp:			evt::Timestamp			#  
											  }
											    =>
											    printf "guievent_sink()/SELECTION_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::SELECTION_NOTIFY
											  {
											    requesting_window_id:	evt::Window_Id,			# The requestor of the selection.
											    selection:			evt::Atom,			# The selection.
											    target:			evt::Atom, 			# The requested type of the selection.
											    property:			Null_Or( evt::Atom ),		# The property to store the selection in.
											    timestamp:			evt::Timestamp  		#  
											  }
											    =>
											    printf "guievent_sink()/SELECTION_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::COLORMAP_NOTIFY
											  {
											    window_id:			evt::Window_Id,			# The affected window.
											    cmap:			Null_Or( evt::Colormap_Id ),	# The colormap.
											    new:			Bool,				# TRUE, if the colormap attribute is changed.
											    installed: 			Bool				# TRUE, if the colormap is installed.
											  }
											    =>
											    printf "guievent_sink()/COLORMAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::CLIENT_MESSAGE
											  {
											    window_id:			evt::Window_Id,			#  
											    type:			evt::Atom,			# The type of the message.
											    value:			evt::Raw_Data			# The message value.
											  }
											    =>
											    printf "guievent_sink()/CLIENT_MESSAGE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::MODIFIER_MAPPING_NOTIFY					# Really a MappingNotify event.
											    =>
											    printf "guievent_sink()/MODIFIER_MAPPING_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::KEYBOARD_MAPPING_NOTIFY					# Really a MappingNotify event.
											  {
											    first_keycode:  evt::Keycode,
											    count:          Int
											  }
											    =>
											    printf "guievent_sink()/KEYBOARD_MAPPING_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

											evt::x::POINTER_MAPPING_NOTIFY					# Really a MappingNotify event.
											    =>
											    printf "guievent_sink()/POINTER_MAPPING_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

										    esac;								# NB: We avoid a '_' case here because if an event is added to evt::x::Event we want a compile error as a reminder to handle it.

										};

									_  =>   {						# Woops, we have prior events that came in before we were ready to process them.
										    saved_events := arg ! *saved_events;	# Add latest event to saved-events list.
										    events = reverse *saved_events;		# Reverse saved-events list so we process them in first-in-first-out order.
										    saved_events := [];				# Clear saved-events so  we don't process any of them twice.
										    apply guievent_sink events;			# Recursively process all saved events in order.  NB: Any new events that arrive during this will just accumulate on guiboss_q. That's fine.
										};						# 
								    esac;
								};
								
						    esac;
						}
					);

				    guievent_sink_fn  :=  guievent_sink;							# Switch guievent_sink_wrapper() over from using initial_guievent_sink() to using guievent_sink().


				    put_in_oneshot (reply_oneshot, guiboss_to_topwindow);
				}
		        );

			get_from_oneshot  reply_oneshot;
		    };

		#
		fun stop_gui
		      (
			running_gui:		rg::Running_Gui,							# Private
			bounce_imps:		Bounce_Imps,
			canvas_imps:		Canvas_Imps,
			packed_imps:		Packed_Imps,
			gadget_imps:		Gadget_Imps,
			topwindow_info:		Topwindow_Info
		      )
		      : sg::Stopped_Gui
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( sg::Stopped_Gui );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				put_in_oneshot  (reply_oneshot,  stop_gui' (runstate, (running_gui, bounce_imps, canvas_imps, packed_imps, gadget_imps, topwindow_info)))
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun start_gui												# PUBLIC.
		      (
			topwindow:	gws::Guiboss_To_Topwindow,
			gui_plan:	gp::Gui_Plan
		      )
		    : (Void -> c2g::Client_To_Guiwindow)
		    =	
		    {   gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( c2g::Client_To_Guiwindow );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				start_gui' (runstate, topwindow, gui_plan, gui_startup_complete', guiboss_q, stop_gui)
		        );

			{.   get_from_oneshot  gui_startup_complete';   };
		    };

		#
		fun restart_gui												# PUBLIC.
		      (
			topwindow:	gws::Guiboss_To_Topwindow,
			stopped_gui: 	sg::Stopped_Gui
		      )
		    : (Void -> c2g::Client_To_Guiwindow)
		    =	
		    {   gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( c2g::Client_To_Guiwindow );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				restart_gui' (runstate, topwindow, stopped_gui, gui_startup_complete', guiboss_q, stop_gui)
		        );

			{.   get_from_oneshot  gui_startup_complete';   };
		    };

		#
		fun get_bounce_theme ()											# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( bt::Gui_To_Bounce_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.gui_to_bounce_theme)
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun get_canvas_theme ()											# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( ct::Gui_To_Canvas_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.gui_to_canvas_theme)
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun get_packed_theme ()											# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( tp::Packed_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.theme)
			);

			get_from_oneshot reply_oneshot;
		    };
	    end;

	#
	fun process_options (options: List(Guiboss_Option), { name, id })
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME	n) =>   my_name			:=  n;
			do_option (ID			i) =>   my_id                   :=  i;
		    end;
		end;

		{ name			=>  *my_name,
		  id 			=>   *my_id
		};
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_guiboss_egg
	      (guiboss_arg:		Guiboss_Arg)									# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	    =
	    {	guiboss_arg ->  (guiboss_options);									# Currently no guiboss_needs component, so this is a no-op.
		#
		(process_options
		  ( guiboss_options,
		    { name		=> "guiboss",
		      id		=>  id_zero
		    }
		) )
		    ->
		    { name,
		      id
		    };
	
		my (id, guiboss_options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();										# Allocate unique imp id.
			(id, ID id ! guiboss_options);									# Make our id stable across stop/restart cycles.
		    else
			(id, guiboss_options);
		    fi;

		guiboss_arg = (guiboss_options);									# Currently no guiboss_needs component, so this is a no-op.

		me =  {
			topwindows	=>  REF im::empty								# Track all topwindows created by our make_topwindow() entrypoint.
		      };

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );		# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));					# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3											# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, guiboss_arg, imports, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;


##########################################################################
# Note[1]
#
# This package is not aimed at gaming where 120 frames per second is welcome,
# but rather at visualization apps etc where the background processing is the
# point and we don't want the display subsystem eating inordinate amounts of
# CPU power.  Consequently in general we throttle screen update to ten frames
# per second or so, controlled by 'seconds_per_frame' in frameclock().
#
# But we do want to minimize response latency to clicking on a widget, so
# we implement a special hack allowing one widget per frame to redraw
# immediately instead of having to wait for the next frame redraw time.
# This hack is controlled by
#	done_extra_startframe_this_frame:	Ref(Bool),





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
