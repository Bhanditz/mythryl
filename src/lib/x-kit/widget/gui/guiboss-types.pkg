## guiboss-types.pkg
#
# Interface types for   src/lib/x-kit/widget/gui/guiboss-imp.pkg
#
# We use three representations for a GUI with transition diagram
#
#     Gui_Plan
#         |
#         v
#     Stopped_Gui
#       |   ^
#       v   |
#     Running_Gui
#
# The application programmers passes guiboss_imp a Gui_Plan
# to define the GUI, which is then converted to a Stopped_Gui
# and at GUI startup time to a Running_Gui.
#     We support pausing and later restarting the GUI by a
# process of converting the Running_Gui back to a Stopped_Gui
# and at restart the Stopped_Gui again to a Running_Gui.
#
# In addition to defining the three GUI representations, this
# file defines most (but not all) of the major ports between
# guiboss_imp and other imps:								# "gadget" refers to any of "widget", "sprite" or "object".  (Most frequently, "widget".)
#
#	guiboss_to_gadget								# The general guiboss_imp -> gadget interface, used for forwarding user mouseclicks etc.  Most frequently used guiboss_imp -> widget_imp, but also to sprite_imp and object_imp.
#	gadget_to_guiboss								# The general gadget -> guiboss_imp interface, used for forwarding draw operations  etc.
#	guiboss_to_packedspace								# The guiboss_imp -> packedspace_imp, used to manage layout of widgets on windows.
#	guiboss-to-canvasspace.pkg							# The guiboss_imp -> canvasspace_imp, used to manage layout of objects on windows.
#	guiboss-to-bouncespace.pkg							# The guiboss_imp -> bouncespace_imp, used to manage layout of sprites on windows.
#     

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;							# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package g2d =  geometry2d;								# geometry2d				is from   src/lib/std/2d/geometry2d.pkg
    package pt  =  packed_theme;							# packed_theme				is from   src/lib/x-kit/widget/theme/packed/packed-theme.pkg
    package evt =  gui_event_types;							# gui_event_types			is from   src/lib/x-kit/widget/gui/gui-event-types.pkg

    package w2p =  widget_to_packedspace;						# widget_to_packedspace			is from   src/lib/x-kit/widget/space/packed/widget-to-packedspace.pkg   
    package p2w =  packedspace_to_widget;						# packedspace_to_widget			is from   src/lib/x-kit/widget/space/packed/packedspace-to-widget.pkg

    package o2c =  object_to_canvasspace;						# object_to_canvasspace			is from   src/lib/x-kit/widget/space/canvas/object-to-canvasspace.pkg   
    package c2o =  canvasspace_to_object;						# canvasspace_to_object			is from   src/lib/x-kit/widget/space/canvas/canvasspace-to-object.pkg

    package s2b =  sprite_to_bouncespace;						# sprite_to_bouncespace			is from   src/lib/x-kit/widget/space/bounce/sprite-to-bouncespace.pkg   
    package b2s =  bouncespace_to_sprite;						# bouncespace_to_sprite			is from   src/lib/x-kit/widget/space/bounce/bouncespace-to-sprite.pkg

    package g2p =  gadget_to_pixmap;							# gadget_to_pixmap			is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg
    package s2g =  space_to_gui;							# space_to_gui				is from   src/lib/x-kit/widget/gui/space-to-gui.pkg

    package iul =  issue_unique_look_id;						# issue_unique_look_id			is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg
    package gws =  guiboss_to_windowsystem;						# guiboss_to_windowsystem		is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg

    package pp  =  standard_prettyprint_mill;						# standard_prettyprint_mill		is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg

    package blh =  bouncespace_layout_hint;						# bouncespace_layout_hint		is from   src/lib/x-kit/widget/space/bounce/bouncespace-layout-hint.pkg
    package clh =  canvasspace_layout_hint;						# canvasspace_layout_hint		is from   src/lib/x-kit/widget/space/canvas/canvasspace-layout-hint.pkg
    package plh =  packedspace_layout_hint;						# packedspace_layout_hint		is from   src/lib/x-kit/widget/space/packed/packedspace-layout-hint.pkg

    package err =  error_message;							# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package gd  =  gui_displaylist;							# gui_displaylist			is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg


    # Some abbreviations because line length was getting out of hand below:
    #
    Bs_Layout =  blh::Bouncespace_Layout_Hint;
    Cs_Layout =  clh::Canvasspace_Layout_Hint;
    Ps_Layout =  plh::Packedspace_Layout_Hint; 
    #
    Once(X) = Oneshot_Maildrop(X);


herein

    package guiboss_types
    {


	#########################################################################################
	## preliminary types

	Viewport_Scroller
	  =
	  { get_viewport_origin: Void -> g2d::Point,
	    set_viewport_origin: g2d::Point -> Void
	  };

	Viewport_Scroller_Callback							# Used in Packed_Widget.VIEWPORT	in   src/lib/x-kit/widget/gui/running-gui.pkg
	  =
	  Null_Or( Viewport_Scroller ) -> Void;


	Tabbed_View_Picker
	  =
	  { get_active_view: Void -> Int,
	    set_active_view: Int -> Void
	  };

	Tabbed_View_Picker_Callback							# Used in Packed_Widget.TABBED_VIEWS	in   src/lib/x-kit/widget/gui/running-gui.pkg
	  =
	  Null_Or( Tabbed_View_Picker ) -> Void;


	#########################################################################################
	## Preliminary running-gui types

	# Storing instances of
	#     guiboss_to_bouncespace, 
	#     guiboss_to_canvasspace, 
	# or  guiboss_to_packedspace
	# directly in Running_Gui leads to package circularity,
	# so instead we store their integer id here, and
	# in guiboss-imp.pkg look them up as needed in
	# (respectively):	
	#     bouncespaces
	#     canvasspaces
	#     packedspaces
	# 
	Bouncespace_Id = Id;
	Canvasspace_Id = Id;
	Packedspace_Id = Id;

	Packed_Layout_Hints												# Predigested form of   List( plh::Packedspace_Layout_Hint ); 
	  =
	  { cut:	Null_Or(Float),											# Controls this widget's share of available pixels. We force this to be positive. Default is 1.0 if not specified.
	    min:	Null_Or(Int)
	  };



	#########################################################################################
	## gadget-to-guiboss types


	Gadget_Mode												# We use this mostly to control how a widget draws itself.
	  =													# To avoid a package cycle this def is duplicated in   src/lib/x-kit/widget/theme/packed/packed-theme.pkg
	  {													# We probably should find/make another home for this def. XXX SUCKO FIXME
	    is_active:				Bool,								# An inactive gadget is passed no user input. Inactive widgets are typically drawn "grayed-out".
	    has_mouse_focus:			Bool,								# A widget which has the mouse cursor on it may want to draw itself brigher or such.
	    has_keyboard_focus:			Bool,								# A widget which has the keyboard focus will often      draw a black outline around its text-entry rectangle.
	    mousebutton_is_down:		Bool								# I'm not sure if this belongs here.
	  };

	#########################################################################################
	## gui-plan datatypes

	Bounce_Widget
	    #
	    = SPRITE		Bounce_Sprite_Start_Fn

	also
	Canvas_Widget
	    #
	    = PACKEDSPACE	(List(Packedspace_Option),  Packed_Widget)
	    #
	    | OBJECT		Canvas_Object_Start_Fn

	also
	Packed_Widget
	    #
	    = ROW		 List( (List(plh::Packedspace_Layout_Hint), Packed_Widget) )
	    | COL		 List( (List(plh::Packedspace_Layout_Hint), Packed_Widget) )
	    #	
	    | SCROLLABLE_VIEW    (
				   Viewport_Scroller_Callback,								# Callback for registering scroller with client app code.
				   g2d::Size,										# Size of pixmap visible through viewport.
				   Packed_Widget									# There will be one pixmap per List entry. (In general they will be the roots of widget-trees.)
				 )											# 
	    | TABBED_VIEWS	 ( Tabbed_View_Picker_Callback,
				   g2d::Size,										# Size of pixmap visible through viewport.
				   List( Packed_Widget )								# *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST ***
				 )											# There will be one pixmap per List entry. (In general they will be the roots of widget-trees.)
				 											# Only one will be visible at a given time.

	    | WIDGET		Packed_Widget_Start_Fn									# These values are created by   make_packed_widget_start_fn   in   src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg 
	    #
	    | CANVASSPACE	(List(Canvasspace_Option),  List((List(clh::Canvasspace_Layout_Hint), Canvas_Widget)))
	    | BOUNCESPACE	(List(Bouncespace_Option),  List((List(blh::Bouncespace_Layout_Hint), Bounce_Widget)))
	    #
	    | NULL_PACKED_WIDGET									# Note[1]


	#########################################################################################
	## stopped-gui datatypes

	also
	Sg_Bounce_Widget												# Nomenclature: "Sg_" == "Stopped_Gui_";  "SG_" == "STOPPED_GUI_".
	    #
	    = SG_SPRITE		( Bounce_Sprite_Start_Fn,
				  Null_Or(Exception)									# saved_sprite_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				)
	also
	Sg_Canvas_Widget
	    #
	    = SG_PACKEDSPACE	(List(Packedspace_Option),  Sg_Packed_Widget)
	    #
	    | SG_OBJECT		( Canvas_Object_Start_Fn,
				  Null_Or(Exception)									# saved_object_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				)
	also
	Sg_Packed_Widget
	    #
	    = SG_ROW		 List( (List(plh::Packedspace_Layout_Hint), Sg_Packed_Widget) )
	    | SG_COL		 List( (List(plh::Packedspace_Layout_Hint), Sg_Packed_Widget) )
	    #	
 	    | SG_SCROLLABLE_VIEW ( Viewport_Scroller_Callback,								# Callback for registering scroller with client app code.
				   g2d::Size,
				   Sg_Packed_Widget									# 
				 )
 	    | SG_TABBED_VIEWS	 ( Tabbed_View_Picker_Callback,
				   g2d::Size,
				   List(Sg_Packed_Widget)								# 
				 )
	    #
	    | SG_WIDGET		( Packed_Widget_Start_Fn,
				  Null_Or(Exception)									# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				)
	    #
	    | SG_CANVASSPACE	(List(Canvasspace_Option),  List((List(clh::Canvasspace_Layout_Hint), Sg_Canvas_Widget)))
	    | SG_BOUNCESPACE	(List(Bouncespace_Option),  List((List(blh::Bouncespace_Layout_Hint), Sg_Bounce_Widget)))
	    #
	    | SG_NULL_PACKED_WIDGET											# Note[1]


	#########################################################################################
	## running-gui datatypes

	also
	Rg_Bounce_Widget												# Nomenclature: "Rg_" == "Running_Gui_",  "RG_" == "RUNNING_GUI_".  
	    #
	    = RG_SPRITE	      {
				bouncespace_to_sprite:	b2s::Bouncespace_To_Sprite,					# 
				guiboss_to_gadget:	Guiboss_To_Gadget,						# 

				endstate_oneshot:	Once( ( 							# The sprite-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
								Bounce_Sprite_Start_Fn,					# 
								Null_Or(Exception)					# saved_sprite_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							    ) )	
			      }
			
	also
	Rg_Canvas_Widget
	    #
	    = RG_PACKEDSPACE  {	packedspace_id:		Packedspace_Id,							# A packed space embedded in a canvas, to allow all packedspace widgets to be used also on a canvas.
				packed_widget:		Rg_Packed_Widget
			      }
	    | RG_OBJECT	      {
				canvasspace_to_object:	c2o::Canvasspace_To_Object,					# 
				guiboss_to_gadget:	Guiboss_To_Gadget,						# 

				endstate_oneshot:	Once( (								# The sprite-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
								Canvas_Object_Start_Fn,
								Null_Or(Exception)					# saved_object_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							    ) )

			      }
	also
	Rg_Packed_Widget
	    #
	    = RG_ROW	      {												# A horizontal row of packed widgets.
				widgets:		List(								# The list of widgets to be laid out and displayed in this row.
							      { widget:	 	Rg_Packed_Widget,			# One widget in the row. Note that it could be a COL or SCROLLABLE_VIEW or such containing multiple subwidgets.
								raw_hints:	List(plh::Packedspace_Layout_Hint),	# Layout hints provided by client code.
								cooked_hints:	Packed_Layout_Hints			# Digested version of previous.
							      }								#
							    ),
				pixels_high_min: 	Ref(Int),							# Minimum            vertical   pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				pixels_wide_min: 	Ref(Int),							# Minimum            horizontal pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				#
				pixels_high_cut: 	Ref(Float),							# Share of remaining vertical   pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				pixels_wide_cut: 	Ref(Float),							# Share of remaining horizontal pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				#
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }

	    | RG_COL	      {												# A vertical column of packed widgets.
				widgets:		List(								# The list of widgets to be laid out and displayed in this column.
							      { widget:		Rg_Packed_Widget,			# One widget in the column. Note that it could be a ROW or SCROLLABLE_VIEW or such containing multiple subwidgets.
								raw_hints:	List(plh::Packedspace_Layout_Hint),	# Layout hints provided by client code.
								cooked_hints:	Packed_Layout_Hints			# Digested version of next
							      }								#
							    ),
				pixels_high_min: 	Ref(Int),							# Minimum            vertical   pixels to allocate for this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				pixels_wide_min: 	Ref(Int),							# Minimum            horizontal pixels to allocate for this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				#
				pixels_high_cut: 	Ref(Float),							# Share of remaining vertical   pixels to allocate to  this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				pixels_wide_cut: 	Ref(Float),							# Share of remaining horizontal pixels to allocate to  this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				#
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }

	    | RG_SCROLLABLE_VIEW {											# Here we provide support for widgets visible through a scrollable viewport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
				widget:			Rg_Packed_Widget,						# Tree of widgets partially visible in viewport.
				gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,					# This is the pixmap visible through the viewport. It holds a full image of above 'widget' tree.
				view_origin:		Ref(g2d::Point),						# Origin of view's backing_pixmap in viewport coordinates, used for scrolling pixmap in viewport.
				backing_pixmap:		s2g::Backing_Pixmap,						# This is the parent pixmap holding the viewport.
				scroller:		Viewport_Scroller,
				callback:		Viewport_Scroller_Callback,					# This is how we pass our Viewport_Scroller to app client code, which basically lets it set 'pixmap_origin' above.
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }

	    | RG_TABBED_VIEWS {												# Here we provide support for selection between alternate views in viewport.  Actually providing tabs happens at a higher level; here we handle pixmap state maintenance and redraw support.
				pixmap_size:		g2d::Size,							# Size of alternate pixmaps visible in viewport.  We require them to all be the same size; we intend that the viewport be the same size.
				widgets:		List(								# This record holds one of the alternate views which may be made visible in the viewport.  *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST! *** 
							      { widget:			Rg_Packed_Widget,		# Tree of widgets visible in this tab.
								gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,	# This pixmap holds the current visible state of the above widget-tree.
								backing_pixmap:		s2g::Backing_Pixmap		# This is the parent pixmap holding the viewport through which we are visible (when we're visible).
							      }								# This record is type Tabview; we can't use that name here because records and datatypes cannot be mutually recursive.
							    ),
				visible_widget:		Ref (								# Which of 'widgets' is currently visible?  This refcell holds one element from 'widgets';  it supports switching between the tabbed views.
							      { widget:			Rg_Packed_Widget,		#
								gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,	#
								backing_pixmap:		s2g::Backing_Pixmap		# 
							      }								# This record is type Tabview; we can't use that name here because records and datatypes cannot be mutually recursive.
							    ),
				callback:		Tabbed_View_Picker_Callback,					# This is how we pass our Tabbed_View_Picker to app client code, which basically lets it set 'visible_widget' above.
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }
	    #
	    | RG_WIDGET	      {												# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg
				guiboss_to_gadget:	Guiboss_To_Gadget,						# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/gui/guiboss-imp.pkg
				packedspace_to_widget:	p2w::Packedspace_To_Widget,					# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

				endstate_oneshot:	Once( (								# The widget-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
								Packed_Widget_Start_Fn,					#
								Null_Or(Exception)					# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							    ) ),
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }

	    #
	    | RG_CANVASSPACE  {	canvasspace_id:		Canvasspace_Id,							# guiboss-imp indexes this value into *canvas_stuff to obtain (e.g.) a Guiboss_To_Canvasspace port to the canvasspace-imp.
				widgets:		List ((List(Cs_Layout), Rg_Canvas_Widget)),			# The list of widgets to be drawn on the canvas. These can be placed arbitrarily, including possible overlaps.
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }
	    | RG_BOUNCESPACE  { bouncespace_id:		Bouncespace_Id,							# guiboss-imp indexes this value into *bounce_stuff to obtain (e.g.) a Guiboss_To_Bouncespace port to the bouncespace-imp.
				widgets:		List ((List(Bs_Layout), Rg_Bounce_Widget)),			# The list of widgets to be drawn on the bouncespace. These can be placed arbitrarily.
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }
	    #
	    | RG_NULL_PACKED_WIDGET											# We need this because Running_Gui requires an Rg_Packed_Widget value, and sometimes we may not have anything else.



	#########################################################################################
	## guiboss-to-packedspace datatypes
	#
	# Communication from	src/lib/x-kit/widget/gui/guiboss-imp.pkg
	# to 			src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

	also
	Guiboss_To_Packedspace
	  =
	  GUIBOSS_TO_PACKEDSPACE
	    { id:			Id,										# Unique id to facilitate storing guiboss_to_packedspace instances in indexed datastructures like red-black trees.
	      #
	      pass_something:		Replyqueue -> (Int -> Void) -> Void,

	      pass_re_siting_done_flag											# This call updates the pixel-rectangle allocations of the widgets in the given widget-tree and notifies when done.
		  :
		  ( g2d::Box,												# Take this pixel rectangle (in window coordinates)
		    s2g::Backing_Pixmap,										# on this pixmap and divide it between the widgets in
		    Rg_Packed_Widget											# this widget-tree.
		  )
		  -> Replyqueue												# When done inform in this imp-replyqueue
		  -> (Void -> Void)											# this handler.
		  -> Void,

	      do_something:		Int -> Void
	    }

	also
	Packedspace_Option
	    #
	    = PS_MICROTHREAD_NAME	String										# 
	    | PS_ID			Id										# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	    | PS_CALLBACK		Guiboss_To_Packedspace -> Void



	#########################################################################################
	## guiboss-to-canvaspace datatypes
	#
	# Communication from	src/lib/x-kit/widget/gui/guiboss-imp.pkg
	# to 			src/lib/x-kit/widget/space/canvas/canvasspace-imp.pkg

	also
	Guiboss_To_Canvasspace
	    =
	    GUIBOSS_TO_CANVASSPACE
	      { id:			Id,										# Unique id to facilitate storing guiboss_to_canvasspace instances in indexed datastructures like red-black trees.
		#
		pass_something:		Replyqueue -> (Int -> Void) -> Void,
		do_something:		Int -> Void
	      }

	also
	Canvasspace_Option
	  #
	  = CS_MICROTHREAD_NAME		String										# 
	  | CS_ID			Id										# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	  | CS_CANVASSPACE_CALLBACK	Guiboss_To_Canvasspace -> Void


	#########################################################################################
	## guiboss-to-bouncespace datatypes
	#
	# Communication from	src/lib/x-kit/widget/gui/guiboss-imp.pkg
	# to 			src/lib/x-kit/widget/space/bounce/bouncespace-imp.pkg

	also
	Guiboss_To_Bouncespace
	    =
	    GUIBOSS_TO_BOUNCESPACE
	      { id:			Id,										# Unique id to facilitate storing guiboss_to_bouncespace instances in indexed datastructures like red-black trees.
		#
		pass_something:	Replyqueue -> (Int -> Void) -> Void,
		do_something:	Int -> Void
	      }

	also
	Bouncespace_Option
	  #
	  = OS_MICROTHREAD_NAME 	String										# 
	  | OS_ID			Id										# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	  | OS_BOUNCESPACE_CALLBACK	Guiboss_To_Bouncespace -> Void


	#########################################################################################
	## gadget-to-guiboss datatypes

	also
	Gadget_To_Guiboss
	    =
	    GADGET_TO_GUIBOSS
	      { id:					Id,							# Unique id to facilitate storing Gadget_To_Guiboss ports in indexed datastructures like red-black trees.
		#
		gadget_may_have_visibly_changed:	iul::Id	-> Void,					# Inform guiboss_imp that the gadget's appearance may need refreshing. Without this, it may not get a start_of_frame call.
														# This call is usually needed only when the app has changed the gadget's appearance; guiboss knows about mouse/keyboard input
														# to gadget and assumes that they may have resulted in appearance changes.

		update_gadget_appearance									# Update gadget appearance in response to a guiboss_to_gadget.start_of_frame {...} call.
		  :
		  { id:				iul::Id,
		    displaylist:			gd::Gui_Displaylist,
		    point_in_gadget:		Null_Or( g2d::Point -> Bool )					# Optional fn to decide if a mouseclick actually hit the gadget itself, or just somewhere near it in the screenspace assigned to it.
		  }
		  ->
		  Void,

		note_changed_gadget_activity:	{ id: iul::Id, is_active:  Bool } -> Void			# FALSE if gadget should be insensitive to input and perhaps drawn grayed-out.  Controlled by application logic.
	      }




	#########################################################################################
	## guiboss-to-gadget datatypes

	also
	Gadget_Transit										# This protocol is intended to support (e.g.) highlighting a gadget while the mouse is over it.
	    #											# The intended semantics here is that:
	    = CAME										#  o  A widget should always see an  CAME before anything else when the mouse cursor enters its space.   CAME events are NOT sent during a drag. A MOVED is always sent immediately after an CAME, with the same mouse coordinate.
 	    | MOVE										#  o  A widget can see any number of MOVE events between a CAME and LEFT; all will be in its space.	 MOVE events are NOT sent during a drag.
	    | LEFT										#  o  A widget should always see a   LEFT after  everything else when the mouse cursor exits  its space. LEFT events are NOT sent during a drag.
	    											#  o  Thus, a widget is not guaranteed to see an CAME every time the mouse cursor enters it (due to drag exception). But if it sees anything at all, an CAME will be first, and a LEFT will be last.

	also
	Drag_Phase										# This protocol is intended to support dragging a slider or scrollbar thumb.
	    #											# The intended semantics here is that:
	    = OPEN										#  o  Every drag sequence begins with exactly one OPEN.
	    | DRAG										#  o  Every drag sequence has zero or more        DRAG phases.
	    | DONE										#  o  Every drag sequence ends   with exactly one DONE.
												# 

	also
	Key_Event										# This protocol is intended to support keyboard text entry.
	    #
	    = KEY_PRESS
	    | KEY_RELEASE

	also
	Mousebutton_Event									# This protocol is intended to support mouse button processing.  Double-clicks are not supported here.  I dislike them because they inherently add latency, and half of GUI framework design is about minimizing latency.
	    #
	    = MOUSEBUTTON_PRESS
	    | MOUSEBUTTON_RELEASE

	also
	Guiboss_To_Gadget
	  =
	  GUIBOSS_TO_GADGET
	    { id:			iul::Id,						# Unique id to facilitate storing Guiboss_To_Gadget ports in indexed datastructures like red-black trees.
		#
		wants_keystrokes:	Bool,							# TRUE iff guiboss_imp should send keyboard events to this widget.  This might need to become a Ref(Bool)...?
		wants_mouseclicks:	Bool,							# TRUE iff guiboss_imp should send mouse    events to this widget.  This is about correctness not efficiency: We might have two nested candidate widgets where this flag decides which one gets the event.

		#
		before_first_frame: {								# Before the first start_of_frame call every widget-imp gets this call from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
				      #								# If its appearance has changed it should call note_changed_gadget_foreground() from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
				      site:			g2d::Box,			# Window rectangle in which to draw.
				      theme:		pt::Packed_Theme,
				      #
				      get_font:		List(String) ->  evt::Font,		# Accepts a list of font names which are tried in order; returns font 'ascent' and 'descent' in pixels -- sum them to get  font height.
				      pass_font:	List(String) -> Replyqueue		#
								     -> ( evt::Font -> Void )	#
								     -> Void,			# Nonblocking version of previous, for use in imps.

				      make_rw_pixmap:	g2d::Size -> g2p::Gadget_To_Rw_Pixmap
				    }
				    ->
				    Void,


		start_of_frame:	{								# At the start of every frame every widget-imp gets this call from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
				  #								# If its appearance has changed it should call update_gadget_appearance() from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
				  frame_number:		Int,					# 1,2,3,... Purely for convenience of look-imp, guiboss-imp makes no use of this.
				  site:			g2d::Box,				# Window rectangle in which to draw.
				  visible:		Bool,					# If FALSE, widget is not visible on screen, so look-imp may be able to avoid updating foreground displaylist.
				  duration_in_seconds:	Float,					# If state has changed look-imp should call update_gadget_appearance() before this time is up. Also useful for motionblur.
				  this_gadget_mode:	Gadget_Mode,
				  theme:		pt::Packed_Theme
				}
				->
				Void,


		note_mouse_drag_event:	    {							# Intended to support dragging sliders and scrollbar thumbs etc.  Not intended for drag-and-drop.
					      phase:		    Drag_Phase,			# We guarantee that the gadget that sees the OPEN (downclick) for a drag also sees all the DRAGs and the DONE for that drag, and that no other gadget sees drag or transit events during that time period.
					      modifier_keys_state:  evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
					      mousebuttons_state:   evt::Mousebuttons_State,	# State of mouse buttons as a bool record.
					      event_point:	    g2d::Point,			# 'event_point' is the current   point the window's coordinate system.
					      start_point:	    g2d::Point,			# 'start_point' is the downclick point the window's coordinate system.
					      last_point:	    g2d::Point,			# 'last_point'  is the event_point from the preceding ntoe_mouse_drag_event call.
					      site:		    g2d::Box,			# Widget's assigned area in window coordinates.
					      theme:		    pt::Packed_Theme		#
					    }							# DONE is sent when last mousebutton is released, no matter where that happnes.
					    -> Void,						# Normally OPEN and DRAG are sent if they occur within the gadget's assigned site.
												# This can be restricted to a sub-area of the site using point_in_gadget -- src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg

		note_mouse_transit:	    {							# Mouse entering or leaving window site assigned to gadget.  Intended to support tooltips, active-widget highlighting etc. Note that buttons are always all up in a mouse transit -- otherwise it is a mouse-drag event.
					      transit:		    Gadget_Transit,
					      modifier_keys_state:  evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
					      event_point:	    g2d::Point,			# 'event_point'  is the click point the window's coordinate system.
					      site:		    g2d::Box,			# Widget's assigned area in window coordinates.
					      theme:		    pt::Packed_Theme		#
					    }							# CAME/MOVE/LEFT are never sent during drag operations.
					    -> Void,						# Normally CAME/MOVE  are sent if they occur within the gadget's assigned site.
												# This can be restricted to a sub-area of the site using point_in_gadget -- src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg

		note_key_event:	    	   {							# Note keyboard KEY_PRESS or KEY_RELEASE at 'point'. Intended for textfield text entry etc.
					      key_event:	    Key_Event,			# KEY_PRESS or KEY_RELEASE.
					      keycode:		    evt::Keycode,		# Keyboard key just pressed/released.
					      keysym:		    evt::Keysym,		# Keysym  of the key.  This is not present in the X version of Key_Kevtinfo; added for widget-code convenience.
					      string:		    String,			# Ascii  for the key.  This is not present in the X version of Key_Kevtinfo; added for widget-code convenience.
					      modifier_keys_state:  evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
					      mousebuttons_state:   evt::Mousebuttons_State,	# State of mouse buttons as a bool record.
					      event_point:	    g2d::Point,			# 'point'  is the click point the window's coordinate system.
					      site:		    g2d::Box,			# Widget's assigned area in window coordinates.
					      theme:		    pt::Packed_Theme
					    }
					    -> Void,

		note_mousebutton_event:	    {							# Note mousebutton click at 'point'.  Intended for pushbuttons etc.
					      mousebutton_event:    Mousebutton_Event,		# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE. These go to the gadget under the mouse pointer, hence a gadget may not see both if the pointer moves between them. Use note_mouse_drag_event if this is a problem.
					      mouse_button:	    evt::Mousebutton,		# Mouse button just clicked down. Range is 1-13 or more.  Typically 1=left, 2=middle, 3=right, 4=mousewheel-forward, 5=mousewheel-back.
					      modifier_keys_state:  evt::Modifier_Keys_State,	# State of the modifier keys (shift, ctrl...).
					      mousebuttons_state:   evt::Mousebuttons_State,	# State of mouse buttons as a bool record, BEFORE THE EVENT -- so a MOUSEBUTTON_RLEASE will always show at least one button down.
					      event_point:	    g2d::Point,			# 'point'  is the click point the window's coordinate system.
					      site:		    g2d::Box,			# Widget's assigned area in window coordinates.
					      theme:		    pt::Packed_Theme		#
					    }							# Normally MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE are sent if they occur within the gadget's assigned site.
					    -> Void						# This can be restricted to a sub-area of the site using point_in_gadget -- src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
	      }


	#########################################################################################
	## Bounce_Sprite_Start_Fn

	also
	Bounce_Sprite_Start_Fn
	  =
	  BOUNCE_SPRITE_START_FN							# Needs to be a datatype (vs plain type) because of the recursive reference in endstate_oneshot.
	    (
	      { gadget_to_guiboss:	Gadget_To_Guiboss,				# 
		sprite_to_bouncespace:	s2b::Sprite_To_Bouncespace,			# 
		run_gun':		Run_Gun,					#
		end_gun':		End_Gun,					#
		endstate_oneshot:	Oneshot_Maildrop( ( Bounce_Sprite_Start_Fn, 	#
							    Null_Or(Exception)		# saved_sprite_state value used by arrowbutton etc to preserve state across gui stop/restart cycles.
							) ),
		saved_sprite_state:	Null_Or(Exception)				# When restarting a stopped gui this preserves the local state for (e.g.) arrowbutton.
	      }
	      ->
	      { guiboss_to_gadget:		Guiboss_To_Gadget,			# 
		bouncespace_to_sprite:	b2s::Bouncespace_To_Sprite			# 
	      }
	    )

	#########################################################################################
	## Canvas_Object_Start_Fn

	also
	Canvas_Object_Start_Fn
	  =
	  CANVAS_OBJECT_START_FN							# Needs to be a datatype (vs plain type) because of the recursive reference in endstate_oneshot.
	    (
	      { gadget_to_guiboss:	Gadget_To_Guiboss,				# 
		object_to_canvasspace:	o2c::Object_To_Canvasspace,			# 
		run_gun':		Run_Gun,					#
		end_gun':		End_Gun,					#
		endstate_oneshot:	Oneshot_Maildrop( ( Canvas_Object_Start_Fn,
							    Null_Or(Exception)		# saved_object_state value used by arrowbutton etc to preserve state across gui stop/restart cycles.
							) ),				#
		saved_object_state:	Null_Or(Exception)				# When restarting a stopped gui this preserves the local state for (e.g.) arrowbutton.
	      }
	      ->
	      { guiboss_to_gadget:		Guiboss_To_Gadget,			# 
		canvasspace_to_object:	c2o::Canvasspace_To_Object			# 
	      }
	    )

	#########################################################################################
	## Packed_Widget_Start_Fn

	also	
	Packed_Widget_Start_Fn								# This type is the critical interface between the widget world and src/lib/x-kit/widget/gui/guiboss-imp.pkg
	  =										# In particular stopped_gui__to__running_gui() in guiboss_imp calls the packed_widget_start_fn built in   src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg
	  PACKED_WIDGET_START_FN							# Needs to be a datatype (vs plain type) because of the recursive reference in endstate_oneshot.
	    (
	      { gadget_to_guiboss:	Gadget_To_Guiboss,				# 
		widget_to_packedspace:	w2p::Widget_To_Packedspace,			# 
		run_gun':		Run_Gun,					#
		end_gun':		End_Gun,					#
		endstate_oneshot:	Oneshot_Maildrop( ( Packed_Widget_Start_Fn,
							    Null_Or(Exception)		# saved_widget_state value used by arrowbutton etc to preserve state across gui stop/restart cycles.
							) ),				#
		saved_widget_state:	Null_Or(Exception)				# When restarting a stopped gui this preserves the local state for (e.g.) arrowbutton.
	      }										# arrowbutton				is from   src/lib/x-kit/widget/leaf/arrowbutton.pkg
	      ->
	      { guiboss_to_gadget:	Guiboss_To_Gadget,				# 
		packedspace_to_widget:	p2w::Packedspace_To_Widget			# 
	      }
	    );



	#########################################################################################
	## More guiboss-to-packedspace types types

	Packedspace_Arg =  List(Packedspace_Option);									# Currently no required component.



	#########################################################################################
	## More guiboss-to-canvasspace types types

	Canvasspace_Arg =  List(Canvasspace_Option);									# Currently no required component.



	#########################################################################################
	## More guiboss-to-bouncespace types types

	Bouncespace_Arg =  List(Bouncespace_Option);									# Currently no required component.


	#########################################################################################
	## More gui-plan types

	Gui_Plan =  (Packedspace_Arg,  Packed_Widget);



	#########################################################################################
	## More stopped-gui types

	Stopped_Gui =  (Packedspace_Arg,  Sg_Packed_Widget);


	#########################################################################################
	## Basic nonrecursive types

											# Can't define a Widget_Imports here because of the type recursion on endstate_oneshot.
	Widget_Exports
	  =
	  { guiboss_to_gadget:		Guiboss_To_Gadget,				# 
	    packedspace_to_widget:	p2w::Packedspace_To_Widget			# 
	  };




	Object_Exports
	  =
	  { guiboss_to_gadget:		Guiboss_To_Gadget,				# 
	    canvasspace_to_object:	c2o::Canvasspace_To_Object			# 
	  };





	Sprite_Exports
	  =
	  { guiboss_to_gadget:		Guiboss_To_Gadget,				# 
	    bouncespace_to_sprite:	b2s::Bouncespace_To_Sprite			# 
	  };






	#########################################################################################
	## More running-gui types

	Running_Gui =	      {	fire_end_gun:		Void -> Void,							# Calling this fn will cause all state and look imps in the gui to exit, saving their state to their oneshots.
				packedspace_id:		Packedspace_Id,							# guiboss-imp indexes this value into *packed_stuff to obtain (e.g.) a Guiboss_To_Packedspace port to the packedspace-imp.
				packed_widget:		Rg_Packed_Widget,						# The widget (or more commonly, tree of widgets) managed by the gui-tree's toplevel packedspace-imp.
				topwindow:		gws::Guiboss_To_Topwindow,					# The topwindow on which to draw our widgets.
				topwindow_pixmap:	s2g::Backing_Pixmap,						# Holds toplevel s2g::TOPWINDOW_PIXMAP for gui.
				next_stacking_order:	Ref(Int)							# Next space_to_gui::Backing_Pixmap.stacking_order value to issue.
			      };



	Row_Widget													# This is intended to match the ROW declaration above.
	  =														# We can't use this definition there because plain types cannot be mutually recursive.
	  { widget:	 	Rg_Packed_Widget,									#
	    cooked_hints:	Packed_Layout_Hints,									# Digested version of next
	    raw_hints:		List(plh::Packedspace_Layout_Hint)							# Layout hints provided by client code.
	  };														#

	Col_Widget													# This is intended to match the COL declaration above.
	  =														# We can't use this definition there because plain types cannot be mutually recursive.
	  { widget:		Rg_Packed_Widget,									#
	    cooked_hints:	Packed_Layout_Hints,									# Digested version of next
	    raw_hints:		List(plh::Packedspace_Layout_Hint)							# Layout hints provided by client code.
	  };														#

	Tabview														# Something visible in a Rg_Packed_Widget.TABBED_VIEWS.  It is convenient to have a name for this type.
	  =
	  { widget:		 Rg_Packed_Widget,									#
	    gadget_to_rw_pixmap: g2p::Gadget_To_Rw_Pixmap,
	    backing_pixmap:	 s2g::Backing_Pixmap									# 
	  }														#
	  ;

															# This section gives names to the implicit record types above used by ROW, COL ...
															# It really sucks that records cannot be included in recursive definitions.
	Row
	  =
	  {														# A horizontal row of packed widgets.
	    widgets:		List(											# The list of widgets to be laid out and displayed in this row.
					  { widget:	 	 Rg_Packed_Widget,					# One widget in the row. Note that it could be a COL or SCROLLABLE_VIEW or such containing multiple subwidgets.
					    raw_hints:	 	 List(plh::Packedspace_Layout_Hint),			# Layout hints provided by client code.
					    cooked_hints:	Packed_Layout_Hints					# Digested version of previous.
					  }										#
					),
	    pixels_high_min: 	Ref(Int),										# Minimum            vertical   pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    pixels_wide_min: 	Ref(Int),										# Minimum            horizontal pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    #
	    pixels_high_cut: 	Ref(Float),										# Share of remaining vertical   pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    pixels_wide_cut: 	Ref(Float),										# Share of remaining horizontal pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    #
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };

	Col
	  =
	  {														# A vertical column of packed widgets.
	    widgets:		List(											# The list of widgets to be laid out and displayed in this column.
					  { widget:		Rg_Packed_Widget,					# One widget in the column. Note that it could be a ROW or SCROLLABLE_VIEW or such containing multiple subwidgets.
					    raw_hints:	List(plh::Packedspace_Layout_Hint),				# Layout hints provided by client code.
					    cooked_hints:	Packed_Layout_Hints					# Digested version of next
					  }										#
					),
	    pixels_high_min: 	Ref(Int),										# Minimum            vertical   pixels to allocate for this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    pixels_wide_min: 	Ref(Int),										# Minimum            horizontal pixels to allocate for this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    #
	    pixels_high_cut: 	Ref(Float),										# Share of remaining vertical   pixels to allocate to  this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    pixels_wide_cut: 	Ref(Float),										# Share of remaining horizontal pixels to allocate to  this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    #
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };


	Scrollable_View
	  =
	  {														# Here we provide support for widgets visible through a scrollable viewport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
	    widget:			Rg_Packed_Widget,								# Tree of widgets partially visible in viewport.
	    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,							# This is the pixmap visible through the viewport. It holds a full image of above 'widget' tree.
	    view_origin:		Ref(g2d::Point),								# Origin of view's backing_pixmap in viewport coordinates, used for scrolling pixmap in viewport.
	    backing_pixmap:		s2g::Backing_Pixmap,								# This is the parent pixmap holding the viewport.
	    scroller:			Viewport_Scroller,
	    callback:			Viewport_Scroller_Callback,							# This is how we pass our Viewport_Scroller to app client code, which basically lets it set 'pixmap_origin' above.
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };

	Tabbed_Views
	  =
	  {														# Here we provide support for selection between alternate views in viewport.  Actually providing tabs happens at a higher level; here we handle pixmap state maintenance and redraw support.
	    pixmap_size:		g2d::Size,									# Size of alternate pixmaps visible in viewport.  We require them to all be the same size; we intend that the viewport be the same size.
	    widgets:		List(											# This record holds one of the alternate views which may be made visible in the viewport.  *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST! *** 
					  { widget:			Rg_Packed_Widget,				# Tree of widgets visible in this tab.
					    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,			# This pixmap holds the current visible state of the above widget-tree.
					    backing_pixmap:		s2g::Backing_Pixmap				# This is the parent pixmap holding the viewport through which we are visible (when we're visible).
					  }										# This record is type Tabview; we can't use that name here because records and datatypes cannot be mutually recursive.
					),
	    visible_widget:		Ref (										# Which of 'widgets' is currently visible?  This refcell holds one element from 'widgets';  it supports switching between the tabbed views.
					  { widget:			Rg_Packed_Widget,				#
					    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,			#
					    backing_pixmap:		s2g::Backing_Pixmap				# 
					  }										# This record is type Tabview; we can't use that name here because records and datatypes cannot be mutually recursive.
					),
	    callback:			Tabbed_View_Picker_Callback,							# This is how we pass our Tabbed_View_Picker to app client code, which basically lets it set 'visible_widget' above.
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };

	Widget
	  =
	  {														# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg
	    guiboss_to_gadget:		Guiboss_To_Gadget,								# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/gui/guiboss-imp.pkg
	    packedspace_to_widget:	p2w::Packedspace_To_Widget,							# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

	    endstate_oneshot:	Once( (											# The widget-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
					Packed_Widget_Start_Fn,							#
					Null_Or(Exception)								# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				    ) ),
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };

															# We'll eventually want canvas and bounce stuff here, but that isn't really operational yet.
	#########################################################################################
	## more guiboss-to-packedspace types

	#########################################################################################
	## packedspace-imp code

	fun pprint_packedspace_arg
	      (pp:		pp::Prettyprint_Mill)
	      (packedspace_arg:	Packedspace_Arg)
	    =
	    {
		packedspace_arg
		    ->
		    (
			options:	List(Packedspace_Option)
		    );

		pp.box {.
		    pp.txt "[ ";
		    pp::seq {. pp.txt ", "; }
			    pprint_option
			    options
			    ;	
		    pp.txt " ]";
		    pp.lit ")";
		};
	    }
	    where
		fun pprint_option option
		    =
		    case option
			#
			PS_MICROTHREAD_NAME name =>  {  pp.lit (sprintf "PS_MICROTHREAD_NAME \"%s\"" name);	};
			PS_ID               id	 =>  {  pp.lit (sprintf "PS_ID %d" (id_to_int id)         );	};
			PS_CALLBACK _		 =>  {  pp.lit          "PS_CALLBACK (callback)";		};
		    esac;
	    end;


	fun pprint_packedspace_layout_hint
	      #	
	      (pp:		pp::Prettyprint_Mill)
	      (layout_hint:	plh::Packedspace_Layout_Hint)
	    =
	    case layout_hint
		#
		plh::WIDGET_PIXELS_CUT f =>    pp.lit (sprintf  "WIDGET_PIXELS_CUT %f"  f);
		plh::WIDGET_PIXELS_MIN i =>    pp.lit (sprintf  "WIDGET_PIXESL_MIN %d"  i);
	    esac;





	#########################################################################################
	## canvasspace-imp code


	fun pprint_canvasspace_arg
	      (pp:			pp::Prettyprint_Mill)
	      (canvasspace_arg:	Canvasspace_Arg)
	    =
	    {
		canvasspace_arg
		    ->
		    (
			options:	List(Canvasspace_Option)
		    );

		pp.box {.
		    pp.txt "[ ";
		    pp::seq {. pp.txt ", "; }
			    pprint_option
			    options
			    ;	
		    pp.txt " ]";
		    pp.lit ")";
		};
	    }
	    where
		fun pprint_option option
		    =
		    case option
			#
			CS_MICROTHREAD_NAME	name	=>  {  pp.lit (sprintf "CS_MICROTHREAD_NAME \"%s\"" name);	};
			CS_ID			id	=>  {  pp.lit (sprintf "CS_ID %d" (id_to_int id)         );	};
			CS_CANVASSPACE_CALLBACK _	=>  {  pp.lit          "CS_CANVASSPACE_CALLBACK (callback)";	};
		    esac;
	    end;

	fun pprint_canvasspace_layout_hint
	      #	
	      (pp:		pp::Prettyprint_Mill)
	      (layout_hint:	clh::Canvasspace_Layout_Hint)
	    =
	    case layout_hint
		#
		clh::SHARE s =>    pp.lit (sprintf  "SHARE %g"  s);
	    esac;



	#########################################################################################
	## bouncespace-imp code

	fun pprint_bouncespace_arg
	      (pp:			pp::Prettyprint_Mill)
	      (bouncespace_arg:		Bouncespace_Arg)
	    =
	    {
		bouncespace_arg
		    ->
		    (
			options:	List(Bouncespace_Option)
		    );

		pp.box {.
		    pp.txt "[ ";
		    pp::seq {. pp.txt ", "; }
			    pprint_option
			    options
			    ;	
		    pp.txt " ]";
		    pp.lit ")";
		};
	    }
	    where
		fun pprint_option option
		    =
		    case option
			#
			OS_MICROTHREAD_NAME name	=>  {  pp.lit (sprintf "OS_MICROTHREAD_NAME \"%s\"" name);	};
			OS_ID               id		=>  {  pp.lit (sprintf "OS_ID %d" (id_to_int id)          );	};
			OS_BOUNCESPACE_CALLBACK _	=>  {  pp.lit          "OS_BOUNCESPACE_CALLBACK (callback)";	};
		    esac;
	    end;


	fun pprint_bouncespace_layout_hint
	      #	
	      (pp:		pp::Prettyprint_Mill)
	      (layout_hint:	blh::Bouncespace_Layout_Hint)
	    =
	    case layout_hint
		#
		blh::SHARE s =>    pp.lit (sprintf  "SHARE %g"  s);
	    esac;


	#########################################################################################
	## gui-plan code

	fun pprint_gui_plan (gui_plan: Gui_Plan)							# "pprint" == "prettyprint".
	    =
	    pp::with_standard_prettyprint_mill
		#
		(err::default_plaint_sink ())	[]
		#
		(\\ pp:   pp::Prettyprint_Mill
		    =
		    do_gui_plan  gui_plan
		    where
			fun do_gui_plan  gui_plan
			    =
			    do_packedspace  gui_plan

			also
			fun do_packedspace
			      ( packedspace_arg:	Packedspace_Arg,
				packed_widget:		Packed_Widget
			      )
			    =
			    {   pp.box {.
				    do_packedspace_arg  packedspace_arg;
				    do_packed_widget     packed_widget;
				};
				pp.newline();
			    }

			also
			fun do_bouncespace
			      (
				bouncespace_arg:	Bouncespace_Arg,
				bounce_widgets:		List(  (List(blh::Bouncespace_Layout_Hint), Bounce_Widget)  )
			      )
			    =
			    {   pp.box {.
				    do_bouncespace_arg  bouncespace_arg;
				    do_bounce_widgets    bounce_widgets;
				};
				pp.newline();
			    }

			also
			fun do_bouncespace_arg  (bouncespace_arg:	Bouncespace_Arg)
			    =
			    {
				pprint_bouncespace_arg  pp  bouncespace_arg;
				pp.newline();
			    }


			also
			fun do_bouncespace_layout_hints  (layout_hints: List(blh::Bouncespace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  blh::Bouncespace_Layout_Hint)
				    =
				    pprint_bouncespace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_bounce_widgets  (bounce_widgets:		List(  (List(blh::Bouncespace_Layout_Hint), Bounce_Widget)  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";

				    fun do_widget (layout_hints: List(blh::Bouncespace_Layout_Hint),  bounce_widget: Bounce_Widget)
					=
					pp.box {.
					    do_bounce_widget			bounce_widget;
					    pp.endlit ",";
					    pp.txt " ";
					    do_bouncespace_layout_hints	 layout_hints;
					};

				    pp::seq
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					bounce_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_bounce_widget  (bounce_widget:	Bounce_Widget)
			    =
			    case bounce_widget
				#
				SPRITE _
				    =>
				    {
					pp.box {.
					    pp.lit  "SPRITE _";
					};
					pp.newline();
				    };
			    esac

			also
			fun do_canvasspace
			      (
				canvasspace_arg:	Canvasspace_Arg,
				canvas_widgets:		List(  (List(clh::Canvasspace_Layout_Hint), Canvas_Widget)  )
			      )
			    =
			    {   pp.box {.
				    do_canvasspace_arg  canvasspace_arg;
				    do_canvas_widgets    canvas_widgets;
				};
				pp.newline();
			    }

			also
			fun do_canvasspace_arg  (canvasspace_arg:	Canvasspace_Arg)
			    =
			    {
				pprint_canvasspace_arg  pp  canvasspace_arg;
				pp.newline();
			    }

			also
			fun do_canvasspace_layout_hints  (layout_hints: List(clh::Canvasspace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  clh::Canvasspace_Layout_Hint)
				    =
				    pprint_canvasspace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_canvas_widgets  (canvas_widgets:		List(  (List(clh::Canvasspace_Layout_Hint),  Canvas_Widget)  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";


				    fun do_widget (layout_hints: List(clh::Canvasspace_Layout_Hint),  canvas_widget: Canvas_Widget)
					=
					pp.box {.
					    do_canvas_widget			canvas_widget;
					    pp.endlit ",";
					    pp.txt " ";
					    do_canvasspace_layout_hints	layout_hints;
					};

				    pp::seq
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					canvas_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_canvas_widget  (canvas_widget:	Canvas_Widget)
			    =
			    case canvas_widget
				#
				OBJECT _
				    =>
				    {
					pp.box {.
					    pp.lit  "OBJECT _";
					};
					pp.newline();
				    };

			        PACKEDSPACE  packedspace
				    =>
				    {
					pp.lit  "PACKEDSPACE ";
					pp.newline();
					do_packedspace packedspace;
					pp.newline();
				    };
			    esac

			also
			fun do_packedspace_arg  (packedspace_arg:	Packedspace_Arg)
			    =
			    {
				pprint_packedspace_arg  pp  packedspace_arg;
				pp.newline();
			    }

			also
			fun do_packedspace_layout_hints  (layout_hints: List(plh::Packedspace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  plh::Packedspace_Layout_Hint)
				    =
				    pprint_packedspace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_packed_widget  (packed_widget:	Packed_Widget)
			    =
			    case packed_widget
				#
			        ROW	(widgets:	 List( (List(plh::Packedspace_Layout_Hint), Packed_Widget) ))
				    =>
				    {
					pp.box' 0 -1 {.
					    pp.lit  "ROW [";
					    pp.ind 2;
					    pp.txt " ";

					    fun do_widget (layout_hints: List(plh::Packedspace_Layout_Hint), packed_widget: Packed_Widget)
						=
						pp.box {.
						    do_packed_widget			packed_widget;
						    pp.endlit ",";
						    pp.txt " ";
						    do_packedspace_layout_hints	layout_hints;
						};

					    pp::seq
						{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
						do_widget				# Print one list element.
						widgets;				# List of elements.

					    pp.ind 0;
					    pp.txt " ";
					    pp.lit "]";
					};
				    };

			        COL	(a:	 List( (List(plh::Packedspace_Layout_Hint), Packed_Widget) ))
				    =>
				    {
					pp.lit  "COL";
					pp.newline();
				    };

				SCROLLABLE_VIEW _
				    =>
				    {
					pp.box {.
					    pp.lit  "SCROLLABLE_VIEW _";
					};
					pp.newline();
				    };

				TABBED_VIEWS _
				    =>
				    {
					pp.box {.
					    pp.lit  "TABBED_VIEWS _";
					};
					pp.newline();
				    };

				WIDGET _
				    =>
				    {
					pp.box {.
					    pp.lit  "WIDGET _";
					};
					pp.newline();
				    };

			        CANVASSPACE (canvasspace:	(Canvasspace_Arg,  List((List(clh::Canvasspace_Layout_Hint), Canvas_Widget))))
				    =>
				    {
					pp.lit  "CANVASSPACE";
					do_canvasspace  canvasspace;
					pp.newline();
				    };

			        BOUNCESPACE (bouncespace:	(Bouncespace_Arg,  List((List(blh::Bouncespace_Layout_Hint), Bounce_Widget))))
				    =>
				    {
					pp.lit  "BOUNCESPACE";
					do_bouncespace  bouncespace;
					pp.newline();
				    };
			      
			        NULL_PACKED_WIDGET
				    =>
				    {
					pp.lit  "NULL_PACKED_WIDGET";
					pp.newline();
				    };
			    esac;
		    end
		);

	#########################################################################################
	## stopped-gui code

	fun pprint_stopped_gui (stopped_gui: Stopped_Gui)								# "pprint" == "prettyprint".
	    =
	    pp::with_standard_prettyprint_mill
		#
		(err::default_plaint_sink ())	[]
		#
		(\\ pp:   pp::Prettyprint_Mill
		    =
		    do_stopped_gui  stopped_gui
		    where
			fun do_stopped_gui  stopped_gui
			    =
			    do_packedspace  stopped_gui

			also
			fun do_packedspace
			      ( packedspace_arg:	Packedspace_Arg,
				packed_widget:		Sg_Packed_Widget
			      )
			    =
			    {   pp.box {.
				    do_packedspace_arg  packedspace_arg;
				    do_packed_widget     packed_widget;
				};
				pp.newline();
			    }

			also
			fun do_bouncespace
			      (
				bouncespace_arg:	Bouncespace_Arg,
				bounce_widgets:		List(  (List(blh::Bouncespace_Layout_Hint),  Sg_Bounce_Widget)  )
			      )
			    =
			    {   pp.box {.
				    do_bouncespace_arg  bouncespace_arg;
				    do_bounce_widgets    bounce_widgets;
				};
				pp.newline();
			    }

			also
			fun do_bouncespace_arg  (bouncespace_arg:	Bouncespace_Arg)
			    =
			    {
				pprint_bouncespace_arg  pp  bouncespace_arg;
				pp.newline();
			    }


			also
			fun do_bouncespace_layout_hints  (layout_hints: List(blh::Bouncespace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  blh::Bouncespace_Layout_Hint)
				    =
				    pprint_bouncespace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_bounce_widgets  (bounce_widgets:		List(  (List(blh::Bouncespace_Layout_Hint),  Sg_Bounce_Widget)  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";

				    fun do_widget (layout_hints: List(blh::Bouncespace_Layout_Hint),  bounce_widget: Sg_Bounce_Widget)
					=
					pp.box {.
					    do_bounce_widget			bounce_widget;
					    pp.endlit ",";
					    pp.txt " ";
					    do_bouncespace_layout_hints	layout_hints;
					};

				    pp::seq
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					bounce_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_bounce_widget  (bounce_widget:	Sg_Bounce_Widget)
			    =
			    case bounce_widget
				#
			        SG_SPRITE ( fn:			Bounce_Sprite_Start_Fn,
					    saved_sprite_state:	Null_Or(Exception)
					  )
				    =>
				    {
					pp.box {.
					    pp.lit  "SPRITE _";
					};
					pp.newline();
				    };

# 			        SG_BALL	( ball_arg:		c2b::Make_Arg,
# 					  ball_look_arg:	bli::Bounce_Look_Arg
# 					)
# 				    =>
# 				    {
# 					pp.box {.
# 					    pp.lit  "BALL (";		pp.txt " ";
# 					    bsi::pprint_make_arg  pp  ball_arg;
# 					    pp.txt ", ";
# 					    blx::pprint_bounce_look_arg  pp  ball_look_arg;
# 					    pp.lit  ")";
# 					};
# 					pp.newline();
# 				    };
			    esac

			also
			fun do_canvasspace
			      (
				canvasspace_arg:	Canvasspace_Arg,
				canvas_widgets:		List(  (List(clh::Canvasspace_Layout_Hint),  Sg_Canvas_Widget)  )
			      )
			    =
			    {   pp.box {.
				    do_canvasspace_arg  canvasspace_arg;
				    do_canvas_widgets    canvas_widgets;
				};
				pp.newline();
			    }

			also
			fun do_canvasspace_arg  (canvasspace_arg:	Canvasspace_Arg)
			    =
			    {
				pprint_canvasspace_arg  pp  canvasspace_arg;
				pp.newline();
			    }

			also
			fun do_canvasspace_layout_hints  (layout_hints: List(clh::Canvasspace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  clh::Canvasspace_Layout_Hint)
				    =
				    pprint_canvasspace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_canvas_widgets  (canvas_widgets:		List(  (List(clh::Canvasspace_Layout_Hint),  Sg_Canvas_Widget)  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";


				    fun do_widget (layout_hints: List(clh::Canvasspace_Layout_Hint),  canvas_widget: Sg_Canvas_Widget)
					=
					pp.box {.
					    do_canvas_widget			canvas_widget;
					    pp.endlit ",";
					    pp.txt " ";
					    do_canvasspace_layout_hints	layout_hints;
					};

				    pp::seq
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					canvas_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_canvas_widget  (canvas_widget:	Sg_Canvas_Widget)
			    =
			    case canvas_widget
				#
				SG_OBJECT ( fn:			Canvas_Object_Start_Fn,
					    saved_object_state:	Null_Or(Exception)
					  )
				    =>
				    {
					pp.box {.
					    pp.lit  "SG_OBJECT _";
					};
					pp.newline();
				    };

			        SG_PACKEDSPACE  packedspace
				    =>
				    {
					pp.lit  "SG_PACKEDSPACE ";
					pp.newline();
					do_packedspace packedspace;
					pp.newline();
				    };
			    esac

			also
			fun do_packedspace_arg  (packedspace_arg:	Packedspace_Arg)
			    =
			    {
				pprint_packedspace_arg  pp  packedspace_arg;
				pp.newline();
			    }

			also
			fun do_packedspace_layout_hints  (layout_hints: List(plh::Packedspace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  plh::Packedspace_Layout_Hint)
				    =
				    pprint_packedspace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_packed_widget  (packed_widget:	Sg_Packed_Widget)
			    =
			    case packed_widget
				#
			        SG_ROW	(widgets:	 List( (List(plh::Packedspace_Layout_Hint), Sg_Packed_Widget) ))
				    =>
				    {
					pp.box' 0 -1 {.
					    pp.lit  "Sg_ROW [";
					    pp.ind 2;
					    pp.txt " ";

					    fun do_widget (layout_hints: List(plh::Packedspace_Layout_Hint), packed_widget: Sg_Packed_Widget)
						=
						pp.box {.
						    do_packed_widget			packed_widget;
						    pp.endlit ",";
						    pp.txt " ";
						    do_packedspace_layout_hints	layout_hints;
						};

					    pp::seq
						{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
						do_widget				# Print one list element.
						widgets;				# List of elements.

					    pp.ind 0;
					    pp.txt " ";
					    pp.lit "]";
					};
				    };

			        SG_COL	(a:	 List( (List(plh::Packedspace_Layout_Hint), Sg_Packed_Widget) ))
				    =>
				    {
					pp.lit  "SG_COL";
					pp.newline();
				    };

			        SG_SCROLLABLE_VIEW (a:	(Viewport_Scroller_Callback, g2d::Size, Sg_Packed_Widget) )
				    =>
				    {
					pp.lit  "SG_SCROLLABLE_VIEW";
					pp.newline();
				    };

			        SG_TABBED_VIEWS (a:	(Tabbed_View_Picker_Callback,  g2d::Size,  List( Sg_Packed_Widget)))
				    =>
				    {
					pp.lit  "SG_TABBED_VIEWS";
					pp.newline();
				    };

			        SG_WIDGET ( fn:			Packed_Widget_Start_Fn,
					    saved_widget_state:	Null_Or(Exception)
					  )
				    =>
				    {
					pp.box {.
					    pp.lit  "SG_WIDGET _";
					};
					pp.newline();
				    };


			        SG_CANVASSPACE (canvasspace:	(Canvasspace_Arg,  List((List(clh::Canvasspace_Layout_Hint), Sg_Canvas_Widget))))
				    =>
				    {
					pp.lit  "SG_CANVASSPACE";
					do_canvasspace  canvasspace;
					pp.newline();
				    };

			        SG_BOUNCESPACE (bouncespace:	(Bouncespace_Arg,  List((List(blh::Bouncespace_Layout_Hint), Sg_Bounce_Widget))))
				    =>
				    {
					pp.lit  "SG_BOUNCESPACE";
					do_bouncespace  bouncespace;
					pp.newline();
				    };
			      
			        SG_NULL_PACKED_WIDGET
				    =>
				    {
					pp.lit  "SG_NULL_PACKED_WIDGET";
					pp.newline();
				    };
			    esac;
		    end
		);



	#########################################################################################
	## running-gui code

	fun packed_widget_site (packed_widget: Rg_Packed_Widget)
	    =
	    case packed_widget
		#
		RG_ROW r		=>  *r.site;
		RG_COL r		=>  *r.site;
		RG_SCROLLABLE_VIEW r	=>  *r.site;
		RG_TABBED_VIEWS r	=>  *r.site;
		RG_WIDGET r		=>  *r.site;
		RG_CANVASSPACE r	=>  *r.site;
		RG_BOUNCESPACE r	=>  *r.site;
		RG_NULL_PACKED_WIDGET	=>  g2d::box::zero;
	    esac;


	Running_Gui_Postorder_Apply_Option										# The following running_gui_postorder_apply() facility allows clients to iterate over nodes in a Running_Gui tree without having to write out the whole recursion.
	  #
	  = ROW_FN		(Row		 -> Void)								# Call this fn on ROW             nodes in Running_Gui. Defaults to null fn.
	  | COL_FN		(Col		 -> Void)								# Call this fn on COL             nodes in Running_Gui. Defaults to null fn.
	  | SCROLLABLE_VIEW_FN	(Scrollable_View -> Void)								# Call this fn on SCROLLABLE_VIEW nodes in Running_Gui. Defaults to null fn.
	  | TABBED_VIEWS_FN	(Tabbed_Views	 -> Void)								# Call this fn on TABBED_VIEWS    nodes in Running_Gui. Defaults to null fn.
	  | WIDGET_FN		(Widget		 -> Void)								# Call this fn on WIDGET          nodes in Running_Gui. Defaults to null fn.
	  | DO_INVISIBLE_VIEWS  Bool											# Defaults to TRUE.  If FALSE, recursion will not enter de-selected views in a TABBED_VIEWS node.
	  ;

	fun running_gui_postorder_apply
	      (
		running_gui:	Running_Gui,
		options:	List( Running_Gui_Postorder_Apply_Option )
	      )
	    =
	    do_packed_widget  running_gui.packed_widget
	    where

		fun process_options  (options:  List(Running_Gui_Postorder_Apply_Option))
		    =
		    {   null_fn = (\\ (x: X) = ());
			#
			my_row_fn			=  REF  null_fn;
			my_col_fn			=  REF  null_fn;
			my_scrollable_view_fn		=  REF  null_fn;
			my_tabbed_views_fn		=  REF  null_fn;
			my_widget_fn			=  REF  null_fn;
			my_do_invisible_views		=  REF  TRUE;

			apply  do_option  options
			where
			    fun do_option (ROW_FN			fn) =>  my_row_fn			:=  fn;
				do_option (COL_FN			fn) =>  my_col_fn			:=  fn;
				do_option (SCROLLABLE_VIEW_FN		fn) =>  my_scrollable_view_fn		:=  fn;
				do_option (TABBED_VIEWS_FN		fn) =>  my_tabbed_views_fn		:=  fn;
				do_option (WIDGET_FN			fn) =>  my_widget_fn			:=  fn;
				do_option (DO_INVISIBLE_VIEWS		b ) =>  my_do_invisible_views		:=  b ;
			    end;
			end;

			{ row_fn			=>  *my_row_fn,
			  col_fn			=>  *my_col_fn,
			  scrollable_view_fn		=>  *my_scrollable_view_fn,
			  tabbed_views_fn		=>  *my_tabbed_views_fn,
			  widget_fn			=>  *my_widget_fn,
			  do_invisible_views		=>  *my_do_invisible_views
			};
		    };

		options =  process_options  options;

		fun do_packed_widget (packed_widget: Rg_Packed_Widget)
		    =
		    case packed_widget
			#
			RG_ROW row =>	{   apply do_widget row.widgets
						where
						    fun do_widget (row_widget: Row_Widget)
							=
							do_packed_widget row_widget.widget;
						end;

					    options.row_fn row;
					};

			RG_COL col =>	{   apply do_widget col.widgets
						where
						    fun do_widget (col_widget: Col_Widget)
							=
							do_packed_widget col_widget.widget;
						end;

					    options.col_fn  col;
					};

			RG_SCROLLABLE_VIEW view
			    =>		{   do_packed_widget  view.widget;
					    #
					    options.scrollable_view_fn  view;
					};

			RG_TABBED_VIEWS views
			    =>		{   fun do_tabview (tabview: Tabview)
						=
						do_packed_widget tabview.widget;

					    if options.do_invisible_views
						#
						apply do_tabview views.widgets;
					    else
						do_tabview *views.visible_widget;
					    fi;

					    options.tabbed_views_fn views;
					};

			RG_WIDGET widget
			    =>		{   options.widget_fn widget;
					};

			RG_CANVASSPACE space
			    =>		{   ();											# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
					};
			RG_BOUNCESPACE space
			    =>		{   ();											# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
					};
			RG_NULL_PACKED_WIDGET
			    =>		{   ();
					};
		    esac;
	    end;


    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.

