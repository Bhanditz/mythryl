## guiboss-types.pkg
#
# Interface types for   src/lib/x-kit/widget/gui/guiboss-imp.pkg
#
# We use three representations for a GUI with transition diagram
#
#     Gui_Plan
#         |
#         v
#     Stopped_Gui
#       |   ^
#       v   |
#     Running_Gui
#
# The application programmers passes guiboss_imp a Gui_Plan
# to define the GUI, which is then converted to a Stopped_Gui
# and at GUI startup time to a Running_Gui.
#     We support pausing and later restarting the GUI by a
# process of converting the Running_Gui back to a Stopped_Gui
# and at restart the Stopped_Gui again to a Running_Gui.
#
# In addition to defining the three GUI representations, this
# file defines most (but not all) of the major ports between
# guiboss_imp and other imps:								# "gadget" refers to any of "widget", "sprite" or "object".  (Most frequently, "widget".)
#
#	guiboss_to_gadget								# The general guiboss_imp -> gadget interface, used for forwarding user mouseclicks etc.  Most frequently used guiboss_imp -> widget_imp, but also to sprite_imp and object_imp.
#	gadget_to_guiboss								# The general gadget -> guiboss_imp interface, used for forwarding draw operations  etc.
#	guiboss_to_packedspace								# The guiboss_imp -> packedspace_imp, used to manage layout of widgets on windows.
#	guiboss-to-canvasspace.pkg							# The guiboss_imp -> canvasspace_imp, used to manage layout of objects on windows.
#	guiboss-to-bouncespace.pkg							# The guiboss_imp -> bouncespace_imp, used to manage layout of sprites on windows.
#     

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;							# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package g2d =  geometry2d;								# geometry2d				is from   src/lib/std/2d/geometry2d.pkg

    package w2g =  gadget_to_guiboss;							# gadget_to_guiboss			is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
    package b2g =  guiboss_to_gadget;							# guiboss_to_gadget			is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg

    package w2p =  widget_to_packedspace;						# widget_to_packedspace			is from   src/lib/x-kit/widget/space/packed/widget-to-packedspace.pkg   
    package p2w =  packedspace_to_widget;						# packedspace_to_widget			is from   src/lib/x-kit/widget/space/packed/packedspace-to-widget.pkg

    package o2c =  object_to_canvasspace;						# object_to_canvasspace			is from   src/lib/x-kit/widget/space/canvas/object-to-canvasspace.pkg   
    package c2o =  canvasspace_to_object;						# canvasspace_to_object			is from   src/lib/x-kit/widget/space/canvas/canvasspace-to-object.pkg

    package s2b =  sprite_to_bouncespace;						# sprite_to_bouncespace			is from   src/lib/x-kit/widget/space/bounce/sprite-to-bouncespace.pkg   
    package b2s =  bouncespace_to_sprite;						# bouncespace_to_sprite			is from   src/lib/x-kit/widget/space/bounce/bouncespace-to-sprite.pkg

    package g2p =  gadget_to_pixmap;							# gadget_to_pixmap			is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg
    package s2g =  space_to_gui;							# space_to_gui				is from   src/lib/x-kit/widget/gui/space-to-gui.pkg

    package gws =  guiboss_to_windowsystem;						# guiboss_to_windowsystem		is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg

    package os  =  guiboss_to_bouncespace;						# guiboss_to_bouncespace		is from   src/lib/x-kit/widget/space/bounce/guiboss-to-bouncespace.pkg
    package osi =  bouncespace_imp;							# bouncespace_imp			is from   src/lib/x-kit/widget/space/bounce/bouncespace-imp.pkg

    package cs  =  guiboss_to_canvasspace;						# guiboss_to_canvasspace		is from   src/lib/x-kit/widget/space/canvas/guiboss-to-canvasspace.pkg
    package csi =  canvasspace_imp;							# canvasspace_imp			is from   src/lib/x-kit/widget/space/canvas/canvasspace-imp.pkg

    package pp  =  standard_prettyprint_mill;						# standard_prettyprint_mill		is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg

    package blh =  bouncespace_layout_hint;						# bouncespace_layout_hint		is from   src/lib/x-kit/widget/space/bounce/bouncespace-layout-hint.pkg
    package clh =  canvasspace_layout_hint;						# canvasspace_layout_hint		is from   src/lib/x-kit/widget/space/canvas/canvasspace-layout-hint.pkg
    package plh =  packedspace_layout_hint;						# packedspace_layout_hint		is from   src/lib/x-kit/widget/space/packed/packedspace-layout-hint.pkg

#   package xt  =  xtypes;								# xtypes				is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
#   package r8  =  rgb8;								# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
#   package xtr =  xlogger;								# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package err =  error_message;							# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg



    # These imps need to be passed Running_Gui instances,
    # so referring directly to them here would create
    # circular package dependencies:
    #
#   package os  =  guiboss_to_bouncespace;			# guiboss_to_bouncespace	is from   src/lib/x-kit/widget/space/bounce/guiboss-to-bouncespace.pkg
#   package cs  =  guiboss_to_canvasspace;			# guiboss_to_canvasspace	is from   src/lib/x-kit/widget/space/canvas/guiboss-to-canvasspace.pkg
#   package ps  =  guiboss_to_packedspace;			# guiboss_to_packedspace	is from   src/lib/x-kit/widget/space/packed/guiboss-to-packedspace.pkg
    

    # Some abbreviations because line length was getting out of hand below:
    #
    Bs_Layout =  blh::Bouncespace_Layout_Hint;
    Cs_Layout =  clh::Canvasspace_Layout_Hint;
    Ps_Layout =  plh::Packedspace_Layout_Hint; 
    #
    Once(X) = Oneshot_Maildrop(X);


herein

    package guiboss_types
    {


	#########################################################################################
	## Basic nonrecursive types

											# Can't define a Widget_Imports here because of the type recursion on endstate_oneshot.
	Widget_Exports
	  =
	  { guiboss_to_gadget:		b2g::Guiboss_To_Gadget,				# 
	    packedspace_to_widget:	p2w::Packedspace_To_Widget			# 
	  };

	Packed_Widget_Start_Fn								# This type is the critical interface between the widget world and src/lib/x-kit/widget/gui/guiboss-imp.pkg
	  =										# In particular stopped_gui__to__running_gui() in guiboss_imp calls the packed_widget_start_fn built in   src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg
	  PACKED_WIDGET_START_FN							# Needs to be a datatype (vs plain type) because of the recursive reference in endstate_oneshot.
	    (
	      { gadget_to_guiboss:	w2g::Gadget_To_Guiboss,				# 
		widget_to_packedspace:	w2p::Widget_To_Packedspace,			# 
		run_gun':		Run_Gun,					#
		end_gun':		End_Gun,					#
		endstate_oneshot:	Oneshot_Maildrop( ( Packed_Widget_Start_Fn,
							    Null_Or(Exception)		# saved_widget_state value used by arrowbutton etc to preserve state across gui stop/restart cycles.
							) ),				#
		saved_widget_state:	Null_Or(Exception)				# When restarting a stopped gui this preserves the local state for (e.g.) arrowbutton.
	      }										# arrowbutton				is from   src/lib/x-kit/widget/leaf/arrowbutton.pkg
	      ->
	      Widget_Exports	
	    );




	Object_Exports
	  =
	  { guiboss_to_gadget:		b2g::Guiboss_To_Gadget,				# 
	    canvasspace_to_object:	c2o::Canvasspace_To_Object			# 
	  };

	Canvas_Object_Start_Fn
	  =
	  CANVAS_OBJECT_START_FN							# Needs to be a datatype (vs plain type) because of the recursive reference in endstate_oneshot.
	    (
	      { gadget_to_guiboss:	w2g::Gadget_To_Guiboss,				# 
		object_to_canvasspace:	o2c::Object_To_Canvasspace,			# 
		run_gun':		Run_Gun,					#
		end_gun':		End_Gun,					#
		endstate_oneshot:	Oneshot_Maildrop( ( Canvas_Object_Start_Fn,
							    Null_Or(Exception)		# saved_object_state value used by arrowbutton etc to preserve state across gui stop/restart cycles.
							) ),				#
		saved_object_state:	Null_Or(Exception)				# When restarting a stopped gui this preserves the local state for (e.g.) arrowbutton.
	      }
	      ->
	      Object_Exports	
	    );





	Sprite_Exports
	  =
	  { guiboss_to_gadget:		b2g::Guiboss_To_Gadget,				# 
	    bouncespace_to_sprite:	b2s::Bouncespace_To_Sprite			# 
	  };

	Bounce_Sprite_Start_Fn
	  =
	  BOUNCE_SPRITE_START_FN							# Needs to be a datatype (vs plain type) because of the recursive reference in endstate_oneshot.
	    (
	      { gadget_to_guiboss:	w2g::Gadget_To_Guiboss,				# 
		sprite_to_bouncespace:	s2b::Sprite_To_Bouncespace,			# 
		run_gun':		Run_Gun,					#
		end_gun':		End_Gun,					#
		endstate_oneshot:	Oneshot_Maildrop( ( Bounce_Sprite_Start_Fn, 	#
							    Null_Or(Exception)		# saved_sprite_state value used by arrowbutton etc to preserve state across gui stop/restart cycles.
							) ),
		saved_sprite_state:	Null_Or(Exception)				# When restarting a stopped gui this preserves the local state for (e.g.) arrowbutton.
	      }
	      ->
	      Sprite_Exports	
	    );


	Viewport_Scroller
	  =
	  { get_viewport_origin: Void -> g2d::Point,
	    set_viewport_origin: g2d::Point -> Void
	  };

	Viewport_Scroller_Callback							# Used in Packed_Widget.VIEWPORT	in   src/lib/x-kit/widget/gui/running-gui.pkg
	  =
	  Null_Or( Viewport_Scroller ) -> Void;


	Tabbed_View_Picker
	  =
	  { get_active_view: Void -> Int,
	    set_active_view: Int -> Void
	  };

	Tabbed_View_Picker_Callback							# Used in Packed_Widget.TABBED_VIEWS	in   src/lib/x-kit/widget/gui/running-gui.pkg
	  =
	  Null_Or( Tabbed_View_Picker ) -> Void;



	#########################################################################################
	## preliminary guiboss-to-packedspace types


	#########################################################################################
	## Preliminary running-gui types

	# Storing instances of
	#     os::guiboss_to_bouncespace, 
	#     cs::guiboss_to_canvasspace, 
	# or  guiboss_to_packedspace
	# directly in Running_Gui leads to package circularity,
	# so instead we store their integer id here, and
	# in guiboss-imp.pkg look them up as needed in
	# (respectively):	
	#     bouncespaces
	#     canvasspaces
	#     packedspaces
	# 
	Bouncespace_Id = Id;
	Canvasspace_Id = Id;
	Packedspace_Id = Id;

	Packed_Layout_Hints												# Predigested form of   List( plh::Packedspace_Layout_Hint ); 
	  =
	  { cut:	Null_Or(Float),											# Controls this widget's share of available pixels. We force this to be positive. Default is 1.0 if not specified.
	    min:	Null_Or(Int)
	  };



	#########################################################################################
	## gui-plan datatypes

	Bounce_Widget
	    #
	    = SPRITE		Bounce_Sprite_Start_Fn

	also
	Canvas_Widget
	    #
	    = PACKEDSPACE	(List(Packedspace_Option),  Packed_Widget)
	    #
	    | OBJECT		Canvas_Object_Start_Fn

	also
	Packed_Widget
	    #
	    = ROW		 List( (List(plh::Packedspace_Layout_Hint), Packed_Widget) )
	    | COL		 List( (List(plh::Packedspace_Layout_Hint), Packed_Widget) )
	    #	
	    | SCROLLABLE_VIEW    (
				   Viewport_Scroller_Callback,								# Callback for registering scroller with client app code.
				   g2d::Size,										# Size of pixmap visible through viewport.
				   Packed_Widget									# There will be one pixmap per List entry. (In general they will be the roots of widget-trees.)
				 )											# 
	    | TABBED_VIEWS	 ( Tabbed_View_Picker_Callback,
				   g2d::Size,										# Size of pixmap visible through viewport.
				   List( Packed_Widget )								# *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST ***
				 )											# There will be one pixmap per List entry. (In general they will be the roots of widget-trees.)
				 											# Only one will be visible at a given time.

	    | WIDGET		Packed_Widget_Start_Fn									# These values are created by   make_packed_widget_start_fn   in   src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg 
	    #
	    | CANVASSPACE	(cs::Canvasspace_Arg,  List((List(clh::Canvasspace_Layout_Hint), Canvas_Widget)))
	    | BOUNCESPACE	(os::Bouncespace_Arg,  List((List(blh::Bouncespace_Layout_Hint), Bounce_Widget)))
	    #
	    | NULL_PACKED_WIDGET									# Note[1]


	#########################################################################################
	## stopped-gui datatypes

	also
	Sg_Bounce_Widget												# Nomenclature: "Sg_" == "Stopped_Gui_";  "SG_" == "STOPPED_GUI_".
	    #
	    = SG_SPRITE		( Bounce_Sprite_Start_Fn,
				  Null_Or(Exception)									# saved_sprite_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				)
	also
	Sg_Canvas_Widget
	    #
	    = SG_PACKEDSPACE	(List(Packedspace_Option),  Sg_Packed_Widget)
	    #
	    | SG_OBJECT		( Canvas_Object_Start_Fn,
				  Null_Or(Exception)									# saved_object_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				)
	also
	Sg_Packed_Widget
	    #
	    = SG_ROW		 List( (List(plh::Packedspace_Layout_Hint), Sg_Packed_Widget) )
	    | SG_COL		 List( (List(plh::Packedspace_Layout_Hint), Sg_Packed_Widget) )
	    #	
 	    | SG_SCROLLABLE_VIEW ( Viewport_Scroller_Callback,								# Callback for registering scroller with client app code.
				   g2d::Size,
				   Sg_Packed_Widget									# 
				 )
 	    | SG_TABBED_VIEWS	 ( Tabbed_View_Picker_Callback,
				   g2d::Size,
				   List(Sg_Packed_Widget)								# 
				 )
	    #
	    | SG_WIDGET		( Packed_Widget_Start_Fn,
				  Null_Or(Exception)									# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				)
	    #
	    | SG_CANVASSPACE	(cs::Canvasspace_Arg,  List((List(clh::Canvasspace_Layout_Hint), Sg_Canvas_Widget)))
	    | SG_BOUNCESPACE	(os::Bouncespace_Arg,  List((List(blh::Bouncespace_Layout_Hint), Sg_Bounce_Widget)))
	    #
	    | SG_NULL_PACKED_WIDGET											# Note[1]


	#########################################################################################
	## running-gui datatypes

	also
	Rg_Bounce_Widget												# Nomenclature: "Rg_" == "Running_Gui_",  "RG_" == "RUNNING_GUI_".  
	    #
	    = RG_SPRITE	      {
				bouncespace_to_sprite:	b2s::Bouncespace_To_Sprite,					# 
				guiboss_to_gadget:	b2g::Guiboss_To_Gadget,						# 

				endstate_oneshot:	Once( ( 							# The sprite-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
								Bounce_Sprite_Start_Fn,					# 
								Null_Or(Exception)					# saved_sprite_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							    ) )	
			      }
			
	also
	Rg_Canvas_Widget
	    #
	    = RG_PACKEDSPACE  {	packedspace_id:		Packedspace_Id,							# A packed space embedded in a canvas, to allow all packedspace widgets to be used also on a canvas.
				packed_widget:		Rg_Packed_Widget
			      }
	    | RG_OBJECT	      {
				canvasspace_to_object:	c2o::Canvasspace_To_Object,					# 
				guiboss_to_gadget:	b2g::Guiboss_To_Gadget,						# 

				endstate_oneshot:	Once( (								# The sprite-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
								Canvas_Object_Start_Fn,
								Null_Or(Exception)					# saved_object_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							    ) )

			      }
	also
	Rg_Packed_Widget
	    #
	    = RG_ROW	      {												# A horizontal row of packed widgets.
				widgets:		List(								# The list of widgets to be laid out and displayed in this row.
							      { widget:	 	Rg_Packed_Widget,			# One widget in the row. Note that it could be a COL or SCROLLABLE_VIEW or such containing multiple subwidgets.
								raw_hints:	List(plh::Packedspace_Layout_Hint),	# Layout hints provided by client code.
								cooked_hints:	Packed_Layout_Hints			# Digested version of previous.
							      }								#
							    ),
				pixels_high_min: 	Ref(Int),							# Minimum            vertical   pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				pixels_wide_min: 	Ref(Int),							# Minimum            horizontal pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				#
				pixels_high_cut: 	Ref(Float),							# Share of remaining vertical   pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				pixels_wide_cut: 	Ref(Float),							# Share of remaining horizontal pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				#
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }

	    | RG_COL	      {												# A vertical column of packed widgets.
				widgets:		List(								# The list of widgets to be laid out and displayed in this column.
							      { widget:		Rg_Packed_Widget,			# One widget in the column. Note that it could be a ROW or SCROLLABLE_VIEW or such containing multiple subwidgets.
								raw_hints:	List(plh::Packedspace_Layout_Hint),	# Layout hints provided by client code.
								cooked_hints:	Packed_Layout_Hints			# Digested version of next
							      }								#
							    ),
				pixels_high_min: 	Ref(Int),							# Minimum            vertical   pixels to allocate for this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				pixels_wide_min: 	Ref(Int),							# Minimum            horizontal pixels to allocate for this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				#
				pixels_high_cut: 	Ref(Float),							# Share of remaining vertical   pixels to allocate to  this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				pixels_wide_cut: 	Ref(Float),							# Share of remaining horizontal pixels to allocate to  this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
				#
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }

	    | RG_SCROLLABLE_VIEW {											# Here we provide support for widgets visible through a scrollable viewport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
				widget:			Rg_Packed_Widget,						# Tree of widgets partially visible in viewport.
				gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,					# This is the pixmap visible through the viewport. It holds a full image of above 'widget' tree.
				view_origin:		Ref(g2d::Point),						# Origin of view's backing_pixmap in viewport coordinates, used for scrolling pixmap in viewport.
				backing_pixmap:		s2g::Backing_Pixmap,						# This is the parent pixmap holding the viewport.
				scroller:		Viewport_Scroller,
				callback:		Viewport_Scroller_Callback,					# This is how we pass our Viewport_Scroller to app client code, which basically lets it set 'pixmap_origin' above.
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }

	    | RG_TABBED_VIEWS {												# Here we provide support for selection between alternate views in viewport.  Actually providing tabs happens at a higher level; here we handle pixmap state maintenance and redraw support.
				pixmap_size:		g2d::Size,							# Size of alternate pixmaps visible in viewport.  We require them to all be the same size; we intend that the viewport be the same size.
				widgets:		List(								# This record holds one of the alternate views which may be made visible in the viewport.  *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST! *** 
							      { widget:			Rg_Packed_Widget,		# Tree of widgets visible in this tab.
								gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,	# This pixmap holds the current visible state of the above widget-tree.
								backing_pixmap:		s2g::Backing_Pixmap		# This is the parent pixmap holding the viewport through which we are visible (when we're visible).
							      }								# This record is type Tabview; we can't use that name here because records and datatypes cannot be mutually recursive.
							    ),
				visible_widget:		Ref (								# Which of 'widgets' is currently visible?  This refcell holds one element from 'widgets';  it supports switching between the tabbed views.
							      { widget:			Rg_Packed_Widget,		#
								gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,	#
								backing_pixmap:		s2g::Backing_Pixmap		# 
							      }								# This record is type Tabview; we can't use that name here because records and datatypes cannot be mutually recursive.
							    ),
				callback:		Tabbed_View_Picker_Callback,					# This is how we pass our Tabbed_View_Picker to app client code, which basically lets it set 'visible_widget' above.
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }
	    #
	    | RG_WIDGET	      {												# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg
				guiboss_to_gadget:	b2g::Guiboss_To_Gadget,						# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/gui/guiboss-imp.pkg
				packedspace_to_widget:	p2w::Packedspace_To_Widget,					# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

				endstate_oneshot:	Once( (								# The widget-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
								Packed_Widget_Start_Fn,					#
								Null_Or(Exception)					# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							    ) ),
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }

	    #
	    | RG_CANVASSPACE  {	canvasspace_id:		Canvasspace_Id,							# guiboss-imp indexes this value into *canvas_stuff to obtain (e.g.) a Guiboss_To_Canvasspace port to the canvasspace-imp.
				widgets:		List ((List(Cs_Layout), Rg_Canvas_Widget)),			# The list of widgets to be drawn on the canvas. These can be placed arbitrarily, including possible overlaps.
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }
	    | RG_BOUNCESPACE  { bouncespace_id:		Bouncespace_Id,							# guiboss-imp indexes this value into *bounce_stuff to obtain (e.g.) a Guiboss_To_Bouncespace port to the bouncespace-imp.
				widgets:		List ((List(Bs_Layout), Rg_Bounce_Widget)),			# The list of widgets to be drawn on the bouncespace. These can be placed arbitrarily.
				site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
			      }
	    #
	    | RG_NULL_PACKED_WIDGET											# We need this because Running_Gui requires an Rg_Packed_Widget value, and sometimes we may not have anything else.



	#########################################################################################
	## guiboss-to-packedspace datatypes
	#
	# Communication from	src/lib/x-kit/widget/gui/guiboss-imp.pkg
	# to 			src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

	also
	Guiboss_To_Packedspace
	  =
	  GUIBOSS_TO_PACKEDSPACE
	    { id:			Id,										# Unique id to facilitate storing guiboss_to_packedspace instances in indexed datastructures like red-black trees.
	      #
	      pass_something:		Replyqueue -> (Int -> Void) -> Void,

	      pass_re_siting_done_flag											# This call updates the pixel-rectangle allocations of the widgets in the given widget-tree and notifies when done.
		  :
		  ( g2d::Box,												# Take this pixel rectangle (in window coordinates)
		    s2g::Backing_Pixmap,										# on this pixmap and divide it between the widgets in
		    Rg_Packed_Widget											# this widget-tree.
		  )
		  -> Replyqueue												# When done inform in this imp-replyqueue
		  -> (Void -> Void)											# this handler.
		  -> Void,

	      do_something:		Int -> Void
	    }

	also
	Packedspace_Option
	    #
	    = MICROTHREAD_NAME	String											# 
	    | ID			Id										# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	    | PACKEDSPACE_CALLBACK	Guiboss_To_Packedspace -> Void
	    ;


	#########################################################################################
	## More guiboss-to-packedspace types types

	Packedspace_Arg =  List(Packedspace_Option);									# Currently no required component.

	#########################################################################################
	## More gui-plan types

	Gui_Plan =  (Packedspace_Arg,  Packed_Widget);

	#########################################################################################
	## More stopped-gui types

	Stopped_Gui =  (Packedspace_Arg,  Sg_Packed_Widget);


	#########################################################################################
	## More running-gui types

	Running_Gui =	      {	fire_end_gun:		Void -> Void,							# Calling this fn will cause all state and look imps in the gui to exit, saving their state to their oneshots.
				packedspace_id:		Packedspace_Id,							# guiboss-imp indexes this value into *packed_stuff to obtain (e.g.) a Guiboss_To_Packedspace port to the packedspace-imp.
				packed_widget:		Rg_Packed_Widget,						# The widget (or more commonly, tree of widgets) managed by the gui-tree's toplevel packedspace-imp.
				topwindow:		gws::Guiboss_To_Topwindow,					# The topwindow on which to draw our widgets.
				topwindow_pixmap:	s2g::Backing_Pixmap,						# Holds toplevel s2g::TOPWINDOW_PIXMAP for gui.
				next_stacking_order:	Ref(Int)							# Next space_to_gui::Backing_Pixmap.stacking_order value to issue.
			      };



	Row_Widget													# This is intended to match the ROW declaration above.
	  =														# We can't use this definition there because plain types cannot be mutually recursive.
	  { widget:	 	Rg_Packed_Widget,									#
	    cooked_hints:	Packed_Layout_Hints,									# Digested version of next
	    raw_hints:		List(plh::Packedspace_Layout_Hint)							# Layout hints provided by client code.
	  };														#

	Col_Widget													# This is intended to match the COL declaration above.
	  =														# We can't use this definition there because plain types cannot be mutually recursive.
	  { widget:		Rg_Packed_Widget,									#
	    cooked_hints:	Packed_Layout_Hints,									# Digested version of next
	    raw_hints:		List(plh::Packedspace_Layout_Hint)							# Layout hints provided by client code.
	  };														#

	Tabview														# Something visible in a Rg_Packed_Widget.TABBED_VIEWS.  It is convenient to have a name for this type.
	  =
	  { widget:		 Rg_Packed_Widget,									#
	    gadget_to_rw_pixmap: g2p::Gadget_To_Rw_Pixmap,
	    backing_pixmap:	 s2g::Backing_Pixmap									# 
	  }														#
	  ;

															# This section gives names to the implicit record types above used by ROW, COL ...
															# It really sucks that records cannot be included in recursive definitions.
	Row
	  =
	  {														# A horizontal row of packed widgets.
	    widgets:		List(											# The list of widgets to be laid out and displayed in this row.
					  { widget:	 	 Rg_Packed_Widget,					# One widget in the row. Note that it could be a COL or SCROLLABLE_VIEW or such containing multiple subwidgets.
					    raw_hints:	 	 List(plh::Packedspace_Layout_Hint),			# Layout hints provided by client code.
					    cooked_hints:	Packed_Layout_Hints					# Digested version of previous.
					  }										#
					),
	    pixels_high_min: 	Ref(Int),										# Minimum            vertical   pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    pixels_wide_min: 	Ref(Int),										# Minimum            horizontal pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    #
	    pixels_high_cut: 	Ref(Float),										# Share of remaining vertical   pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    pixels_wide_cut: 	Ref(Float),										# Share of remaining horizontal pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    #
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };

	Col
	  =
	  {														# A vertical column of packed widgets.
	    widgets:		List(											# The list of widgets to be laid out and displayed in this column.
					  { widget:		Rg_Packed_Widget,					# One widget in the column. Note that it could be a ROW or SCROLLABLE_VIEW or such containing multiple subwidgets.
					    raw_hints:	List(plh::Packedspace_Layout_Hint),				# Layout hints provided by client code.
					    cooked_hints:	Packed_Layout_Hints					# Digested version of next
					  }										#
					),
	    pixels_high_min: 	Ref(Int),										# Minimum            vertical   pixels to allocate for this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    pixels_wide_min: 	Ref(Int),										# Minimum            horizontal pixels to allocate for this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    #
	    pixels_high_cut: 	Ref(Float),										# Share of remaining vertical   pixels to allocate to  this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    pixels_wide_cut: 	Ref(Float),										# Share of remaining horizontal pixels to allocate to  this COL widget.	 Used in src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	    #
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };


	Scrollable_View
	  =
	  {														# Here we provide support for widgets visible through a scrollable viewport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
	    widget:			Rg_Packed_Widget,								# Tree of widgets partially visible in viewport.
	    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,							# This is the pixmap visible through the viewport. It holds a full image of above 'widget' tree.
	    view_origin:		Ref(g2d::Point),								# Origin of view's backing_pixmap in viewport coordinates, used for scrolling pixmap in viewport.
	    backing_pixmap:		s2g::Backing_Pixmap,								# This is the parent pixmap holding the viewport.
	    scroller:			Viewport_Scroller,
	    callback:			Viewport_Scroller_Callback,							# This is how we pass our Viewport_Scroller to app client code, which basically lets it set 'pixmap_origin' above.
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };

	Tabbed_Views
	  =
	  {														# Here we provide support for selection between alternate views in viewport.  Actually providing tabs happens at a higher level; here we handle pixmap state maintenance and redraw support.
	    pixmap_size:		g2d::Size,									# Size of alternate pixmaps visible in viewport.  We require them to all be the same size; we intend that the viewport be the same size.
	    widgets:		List(											# This record holds one of the alternate views which may be made visible in the viewport.  *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST! *** 
					  { widget:			Rg_Packed_Widget,				# Tree of widgets visible in this tab.
					    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,			# This pixmap holds the current visible state of the above widget-tree.
					    backing_pixmap:		s2g::Backing_Pixmap				# This is the parent pixmap holding the viewport through which we are visible (when we're visible).
					  }										# This record is type Tabview; we can't use that name here because records and datatypes cannot be mutually recursive.
					),
	    visible_widget:		Ref (										# Which of 'widgets' is currently visible?  This refcell holds one element from 'widgets';  it supports switching between the tabbed views.
					  { widget:			Rg_Packed_Widget,				#
					    gadget_to_rw_pixmap:	g2p::Gadget_To_Rw_Pixmap,			#
					    backing_pixmap:		s2g::Backing_Pixmap				# 
					  }										# This record is type Tabview; we can't use that name here because records and datatypes cannot be mutually recursive.
					),
	    callback:			Tabbed_View_Picker_Callback,							# This is how we pass our Tabbed_View_Picker to app client code, which basically lets it set 'visible_widget' above.
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };

	Widget
	  =
	  {														# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/packed/default/look/widget-imp.pkg
	    guiboss_to_gadget:		b2g::Guiboss_To_Gadget,								# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/gui/guiboss-imp.pkg
	    packedspace_to_widget:	p2w::Packedspace_To_Widget,							# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/space/packed/packedspace-imp.pkg

	    endstate_oneshot:	Once( (											# The widget-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
					Packed_Widget_Start_Fn,							#
					Null_Or(Exception)								# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				    ) ),
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
	  };

															# We'll eventually want canvas and bounce stuff here, but that isn't really operational yet.
	#########################################################################################
	## more guiboss-to-packedspace types

	#########################################################################################
	## packedspace-imp code

	fun pprint_packedspace_arg
	      (pp:		pp::Prettyprint_Mill)
	      (packedspace_arg:	Packedspace_Arg)
	    =
	    {
		packedspace_arg
		    ->
		    (
			options:	List(Packedspace_Option)
		    );

		pp.box {.
		    pp.txt "[ ";
		    pp::seq {. pp.txt ", "; }
			    pprint_option
			    options
			    ;	
		    pp.txt " ]";
		    pp.lit ")";
		};
	    }
	    where
		fun pprint_option option
		    =
		    case option
			#
			MICROTHREAD_NAME name	=>  {  pp.lit (sprintf "MICROTHREAD_NAME \"%s\"" name);		};
			ID               id	=>  {  pp.lit (sprintf "ID %d" (id_to_int id)         );	};
			PACKEDSPACE_CALLBACK _	=>  {  pp.lit          "PACKEDSPACE_CALLBACK (callback)";	};
		    esac;
	    end;


	fun pprint_packedspace_layout_hint
	      #	
	      (pp:		pp::Prettyprint_Mill)
	      (layout_hint:	plh::Packedspace_Layout_Hint)
	    =
	    case layout_hint
		#
		plh::WIDGET_PIXELS_CUT f =>    pp.lit (sprintf  "WIDGET_PIXELS_CUT %f"  f);
		plh::WIDGET_PIXELS_MIN i =>    pp.lit (sprintf  "WIDGET_PIXESL_MIN %d"  i);
	    esac;

	#########################################################################################
	## gui-plan code

	fun pprint_gui_plan (gui_plan: Gui_Plan)							# "pprint" == "prettyprint".
	    =
	    pp::with_standard_prettyprint_mill
		#
		(err::default_plaint_sink ())	[]
		#
		(\\ pp:   pp::Prettyprint_Mill
		    =
		    do_gui_plan  gui_plan
		    where
			fun do_gui_plan  gui_plan
			    =
			    do_packedspace  gui_plan

			also
			fun do_packedspace
			      ( packedspace_arg:	Packedspace_Arg,
				packed_widget:		Packed_Widget
			      )
			    =
			    {   pp.box {.
				    do_packedspace_arg  packedspace_arg;
				    do_packed_widget     packed_widget;
				};
				pp.newline();
			    }

			also
			fun do_bouncespace
			      (
				bouncespace_arg:	os::Bouncespace_Arg,
				bounce_widgets:		List(  (List(blh::Bouncespace_Layout_Hint), Bounce_Widget)  )
			      )
			    =
			    {   pp.box {.
				    do_bouncespace_arg  bouncespace_arg;
				    do_bounce_widgets    bounce_widgets;
				};
				pp.newline();
			    }

			also
			fun do_bouncespace_arg  (bouncespace_arg:	os::Bouncespace_Arg)
			    =
			    {
				osi::pprint_bouncespace_arg  pp  bouncespace_arg;
				pp.newline();
			    }


			also
			fun do_bouncespace_layout_hints  (layout_hints: List(blh::Bouncespace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  blh::Bouncespace_Layout_Hint)
				    =
				    osi::pprint_bouncespace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_bounce_widgets  (bounce_widgets:		List(  (List(blh::Bouncespace_Layout_Hint), Bounce_Widget)  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";

				    fun do_widget (layout_hints: List(blh::Bouncespace_Layout_Hint),  bounce_widget: Bounce_Widget)
					=
					pp.box {.
					    do_bounce_widget			bounce_widget;
					    pp.endlit ",";
					    pp.txt " ";
					    do_bouncespace_layout_hints	 layout_hints;
					};

				    pp::seq
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					bounce_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_bounce_widget  (bounce_widget:	Bounce_Widget)
			    =
			    case bounce_widget
				#
				SPRITE _
				    =>
				    {
					pp.box {.
					    pp.lit  "SPRITE _";
					};
					pp.newline();
				    };
			    esac

			also
			fun do_canvasspace
			      (
				canvasspace_arg:	cs::Canvasspace_Arg,
				canvas_widgets:		List(  (List(clh::Canvasspace_Layout_Hint), Canvas_Widget)  )
			      )
			    =
			    {   pp.box {.
				    do_canvasspace_arg  canvasspace_arg;
				    do_canvas_widgets    canvas_widgets;
				};
				pp.newline();
			    }

			also
			fun do_canvasspace_arg  (canvasspace_arg:	cs::Canvasspace_Arg)
			    =
			    {
				csi::pprint_canvasspace_arg  pp  canvasspace_arg;
				pp.newline();
			    }

			also
			fun do_canvasspace_layout_hints  (layout_hints: List(clh::Canvasspace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  clh::Canvasspace_Layout_Hint)
				    =
				    csi::pprint_canvasspace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_canvas_widgets  (canvas_widgets:		List(  (List(clh::Canvasspace_Layout_Hint),  Canvas_Widget)  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";


				    fun do_widget (layout_hints: List(clh::Canvasspace_Layout_Hint),  canvas_widget: Canvas_Widget)
					=
					pp.box {.
					    do_canvas_widget			canvas_widget;
					    pp.endlit ",";
					    pp.txt " ";
					    do_canvasspace_layout_hints	layout_hints;
					};

				    pp::seq
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					canvas_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_canvas_widget  (canvas_widget:	Canvas_Widget)
			    =
			    case canvas_widget
				#
				OBJECT _
				    =>
				    {
					pp.box {.
					    pp.lit  "OBJECT _";
					};
					pp.newline();
				    };

			        PACKEDSPACE  packedspace
				    =>
				    {
					pp.lit  "PACKEDSPACE ";
					pp.newline();
					do_packedspace packedspace;
					pp.newline();
				    };
			    esac

			also
			fun do_packedspace_arg  (packedspace_arg:	Packedspace_Arg)
			    =
			    {
				pprint_packedspace_arg  pp  packedspace_arg;
				pp.newline();
			    }

			also
			fun do_packedspace_layout_hints  (layout_hints: List(plh::Packedspace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  plh::Packedspace_Layout_Hint)
				    =
				    pprint_packedspace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_packed_widget  (packed_widget:	Packed_Widget)
			    =
			    case packed_widget
				#
			        ROW	(widgets:	 List( (List(plh::Packedspace_Layout_Hint), Packed_Widget) ))
				    =>
				    {
					pp.box' 0 -1 {.
					    pp.lit  "ROW [";
					    pp.ind 2;
					    pp.txt " ";

					    fun do_widget (layout_hints: List(plh::Packedspace_Layout_Hint), packed_widget: Packed_Widget)
						=
						pp.box {.
						    do_packed_widget			packed_widget;
						    pp.endlit ",";
						    pp.txt " ";
						    do_packedspace_layout_hints	layout_hints;
						};

					    pp::seq
						{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
						do_widget				# Print one list element.
						widgets;				# List of elements.

					    pp.ind 0;
					    pp.txt " ";
					    pp.lit "]";
					};
				    };

			        COL	(a:	 List( (List(plh::Packedspace_Layout_Hint), Packed_Widget) ))
				    =>
				    {
					pp.lit  "COL";
					pp.newline();
				    };

				SCROLLABLE_VIEW _
				    =>
				    {
					pp.box {.
					    pp.lit  "SCROLLABLE_VIEW _";
					};
					pp.newline();
				    };

				TABBED_VIEWS _
				    =>
				    {
					pp.box {.
					    pp.lit  "TABBED_VIEWS _";
					};
					pp.newline();
				    };

				WIDGET _
				    =>
				    {
					pp.box {.
					    pp.lit  "WIDGET _";
					};
					pp.newline();
				    };

			        CANVASSPACE (canvasspace:	(cs::Canvasspace_Arg,  List((List(clh::Canvasspace_Layout_Hint), Canvas_Widget))))
				    =>
				    {
					pp.lit  "CANVASSPACE";
					do_canvasspace  canvasspace;
					pp.newline();
				    };

			        BOUNCESPACE (bouncespace:	(os::Bouncespace_Arg,  List((List(blh::Bouncespace_Layout_Hint), Bounce_Widget))))
				    =>
				    {
					pp.lit  "BOUNCESPACE";
					do_bouncespace  bouncespace;
					pp.newline();
				    };
			      
			        NULL_PACKED_WIDGET
				    =>
				    {
					pp.lit  "NULL_PACKED_WIDGET";
					pp.newline();
				    };
			    esac;
		    end
		);

	#########################################################################################
	## stopped-gui code

	fun pprint_stopped_gui (stopped_gui: Stopped_Gui)								# "pprint" == "prettyprint".
	    =
	    pp::with_standard_prettyprint_mill
		#
		(err::default_plaint_sink ())	[]
		#
		(\\ pp:   pp::Prettyprint_Mill
		    =
		    do_stopped_gui  stopped_gui
		    where
			fun do_stopped_gui  stopped_gui
			    =
			    do_packedspace  stopped_gui

			also
			fun do_packedspace
			      ( packedspace_arg:	Packedspace_Arg,
				packed_widget:		Sg_Packed_Widget
			      )
			    =
			    {   pp.box {.
				    do_packedspace_arg  packedspace_arg;
				    do_packed_widget     packed_widget;
				};
				pp.newline();
			    }

			also
			fun do_bouncespace
			      (
				bouncespace_arg:	os::Bouncespace_Arg,
				bounce_widgets:		List(  (List(blh::Bouncespace_Layout_Hint),  Sg_Bounce_Widget)  )
			      )
			    =
			    {   pp.box {.
				    do_bouncespace_arg  bouncespace_arg;
				    do_bounce_widgets    bounce_widgets;
				};
				pp.newline();
			    }

			also
			fun do_bouncespace_arg  (bouncespace_arg:	os::Bouncespace_Arg)
			    =
			    {
				osi::pprint_bouncespace_arg  pp  bouncespace_arg;
				pp.newline();
			    }


			also
			fun do_bouncespace_layout_hints  (layout_hints: List(blh::Bouncespace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  blh::Bouncespace_Layout_Hint)
				    =
				    osi::pprint_bouncespace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_bounce_widgets  (bounce_widgets:		List(  (List(blh::Bouncespace_Layout_Hint),  Sg_Bounce_Widget)  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";

				    fun do_widget (layout_hints: List(blh::Bouncespace_Layout_Hint),  bounce_widget: Sg_Bounce_Widget)
					=
					pp.box {.
					    do_bounce_widget			bounce_widget;
					    pp.endlit ",";
					    pp.txt " ";
					    do_bouncespace_layout_hints	layout_hints;
					};

				    pp::seq
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					bounce_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_bounce_widget  (bounce_widget:	Sg_Bounce_Widget)
			    =
			    case bounce_widget
				#
			        SG_SPRITE ( fn:			Bounce_Sprite_Start_Fn,
					    saved_sprite_state:	Null_Or(Exception)
					  )
				    =>
				    {
					pp.box {.
					    pp.lit  "SPRITE _";
					};
					pp.newline();
				    };

# 			        SG_BALL	( ball_arg:		c2b::Make_Arg,
# 					  ball_look_arg:	bli::Bounce_Look_Arg
# 					)
# 				    =>
# 				    {
# 					pp.box {.
# 					    pp.lit  "BALL (";		pp.txt " ";
# 					    bsi::pprint_make_arg  pp  ball_arg;
# 					    pp.txt ", ";
# 					    blx::pprint_bounce_look_arg  pp  ball_look_arg;
# 					    pp.lit  ")";
# 					};
# 					pp.newline();
# 				    };
			    esac

			also
			fun do_canvasspace
			      (
				canvasspace_arg:	cs::Canvasspace_Arg,
				canvas_widgets:		List(  (List(clh::Canvasspace_Layout_Hint),  Sg_Canvas_Widget)  )
			      )
			    =
			    {   pp.box {.
				    do_canvasspace_arg  canvasspace_arg;
				    do_canvas_widgets    canvas_widgets;
				};
				pp.newline();
			    }

			also
			fun do_canvasspace_arg  (canvasspace_arg:	cs::Canvasspace_Arg)
			    =
			    {
				csi::pprint_canvasspace_arg  pp  canvasspace_arg;
				pp.newline();
			    }

			also
			fun do_canvasspace_layout_hints  (layout_hints: List(clh::Canvasspace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  clh::Canvasspace_Layout_Hint)
				    =
				    csi::pprint_canvasspace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_canvas_widgets  (canvas_widgets:		List(  (List(clh::Canvasspace_Layout_Hint),  Sg_Canvas_Widget)  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";


				    fun do_widget (layout_hints: List(clh::Canvasspace_Layout_Hint),  canvas_widget: Sg_Canvas_Widget)
					=
					pp.box {.
					    do_canvas_widget			canvas_widget;
					    pp.endlit ",";
					    pp.txt " ";
					    do_canvasspace_layout_hints	layout_hints;
					};

				    pp::seq
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					canvas_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_canvas_widget  (canvas_widget:	Sg_Canvas_Widget)
			    =
			    case canvas_widget
				#
				SG_OBJECT ( fn:			Canvas_Object_Start_Fn,
					    saved_object_state:	Null_Or(Exception)
					  )
				    =>
				    {
					pp.box {.
					    pp.lit  "SG_OBJECT _";
					};
					pp.newline();
				    };

			        SG_PACKEDSPACE  packedspace
				    =>
				    {
					pp.lit  "SG_PACKEDSPACE ";
					pp.newline();
					do_packedspace packedspace;
					pp.newline();
				    };
			    esac

			also
			fun do_packedspace_arg  (packedspace_arg:	Packedspace_Arg)
			    =
			    {
				pprint_packedspace_arg  pp  packedspace_arg;
				pp.newline();
			    }

			also
			fun do_packedspace_layout_hints  (layout_hints: List(plh::Packedspace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  plh::Packedspace_Layout_Hint)
				    =
				    pprint_packedspace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_packed_widget  (packed_widget:	Sg_Packed_Widget)
			    =
			    case packed_widget
				#
			        SG_ROW	(widgets:	 List( (List(plh::Packedspace_Layout_Hint), Sg_Packed_Widget) ))
				    =>
				    {
					pp.box' 0 -1 {.
					    pp.lit  "Sg_ROW [";
					    pp.ind 2;
					    pp.txt " ";

					    fun do_widget (layout_hints: List(plh::Packedspace_Layout_Hint), packed_widget: Sg_Packed_Widget)
						=
						pp.box {.
						    do_packed_widget			packed_widget;
						    pp.endlit ",";
						    pp.txt " ";
						    do_packedspace_layout_hints	layout_hints;
						};

					    pp::seq
						{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
						do_widget				# Print one list element.
						widgets;				# List of elements.

					    pp.ind 0;
					    pp.txt " ";
					    pp.lit "]";
					};
				    };

			        SG_COL	(a:	 List( (List(plh::Packedspace_Layout_Hint), Sg_Packed_Widget) ))
				    =>
				    {
					pp.lit  "SG_COL";
					pp.newline();
				    };

			        SG_SCROLLABLE_VIEW (a:	(Viewport_Scroller_Callback, g2d::Size, Sg_Packed_Widget) )
				    =>
				    {
					pp.lit  "SG_SCROLLABLE_VIEW";
					pp.newline();
				    };

			        SG_TABBED_VIEWS (a:	(Tabbed_View_Picker_Callback,  g2d::Size,  List( Sg_Packed_Widget)))
				    =>
				    {
					pp.lit  "SG_TABBED_VIEWS";
					pp.newline();
				    };

			        SG_WIDGET ( fn:			Packed_Widget_Start_Fn,
					    saved_widget_state:	Null_Or(Exception)
					  )
				    =>
				    {
					pp.box {.
					    pp.lit  "SG_WIDGET _";
					};
					pp.newline();
				    };


			        SG_CANVASSPACE (canvasspace:	(cs::Canvasspace_Arg,  List((List(clh::Canvasspace_Layout_Hint), Sg_Canvas_Widget))))
				    =>
				    {
					pp.lit  "SG_CANVASSPACE";
					do_canvasspace  canvasspace;
					pp.newline();
				    };

			        SG_BOUNCESPACE (bouncespace:	(os::Bouncespace_Arg,  List((List(blh::Bouncespace_Layout_Hint), Sg_Bounce_Widget))))
				    =>
				    {
					pp.lit  "SG_BOUNCESPACE";
					do_bouncespace  bouncespace;
					pp.newline();
				    };
			      
			        SG_NULL_PACKED_WIDGET
				    =>
				    {
					pp.lit  "SG_NULL_PACKED_WIDGET";
					pp.newline();
				    };
			    esac;
		    end
		);



	#########################################################################################
	## running-gui code

	fun packed_widget_site (packed_widget: Rg_Packed_Widget)
	    =
	    case packed_widget
		#
		RG_ROW r		=>  *r.site;
		RG_COL r		=>  *r.site;
		RG_SCROLLABLE_VIEW r	=>  *r.site;
		RG_TABBED_VIEWS r	=>  *r.site;
		RG_WIDGET r		=>  *r.site;
		RG_CANVASSPACE r	=>  *r.site;
		RG_BOUNCESPACE r	=>  *r.site;
		RG_NULL_PACKED_WIDGET	=>  g2d::box::zero;
	    esac;


	Running_Gui_Postorder_Apply_Option										# The following running_gui_postorder_apply() facility allows clients to iterate over nodes in a Running_Gui tree without having to write out the whole recursion.
	  #
	  = ROW_FN		(Row		 -> Void)								# Call this fn on ROW             nodes in Running_Gui. Defaults to null fn.
	  | COL_FN		(Col		 -> Void)								# Call this fn on COL             nodes in Running_Gui. Defaults to null fn.
	  | SCROLLABLE_VIEW_FN	(Scrollable_View -> Void)								# Call this fn on SCROLLABLE_VIEW nodes in Running_Gui. Defaults to null fn.
	  | TABBED_VIEWS_FN	(Tabbed_Views	 -> Void)								# Call this fn on TABBED_VIEWS    nodes in Running_Gui. Defaults to null fn.
	  | WIDGET_FN		(Widget		 -> Void)								# Call this fn on WIDGET          nodes in Running_Gui. Defaults to null fn.
	  | DO_INVISIBLE_VIEWS  Bool											# Defaults to TRUE.  If FALSE, recursion will not enter de-selected views in a TABBED_VIEWS node.
	  ;

	fun running_gui_postorder_apply
	      (
		running_gui:	Running_Gui,
		options:	List( Running_Gui_Postorder_Apply_Option )
	      )
	    =
	    do_packed_widget  running_gui.packed_widget
	    where

		fun process_options  (options:  List(Running_Gui_Postorder_Apply_Option))
		    =
		    {   null_fn = (\\ (x: X) = ());
			#
			my_row_fn			=  REF  null_fn;
			my_col_fn			=  REF  null_fn;
			my_scrollable_view_fn		=  REF  null_fn;
			my_tabbed_views_fn		=  REF  null_fn;
			my_widget_fn			=  REF  null_fn;
			my_do_invisible_views		=  REF  TRUE;

			apply  do_option  options
			where
			    fun do_option (ROW_FN			fn) =>  my_row_fn			:=  fn;
				do_option (COL_FN			fn) =>  my_col_fn			:=  fn;
				do_option (SCROLLABLE_VIEW_FN		fn) =>  my_scrollable_view_fn		:=  fn;
				do_option (TABBED_VIEWS_FN		fn) =>  my_tabbed_views_fn		:=  fn;
				do_option (WIDGET_FN			fn) =>  my_widget_fn			:=  fn;
				do_option (DO_INVISIBLE_VIEWS		b ) =>  my_do_invisible_views		:=  b ;
			    end;
			end;

			{ row_fn			=>  *my_row_fn,
			  col_fn			=>  *my_col_fn,
			  scrollable_view_fn		=>  *my_scrollable_view_fn,
			  tabbed_views_fn		=>  *my_tabbed_views_fn,
			  widget_fn			=>  *my_widget_fn,
			  do_invisible_views		=>  *my_do_invisible_views
			};
		    };

		options =  process_options  options;

		fun do_packed_widget (packed_widget: Rg_Packed_Widget)
		    =
		    case packed_widget
			#
			RG_ROW row =>	{   apply do_widget row.widgets
						where
						    fun do_widget (row_widget: Row_Widget)
							=
							do_packed_widget row_widget.widget;
						end;

					    options.row_fn row;
					};

			RG_COL col =>	{   apply do_widget col.widgets
						where
						    fun do_widget (col_widget: Col_Widget)
							=
							do_packed_widget col_widget.widget;
						end;

					    options.col_fn  col;
					};

			RG_SCROLLABLE_VIEW view
			    =>		{   do_packed_widget  view.widget;
					    #
					    options.scrollable_view_fn  view;
					};

			RG_TABBED_VIEWS views
			    =>		{   fun do_tabview (tabview: Tabview)
						=
						do_packed_widget tabview.widget;

					    if options.do_invisible_views
						#
						apply do_tabview views.widgets;
					    else
						do_tabview *views.visible_widget;
					    fi;

					    options.tabbed_views_fn views;
					};

			RG_WIDGET widget
			    =>		{   options.widget_fn widget;
					};

			RG_CANVASSPACE space
			    =>		{   ();											# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
					};
			RG_BOUNCESPACE space
			    =>		{   ();											# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
					};
			RG_NULL_PACKED_WIDGET
			    =>		{   ();
					};
		    esac;
	    end;


    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.

