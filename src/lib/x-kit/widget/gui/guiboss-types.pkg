## guiboss-types.pkg
#
# Interface types for   src/lib/x-kit/widget/gui/guiboss-imp.pkg
#
# This file contains a great recursive black hole:  					# Originally this was a flock of separate files, but the natural recursive
# No type or function which enters it can ever escape.					# relationships proved just too difficult to avoid, so they all moved into
#											# this file where they can recursively refer to each other to their heart's
# We use four representations for a GUI with transition diagram				# content.  Sometimes it is best to just accept the inevitable...
#
#     Gui_Plan
#         |
#         v
#     Paused_Gui									# Gui_Plan -> Paused_Gui -> Running_Gui -> Paused_Gui -> Running_Gui is actually UNTESTED as yet. In fact, Running_Gui -> Paused_Gui may be a bad idea and be removed in future.
#       |   ^										# (In practice we mainly do    Gui_Plan -> Paused_Gui -> Running_Gui and then kill_gui() the Running_Gui.)
#       v   |
#     Running_Gui
#       |   ^
#       v   |
#     Export_Gui									# The purpose of this is to allow client code to morph a running gui by generating an Export_Gui (Gadget_To_Guiboss.get_exported_running_gui), editing it, and submitting it (Gadget_To_Guiboss.morph_running_gui).
#
# The application programmers passes guiboss_imp a Gui_Plan
# to define the GUI, which is then converted to a Paused_Gui
# and at GUI startup time to a Running_Gui.
#     We support pausing and later restarting the GUI by a				# IN THEORY! :-)
# process of converting the Running_Gui back to a Paused_Gui
# and at restart the Paused_Gui again to a Running_Gui.
#
# In addition to defining the three GUI representations, this
# file defines most (but not all) of the major ports between
# guiboss_imp and other imps:								# "gadget" refers to any of "widget", "sprite" or "object".  (Most frequently, "widget".)
#
#	guiboss_to_gadget								# The general guiboss_imp -> gadget interface, used for forwarding user mouseclicks etc.  Most frequently used guiboss_imp -> widget_imp, but also to sprite_imp and object_imp.
#	gadget_to_guiboss								# The general gadget -> guiboss_imp interface, used for forwarding draw operations  etc.
#	guiboss_to_widgetspace								# The guiboss_imp -> widgetspace_imp, used to manage layout of widgets on windows.
#	guiboss_to_objectspace								# The guiboss_imp -> objectspace_imp, used to manage layout of objects on windows.
#	guiboss_to_spritespace								# The guiboss_imp -> spritespace_imp, used to manage layout of sprites on windows.
#     

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;							# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package g2d =  geometry2d;								# geometry2d				is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;							# geometry2d_junk			is from   src/lib/std/2d/geometry2d-junk.pkg

    package wt  =  widget_theme;							# widget_theme				is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg
    package evt =  gui_event_types;							# gui_event_types			is from   src/lib/x-kit/widget/gui/gui-event-types.pkg

    package w2p =  widget_to_widgetspace;						# widget_to_widgetspace			is from   src/lib/x-kit/widget/space/widget/widget-to-widgetspace.pkg   
    package p2w =  widgetspace_to_widget;						# widgetspace_to_widget			is from   src/lib/x-kit/widget/space/widget/widgetspace-to-widget.pkg

    package o2c =  object_to_objectspace;						# object_to_objectspace			is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg   
    package c2o =  objectspace_to_object;						# objectspace_to_object			is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2b =  sprite_to_spritespace;						# sprite_to_spritespace			is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg   
    package b2s =  spritespace_to_sprite;						# spritespace_to_sprite			is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg

    package g2p =  gadget_to_pixmap;							# gadget_to_pixmap			is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg
#   package s2g =  space_to_gui;							# space_to_gui				is from   src/lib/x-kit/widget/gui/space-to-gui.pkg

    package im  =  int_red_black_map;							# int_red_black_map			is from   src/lib/src/int-red-black-map.pkg
    package iul =  issue_unique_look_id;						# issue_unique_look_id			is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg
    package gtg =  guiboss_to_guishim;							# guiboss_to_guishim			is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package pp  =  standard_prettyprint_mill;						# standard_prettyprint_mill		is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg

    package lms =  list_mergesort;							# list_mergesort			is from   src/lib/src/list-mergesort.pkg

    package err =  error_message;							# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package gd  =  gui_displaylist;							# gui_displaylist			is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    package t2t =  texteditor_to_textbuffer;						# texteditor_to_textbuffer		is from   src/lib/x-kit/widget/edit/texteditor-to-textbuffer.pkg


    # Some abbreviations because line length was getting out of hand below:
    #
    Once(X) = Oneshot_Maildrop(X);

    nb = log::note_on_stderr;								# log					is from   src/lib/std/src/log.pkg

herein

    package guiboss_types
    {


	#########################################################################################
	### preliminary types

	Scroller									# Client controller for scrolling a viewable around in a scrollport.
	  =
	  { get_scrollport_origin: Void -> g2d::Point,
	    set_scrollport_origin: g2d::Point -> Void
	  };

	Scroller_Callback								# Used in Gp_Widget.SCROLLPORT	in   src/lib/x-kit/widget/gui/running-gui.pkg
	  =
	  Null_Or( Scroller ) -> Void;


	Tab_Picker									# Client controller for which tab is visible in given tabport.
	  =
	  { get_active_tab: Void -> Int,
	    set_active_tab: Int -> Void
	  };

	Tab_Picker_Callback								# Used in Gp_Widget.TABBED_VIEWS	in   src/lib/x-kit/widget/gui/running-gui.pkg
	  =
	  Null_Or( Tab_Picker ) -> Void;


	#########################################################################################
	### Preliminary running-gui types

	# Storing instances of
	#     guiboss_to_spritespace, 
	#     guiboss_to_objectspace, 
	# or  guiboss_to_widgetspace
	# directly in Running_Gui leads to package circularity,
	# so instead we store their integer id here, and
	# in guiboss-imp.pkg look them up as needed in
	# (respectively):	
	#     spritespaces
	#     objectspaces
	#     widgetspaces
	# 
	Spritespace_Id = Id;
	Objectspace_Id = Id;
	Widgetspace_Id = Id;



	#########################################################################################
	### gadget-to-guiboss types


	Gadget_Mode													# We use this mostly to control how a widget draws itself.
	  =														# To avoid a package cycle this def is duplicated in   src/lib/x-kit/widget/theme/widget/widget-theme.pkg
	  {														# We probably should find/make another home for this def. XXX SUCKO FIXME
	    is_active:				Bool,									# An inactive gadget is passed no user input. Inactive widgets are typically drawn "grayed-out".
	    has_mouse_focus:			Bool,									# A widget which has the mouse cursor on it may want to draw itself brigher or such.
	    has_keyboard_focus:			Bool									# A widget which has the keyboard focus will often      draw a black outline around its text-entry rectangle.
	  };


	Wakeup_Arg
	  =
	  { frame_number:			Int,									# 1,2,3,... Purely for convenience of widget, guiboss-imp makes no use of this.
	    site:				g2d::Box,								# Window rectangle in which to draw.
	    visible:				Bool,									# If FALSE, widget is not visible on screen, so look-imp may be able to avoid updating foreground and background.
	    duration_in_seconds:		Float,									# If state has changed look-imp should call redraw_gadget() before this time is up. Also useful for motionblur.
	    gadget_mode:			Gadget_Mode								# is_active/has_keyboard_focus/has_mouse_focus flags.
	  };

	Wake_Me_Option
	  #
	  = AT_FRAME_N				Null_Or( (Int,   Wakeup_Arg -> Void) )					# Call gadget.wakeup once, during frame N, and pass given arg in call. NULL arg turns this wakeup off.
	  | EVERY_N_FRAMES			Null_Or( (Int,   Wakeup_Arg -> Void) )					# Call gadget.wakeup every N frames,       and pass given arg in call. NULL arg turns this wakeup off.
#
# I'm too lazy to implement these two right
# now but I expect we'll want them eventually:   -- CrT 2015-01-05  	
# 
#	  | IN_S_SECONDS			Null_Or( (Float, Wakeup_Arg -> Void) )					# Call gadget.wakeup once after s seconds, and pass given arg in call. NULL arg turns this wakeup off.
#	  | EVERY_S_SECONDS			Null_Or( (Float, Wakeup_Arg -> Void) )					# Call gadget.wakeup every      s seconds, and pass given arg in call. NULL arg turns this wakeup off.
	  ;


	#########################################################################################
	### gui-plan datatypes

	Gp_Scrollable													# Contents for a scrollport.
	    #
	    = SCROLLABLE_ID	Id											# Id for a SCROLLABLE elsewhere in the Gui_Plan.
	    #
	    | SCROLLABLE	{ id:		Id,									# Id by which this SCROLLABLE may be referenced in SCROLLABLE_ID values.
				  pixmap_size:	g2d::Size,								# Size of pixmap visible in scrollport.
				  widget:	Gp_Widget								# Widget-tree providing content visible in scrollport -- will be rendered onto pixmap.
				}

	also
	Gp_Sprite
	    #
	    = SPRITE		Sprite_Start_Fn

	also
	Gp_Object
	    #
	    = WIDGETSPACE	(List(Widgetspace_Option),  Gp_Widget)
	    #
	    | OBJECT		Object_Start_Fn

	also
	Gp_Widget
	    #
	    = ROW		Gp_Row
	    | COL		Gp_Col
	    #
	    | ROW'		Gp_Row'
	    | COL'		Gp_Col'
	    #
	    | GRID		Gp_Grid											# Grid of widgets; outer list goes by rows, inner lists go by columns.
	    #	
	    | SCROLLPORT	Gp_Scrollport
	    | TABPORT	 	Gp_Tabport

	    | FRAME		Gp_Frame										# For frame customization.

	    | WIDGET		Gpwidget										# These values are created by   make_widget_start_fn   in   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg 
	    #
	    | OBJECTSPACE	Gp_Objectspace
	    | SPRITESPACE	Gp_Spritespace
	    #
	    | NULL_WIDGET												# Note[1]


	also
	Frame_Option
	    #
	    = FRAME_WIDGET	Widget_Start_Fn



	#########################################################################################			# 2014-12-13: I'm inclined to think we don't actually need or want paused-gui, but it would be a pain to add it back in if I'm wrong and it does no great harm for now, so I'm leaving it in until the situation clarifies.
	### paused-gui datatypes
															# Nomenclature: "Pg_" == "Paused_Gui_";  "PG_" == "PAUSED_GUI_".
	also
	Pg_Scrollable													# Contents for a scrollport.
	    #
	    = PG_SCROLLABLE_ID	Id											# Id for a PG_SCROLLABLE elsewhere in the Gui_Plan.
	    #
	    | PG_SCROLLABLE	{ id:		Id,									# Id by which this PG_SCROLLABLE may be referenced in PG_SCROLLABLE_ID values.
				  pixmap_size:	g2d::Size,								# Size of pixmap visible in scrollport.
				  pg_widget:	Pg_Widget								# Widget-tree providing content visible in scrollport -- will be rendered onto pixmap.
				}
	also
	Pg_Sprite													# 
	    #
	    = PG_SPRITE		( Sprite_Start_Fn,
				  Null_Or(Exception)									# saved_sprite_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				)
	also
	Pg_Object
	    #
	    = PG_WIDGETSPACE	(List(Widgetspace_Option),  Pg_Widget)
	    #
	    | PG_OBJECT		( Object_Start_Fn,
				  Null_Or(Exception)									# saved_object_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				)
	also
	Pg_Widget
	    #
	    = PG_ROW          (Id, List( Pg_Widget ) )
	    | PG_COL          (Id, List( Pg_Widget ) )
	    #
	    | PG_GRID		   List( List( Pg_Widget ) )

	    | PG_SCROLLPORT	 { scroller_callback:	Scroller_Callback,						# Callback for registering scroller with client app code.
				   scrollable:		Pg_Scrollable							# What to show in the scrollport.
				 }
	    | PG_TABPORT	 ( Tab_Picker_Callback,
				   g2d::Size,
				   List(Pg_Widget)									# 
				 )
	    | PG_FRAME		 ( Pg_Widget,										# frame_widget.
				   Pg_Widget										# widget.
				 )

	    | PG_WIDGET		( Widget_Start_Fn,
				  Null_Or(Exception)									# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				)

	    | PG_OBJECTSPACE	(List(Objectspace_Option),  List(Pg_Object))
	    | PG_SPRITESPACE	(List(Spritespace_Option),  List(Pg_Sprite))

	    | PG_NULL_WIDGET												# Note[1]



	#########################################################################################
	### running-gui datatypes
															# Nomenclature: "Rg_" == "Running_Gui_",  "RG_" == "RUNNING_GUI_".  
	also
	Rg_Sprite													# This datatype has only one alternative, but will presumably eventually have multiple variants just like Rg_Object and Rg_Widget, so converting it to a simple type is probably a bad idea.
	    #
	    = RG_SPRITE	      {
				spritespace_to_sprite:	b2s::Spritespace_To_Sprite,					# 
				guiboss_to_gadget:	Guiboss_To_Gadget,						# 

				endstate_oneshot:	Once( ( 							# The sprite-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
								Sprite_Start_Fn,					# 
								Null_Or(Exception)					# saved_sprite_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							    ) )	
			      }
			
	also
	Rg_Object
	    #
	    = RG_WIDGETSPACE  {	widgetspace_id:		Widgetspace_Id,							# A widget space embedded in a object, to allow all widgetspace widgets to be used also on a object.
				rg_widget:		Rg_Widget
			      }
	    | RG_OBJECT	      {
				objectspace_to_object:	c2o::Objectspace_To_Object,					# 
				guiboss_to_gadget:	Guiboss_To_Gadget,						# 

				endstate_oneshot:	Once( (								# The sprite-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
								Object_Start_Fn,
								Null_Or(Exception)					# saved_object_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
							    ) )

			      }
			
	also
	Rg_Widget
	    #
	    = RG_ROW		  Rg_Row										# 
	    | RG_COL		  Rg_Col										# 
	    #
	    | RG_GRID		  Rg_Grid										# A rectangular grid of widget widgets.

# | RG_CUSTOM_LAYOUT here might be a good idea by and by. Semantics TBD

	    | RG_SCROLLPORT  	  Rg_Scrollport										# Here we provide support for widgets visible through a scrollable scrollport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
	    | RG_TABPORT	  Rg_Tabport										# Here we provide support for selection between alternate views in scrollport.  Actually providing tabs happens at a higher level; here we handle pixmap state maintenance and redraw support.
	    #
	    | RG_FRAME		  Rg_Frame
	    | RG_WIDGET	          Rgwidget										# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
	    #
	    | RG_OBJECTSPACE	  Rg_Objectspace
	    | RG_SPRITESPACE	  Rg_Spritespace
	    #
	    | RG_NULL_WIDGET												# We need this because Running_Gui requires an Rg_Widget value, and sometimes we may not have anything else.


	#########################################################################################
	### guiboss-to-widgetspace datatypes
	#
	# Communication from	src/lib/x-kit/widget/gui/guiboss-imp.pkg
	# to 			src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

	also
	Widgetspace_Option
	    #
	    = PS_MICROTHREAD_NAME	String										# 
	    | PS_ID			Id										# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	    | PS_CALLBACK		Guiboss_To_Widgetspace -> Void



	#########################################################################################
	### guiboss-to-objectpace datatypes
	#
	# Communication from	src/lib/x-kit/widget/gui/guiboss-imp.pkg
	# to 			src/lib/x-kit/widget/space/object/objectspace-imp.pkg

	also
	Objectspace_Option
	  #
	  = CS_MICROTHREAD_NAME		String										# 
	  | CS_ID			Id										# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	  | CS_OBJECTSPACE_CALLBACK	Guiboss_To_Objectspace -> Void


	#########################################################################################
	### guiboss-to-spritespace datatypes
	#
	# Communication from	src/lib/x-kit/widget/gui/guiboss-imp.pkg
	# to 			src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg

	also
	Spritespace_Option
	  #
	  = OS_MICROTHREAD_NAME 	String										# 
	  | OS_ID			Id										# Unique ID for imp, issued by issue_unique_id::issue_unique_id().
	  | OS_SPRITESPACE_CALLBACK	Guiboss_To_Spritespace -> Void


	#########################################################################################
	### gadget-to-guiboss datatypes





	#########################################################################################
	### guiboss-to-gadget datatypes

	also
	Gadget_Transit													# This protocol is intended to support (e.g.) highlighting a gadget while the mouse is over it.
	    #														# The intended semantics here is that:
	    = CAME													#  o  A widget should always see an  CAME before anything else when the mouse cursor enters its space.   CAME events are NOT sent during a drag. A MOVE is always sent immediately after an CAME, with the same mouse coordinate.
 	    | MOVE													#  o  A widget can see any number of MOVE events between a CAME and LEFT; all will be in its space.	 MOVE events are NOT sent during a drag.
	    | LEFT													#  o  A widget should always see a   LEFT after  everything else when the mouse cursor exits  its space. LEFT events are NOT sent during a drag.
	    														#  o  Thus, a widget is not guaranteed to see an CAME every time the mouse cursor enters it (due to drag exception). But if it sees anything at all, an CAME will be first, and a LEFT will be last.

	also
	Drag_Phase													# This protocol is intended to support dragging a slider or scrollbar thumb.
	    #														# The intended semantics here is that:
	    = OPEN													#  o  Every drag sequence begins with exactly one OPEN.
	    | DRAG													#  o  Every drag sequence has zero or more        DRAG phases.
	    | DONE													#  o  Every drag sequence ends   with exactly one DONE.
															# 

	also
	Key_Event													# This protocol is intended to support keyboard text entry.
	    #
	    = KEY_PRESS
	    | KEY_RELEASE

	also
	Mousebutton_Event												# This protocol is intended to support mouse button processing.  Double-clicks are not supported here.  I dislike them because they inherently add latency, and half of GUI framework design is about minimizing latency.
	    #
	    = MOUSEBUTTON_PRESS
	    | MOUSEBUTTON_RELEASE


	#########################################################################################
	### Sprite_Start_Fn datatype

	also
	Sprite_Start_Fn													# Converting this to a simple type does not work due to mutual recursion between Sprite_Start_Fn and Sprite_Imports.
	  =
	  SPRITE_START_FN  (Sprite_Imports -> Sprite_Exports)



	#########################################################################################
	### Object_Start_Fn datatype

	also
	Object_Start_Fn													# Converting this to a simple type does not work due to mutual recursion between Object_Start_Fn and Object_Imports.
	  =
	  OBJECT_START_FN  (Object_Imports -> Object_Exports)



	#########################################################################################
	### Widget_Start_Fn datatype

	also	
	Widget_Start_Fn													# Converting this to a simple type does not work due to mutual recursion between Widget_Start_Fn and Widget_Imports.
	  =														# This type is the critical interface between the widget world and src/lib/x-kit/widget/gui/guiboss-imp.pkg
	  WIDGET_START_FN  (Widget_Imports -> Widget_Exports)								# In particular paused_gui__to__running_gui() in guiboss_imp calls the widget_start_fn built in   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
	      


	#########################################################################################
	### Subwindow_Or_View datatype											# This is used mainly for the home of a gadget, since a gadget may live either directly on a subwindow or else in a scrollport visible ultimately on a subwindow.
															# 
	also														# 
	Subwindow_Or_View												# 
	  #														# 
	  = SUBWINDOW_INFO  Subwindow_Info										# 
	  #	
	  | VIEWABLE_INFO   Viewable_Info										# 


	also														# 
	Subwindow_Data													# This is used in Topwindow_Info and Running_Gui because they are always located directly on a subwindow, not on a scrollport within a subwindow.
	  #														# Unfortunately we can NOT just replace Subwindow_Data everywhere by Subwindow_Info because then Subwindow_Info contains fields of type Subwindow_Info, which is not allowed by the type system.
	  = SUBWINDOW_DATA  Subwindow_Info										# 


	#########################################################################################
	### Xi_Subwindow_Or_View datatype										# 
															# 
	also
	Xi_Sprite													# This datatype has only one alternative, but will presumably eventually have multiple variants just like Rg_Object and Rg_Widget, so converting it to a simple type is probably a bad idea.
	    #
	    = XI_SPRITE	      {
				sprite_id:		iul::Id
			      }
			
	also
	Xi_Object
	    #
	    = XI_WIDGETSPACE  {	widgetspace_id:		Id,								# 
				xi_widget:		Xi_Widget
			      }
	    | XI_OBJECT	      {
				object_id:		iul::Id
			      }

	also
	Xi_Widget
	    #
	    = XI_ROW		    Xi_Row
	    | XI_COL		    Xi_Col
	    #
	    | XI_GRID		    Xi_Grid										# A rectangular grid of widget widgets.
	    | XI_SCROLLPORT  	    Xi_Scrollport									# Here we provide support for widgets visible through a scrollable scrollport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
	    | XI_TABPORT	    Xi_Tabport										# Here we provide support for selection between alternate views in scrollport.  Actually providing tabs happens at a higher level; here we handle pixmap state maintenance and redraw support.
	    #
	    | XI_FRAME		    Xi_Frame
	    | XI_WIDGET	            Xiwidget										# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
	    #
	    | XI_OBJECTSPACE	    List(Xi_Object)
	    | XI_SPRITESPACE	    List(Xi_Sprite)
	    #
	    | XI_NULL_WIDGET												# We need this because Running_Gui requires an Rg_Widget value, and sometimes we may not have anything else.
	    | XI_GUI_PLAN	    Gui_Plan										# To allow starting up new widgets as part of a running-gui update.


	also														# 
	Xi_Subwindow_Or_View												# 
	  #														# 
	  = XI_SUBWINDOW_INFO  Xi_Subwindow_Info									# 
	  #	
	  | XI_VIEWABLE_INFO  												# 



	#########################################################################################
	### More Subwindow_Or_View types

	withtype
	Spritespace_Arg =  List(Spritespace_Option)									# Currently no required component.

	also
	Objectspace_Arg =  List(Objectspace_Option)									# Currently no required component.

	also
	Widgetspace_Arg =  List(Widgetspace_Option)									# Currently no required component.

	also
	Paused_Gui =  (Widgetspace_Arg,  Pg_Widget)

	also
	Client_To_Guiwindow
	  =
	  { id:				Id,										# Unique id to facilitate storing guiboss instances in indexed datastructures like red-black trees.
	    pause_gui:			Void -> Paused_Gui,								# Stop gui but preserve its state and Xserver-side resources.
	    kill_gui:			Void -> Void									# Stop gui and recycle  its state and Xserver-side resources.
	  }

	also
	Gui_Plan =  Gp_Widget

	also
	Make_Popup_Fn 													# Create popup pane on given window in given site.  Given site is adjusted to lie entirely within parent (if necessary) and returned.
	  =
      	  (
	    g2d::Box,													# Requested site for popup, in basewindow coordinates.
	    Gui_Plan													# 
	  )
	  ->
	  (
	    g2d::Box,													# Actual site for popup, in basewindow coordinates. It differs from requested site only if requested site does not lie entirely within basewindow site.
	    Client_To_Guiwindow
	  )

	also
	Guiboss_To_Objectspace												# 
	    =
	      { id:			Id,										# Unique id to facilitate storing guiboss_to_objectspace instances in indexed datastructures like red-black trees.
		#
		pass_something:		Replyqueue -> (Int -> Void) -> Void,
		do_something:		Int -> Void
	      }

	also
	Guiboss_To_Spritespace												# 
	    =
	      { id:			Id,										# Unique id to facilitate storing guiboss_to_spritespace instances in indexed datastructures like red-black trees.
		#
		pass_something:	Replyqueue -> (Int -> Void) -> Void,
		do_something:	Int -> Void
	      }

	also
	Guiboss_To_Widgetspace												# 
	  =
	    { id:			Id,										# Unique id to facilitate storing guiboss_to_widgetspace instances in indexed datastructures like red-black trees.
	      #
	      pass_something:		Replyqueue -> (Int -> Void) -> Void,

	      re_site_widget_tree											# This call updates the pixel-rectangle allocations of the widgets in the given widget-tree and notifies when done.
		  :
		  ( g2d::Box,												# Take this pixel rectangle (in window coordinates)
		    Subwindow_Data,											# on this pixmap and divide it between the widgets in
		    Rg_Widget												# this widget-tree.
		  )
		  -> Void,

	      pass_re_siting_done_flag											# Same as above, for imps that want to do continuation processing when re-siting is complete.
		  :
		  ( g2d::Box,												# Take this pixel rectangle (in window coordinates)
		    Subwindow_Data,											# on this pixmap and divide it between the widgets in
		    Rg_Widget												# this widget-tree.
		  )
		  -> Replyqueue												# When done inform in this imp-replyqueue
		  -> (Void -> Void)											# this handler.
		  -> Void,

	      do_something:		Int -> Void
	    }

	also
	Gadget_To_Guiboss												# 
	    =
	      { id:				Id,									# Unique id to facilitate storing Gadget_To_Guiboss ports in indexed datastructures like red-black trees.
		#
		needs_redraw_gadget_request:	iul::Id	-> Void,							# Inform guiboss_imp that the gadget's appearance needs refreshing. Without this, it may not get a redraw_gadget_request call.
															# This should be called any time the gadget's state changes in a way that would visibly affect its appearance. See Note[3] in   src/lib/x-kit/widget/gui/guiboss-imp.pkg
															# 
		redraw_gadget												# Update gadget appearance in response to a guiboss_to_gadget.redraw_gadget_request {...} call.
		  :													# This can also be called spontaneously in the absence of a redraw_gadget_request call,
		  { id:				iul::Id,								# but if the gadget state gets updated frequently (say, 10,000 times/sec) this may overwhelm the display subsystem.
		    displaylist:		gd::Gui_Displaylist,
		    point_in_gadget:		Null_Or( g2d::Point -> Bool )						# Optional fn to decide if a mouseclick actually hit the gadget itself, or just somewhere near it in the screenspace assigned to it.
		  }
		  ->
		  Void,

		note_changed_gadget_activity:	{ id: iul::Id, is_active:  Bool } -> Void,				# FALSE if gadget should be insensitive to input and perhaps drawn grayed-out.  Controlled by application logic.

		wake_me:			{ id: iul::Id, options:	List(Wake_Me_Option) } -> Void,			# Used to schedule guiboss_to_gadget.wakeup calls.
		make_popup:			Make_Popup_Fn,								# Create popup pane at given site.  Given site is adjusted to lie entirely within parent (if necessary) and returned.

		gadget_to_editboss:		t2t::Gadget_To_Editboss,						# So texteditor.pkg can make  gadget_to_editboss.get_or_make_textbuffer(buffername)  requests.

		redo_layout_and_redisplay:	Void -> Void,								# WRITTEN BUT CURRENTLY UNTESTED! 2015-01-17

		get_exported_running_gui:	Void -> Xi_Widget,							# Export abstract version of guiboss_imp's current Running_Gui.  [ I don't understand why Export_Gui isn't visible here as a synonym of Xi_Widget. -- 2015-01-20 CrT ]
		morph_running_gui:		Xi_Widget -> Void							# Update guiboss_imp's running gui per supplied Export_Gui, which should be a suitably edited version of return value from get_exported_running_gui.  See Note[1] in src/lib/x-kit/widget/gui/guiboss-export-import.pkg
	      }

	also
	Guiboss_To_Gadget												# 
	  =
	    {   id:			iul::Id,									# Unique id to facilitate storing Guiboss_To_Gadget ports in indexed datastructures like red-black trees.
		#
 # These two may be a mistake,
 # I'm not sure they are used
 # or even potentially useful:
		wants_keystrokes:	Bool,										# TRUE iff guiboss_imp should send keyboard events to this gadget.  This might need to become a Ref(Bool)...?
		wants_mouseclicks:	Bool,										# TRUE iff guiboss_imp should send mouse    events to this gadget.  This is about correctness not efficiency: We might have two nested candidate gadgets where this flag decides which one gets the event.

		#
		initialize_gadget: {											# Before the first redraw_gadget_request call every widget-imp/sprite-imp/object-imp gets this call from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
				      #											# If its appearance has changed it should call note_changed_gadget_foreground() from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
				      site:		g2d::Box,							# Window rectangle in which to draw.
				      theme:		wt::Widget_Theme,
				      #
				      get_font:		List(String) ->  evt::Font,					# Accepts a list of font names which are tried in order; returns font 'ascent' and 'descent' in pixels -- sum them to get  font height.
				      pass_font:	List(String) -> Replyqueue					#
								     -> ( evt::Font -> Void )				#
								     -> Void,						# Nonblocking version of previous, for use in imps.

				      make_rw_pixmap:	g2d::Size -> g2p::Gadget_To_Rw_Pixmap
				    }
				    ->
				    Void,


		redraw_gadget_request:	    {										# This is a request to the gadget to redraw itself, made by    src/lib/x-kit/widget/gui/guiboss-imp.pkg
					      #										# Gadget should always respond by calling gadget_to_guiboss.redraw_gadget(), even if appearance is unchanged. (guiboss might be refreshing screen after an EXPOSE event, say.)
					      frame_number:		Int,						# 1,2,3,... Purely for convenience of gadget -- guiboss-imp makes no use of this.
					      site:			g2d::Box,					# Window rectangle in which to draw.
					      visible:			Bool,						# I THINK THIS IS OBSOLETE AND PROBABLY SHOULD BE DROPPED. -- 2015-01-17 CrT  XXX SUCKO FIXME
					      duration_in_seconds:	Float,						# If state has changed look-imp should call redraw_gadget() before this time is up. Also useful for motionblur.
					      gadget_mode:		Gadget_Mode,
					      theme:			wt::Widget_Theme
					    }
					    ->
					    Void,

		wakeup:			    {										# These calls are set up by calling gadget_to_guiboss.wake_me[].
					      #										# 
					      frame_number:		Int,						# 1,2,3,... Purely for convenience of widget, guiboss-imp makes no use of this.
					      site:			g2d::Box,					# Window rectangle in which to draw.
					      visible:			Bool,						# I THINK THIS IS OBSOLETE AND PROBABLY SHOULD BE DROPPED. -- 2015-01-17 CrT  XXX SUCKO FIXME
					      duration_in_seconds:	Float,						# If state has changed look-imp should call redraw_gadget() before this time is up. Also useful for motionblur.
					      gadget_mode:		Gadget_Mode,
					      wakeup_fn:		Wakeup_Arg -> Void 				# Gadget thunk registered via gadget_to_guiboss.wake_me[].
					    }
					    ->
					    Void,


		note_mouse_drag_event:	    {										# Intended to support dragging sliders and scrollbar thumbs etc.  Not intended for drag-and-drop.
					      phase:		    Drag_Phase,						# We guarantee that the gadget that sees the OPEN (downclick) for a drag also sees all the DRAGs and the DONE for that drag, and that no other gadget sees drag or transit events during that time period.
					      modifier_keys_state:  evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
					      mousebuttons_state:   evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
					      event_point:	    g2d::Point,						# 'event_point' is the current   point the window's coordinate system.
					      start_point:	    g2d::Point,						# 'start_point' is the downclick point the window's coordinate system.
					      last_point:	    g2d::Point,						# 'last_point'  is the event_point from the preceding ntoe_mouse_drag_event call.
					      site:		    g2d::Box,						# Gadget's assigned area in window coordinates.
					      theme:		    wt::Widget_Theme					#
					    }										# DONE is sent when last mousebutton is released, no matter where that happnes.
					    -> Void,									# Normally OPEN and DRAG are sent if they occur within the gadget's assigned site.
															# This can be restricted to a sub-area of the site using point_in_gadget -- src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg

		note_mouse_transit:	    {										# Mouse entering or leaving window site assigned to gadget.  Intended to support tooltips, active-widget highlighting etc. Note that buttons are always all up in a mouse transit -- otherwise it is a mouse-drag event.
					      transit:		    Gadget_Transit,
					      modifier_keys_state:  evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
					      event_point:	    g2d::Point,						# 'event_point'  is the click point the window's coordinate system.
					      site:		    g2d::Box,						# Gadget's assigned area in window coordinates.
					      theme:		    wt::Widget_Theme					#
					    }										# CAME/MOVE/LEFT are never sent during drag operations.
					    -> Void,									# Normally CAME/MOVE  are sent if they occur within the gadget's assigned site.
															# This can be restricted to a sub-area of the site using point_in_gadget -- src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg

		note_key_event:	    	   {										# Note keyboard KEY_PRESS or KEY_RELEASE at 'point'. Intended for textfield text entry etc.
					      key_event:	    Key_Event,						# KEY_PRESS or KEY_RELEASE.
					      keycode:		    evt::Keycode,					# Keyboard key just pressed/released.
					      keysym:		    evt::Keysym,					# Keysym  of the key.  This is not present in the X version of Key_Kevtinfo; added for widget-code convenience.
					      string:		    String,						# Ascii  for the key.  This is not present in the X version of Key_Kevtinfo; added for widget-code convenience.
					      modifier_keys_state:  evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
					      mousebuttons_state:   evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
					      event_point:	    g2d::Point,						# 'point'  is the click point the window's coordinate system.
					      site:		    g2d::Box,						# Gadget's assigned area in window coordinates.
					      theme:		    wt::Widget_Theme
					    }
					    -> Void,

		note_mousebutton_event:	    {										# Note mousebutton click at 'point'.  Intended for pushbuttons etc.
					      mousebutton_event:    Mousebutton_Event,					# MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE. These go to the gadget under the mouse pointer, hence a gadget may not see both if the pointer moves between them. Use note_mouse_drag_event if this is a problem.
					      mouse_button:	    evt::Mousebutton,					# Mouse button just clicked down. Range is 1-13 or more.  Typically 1=left, 2=middle, 3=right, 4=mousewheel-forward, 5=mousewheel-back.
					      modifier_keys_state:  evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
					      mousebuttons_state:   evt::Mousebuttons_State,				# State of mouse buttons as a bool record, BEFORE THE EVENT -- so a MOUSEBUTTON_RLEASE will always show at least one button down.
					      event_point:	    g2d::Point,						# 'point'  is the click point the window's coordinate system.
					      site:		    g2d::Box,						# Gadget's assigned area in window coordinates.
					      theme:		    wt::Widget_Theme					#
					    }										# Normally MOUSEBUTTON_PRESS or MOUSEBUTTON_RELEASE are sent if they occur within the gadget's assigned site.
					    -> Void,									# This can be restricted to a sub-area of the site using point_in_gadget -- src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg

		die:			    Void -> Void								# Equivalent to firing end_gun', but affects only one gadget.
	      }

	also
	Spritespace_Imp_Info
	  =
	  { sprite_to_spritespace:	s2b::Sprite_To_Spritespace,							# 
	    guiboss_to_spritespace:	Guiboss_To_Spritespace,
	    endstate_oneshot:		Oneshot_Maildrop( Spritespace_Arg )
	  }

	also
	Objectspace_Imp_Info
	  =
	  { object_to_objectspace:	o2c::Object_To_Objectspace,							# 
	    guiboss_to_objectspace: 	Guiboss_To_Objectspace,
	    endstate_oneshot:		Oneshot_Maildrop( Objectspace_Arg )
	  }

	also
	Widgetspace_Imp_Info
	  =
	  { widget_to_widgetspace:	w2p::Widget_To_Widgetspace,							# 
	    guiboss_to_widgetspace: 	Guiboss_To_Widgetspace,
	    endstate_oneshot:		Oneshot_Maildrop( Widgetspace_Arg )
	  }

	also
	Gadget_Imp_Info													# The per-gadget information we track.  (This is private to guiboss-imp.)
	  =														# Here 'gadget' refers indifferently to widget-imps, sprite-imps and object-imps.
	  { site:			Ref( g2d::Box ),								# Where to draw this gadget, in topwindow coordinates.
	    subwindow_or_view:		Ref(Subwindow_Or_View),
	    #
	    guiboss_to_gadget:		Guiboss_To_Gadget,								# We use this to make requests of gadgets.
	    gadget_mode:		Ref( Gadget_Mode ),								# Tracks whether this gadget currently has the mouse focus (etc).
	    #
	    needs_redraw_request:	Ref( Bool ),									# 
	    sent__initialize_gadget:	Ref( Bool ),
	    #
	    point_in_gadget:		Ref( Null_Or( g2d::Point -> Bool )),						# Optional fn to decide if a mouseclick actually hit the gadget itself, or just somewhere near it in the screenspace assigned to it.
	    #
	    pixmaps:			Ref( im::Map( g2p::Gadget_To_Rw_Pixmap )),					# This tracks all X-server pixmaps created by this particular gadget. We need this so that we can reliably recycle them all when killing the gadget -- otherwise we're leaking memory in the X server.

	    at_frame_n:			Ref (	Null_Or									# Call gadget.wakeup once, during frame N, and pass wakeup_fn in call. NULL means this wakeup is off.
						  { at_frame:	Int,
						    wakeup_fn:	Wakeup_Arg -> Void
						  }
					    ),
	    every_n_frames:		Ref (	Null_Or									# Call gadget.wakeup every N frames,       and pass wakeup_fn in call. NULL means this wakeup is off.
						  { n:		Int,
						    next:	Ref(Int),
						    wakeup_fn:	Wakeup_Arg -> Void
						  }
					    )
	  }  

	also	Spritespace_Imps = Ref( im::Map( Spritespace_Imp_Info ) )						# 
	also	Objectspace_Imps = Ref( im::Map( Objectspace_Imp_Info ) )
	also	Widgetspace_Imps = Ref( im::Map( Widgetspace_Imp_Info ) )
	also	Gadget_Imps      = Ref( im::Map(      Gadget_Imp_Info ) )						# We use this to make requests of visible gadgets.	Index is  (id_to_int guiboss_to_gadget.id).

	also
	Running_Gui =	      {	fire_end_gun:		Void -> Void,							# Calling this fn will cause all state and look imps in the gui to exit, saving their state to their oneshots.
				widgetspace_id:		Widgetspace_Id,							# guiboss-imp indexes this value into *widget_imps to obtain (e.g.) a Guiboss_To_Widgetspace port to the widgetspace-imp.
				rg_widget:		Rg_Widget,							# The widget (or more commonly, tree of widgets) managed by the gui-tree's toplevel widgetspace-imp.
				topwindow:		gtg::Guiboss_To_Topwindow,					# The topwindow on which to draw our widgets.
				subwindow_info:		Subwindow_Data,							# Holds toplevel SUBWINDOW_DATA for gui.
				#
				gadget_imps_for_gui:		Gadget_Imps,						# Holds our gt::Gadget_Imp_Info        instances for this running gui.
				spritespace_imps_for_gui:	Spritespace_Imps,					# Holds our gt::Guiboss_To_Spritespace instances for this running gui.
				objectspace_imps_for_gui:	Objectspace_Imps,					# Holds our gt::Guiboss_To_Objectspace instances for this running gui.
				widgetspace_imps_for_gui:	Widgetspace_Imps					# Holds our gt::Guiboss_To_Widgetspace instances for this running gui.
			      }
	also
	Scrollport_Or_Tabport												# Used (only) in VIEWABLE_INFO; each Port instance describes one scrollport or tabport in which the VIEWABLE_INFO.pixmap is visible. (Typically just one per VIEWABLE_INFO.)
	  =
	  {
	    parent_subwindow_or_view:	Subwindow_Or_View,								# This can be a VIEWABLE_INFO if we have a scrollport located on a scrollport.
	    site:			Ref(g2d::Box),									# Size and location of subwindow scrollport in parent Subwindow_Or_View coordinates.
	    #
	    origin:			Ref(g2d::Point)									# Location of view relative to scrollport. Used to scroll subwindow contents around in parent scrollport.
	  }														# So  if origin is (0,0), pixel (0,0) on viewable draws at upper-left of scrollport,
															# and if origin is (5,5), pixel (0,0) on viewable draws 5 pixels in diagonally at upper-left of scrollport.
															# Used in compute_gadget_redraw_transform() in   src/lib/x-kit/widget/gui/guiboss-imp.pkg
 
	also
	Subwindow_Info													# Used in SUBWINDOW_INFO.
	  =
	  { running_gui:	Ref( Null_Or( Running_Gui ) ),
	    pixmap:		g2p::Gadget_To_Rw_Pixmap,								# Main backing store for this running gui.
	    pixmaps:		Ref( im::Map( g2p::Gadget_To_Rw_Pixmap )),						# This tracks all other X-server pixmaps created by this particular running gui. We need this so that we can reliably recycle them all when killing the gui -- otherwise we're leaking memory in the X server.
	    popups:		Ref(List(Subwindow_Data)),								# These will all be SUBWINDOW_INFO, so 'Ref(List(Subwindow_Info))' would be a better type here.
	    parent:		Null_Or( Subwindow_Data ),								# For popups this points to the parent; for the original non-popup window it is NULL.
	    stacking_order:	Int,											# Assigned in increasing order starting at 1;  these determine who overlies who visually on the screen in case of overlaps. (Popups must be entirely within parent, but sibling popups can overlap.)
	    origin:		Ref(g2d::Point)										# If we have a parent, this gives our location on it. Note that pixmap.size gives our size.
	  }

	also
	Viewable_Info													# A 'viewable' is something which can be visible in a scrollport or tabport. It has a widget-tree 'rg_widget' defining its appearance which gets rendered into 'pixmap' (and thence copied elsewhere) for display.
	  =														# It has a list of backlinks 'scrollports' to the scrollports+tabports in which it is (potentially) visible. These are logically redundant with the port->viewable links, but handy in practice.
	  { id:			Id,											# The 'id' field names us, letting multiple scrollports refer to one viewable.
	    rg_widget:		Ref( Rg_Widget ),									# Widget-tree visible in this viewable, which gets rendered onto 'pixmap' here.
	    #														# rg_widget is a Ref not because we intend to change it, but to work around a technical difficulty in guiboss-imp.pkg:do_pg_widget:PG_SCROLLPORT where  viewable_data and rg_widget each want to be created first.
	    pixmap:		g2p::Gadget_To_Rw_Pixmap,								# Viewable_Info values appear only in RG_SCROLLPORT.viewable_info,
															#                                     RG_TABPORT.tabs
															#		                      RG_TABPORT.visible_tab
	    ports:		Ref( List( Scrollport_Or_Tabport ) ),							# We make this a Ref(List(...)) to allow for adding additional scrollports/tabports opening onto the same underlying viewable pixmap.
															# WARNING: We don't currently use multiple ports onto one pixmap; if we start doing so we'll probably find that *VIEWABLE_INFO.is_visible doesn't work right with them.

	    is_visible:		Ref( Bool )										# This will be FALSE only if we are one of several alternate views in a TABPORT set.
															# We need this so that   update_offscreen_parent_pixmaps_and_then_topwindow()   in   src/lib/x-kit/widget/gui/guiboss-imp.pkg
															# can know when to stop propagating widget updates up the scrollport tree.
	  }			



	also Gp_Row  = List( Gp_Widget )
	also Gp_Col  = List( Gp_Widget )
	also Gp_Row' = (Id, List(Gp_Widget))
	also Gp_Col' = (Id, List(Gp_Widget))
	also Gp_Grid = List( List( Gp_Widget ))
	also Gp_Scrollport   = { scroller_callback: Scroller_Callback,  scrollable: Gp_Scrollable }
	also Gp_Tabport      = ( Tab_Picker_Callback, g2d::Size,	List( Gp_Widget ))					# *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST ***
	also Gp_Frame	     = ( List(Frame_Option),  Gp_Widget )
	also Gpwidget	     = Widget_Start_Fn
	also Gp_Objectspace  = (List(Objectspace_Option),  List(Gp_Object))
	also Gp_Spritespace  = (List(Spritespace_Option),  List(Gp_Sprite))

	#########################################################################################
	### More guiboss-to-widgetspace types



	#########################################################################################
	### More guiboss-to-objectspace types



	#########################################################################################
	### More guiboss-to-spritespace types



	#########################################################################################
	### More gui-plan types


	#########################################################################################
	### More paused-gui types


	#########################################################################################
	### Recursive running-gui types

	also
	Rg_Row														# Used in RG_ROW
	  =
	  {														# A horizontal row of widget widgets.
	    id:				Id,
	    widgets:			List( Rg_Widget ),								# The list of widgets to be laid out and displayed in this row.
	    #
	    pixels_high_min: 		Ref(Int),									# Minimum            vertical   pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    pixels_wide_min: 		Ref(Int),									# Minimum            horizontal pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    #
	    pixels_high_cut: 		Ref(Float),									# Share of remaining vertical   pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    pixels_wide_cut: 		Ref(Float),									# Share of remaining horizontal pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    #
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	  }

	also
	Rg_Col = Rg_Row													# Used in RG_COL.  Synonym to allow better code readability.

	also
	Rg_Grid														# Used in RG_GRID
	  =
	  {														# A grid widget widgets.
	    widgets:			List(	List( Rg_Widget )   ),							# The list lists of widgets to be laid out and displayed in this grid.
	    #
	    pixels_high_min: 		Ref(Int),									# Minimum            vertical   pixels to allocate for this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    pixels_wide_min: 		Ref(Int),									# Minimum            horizontal pixels to allocate for this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    #
	    pixels_high_cut: 		Ref(Float),									# Share of remaining vertical   pixels to allocate to  this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    pixels_wide_cut: 		Ref(Float),									# Share of remaining horizontal pixels to allocate to  this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    #
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	  }


	also
	Rg_Scrollport													# Used in RG_SCROLLPORT
	  =
	  {														# Here we provide support for widgets visible through a scrollable scrollport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
#	    id:				Id,	
	    origin:			Ref(g2d::Point),								# Origin of view's subwindow_or_view in scrollport coordinates, used for scrolling pixmap in scrollport.
	    scroller:			Scroller,									# Client-code interface for controlling view_origin.
	    callback:			Scroller_Callback,								# This is how we pass our Scroller to app client code, which basically lets it set 'pixmap_origin' above.
	    site:			Ref(g2d::Box),									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    #
	    viewable_info:		Viewable_Info									# Pointer to the viewable visible through the scrollport. In principle we support multiple scrollports/tabports open on a single viewable. (Untested, unlikely to be working.)
	  }

	also
	Rg_Tabport													# Used in RG_TABPORT
	  =
	  {														# Here we provide support for selection between alternate views in scrollport.  Actually providing tabs happens at a higher level; here we handle pixmap state maintenance and redraw support.
#	    id:				Id,	
	    pixmap_size:		g2d::Size,									# Size of alternate pixmaps visible in scrollport.  We require them to all be the same size; we intend that the scrollport be the same size.
	    #
	    tabs:			List( Viewable_Info ),								# This record holds one of the alternate views which may be made visible in the scrollport.  *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST! *** 
	    visible_tab:		Ref ( Viewable_Info ),								# Which of 'tabs' is currently visible?  This refcell holds one element from 'tabs';  it supports switching between the tabbed views.
	    #
	    callback:			Tab_Picker_Callback,								# This is how we pass our Tab_Picker to app client code, which basically lets it set 'visible_tab' above.
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	  }

	also
	Rg_Frame
	  =
	  {
	    frame_widget:		Rg_Widget,									# Widget which will draw the frame surround.
	    widget:			Rg_Widget,									# Widget-tree to draw surrounded by frame.
	    #
	    pixels_high_min: 		Ref(Int),									# Minimum            vertical   pixels to allocate for this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    pixels_wide_min:	 	Ref(Int),									# Minimum            horizontal pixels to allocate for this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    #
	    pixels_high_cut: 		Ref(Float),									# Share of remaining vertical   pixels to allocate to  this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    pixels_wide_cut: 		Ref(Float),									# Share of remaining horizontal pixels to allocate to  this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	    #
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	  }

	also
	Rgwidget													# Used in RG_WIDGET
	  =
	  {														# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
	    guiboss_to_gadget:		Guiboss_To_Gadget,								# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/gui/guiboss-imp.pkg
	    widgetspace_to_widget:	p2w::Widgetspace_To_Widget,							# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

	    endstate_oneshot:	Once( (											# The widget-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
					Widget_Start_Fn,								#
					Null_Or(Exception)								# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				    ) ),
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	  }

	also
	Rg_Objectspace													# Used in RG_OBJECTSPACE
	  =
	  {
	    objectspace_id:		Objectspace_Id,									# guiboss-imp indexes this value into *object_stuff to obtain (e.g.) a Guiboss_To_Objectspace port to the objectspace-imp.
	    objects:			List( Rg_Object ),								# The list of objects to be drawn. These can be placed arbitrarily, including possible overlaps.
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	  }

	also
	Rg_Spritespace													# Used in RG_SPRITESPACE
	  =
	  { spritespace_id:		Spritespace_Id,									# guiboss-imp indexes this value into *sprite_stuff to obtain (e.g.) a Guiboss_To_Spritespace port to the spritespace-imp.
	    sprites:			List( Rg_Sprite ),								# The list of widgets to be drawn on the spritespace. These can be placed arbitrarily.
	    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
	  }



	also
	Xi_Subwindow_Info												# Used in XI_SUBWINDOW_INFO.
	  =
	  { xi_widget:			Xi_Widget
#	    popups:		List(Xi_Subwindow_Or_View)								# 
	  }

#	also
#	Xi_Tabview													# 
#	  =
#	  { widget:			 Xi_Widget									#
#	  }														#

	also
	Xi_Row														# Used in RG_ROW
	  =
	  {														# A horizontal row of widget widgets.
	    id:				Id,
	    widgets:			List( Xi_Widget )								# The list of widgets to be laid out and displayed in this row.
	  }

	also
	Xi_Col = Xi_Row

	also
	Xi_Grid														# Used in RG_GRID
	  =
	  {														# A grid widget widgets.
	    widgets:			List(	List( Xi_Widget )   )
	  }

	also
	Xi_Scrollport													# 
	  =
	  {														# 
# THIS SHOULD DIE:
	    xi_widget:			Xi_Widget,									# Tree of widgets partially visible in scrollport.
	    origin:			g2d::Point,									# Origin of view's subwindow_or_view in scrollport coordinates, used for scrolling pixmap in scrollport.
	    scroller:			Scroller,
	    callback:			Scroller_Callback								# This is how we pass our Scroller to app client code, which basically lets it set 'pixmap_origin' above.
	  }

	also
	Xi_Tabport													# 
	  =
	  {														# 
	    widgets:			List( Xi_Widget )
	  }

	also
	Xi_Frame
	  =
	  {
	    frame_widget:		Xi_Widget,									# Widget which will draw the frame surround.
	    widget:			Xi_Widget									# Widget-tree to draw surrounded by frame.
	  }

	also
	Xiwidget													# Used in XI_WIDGET
	  =
	  {														# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
	    widget_id:			iul::Id
	  }

	also Xi_Objectspace =	    List(Xi_Object)
	also Xi_Spritespace =	    List(Xi_Sprite)


	#########################################################################################
	### Recursive  Widget_Start_Fn  types


	also
	Widget_Imports
	  =
	  { gadget_to_guiboss:		Gadget_To_Guiboss,								# 
	    widget_to_widgetspace:	w2p::Widget_To_Widgetspace,							# 
	    run_gun':			Run_Gun,									#
	    end_gun':			End_Gun,									# Used by widget subthreads to exit when main widget microthread exits.									#
	    endstate_oneshot:		Oneshot_Maildrop( ( Widget_Start_Fn,
							    Null_Or(Exception)						# saved_widget_state value used by arrowbutton etc to preserve state across gui stop/restart cycles.
							) ),								#
	    saved_widget_state:		Null_Or(Exception)								# When restarting a stopped gui this preserves the local state for (e.g.) arrowbutton.
	  }														# arrowbutton				is from   src/lib/x-kit/widget/leaf/arrowbutton.pkg


	also
	Widget_Exports
	  =
	  { guiboss_to_gadget:		Guiboss_To_Gadget,								# 
	    widgetspace_to_widget:	p2w::Widgetspace_To_Widget							# 
	  }



	#########################################################################################
	### Recursive  Object_Start_Fn  types

	also
	Object_Imports
	  =
	  { gadget_to_guiboss:		Gadget_To_Guiboss,								# 
	    object_to_objectspace:	o2c::Object_To_Objectspace,							# 
	    run_gun':			Run_Gun,									#
	    end_gun':			End_Gun,									# Used by widget subthreads to exit when main widget microthread exits.									#
	    endstate_oneshot:		Oneshot_Maildrop( ( Object_Start_Fn,
							    Null_Or(Exception)						# saved_object_state value used by arrowbutton etc to preserve state across gui stop/restart cycles.
							) ),								#
	    saved_object_state:		Null_Or(Exception)								# When restarting a stopped gui this preserves the local state for (e.g.) arrowbutton.
	  }

	also
	Object_Exports
	  =
	  { guiboss_to_gadget:		Guiboss_To_Gadget,								# 
	    objectspace_to_object:	c2o::Objectspace_To_Object							# 
	  }



	#########################################################################################
	### Recursive  Sprite_Start_Fn  types

	also
	Sprite_Imports
	  =
	  { gadget_to_guiboss:		Gadget_To_Guiboss,								# 
	    sprite_to_spritespace:	s2b::Sprite_To_Spritespace,							# 
	    run_gun':			Run_Gun,									#
	    end_gun':			End_Gun,									# Used by widget subthreads to exit when main widget microthread exits.									#
	    endstate_oneshot:		Oneshot_Maildrop( ( Sprite_Start_Fn, 						#
							    Null_Or(Exception)						# saved_sprite_state value used by arrowbutton etc to preserve state across gui stop/restart cycles.
							) ),
	    saved_sprite_state:		Null_Or(Exception)								# When restarting a stopped gui this preserves the local state for (e.g.) arrowbutton.
	  }

	also
	Sprite_Exports
	  =
	  { guiboss_to_gadget:		Guiboss_To_Gadget,								# 
	    spritespace_to_sprite:	b2s::Spritespace_To_Sprite							# 
	  }

	also
	Export_Gui = Xi_Widget;												# Synonym for improved readability;





	Mouse_Is													# Support for mouse drag operations.
	  #
	  = CROSSING_NONGADGET												# Mouse is not currently to be on any gadget.
	  #
	  | CROSSING_GADGET												# Mouse is currently on a gadget. Eventually we should issue ENTER and LEAVE events based on this. 	
	      { gadget_imp_info:	Gadget_Imp_Info									# This is the gadget on which the mouse is currently located. We send a LEAVE event when the mouse leaves it.
	      }
	  #
	  | DRAGGING_IN_GADGET												# Mouse is being dragged on this gadget.
	      { gadget_imp_info:	Gadget_Imp_Info,								# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
		start_point:		g2d::Point,									# This is the window coordinate of the downclick which started this drag.
		last_point:		g2d::Point									# This is the window coordinate of the last motion event for this drag.
	      }
	  ;

	Topwindow_Info
	  =
	  { # These three are valid throughout
	    # the lifetime of the topwindow:
	    #
	    guiboss_to_topwindow:			gtg::Guiboss_To_Topwindow,
	    current_frame_number:			Ref(Int),							# We count frames for convenience of widgets and debugging.
	    seconds_per_frame:				Ref(Float),							# Primarily so widgets can do motion blurring if they wish.

	    done_extra_redraw_request_this_frame:	Ref(Bool),							# See Note[3].

	    next_stacking_order:			Ref(Int),							# Next Subwindow_Or_View.stacking_order value to issue.
	    

															# The remainder are valid only while a gui is running,
															# which is to say, between restart_gui' and kill_gui' (or pause_gui', once we get it checked out).

	    mouse_is:					Ref( Mouse_Is ),						# Support for mouse drag operations.

	    subwindow_info:				Ref( Null_Or( Subwindow_Data ) ),

	    gadget_imps:				Gadget_Imps,							# Holds info on our gt::Gadget_Imp_Info        instances -- basically, all running widgets, sprites and objects in topwindow.
	    spritespace_imps:				Spritespace_Imps,						# Holds info on our gt::Guiboss_To_Spritespace instances -- all spritespace-imp.pkg instances for this topwindow.
	    objectspace_imps:				Objectspace_Imps,						# Holds info on our gt::Guiboss_To_Objectspace instances -- all objectspace-imp.pkg instances for this topwindow.
	    widgetspace_imps:				Widgetspace_Imps						# Holds info on our gt::Guiboss_To_Widgetspace instances -- all widgetspace-imp.pkg instances for this topwindow.
	  };




	#########################################################################################
	### Gadget_Imp_Info code

	fun same_gadget_imp_info
	      (
		{ guiboss_to_gadget => guiboss_to_gadget1, ... }:	Gadget_Imp_Info,	
		{ guiboss_to_gadget => guiboss_to_gadget2, ... }:	Gadget_Imp_Info
	      )
	    =
	    iul::same_id ( guiboss_to_gadget1.id,
			   guiboss_to_gadget2.id
			 );


	#########################################################################################
	### Subwindow_Or_View code

	fun subwindow_or_view_id_of    (SUBWINDOW_INFO r) =>  r.pixmap.id;
	    subwindow_or_view_id_of    (VIEWABLE_INFO  r) =>  r.pixmap.id;
	end; 

	fun subwindow_info_id_of    (SUBWINDOW_DATA r) =   r.pixmap.id;
	fun viewable_info_id_of     (r: Viewable_Info) =   r.pixmap.id;

	fun gadget_to_rw_pixmap__of (SUBWINDOW_INFO r) =>  r.pixmap;
	    gadget_to_rw_pixmap__of (VIEWABLE_INFO  r) =>  r.pixmap;
	end; 


# As of 2014-10-13 this appears to be nowhere used.
# If we don't find a use for it soon we should probably delete it.
# XXX SUCKO FIXME
	fun subwindow_or_view_is_visible (SUBWINDOW_INFO _)								# This fn is used for finding which widget was clicked on by user;  we're just trying to exclude widgets on de-selected views
		=>													# in TABPORT sets.  Consequently we don't worry about whether scrolling has made a pixmap actually not visible to user.
		TRUE;													# SUBWINDOW_INFO is by definition visible.

	    subwindow_or_view_is_visible (VIEWABLE_INFO r)								# A VIEWABLE_INFO is visible if it has *is_visible==TRUE and some chain of parents leading to a SUBWINDOW_INFO are also visible.
		=>
		if (not *r.is_visible)
		    #
		    FALSE;
		else
		    visible_in_at_least_one_parent  *r.ports								# This stab at supporting multiple scrollports/tabports onto a single pixmap probably doesn't work.  But we're not doing that yet anyhow.
		    where
			fun visible_in_at_least_one_parent ([]: List(Scrollport_Or_Tabport))
				=>
				FALSE;

			    visible_in_at_least_one_parent (r ! rest)
				=>
				if (subwindow_or_view_is_visible  r.parent_subwindow_or_view)
				    #
				    TRUE;
				else
				    visible_in_at_least_one_parent  rest;
				fi;
			end;
		    end;
		fi;
	end; 


	fun subwindow_or_view_id (bp: Subwindow_Or_View)
	    =
	    case bp
		#
		SUBWINDOW_INFO  {											# 
				    pixmap:		g2p::Gadget_To_Rw_Pixmap,					# 
				    stacking_order:	Int,
				    origin:		Ref(g2d::Point),
				    ...
				  }
		    =>
		    sprintf "SUBWINDOW_INFO with pixmap.id => %d  pixmap.size => %s   origin => %s  stacking_order => %d"  (id_to_int pixmap.id)  (g2j::size_to_string pixmap.size)  (g2j::point_to_string *origin)  stacking_order;

		VIEWABLE_INFO     { pixmap:		g2p::Gadget_To_Rw_Pixmap,					# The pixmap visible in the scrollport.
				    ...
				  }
		    =>
		    sprintf "VIEWABLE_INFO with pixmap.id => %d  pixmap.size => %s"  (id_to_int pixmap.id)  (g2j::size_to_string pixmap.size);
	    esac;

	fun subwindow_info_id (bp: Subwindow_Data)
	    =
	    case bp
		#
		SUBWINDOW_DATA  {											# 
				    pixmap:		g2p::Gadget_To_Rw_Pixmap,					# 
				    stacking_order:	Int,
				    origin:		Ref(g2d::Point),
				    ...
				  }
		    =>
		    sprintf "SUBWINDOW_DATA with pixmap.id => %d  pixmap.size => %s   origin => %s  stacking_order => %d"  (id_to_int pixmap.id)  (g2j::size_to_string pixmap.size)  (g2j::point_to_string *origin)  stacking_order;
	    esac;

	stipulate
	    fun die ()
		=
		{   msg = "arg should never be a VIEWABLE_INFO! -- find_all_subwindow_infos_above_given_subwindow_info_in_stacking_order in guiboss-types.pkg";
		    log::fatal msg;
		    raise exception FAIL msg;
		};

	herein
	    fun root_pixmap (subwindow_info:	Subwindow_Data)
		=
		case subwindow_info
		    #
		    SUBWINDOW_DATA r
			=>
			case r.parent
			    #
			    THE subwindow_info =>  root_pixmap subwindow_info;
			    NULL	       =>	       subwindow_info;
			esac;			    
		esac;


	    fun subwindow_info_origin_in_base_window_coordinates							# We support popups on popups, and each popup origin is relative to its parent, so we need to sum the origins of given subwindow_info plus all of its parents.
		  (
		    subwindow_info:	Subwindow_Info
		  )
		  :			g2d::Point
		=
		*subwindow_info.origin
		+
		(sum_of_parent_origins  subwindow_info)
		where
		    fun sum_of_parent_origins subwindow_info
			=
			case subwindow_info.parent
			    #
			    NULL => g2d::point::zero;
			    #
			    THE (SUBWINDOW_DATA r)
				=>
				*r.origin + (sum_of_parent_origins r);
			esac;
		end;

	    fun subwindow_info_of_subwindow_data
		  (
		    subwindow_info:	Subwindow_Data
		  )
		  :			Subwindow_Info
		=
		case subwindow_info
		    #
		    SUBWINDOW_DATA r => r;
		esac;

	    fun subwindow_info_of_subwindow_or_view									# Used in  make_rw_pixmap()  wrapper in  display_one_frame()  in  src/lib/x-kit/widget/gui/guiboss-imp.pkg
		  (
		    subwindow_or_view:	Subwindow_Or_View
		  )
		  :				Subwindow_Info
		=
		case subwindow_or_view
		    #
		    SUBWINDOW_INFO r => r;
		    #
		    VIEWABLE_INFO r
			=>
			case *r.ports											# List of scrollports/tabports in which viewable is (potentially) visible.
			    #
			    [ r ]  =>   {   subwindow_info_of_subwindow_or_view  r.parent_subwindow_or_view; };
			    #
			    _	   =>   {   msg = "Unsupported case in subwindow_info_of_subwindow_or_view/VIEWABLE_INFO --guiboss-types.pkg";
					    log::fatal msg;
					    raise exception FAIL msg;
					};
			esac;
		esac;

	    fun find_all_subwindow_datas_above_given_stacking_order							# Called below and also by   redraw_all_popups()   in   src/lib/x-kit/widget/gui/guiboss-imp.pkg
		  (
		    subwindow_info:	Subwindow_Data,
		    our_stacking_order:	Int
		  )
		  :			List( Subwindow_Data )								# 
		=
		case subwindow_info
		    #
		    SUBWINDOW_DATA r
			=>
{
# nb {. sprintf "find_all_subwindow_datas_above_given_stacking_order our_stacking_order d=%d r.stacking_order d=%d r.pixmap.id d=%d r.parent=%s #popups d=%d" our_stacking_order r.stacking_order (id_to_int r.pixmap.id) (case r.parent NULL => "NULL"; _ => "NON-null"; esac) (list::length *r.popups); };
			{    
# nb {. sprintf "find_all_subwindow_datas_above_given_stacking_order subwindow_info s=%s" (subwindow_or_view_id subwindow_info); };
			    subwindow_info =  root_pixmap subwindow_info;
# nb {. sprintf "find_all_subwindow_datas_above_given_stacking_order (root_pixmap subwindow_info) s=%s" (subwindow_or_view_id subwindow_info); };
# result =
			    find' subwindow_info;
# nb {. "find_all_subwindow_datas_above_given_stacking_order resultlist:"; };
# apply show_subwindow_or_view result
# where
#     fun show_subwindow_or_view (subwindow_or_view: Subwindow_Or_View)
# 	=
# 	nb {. sprintf "resultlist element == %s"  (subwindow_or_view_id subwindow_or_view); };
# end;
# 
# result;
			}
			where
			    fun find' tp
				=
{
# nb {. sprintf "find_all_subwindow_datas_above_given_stacking_order/find' tp s=%s" (subwindow_or_view_id tp); };
				case tp
				    #
				    SUBWINDOW_DATA (pm: Subwindow_Info)
					=>
					{
# nb {. sprintf "find_all_subwindow_datas_above_given_stacking_order/find' our_stacking_order=%d r.stacking_order=%d pm.stacking_order=%d r.pixmap.id=%d r.parent=%s #popups=%d" our_stacking_order r.stacking_order pm.stacking_order (id_to_int r.pixmap.id) (case r.parent NULL => "NULL"; _ => "NON-null"; esac) (list::length *r.popups); };
					    results =   if (pm.stacking_order > our_stacking_order)   [ tp ];
							else					      [    ];
							fi;	

# result =
					    list::cat  (results  !  (map find' *pm.popups));
# nb {. sprintf "find_all_subwindow_datas_above_given_stacking_order/find' our_stacking_order=%d r.stacking_order=%d r.pixmap.id=%d r.parent=%s #popups=%d #results=%d" our_stacking_order r.stacking_order (id_to_int r.pixmap.id) (case r.parent NULL => "NULL"; _ => "NON-null"; esac) (list::length *r.popups) (list::length result); };
# result;
					};

				esac;
};
			end;
};

		esac;

	    fun find_all_subwindow_infos_above_given_subwindow_or_view_in_stacking_order
		  (
		    subwindow_or_view:	Subwindow_Or_View
		  )
		  :			List( Subwindow_Info )								# By returning  List(Subwindow_Info)  rather than  List(Subwindow_Or_View)  we spare our caller the nuisance of dealing with all the impossible VIEWABLE_INFO cases.
		=
		case subwindow_or_view
		    #
		    SUBWINDOW_INFO r
			=>
			{   subwindow_infos
				=
				find_all_subwindow_datas_above_given_stacking_order
				  (
				    SUBWINDOW_DATA r,
				    r.stacking_order
				  );

			    subwindow_infos
				=
				map  subwindow_info_of_subwindow_data  subwindow_infos;


			    subwindow_infos;
			};

		    VIEWABLE_INFO { ports => REF ports, ... }								# A scrollport/tabport does not have an independent stacking order, it lies at the same stacking order as its parent. (Every scrollport/tabport has a non-port ancestor.)
			=>
			case ports
			    #
			    (port ! _)
				=>
				find_all_subwindow_infos_above_given_subwindow_or_view_in_stacking_order		# XXX SUCKO FIXME As yet we're not actually supporting multiple ports opening onto one shared viewable.
				    #
				    port.parent_subwindow_or_view;

			    []  =>  {   msg = "Empty scrollport/tabport list not supported in VIEWABLE_INFO -- find_all_subwindow_infos_above_given_subwindow_or_view_in_stacking_order";
					log::fatal msg;
					raise exception FAIL msg;
				    };
			esac;
		esac;

	    fun return_all_subwindow_infos_in_descending_stacking_order
		  (
		    null_or_subwindow_info:	Null_Or (Subwindow_Data)
		  )
		  :				List( Subwindow_Info )							# By returning  List(Subwindow_Info)  rather than  List(Subwindow_Or_View)  we spare our caller the nuisance of dealing with all the impossible VIEWABLE_INFO cases.
		=
		case null_or_subwindow_info
		    #
		    THE (subwindow_info as SUBWINDOW_DATA r)
			=>
			{   subwindow_datas
				=
				find_all_subwindow_datas_above_given_stacking_order
				  (
				    subwindow_info,
				    0
				  );

			    subwindow_infos
				=
				map  subwindow_info_of_subwindow_data  subwindow_datas;

			    subwindow_infos
				=
				lms::sort_list subwindow_info_gt subwindow_infos
				where
				    fun subwindow_info_gt
					  (
					    p1:	Subwindow_Info,
					    p2:	Subwindow_Info
					  )
					=
					p1.stacking_order < p2.stacking_order;
				end;

# nb {. "subwindow_infos in order:"; };
# apply print_pixmap_order subwindow_infos
# where
#     fun print_pixmap_order (p: Subwindow_Info)
# 	=
# 	nb {. sprintf "subwindow_info.stacking_order d=%d" p.stacking_order; };
# end;


			    subwindow_infos;
			};

		    NULL => [];
		esac;

	    fun adjust_origin (origin: g2d::Point, parent: Null_Or(Subwindow_Data))
		=
		case parent
		    #
		    NULL  =>    origin;
		    #
		    THE p =>    case p
				    #
				    SUBWINDOW_DATA (pm: Subwindow_Info)
					=>
					adjust_origin (origin + *pm.origin, pm.parent);
				esac;
		esac;

	    fun subwindow_info_site_in_basewindow_coordinates
		  (
		    subwindow_info:	Subwindow_Info
		  )
		=
		{	 
		    size   =    subwindow_info.pixmap.size;
		    #
		    origin =   *subwindow_info.origin;

		    origin =    adjust_origin (origin, subwindow_info.parent);

		   g2d::box::make (origin, size);
		};

# This is unused and should probably be deleted XXX SUCKO FIXME
	    fun translate_frombox_to_basewindow_coordinates
		  (
		    subwindow_info:	Subwindow_Info,
		    from_box:		g2d::Box
		  )
		=
		{   box_origin = g2d::box::upperleft from_box;
		    #
		    origin =   *subwindow_info.origin + box_origin;

		    origin =    adjust_origin (origin, subwindow_info.parent);

		    g2d::box::clone_box_at (from_box, origin);
		};
	end;





	#########################################################################################
	### widgetspace-imp code

	fun pprint_widgetspace_arg
	      (pp:		pp::Prettyprint_Mill)
	      (widgetspace_arg:	Widgetspace_Arg)
	    =
	    {
		widgetspace_arg
		    ->
		    (
			options:	List(Widgetspace_Option)
		    );

		pp.box {.
		    pp.txt "[ ";
		    pp::seqx {. pp.txt ", "; }
			    pprint_option
			    options
			    ;	
		    pp.txt " ]";
		    pp.lit ")";
		};
	    }
	    where
		fun pprint_option option
		    =
		    case option
			#
			PS_MICROTHREAD_NAME name =>  {  pp.lit (sprintf "PS_MICROTHREAD_NAME \"%s\"" name);	};
			PS_ID               id	 =>  {  pp.lit (sprintf "PS_ID %d" (id_to_int id)         );	};
			PS_CALLBACK _		 =>  {  pp.lit          "PS_CALLBACK (callback)";		};
		    esac;
	    end;




	#########################################################################################
	### objectspace-imp code


	fun pprint_objectspace_arg
	      (pp:			pp::Prettyprint_Mill)
	      (objectspace_arg:	Objectspace_Arg)
	    =
	    {
		objectspace_arg
		    ->
		    (
			options:	List(Objectspace_Option)
		    );

		pp.box {.
		    pp.txt "[ ";
		    pp::seqx {. pp.txt ", "; }
			    pprint_option
			    options
			    ;	
		    pp.txt " ]";
		    pp.lit ")";
		};
	    }
	    where
		fun pprint_option option
		    =
		    case option
			#
			CS_MICROTHREAD_NAME	name	=>  {  pp.lit (sprintf "CS_MICROTHREAD_NAME \"%s\"" name);	};
			CS_ID			id	=>  {  pp.lit (sprintf "CS_ID %d" (id_to_int id)         );	};
			CS_OBJECTSPACE_CALLBACK _	=>  {  pp.lit          "CS_OBJECTSPACE_CALLBACK (callback)";	};
		    esac;
	    end;


	#########################################################################################
	### spritespace-imp code

	fun pprint_spritespace_arg
	      (pp:			pp::Prettyprint_Mill)
	      (spritespace_arg:		Spritespace_Arg)
	    =
	    {
		spritespace_arg
		    ->
		    (
			options:	List(Spritespace_Option)
		    );

		pp.box {.
		    pp.txt "[ ";
		    pp::seqx {. pp.txt ", "; }
			    pprint_option
			    options
			    ;	
		    pp.txt " ]";
		    pp.lit ")";
		};
	    }
	    where
		fun pprint_option option
		    =
		    case option
			#
			OS_MICROTHREAD_NAME name	=>  {  pp.lit (sprintf "OS_MICROTHREAD_NAME \"%s\"" name);	};
			OS_ID               id		=>  {  pp.lit (sprintf "OS_ID %d" (id_to_int id)          );	};
			OS_SPRITESPACE_CALLBACK _	=>  {  pp.lit          "OS_SPRITESPACE_CALLBACK (callback)";	};
		    esac;
	    end;



	#########################################################################################
	### gui-plan code


	Gui_Plan_Apply_Option												# The following gui_plan_apply() facility allows clients to iterate over nodes in a Gui_Plan tree without having to write out the whole recursion.
	  #
	  = GP_ROW_FN		(Gp_Row	 	-> Void)					# Call this fn on ROW    	     nodes in Gui_Plan. Defaults to null fn.
	  | GP_COL_FN		(Gp_Col 	-> Void)					# Call this fn on COL    	     nodes in Gui_Plan. Defaults to null fn.
	  #
	  | GP_ROW'_FN		(Gp_Row'	-> Void)					# Call this fn on ROW'    	     nodes in Gui_Plan. Defaults to null fn.
	  | GP_COL'_FN		(Gp_Col' 	-> Void)					# Call this fn on COL'    	     nodes in Gui_Plan. Defaults to null fn.
	  #
	  | GP_GRID_FN		(Gp_Grid 	-> Void)					# Call this fn on GRID               nodes in Gui_Plan. Defaults to null fn.
	  | GP_SCROLLPORT_FN	(Gp_Scrollport 	-> Void)					# Call this fn on SCROLLPORT	     nodes in Gui_Plan. Defaults to null fn.
	  | GP_TABPORT_FN	(Gp_Tabport	-> Void)					# Call this fn on TABPORT	     nodes in Gui_Plan. Defaults to null fn.
	  #
	  | GP_FRAME_FN		(Gp_Frame 	-> Void)					# Call this fn on FRAME              nodes in Gui_Plan. Defaults to null fn.
	  | GP_WIDGET_FN	(Gpwidget	-> Void)					# Call this fn on WIDGET             nodes in Gui_Plan. Defaults to null fn.
	  ;


	fun gui_plan_apply
	      (
		gui_plan as	( gp_widget:		Gp_Widget
				),
		options:	List( Gui_Plan_Apply_Option )
	      )
	    =
	    do_gp_widget  gp_widget
	    where

		fun process_options  (options:  List(Gui_Plan_Apply_Option))
		    =
		    {   null_fn = (\\ (x: X) = ());
			#
			my_row_fn			=  REF  null_fn;
			my_col_fn			=  REF  null_fn;
			#
			my_row'_fn			=  REF  null_fn;
			my_col'_fn			=  REF  null_fn;
			#
			my_grid_fn			=  REF  null_fn;
			my_scrollport_fn		=  REF  null_fn;
			my_tabport_fn			=  REF  null_fn;
			my_frame_fn			=  REF  null_fn;
			my_widget_fn			=  REF  null_fn;

			apply  do_option  options
			where
			    fun do_option (GP_ROW_FN			fn) =>  my_row_fn			:=  fn;
				do_option (GP_COL_FN			fn) =>  my_col_fn			:=  fn;
				#
				do_option (GP_ROW'_FN			fn) =>  my_row'_fn			:=  fn;
				do_option (GP_COL'_FN			fn) =>  my_col'_fn			:=  fn;
				#
				do_option (GP_GRID_FN			fn) =>  my_grid_fn			:=  fn;
				do_option (GP_SCROLLPORT_FN		fn) =>  my_scrollport_fn		:=  fn;
				do_option (GP_TABPORT_FN		fn) =>  my_tabport_fn			:=  fn;
				do_option (GP_FRAME_FN			fn) =>  my_frame_fn			:=  fn;
				do_option (GP_WIDGET_FN			fn) =>  my_widget_fn			:=  fn;
			    end;
			end;

			{ row_fn			=>  *my_row_fn,
			  col_fn			=>  *my_col_fn,
			  #
			  row'_fn			=>  *my_row'_fn,
			  col'_fn			=>  *my_col'_fn,
			  #
			  grid_fn			=>  *my_grid_fn,
			  scrollport_fn			=>  *my_scrollport_fn,
			  tabport_fn			=>  *my_tabport_fn,
			  frame_fn			=>  *my_frame_fn,
			  widget_fn			=>  *my_widget_fn
			};
		    };

		options =  process_options  options;

		fun do_gp_widget (gp_widget: Gp_Widget)
		    =
		    case gp_widget
			#
			ROW (arg:	Gp_Row)
			    =>
			    {   arg -> (widgets:	List( Gp_Widget ));
				#
				apply	do_gp_widget  widgets;

				options.row_fn  arg;
			    };

			COL (arg:	Gp_Col)
			    =>
			    {   arg -> (widgets:	List( Gp_Widget ));
				#
				apply	do_gp_widget  widgets;

				options.col_fn  arg;
			    };

			ROW' (arg:	Gp_Row')
			    =>
			    {   arg ->  ( id:		Id,
					  widgets:	List( Gp_Widget )
					);
				#
				apply	do_gp_widget  widgets;

				options.row'_fn  arg;
			    };

			COL' (arg:	Gp_Col')
			    =>
			    {   arg ->  ( id:		Id,
					  widgets:	List( Gp_Widget )
					);
				#
				apply	do_gp_widget  widgets;

				options.col'_fn  arg;
			    };

			GRID (arg:	Gp_Grid)
			    =>
			    {   arg ->  (widgets:	List( List( Gp_Widget ) ));
				#
				apply	do_widgets   widgets
					where
					    fun do_widgets (widgets: List(Gp_Widget))
						=
						apply do_gp_widget widgets;
					end;

				options.grid_fn  arg;
			    };

			SCROLLPORT (arg:	Gp_Scrollport)
			    =>
			    {   arg ->  { scroller_callback:	Scroller_Callback,
					  scrollable:		Gp_Scrollable
					};

				case scrollable
				    #
				    SCROLLABLE	{ id:		Id,									# Id by which this SCROLLABLE may be referenced in SCROLLABLE_ID values.
						  pixmap_size:	g2d::Size,								# Size of pixmap visible in scrollport.
						  widget:	Gp_Widget								# Widget-tree providing content visible in scrollport -- will be rendered onto pixmap.
						}
					=>
					do_gp_widget  widget;

				    SCROLLABLE_ID id => ();
				esac;

				options.scrollport_fn  arg;
			    };

			TABPORT (arg:	Gp_Tabport)
			    =>
			    {   arg ->  ( tab_picker_callback:	Tab_Picker_Callback,
					  pixmap_size:		g2d::Size,
					  tabs:			List( Gp_Widget )							# *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST ***
					);

				apply  do_gp_widget  tabs;

				options.tabport_fn  arg;
			    };

			FRAME (arg:	Gp_Frame)
			    =>
			    {   arg ->  ( frame_options:	List(Frame_Option),
					  widget:		Gp_Widget
					);

				do_gp_widget widget;
					    #
				options.frame_fn  arg;
			    };

			WIDGET (arg:	Gpwidget)
			    =>
			    {   arg ->  (widget_start_fn:	Widget_Start_Fn);
				#
				options.widget_fn  arg;
			    };

			OBJECTSPACE (arg:	Gp_Objectspace)
			    =>
			    {   arg ->  ( objectspace_options:	List( Objectspace_Option ),
					  objects:		List( Gp_Object )
					);

				# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.

				();
			    };

			SPRITESPACE (arg:	Gp_Spritespace)
			    =>
			    {   arg ->  ( spritespace_options:	List( Spritespace_Option ),
					  sprites:		List( Gp_Sprite )
					);

				# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.

				();
			    };

			NULL_WIDGET
			    =>
			    {
				();									# Move along, nothing to see here.
			    };
		    esac;
	    end;


	fun pprint_gui_plan (gui_plan: Gui_Plan)							# "pprint" == "prettyprint".
	    =
	    pp::with_standard_prettyprint_mill
		#
		(err::default_plaint_sink ())	[]
		#
		(\\ pp:   pp::Prettyprint_Mill
		    =
		    do_gui_plan  gui_plan
		    where
			fun do_gui_plan  gui_plan
			    =
			    do_gp_widget    gui_plan

			also
			fun do_widgetspace
			      ( widgetspace_arg:	Widgetspace_Arg,
				gp_widget:		Gp_Widget
			      )
			    =
			    {   pp.box {.
				    do_widgetspace_arg  widgetspace_arg;
				    do_gp_widget     gp_widget;
				};
				pp.newline();
			    }

			also
			fun do_spritespace
			      (
				spritespace_arg:	Spritespace_Arg,
				pg_sprites:		List(  Gp_Sprite  )
			      )
			    =
			    {   pp.box {.
				    do_spritespace_arg  spritespace_arg;
				    do_pg_sprites   	pg_sprites;
				};
				pp.newline();
			    }

			also
			fun do_spritespace_arg  (spritespace_arg:	Spritespace_Arg)
			    =
			    {
				pprint_spritespace_arg  pp  spritespace_arg;
				pp.newline();
			    }


			also
			fun do_pg_sprites  (gp_sprites:		List( Gp_Sprite ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";

				    fun do_sprite (gp_sprite: Gp_Sprite)
					=
					pp.box {.
					    do_gp_sprite			gp_sprite;
					    pp.endlit ",";
					    pp.txt " ";
					};

				    pp::seqx
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_sprite				# Print one list element.
					gp_sprites;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_gp_sprite  (gp_sprite:	Gp_Sprite)
			    =
			    case gp_sprite
				#
				SPRITE _
				    =>
				    {
					pp.box {.
					    pp.lit  "SPRITE _";
					};
					pp.newline();
				    };
			    esac

			also
			fun do_objectspace
			      (
				objectspace_arg:	Objectspace_Arg,
				object_widgets:		List(  Gp_Object )
			      )
			    =
			    {   pp.box {.
				    do_objectspace_arg  objectspace_arg;
				    do_object_widgets    object_widgets;
				};
				pp.newline();
			    }

			also
			fun do_objectspace_arg  (objectspace_arg:	Objectspace_Arg)
			    =
			    {
				pprint_objectspace_arg  pp  objectspace_arg;
				pp.newline();
			    }

			also
			fun do_object_widgets  (object_widgets:		List( Gp_Object ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";


				    fun do_widget (object_widget: Gp_Object)
					=
					pp.box {.
					    do_object_widget			object_widget;
					    pp.endlit ",";
					    pp.txt " ";
					};

				    pp::seqx
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					object_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_object_widget  (object_widget:	Gp_Object)
			    =
			    case object_widget
				#
				OBJECT _
				    =>
				    {
					pp.box {.
					    pp.lit  "OBJECT _";
					};
					pp.newline();
				    };

			        WIDGETSPACE  widgetspace
				    =>
				    {
					pp.lit  "WIDGETSPACE ";
					pp.newline();
					do_widgetspace widgetspace;
					pp.newline();
				    };
			    esac

			also
			fun do_widgetspace_arg  (widgetspace_arg:	Widgetspace_Arg)
			    =
			    {
				pprint_widgetspace_arg  pp  widgetspace_arg;
				pp.newline();
			    }

			also
			fun do_gp_widget  (gp_widget:	Gp_Widget)
			    =
			    case gp_widget
				#
			        ROW	(widgets:	 List( Gp_Widget ))
				    =>
				    {
					pp.box' 0 -1 {.
					    pp.lit  "ROW [";
					    pp.ind 2;
					    pp.txt " ";

					    fun do_widget (gp_widget: Gp_Widget)
						=
						pp.box {.
						    do_gp_widget			gp_widget;
						    pp.endlit ",";
						};

					    pp::seqx
						{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
						do_widget				# Print one list element.
						widgets;				# List of elements.

					    pp.ind 0;
					    pp.txt " ";
					    pp.lit "]";
					};
				    };

			        COL	(a:	 List( Gp_Widget ))
				    =>
				    {
					pp.lit  "COL";
					pp.newline();
				    };

			        ROW' (id, a:	 List( Gp_Widget ))
				    =>
				    {
					pp.lit  "ROW'";
					pp.newline();
				    };

			        COL' (id, a:	 List( Gp_Widget ))
				    =>
				    {
					pp.lit  "COL'";
					pp.newline();
				    };

			        GRID	(a: List( List( Gp_Widget )))
				    =>
				    {
					pp.lit  "GRID ... ";
					pp.newline();
				    };

				SCROLLPORT _
				    =>
				    {
					pp.box {.
					    pp.lit  "SCROLLPORT _";
					};
					pp.newline();
				    };

				TABPORT _
				    =>
				    {
					pp.box {.
					    pp.lit  "TABPORT _";
					};
					pp.newline();
				    };

				FRAME _
				    =>
				    {
					pp.box {.
					    pp.lit  "FRAME _";
					};
					pp.newline();
				    };

				WIDGET _
				    =>
				    {
					pp.box {.
					    pp.lit  "WIDGET _";
					};
					pp.newline();
				    };

			        OBJECTSPACE (objectspace:	(Objectspace_Arg,  List( Gp_Object)))
				    =>
				    {
					pp.lit  "OBJECTSPACE";
					do_objectspace  objectspace;
					pp.newline();
				    };

			        SPRITESPACE (spritespace:	(Spritespace_Arg,  List( Gp_Sprite )))
				    =>
				    {
					pp.lit  "SPRITESPACE";
					do_spritespace  spritespace;
					pp.newline();
				    };
			      
			        NULL_WIDGET
				    =>
				    {
					pp.lit  "NULL_WIDGET";
					pp.newline();
				    };
			    esac;
		    end
		);

	#########################################################################################
	### stopped-gui code

	fun pprint_paused_gui (paused_gui: Paused_Gui)								# "pprint" == "prettyprint".
	    =
	    pp::with_standard_prettyprint_mill
		#
		(err::default_plaint_sink ())	[]
		#
		(\\ pp:   pp::Prettyprint_Mill
		    =
		    do_paused_gui  paused_gui
		    where
			fun do_paused_gui  paused_gui
			    =
			    do_widgetspace  paused_gui

			also
			fun do_widgetspace
			      ( widgetspace_arg:	Widgetspace_Arg,
				pg_widget:		Pg_Widget
			      )
			    =
			    {   pp.box {.
				    do_widgetspace_arg  widgetspace_arg;
				    do_pg_widget     pg_widget;
				};
				pp.newline();
			    }

			also
			fun do_spritespace
			      (
				spritespace_arg:	Spritespace_Arg,
				pg_sprites:		List( Pg_Sprite )
			      )
			    =
			    {   pp.box {.
				    do_spritespace_arg  spritespace_arg;
				    do_pg_sprites   	pg_sprites;
				};
				pp.newline();
			    }

			also
			fun do_spritespace_arg  (spritespace_arg:	Spritespace_Arg)
			    =
			    {
				pprint_spritespace_arg  pp  spritespace_arg;
				pp.newline();
			    }


			also
			fun do_pg_sprites  (pg_sprites:		List( Pg_Sprite ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";

				    fun do_sprite (pg_sprite: Pg_Sprite)
					=
					pp.box {.
					    do_pg_sprite   pg_sprite;
					    pp.endlit ",";
					    pp.txt " ";
					};

				    pp::seqx
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_sprite				# Print one list element.
					pg_sprites;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_pg_sprite  (pg_sprite:	Pg_Sprite)
			    =
			    case pg_sprite
				#
			        PG_SPRITE ( fn:			Sprite_Start_Fn,
					    saved_sprite_state:	Null_Or(Exception)
					  )
				    =>
				    {
					pp.box {.
					    pp.lit  "SPRITE _";
					};
					pp.newline();
				    };

# 			        SG_BALL	( ball_arg:		c2b::Make_Arg,
# 					  ball_look_arg:	bli::Sprite_Look_Arg
# 					)
# 				    =>
# 				    {
# 					pp.box {.
# 					    pp.lit  "BALL (";		pp.txt " ";
# 					    bsi::pprint_make_arg  pp  ball_arg;
# 					    pp.txt ", ";
# 					    blx::pprint_sprite_look_arg  pp  ball_look_arg;
# 					    pp.lit  ")";
# 					};
# 					pp.newline();
# 				    };
			    esac

			also
			fun do_objectspace
			      (
				objectspace_arg:	Objectspace_Arg,
				object_widgets:		List( Pg_Object )
			      )
			    =
			    {   pp.box {.
				    do_objectspace_arg  objectspace_arg;
				    do_object_widgets    object_widgets;
				};
				pp.newline();
			    }

			also
			fun do_objectspace_arg  (objectspace_arg:	Objectspace_Arg)
			    =
			    {
				pprint_objectspace_arg  pp  objectspace_arg;
				pp.newline();
			    }

			also
			fun do_object_widgets  (object_widgets:		List(  ( /* List(clh::Objectspace_Layout_Hint), */  Pg_Object)  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";


				    fun do_widget (object_widget:	Pg_Object)
					=
					pp.box {.
					    do_object_widget			object_widget;
					    pp.endlit ",";
					    pp.txt " ";
					};

				    pp::seqx
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					object_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_object_widget  (object_widget:	Pg_Object)
			    =
			    case object_widget
				#
				PG_OBJECT ( fn:			Object_Start_Fn,
					    saved_object_state:	Null_Or(Exception)
					  )
				    =>
				    {
					pp.box {.
					    pp.lit  "PG_OBJECT _";
					};
					pp.newline();
				    };

			        PG_WIDGETSPACE  widgetspace
				    =>
				    {
					pp.lit  "PG_WIDGETSPACE ";
					pp.newline();
					do_widgetspace widgetspace;
					pp.newline();
				    };
			    esac

			also
			fun do_widgetspace_arg  (widgetspace_arg:	Widgetspace_Arg)
			    =
			    {
				pprint_widgetspace_arg  pp  widgetspace_arg;
				pp.newline();
			    }

			also
			fun do_pg_widget  (pg_widget:	Pg_Widget)
			    =
			    case pg_widget
				#
			        PG_ROW	(id,  widgets:	 List( Pg_Widget ))
				    =>
				    {
					pp.box' 0 -1 {.
					    pp.lit  "PG_ROW [";
					    pp.ind 2;
					    pp.txt " ";

					    fun do_widget (pg_widget: Pg_Widget)
						=
						pp.box {.
						    do_pg_widget  pg_widget;
						    pp.endlit ",";
						    pp.txt " ";
						};

					    pp::seqx
						{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
						do_widget				# Print one list element.
						widgets;				# List of elements.

					    pp.ind 0;
					    pp.txt " ";
					    pp.lit "]";
					};
				    };

			        PG_COL	(id,  a:	 List( Pg_Widget ))
				    =>
				    {
					pp.lit  "PG_COL";
					pp.newline();
				    };

			        PG_GRID	(a: List( List( Pg_Widget )) )
				    =>
				    {
					pp.lit  "PG_GRID";
					pp.newline();
				    };

			        PG_SCROLLPORT _
				    =>
				    {
					pp.lit  "PG_SCROLLPORT";
					pp.newline();
				    };

			        PG_TABPORT (a:	(Tab_Picker_Callback,  g2d::Size,  List( Pg_Widget)))
				    =>
				    {
					pp.lit  "PG_TABPORT";
					pp.newline();
				    };

			        PG_FRAME _
				    =>
				    {
					pp.lit  "PG_FRAME ... ";
					pp.newline();
				    };

			        PG_WIDGET ( fn:			Widget_Start_Fn,
					    saved_widget_state:	Null_Or(Exception)
					  )
				    =>
				    {
					pp.box {.
					    pp.lit  "PG_WIDGET _";
					};
					pp.newline();
				    };


			        PG_OBJECTSPACE (objectspace:	(Objectspace_Arg,  List( Pg_Object )))
				    =>
				    {
					pp.lit  "PG_OBJECTSPACE";
					do_objectspace  objectspace;
					pp.newline();
				    };

			        PG_SPRITESPACE (spritespace:	(Spritespace_Arg,  List( Pg_Sprite )))
				    =>
				    {
					pp.lit  "PG_SPRITESPACE";
					do_spritespace  spritespace;
					pp.newline();
				    };
			      
			        PG_NULL_WIDGET
				    =>
				    {
					pp.lit  "PG_NULL_WIDGET";
					pp.newline();
				    };
			    esac;
		    end
		);



	#########################################################################################
	### paused-gui code

	Paused_Gui_Apply_Option												# The following paused_gui_apply() facility allows clients to iterate over nodes in a Paused_Gui tree without having to write out the whole recursion.
	  #
	  = PG_ROW_FN		((Id, List( Pg_Widget ) )	 	-> Void)					# Call this fn on PG_ROW    	     nodes in Paused_Gui. Defaults to null fn.
	  | PG_COL_FN		((Id, List( Pg_Widget ) )	 	-> Void)					# Call this fn on PG_COL    	     nodes in Paused_Gui. Defaults to null fn.
	  #
	  | PG_GRID_FN		(List( List( Pg_Widget ) )	 	-> Void)					# Call this fn on PG_GRID            nodes in Paused_Gui. Defaults to null fn.
	  | PG_SCROLLPORT_FN	({ scroller_callback:	Scroller_Callback,
				   scrollable:		Pg_Scrollable							# What to show in the scrollport.
				 }				 	-> Void)					# Call this fn on PG_SCROLLPORT	     nodes in Paused_Gui. Defaults to null fn.
	  | PG_TABPORT_FN	(( Tab_Picker_Callback,
				   g2d::Size,
				   List(Pg_Widget)									# 
				 )				 	-> Void)					# Call this fn on PG_TABPORT	     nodes in Paused_Gui. Defaults to null fn.
	  | PG_FRAME_FN		((Pg_Widget, Pg_Widget)		 	-> Void)					# Call this fn on PG_FRAME           nodes in Paused_Gui. Defaults to null fn.
	  | PG_WIDGET_FN	(( Widget_Start_Fn,Null_Or(Exception))	-> Void)					# Call this fn on PG_WIDGET          nodes in Paused_Gui. Defaults to null fn.
	  ;


	fun paused_gui_apply
	      (
		paused_gui as	( widgetspace_arg:	Widgetspace_Arg,
				  pg_widget:		Pg_Widget
				),
		options:	List( Paused_Gui_Apply_Option )
	      )
	    =
	    do_pg_widget  pg_widget
	    where

		fun process_options  (options:  List(Paused_Gui_Apply_Option))
		    =
		    {   null_fn = (\\ (x: X) = ());
			#
			my_row_fn			=  REF  null_fn;
			my_col_fn			=  REF  null_fn;
			#
			my_grid_fn			=  REF  null_fn;
			my_scrollport_fn		=  REF  null_fn;
			my_tabport_fn			=  REF  null_fn;
			my_frame_fn			=  REF  null_fn;
			my_widget_fn			=  REF  null_fn;

			apply  do_option  options
			where
			    fun do_option (PG_ROW_FN			fn) =>  my_row_fn			:=  fn;
				do_option (PG_COL_FN			fn) =>  my_col_fn			:=  fn;
				#
				do_option (PG_GRID_FN			fn) =>  my_grid_fn			:=  fn;
				do_option (PG_SCROLLPORT_FN		fn) =>  my_scrollport_fn		:=  fn;
				do_option (PG_TABPORT_FN		fn) =>  my_tabport_fn			:=  fn;
				do_option (PG_FRAME_FN			fn) =>  my_frame_fn			:=  fn;
				do_option (PG_WIDGET_FN			fn) =>  my_widget_fn			:=  fn;
			    end;
			end;

			{ row_fn			=>  *my_row_fn,
			  col_fn			=>  *my_col_fn,
			  #
			  grid_fn			=>  *my_grid_fn,
			  scrollport_fn			=>  *my_scrollport_fn,
			  tabport_fn			=>  *my_tabport_fn,
			  frame_fn			=>  *my_frame_fn,
			  widget_fn			=>  *my_widget_fn
			};
		    };

		options =  process_options  options;

		fun do_pg_widget (pg_widget: Pg_Widget)
		    =
		    case pg_widget
			#
			PG_ROW (row as (id, widgets)) =>
					{
					    apply do_widget widgets
						where
						    fun do_widget (widget: Pg_Widget)
							=
							do_pg_widget  widget;
						end;

					    options.row_fn row;
					};

			PG_COL (col as (id, widgets)) =>
					{
					    apply do_widget widgets
						where
						    fun do_widget (widget: Pg_Widget)
							=
							do_pg_widget  widget;
						end;

					    options.col_fn col;
					};

			PG_GRID widgets =>  {   apply do_widgets widgets
						where
						    fun do_widgets (widgets: List(Pg_Widget))
							=
							apply do_widget widgets
							where
							    fun do_widget (widget: Pg_Widget)
								=
								do_pg_widget widget;
							end;
						end;

					    options.grid_fn  widgets;
					};

			PG_SCROLLPORT view
			    =>		{   case view.scrollable
						#
						PG_SCROLLABLE { id, pixmap_size, pg_widget }
						    =>
						    do_pg_widget  pg_widget;

						PG_SCROLLABLE_ID id => ();
					    esac;	

					    #
					    options.scrollport_fn  view;
					};

			PG_TABPORT (tabs as (tab_picker_callback, pixmap_size, pg_widgets))
			    =>		{
					    apply  do_pg_widget  pg_widgets;
					    #
					    options.tabport_fn tabs;
					};

			PG_FRAME (f as (frame_widget, widget))
			    =>		{
					    do_pg_widget frame_widget;
					    do_pg_widget widget;
					    #
					    options.frame_fn  f;
					};

			PG_WIDGET widget
			    =>		{   options.widget_fn  widget;
					};

			PG_OBJECTSPACE space
			    =>		{   ();											# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
					};
			PG_SPRITESPACE space
			    =>		{   ();											# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
					};
			PG_NULL_WIDGET
			    =>		{   ();
					};
		    esac;
	    end;


	#########################################################################################
	### running-gui code

	fun widget_site (rg_widget: Rg_Widget)
	    =
	    case rg_widget
		#
		RG_ROW 		r	=>  *r.site;
		RG_COL 		r	=>  *r.site;
		RG_GRID 	r	=>  *r.site;
		RG_SCROLLPORT	r	=>  *r.site;
		RG_TABPORT 	r	=>  *r.site;
		RG_FRAME 	r	=>  *r.site;
		RG_WIDGET 	r	=>  *r.site;
		RG_OBJECTSPACE  r	=>  *r.site;
		RG_SPRITESPACE  r	=>  *r.site;
		#
		RG_NULL_WIDGET		=>  g2d::box::zero;
	    esac;



	Running_Gui_Map_Option												# The following running_gui_map() facility allows clients to rewrite a Running_Gui tree without having to write out the whole recursion.
	  #
	  = ROW_MAP_FN		(Rg_Row		 -> Rg_Row)								# Call this fn on RG_ROW    	     nodes in Running_Gui. Defaults to null fn.
	  | COL_MAP_FN		(Rg_Col		 -> Rg_Col)								# Call this fn on RG_COL    	     nodes in Running_Gui. Defaults to null fn.
	  | GRID_MAP_FN		(Rg_Grid	 -> Rg_Grid)								# Call this fn on RG_GRID            nodes in Running_Gui. Defaults to null fn.
	  | SCROLLPORT_MAP_FN	(Rg_Scrollport   -> Rg_Scrollport)							# Call this fn on RG_SCROLLPORT	     nodes in Running_Gui. Defaults to null fn.
	  | TABPORT_MAP_FN	(Rg_Tabport	 -> Rg_Tabport)								# Call this fn on RG_TABPORT	     nodes in Running_Gui. Defaults to null fn.
	  | FRAME_MAP_FN	(Rg_Frame	 -> Rg_Frame)								# Call this fn on RG_FRAME           nodes in Running_Gui. Defaults to null fn.
	  | WIDGET_MAP_FN	(Rgwidget	 -> Rgwidget)								# Call this fn on RG_WIDGET          nodes in Running_Gui. Defaults to null fn.
	  ;

	fun running_gui_map
	      (
		running_gui:	Running_Gui,
		options:	List( Running_Gui_Map_Option )
	      )
	    :			Running_Gui
	    =
	    {   running_gui ->	  { fire_end_gun:		Void -> Void,						# Calling this fn will cause all state and look imps in the gui to exit, saving their state to their oneshots.
				    widgetspace_id:		Widgetspace_Id,						# guiboss-imp indexes this value into *widget_imps to obtain (e.g.) a Guiboss_To_Widgetspace port to the widgetspace-imp.
				    rg_widget:			Rg_Widget,						# The widget (or more commonly, tree of widgets) managed by the gui-tree's toplevel widgetspace-imp.
				    topwindow:			gtg::Guiboss_To_Topwindow,				# The topwindow on which to draw our widgets.
				    subwindow_info:		Subwindow_Data,						# Holds toplevel SUBWINDOW_DATA for gui.
				    #
				    gadget_imps_for_gui:	Gadget_Imps,						# Holds our gt::Gadget_Imp_Info        instances for this running gui.
				    spritespace_imps_for_gui:	Spritespace_Imps,					# Holds our gt::Guiboss_To_Spritespace instances for this running gui.
				    objectspace_imps_for_gui:	Objectspace_Imps,					# Holds our gt::Guiboss_To_Objectspace instances for this running gui.
				    widgetspace_imps_for_gui:	Widgetspace_Imps					# Holds our gt::Guiboss_To_Widgetspace instances for this running gui.
				  };

		rg_widget =  do_rg_widget  rg_widget;

		running_gui =	  { fire_end_gun,
				    widgetspace_id,
				    rg_widget,
				    topwindow,
				    subwindow_info,
				    #
				    gadget_imps_for_gui,
				    spritespace_imps_for_gui,
				    objectspace_imps_for_gui,
				    widgetspace_imps_for_gui
				  };
		running_gui;
	    }
	    where

		fun process_options  (options:  List(Running_Gui_Map_Option))
		    =
		    {   null_fn = (\\ (x: X) = x);
			#
			my_row_fn			=  REF  null_fn;
			my_col_fn			=  REF  null_fn;
			#
			my_grid_fn			=  REF  null_fn;
			my_scrollport_fn		=  REF  null_fn;
			my_tabport_fn			=  REF  null_fn;
			my_frame_fn			=  REF  null_fn;
			my_widget_fn			=  REF  null_fn;

			apply  do_option  options
			where
			    fun do_option (ROW_MAP_FN			fn) =>  my_row_fn			:=  fn;
				do_option (COL_MAP_FN			fn) =>  my_col_fn			:=  fn;
				#
				do_option (GRID_MAP_FN			fn) =>  my_grid_fn			:=  fn;
				do_option (SCROLLPORT_MAP_FN		fn) =>  my_scrollport_fn		:=  fn;
				do_option (TABPORT_MAP_FN		fn) =>  my_tabport_fn			:=  fn;
				do_option (FRAME_MAP_FN			fn) =>  my_frame_fn			:=  fn;
				do_option (WIDGET_MAP_FN		fn) =>  my_widget_fn			:=  fn;
			    end;
			end;

			{ row_fn			=>  *my_row_fn,
			  col_fn			=>  *my_col_fn,
			  #
			  grid_fn			=>  *my_grid_fn,
			  scrollport_fn			=>  *my_scrollport_fn,
			  tabport_fn			=>  *my_tabport_fn,
			  frame_fn			=>  *my_frame_fn,
			  widget_fn			=>  *my_widget_fn
			};
		    };

		options =  process_options  options;

		fun do_rg_widget (rg_widget: Rg_Widget)
		    =
		    case rg_widget
			#
			RG_ROW (arg:	Rg_Row)
			    =>
			    {   arg ->	  { id:				Id,
					    widgets:			List( Rg_Widget ),								# The list of widgets to be laid out and displayed in this row.
					    #
					    pixels_high_min: 		Ref(Int),									# Minimum            vertical   pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_min: 		Ref(Int),									# Minimum            horizontal pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    pixels_high_cut: 		Ref(Float),									# Share of remaining vertical   pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_cut: 		Ref(Float),									# Share of remaining horizontal pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				widgets =  map do_rg_widget widgets;

				arg =	  { id,
					    widgets,
					    #
					    pixels_high_min,
					    pixels_wide_min,
					    #
					    pixels_high_cut,
					    pixels_wide_cut,
					    #
					    site
					  };

				RG_ROW (options.row_fn  arg);
			    };

			RG_COL (arg:	Rg_Col)
			    =>
			    {   arg ->	  { id:				Id,
					    widgets:			List( Rg_Widget ),								# The list of widgets to be laid out and displayed in this row.
					    #
					    pixels_high_min: 		Ref(Int),									# Minimum            vertical   pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_min: 		Ref(Int),									# Minimum            horizontal pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    pixels_high_cut: 		Ref(Float),									# Share of remaining vertical   pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_cut: 		Ref(Float),									# Share of remaining horizontal pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				widgets =  map do_rg_widget widgets;

				arg =	  { id,
					    widgets,
					    #
					    pixels_high_min,
					    pixels_wide_min,
					    #
					    pixels_high_cut,
					    pixels_wide_cut,
					    #
					    site
					  };

				RG_COL (options.col_fn  arg);
			    };

			RG_GRID (arg:	Rg_Grid)
			    =>
			    {   arg ->	  { widgets:			List(	List( Rg_Widget )   ),							# The list lists of widgets to be laid out and displayed in this grid.
					    #
					    pixels_high_min: 		Ref(Int),									# Minimum            vertical   pixels to allocate for this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_min: 		Ref(Int),									# Minimum            horizontal pixels to allocate for this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    pixels_high_cut: 		Ref(Float),									# Share of remaining vertical   pixels to allocate to  this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_cut: 		Ref(Float),									# Share of remaining horizontal pixels to allocate to  this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				widgets =  map  do_widgets  widgets
						where
						    fun do_widgets (widgets: List(Rg_Widget))
							=
							map  do_rg_widget  widgets;
						end;

				arg =	  { widgets,
					    #
					    pixels_high_min,
					    pixels_wide_min,
					    #
					    pixels_high_cut,
					    pixels_wide_cut,
					    #
					    site
					  };



				RG_GRID  (options.grid_fn  arg);
			    };

			RG_SCROLLPORT (arg:	Rg_Scrollport)
			    =>
			    {   arg ->	  { origin:			Ref(g2d::Point),								# Origin of view's subwindow_or_view in scrollport coordinates, used for scrolling pixmap in scrollport.
					    scroller:			Scroller,									# Client-code interface for controlling view_origin.
					    callback:			Scroller_Callback,								# This is how we pass our Scroller to app client code, which basically lets it set 'pixmap_origin' above.
					    site:			Ref(g2d::Box),									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    viewable_info:		Viewable_Info									# Pointer to the viewable visible through the scrollport. In principle we support multiple scrollports/tabports open on a single viewable. (Untested, unlikely to be working.)
					  };

				viewable_info ->
					  { id:			Id,											# The 'id' field names us, letting multiple scrollports refer to one viewable.
					    rg_widget:		Ref( Rg_Widget ),									# Widget-tree visible in this viewable, which gets rendered onto 'pixmap' here.
					    #														# rg_widget is a Ref not because we intend to change it, but to work around a technical difficulty in guiboss-imp.pkg:do_pg_widget:PG_SCROLLPORT where  viewable_data and rg_widget each want to be created first.
					    pixmap:		g2p::Gadget_To_Rw_Pixmap,								# Viewable_Info values appear only in RG_SCROLLPORT.viewable_info,
																			#                                     RG_TABPORT.tabs
																			#		                      RG_TABPORT.visible_tab
					    ports:		Ref( List( Scrollport_Or_Tabport ) ),							# We make this a Ref(List(...)) to allow for adding additional scrollports/tabports opening onto the same underlying viewable pixmap.
																			# WARNING: We don't currently use multiple ports onto one pixmap; if we start doing so we'll probably find that *VIEWABLE_INFO.is_visible doesn't work right with them.

					    is_visible:		Ref( Bool )										# This will be FALSE only if we are one of several alternate views in a TABPORT set.
																			# We need this so that   update_offscreen_parent_pixmaps_and_then_topwindow()   in   src/lib/x-kit/widget/gui/guiboss-imp.pkg
																			# can know when to stop propagating widget updates up the scrollport tree.
					  };

				rg_widget = do_rg_widget  *rg_widget;

				viewable_info =			
					  { id,
					    rg_widget =>	REF rg_widget,
					    pixmap,
					    ports,
					    is_visible
					  };

				arg =	  { origin,
					    scroller,
					    callback,
					    site,
					    #
					    viewable_info
					  };

				RG_SCROLLPORT (options.scrollport_fn  arg);
			    };

			RG_TABPORT (arg:	Rg_Tabport)
			    =>
			    {   arg ->	  { pixmap_size:		g2d::Size,									# Size of alternate pixmaps visible in scrollport.  We require them to all be the same size; we intend that the scrollport be the same size.
					    #
					    tabs:			List( Viewable_Info ),								# This record holds one of the alternate views which may be made visible in the scrollport.  *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST! *** 
					    visible_tab:		Ref ( Viewable_Info ),								# Which of 'tabs' is currently visible?  This refcell holds one element from 'tabs';  it supports switching between the tabbed views.
					    #
					    callback:			Tab_Picker_Callback,								# This is how we pass our Tab_Picker to app client code, which basically lets it set 'visible_tab' above.
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };
	
				number_of_visible_tab
				    =
				    number_of_active_widget (tabs, 0)
				    where
					fun number_of_active_widget  ([]: List(Viewable_Info),  i: Int)
						=>
						0;

					    number_of_active_widget ((widget ! rest), i)
						=>
						if (id_to_int widget.pixmap.id == id_to_int (*visible_tab).pixmap.id)   i;
						else							                number_of_active_widget (rest, i+1);
						fi;
					end;
				    end;

				tabs =  map  do_tab  tabs
					where
					    fun do_tab (arg: Viewable_Info)
						=
						{   arg ->    { id:		Id,
								rg_widget:	Ref( Rg_Widget ),
								pixmap:		g2p::Gadget_To_Rw_Pixmap,
								ports:		Ref( List( Scrollport_Or_Tabport ) ),
								is_visible:	Ref( Bool )
							      };

						    rg_widget = do_rg_widget *rg_widget;

						    arg =     { id,
								rg_widget   =>	REF rg_widget,
								pixmap,
								ports	    =>  REF *ports,
								is_visible  =>	REF *is_visible
							      };
						    arg;
						};
					end;


				arg =	  { pixmap_size,
					    #
					    tabs,
					    visible_tab => REF (list::nth (tabs, number_of_visible_tab)),
					    #
					    callback,
					    site
					  };

				RG_TABPORT  (options.tabport_fn  arg);
			    };

			RG_FRAME (arg:	Rg_Frame)
			    =>
			    {   arg -> 	  { frame_widget:		Rg_Widget,									# Widget which will draw the frame surround.
					    widget:			Rg_Widget,									# Widget-tree to draw surrounded by frame.
					    #
					    pixels_high_min: 		Ref(Int),									# Minimum            vertical   pixels to allocate for this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_min:	 	Ref(Int),									# Minimum            horizontal pixels to allocate for this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    pixels_high_cut: 		Ref(Float),									# Share of remaining vertical   pixels to allocate to  this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_cut: 		Ref(Float),									# Share of remaining horizontal pixels to allocate to  this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				frame_widget =  do_rg_widget  frame_widget;
				widget	     =  do_rg_widget        widget;

				arg = 	  { frame_widget,
					    widget,
					    #
					    pixels_high_min => 		REF *pixels_high_min,
					    pixels_wide_min =>	 	REF *pixels_wide_min,
					    #
					    pixels_high_cut => 		REF *pixels_high_cut,
					    pixels_wide_cut => 		REF *pixels_wide_cut,
					    #
					    site	    =>		REF *site
					  };

				RG_FRAME (options.frame_fn  arg);
			    };

			RG_WIDGET (arg: Rgwidget)
			    =>
			    {   arg ->	  { guiboss_to_gadget:		Guiboss_To_Gadget,								# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/gui/guiboss-imp.pkg
					    widgetspace_to_widget:	p2w::Widgetspace_To_Widget,							# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

					    endstate_oneshot:	Once( (											# The widget-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
									Widget_Start_Fn,								#
									Null_Or(Exception)								# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
								    ) ),
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				arg =	  { guiboss_to_gadget,
					    widgetspace_to_widget,
					    endstate_oneshot,
					    site			=> REF *site
					  };

				RG_WIDGET (options.widget_fn  arg);
			    };

			RG_OBJECTSPACE (arg:	Rg_Objectspace)
			    =>
			    {   arg -> 	  { objectspace_id:		Objectspace_Id,									# guiboss-imp indexes this value into *object_stuff to obtain (e.g.) a Guiboss_To_Objectspace port to the objectspace-imp.
					    objects:			List( Rg_Object ),								# The list of objects to be drawn. These can be placed arbitrarily, including possible overlaps.
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.

				arg = 	  { objectspace_id,
					    objects,
					    site		=> REF *site
					  };

				RG_OBJECTSPACE arg;

			    };

			RG_SPRITESPACE (arg:	Rg_Spritespace)
			    =>
			    {   arg ->	  { spritespace_id:		Spritespace_Id,									# guiboss-imp indexes this value into *sprite_stuff to obtain (e.g.) a Guiboss_To_Spritespace port to the spritespace-imp.
					    sprites:			List( Rg_Sprite ),								# The list of widgets to be drawn on the spritespace. These can be placed arbitrarily.
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.

				arg =	  { spritespace_id,
					    sprites,
					    site		=> REF *site
					  };

				RG_SPRITESPACE arg;
			    };

			RG_NULL_WIDGET
			    =>
			    {
				rg_widget;
			    };
		    esac;
	    end;



	Running_Gui_Apply_Option												# The following running_gui_apply() facility allows clients to walk a Running_Gui tree without having to write out the whole recursion.
	  #
	  = ROW_FN		(Rg_Row		 -> Void)									# Call this fn on RG_ROW    	     nodes in Running_Gui. Defaults to null fn.
	  | COL_FN		(Rg_Col		 -> Void)									# Call this fn on RG_COL    	     nodes in Running_Gui. Defaults to null fn.
	  | GRID_FN		(Rg_Grid	 -> Void)									# Call this fn on RG_GRID            nodes in Running_Gui. Defaults to null fn.
	  | SCROLLPORT_FN	(Rg_Scrollport   -> Void)									# Call this fn on RG_SCROLLPORT	     nodes in Running_Gui. Defaults to null fn.
	  | TABPORT_FN		(Rg_Tabport	 -> Void)									# Call this fn on RG_TABPORT	     nodes in Running_Gui. Defaults to null fn.
	  | FRAME_FN		(Rg_Frame	 -> Void)									# Call this fn on RG_FRAME           nodes in Running_Gui. Defaults to null fn.
	  | WIDGET_FN		(Rgwidget	 -> Void)									# Call this fn on RG_WIDGET          nodes in Running_Gui. Defaults to null fn.
	  ;

	fun running_gui_apply
	      (
		running_gui:	Running_Gui,
		options:	List( Running_Gui_Apply_Option )
	      )
	    :			Void
	    =
	    {   running_gui ->	  { fire_end_gun:		Void -> Void,							# Calling this fn will cause all state and look imps in the gui to exit, saving their state to their oneshots.
				    widgetspace_id:		Widgetspace_Id,							# guiboss-imp indexes this value into *widget_imps to obtain (e.g.) a Guiboss_To_Widgetspace port to the widgetspace-imp.
				    rg_widget:			Rg_Widget,							# The widget (or more commonly, tree of widgets) managed by the gui-tree's toplevel widgetspace-imp.
				    topwindow:			gtg::Guiboss_To_Topwindow,					# The topwindow on which to draw our widgets.
				    subwindow_info:		Subwindow_Data,							# Holds toplevel SUBWINDOW_DATA for gui.
				    #
				    gadget_imps_for_gui:	Gadget_Imps,							# Holds our gt::Gadget_Imp_Info        instances for this running gui.
				    spritespace_imps_for_gui:	Spritespace_Imps,						# Holds our gt::Guiboss_To_Spritespace instances for this running gui.
				    objectspace_imps_for_gui:	Objectspace_Imps,						# Holds our gt::Guiboss_To_Objectspace instances for this running gui.
				    widgetspace_imps_for_gui:	Widgetspace_Imps						# Holds our gt::Guiboss_To_Widgetspace instances for this running gui.
				  };

		do_rg_widget  rg_widget;
	    }
	    where

		fun process_options  (options:  List(Running_Gui_Apply_Option))
		    =
		    {   null_fn = (\\ (x: X) = ());
			#
			my_row_fn			=  REF  null_fn;
			my_col_fn			=  REF  null_fn;
			#
			my_grid_fn			=  REF  null_fn;
			my_scrollport_fn		=  REF  null_fn;
			my_tabport_fn			=  REF  null_fn;
			my_frame_fn			=  REF  null_fn;
			my_widget_fn			=  REF  null_fn;

			apply  do_option  options
			where
			    fun do_option (ROW_FN		fn) =>  my_row_fn			:=  fn;
				do_option (COL_FN		fn) =>  my_col_fn			:=  fn;
				#
				do_option (GRID_FN		fn) =>  my_grid_fn			:=  fn;
				do_option (SCROLLPORT_FN	fn) =>  my_scrollport_fn		:=  fn;
				do_option (TABPORT_FN		fn) =>  my_tabport_fn			:=  fn;
				do_option (FRAME_FN		fn) =>  my_frame_fn			:=  fn;
				do_option (WIDGET_FN		fn) =>  my_widget_fn			:=  fn;
			    end;
			end;

			{ row_fn			=>  *my_row_fn,
			  col_fn			=>  *my_col_fn,
			  #
			  grid_fn			=>  *my_grid_fn,
			  scrollport_fn			=>  *my_scrollport_fn,
			  tabport_fn			=>  *my_tabport_fn,
			  frame_fn			=>  *my_frame_fn,
			  widget_fn			=>  *my_widget_fn
			};
		    };

		options =  process_options  options;

		fun do_rg_widget (rg_widget: Rg_Widget)
		    =
		    case rg_widget
			#
			RG_ROW (arg:	Rg_Row)
			    =>
			    {   arg ->	  { id:				Id,
					    widgets:			List( Rg_Widget ),								# The list of widgets to be laid out and displayed in this row.
					    #
					    pixels_high_min: 		Ref(Int),									# Minimum            vertical   pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_min: 		Ref(Int),									# Minimum            horizontal pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    pixels_high_cut: 		Ref(Float),									# Share of remaining vertical   pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_cut: 		Ref(Float),									# Share of remaining horizontal pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				apply  do_rg_widget widgets;

				options.row_fn  arg;
			    };

			RG_COL (arg:	Rg_Col)
			    =>
			    {   arg ->	  { id:				Id,
					    widgets:			List( Rg_Widget ),								# The list of widgets to be laid out and displayed in this row.
					    #
					    pixels_high_min: 		Ref(Int),									# Minimum            vertical   pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_min: 		Ref(Int),									# Minimum            horizontal pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    pixels_high_cut: 		Ref(Float),									# Share of remaining vertical   pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_cut: 		Ref(Float),									# Share of remaining horizontal pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				apply do_rg_widget widgets;

				options.col_fn  arg;
			    };

			RG_GRID (arg:	Rg_Grid)
			    =>
			    {   arg ->	  { widgets:			List(	List( Rg_Widget )   ),							# The list lists of widgets to be laid out and displayed in this grid.
					    #
					    pixels_high_min: 		Ref(Int),									# Minimum            vertical   pixels to allocate for this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_min: 		Ref(Int),									# Minimum            horizontal pixels to allocate for this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    pixels_high_cut: 		Ref(Float),									# Share of remaining vertical   pixels to allocate to  this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_cut: 		Ref(Float),									# Share of remaining horizontal pixels to allocate to  this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				apply   do_widgets  widgets
					where
					    fun do_widgets (widgets: List(Rg_Widget))
						=
						apply  do_rg_widget  widgets;
					end;

				options.grid_fn  arg;
			    };

			RG_SCROLLPORT (arg:	Rg_Scrollport)
			    =>
			    {   arg ->	  { origin:			Ref(g2d::Point),								# Origin of view's subwindow_or_view in scrollport coordinates, used for scrolling pixmap in scrollport.
					    scroller:			Scroller,									# Client-code interface for controlling view_origin.
					    callback:			Scroller_Callback,								# This is how we pass our Scroller to app client code, which basically lets it set 'pixmap_origin' above.
					    site:			Ref(g2d::Box),									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    viewable_info:		Viewable_Info									# Pointer to the viewable visible through the scrollport. In principle we support multiple scrollports/tabports open on a single viewable. (Untested, unlikely to be working.)
					  };

				viewable_info ->
					  { id:			Id,											# The 'id' field names us, letting multiple scrollports refer to one viewable.
					    rg_widget:		Ref( Rg_Widget ),									# Widget-tree visible in this viewable, which gets rendered onto 'pixmap' here.
					    #														# rg_widget is a Ref not because we intend to change it, but to work around a technical difficulty in guiboss-imp.pkg:do_pg_widget:PG_SCROLLPORT where  viewable_data and rg_widget each want to be created first.
					    pixmap:		g2p::Gadget_To_Rw_Pixmap,								# Viewable_Info values appear only in RG_SCROLLPORT.viewable_info,
																			#                                     RG_TABPORT.tabs
																			#		                      RG_TABPORT.visible_tab
					    ports:		Ref( List( Scrollport_Or_Tabport ) ),							# We make this a Ref(List(...)) to allow for adding additional scrollports/tabports opening onto the same underlying viewable pixmap.
																			# WARNING: We don't currently use multiple ports onto one pixmap; if we start doing so we'll probably find that *VIEWABLE_INFO.is_visible doesn't work right with them.

					    is_visible:		Ref( Bool )										# This will be FALSE only if we are one of several alternate views in a TABPORT set.
																			# We need this so that   update_offscreen_parent_pixmaps_and_then_topwindow()   in   src/lib/x-kit/widget/gui/guiboss-imp.pkg
																			# can know when to stop propagating widget updates up the scrollport tree.
					  };

				do_rg_widget  *rg_widget;

				options.scrollport_fn  arg;
			    };

			RG_TABPORT (arg:	Rg_Tabport)
			    =>
			    {   arg ->	  { pixmap_size:		g2d::Size,									# Size of alternate pixmaps visible in scrollport.  We require them to all be the same size; we intend that the scrollport be the same size.
					    #
					    tabs:			List( Viewable_Info ),								# This record holds one of the alternate views which may be made visible in the scrollport.  *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST! *** 
					    visible_tab:		Ref ( Viewable_Info ),								# Which of 'tabs' is currently visible?  This refcell holds one element from 'tabs';  it supports switching between the tabbed views.
					    #
					    callback:			Tab_Picker_Callback,								# This is how we pass our Tab_Picker to app client code, which basically lets it set 'visible_tab' above.
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };
	
				apply   do_tab  tabs
					where
					    fun do_tab (arg: Viewable_Info)
						=
						{   arg ->    { id:		Id,
								rg_widget:	Ref( Rg_Widget ),
								pixmap:		g2p::Gadget_To_Rw_Pixmap,
								ports:		Ref( List( Scrollport_Or_Tabport ) ),
								is_visible:	Ref( Bool )
							      };

						    do_rg_widget *rg_widget;
						};
					end;


				options.tabport_fn  arg;
			    };

			RG_FRAME (arg:	Rg_Frame)
			    =>
			    {   arg -> 	  { frame_widget:		Rg_Widget,									# Widget which will draw the frame surround.
					    widget:			Rg_Widget,									# Widget-tree to draw surrounded by frame.
					    #
					    pixels_high_min: 		Ref(Int),									# Minimum            vertical   pixels to allocate for this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_min:	 	Ref(Int),									# Minimum            horizontal pixels to allocate for this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    pixels_high_cut: 		Ref(Float),									# Share of remaining vertical   pixels to allocate to  this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    pixels_wide_cut: 		Ref(Float),									# Share of remaining horizontal pixels to allocate to  this FRAME widget.	 Used in src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    #
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				do_rg_widget  frame_widget;
				do_rg_widget        widget;

				options.frame_fn  arg;
			    };

			RG_WIDGET (arg: Rgwidget)
			    =>
			    {   arg ->	  { guiboss_to_gadget:		Guiboss_To_Gadget,								# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/gui/guiboss-imp.pkg
					    widgetspace_to_widget:	p2w::Widgetspace_To_Widget,							# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

					    endstate_oneshot:	Once( (											# The widget-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
									Widget_Start_Fn,								#
									Null_Or(Exception)								# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
								    ) ),
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				options.widget_fn  arg;
			    };

			RG_OBJECTSPACE (arg:	Rg_Objectspace)
			    =>
			    {   arg -> 	  { objectspace_id:		Objectspace_Id,									# guiboss-imp indexes this value into *object_stuff to obtain (e.g.) a Guiboss_To_Objectspace port to the objectspace-imp.
					    objects:			List( Rg_Object ),								# The list of objects to be drawn. These can be placed arbitrarily, including possible overlaps.
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.

			    };

			RG_SPRITESPACE (arg:	Rg_Spritespace)
			    =>
			    {   arg ->	  { spritespace_id:		Spritespace_Id,									# guiboss-imp indexes this value into *sprite_stuff to obtain (e.g.) a Guiboss_To_Spritespace port to the spritespace-imp.
					    sprites:			List( Rg_Sprite ),								# The list of widgets to be drawn on the spritespace. These can be placed arbitrarily.
					    site:			Ref(g2d::Box)									# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  };

				# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
			    };

			RG_NULL_WIDGET
			    =>
			    {
			    };
		    esac;
	    end;


	#########################################################################################
	### export-gui code


	Export_Gui_Map_Option												# The following export_gui_postorder_apply() facility allows clients to rewrite an Export_Gui tree without having to write out the whole recursion.
	  #
	  = XI_ROW_MAP_FN		(Xi_Row	 	-> Xi_Row	)						# Call this fn on XI_ROW    	     nodes in Export_Gui. Defaults to null fn.
	  | XI_COL_MAP_FN		(Xi_Col	 	-> Xi_Col	)						# Call this fn on XI_COL    	     nodes in Export_Gui. Defaults to null fn.
	  | XI_GRID_MAP_FN		(Xi_Grid 	-> Xi_Grid	)						# Call this fn on XI_GRID            nodes in Export_Gui. Defaults to null fn.
	  | XI_SCROLLPORT_MAP_FN	(Xi_Scrollport 	-> Xi_Scrollport)						# Call this fn on XI_SCROLLPORT	     nodes in Export_Gui. Defaults to null fn.
	  | XI_TABPORT_MAP_FN		(Xi_Tabport	-> Xi_Tabport	)						# Call this fn on XI_TABPORT	     nodes in Export_Gui. Defaults to null fn.
	  | XI_FRAME_MAP_FN		(Xi_Frame 	-> Xi_Frame	)						# Call this fn on XI_FRAME           nodes in Export_Gui. Defaults to null fn.
	  | XI_WIDGET_MAP_FN		(Xiwidget	-> Xiwidget	)						# Call this fn on XI_WIDGET          nodes in Export_Gui. Defaults to null fn.
	  | XI_GUIPLAN_MAP_FN		(Gui_Plan	-> Gui_Plan	)						# Call this fn on XI_WIDGET          nodes in Export_Gui. Defaults to null fn.
	  #
	  | XI_GP_ROW_MAP_FN		(Gp_Row		-> Gp_Row	)
	  | XI_GP_COL_MAP_FN		(Gp_Col		-> Gp_Col	)
	  | XI_GP_ROW'_MAP_FN		(Gp_Row'	-> Gp_Row'	)
	  | XI_GP_COL'_MAP_FN		(Gp_Col'	-> Gp_Col'	)
	  | XI_GP_GRID_MAP_FN		(Gp_Grid 	-> Gp_Grid	)
	  | XI_GP_SCROLLPORT_MAP_FN	(Gp_Scrollport	-> Gp_Scrollport)
	  | XI_GP_TABPORT_MAP_FN	(Gp_Tabport	-> Gp_Tabport	)
	  | XI_GP_FRAME_MAP_FN		(Gp_Frame	-> Gp_Frame	)
	  | XI_GP_WIDGET_MAP_FN		(Gpwidget	-> Gpwidget	)
	  ;


	fun export_gui_map
	      (
		export_gui as	( xi_widget:		Xi_Widget),
		#
		options:	List( Export_Gui_Map_Option )
	      )
	    =
	    {   xi_widget =  do_xi_widget  xi_widget;
		#
		(xi_widget, options);
	    }
	    where

		fun process_options  (options:  List(Export_Gui_Map_Option))
		    =
		    {   null_fn = (\\ (x: X) = x);
			#
			my_row_fn			=  REF  null_fn;
			my_col_fn			=  REF  null_fn;
			#
			my_grid_fn			=  REF  null_fn;
			my_scrollport_fn		=  REF  null_fn;
			my_tabport_fn			=  REF  null_fn;
			my_frame_fn			=  REF  null_fn;
			my_widget_fn			=  REF  null_fn;
			my_guiplan_fn			=  REF  null_fn;

			my_gp_row_fn			=  REF  null_fn;
			my_gp_col_fn			=  REF  null_fn;
			my_gp_row'_fn			=  REF  null_fn;
			my_gp_col'_fn			=  REF  null_fn;
			my_gp_grid_fn			=  REF  null_fn;
			my_gp_scrollport_fn		=  REF  null_fn;
			my_gp_tabport_fn		=  REF  null_fn;
			my_gp_frame_fn			=  REF  null_fn;
			my_gp_widget_fn			=  REF  null_fn;

			apply  do_option  options
			where
			    fun do_option (XI_ROW_MAP_FN		fn) =>  my_row_fn			:=  fn;
				do_option (XI_COL_MAP_FN		fn) =>  my_col_fn			:=  fn;
				#
				do_option (XI_GRID_MAP_FN		fn) =>  my_grid_fn			:=  fn;
				do_option (XI_SCROLLPORT_MAP_FN		fn) =>  my_scrollport_fn		:=  fn;
				do_option (XI_TABPORT_MAP_FN		fn) =>  my_tabport_fn			:=  fn;
				do_option (XI_FRAME_MAP_FN		fn) =>  my_frame_fn			:=  fn;
				do_option (XI_WIDGET_MAP_FN		fn) =>  my_widget_fn			:=  fn;
				do_option (XI_GUIPLAN_MAP_FN		fn) =>  my_guiplan_fn			:=  fn;
				#
				do_option (XI_GP_ROW_MAP_FN		fn) =>  my_gp_row_fn			:=  fn;
				do_option (XI_GP_COL_MAP_FN		fn) =>  my_gp_col_fn			:=  fn;
				do_option (XI_GP_ROW'_MAP_FN		fn) =>  my_gp_row'_fn			:=  fn;
				do_option (XI_GP_COL'_MAP_FN		fn) =>  my_gp_col'_fn			:=  fn;
				do_option (XI_GP_GRID_MAP_FN		fn) =>  my_gp_grid_fn			:=  fn;
				do_option (XI_GP_SCROLLPORT_MAP_FN	fn) =>  my_gp_scrollport_fn		:=  fn;
				do_option (XI_GP_TABPORT_MAP_FN		fn) =>  my_gp_tabport_fn		:=  fn;
				do_option (XI_GP_FRAME_MAP_FN		fn) =>  my_gp_frame_fn			:=  fn;
				do_option (XI_GP_WIDGET_MAP_FN		fn) =>  my_gp_widget_fn			:=  fn;
			    end;
			end;

			{ row_fn			=>  *my_row_fn,
			  col_fn			=>  *my_col_fn,
			  #
			  grid_fn			=>  *my_grid_fn,
			  scrollport_fn			=>  *my_scrollport_fn,
			  tabport_fn			=>  *my_tabport_fn,
			  frame_fn			=>  *my_frame_fn,
			  widget_fn			=>  *my_widget_fn,
			  guiplan_fn			=>  *my_guiplan_fn,
			  #
			  gp_row_fn			=>  *my_gp_row_fn,
			  gp_col_fn			=>  *my_gp_col_fn,
			  gp_row'_fn			=>  *my_gp_row'_fn,
			  gp_col'_fn			=>  *my_gp_col'_fn,
			  gp_grid_fn			=>  *my_gp_grid_fn,
			  gp_scrollport_fn		=>  *my_gp_scrollport_fn,
			  gp_tabport_fn			=>  *my_gp_tabport_fn,
			  gp_frame_fn			=>  *my_gp_frame_fn,
			  gp_widget_fn			=>  *my_gp_widget_fn
			};
		    };

		options =  process_options  options;


		fun do_gp_widget (gp_widget: Gp_Widget):  Gp_Widget
		    =
		    case gp_widget
			#
			ROW (arg:	Gp_Row)
			    =>
			    {	arg -> (row:  List(Gp_Widget));
				#
				row =  map  do_gp_widget  row;

				ROW (options.gp_row_fn  row);
			    };

			COL (arg:	Gp_Col)
			    =>
			    {	arg -> (col:  List(Gp_Widget));
				#
				col =  map  do_gp_widget  col;
				#
				COL (options.gp_col_fn  col);
			    };

			ROW' (arg:	Gp_Row')
			    =>
			    {   arg ->  ( id:		Id,
					  widgets:	List(Gp_Widget)
					);
				#
				widgets =  map  do_gp_widget  widgets;

				arg = (id, widgets);

				ROW' (options.gp_row'_fn  arg);
			    };

			COL' (arg:	Gp_Col')
			    =>
			    {   arg ->  ( id:		Id,
					  widgets:	List(Gp_Widget)
					);
				#
				widgets =  map  do_gp_widget  widgets;

				arg = (id, widgets);

				COL' (options.gp_col'_fn  arg);
			    };

			GRID (arg:	Gp_Grid)
			    =>
			    {	arg -> (grid:  List(List(Gp_Widget)));
				#
				grid =	map  do_gp_widgets  grid
					    where
						fun do_gp_widgets (widgets: List(Gp_Widget))
						    =
						    map  do_gp_widget  widgets;
					    end	;

				arg = grid;

				GRID (options.gp_grid_fn  arg);
			    };

			SCROLLPORT (arg:  Gp_Scrollport)
			    =>
			    {	arg ->  { scroller_callback:	Scroller_Callback,
					  scrollable:		Gp_Scrollable
					};

				scrollable
				    =
				    case scrollable
					#
					SCROLLABLE_ID id
					    =>
					    scrollable;

					SCROLLABLE { id:		Id,									# Id by which this SCROLLABLE may be referenced in SCROLLABLE_ID values.
						     pixmap_size:	g2d::Size,								# Size of pixmap visible in scrollport.
						     widget:		Gp_Widget								# Widget-tree providing content visible in scrollport -- will be rendered onto pixmap.
						   }
					    =>				
					    SCROLLABLE
					      { id,
						pixmap_size,
						widget => 	do_gp_widget  widget
					      };
				    esac;

				arg =   { scroller_callback, scrollable };

				SCROLLPORT (options.gp_scrollport_fn  arg);
			    };

			TABPORT (arg:  Gp_Tabport)
			    =>
			    {	arg ->  ( tab_picker_callback:	Tab_Picker_Callback,
					  pixmap_size:		g2d::Size,
					  tabs:			List( Gp_Widget )					# *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST ***
					);

				tabs =  map  do_gp_widget  tabs;

				arg  =  ( tab_picker_callback,
					  pixmap_size,
					  tabs
					);

				TABPORT (options.gp_tabport_fn  arg);
			    };

			FRAME (arg:  Gp_Frame)
			    =>
			    {   arg ->  ( frame_options:	List(Frame_Option),
					  gp_widget:		Gp_Widget
					);

				gp_widget =  do_gp_widget  gp_widget;

				arg ->  ( frame_options, gp_widget);

				FRAME (options.gp_frame_fn  arg);
			    };

			WIDGET (arg:	Gpwidget)
			    =>
			    {   arg ->  (wdget_start_fn:	Widget_Start_Fn);
				#
				WIDGET (options.gp_widget_fn  arg);
			    };

			OBJECTSPACE (arg:	Gp_Objectspace)
			    =>
			    {   arg ->  ( objectspace_options:	List( Objectspace_Option ),
					  objects:		List( Gp_Object )
					);

				arg =   ( objectspace_options,
					  objects
					);

				OBJECTSPACE arg;										# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
			    };

			SPRITESPACE   (arg:	Gp_Spritespace)
			    =>
			    {   arg ->  ( spritesapce_options:	List( Spritespace_Option ),
					  sprites:		List( Gp_Sprite )
					);

				arg =   ( spritesapce_options,
					  sprites
					);

				SPRITESPACE arg;										# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
			    };

			NULL_WIDGET
			    =>
			    {
				gp_widget;
			    };
		    esac;


		fun do_xi_widget (xi_widget: Xi_Widget)
		    =
		    case xi_widget
			#
			XI_ROW (arg:	Xi_Row)
			    =>
			    {   arg -> 	{ id, widgets };
				#
				widgets =  map  do_xi_widget  widgets;

				arg = 	{ id, widgets };

				XI_ROW  (options.row_fn  arg);
			    };

			XI_COL (arg:	Xi_Col)
			    =>
			    {   arg -> 	{ id, widgets };
				#
				widgets =  map  do_xi_widget  widgets;

				arg = 	{ id, widgets };

				XI_COL (options.row_fn  arg);
			    };


			XI_GRID (arg:	Xi_Grid)
			    =>
			    {   arg ->  { widgets:	List( List( Xi_Widget )) };
				#
				widgets =   map do_widgets widgets
						where
						    fun do_widgets (widgets: List(Xi_Widget))
							=
							map  do_xi_widget  widgets;
						end;

				arg =  { widgets };

				XI_GRID (options.grid_fn  arg);
			    };

			XI_SCROLLPORT (arg:	Xi_Scrollport)
			    =>
			    {   arg ->    { xi_widget:			Xi_Widget,									# Tree of widgets partially visible in scrollport.
					    origin:			g2d::Point,									# Origin of view's subwindow_or_view in scrollport coordinates, used for scrolling pixmap in scrollport.
					    scroller:			Scroller,
					    callback:			Scroller_Callback								# This is how we pass our Scroller to app client code, which basically lets it set 'pixmap_origin' above.
					  };

				xi_widget =  do_xi_widget  xi_widget;

				arg =     { xi_widget,
					    origin,
					    scroller,
					    callback
					  };

				XI_SCROLLPORT (options.scrollport_fn  arg);
			    };

			XI_TABPORT (arg:	Xi_Tabport)
			    =>
			    {   arg ->  {  widgets:			List( Xi_Widget )
					};

				widgets =  map  do_xi_widget  widgets;

				arg =   {  widgets };

				XI_TABPORT (options.tabport_fn  arg);
			    };

			XI_FRAME (arg:		Xi_Frame)
			    =>
			    {   arg -> 	{ frame_widget:		Xi_Widget,									# Widget which will draw the frame surround.
					  widget:		Xi_Widget									# Widget-tree to draw surrounded by frame.
					};

				frame_widget =  do_xi_widget  frame_widget;
				widget	     =  do_xi_widget  widget;

				arg = 	{ frame_widget,
					  widget
					};

				XI_FRAME (options.frame_fn  arg);
			    };

			XI_WIDGET (arg:		Xiwidget)
			    =>
			    {   arg -> 	{ widget_id:		iul::Id
					};

				arg =   { widget_id };

				XI_WIDGET (options.widget_fn  arg);
			    };

			XI_OBJECTSPACE (arg:	Xi_Objectspace)
			    =>
			    {   arg -> (xi_objects:	List(Xi_Object));
				#
				arg =  (xi_objects);

				XI_OBJECTSPACE arg;												# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
			    };

			XI_SPRITESPACE (arg:	Xi_Spritespace)
			    =>
			    {   arg -> (xi_sprites:	List(Xi_Sprite));
				#
				arg =  (xi_sprites);

				XI_SPRITESPACE arg;												# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
			    };

			XI_NULL_WIDGET
			    =>
			    {
				xi_widget;
			    };

			XI_GUI_PLAN (arg:	Gui_Plan)
			    =>
			    {   arg -> (gp_widget:	Gp_Widget);
				#
				gp_widget =  do_gp_widget  gp_widget;

				arg =  (gp_widget);

				XI_GUI_PLAN (options.guiplan_fn  arg);
			    };
		    esac;
	    end;




	Export_Gui_Apply_Option												# The following export_gui_postorder_apply() facility allows clients to rewrite an Export_Gui tree without having to write out the whole recursion.
	  #
	  = XI_ROW_FN		(Xi_Row	 	-> Void)								# Call this fn on XI_ROW    	     nodes in Export_Gui. Defaults to null fn.
	  | XI_COL_FN		(Xi_Col	 	-> Void)								# Call this fn on XI_COL    	     nodes in Export_Gui. Defaults to null fn.
	  | XI_GRID_FN		(Xi_Grid 	-> Void)								# Call this fn on XI_GRID            nodes in Export_Gui. Defaults to null fn.
	  | XI_SCROLLPORT_FN	(Xi_Scrollport 	-> Void)								# Call this fn on XI_SCROLLPORT	     nodes in Export_Gui. Defaults to null fn.
	  | XI_TABPORT_FN	(Xi_Tabport	-> Void)								# Call this fn on XI_TABPORT	     nodes in Export_Gui. Defaults to null fn.
	  | XI_FRAME_FN		(Xi_Frame 	-> Void)								# Call this fn on XI_FRAME           nodes in Export_Gui. Defaults to null fn.
	  | XI_WIDGET_FN	(Xiwidget	-> Void)								# Call this fn on XI_WIDGET          nodes in Export_Gui. Defaults to null fn.
	  | XI_GUIPLAN_FN	(Gui_Plan	-> Void)								# Call this fn on XI_WIDGET          nodes in Export_Gui. Defaults to null fn.
	  #
	  | XI_GP_ROW_FN	(Gp_Row		-> Void)
	  | XI_GP_COL_FN	(Gp_Col		-> Void)
	  | XI_GP_ROW'_FN	(Gp_Row'	-> Void)
	  | XI_GP_COL'_FN	(Gp_Col'	-> Void)
	  | XI_GP_GRID_FN	(Gp_Grid 	-> Void)
	  | XI_GP_SCROLLPORT_FN	(Gp_Scrollport	-> Void)
	  | XI_GP_TABPORT_FN	(Gp_Tabport	-> Void)
	  | XI_GP_FRAME_FN	(Gp_Frame	-> Void)
	  | XI_GP_WIDGET_FN	(Gpwidget	-> Void)
	  ;


	fun export_gui_apply
	      (
		export_gui as	( xi_widget:		Xi_Widget),
		#
		options:	List( Export_Gui_Apply_Option )
	      )
	    =
	    do_xi_widget  xi_widget
	    where

		fun process_options  (options:  List(Export_Gui_Apply_Option))
		    =
		    {   null_fn = (\\ (x: X) = ());
			#
			my_row_fn			=  REF  null_fn;
			my_col_fn			=  REF  null_fn;
			#
			my_grid_fn			=  REF  null_fn;
			my_scrollport_fn		=  REF  null_fn;
			my_tabport_fn			=  REF  null_fn;
			my_frame_fn			=  REF  null_fn;
			my_widget_fn			=  REF  null_fn;
			my_guiplan_fn			=  REF  null_fn;

			my_gp_row_fn			=  REF  null_fn;
			my_gp_col_fn			=  REF  null_fn;
			my_gp_row'_fn			=  REF  null_fn;
			my_gp_col'_fn			=  REF  null_fn;
			my_gp_grid_fn			=  REF  null_fn;
			my_gp_scrollport_fn		=  REF  null_fn;
			my_gp_tabport_fn		=  REF  null_fn;
			my_gp_frame_fn			=  REF  null_fn;
			my_gp_widget_fn			=  REF  null_fn;

			apply  do_option  options
			where
			    fun do_option (XI_ROW_FN		fn) =>  my_row_fn			:=  fn;
				do_option (XI_COL_FN		fn) =>  my_col_fn			:=  fn;
				#
				do_option (XI_GRID_FN		fn) =>  my_grid_fn			:=  fn;
				do_option (XI_SCROLLPORT_FN	fn) =>  my_scrollport_fn		:=  fn;
				do_option (XI_TABPORT_FN	fn) =>  my_tabport_fn			:=  fn;
				do_option (XI_FRAME_FN		fn) =>  my_frame_fn			:=  fn;
				do_option (XI_WIDGET_FN		fn) =>  my_widget_fn			:=  fn;
				do_option (XI_GUIPLAN_FN	fn) =>  my_guiplan_fn			:=  fn;
				#
				do_option (XI_GP_ROW_FN		fn) =>  my_gp_row_fn			:=  fn;
				do_option (XI_GP_COL_FN		fn) =>  my_gp_col_fn			:=  fn;
				do_option (XI_GP_ROW'_FN	fn) =>  my_gp_row'_fn			:=  fn;
				do_option (XI_GP_COL'_FN	fn) =>  my_gp_col'_fn			:=  fn;
				do_option (XI_GP_GRID_FN	fn) =>  my_gp_grid_fn			:=  fn;
				do_option (XI_GP_SCROLLPORT_FN	fn) =>  my_gp_scrollport_fn		:=  fn;
				do_option (XI_GP_TABPORT_FN	fn) =>  my_gp_tabport_fn		:=  fn;
				do_option (XI_GP_FRAME_FN	fn) =>  my_gp_frame_fn			:=  fn;
				do_option (XI_GP_WIDGET_FN	fn) =>  my_gp_widget_fn			:=  fn;
			    end;
			end;

			{ row_fn			=>  *my_row_fn,
			  col_fn			=>  *my_col_fn,
			  #
			  grid_fn			=>  *my_grid_fn,
			  scrollport_fn			=>  *my_scrollport_fn,
			  tabport_fn			=>  *my_tabport_fn,
			  frame_fn			=>  *my_frame_fn,
			  widget_fn			=>  *my_widget_fn,
			  guiplan_fn			=>  *my_guiplan_fn,
			  #
			  gp_row_fn			=>  *my_gp_row_fn,
			  gp_col_fn			=>  *my_gp_col_fn,
			  gp_row'_fn			=>  *my_gp_row'_fn,
			  gp_col'_fn			=>  *my_gp_col'_fn,
			  gp_grid_fn			=>  *my_gp_grid_fn,
			  gp_scrollport_fn		=>  *my_gp_scrollport_fn,
			  gp_tabport_fn			=>  *my_gp_tabport_fn,
			  gp_frame_fn			=>  *my_gp_frame_fn,
			  gp_widget_fn			=>  *my_gp_widget_fn
			};
		    };

		options =  process_options  options;


		fun do_gp_widget (gp_widget: Gp_Widget):  Void
		    =
		    case gp_widget
			#
			ROW (arg:	Gp_Row)
			    =>
			    {	arg -> (row:  List(Gp_Widget));
				#
				apply  do_gp_widget  row;

				options.gp_row_fn  arg;
			    };

			COL (arg:	Gp_Col)
			    =>
			    {	arg -> (col:  List(Gp_Widget));
				#
				apply  do_gp_widget  col;

				options.gp_col_fn  arg;
			    };

			ROW' (arg:	Gp_Row')
			    =>
			    {   arg ->  ( id:		Id,
					  widgets:	List(Gp_Widget)
					);
				#
				apply  do_gp_widget  widgets;

				options.gp_row'_fn  arg;
			    };

			COL' (arg:	Gp_Col')
			    =>
			    {   arg ->  ( id:		Id,
					  widgets:	List(Gp_Widget)
					);
				#
				apply  do_gp_widget  widgets;

				options.gp_col'_fn  arg;
			    };

			GRID (arg:	Gp_Grid)
			    =>
			    {	arg -> (grid:  List(List(Gp_Widget)));
				#
				apply   do_gp_widgets  grid
					where
					    fun do_gp_widgets (widgets: List(Gp_Widget))
						=
						apply  do_gp_widget  widgets;
					end;

				options.gp_grid_fn  arg;
			    };

			SCROLLPORT (arg:  Gp_Scrollport)
			    =>
			    {	arg ->  { scroller_callback:	Scroller_Callback,
					  scrollable:		Gp_Scrollable
					};

				case scrollable
				    #
				    SCROLLABLE { id:		Id,									# Id by which this SCROLLABLE may be referenced in SCROLLABLE_ID values.
						 pixmap_size:	g2d::Size,								# Size of pixmap visible in scrollport.
						 widget:	Gp_Widget								# Widget-tree providing content visible in scrollport -- will be rendered onto pixmap.
					       }
					=>				
					do_gp_widget  widget;

				    SCROLLABLE_ID id =>  ();
				esac;

				options.gp_scrollport_fn  arg;
			    };

			TABPORT (arg:  Gp_Tabport)
			    =>
			    {	arg ->  ( tab_picker_callback:	Tab_Picker_Callback,
					  pixmap_size:		g2d::Size,
					  tabs:			List( Gp_Widget )					# *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST ***
					);

				apply  do_gp_widget  tabs;

				options.gp_tabport_fn  arg;
			    };

			FRAME (arg:  Gp_Frame)
			    =>
			    {   arg ->  ( frame_options:	List(Frame_Option),
					  gp_widget:		Gp_Widget
					);

				do_gp_widget  gp_widget;

				options.gp_frame_fn  arg;
			    };

			WIDGET (arg:	Gpwidget)
			    =>
			    {   arg ->  (wdget_start_fn:	Widget_Start_Fn);
				#
				options.gp_widget_fn  arg;
			    };

			OBJECTSPACE (arg:	Gp_Objectspace)
			    =>
			    {   arg ->  ( objectspace_options:	List( Objectspace_Option ),
					  objects:		List( Gp_Object )
					);

				# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
			    };

			SPRITESPACE   (arg:	Gp_Spritespace)
			    =>
			    {   arg ->  ( spritesapce_options:	List( Spritespace_Option ),
					  sprites:		List( Gp_Sprite )
					);

				# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
			    };

			NULL_WIDGET
			    =>
			    {
			    };
		    esac;


		fun do_xi_widget (xi_widget: Xi_Widget)
		    =
		    case xi_widget
			#
			XI_ROW (arg:	Xi_Row)
			    =>
			    {   arg -> 	{ id, widgets };
				#
				apply  do_xi_widget  widgets;

				options.row_fn  arg;
			    };

			XI_COL (arg:	Xi_Col)
			    =>
			    {   arg -> 	{ id, widgets };
				#
				apply  do_xi_widget  widgets;

				options.row_fn  arg;
			    };


			XI_GRID (arg:	Xi_Grid)
			    =>
			    {   arg ->  { widgets:	List( List( Xi_Widget )) };
				#
				apply   do_widgets widgets
					where
					    fun do_widgets (widgets: List(Xi_Widget))
						=
						apply  do_xi_widget  widgets;
					end;

				options.grid_fn  arg;
			    };

			XI_SCROLLPORT (arg:	Xi_Scrollport)
			    =>
			    {   arg ->    { xi_widget:			Xi_Widget,									# Tree of widgets partially visible in scrollport.
					    origin:			g2d::Point,									# Origin of view's subwindow_or_view in scrollport coordinates, used for scrolling pixmap in scrollport.
					    scroller:			Scroller,
					    callback:			Scroller_Callback								# This is how we pass our Scroller to app client code, which basically lets it set 'pixmap_origin' above.
					  };

				do_xi_widget  xi_widget;

				options.scrollport_fn  arg;
			    };

			XI_TABPORT (arg:	Xi_Tabport)
			    =>
			    {   arg ->  {  widgets:			List( Xi_Widget )
					};

				apply  do_xi_widget  widgets;

				options.tabport_fn  arg;
			    };

			XI_FRAME (arg:		Xi_Frame)
			    =>
			    {   arg -> 	{ frame_widget:		Xi_Widget,									# Widget which will draw the frame surround.
					  widget:		Xi_Widget									# Widget-tree to draw surrounded by frame.
					};

				do_xi_widget  frame_widget;
				do_xi_widget  widget;

				options.frame_fn  arg;
			    };

			XI_WIDGET (arg:		Xiwidget)
			    =>
			    {   arg -> 	{ widget_id:		iul::Id
					};

				options.widget_fn  arg;
			    };

			XI_OBJECTSPACE (arg:	Xi_Objectspace)
			    =>
			    {   arg -> (xi_objects:	List(Xi_Object));
				#
				# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
			    };

			XI_SPRITESPACE (arg:	Xi_Spritespace)
			    =>
			    {   arg -> (xi_sprites:	List(Xi_Sprite));
				#
				# Eventually we'll have to do the full subrecursion here but for the moment none of that stuff is really operational.
			    };

			XI_NULL_WIDGET
			    =>
			    {
			    };

			XI_GUI_PLAN (arg:	Gui_Plan)
			    =>
			    {   arg -> (gp_widget:	Gp_Widget);
				#
				do_gp_widget  gp_widget;

				options.guiplan_fn  arg;
			    };
		    esac;
	    end;




	fun pprint_subwindow_info (subwindow_info: Subwindow_Data)
	    =
	    pp::with_standard_prettyprint_mill
		#
		(err::default_plaint_sink ())	[]
		#
		(\\ pp:   pp::Prettyprint_Mill
		    =
		    do_subwindow_info subwindow_info
		    where

# 			also
# 			fun do_widgetspace
# 			      ( widgetspace_arg:	Widgetspace_Arg,
# 				pg_widget:		Pg_Widget
# 			      )
# 			    =
# 			    {   pp.box {.
# 				    do_widgetspace_arg  widgetspace_arg;
# 				    do_pg_widget     pg_widget;
# 				};
# 				pp.newline();
# 			    }
# 
# 			also
# 			fun do_spritespace
# 			      (
# 				spritespace_arg:	Spritespace_Arg,
# 				pg_sprite:		List( Pg_Sprite )
# 			      )
# 			    =
# 			    {   pp.box {.
# 				    do_spritespace_arg  spritespace_arg;
# 				    do_pg_sprites	pg_sprites;
# 				};
# 				pp.newline();
# 			    }
# 
# 			also
# 			fun do_spritespace_arg  (spritespace_arg:	Spritespace_Arg)
# 			    =
# 			    {
# 				pprint_spritespace_arg  pp  spritespace_arg;
# 				pp.newline();
# 			    }
# 
# 
# 			also
# 			fun do_pg_sprites  (pg_sprites:		List( Pg_Sprite ))
# 			    =
# 			    {
# 				pp.box' 0 -1 {.
# 				    pp.lit  "[";
# 				    pp.ind 2;
# 				    pp.txt " ";
# 
# 				    fun do_sprite (pg_sprite: Pg_Sprite)
# 					=
# 					pp.box {.
# 					    do_pg_sprite  pg_sprite;
# 					    pp.endlit ",";
# 					    pp.txt " ";
# 					};
# 
# 				    pp::seqx
# 					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
# 					do_widget				# Print one list element.
# 					pg_sprite;				# List of elements.
# 
# 				    pp.ind 0;
# 				    pp.txt " ";
# 				    pp.lit "]";
# 				};
# 			    }
# 
# 			also
# 			fun do_pg_sprite  (pg_sprite:	Pg_Sprite)
# 			    =
# 			    case pg_sprite
# 				#
# 			        PG_SPRITE ( fn:			Sprite_Start_Fn,
# 					    saved_sprite_state:	Null_Or(Exception)
# 					  )
# 				    =>
# 				    {
# 					pp.box {.
# 					    pp.lit  "SPRITE _";
# 					};
# 					pp.newline();
# 				    };
# 
# # 			        SG_BALL	( ball_arg:		c2b::Make_Arg,
# # 					  ball_look_arg:	bli::Sprite_Look_Arg
# # 					)
# # 				    =>
# # 				    {
# # 					pp.box {.
# # 					    pp.lit  "BALL (";		pp.txt " ";
# # 					    bsi::pprint_make_arg  pp  ball_arg;
# # 					    pp.txt ", ";
# # 					    blx::pprint_sprite_look_arg  pp  ball_look_arg;
# # 					    pp.lit  ")";
# # 					};
# # 					pp.newline();
# # 				    };
# 			    esac
# 
# 			also
# 			fun do_objectspace
# 			      (
# 				objectspace_arg:	Objectspace_Arg,
# 				object_widgets:		List( Pg_Object )
# 			      )
# 			    =
# 			    {   pp.box {.
# 				    do_objectspace_arg  objectspace_arg;
# 				    do_object_widgets    object_widgets;
# 				};
# 				pp.newline();
# 			    }
# 
# 			also
# 			fun do_objectspace_arg  (objectspace_arg:	Objectspace_Arg)
# 			    =
# 			    {
# 				pprint_objectspace_arg  pp  objectspace_arg;
# 				pp.newline();
# 			    }
# 
# 			also
# 			fun do_object_widgets  (object_widgets:		List( Pg_Object ))
# 			    =
# 			    {
# 				pp.box' 0 -1 {.
# 				    pp.lit  "[";
# 				    pp.ind 2;
# 				    pp.txt " ";
# 
# 
# 				    fun do_widget (object_widget: Pg_Object)
# 					=
# 					pp.box {.
# 					    do_object_widget			object_widget;
# 					    pp.endlit ",";
# 					    pp.txt " ";
# 					};
# 
# 				    pp::seqx
# 					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
# 					do_widget				# Print one list element.
# 					object_widgets;				# List of elements.
# 
# 				    pp.ind 0;
# 				    pp.txt " ";
# 				    pp.lit "]";
# 				};
# 			    }
# 
# 			also
# 			fun do_object_widget  (object_widget:	Pg_Object)
# 			    =
# 			    case object_widget
# 				#
# 				PG_OBJECT ( fn:			Object_Start_Fn,
# 					    saved_object_state:	Null_Or(Exception)
# 					  )
# 				    =>
# 				    {
# 					pp.box {.
# 					    pp.lit  "PG_OBJECT _";
# 					};
# 					pp.newline();
# 				    };
# 
# 			        PG_WIDGETSPACE  widgetspace
# 				    =>
# 				    {
# 					pp.lit  "PG_WIDGETSPACE ";
# 					pp.newline();
# 					do_widgetspace widgetspace;
# 					pp.newline();
# 				    };
# 			    esac
# 

			fun do_running_gui
			      (
				{ fire_end_gun:		Void -> Void,							# Calling this fn will cause all state and look imps in the gui to exit, saving their state to their oneshots.
				  widgetspace_id:	Widgetspace_Id,							# guiboss-imp indexes this value into *widget_stuff to obtain (e.g.) a Guiboss_To_Widgetspace port to the widgetspace-imp.
				  rg_widget:		Rg_Widget,							# The widget (or more commonly, tree of widgets) managed by the gui-tree's toplevel widgetspace-imp.
				  topwindow:		gtg::Guiboss_To_Topwindow,					# The topwindow on which to draw our widgets.
				  subwindow_info:	Subwindow_Data,							# Holds toplevel SUBWINDOW_DATA for gui.
				  #
				  gadget_imps_for_gui:		Gadget_Imps,						# Holds our gt::Gadget_Imp_Info        instances for this running gui.
				  spritespace_imps_for_gui:	Spritespace_Imps,					# Holds our gt::Guiboss_To_Spritespace instances for this running gui.
				  objectspace_imps_for_gui:	Objectspace_Imps,					# Holds our gt::Guiboss_To_Objectspace instances for this running gui.
				  widgetspace_imps_for_gui:	Widgetspace_Imps					# Holds our gt::Guiboss_To_Widgetspace instances for this running gui.
				}
				:			Running_Gui
			      )
			    =
			    {   pp.box {.
				    pp.lit  "RUNNING_GUI {";
				    pp.ind 2;
				    pp.txt " ";

				    pp.lit  "fire_end_gun => <thunk>";
				    pp.endlit ",";

				    pp.lit  (sprintf "widget_space_id => %d" (id_to_int widgetspace_id));
				    pp.endlit ",";
				    
				    pp.lit  (sprintf "topwindow => { id => %d, subwindow_or_view:Gadget_To_Rw_Pixmap => { id => %d, size => %s... }" (id_to_int topwindow.id) (id_to_int topwindow.subwindow_or_view.id) (g2j::size_to_string topwindow.subwindow_or_view.size));
				    pp.endlit ",";

				    pp.box {.
					pp.lit  "rg_widget => ";
					do_rg_widget rg_widget;
				    };
				    pp.endlit ",";

				    pp.lit  (sprintf "subwindow_info => %s" (subwindow_info_id subwindow_info));
				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "}";
				};
				pp.newline();
			    }	

			also
			fun do_subwindow_info (bp: Subwindow_Data)
			    =
			    case bp
				#
			        SUBWINDOW_DATA  {												# 
						    running_gui:	Ref( Null_Or( Running_Gui ) ),						# 
						    pixmap:		g2p::Gadget_To_Rw_Pixmap,						# Main backing pixmap for this running gui.
						    pixmaps:		Ref( im::Map( g2p::Gadget_To_Rw_Pixmap )),				# All other X-server side pixmaps created by this running gui. (So we can reliably recycle them when we kill the gui -- otherwise we're leaking X-server memory.) 
						    popups:		Ref(List(Subwindow_Data)),						# These will all be SUBWINDOW_DATA, so 'Ref(List(Subwindow_Data))' would be a better type here.
						    parent:		Null_Or( Subwindow_Data ),						# For popups this points to the parent; for the original non-popup window it is NULL.
						    stacking_order:	Int,									# Assigned in increasing order starting at 1;  these determine who overlies who visually on the screen in case of overlaps. (Popups must be entirely within parent, but sibling popups can overlap.)
						    origin:		Ref(g2d::Point)								# If we have a parent, this gives our location on it. Note that pixmap.size gives our size.
						  }
				    =>
				    {
					pp.box' 0 -1 {.
					    pp.lit  "SUBWINDOW_INFO {";
					    pp.ind 2;
					    pp.txt " ";

					    pp.lit  (sprintf "stacking_order => %d" stacking_order);
					    pp.endlit ",";

					    pp.lit  (sprintf "origin => %s" (g2j::point_to_string *origin));
					    pp.endlit ",";

					    pp.lit  (sprintf "pixmap.id => %d" (id_to_int pixmap.id));
					    pp.endlit ",";

					    case *running_gui
						#
						NULL   =>  pp.lit "running_site => NULL";
						THE rg =>  do_running_gui rg;
					    esac;
					    pp.endlit ",";

					    case parent
						NULL  => pp.lit  "parent => NULL";
						THE p => pp.lit  (sprintf "parent => <<< %s >>>" (subwindow_info_id p));
					    esac;
					    pp.endlit ",";

					    pp.lit  (sprintf "#popups => %d" (list::length *popups));
					    pp.endlit ",";

					    pp::seqx
						{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
						do_subwindow_info			# Print one list element.
						*popups;				# List of elements.

					    pp.ind 0;
					    pp.txt " ";
					    pp.lit "}";
					};
					pp.newline();
				    };
			        #	
			    esac

 			also
			fun do_widgetspace_arg  (widgetspace_arg:	Widgetspace_Arg)
			    =
			    {
				pprint_widgetspace_arg  pp  widgetspace_arg;
				pp.newline();
			    }

			also
			fun do_rg_widget  (rg_widget:	Rg_Widget)
			    =
			    case rg_widget
				#
			        RG_ROW	{ id:			Id,
					  widgets:		List( Rg_Widget ),
					  pixels_high_min: 	Ref(Int),							# Minimum            vertical   pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  pixels_wide_min: 	Ref(Int),							# Minimum            horizontal pixels to allocate for this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  #
					  pixels_high_cut: 	Ref(Float),							# Share of remaining vertical   pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  pixels_wide_cut: 	Ref(Float),							# Share of remaining horizontal pixels to allocate to  this ROW widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  #
					  site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					}
				    =>
				    {
					pp.box' 0 -1 {.
					    pp.lit  "RG_ROW {";
					    pp.ind 2;
					    pp.txt " ";
					    pp.lit (sprintf "site => %s" (g2j::box_to_string *site));
					    pp.endlit ",";

					    fun do_widget (rg_widget: Rg_Widget)
						=
						pp.box {.
						    do_rg_widget		rg_widget;
						    pp.endlit ",";
						    pp.txt " ";
						};

					    pp::listx pp
						do_widget				# Print one list element.
						""					# Title.
						widgets;				# List of elements.


					    pp.ind 0;
					    pp.txt " ";
					    pp.lit "}";
					};
				    };


			        RG_COL	{ id:			Id,
					  widgets:		List( Rg_Widget ),
					  pixels_high_min: 	Ref(Int),							# Minimum            vertical   pixels to allocate for this COL widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  pixels_wide_min: 	Ref(Int),							# Minimum            horizontal pixels to allocate for this COL widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  #
					  pixels_high_cut: 	Ref(Float),							# Share of remaining vertical   pixels to allocate to  this COL widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  pixels_wide_cut: 	Ref(Float),							# Share of remaining horizontal pixels to allocate to  this COL widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  #
					  site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					}
				    =>
				    {
					pp.box' 0 -1 {.
					    pp.lit  "RG_COL {";
					    pp.ind 2;
					    pp.txt " ";
					    pp.lit (sprintf "site => %s" (g2j::box_to_string *site));
					    pp.endlit ",";

					    fun do_widget (rg_widget: Rg_Widget)
						=
						pp.box {.
						    do_rg_widget  rg_widget;
						    pp.endlit ",";
						    pp.txt " ";
						};

					    pp::listx pp
						do_widget				# Print one list element.
						""					# Title.
						widgets;				# List of elements.

					    pp.ind 0;
					    pp.txt " ";
					    pp.lit "}";
					};
				    };


			        RG_GRID	{ widgets:		List( List( Rg_Widget ) ),
					  pixels_high_min: 	Ref(Int),								# Minimum            vertical   pixels to allocate for this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  pixels_wide_min: 	Ref(Int),								# Minimum            horizontal pixels to allocate for this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  #
					  pixels_high_cut: 	Ref(Float),								# Share of remaining vertical   pixels to allocate to  this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  pixels_wide_cut: 	Ref(Float),								# Share of remaining horizontal pixels to allocate to  this GRID widget.	 Used in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					  #
					  site:			Ref(g2d::Box)								# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					}
				    =>
				    {
					pp.box' 0 -1 {.
					    pp.lit  "RG_GRID {";
					    pp.ind 2;
					    pp.txt " ";
					    pp.lit (sprintf "site => %s" (g2j::box_to_string *site));
					    pp.endlit ",";

					    pp::listx pp
						do_row											# Print one list element.
						""											# Title.
						widgets											# List of elements.
					    where
						fun do_row (widgets:	List(Rg_Widget))
						    =
						    pp::listx pp
							do_widget									# Print one list element.
							""										# Title.
							widgets										# List of elements.
						    where
							fun do_widget (rg_widget:	Rg_Widget)
							    =
							    pp.box {.
								do_rg_widget  rg_widget;
								pp.endlit ",";
								pp.txt " ";
							    };
						    end;
					    end;


					    pp.ind 0;
					    pp.txt " ";
					    pp.lit "}";
					};
				    };


			        RG_SCROLLPORT {												# Here we provide support for widgets visible through a scrollable scrollport.  Actually providing scrollbars happens at a higher level; here we handle pixmap state maintenance and redraw support.
					      origin:			Ref(g2d::Point),						# Origin of view's subwindow_or_view in scrollport coordinates, used for scrolling pixmap in scrollport.
					      viewable_info:		Viewable_Info,							# This is the parent pixmap holding the scrollport.
					      scroller:			Scroller,
					      callback:			Scroller_Callback,						# This is how we pass our Scroller to app client code, which basically lets it set 'pixmap_origin' above.
					      site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					    }
				    =>
				    {
					pp.lit  "RG_SCROLLPORT { ... }";
					pp.newline();
				    };

				RG_TABPORT
					{												# Here we provide support for selection between alternate views in scrollport.  Actually providing tabs happens at a higher level; here we handle pixmap state maintenance and redraw support.
					  pixmap_size:		g2d::Size,								# Size of alternate pixmaps visible in scrollport.  We require them to all be the same size; we intend that the scrollport be the same size.

					  tabs:			List( Viewable_Info ),							# Each record holds one of the alternate tabs which may be made visible in the tabport.  *** WE REQUIRE AT LEAST ONE ENTRY IN THE LIST! *** 
					  visible_tab:		Ref ( Viewable_Info ),							# Which of 'tabs' is currently visible?  This refcell holds one element from 'tabs';  it supports switching between the tabbed views.

					  callback:		Tab_Picker_Callback,							# This is how we pass our Tab_Picker to app client code, which basically lets it set 'visible_tab' above.
					  site:			Ref(g2d::Box)								# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					}
				    =>
				    {
					pp.lit  "RG_TABPORT { ... }";
					pp.newline();
				    };

				RG_FRAME  _
				    =>
				    {
					pp.lit  "RG_FRAME { ... }";
					pp.newline();
				    };

			        RG_WIDGET  {												# An actual leaf widget like an arrowbutton or label or text-entry box. These are all customizations of src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
						  guiboss_to_gadget:		Guiboss_To_Gadget,					# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/gui/guiboss-imp.pkg
						  widgetspace_to_widget:	p2w::Widgetspace_To_Widget,				# The command end of a port for communication to a widget-imp from a					src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

						  endstate_oneshot:	Once( (								# The widget-imp will save its state into this one-shot when shutting down due to end_gun' firing. Used by guiboss-imp.
										  Widget_Start_Fn,					#
										  Null_Or(Exception)					# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
									      ) ),
						  site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
						}
				    =>
				    {
					pp.box {.
					    pp.lit  "RG_WIDGET {";

					    pp.lit (sprintf "widgetspace_to_widget.id => %d" (iul::id_to_int widgetspace_to_widget.id));
					    pp.endlit ",";

					    pp.lit (sprintf "guiboss_to_gadget.id => %d" (iul::id_to_int guiboss_to_gadget.id));
					    pp.endlit ",";

					    pp.lit (sprintf "site => %s" (g2j::box_to_string *site));
					    pp.lit  " }";
					};
					pp.newline();
				    };


			        RG_OBJECTSPACE  { objectspace_id:	Objectspace_Id,							# guiboss-imp indexes this value into *object_stuff to obtain (e.g.) a Guiboss_To_Objectspace port to the objectspace-imp.
						  objects:		List( Rg_Object ),						# The list of objects to be drawn. These can be placed arbitrarily, including possible overlaps.
						  site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
						}
				    =>
				    {
					pp.lit  "$RG_OBJECTSPACE";
#					do_objectspace  objectspace;
					pp.newline();
				    };

			       RG_SPRITESPACE { spritespace_id:		Spritespace_Id,							# guiboss-imp indexes this value into *sprite_stuff to obtain (e.g.) a Guiboss_To_Spritespace port to the spritespace-imp.
						sprites:		List( Rg_Sprite ),						# The list of widgets to be drawn on the spritespace. These can be placed arbitrarily.
						site:			Ref(g2d::Box)							# Current assigned site on pixmap.  Set by  assign_sites_to_all_widgets()     in   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
					      }
				    =>
				    {
					pp.lit  "RG_SPRITESPACE";
#					do_spritespace  spritespace;
					pp.newline();
				    };
			      
			        RG_NULL_WIDGET
				    =>
				    {
					pp.lit  "RG_NULL_WIDGET";
					pp.newline();
				    };
			    esac;
	    end
		);




    };
end;

##########################################################################
# Note[1]
#
# We need a NULL_WIDGET but not a NULL_SPRITE or NULL_OBJECT
# because Gui_Plans are required arguments to guiboss-imp and
# Gp_Widget is a required component of a Gui_Plan, but
# sprite and object spaces are always optional.


##########################################################################
# Note[2]
#
#           "Simple  things should be simple.
#            Complex things should be possible."
#                             -- Alan Kay
#
# The purpose of the Rg_Widget facilities generally and
# of RG_ROW RG_COL RG_GRID specifically is to make simple GUI
# layout problems simple.
#
# In general, complex widget layout issues should be handled by
# writing custom code which lays out widgets (etc) on a object,
# not by cluttering Rg_Widget with special cases.
#
# Trying to make complex things simple will always fail;
# the result will be instead to make simple things complex.



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\|### \\)"		 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.

