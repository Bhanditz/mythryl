## stopped-gui.pkg
#
# A stopped_gui is an abstract gui specification.  Client
# code constructs a stopped_gui to describe a desired gui
# and hands it to guiboss-imp to run.
#
# When guiboss::restart_gui is called, guiboss converts
# the stopped_gui it is given into a running_gui tree which
# contains running widget imps and records all runtime-
# relevant information.
#
# When guiboss::stop_gui is called, the runtime running_gui
# is converted back into a stopped_gui which preserves the
# state of the GUI at shutdown time, for possible later
# resumption via guiboss::restart_gui.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg

    package gt  = gui_types;					# gui_types				is from   src/lib/x-kit/widget/gui/gui-types.pkg

    package os  =  guiboss_to_bouncespace;			# guiboss_to_bouncespace		is from   src/lib/x-kit/widget/space/bounce/guiboss-to-bouncespace.pkg
    package osi =  bouncespace_imp;				# bouncespace_imp			is from   src/lib/x-kit/widget/space/bounce/bouncespace-imp.pkg

    package cs  =  guiboss_to_canvasspace;			# guiboss_to_canvasspace		is from   src/lib/x-kit/widget/space/canvas/guiboss-to-canvasspace.pkg
    package csi =  canvasspace_imp;				# canvasspace_imp			is from   src/lib/x-kit/widget/space/canvas/canvasspace-imp.pkg

    package ps  =  guiboss_to_packedspace;			# guiboss_to_packedspace				is from   src/lib/x-kit/widget/space/packed/guiboss-to-packedspace.pkg
    package psi =  packedspace_imp;				# packedspace_imp			is from   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg


    package w2g =  gadget_to_guiboss;				# gadget_to_guiboss			is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg
    package w2p =  widget_to_packedspace;			# widget_to_packedspace			is from   src/lib/x-kit/widget/space/packed/widget-to-packedspace.pkg   
#   package b2g =  guiboss_to_gadget;				# guiboss_to_gadget			is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg
    package p2w =  packedspace_to_widget;			# packedspace_to_widget			is from   src/lib/x-kit/widget/space/packed/packedspace-to-widget.pkg



    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill		is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg

    package blh =  bouncespace_layout_hint;			# bouncespace_layout_hint		is from   src/lib/x-kit/widget/space/bounce/bouncespace-layout-hint.pkg
    package clh =  canvasspace_layout_hint;			# canvasspace_layout_hint		is from   src/lib/x-kit/widget/space/canvas/canvasspace-layout-hint.pkg
    package plh =  packedspace_layout_hint;			# packedspace_layout_hint		is from   src/lib/x-kit/widget/space/packed/packedspace-layout-hint.pkg

    package xg  =  xgeometry;					# xgeometry				is from   src/lib/std/2d/xgeometry.pkg
    package xt  =  xtypes;					# xtypes				is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package r8  =  rgb8;					# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
#   package xtr =  xlogger;					# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package err =  error_message;				# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    #


herein

    package stopped_gui
    {
	#
	Bounce_Widget
	    #
	    = SPRITE		( gt::Bounce_Sprite_Start_Fn,
				  Null_Or(Exception)									# saved_sprite_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				)
	also
	Canvas_Widget
	    #
	    = PACKEDSPACE	(ps::Packedspace_Arg,  Packed_Widget)
	    #
	    | OBJECT		( gt::Canvas_Object_Start_Fn,
				  Null_Or(Exception)									# saved_object_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				)
	also
	Packed_Widget
	    #
	    = ROW		 List( (List(plh::Packedspace_Layout_Hint), Packed_Widget) )
	    | COL		 List( (List(plh::Packedspace_Layout_Hint), Packed_Widget) )
	    #	
	    | WIDGET		( gt::Packed_Widget_Start_Fn,
				  Null_Or(Exception)									# saved_widget_state, used by arrowbutton etc to preserve state across gui stop/restart cycles.
				)
	    #
	    | CANVASSPACE	(cs::Canvasspace_Arg,  List((List(clh::Canvasspace_Layout_Hint), Canvas_Widget)))
	    | BOUNCESPACE	(os::Bouncespace_Arg,  List((List(blh::Bouncespace_Layout_Hint), Bounce_Widget)))
	    #
	    | NULL_PACKED_WIDGET											# Note[1]
	    ;

	Stopped_Gui =  (ps::Packedspace_Arg,  Packed_Widget);

	fun pprint_stopped_gui (stopped_gui: Stopped_Gui)								# "pprint" == "prettyprint".
	    =
	    pp::with_standard_prettyprint_mill
		#
		(err::default_plaint_sink ())	[]
		#
		(\\ pp:   pp::Prettyprint_Mill
		    =
		    do_stopped_gui  stopped_gui
		    where
			fun do_stopped_gui  stopped_gui
			    =
			    do_packedspace  stopped_gui

			also
			fun do_packedspace
			      ( packedspace_arg:	ps::Packedspace_Arg,
				packed_widget:		Packed_Widget
			      )
			    =
			    {   pp.box {.
				    do_packedspace_arg  packedspace_arg;
				    do_packed_widget     packed_widget;
				};
				pp.newline();
			    }

			also
			fun do_bouncespace
			      (
				bouncespace_arg:	os::Bouncespace_Arg,
				bounce_widgets:		List(  (List(blh::Bouncespace_Layout_Hint),  Bounce_Widget)  )
			      )
			    =
			    {   pp.box {.
				    do_bouncespace_arg  bouncespace_arg;
				    do_bounce_widgets    bounce_widgets;
				};
				pp.newline();
			    }

			also
			fun do_bouncespace_arg  (bouncespace_arg:	os::Bouncespace_Arg)
			    =
			    {
				osi::pprint_bouncespace_arg  pp  bouncespace_arg;
				pp.newline();
			    }


			also
			fun do_bouncespace_layout_hints  (layout_hints: List(blh::Bouncespace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  blh::Bouncespace_Layout_Hint)
				    =
				    osi::pprint_bouncespace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_bounce_widgets  (bounce_widgets:		List(  (List(blh::Bouncespace_Layout_Hint),  Bounce_Widget)  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";

				    fun do_widget (layout_hints: List(blh::Bouncespace_Layout_Hint),  bounce_widget: Bounce_Widget)
					=
					pp.box {.
					    do_bounce_widget			bounce_widget;
					    pp.endlit ",";
					    pp.txt " ";
					    do_bouncespace_layout_hints	layout_hints;
					};

				    pp::seq
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					bounce_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_bounce_widget  (bounce_widget:	Bounce_Widget)
			    =
			    case bounce_widget
				#
			        SPRITE	( fn:			gt::Bounce_Sprite_Start_Fn,
					  saved_sprite_state:	Null_Or(Exception)
					)
				    =>
				    {
					pp.box {.
					    pp.lit  "SPRITE _";
					};
					pp.newline();
				    };

# 			        BALL	( ball_arg:		c2b::Make_Arg,
# 					  ball_look_arg:	bli::Bounce_Look_Arg
# 					)
# 				    =>
# 				    {
# 					pp.box {.
# 					    pp.lit  "BALL (";		pp.txt " ";
# 					    bsi::pprint_make_arg  pp  ball_arg;
# 					    pp.txt ", ";
# 					    blx::pprint_bounce_look_arg  pp  ball_look_arg;
# 					    pp.lit  ")";
# 					};
# 					pp.newline();
# 				    };
			    esac

			also
			fun do_canvasspace
			      (
				canvasspace_arg:	cs::Canvasspace_Arg,
				canvas_widgets:		List(  (List(clh::Canvasspace_Layout_Hint),  Canvas_Widget)  )
			      )
			    =
			    {   pp.box {.
				    do_canvasspace_arg  canvasspace_arg;
				    do_canvas_widgets    canvas_widgets;
				};
				pp.newline();
			    }

			also
			fun do_canvasspace_arg  (canvasspace_arg:	cs::Canvasspace_Arg)
			    =
			    {
				csi::pprint_canvasspace_arg  pp  canvasspace_arg;
				pp.newline();
			    }

			also
			fun do_canvasspace_layout_hints  (layout_hints: List(clh::Canvasspace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  clh::Canvasspace_Layout_Hint)
				    =
				    csi::pprint_canvasspace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_canvas_widgets  (canvas_widgets:		List(  (List(clh::Canvasspace_Layout_Hint),  Canvas_Widget)  ))
			    =
			    {
				pp.box' 0 -1 {.
				    pp.lit  "[";
				    pp.ind 2;
				    pp.txt " ";


				    fun do_widget (layout_hints: List(clh::Canvasspace_Layout_Hint),  canvas_widget: Canvas_Widget)
					=
					pp.box {.
					    do_canvas_widget			canvas_widget;
					    pp.endlit ",";
					    pp.txt " ";
					    do_canvasspace_layout_hints	layout_hints;
					};

				    pp::seq
					{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
					do_widget				# Print one list element.
					canvas_widgets;				# List of elements.

				    pp.ind 0;
				    pp.txt " ";
				    pp.lit "]";
				};
			    }

			also
			fun do_canvas_widget  (canvas_widget:	Canvas_Widget)
			    =
			    case canvas_widget
				#
				OBJECT	( fn:			gt::Canvas_Object_Start_Fn,
					  saved_object_state:	Null_Or(Exception)
					)
				    =>
				    {
					pp.box {.
					    pp.lit  "OBJECT _";
					};
					pp.newline();
				    };

			        PACKEDSPACE  packedspace
				    =>
				    {
					pp.lit  "PACKEDSPACE ";
					pp.newline();
					do_packedspace packedspace;
					pp.newline();
				    };
			    esac

			also
			fun do_packedspace_arg  (packedspace_arg:	ps::Packedspace_Arg)
			    =
			    {
				psi::pprint_packedspace_arg  pp  packedspace_arg;
				pp.newline();
			    }

			also
			fun do_packedspace_layout_hints  (layout_hints: List(plh::Packedspace_Layout_Hint))
			    =
			    {   title = "";
				#
				fun do_hint (hint:  plh::Packedspace_Layout_Hint)
				    =
				    psi::pprint_packedspace_layout_hint  pp  hint;

				pp::list  pp  do_hint  title  layout_hints;
			    }

			also
			fun do_packed_widget  (packed_widget:	Packed_Widget)
			    =
			    case packed_widget
				#
			        ROW	(widgets:	 List( (List(plh::Packedspace_Layout_Hint), Packed_Widget) ))
				    =>
				    {
					pp.box' 0 -1 {.
					    pp.lit  "ROW [";
					    pp.ind 2;
					    pp.txt " ";

					    fun do_widget (layout_hints: List(plh::Packedspace_Layout_Hint), packed_widget: Packed_Widget)
						=
						pp.box {.
						    do_packed_widget			packed_widget;
						    pp.endlit ",";
						    pp.txt " ";
						    do_packedspace_layout_hints	layout_hints;
						};

					    pp::seq
						{.   pp.endlit ",";   pp.txt " ";   }	# Inter-element separator.
						do_widget				# Print one list element.
						widgets;				# List of elements.

					    pp.ind 0;
					    pp.txt " ";
					    pp.lit "]";
					};
				    };

			        COL	(a:	 List( (List(plh::Packedspace_Layout_Hint), Packed_Widget) ))
				    =>
				    {
					pp.lit  "COL";
					pp.newline();
				    };

			        WIDGET	( fn:			gt::Packed_Widget_Start_Fn,
					  saved_widget_state:	Null_Or(Exception)
					)
				    =>
				    {
					pp.box {.
					    pp.lit  "WIDGET _";
					};
					pp.newline();
				    };


			        CANVASSPACE (canvasspace:	(cs::Canvasspace_Arg,  List((List(clh::Canvasspace_Layout_Hint), Canvas_Widget))))
				    =>
				    {
					pp.lit  "CANVASSPACE";
					do_canvasspace  canvasspace;
					pp.newline();
				    };

			        BOUNCESPACE (bouncespace:	(os::Bouncespace_Arg,  List((List(blh::Bouncespace_Layout_Hint), Bounce_Widget))))
				    =>
				    {
					pp.lit  "BOUNCESPACE";
					do_bouncespace  bouncespace;
					pp.newline();
				    };
			      
			        NULL_PACKED_WIDGET
				    =>
				    {
					pp.lit  "NULL_PACKED_WIDGET";
					pp.newline();
				    };
			    esac;
		    end
		);
    };

end;


####################################################################################
# Note[1]
#    We need a NULL_PACKED_WIDGET but not a NULL_CANVAS_WIDGET or NULL_BOUNCE_WIDGET
#    because a Packed_Widget is a mandatory part of Stopped_Gui, but Bounce_Widget and
#    Canvas_Widget are always optional (an empty list is always permissible).





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
