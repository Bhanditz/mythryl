## appwindow-for-x.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include threadkit;						# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ap  =  atom_port;					# atom_port			is from   src/lib/x-kit/xclient/src/iccc/atom-port.pkg
    package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package aw  =  appwindow;					# appwindow			is from   src/lib/x-kit/widget/theme/appwindow.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
    package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
    package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package et  =  event_types;					# event_types			is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package exp =  xserver;					# xserver			is from   src/lib/x-kit/xclient/src/window/xserver.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
    package iui =  issue_unique_id;				# issue_unique_id		is from   src/lib/src/issue-unique-id.pkg
    package kp  =  keymap;					# keymap			is from   src/lib/x-kit/xclient/src/window/keymap.pkg
    package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
#   package rgb =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
    package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
    package s2p =  xevent_to_window;				# xevent_to_window		is from   src/lib/x-kit/xclient/src/window/xevent-to-window.pkg
    package sep =  selection_port;				# selection_port		is from   src/lib/x-kit/xclient/src/window/selection-port.pkg
    package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
    package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
    package sp  =  xsequencer;					# xsequencer			is from   src/lib/x-kit/xclient/src/wire/xsequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/basic/widget.pkg
    package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package wpp =  window_watcher;				# window_watcher		is from   src/lib/x-kit/xclient/src/window/window-watcher.pkg
    package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
    package x2s =  xevent_to_string;				# xevent_to_string		is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
    package xg  =  xgeometry;					# xgeometry			is from   src/lib/std/2d/xgeometry.pkg
    package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package xt  =  xtypes;					# xtypes			is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #
    tracefile   =  "widget-unit-test.trace.log";
herein

    package appwindow_for_x
    :       Appwindow_Imp												# Appwindow_Imp		is from   src/lib/x-kit/widget/theme/appwindow-imp.api
    {
	#
	include appwindow;												# appwindow		is from   src/lib/x-kit/widget/theme/appwindow.pkg
	#

	Imports = {													# Ports we use, provided by other imps.
		    int_sink: Int -> Void
		  };

	Exports	= {													# Ports we provide for use by other imps.
		    appwindow:	Appwindow
		  };

	Appwindow_Needs
	  =
	  {
	    site:	xg::Window_Site											# Where and how big (in pixels) should the application window be?
	  };

	Appwindow_Option
	  #
	  = MICROTHREAD_NAME		String										#
	  | ID				Int										# Unique ID for window, issued by issue_unique_id::issue_unique_id().
	  | CHANGE_CALLBACK		Appwindow_Needs -> Void								# We'll call each of these callbacks each time our value changes.
	  | APPWINDOW_CALLBACK		aw::Appwindow -> Void								# Client code registers this callback to get a port to us once we start up.
	  ;

	Appwindow_Arg = (Appwindow_Needs, List(Appwindow_Option));

	Appwindow_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);

	Appwindow_State													# Holds all nonephemeral mutable state maintained by shape.
	  =
	  { id:		Int,
	    state:	Ref( Appwindow_Needs )
	  };

	Me_Slot = Mailslot( { imports:			Imports,
			      me:			Appwindow_State,
			      options:			List(Appwindow_Option),
			      run_gun':			Run_Gun,
			      end_gun':			End_Gun,
			      endstate_oneshot:		Null_Or(Oneshot_Maildrop(Appwindow_Arg)),			# When end_gun fires we save our state in this and exit.
			      change_callbacks:		Ref(List(Appwindow_Needs -> Void)),
			      appwindow_callbacks:	List(Appwindow -> Void)
			    }
			  );



	Runstate = {													# These values will be statically globally visible throughout the code body for the imp.
		    me:			Appwindow_State,								# State which is preserved across imp shutdown/restart cycles.
		    options:		List(Appwindow_Option),
		    imports:		Imports,									# Imps to which we send requests.
		    to:			Replyqueue,									# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':		End_Gun,									# We shut down the microthread when this fires.
		    endstate_oneshot:	Null_Or(Oneshot_Maildrop(Appwindow_Arg)),					# When end_gun fires we save our state in this and exit.
		    change_callbacks:	Ref(List(Appwindow_Needs -> Void)),						#
		    fire_end_gun:	Void -> Void,
		    window:		xj::Window
		   };

	Appwindow_Q    = Mailqueue( Runstate -> Void );

	fun create_window   (xsequencer: sp::Xsequencer)								# Create a new X-window with the given xid 
	    {
	      window_id:    	xt::Window_Id,
	      parent_window_id:	xt::Window_Id,
	      visual_id:	xt::Visual_Id_Choice,
	      #	
	      io_class:		xt::Io_Class,
	      depth:		Int,
	      site:		xg::Window_Site,
	      attributes:	List( xt::a::Window_Attribute )
	    }
	    =
	    xsequencer.send_xrequest  msg
	    where 
		msg =   v2w::encode_create_window
			  {
			    window_id,
			    parent_window_id,
			    visual_id,
			    io_class,
			    depth,
			    site,
			    attributes
			  };
	    end;

	fun create_x_window_plus_supporting_impnet ()
	    =
	    {
		(au::get_xdisplay_string_and_xauthentication  NULL)
		    ->
		    ( display_name:     String,										# Typically from $DISPLAY environment variable.
		      xauthentication:  Null_Or(xt::Xauthentication)							# Typically from ~/.Xauthority
		    );

		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		root_window = 	rw::make_root_window  { display_name,
							xauthentication,
							run_gun',
							end_gun'
						      };

		root_window ->  rw::ROOT_WINDOW
					  { screen:			xj::Screen,
					    id:				Int,
					    #
					    make_shade:			rgb::Rgb -> shp::Shades,
					    make_tile:			String -> rop::Ro_Pixmap,
					    #
					    style:			wy::Widget_Style,
					    next_widget_id:		Void -> Int
					  };


		screen ->    xj::SCREEN   { xsession:			xj::Xsession,
					    screen_info:		xj::Screen_Info
					  };


		screen_info
		    ->
		         xj::SCREEN_INFO  { xscreen:			dy::Xscreen,
					    per_depth_imps:		List (xj::Per_Depth_Imps),
					    rootwindow_per_depth_imps:        xj::Per_Depth_Imps
					  };	

		xsession -> xj::XSESSION  { xdisplay:			dy::Xdisplay,          				#  
					    screens:			List( xj::Screen_Info ),			# Screens attached to this display.  Always a length-1 list in practice.

					    default_screen_info:   	xj::Screen_Info,

					    xevent_to_window:		s2p::Xevent_To_Window,				# Feeds X events to appropriate toplevel window.

					    font_index:          	fti::Font_Index,
					    atom_port:          	ap::Atom_Port,

					    window_watcher:		wpp::Window_Watcher,
					    selection_port:     	sep::Selection_Port,

					    xsequencer:			sp::Xsequencer,
					    keymap:			kp::Keymap
					  };

		xdisplay -> dy::XDISPLAY  { socket: 			sj::Stream_Socket(Int),				# Actual unix socket fd, wrapped up a bit. The 'Int' part is bogus -- I
					    #										# don't get what Reppy was trying to do with that phantom type.
					    name:			String,						# "host: display::screen",     e.g. "foo.com:0.0".
					    vendor:			String,						# Name of the server's vendor, e.g. 'The X.Org Foundation'.

					    default_screen => default_screen_number:	Int,				# Number of the default screen.  Always 0 in practice.

					    screens => display_screens:	List( dy::Xscreen ),				# Screens attached to this display.  Always a length-1 list in practice.

					    pixmap_formats:		List( xt::Pixmap_Format ),
					    max_request_length:	Int,

					    image_byte_order:		xt::Order,
					    bitmap_bit_order:		xt::Order,

					    bitmap_scanline_unit:	xt::Raw_Format,
					    bitmap_scanline_pad:	xt::Raw_Format,

					    min_keycode:		xt::Keycode,
					    max_keycode:		xt::Keycode,

					    next_xid:			Void -> xt::Xid					# resource id allocator. Implemented below by spawn_xid_factory_thread()    from   src/lib/x-kit/xclient/src/wire/display-old.pkg
					  };
			
		default_screen =   xj::default_screen_of  xsession;

		screen =  list::nth  (display_screens, default_screen_number);

		screen ->  dy::XSCREEN { root_window_id, root_visual, black_rgb8, white_rgb8, ... };

		background_pixel =  rgb8::rgb8_from_ints (16, 128+32, 32);
		border_pixel     =  black_rgb8;

		window_id        =  next_xid ();

		fire_run_gun ();

		window_has_received_first_expose_xevent_oneshot
			=
			make_oneshot_maildrop(): Oneshot_Maildrop(Void);

		fun wait_until_window_has_received_first_expose_xevent ()
		    =
		    get_from_oneshot  window_has_received_first_expose_xevent_oneshot;
			 

		fun xevent_sink ( route:		s2p::Envelope_Route,
				  event:		et::x::Event
				)
		    =
		    {   
			#
			case event
			    #
			    et::x::EXPOSE { exposed_window_id:  xt::Window_Id,							# The exposed window. 
					    boxes:              List( xg::Box ),						# The exposed rectangle.  The list is
																# so  that multiple events can be packed. 
					    count:              Int								# Number of subsequent expose events.
					  }
				=>  {
					printf "xevent_sink(): EXPOSE { exposed_window_id d=%d (window_id d=%d) count d=%d list::length boxes d=%d     -- xclient-unit-test.pkg\n"
					    (xt::xid_to_int exposed_window_id)
					    (xt::xid_to_int window_id)
					    count
					    (list::length boxes)
					;

					if (xt::same_xid (exposed_window_id, window_id))
					    #
					    put_in_oneshot (window_has_received_first_expose_xevent_oneshot, ());
					fi;
				    };

			    _   =>  printf "xevent_sink(): ignoring '%s' x event     -- xclient-unit-test.pkg\n" (x2s::xevent_name event);

			esac;
		    };

		xevent_to_window.note_new_topwindow
		  (
		    window_id,
		    xg::WINDOW_SITE  { upperleft    =>  xg::POINT { col =>   0, row  =>  0 },
				       size         =>  xg::SIZE { wide => 165, high => 85 },
				       border_thickness =>  1
				     },
		    xevent_sink
		  );

		case root_visual
		    #
		    xt::VISUAL { visual_id, depth as 24, red_mask => 0uxFF0000, green_mask => 0ux00FF00, blue_mask => 0ux0000FF, ... }		# Code currently assumes that we always get this case.
                        =>
                        {
			    create_window   xsequencer											# Create a window on the X server to draw stuff in etc.
			      {
				window_id,
				parent_window_id =>	root_window_id,

				visual_id        =>	xt::SAME_VISUAL_AS_PARENT,
				#
				depth,
				io_class	 =>	xt::INPUT_OUTPUT,
				#
				site		 =>    	xg::WINDOW_SITE
							  { upperleft    =>  xg::POINT { col =>   0, row  =>  0 },
							    size         =>  xg::SIZE  { wide=> 165, high => 85 },
							    border_thickness =>  1
							  },

				attributes	 =>     [ xt::a::BORDER_PIXEL     border_pixel,
							  xt::a::BACKGROUND_PIXEL background_pixel,
							  xt::a::EVENT_MASK       wi::standard_xevent_mask
							]
			      };

			    xsequencer.send_xrequest  (v2w::encode_map_window { window_id });					# "map" (make visible) our new window.


			    wait_until_window_has_received_first_expose_xevent ();


			    per_depth_imps = xj::per_depth_imps_for_depth (default_screen, depth);

			    per_depth_imps
				->
				xj::PER_DEPTH_IMPS    { depth:			Int,
							xserver:		exp::Xserver,					# The xpacket encoder  for this depth on this screen.
							window_map_event_sink:	wme::Window_Map_Event_Sink
						      };									#

			    window = xj::WINDOW { window_id, screen => default_screen, per_depth_imps, xserver };		# Create a client-side xj::WINDOW to represent our new X server window.


			    (fire_end_gun, window);
			};

		    xt::VISUAL { visual_id, depth, red_mask, green_mask, blue_mask, ... }
                        =>
                        {   printf      "This code assumes root visual has depth=24 red_mask=0xff0000 green_mask=0x00ff00 blue_mask=0x0000ff\n\
					\but actually the  root visual has depth=%d red_mask=0x%06x green_mask=0x%06x blue_mask=0x%06x  -- appwindow-for-x.pkg\n"  depth  (unt::to_int red_mask)  (unt::to_int green_mask)  (unt::to_int blue_mask);
			    raise exception FAIL "Unsupported X visual. -- appwindow-for-x.pkg";
			};

		    xt::NO_VISUAL_FOR_THIS_DEPTH int
                        =>
                        {   # This case should never happen.
			    raise exception FAIL "root_visual is NO_VISUAL_FOR_THIS_DEPTH?! -- appwindow-for-x.pkg";
			};
		esac;
	    };

	fun exercise_appwindow'   (window:  xj::Window)	
	    =
	    {	mblack   =  mtx::make_rw_matrix ((10,10), r8::rgb8_black	);
		#
		mred     =  mtx::make_rw_matrix ((10,10), r8::rgb8_red		);
		mgreen   =  mtx::make_rw_matrix ((10,10), r8::rgb8_green	);
		mblue    =  mtx::make_rw_matrix ((10,10), r8::rgb8_blue		);
		#
		mcyan    =  mtx::make_rw_matrix ((10,10), r8::rgb8_cyan		);
		mmagenta =  mtx::make_rw_matrix ((10,10), r8::rgb8_magenta	);
		myellow  =  mtx::make_rw_matrix ((10,10), r8::rgb8_yellow	);
		#
		mwhite   =  mtx::make_rw_matrix ((10,10), r8::rgb8_white	);
		#
		fun to_x dest pixmat					# Dest is something like   { col => 140, row => 20 }
		    =
		    cpt::copy_from_clientside_pixmat_to_pixmap
			#
			window
			#
			{ from => pixmat,
			  from_box => xg::BOX { col => 0,  wide => 9,
						row => 0,  high => 9
					      },
			  to_point => xg::POINT dest
			};

		# fun from_x ()
		#     =
		#     cpt::make_clientside_pixmat_from_window (window_area_to_sample, window);

#		printf "appwindow-for-x.pkg sleeping for 2 seconds before doing 100 updates...\n";
#		sleep_for 2.0;

		matrices = [ mblack, mred, mgreen, mblue, mcyan, mmagenta, myellow, mwhite ];

		for (i = 0, m = matrices;  i < 100;  ++i) {
		    #
		    to_x { col =>   0, row =>  1 }  (list::nth (m, 0));
		    to_x { col =>   0, row => 11 }  (list::nth (m, 1));
		    to_x { col =>   0, row => 21 }  (list::nth (m, 2));
		    to_x { col =>   0, row => 31 }  (list::nth (m, 3));
		    to_x { col =>   0, row => 41 }  (list::nth (m, 4));
		    to_x { col =>   0, row => 51 }  (list::nth (m, 5));
		    to_x { col =>   0, row => 61 }  (list::nth (m, 6));
		    to_x { col =>   0, row => 71 }  (list::nth (m, 7));
		    #
		    to_x { col =>  10, row =>  1 }  (list::nth (m, 7));
		    to_x { col =>  10, row => 11 }  (list::nth (m, 6));
		    to_x { col =>  10, row => 21 }  (list::nth (m, 5));
		    to_x { col =>  10, row => 31 }  (list::nth (m, 4));
		    to_x { col =>  10, row => 41 }  (list::nth (m, 3));
		    to_x { col =>  10, row => 51 }  (list::nth (m, 2));
		    to_x { col =>  10, row => 61 }  (list::nth (m, 1));
		    to_x { col =>  10, row => 71 }  (list::nth (m, 0));
		    #
		    to_x { col =>  20, row =>  1 }  (list::nth (m, 0));
		    to_x { col =>  20, row => 11 }  (list::nth (m, 1));
		    to_x { col =>  20, row => 21 }  (list::nth (m, 2));
		    to_x { col =>  20, row => 31 }  (list::nth (m, 3));
		    to_x { col =>  20, row => 41 }  (list::nth (m, 4));
		    to_x { col =>  20, row => 51 }  (list::nth (m, 5));
		    to_x { col =>  20, row => 61 }  (list::nth (m, 6));
		    to_x { col =>  20, row => 71 }  (list::nth (m, 7));
		    #
		    to_x { col =>  30, row =>  1 }  (list::nth (m, 7));
		    to_x { col =>  30, row => 11 }  (list::nth (m, 6));
		    to_x { col =>  30, row => 21 }  (list::nth (m, 5));
		    to_x { col =>  30, row => 31 }  (list::nth (m, 4));
		    to_x { col =>  30, row => 41 }  (list::nth (m, 3));
		    to_x { col =>  30, row => 51 }  (list::nth (m, 2));
		    to_x { col =>  30, row => 61 }  (list::nth (m, 1));
		    to_x { col =>  30, row => 71 }  (list::nth (m, 0));
		    #
		    to_x { col =>  40, row =>  1 }  (list::nth (m, 0));
		    to_x { col =>  40, row => 11 }  (list::nth (m, 1));
		    to_x { col =>  40, row => 21 }  (list::nth (m, 2));
		    to_x { col =>  40, row => 31 }  (list::nth (m, 3));
		    to_x { col =>  40, row => 41 }  (list::nth (m, 4));
		    to_x { col =>  40, row => 51 }  (list::nth (m, 5));
		    to_x { col =>  40, row => 61 }  (list::nth (m, 6));
		    to_x { col =>  40, row => 71 }  (list::nth (m, 7));
		    #
		    to_x { col =>  50, row =>  1 }  (list::nth (m, 7));
		    to_x { col =>  50, row => 11 }  (list::nth (m, 6));
		    to_x { col =>  50, row => 21 }  (list::nth (m, 5));
		    to_x { col =>  50, row => 31 }  (list::nth (m, 4));
		    to_x { col =>  50, row => 41 }  (list::nth (m, 3));
		    to_x { col =>  50, row => 51 }  (list::nth (m, 2));
		    to_x { col =>  50, row => 61 }  (list::nth (m, 1));
		    to_x { col =>  50, row => 71 }  (list::nth (m, 0));
		    #
		    to_x { col =>  60, row =>  1 }  (list::nth (m, 0));
		    to_x { col =>  60, row => 11 }  (list::nth (m, 1));
		    to_x { col =>  60, row => 21 }  (list::nth (m, 2));
		    to_x { col =>  60, row => 31 }  (list::nth (m, 3));
		    to_x { col =>  60, row => 41 }  (list::nth (m, 4));
		    to_x { col =>  60, row => 51 }  (list::nth (m, 5));
		    to_x { col =>  60, row => 61 }  (list::nth (m, 6));
		    to_x { col =>  60, row => 71 }  (list::nth (m, 7));
		    #
		    to_x { col =>  70, row =>  1 }  (list::nth (m, 7));
		    to_x { col =>  70, row => 11 }  (list::nth (m, 6));
		    to_x { col =>  70, row => 21 }  (list::nth (m, 5));
		    to_x { col =>  70, row => 31 }  (list::nth (m, 4));
		    to_x { col =>  70, row => 41 }  (list::nth (m, 3));
		    to_x { col =>  70, row => 51 }  (list::nth (m, 2));
		    to_x { col =>  70, row => 61 }  (list::nth (m, 1));
		    to_x { col =>  70, row => 71 }  (list::nth (m, 0));
		    #
		    to_x { col =>  80, row =>  1 }  (list::nth (m, 0));
		    to_x { col =>  80, row => 11 }  (list::nth (m, 1));
		    to_x { col =>  80, row => 21 }  (list::nth (m, 2));
		    to_x { col =>  80, row => 31 }  (list::nth (m, 3));
		    to_x { col =>  80, row => 41 }  (list::nth (m, 4));
		    to_x { col =>  80, row => 51 }  (list::nth (m, 5));
		    to_x { col =>  80, row => 61 }  (list::nth (m, 6));
		    to_x { col =>  80, row => 71 }  (list::nth (m, 7));
		    #
		    to_x { col =>  90, row =>  1 }  (list::nth (m, 7));
		    to_x { col =>  90, row => 11 }  (list::nth (m, 6));
		    to_x { col =>  90, row => 21 }  (list::nth (m, 5));
		    to_x { col =>  90, row => 31 }  (list::nth (m, 4));
		    to_x { col =>  90, row => 41 }  (list::nth (m, 3));
		    to_x { col =>  90, row => 51 }  (list::nth (m, 2));
		    to_x { col =>  90, row => 61 }  (list::nth (m, 1));
		    to_x { col =>  90, row => 71 }  (list::nth (m, 0));
		    #
		    to_x { col => 100, row =>  1 }  (list::nth (m, 0));
		    to_x { col => 100, row => 11 }  (list::nth (m, 1));
		    to_x { col => 100, row => 21 }  (list::nth (m, 2));
		    to_x { col => 100, row => 31 }  (list::nth (m, 3));
		    to_x { col => 100, row => 41 }  (list::nth (m, 4));
		    to_x { col => 100, row => 51 }  (list::nth (m, 5));
		    to_x { col => 100, row => 61 }  (list::nth (m, 6));
		    to_x { col => 100, row => 71 }  (list::nth (m, 7));
		    #
		    to_x { col => 110, row =>  1 }  (list::nth (m, 7));
		    to_x { col => 110, row => 11 }  (list::nth (m, 6));
		    to_x { col => 110, row => 21 }  (list::nth (m, 5));
		    to_x { col => 110, row => 31 }  (list::nth (m, 4));
		    to_x { col => 110, row => 41 }  (list::nth (m, 3));
		    to_x { col => 110, row => 51 }  (list::nth (m, 2));
		    to_x { col => 110, row => 61 }  (list::nth (m, 1));
		    to_x { col => 110, row => 71 }  (list::nth (m, 0));
		    #
		    to_x { col => 120, row =>  1 }  (list::nth (m, 0));
		    to_x { col => 120, row => 11 }  (list::nth (m, 1));
		    to_x { col => 120, row => 21 }  (list::nth (m, 2));
		    to_x { col => 120, row => 31 }  (list::nth (m, 3));
		    to_x { col => 120, row => 41 }  (list::nth (m, 4));
		    to_x { col => 120, row => 51 }  (list::nth (m, 5));
		    to_x { col => 120, row => 61 }  (list::nth (m, 6));
		    to_x { col => 120, row => 71 }  (list::nth (m, 7));
		    #
		    to_x { col => 130, row =>  1 }  (list::nth (m, 7));
		    to_x { col => 130, row => 11 }  (list::nth (m, 6));
		    to_x { col => 130, row => 21 }  (list::nth (m, 5));
		    to_x { col => 130, row => 31 }  (list::nth (m, 4));
		    to_x { col => 130, row => 41 }  (list::nth (m, 3));
		    to_x { col => 130, row => 51 }  (list::nth (m, 2));
		    to_x { col => 130, row => 61 }  (list::nth (m, 1));
		    to_x { col => 130, row => 71 }  (list::nth (m, 0));
		    #
		    to_x { col => 140, row =>  1 }  (list::nth (m, 0));
		    to_x { col => 140, row => 11 }  (list::nth (m, 1));
		    to_x { col => 140, row => 21 }  (list::nth (m, 2));
		    to_x { col => 140, row => 31 }  (list::nth (m, 3));
		    to_x { col => 140, row => 41 }  (list::nth (m, 4));
		    to_x { col => 140, row => 51 }  (list::nth (m, 5));
		    to_x { col => 140, row => 61 }  (list::nth (m, 6));
		    to_x { col => 140, row => 71 }  (list::nth (m, 7));
		    #
		    to_x { col => 150, row =>  1 }  (list::nth (m, 7));
		    to_x { col => 150, row => 11 }  (list::nth (m, 6));
		    to_x { col => 150, row => 21 }  (list::nth (m, 5));
		    to_x { col => 150, row => 31 }  (list::nth (m, 4));
		    to_x { col => 150, row => 41 }  (list::nth (m, 3));
		    to_x { col => 150, row => 51 }  (list::nth (m, 2));
		    to_x { col => 150, row => 61 }  (list::nth (m, 1));
		    to_x { col => 150, row => 71 }  (list::nth (m, 0));
		    #
		    m =  (list::tail m)  @ [ list::head m ];								# Rotate the colors for visual interest.
		};
#		printf "appwindow-for-x.pkg sleeping for 2 seconds after doing 100 updates...\n";
#		sleep_for 2.0;

	    };	

	fun run (
		  appwindow_q:			Appwindow_Q,		
		  #
		  runstate as
		   {													# These values will be statically globally visible throughout the code body for the imp.
		      me:			Appwindow_State,								# State which is preserved across imp shutdown/restart cycles.
		      options:			List(Appwindow_Option),
		      imports:			Imports,									# Imps to which we send requests.
		      to:			Replyqueue,									# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		      end_gun':			End_Gun,									# We shut down the microthread when this fires.
		      endstate_oneshot:		Null_Or(Oneshot_Maildrop(Appwindow_Arg)),					# When end_gun fires we save our state in this and exit.
		      change_callbacks:		Ref(List(Appwindow_Needs -> Void)),						#
		      fire_end_gun:		Void -> Void,
		      window:			xj::Window
		  }
		)
	    =
	    loop ()
	    where

		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                            ==>  shut_down_appwindow_imp'),
			    (take_from_mailqueue' appwindow_q    ==>  do_appwindow_plea)
			];

			loop ();
		    }	
		    where
			fun do_appwindow_plea  thunk
			    =
			    thunk runstate;


			fun shut_down_appwindow_imp' ()
			    =
			    {   fire_end_gun ();
				#
				case endstate_oneshot									# Pass our state back to gui-boss to allow later impnet restart without state loss.
				    #
				    NULL	=> ();
				    THE oneshot => put_in_oneshot (oneshot, (*me.state, options));			# 
				esac;


				thread_exit { success => TRUE };							# Will not return.
			    };
		    end;
	    end;	



	fun startup   (id: Int,  reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()				# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		appwindow
		    =
		    { id, do_something, exercise_appwindow, pass_something, pass_appwindow_exercise_results };

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, { appwindow }));						# Return value from appwindow_egg'().

		(take_from_mailslot  me_slot)										# Imports from appwindow_egg'().
		    ->
		    { me, options, imports,
		      run_gun', end_gun',
		      endstate_oneshot, change_callbacks, appwindow_callbacks
		    };

		apply   {. #callback appwindow; }   appwindow_callbacks;						# Pass our port to everyone who asked for it.
		apply   {. #callback *me.state; }     *change_callbacks;						# Pass our initial state to everyone who is change-subscribed.

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		(create_x_window_plus_supporting_impnet ())
		    ->
		    ( fire_end_gun:	Void -> Void,
		      window:		xj::Window
		    );

		run (													# Will not return.
		      appwindow_q,
		      #
		      {
			me, options,  imports,
			to, end_gun',
			endstate_oneshot, change_callbacks,
			fire_end_gun, window
		      }
		    );
	    }
	    where
		appwindow_q     =  make_mailqueue (get_current_microthread()):  Appwindow_Q;


		fun  pass_appwindow_exercise_results  (replyqueue: Replyqueue)  (reply_handler: Int -> Void)		# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Int );

			put_in_mailqueue  (appwindow_q,
			    #
			    fn ({ window, ... }: Runstate)
				=
				{   exercise_appwindow'  window;
				    #
				    put_in_oneshot (reply_oneshot, 0);
				}
			);

			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };

		fun exercise_appwindow ()										# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Void );
			#
			put_in_mailqueue  (appwindow_q,
			    #
			    fn ({ window, ... }: Runstate)
				=
				{   exercise_appwindow'  window;
				    #
				    put_in_oneshot (reply_oneshot, ());
				}
			);

			fn () = get_from_oneshot reply_oneshot;								# Return a thunk which will wait until exercise is complete.
		    };


		fun do_something (i: Int)										# PUBLIC.
		    =	
		    put_in_mailqueue  (appwindow_q,
			#
			fn ({ imports, ... }: Runstate)
			    =
			    imports.int_sink i										# Demonstrate use of imports.
		    );


		fun pass_something (replyqueue: Replyqueue)  (reply_handler: Int -> Void)				# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Int );
			#
			put_in_mailqueue  (appwindow_q,
			    #
			    fn ({ me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, 0)
			);

			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };


	    end;


	fun process_options (options: List(Appwindow_Option), { name, id, change_callbacks, appwindow_callbacks })
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		my_change_callbacks	=     change_callbacks;		# Comes with REF pre-installed.
		my_appwindow_callbacks	= REF appwindow_callbacks;

		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME n)  =>   my_name	:=  n;
		        do_option (ID               i)  =>   my_id	:=  i;
			#
			do_option (CHANGE_CALLBACK     c)  =>  my_change_callbacks    :=  c ! *my_change_callbacks;
			do_option (APPWINDOW_CALLBACK  c)  =>  my_appwindow_callbacks :=  c ! *my_appwindow_callbacks;
		    end;
		end;

		{ name			=>  *my_name,
		  id 			=>  *my_id,
		  #
		  change_callbacks	=>   my_change_callbacks,
		  appwindow_callbacks	=>  *my_appwindow_callbacks
	        };
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_appwindow_egg
	        ( needs:	     Appwindow_Needs,
		  options:	List(Appwindow_Option)
		)
		(endstate_oneshot:	 Null_Or(Oneshot_Maildrop(Appwindow_Arg)))					# When end_gun fires we save our state in this and exit.
	    =
	    {   (process_options
		  ( options,
		    { name			=>  "appwindow_for_x",
		      id			=>  0,
		      #	
		      change_callbacks		=> REF([]),
		      appwindow_callbacks	=> []
		    }
		) )
		  ->
		  { name,
		    id,
		    #
		    change_callbacks,
		    appwindow_callbacks
		  };
	
		my (id, options)
		    =
		    if (id == 0)
			id = iui::issue_unique_id();									# Allocate unique imp id.
			(id, ID id ! options);										# Make our id stable across stop/restart cycles.
		    else
			(id, options);
		    fi;

		me =  { id,
			state =>  REF needs
		      };

		fn () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );		# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));					# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3											# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, options, imports, run_gun', end_gun', endstate_oneshot, change_callbacks, appwindow_callbacks });
				};

			    (exports, phase3);
			};
	    };
    };

end;
