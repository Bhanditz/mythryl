## appwindow-for-x.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include threadkit;						# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ap  =  atom_port;					# atom_port			is from   src/lib/x-kit/xclient/src/iccc/atom-port.pkg
    package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package aw  =  appwindow;					# appwindow			is from   src/lib/x-kit/widget/theme/appwindow.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
    package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
    package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package et  =  event_types;					# event_types			is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package exa =  exercise_x_appwindow;			# exercise_x_appwindow		is from   src/lib/x-kit/widget/xkit/app/exercise-x-appwindow.pkg
    package exp =  xserver;					# xserver			is from   src/lib/x-kit/xclient/src/window/xserver.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
    package kp  =  keymap;					# keymap			is from   src/lib/x-kit/xclient/src/window/keymap.pkg
    package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
#   package rgb =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
    package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
    package s2p =  xevent_to_window;				# xevent_to_window		is from   src/lib/x-kit/xclient/src/window/xevent-to-window.pkg
    package sep =  selection_port;				# selection_port		is from   src/lib/x-kit/xclient/src/window/selection-port.pkg
    package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
    package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
    package sp  =  xsequencer;					# xsequencer			is from   src/lib/x-kit/xclient/src/wire/xsequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/basic/widget.pkg
    package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package wpp =  window_watcher;				# window_watcher		is from   src/lib/x-kit/xclient/src/window/window-watcher.pkg
    package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
    package x2s =  xevent_to_string;				# xevent_to_string		is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
    package xg  =  xgeometry;					# xgeometry			is from   src/lib/std/2d/xgeometry.pkg
    package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package xt  =  xtypes;					# xtypes			is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #
    tracefile   =  "widget-unit-test.trace.log";
herein

    package appwindow_for_x
    :       Appwindow_Imp												# Appwindow_Imp		is from   src/lib/x-kit/widget/theme/appwindow-imp.api
    {
	#
	include appwindow;												# appwindow		is from   src/lib/x-kit/widget/theme/appwindow.pkg
	#

	Imports = {													# Ports we use, provided by other imps.
		    int_sink: Int -> Void
		  };

	Exports	= {													# Ports we provide for use by other imps.
		    appwindow:	Appwindow
		  };

	Appwindow_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);

	Appwindow_State													# Holds all nonephemeral mutable state maintained by shape.
	  =
	  { id:			Id,
	    state:		Ref( Appwindow_Needs ),
	    border_pixel:	r8::Rgb8
	  };

	Me_Slot = Mailslot( { imports:			Imports,
			      me:			Appwindow_State,
			      options:			List(Appwindow_Option),
			      run_gun':			Run_Gun,
			      end_gun':			End_Gun,
			      endstate_oneshot:		Null_Or(Oneshot_Maildrop(aw::Appwindow_Arg)),			# When end_gun fires we save our state in this and exit.
			      change_callbacks:		Ref(List(Appwindow_Needs -> Void)),
			      appwindow_callbacks:	List(Appwindow -> Void)
			    }
			  );



	Runstate = {													# These values will be statically globally visible throughout the code body for the imp.
		    me:			Appwindow_State,								# State which is preserved across imp shutdown/restart cycles.
		    options:		List(Appwindow_Option),
		    imports:		Imports,									# Imps to which we send requests.
		    to:			Replyqueue,									# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':		End_Gun,									# We shut down the microthread when this fires.
		    endstate_oneshot:	Null_Or(Oneshot_Maildrop(aw::Appwindow_Arg)),					# When end_gun fires we save our state in this and exit.
		    change_callbacks:	Ref(List(Appwindow_Needs -> Void)),						#
		    fire_end_gun:	Void -> Void,
		    window:		xj::Window
		   };

	Appwindow_Q    = Mailqueue( Runstate -> Void );

	fun create_window   (xsequencer: sp::Xsequencer)								# Create a new X-window with the given xid 
	    {
	      window_id:    	xt::Window_Id,
	      parent_window_id:	xt::Window_Id,
	      visual_id:	xt::Visual_Id_Choice,
	      #	
	      io_class:		xt::Io_Class,
	      depth:		Int,
	      site:		xg::Window_Site,
	      attributes:	List( xt::a::Window_Attribute )
	    }
	    =
	    xsequencer.send_xrequest  msg
	    where 
		msg =   v2w::encode_create_window
			  {
			    window_id,
			    parent_window_id,
			    visual_id,
			    io_class,
			    depth,
			    site,
			    attributes
			  };
	    end;

	fun create_x_window_plus_supporting_impnet
	    (
	      {	site:			xg::Window_Site,
		background_pixel:	r8::Rgb8
	      },
	      border_pixel:		r8::Rgb8
	    )
	    =
	    {
		(au::get_xdisplay_string_and_xauthentication  NULL)
		    ->
		    ( display_name:     String,										# Typically from $DISPLAY environment variable.
		      xauthentication:  Null_Or(xt::Xauthentication)							# Typically from ~/.Xauthority
		    );

		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		root_window = 	rw::make_root_window  { display_name,
							xauthentication,
							run_gun',
							end_gun'
						      };

		root_window ->  rw::ROOT_WINDOW
					  { id:				Id,
					    #
					    screen:			xj::Screen,
					    #
					    make_shade:			rgb::Rgb -> shp::Shades,
					    make_tile:			String -> rop::Ro_Pixmap,
					    #
					    style:			wy::Widget_Style,
					    next_widget_id:		Void -> Int
					  };


		screen ->    		  { xsession:			xj::Xsession,
					    screen_info:		xj::Screen_Info
					  }:				xj::Screen
					  ;

		screen_info ->		  { xscreen:			dy::Xscreen,
					    per_depth_imps:		List (xj::Per_Depth_Imps),
					    rootwindow_per_depth_imps:        xj::Per_Depth_Imps
					  }
					  :				xj::Screen_Info
					  ;

		xsession -> 		  { xdisplay:			dy::Xdisplay,          				#  
					    screens:			List( xj::Screen_Info ),			# Screens attached to this display.  Always a length-1 list in practice.

					    default_screen_info:   	xj::Screen_Info,

					    xevent_to_window:		s2p::Xevent_To_Window,				# Feeds X events to appropriate toplevel window.

					    font_index:          	fti::Font_Index,
					    atom_port:          	ap::Atom_Port,

					    window_watcher:		wpp::Window_Watcher,
					    selection_port:     	sep::Selection_Port,

					    xsequencer:			sp::Xsequencer,
					    keymap:			kp::Keymap
					  }:				xj::Xsession
					  ;

		xdisplay -> 		  { socket: 			sj::Stream_Socket(Int),				# Actual unix socket fd, wrapped up a bit. The 'Int' part is bogus -- I
					    #										# don't get what Reppy was trying to do with that phantom type.
					    name:			String,						# "host: display::screen",     e.g. "foo.com:0.0".
					    vendor:			String,						# Name of the server's vendor, e.g. 'The X.Org Foundation'.

					    default_screen => default_screen_number:	Int,				# Number of the default screen.  Always 0 in practice.

					    screens => display_screens:	List( dy::Xscreen ),				# Screens attached to this display.  Always a length-1 list in practice.

					    pixmap_formats:		List( xt::Pixmap_Format ),
					    max_request_length:	Int,

					    image_byte_order:		xt::Order,
					    bitmap_bit_order:		xt::Order,

					    bitmap_scanline_unit:	xt::Raw_Format,
					    bitmap_scanline_pad:	xt::Raw_Format,

					    min_keycode:		xt::Keycode,
					    max_keycode:		xt::Keycode,

					    next_xid:			Void -> xt::Xid					# resource id allocator.
					  }:				dy::Xdisplay					# Implemented below by spawn_xid_factory_thread() from
					  ;
															# src/lib/x-kit/xclient/src/wire/display-old.pkg
		default_screen =   xj::default_screen_of  xsession;

		screen =  list::nth  (display_screens, default_screen_number);

		screen ->  { root_window_id, root_visual, black_rgb8, white_rgb8, ... }: dy::Xscreen;

		window_id        =  next_xid ();

		fire_run_gun ();

		window_has_received_first_expose_xevent_oneshot
			=
			make_oneshot_maildrop(): Oneshot_Maildrop(Void);

		fun wait_until_window_has_received_first_expose_xevent ()
		    =
		    get_from_oneshot  window_has_received_first_expose_xevent_oneshot;
			 

		fun xevent_sink ( route:		s2p::Envelope_Route,
				  event:		et::x::Event
				)
		    =
		    {   
			#
			case event
			    #
			    et::x::EXPOSE { exposed_window_id:  xt::Window_Id,							# The exposed window. 
					    boxes:              List( xg::Box ),						# The exposed rectangle.  The list is
																# so  that multiple events can be packed. 
					    count:              Int								# Number of subsequent expose events.
					  }
				=>  {
					printf "xevent_sink(): EXPOSE { exposed_window_id d=%d (window_id d=%d) count d=%d list::length boxes d=%d     -- xclient-unit-test.pkg\n"
					    (xt::xid_to_int exposed_window_id)
					    (xt::xid_to_int window_id)
					    count
					    (list::length boxes)
					;

					if (xt::same_xid (exposed_window_id, window_id))
					    #
					    put_in_oneshot (window_has_received_first_expose_xevent_oneshot, ());
					fi;
				    };

			    _   =>  printf "xevent_sink(): ignoring '%s' x event     -- xclient-unit-test.pkg\n" (x2s::xevent_name event);

			esac;
		    };

		xevent_to_window.note_new_topwindow
		  (
		    window_id,
		    site,
		    xevent_sink
		  );

		case root_visual
		    #
		    xt::VISUAL
		      {
			visual_id,
			depth as 24,
			  red_mask => 0uxFF0000,										# Code currently assumes that we always get this case.
			green_mask => 0ux00FF00,										# I'm assuming for now that this is a de facto standard. -- 2014-04-06 Cynbe
			 blue_mask => 0ux0000FF,
			...
			}
                        =>
                        {
			    create_window   xsequencer										# Create a window on the X server to draw stuff in etc.
			      {
				window_id,
				parent_window_id =>	root_window_id,

				visual_id        =>	xt::SAME_VISUAL_AS_PARENT,
				#
				depth,
				io_class	 =>	xt::INPUT_OUTPUT,
				#
				site,												# Requested window-size-in-pixels and position. (Window manager seems to ignore position.)
				#												# We require that client code provide this info.
				attributes	 =>     [ xt::a::BORDER_PIXEL     border_pixel,
							  xt::a::BACKGROUND_PIXEL background_pixel,
							  xt::a::EVENT_MASK       wi::standard_xevent_mask
							]
			      };

			    xsequencer.send_xrequest  (v2w::encode_map_window { window_id });					# "map" (make visible) our new window.


			    wait_until_window_has_received_first_expose_xevent ();


			    per_depth_imps = xj::per_depth_imps_for_depth (default_screen, depth);

			    per_depth_imps
				->
				{ depth:			Int,
				  xserver:			exp::Xserver,							# The xpacket encoder  for this depth on this screen.
				  window_map_event_sink:	wme::Window_Map_Event_Sink
				}												#
				:				xj::Per_Depth_Imps    
				;

			    window = { window_id, screen => default_screen, per_depth_imps, xserver }: xj::Window;		# Create a client-side window to represent our new X server window.


			    (fire_end_gun, window);
			};

		    xt::VISUAL { visual_id, depth, red_mask, green_mask, blue_mask, ... }
                        =>
                        {   printf      "This code assumes root visual has depth=24 red_mask=0xff0000 green_mask=0x00ff00 blue_mask=0x0000ff\n\
					\but actually the  root visual has depth=%d red_mask=0x%06x green_mask=0x%06x blue_mask=0x%06x  -- appwindow-for-x.pkg\n"  depth  (unt::to_int red_mask)  (unt::to_int green_mask)  (unt::to_int blue_mask);
			    raise exception FAIL "Unsupported X visual. -- appwindow-for-x.pkg";
			};

		    xt::NO_VISUAL_FOR_THIS_DEPTH int
                        =>
                        {   # This case should never happen.
			    raise exception FAIL "root_visual is NO_VISUAL_FOR_THIS_DEPTH?! -- appwindow-for-x.pkg";
			};
		esac;
	    };

	fun run (
		  appwindow_q:			Appwindow_Q,		
		  #
		  runstate as
		   {													# These values will be statically globally visible throughout the code body for the imp.
		      me:			Appwindow_State,							# State which is preserved across imp shutdown/restart cycles.
		      options:			List(Appwindow_Option),
		      imports:			Imports,								# Imps to which we send requests.
		      to:			Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		      end_gun':			End_Gun,								# We shut down the microthread when this fires.
		      endstate_oneshot:		Null_Or(Oneshot_Maildrop(aw::Appwindow_Arg)),				# When end_gun fires we save our state in this and exit.
		      change_callbacks:		Ref(List(Appwindow_Needs -> Void)),					#
		      fire_end_gun:		Void -> Void,
		      window:			xj::Window
		  }
		)
	    =
	    loop ()
	    where

		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                            ==>  shut_down_appwindow_imp'),
			    (take_from_mailqueue' appwindow_q    ==>  do_appwindow_plea)
			];

			loop ();
		    }	
		    where
			fun do_appwindow_plea  thunk
			    =
			    thunk runstate;


			fun shut_down_appwindow_imp' ()
			    =
			    {   fire_end_gun ();
				#
				case endstate_oneshot									# Pass our state back to gui-boss to allow later impnet restart without state loss.
				    #
				    NULL	=> ();
				    THE oneshot => put_in_oneshot (oneshot, (*me.state, options));			# 
				esac;


				thread_exit { success => TRUE };							# Will not return.
			    };
		    end;
	    end;	



	fun startup   (id: Id,  reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()				# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		appwindow
		    =
		    { id,
		      subscribe_to_changes,
		      draw_ops,
		      do_something,
		      pass_window_site,
		      exercise_appwindow,
		      pass_appwindow_exercise_results
		    };

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, { appwindow }));						# Return value from appwindow_egg'().

		(take_from_mailslot  me_slot)										# Imports from appwindow_egg'().
		    ->
		    { me, options, imports,
		      run_gun', end_gun',
		      endstate_oneshot, change_callbacks, appwindow_callbacks
		    };

# XXX BUGGO FIXME This code is sub-optimal in that:
# 1) We never verify that the window manager gave us the window size (or position) that we requested,
# 2) We don't track changes in window size or position.
# 3) We probably should allow client code to specify whether to allow size changes,
#    but I forget what the X API is for doing that.  -- 2014-04-06 CrT

		apply   {. #callback appwindow; }   appwindow_callbacks;						# Pass our port to everyone who asked for it.
		apply   {. #callback *me.state; }     *change_callbacks;						# Pass our initial state to everyone who is change-subscribed.

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		(create_x_window_plus_supporting_impnet (*me.state, me.border_pixel))
		    ->
		    ( fire_end_gun:	Void -> Void,
		      window:		xj::Window
		    );

		run (													# Will not return.
		      appwindow_q,
		      #
		      {
			me, options,  imports,
			to, end_gun',
			endstate_oneshot, change_callbacks,
			fire_end_gun, window
		      }
		    );
	    }
	    where
		appwindow_q     =  make_mailqueue (get_current_microthread()):  Appwindow_Q;


		fun subscribe_to_changes   callback									# PUBLIC.
		    =	
		    put_in_mailqueue  (appwindow_q,
			#
			fn ({ change_callbacks, ... }: Runstate)
			    =
			    change_callbacks :=  callback ! *change_callbacks
		    );

		fun  pass_appwindow_exercise_results  (replyqueue: Replyqueue)  (reply_handler: Int -> Void)		# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Int );

			put_in_mailqueue  (appwindow_q,
			    #
			    fn ({ window, ... }: Runstate)
				=
#				{   exercise_appwindow'  window;
				{   exa::exercise_x_appwindow  window;
				    #
				    put_in_oneshot (reply_oneshot, 0);
				}
			);

			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };

		fun exercise_appwindow ()										# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Void );
			#
			put_in_mailqueue  (appwindow_q,
			    #
			    fn ({ window, ... }: Runstate)
				=
#				{   exercise_appwindow'  window;
				{   exa::exercise_x_appwindow  window;
				    #
				    put_in_oneshot (reply_oneshot, ());
				}
			);

			fn () = get_from_oneshot reply_oneshot;								# Return a thunk which will wait until exercise is complete.
		    };


		fun draw_ops (draw_ops: List( exp::Draw_Op ))								# PUBLIC.
		    =	
		    {   put_in_mailqueue  (appwindow_q,									# This is a simple pass-through to xserver.pkg  The point here
			    #												# is that the appwindow api is intended to be cross-platform,
			    fn (r: Runstate)										# so in principle we might be translating the Draw_Ops to
				=											# Windows equivalents, say.
				r.window.xserver.draw_ops  draw_ops
			);
		    };


		fun do_something (i: Int)										# PUBLIC.
		    =	
		    put_in_mailqueue  (appwindow_q,
			#
			fn ({ imports, ... }: Runstate)
			    =
			    imports.int_sink i										# Demonstrate use of imports.
		    );


		fun pass_window_site (replyqueue: Replyqueue)  (reply_handler: xg::Window_Site -> Void)			# PUBLIC.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( xg::Window_Site );
			#
			put_in_mailqueue  (appwindow_q,
			    #
			    fn ({ me, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, (*me.state).site)
			);

			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };
	    end;


	fun process_options (options: List(Appwindow_Option), { name, id, border_pixel, change_callbacks, appwindow_callbacks })
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		my_border_pixel		=  REF border_pixel;
		my_change_callbacks	=     change_callbacks;		# Comes with REF pre-installed.
		my_appwindow_callbacks	= REF appwindow_callbacks;

		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME	n)  =>  my_name			:=  n;
		        do_option (ID			i)  =>  my_id			:=  i;
			#
		        do_option (BORDER_PIXEL		i)  =>  my_border_pixel		:=  i;
			#
			do_option (CHANGE_CALLBACK	c)  =>  my_change_callbacks	:=  c ! *my_change_callbacks;
			do_option (APPWINDOW_CALLBACK	c)  =>  my_appwindow_callbacks	:=  c ! *my_appwindow_callbacks;
		    end;
		end;

		{ name			=>  *my_name,
		  id 			=>  *my_id,
		  #
		  border_pixel		=>  *my_border_pixel,
		  #
		  change_callbacks	=>   my_change_callbacks,
		  appwindow_callbacks	=>  *my_appwindow_callbacks
	        };
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_appwindow_egg
	        ( needs:	     Appwindow_Needs,
		  options:	List(Appwindow_Option)
		)
		(endstate_oneshot:	 Null_Or(Oneshot_Maildrop(aw::Appwindow_Arg)))					# When end_gun fires we save our state in this and exit.
	    =
	    {   (process_options
		  ( options,
		    { name			=>  "appwindow_for_x",
		      id			=>  id_zero,
		      #	
		      border_pixel		=>  r8::rgb8_from_ints (0,0,0),						# Default to dead black.  Window managers appear to ignore this value these days anyhow.
		      #	
		      change_callbacks		=> REF([]),
		      appwindow_callbacks	=> []
		    }
		) )
		  ->
		  { name,
		    id,
		    #
		    border_pixel,
		    #
		    change_callbacks,
		    appwindow_callbacks
		  };
	
		my (id, options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();										# Allocate unique imp id.
			(id, ID id ! options);										# Make our id stable across stop/restart cycles.
		    else
			(id, options);
		    fi;

		me =  { id,
			state =>  REF needs,
			border_pixel
		      };

		fn () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );		# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));					# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3											# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, options, imports, run_gun', end_gun', endstate_oneshot, change_callbacks, appwindow_callbacks });
				};

			    (exports, phase3);
			};
	    };
    };

end;
