## windowsystem-imp-for-x.pkg
#
# windowsystem implements the boundary between the
# portable and windowsystem-specific parts of the system:
# Higher-level bits like guiboss_imp are intended to		# guiboss_imp			is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
# be platform-agnostic, whereas lower-level stuff like
# xserver_ximp are platform-specific.				# xserver_ximp			is from   src/lib/x-kit/xclient/src/window/xserver-ximp.pkg
#
# windowsystem_imp_for_x should probably be in a library which
# hides all the x-specific stuff, so that higher
# levels of the system cannot accidentally wind
# up calling x-specific stuff.  We don't yet do that. 	XXX SUCKO FIXME

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ap  =  client_to_atom;				# client_to_atom		is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
    package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package gws =  guiboss_to_windowsystem;			# guiboss_to_windowsystem	is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
    package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
    package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package exa =  exercise_x_appwindow;			# exercise_x_appwindow		is from   src/lib/x-kit/widget/xkit/app/exercise-x-appwindow.pkg
    package w2x =  windowsystem_to_xserver;			# windowsystem_to_xserver	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xserver.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
    package gd  =  gui_displaylist;				# gui_displaylist		is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    package k2k =  keycode_to_keysym;				# keycode_to_keysym		is from   src/lib/x-kit/xclient/src/window/keycode-to-keysym.pkg
    package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap	is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
    package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
    package pen =  pen;						# pen				is from   src/lib/x-kit/xclient/src/window/pen.pkg
    package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
#   package rgb =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
    package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router	is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg
    package sep =  client_to_selection;				# client_to_selection		is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
    package shp =  shade;					# shade				is from   src/lib/x-kit/widget/lib/shade.pkg
    package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
    package x2s =  xclient_to_sequencer;			# xclient_to_sequencer		is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/old/basic/widget.pkg
    package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package wpp =  client_to_window_watcher;			# client_to_window_watcher	is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
    package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
    package xg  =  xgeometry;					# xgeometry			is from   src/lib/std/2d/xgeometry.pkg
    package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package xet =  xevent_types;				# xevent_types			is from   src/lib/x-kit/xclient/src/wire/xevent-types.pkg
    package e2s =  xevent_to_string;				# xevent_to_string		is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
    package xt  =  xtypes;					# xtypes			is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    #
    # The above three are the X-specific versions of the
    # below two platform-independent packages.  X events
    # come to us from the X server in xet:: encoding.  We	# For the big dataflow diagram see   src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
    # translate them to evt:: encoding and forward them to
    # guiboss_imp, which forwards them to appropriate imps.	# guiboss_imp			is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
    #
    package evt =  gui_event_types;				# gui_event_types		is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string		is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    #
    # This one translates from the X to Gui versions:
    package x2g =  xevent_to_gui_event;				# xevent_to_gui_event		is from   src/lib/x-kit/widget/xkit/app/xevent-to-gui-event.pkg
    package g2x =  gui_event_to_xevent;				# gui_event_to_xevent		is from   src/lib/x-kit/widget/xkit/app/gui-event-to-xevent.pkg

dummy1 = k2k::translate_keycode_to_keysym;

    tracefile   =  "widget-unit-test.trace.log";
herein

    package windowsystem_imp_for_x
    :       Windowsystem_Imp												# Windowsystem_Imp		is from   src/lib/x-kit/widget/theme/windowsystem-imp.api
    {
	include package   guiboss_to_windowsystem;									# guiboss_to_windowsystem	is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg
	#
	Imports = {													# Ports we use, provided by other imps.
		    int_sink: Int -> Void
		  };

	Exports	= {													# Ports we provide for use by other imps.
		    guiboss_to_windowsystem:	Guiboss_To_Windowsystem
		  };

	Windowsystem_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);

	Appwindow_State													# Holds all nonephemeral mutable state maintained by shape.
	  =
	  { id:			Id,
	    state:		Ref( Windowsystem_Needs )
	  };

	Me_Slot = Mailslot( { imports:			Imports,
			      me:			Appwindow_State,
			      options:			List(Windowsystem_Option),
			      run_gun':			Run_Gun,
			      end_gun':			End_Gun,
			      endstate_oneshot:		Null_Or(Oneshot_Maildrop(gws::Windowsystem_Arg)),		# When end_gun fires we save our state in this and exit.
			      change_callbacks:		Ref(List(Windowsystem_Needs -> Void)),
			      windowsystem_callbacks:	List(Guiboss_To_Windowsystem -> Void)
			    }
			  );



	Runstate = {													# These values will be statically globally visible throughout the code body for the imp.
		    me:				Appwindow_State,							# State which is preserved across imp shutdown/restart cycles.
		    options:			List(Windowsystem_Option),
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# We shut down the microthread when this fires.
		    endstate_oneshot:		Null_Or(Oneshot_Maildrop(gws::Windowsystem_Arg)),			# When end_gun fires we save our state in this and exit.
		    change_callbacks:		Ref(List(Windowsystem_Needs -> Void)),					#
		    fire_end_gun:		Void -> Void,
		    root_window:		rw::Root_Window,
		    key_mapping:		Ref (Null_Or( k2k::Key_Mapping ) )
		   };

	Appwindow_Q    = Mailqueue( Runstate -> Void );
	#




	fun start_xsession ()												# Private. Called only from startup().
	    =
	    {
		(au::get_xdisplay_string_and_xauthentication  NULL)
		    ->
		    ( display_name:     String,										# Typically from $DISPLAY environment variable.
		      xauthentication:  Null_Or(xt::Xauthentication)							# Typically from ~/.Xauthority
		    );

		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		root_window = 	rw::make_root_window  { display_name,
							xauthentication,
							run_gun',
							end_gun'
						      };

		fire_run_gun ();

		( end_gun':		mailop::End_Gun,
		  fire_end_gun:		Void -> Void,
		  root_window:		rw::Root_Window
		);
	    };

	fun create_x_window_plus_supporting_impnet
	    (
	      site:			xg::Window_Site,
	      background_pixel:		r8::Rgb8,
	      border_pixel:		r8::Rgb8,
	      root_window:		rw::Root_Window,
	      guievent_sink:		(a2r::Envelope_Route, evt::x::Event) -> Void,
	      key_mapping:		k2k::Key_Mapping	

	    )
	    =
	    {
		root_window ->  	  { id:					Id,
					    #
					    screen:				xj::Screen,
					    #
					    make_shade:				rgb::Rgb -> shp::Shades,
					    make_tile:				String -> rop::Ro_Pixmap,
					    #
					    style:				wy::Widget_Style,
					    next_widget_id:			Void -> Int
					  }
					  :					rw::Root_Window
					  ;
				


		screen ->    		  { xsession:				xj::Xsession,
					    screen_info:			xj::Screen_Info
					  }
					  :					xj::Screen
					  ;

		screen_info ->		  { xscreen:				dy::Xscreen,
					    per_depth_imps:			List (xj::Per_Depth_Imps),
					    rootwindow_per_depth_imps:  	      xj::Per_Depth_Imps
					  }
					  :					xj::Screen_Info
					  ;

		xsession -> 		  { xdisplay:				dy::Xdisplay,          			#  
					    screens:				List( xj::Screen_Info ),		# Screens attached to this display.  Always a length-1 list in practice.

					    default_screen_info:   		xj::Screen_Info,

					    windowsystem_to_xevent_router:	a2r::Windowsystem_To_Xevent_Router,	# Feeds X events to appropriate toplevel window.

					    font_index:          		fti::Font_Index,
					    client_to_atom:          		ap::Client_To_Atom,

					    client_to_window_watcher:		wpp::Client_To_Window_Watcher,
					    client_to_selection:     		sep::Client_To_Selection,

					    windowsystem_to_xserver:		w2x::Windowsystem_To_Xserver,
					    xclient_to_sequencer:		x2s::Xclient_To_Sequencer,
					    xevent_router_to_keymap:		r2k::Xevent_Router_To_Keymap
					  }
					  :					xj::Xsession
					  ;

		xdisplay -> 		  { socket: 				sj::Stream_Socket(Int),			# Actual unix socket fd, wrapped up a bit. The 'Int' part is bogus -- I
					    #										# don't get what Reppy was trying to do with that phantom type.
					    name:				String,					# "host: display::screen",     e.g. "foo.com:0.0".
					    vendor:				String,					# Name of the server's vendor, e.g. 'The X.Org Foundation'.

					    default_screen
						=>
						default_screen_number:		Int,					# Number of the default screen.  Always 0 in practice.

					    screens
						=>
						display_screens:		List( dy::Xscreen ),			# Screens attached to this display.  Always a length-1 list in practice.

					    pixmap_formats:			List( xt::Pixmap_Format ),
					    max_request_length:	Int,

					    image_byte_order:			xt::Order,
					    bitmap_bit_order:			xt::Order,

					    bitmap_scanline_unit:		xt::Raw_Format,
					    bitmap_scanline_pad:		xt::Raw_Format,

					    min_keycode:			xt::Keycode,
					    max_keycode:			xt::Keycode,

					    next_xid:				Void -> xt::Xid				# resource id allocator.
					  }
					  :					dy::Xdisplay				# Implemented below by spawn_xid_factory_thread() from
					  ;
															# src/lib/x-kit/xclient/src/wire/display-old.pkg
		default_screen =   xj::default_screen_of  xsession;

		screen =  list::nth  (display_screens, default_screen_number);

		screen ->  { root_window_id, root_visual, black_rgb8, white_rgb8, ... }: dy::Xscreen;

		window_id        =  next_xid ();

		window_has_received_first_expose_xevent_oneshot
			=
			make_oneshot_maildrop(): Oneshot_Maildrop(Void);
		#
		fun wait_until_window_has_received_first_expose_xevent ()
		    =
		    get_from_oneshot  window_has_received_first_expose_xevent_oneshot;
			 
		seen_first_expose_event_for__window_id
		    =
		    REF FALSE;

		#
		fun xevent_sink												# Snoop on event for local purposes, then forward it to guiboss which will ship it to the appropriate widget (if any).
		      (
			route:		a2r::Envelope_Route,
			event:		xet::x::Event
		      )
		    =
		    {   
			#
			case event
			    #
			    xet::x::EXPOSE { exposed_window_id:  xt::Window_Id,						# The exposed window. 
					    boxes:              List( xg::Box ),					# The exposed rectangle.  The list is
															# so  that multiple events can be packed. 
					    count:              Int							# Number of subsequent expose events.
					  }
				=>  {
# printf "xevent_sink(): EXPOSE { exposed_window_id d=%d (window_id d=%d) count d=%d list::length boxes d=%d     -- xclient-unit-test.pkg\n"
#     (xt::xid_to_int exposed_window_id)
#     (xt::xid_to_int window_id)
#     count
#     (list::length boxes)
# ;
					# The X protocol specifies that we should not
					# send stuff to an X window until we have seen
					# the first EXPOSE event for it, so we need to
					# track that carefully:
					#
					if  (    (not *seen_first_expose_event_for__window_id)				# Avoid writing more than once to a oneshot!
					    and  (xt::same_xid  (exposed_window_id, window_id))
					    )
					    seen_first_expose_event_for__window_id := TRUE;

					    put_in_oneshot (window_has_received_first_expose_xevent_oneshot, ());	# Unblock ourself (below): When we return, new topwindow will be ready to accept draw commands.
					fi;
				    };

			    _   =>  {
# printf "xevent_sink(): ignoring '%s' x event     -- xclient-unit-test.pkg\n" (e2s::xevent_name event);
					();
				    };

			esac;

if (*log::debugging) log::note {. "xevent_sink calling guievent_sink -- windowsystem-imp-for-x.pkg"; }; fi;
			guievent_sink  (route,  x2g::xevent_to_gui_event (event, key_mapping));				# Note conversion from X-specific xet::x::Event to platform-agnostic evt::x::Event format.

		    };

		windowsystem_to_xevent_router.note_new_topwindow
		  (
		    window_id,
		    site,
		    xevent_sink
		  );

		case root_visual
		    #
		    xt::VISUAL
		      {
			visual_id,
			depth as 24,
			  red_mask => 0uxFF0000,										# Code currently assumes that we always get this case.
			green_mask => 0ux00FF00,										# I'm assuming for now that this is a de facto standard. -- 2014-04-06 Cynbe
			 blue_mask => 0ux0000FF,
			...
			}
                        =>
                        {
			    fun create_window   (xclient_to_sequencer: x2s::Xclient_To_Sequencer)				# Create a new X-window with the given xid 
				{
				  window_id:    	xt::Window_Id,
				  parent_window_id:	xt::Window_Id,
				  visual_id:	xt::Visual_Id_Choice,
				  #	
				  io_class:		xt::Io_Class,
				  depth:		Int,
				  site:		xg::Window_Site,
				  attributes:	List( xt::a::Window_Attribute )
				}
				=
				xclient_to_sequencer.send_xrequest  msg
				where 
				    msg =   v2w::encode_create_window
					      {
						window_id,
						parent_window_id,
						visual_id,
						io_class,
						depth,
						site,
						attributes
					      };
				end;

			    create_window   xclient_to_sequencer								# Create a window on the X server to draw stuff in etc.
			      {
				window_id,
				parent_window_id =>	root_window_id,

				visual_id        =>	xt::SAME_VISUAL_AS_PARENT,
				#
				depth,
				io_class	 =>	xt::INPUT_OUTPUT,
				#
				site,												# Requested window-size-in-pixels and position. (Window manager seems to ignore position.)
				#												# We require that client code provide this info.
				attributes	 =>     [ xt::a::BORDER_PIXEL     border_pixel,
							  xt::a::BACKGROUND_PIXEL background_pixel,
							  xt::a::EVENT_MASK       wi::standard_xevent_mask
							]
			      };

			    xclient_to_sequencer.send_xrequest  (v2w::encode_map_window { window_id });				# "map" (make visible) our new window.


			    wait_until_window_has_received_first_expose_xevent ();


			    per_depth_imps = xj::per_depth_imps_for_depth (default_screen, depth);

			    per_depth_imps
				->
				{ depth:			Int,
				  windowsystem_to_xserver:	w2x::Windowsystem_To_Xserver,						# The xpacket encoder  for this depth on this screen.
				  window_map_event_sink:	wme::Window_Map_Event_Sink
				}												#
				:				xj::Per_Depth_Imps    
				;

			    window = { window_id, screen => default_screen, per_depth_imps, windowsystem_to_xserver }: xj::Window;	# Create a client-side window to represent our new X server window.

			    window;
			};

		    xt::VISUAL { visual_id, depth, red_mask, green_mask, blue_mask, ... }
                        =>
                        {   printf      "This code assumes root visual has depth=24 red_mask=0xff0000 green_mask=0x00ff00 blue_mask=0x0000ff\n\
					\but actually the  root visual has depth=%d red_mask=0x%06x green_mask=0x%06x blue_mask=0x%06x  -- windowsystem-imp-for-x.pkg\n"  depth  (unt::to_int red_mask)  (unt::to_int green_mask)  (unt::to_int blue_mask);
			    raise exception FAIL "Unsupported X visual. -- windowsystem-imp-for-x.pkg";
			};

		    xt::NO_VISUAL_FOR_THIS_DEPTH int
                        =>
                        {   # This case should never happen.
			    raise exception FAIL "root_visual is NO_VISUAL_FOR_THIS_DEPTH?! -- windowsystem-imp-for-x.pkg";
			};
		esac;
	    };
	#
	fun convert_displaylist_to_drawoplist
	      (
		window:		xj::Window,
		op:		gd::Gui_Displaylist
	      )
	    =
	    # Convert the platform-independent  Gui_Displaylist  format from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
	    # into    the        X-specific     List(Draw_Op)    format from   src/lib/x-kit/xclient/src/window/windowsystem-to-xserver.pkg
	    #
	    # The former is hierarchical and the latter linear,
	    # so part of the job is flattening the tree. Also,
	    # the latter uses 'pens' to represent color etc,	 pen is from   src/lib/x-kit/xclient/src/window/pen.pkg
	    # so we need to construct those as we go along:
	    #
	    {   ops = do_op (pen::default_pen, op, []);
		#
		reverse ops;			# do_ops produces a result list in reverse order of original 'ops' list, so here we reverse to restore original order.
	    }
	    where
		not_relative = FALSE;		# We're not supporting or using the X relative-draw mode, in which the coordinates of each point are relative to the previous one. 
		#
		to = window.window_id;
		#
		fun do_ops (pen,        [], result) =>			                result  ;
		    do_ops (pen, op ! rest, result) =>  do_ops (pen, rest, do_op(pen,op,result));
		end
		also
		fun do_op (pen, op, result)
		    =
		    case op
			#
			gd::POLY_POINT     (points: List(xg::Point)) =>  { to, pen, op => w2x::x::POLY_POINT    (                   not_relative, points) }  !  result;
			gd::POLY_LINE      (points: List(xg::Point)) =>  { to, pen, op => w2x::x::POLY_LINE     (                   not_relative, points) }  !  result;
			gd::FILL_POLY      (points: List(xg::Point)) =>  { to, pen, op => w2x::x::FILL_POLY     (xt::COMPLEX_SHAPE, not_relative, points) }  !  result;
			#
			gd::POLY_SEG       (lines:  List(xg::Line )) =>  { to, pen, op => w2x::x::POLY_SEG      (                                 lines ) }  !  result;
			#
			gd::POLY_BOX       (boxes:  List(xg::Box  )) =>  { to, pen, op => w2x::x::POLY_BOX      (                                 boxes ) }  !  result;
			gd::POLY_FILL_BOX  (boxes:  List(xg::Box  )) =>  { to, pen, op => w2x::x::POLY_FILL_BOX (                                 boxes ) }  !  result;
			#
			gd::POLY_ARC       (arcs:   List(xg::Arc  )) =>  { to, pen, op => w2x::x::POLY_ARC      (                                 arcs  ) }  !  result;
			gd::POLY_FILL_ARC  (arcs:   List(xg::Arc  )) =>  { to, pen, op => w2x::x::POLY_FILL_ARC (                                 arcs  ) }  !  result;
			#
#			gd::CLEAR_AREA     (box:         xg::Box   ) =>  { to, pen, op => w2x::x::CLEAR_AREA    (                                 box   ) }  !  result;
			#
			gd::COLOR ( color:	r8::Rgb8,								# Use this color
				    ops:	List(gd::Draw_Op)							# when drawing these ops.
				  )
			    =>
			    {   pen = pen::clone_pen (pen, [ pen::p::FOREGROUND color ]);				# Construct a new pen identical to the previous one except for using the new color.
				#
				do_ops (pen, ops, result);								# Process the sublist with the new pen.
			    };
		    esac;
	    end;

	#
	fun run (
		  appwindow_q:			Appwindow_Q,		
		  #
		  runstate as
		    {													# These values will be statically globally visible throughout the code body for the imp.
		      me:			Appwindow_State,							# State which is preserved across imp shutdown/restart cycles.
		      options:			List(Windowsystem_Option),
		      imports:			Imports,								# Imps to which we send requests.
		      to:			Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		      end_gun':			End_Gun,								# We shut down the microthread when this fires.
		      endstate_oneshot:		Null_Or(Oneshot_Maildrop(gws::Windowsystem_Arg)),				# When end_gun fires we save our state in this and exit.
		      change_callbacks:		Ref(List(Windowsystem_Needs -> Void)),					#
		      fire_end_gun:		Void -> Void,
		      root_window:		rw::Root_Window,
		      key_mapping:		Ref (Null_Or (k2k::Key_Mapping ) )
		    }
		)
	    =
	    loop ()
	    where
		#
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                            ==>  shut_down_appwindow_imp'),
			    (take_from_mailqueue' appwindow_q    ==>  do_appwindow_plea)
			];

			loop ();
		    }	
		    where
			fun do_appwindow_plea  thunk
			    =
			    thunk runstate;

			#
			fun shut_down_appwindow_imp' ()
			    =
			    {   fire_end_gun ();
				#
				case endstate_oneshot									# Pass our state back to guiboss to allow later impnet restart without state loss.
				    #
				    NULL	=> ();
				    THE oneshot => put_in_oneshot (oneshot, (*me.state, options));			# 
				esac;


				thread_exit { success => TRUE };							# Will not return.
			    };
		    end;
	    end;	


	#
	fun startup   (id: Id,  reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()				# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#

		guiboss_to_windowsystem
		    =
		    { id,
		      make_topwindow
		    };

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, { guiboss_to_windowsystem }));					# Return value from windowsystem_egg'().

		(take_from_mailslot  me_slot)										# Imports from windowsystem_egg'().
		    ->
		    { me, options, imports,
		      run_gun', end_gun',
		      endstate_oneshot, change_callbacks, windowsystem_callbacks
		    };

# XXX BUGGO FIXME This code is sub-optimal in that:
# 1) We never verify that the window manager gave us the window size (or position) that we requested,
# 2) We don't track changes in window size or position.
# 3) We probably should allow client code to specify whether to allow size changes,
#    but I forget what the X API is for doing that.  -- 2014-04-06 CrT

		apply   {. #callback guiboss_to_windowsystem; }   windowsystem_callbacks;				# Pass our port to everyone who asked for it.
		apply   {. #callback *me.state;        }     *change_callbacks;						# Pass our initial state to everyone who is change-subscribed.

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		(start_xsession ())
		    ->
		    (end_gun', fire_end_gun, root_window);

		run (													# Will not return.
		      appwindow_q,
		      #
		      {													# Runstate
			me,
			options,
			imports,
			to,
			end_gun',
			endstate_oneshot,
			change_callbacks,
			fire_end_gun,
			root_window,
			key_mapping => REF (NULL: Null_Or( k2k::Key_Mapping ) )						# It would be nice to generate 'key_mapping' right after above start_xession,
		      }													# but that leads to odd circularity issues centering on xevent_sink(),
		    );													# so we settle for generating it later in make_topwindow().
	    }
	    where
		appwindow_q     =  make_mailqueue (get_current_microthread()):  Appwindow_Q;

		#
		fun do_something (i: Int)										# PUBLIC.
		    =	
		    put_in_mailqueue  (appwindow_q,
			#
			\\ ({ imports, ... }: Runstate)
			    =
			    imports.int_sink i										# Demonstrate use of imports.
		    );


		#
		fun make_topwindow
		      (
			topwindow_hints:	gws::Topwindow_Hints,
			guievent_sink:		(a2r::Envelope_Route, evt::x::Event) -> Void

		      )
		    =
		    {
			stipulate
			    #
			    fun process_hints (hints: List(gws::Topwindow_Hint), { site, background_pixel, border_pixel })
				=
				{   my_site			=  REF site;
				    my_background_pixel		=  REF background_pixel;
				    my_border_pixel		=  REF border_pixel;

				    apply  do_hint  hints
				    where
					fun do_hint (gws::SITE		   s)  =>  my_site			:=  s;
					    do_hint (gws::BACKGROUND_PIXEL p)  =>  my_background_pixel		:=  p;
					    do_hint (gws::BORDER_PIXEL     p)  =>  my_border_pixel		:=  p;
					end;
				    end;

				    { site		=>  *my_site,
				      background_pixel	=>  *my_background_pixel,
				      border_pixel	=>  *my_border_pixel
				    };
				};
			herein

			    (process_hints
			      (
			        topwindow_hints,
				#
				{ site => { upperleft		=>  { col =>    0, row  =>   0 },
					    size		=>  { wide => 800, high => 600 },
					    border_thickness	=>  1
					  }: xg::Window_Site,

				  background_pixel	=>  r8::rgb8_from_ints (16, 128+32, 32),	# Slightly desaturated green.
				  border_pixel		=>  r8::rgb8_from_ints (0,       0,  0)		# Black.
				}
			    ) )
			      ->
				{ site:			xg::Window_Site,
				  background_pixel:	r8::Rgb8,
				  border_pixel:		r8::Rgb8
				};
			end;



			reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( gws::Guiboss_To_Topwindow );
			#
			put_in_mailqueue  (appwindow_q,
			    #
			    \\ ({ me, root_window, key_mapping, ... }: Runstate)
				=
				{
				    key_mapping'
					=
					case *key_mapping
					    #
					    THE km => km;

					    NULL => {   km =    k2k::create_key_mapping
								  (
								    root_window.screen.xsession.xclient_to_sequencer,
								    root_window.screen.xsession.xdisplay
								  );

							key_mapping = THE km;

							km;
						    };
					esac;
							    


				    (create_x_window_plus_supporting_impnet (site, background_pixel, border_pixel, root_window, guievent_sink, key_mapping'))
					->
					(window:	xj::Window);									# New topwindow.

				    # The following fns are defined here so that
				    # they can lock in the above 'window' value:
				    #
				    fun subscribe_to_changes   callback									# PUBLIC.
					=	
					put_in_mailqueue  (appwindow_q,
					    #
					    \\ ({ change_callbacks, ... }: Runstate)
						=
						change_callbacks :=  callback ! *change_callbacks
					);

# guiboss is going to wind up calling this over and over on the same list.
# We may want to separate conversion from drawing by having a
#     compile_displaylist: Gui_Displaylist -> (Void -> Void)
# which does the translation and then returns a thunk holding the result,
# ready to draw when invoked.  Using the thunk keeps guiboss-imp from
# having to know about the X-specific Draw_Op type that we convert to.
#
				    fun draw_displaylist (displaylist:  gd::Gui_Displaylist)						# PUBLIC.
					=	
					{
if (*log::debugging) log::note {. "draw_displaylist/AAA -- windowsystem-imp-for-x.pkg"; }; fi;
					    put_in_mailqueue  (appwindow_q,
						#
						\\ (r: Runstate)
						    =
						    window.windowsystem_to_xserver.draw_ops
							#
							(convert_displaylist_to_drawoplist  (window, displaylist))
					    );
					};

# XXX BUGGO FIXME Currently we return the requested site for the window,
# which may be totally different from that actually assigned by the window manager.
# Also, it should be passed to make_topwindow(), see comments there. 
				    #
				    fun pass_window_site (replyqueue: Replyqueue)  (reply_handler: xg::Window_Site -> Void)		# PUBLIC.
					=
					{   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( xg::Window_Site );
					    #
					    put_in_mailqueue  (appwindow_q,
						#
						\\ ({ me, ... }: Runstate)
						    =
						    put_in_oneshot (reply_oneshot, site)
					    );

					    put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
					};


# XXX SUCKO FIXME The functionality of the following two calls
# should eventually migrate to (say) src/lib/x-kit/widget/widget-unit-test.pkg
# so as to not clutter up core code with unit-test stuff.
# These are currently here for purely historical reasons:
				    #
				    fun pass_appwindow_exercise_results  (replyqueue: Replyqueue)  (reply_handler: Int -> Void)		# PUBLIC.
					=
					{   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Int );

					    put_in_mailqueue  (appwindow_q,
						#
						\\ (r: Runstate)
						    =
						    {   exa::exercise_x_appwindow  window;
							#
							put_in_oneshot (reply_oneshot, 0);
						    }
					    );

					    put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
					};
				    #
				    fun exercise_appwindow ()										# PUBLIC.
					=	
					{   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Void );
					    #
					    put_in_mailqueue  (appwindow_q,
						#
						\\ (r: Runstate)
						    =
						    {   exa::exercise_x_appwindow  window;
							#
							put_in_oneshot (reply_oneshot, ());
						    }
					    );

					    \\ () = get_from_oneshot reply_oneshot;							# Return a thunk which will wait until exercise is complete.
					};


				    fun send_fake_key_press_event									# Make 'window' receive a (faked) keyboard keypress at 'point'.
					  (
					    keycode:	evt::Keycode,									#  Keyboard key just "pressed down".
					    point:	xg::Point
					  )
					=
					{   keycode =  g2x::gui_keycode_to_x_keycode  keycode;
					    #
# window.windowsystem_to_xserver.draw_ops
# windowsystem_to_xserver.xclient_to_sequencer
# xclient_to_sequencer	src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#	    send_xrequest_and_read_reply:			v1u::Vector -> Mailop( v1u::Vector ),
#	    send_xrequest_and_pass_reply:			v1u::Vector -> Replyqueue -> (v1u::Vector -> Void) -> Void,
#	    send_xrequest_and_read_reply':			(v1u::Vector, Oneshot_Maildrop(Reply_Mail)) -> Void,


					    xj::send_fake_key_press_xevent
						#
						window.screen.xsession
						#
						{ window, keycode, point };
					};

				    fun send_fake_key_release_event									# Make 'window' receive a (faked) keyboard key release at 'point'.
					  (
					    keycode:	evt::Keycode,									#  Keyboard key just "released".
					    point:	xg::Point
					  )
					=
					{   keycode =  g2x::gui_keycode_to_x_keycode  keycode;
					    #
					    xj::send_fake_key_release_xevent
						#
						window.screen.xsession
						#
						{ window, keycode, point };
					};

				    fun send_fake_mousebutton_press_event								# Make 'window' receive a (faked) mousebutton click at 'point'.
					  (
					    button:	evt::Mousebutton,								# Mouse button just "clicked down".
					    point:	xg::Point
					  )
					=
					{   button =  g2x::gui_mousebutton_to_x_mousebutton  button;
					    #
					    xj::send_fake_mousebutton_press_xevent
						#
						window.screen.xsession
						#
						{ window, button, point };
					};


				    fun send_fake_mousebutton_release_event								# Counterpart of previous:  make 'window' receive a (faked) mousebutton release at 'point'.
					  (
					    button:	evt::Mousebutton,								# Mouse button just "released".
					    point:	xg::Point
					  )
					=
					{   button =  g2x::gui_mousebutton_to_x_mousebutton  button;
					    #
					    xj::send_fake_mousebutton_release_xevent
						#
						window.screen.xsession
						#
						{ window, button, point };
					};

				    fun send_fake_mouse_motion_event									# Make window receive a (faked) mouse "drag".
					  (
					    buttons:	List(evt::Mousebutton),								# Mouse button(s) being "dragged".
					    point:	xg::Point
					  )
					=
					{   buttons =  map  g2x::gui_mousebutton_to_x_mousebutton  buttons;
					    #
					    xj::send_fake_mouse_motion_xevent
						#
						window.screen.xsession
						#
						{ window, buttons, point };
					};

				    fun send_fake_''mouse_enter''_event									# Make window receive a (faked) "mouse-enter".
					  (
					    point:	xg::Point									# End-of-event coordinate, thus should be just inside window.
					  )
					=
					xj::send_fake_''mouse_enter''_xevent
					    #
					    window.screen.xsession
					    #
					    { window, point };


				    fun send_fake_''mouse_leave''_event									# Make window receive a (faked) "mouse-leave".
					  (
					    point:	xg::Point									# End-of-event coordinate, thus should be just outside window.
					  )
					=
					xj::send_fake_''mouse_leave''_xevent
					    #
					    window.screen.xsession
					    #
					    { window, point };

# Soon:
				    fun get_pixel_rectangle (window_rectangle_to_read: xg::Box)
					=
					{
					    rw_matrix_rgb8 =  cpt::make_clientside_pixmat_from_window (window_rectangle_to_read, window);		# Read selected part of our window from X server.
					    #
					    rw_matrix_rgb8;
					};

				    guiboss_to_topwindow
					=
					{ id	=> issue_unique_id(),									# We want every guiboss_to_topwindow.id value to be unique within the running Mythryl process (address space).
					  #												# Consequently we don't use our microthread 'id' here because we will typically have multiple topwindows per windowsystem imp.
					  #												# Similarly    We don't use window.window_id here because we might have multiple windowsystem imps talking to different
					  #												# X servers, two of which might issue identical window.window_id values.
					  subscribe_to_changes,			# X
					  draw_displaylist,			# X
					  pass_window_site,			# X
					  exercise_appwindow,			# X
					  pass_appwindow_exercise_results,	# X


					  send_fake_key_press_event,									# Make 'window' receive a (faked) keyboard keypress at 'point'.
					  send_fake_key_release_event,									# Make 'window' receive a (faked) keyboard key release at 'point'.
					  send_fake_mousebutton_press_event,								# Make 'window' receive a (faked) mousebutton click at 'point'.
					  send_fake_mousebutton_release_event,								# Counterpart of previous:  make 'window' receive a (faked) mousebutton release at 'point'.
					  send_fake_mouse_motion_event,									# Make window receive a (faked) mouse "drag".
					  send_fake_''mouse_enter''_event,								# Make window receive a (faked) "mouse-enter".
					  send_fake_''mouse_leave''_event,								# Make window receive a (faked) "mouse-leave".

# Soon:
					  get_pixel_rectangle
#				  -> 
#				  mtx::Rw_Matrix( r8::Rgb8 )							# RGB values for those pixels. NB: Results are undefined if window is not fully visible.

					};

				    
				    put_in_oneshot (reply_oneshot, guiboss_to_topwindow);
				}
			);

			get_from_oneshot reply_oneshot;
		    };


	    end;

	#
	fun process_options (options: List(Windowsystem_Option), { name, id, change_callbacks, windowsystem_callbacks })
	    =
	    {   my_name				=  REF name;
		my_id				=  REF id;
		my_change_callbacks		=     change_callbacks;		# Comes with REF pre-installed.
		my_windowsystem_callbacks	= REF windowsystem_callbacks;

		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME	 n)  =>  my_name			:=  n;
		        do_option (ID			 i)  =>  my_id				:=  i;
			#
			do_option (CHANGE_CALLBACK	 c)  =>  my_change_callbacks		:=  c ! *my_change_callbacks;
			do_option (WINDOWSYSTEM_CALLBACK c)  =>  my_windowsystem_callbacks	:=  c ! *my_windowsystem_callbacks;
		    end;
		end;

		{ name				=>  *my_name,
		  id 				=>  *my_id,
		  #
		  change_callbacks		=>   my_change_callbacks,
		  windowsystem_callbacks	=>  *my_windowsystem_callbacks
	        };
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_windowsystem_egg
	        ( needs:	     Windowsystem_Needs,
		  options:	List(Windowsystem_Option)
		)
		(endstate_oneshot:	 Null_Or(Oneshot_Maildrop(gws::Windowsystem_Arg)))					# When end_gun fires we save our state in this and exit.
	    =
	    {   (process_options
		  ( options,
		    { name			=>  "windowsystem_imp_for_x",
		      id			=>  id_zero,
		      #	
		      change_callbacks		=> REF([]),
		      windowsystem_callbacks	=> []
		    }
		) )
		  ->
		  { name,
		    id,
		    #
		    change_callbacks,
		    windowsystem_callbacks
		  };
	
		my (id, options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();										# Allocate unique imp id.
			(id, ID id ! options);										# Make our id stable across stop/restart cycles.
		    else
			(id, options);
		    fi;

		me =  { id,
			state =>  REF needs
		      };

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );		# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));					# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);
			    #
			    fun phase3											# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, options, imports, run_gun', end_gun', endstate_oneshot, change_callbacks, windowsystem_callbacks });
				};

			    (exports, phase3);
			};
	    };
    };

end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
