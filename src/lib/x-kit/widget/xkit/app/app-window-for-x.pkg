## app-window-for-x.pkg

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include threadkit;						# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ap  =  atom_port;					# atom_port			is from   src/lib/x-kit/xclient/src/iccc/atom-port.pkg
    package au  =  authentication;				# authentication		is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap			is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat			is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
    package dy  =  display;					# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package et  =  event_types;					# event_types			is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package exp =  xserver_port;				# xserver_port			is from   src/lib/x-kit/xclient/src/window/xserver-port.pkg
#   package fil =  file__premicrothread;			# file__premicrothread		is from   src/lib/std/src/posix/file--premicrothread.pkg
    package fti =  font_index;					# font_index			is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
    package kp  =  keymap_port;					# keymap_port			is from   src/lib/x-kit/xclient/src/window/keymap-port.pkg
#   package mtx =  rw_matrix;					# rw_matrix			is from   src/lib/std/src/rw-matrix.pkg
#   package r8  =  rgb8;					# rgb8				is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
#   package rgb =  rgb;						# rgb				is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package rop =  ro_pixmap;					# ro_pixmap			is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
    package rw  =  root_window;					# root_window			is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector			is from   src/lib/std/src/rw-vector.pkg
    package s2p =  xevent_to_window_port;			# xevent_to_window_port		is from   src/lib/x-kit/xclient/src/window/xevent-to-window-port.pkg
    package sep =  selection_port;				# selection_port		is from   src/lib/x-kit/xclient/src/window/selection-port.pkg
    package shp =  shade_port;					# shade_port			is from   src/lib/x-kit/widget/lib/shade-port.pkg
    package sj  =  socket_junk;					# socket_junk			is from   src/lib/internet/socket-junk.pkg
    package sp  =  xsequencer_port;				# xsequencer_port		is from   src/lib/x-kit/xclient/src/wire/xsequencer-port.pkg
#   package tr  =  logger;					# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt			is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts	is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire			is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget			is from   src/lib/x-kit/widget/basic/widget.pkg
    package wi  =  window;					# window			is from   src/lib/x-kit/xclient/src/window/window.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink		is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package wpp =  window_property_port;			# window_property_port		is from   src/lib/x-kit/xclient/src/window/window-property-port.pkg
    package wy  =  widget_style;				# widget_style			is from   src/lib/x-kit/widget/lib/widget-style.pkg
    package x2s =  xevent_to_string;				# xevent_to_string		is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
#   package xc  =  xclient;					# xclient			is from   src/lib/x-kit/xclient/xclient.pkg
    package xg  =  xgeometry;					# xgeometry			is from   src/lib/std/2d/xgeometry.pkg
    package xj  =  xsession_junk;				# xsession_junk			is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package xt  =  xtypes;					# xtypes			is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
#   package xtr =  xlogger;					# xlogger			is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #
    tracefile   =  "widget-unit-test.trace.log";
herein

    package app_window_for_x
    :       App_Window_For_X												# App_Window_For_X			is from   src/lib/x-kit/widget/xkit/app/app-window-for-x.api
    {
	#
	include app_window_for_x_port;											# app_window_for_x_port			is from   src/lib/x-kit/widget/shape/label-shape-port.pkg
	#
	App_Window_For_X_State = Ref( Void );										# Opaque wrapper for all nonephemeral mutable state maintained by shape.

	Imports = {													# Ports we use, provided by other imps.
		    int_sink: Int -> Void
		  };

	Configstate = Mailslot( { imports:	Imports,
				  me:		App_Window_For_X_State,
				  run_gun':	Run_Gun,
				  end_gun':	End_Gun
                                }
                              );

	Label_Plea =  DO_SOMETHING Int
		    |  PASS_SOMETHING Oneshot_Maildrop( Int )
		    ;
	Label_Q    = Mailqueue( Label_Plea );


	Exports	= {													# Ports we provide for use by other imps.
		    app_window_for_x_port:	App_Window_For_X_Port
		  };

	fun create_window   (xsequencer_port: sp::Xsequencer_Port)				# Create a new X-window with the given xid 
	    {
	      window_id:    	xt::Window_Id,
	      parent_window_id:	xt::Window_Id,
	      visual_id:	xt::Visual_Id_Choice,
	      #	
	      io_class:		xt::Io_Class,
	      depth:		Int,
	      site:		xg::Window_Site,
	      attributes:	List( xt::a::Window_Attribute )
	    }
	    =
	    xsequencer_port.send_xrequest  msg
	    where 
		msg =   v2w::encode_create_window
			  {
			    window_id,
			    parent_window_id,
			    visual_id,
			    io_class,
			    depth,
			    site,
			    attributes
			  };
	    end;

	fun create_x_window_plus_supporting_impnet ()
	    =
	    {
		(au::get_xdisplay_string_and_xauthentication  NULL)
		    ->
		    ( display_name:     String,						# Typically from $DISPLAY environment variable.
		      xauthentication:  Null_Or(xt::Xauthentication)			# Typically from ~/.Xauthority
		    );

		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		root_window = 	rw::make_root_window { display_name,
						       xauthentication,
						       run_gun',
						       end_gun'
						     };

		root_window ->  rw::ROOT_WINDOW
					  { screen:			xj::Screen,
					    id:				Ref( Void ),					# Here we are just taking advantage of the fact that all REFs are distinct.
					    #										# We should eventually convert this to a proper small-int id -- eventually
					    #										# one wants to use the id as a key for lookup.  -- 2013-07-21 CrT
					    make_shade:			rgb::Rgb -> shp::Shades,
					    make_tile:			String -> rop::Ro_Pixmap,
					    #
					    style:			wy::Widget_Style,
					    next_widget_id:		Void -> Int
					  };


		screen ->    xj::SCREEN   { xsession:			xj::Xsession,
					    screen_info:		xj::Screen_Info
					  };


		screen_info
		    ->
		         xj::SCREEN_INFO  { xscreen:			dy::Xscreen,
					    per_depth_imps:		List (xj::Per_Depth_Imps),
					    rootwindow_per_depth_imps:        xj::Per_Depth_Imps
					  };	

		xsession -> xj::XSESSION  { xdisplay:			dy::Xdisplay,          				#  
					    screens:			List( xj::Screen_Info ),			# Screens attached to this display.  Always a length-1 list in practice.

					    default_screen_info:   	xj::Screen_Info,

					    xevent_to_window_port:	s2p::Xevent_To_Window_Port,			# Feeds X events to appropriate toplevel window.

					    font_index:          	fti::Font_Index,
					    atom_port:          	ap::Atom_Port,

					    window_property_port:	wpp::Window_Property_Port,
					    selection_port:     	sep::Selection_Port,

					    xsequencer_port:		sp::Xsequencer_Port,
					    keymap_port:		kp::Keymap_Port
					  };

		xdisplay -> dy::XDISPLAY  { socket: 			sj::Stream_Socket(Int),				# Actual unix socket fd, wrapped up a bit. The 'Int' part is bogus -- I don't get what Reppy was trying to do with that phantom type.
					    #
					    name:			String,						# "host: display::screen",     e.g. "foo.com:0.0".
					    vendor:			String,						# Name of the server's vendor, e.g. 'The X.Org Foundation'.

					    default_screen => default_screen_number:	Int,				# Number of the default screen.  Always 0 in practice.

					    screens => display_screens:	List( dy::Xscreen ),				# Screens attached to this display.  Always a length-1 list in practice.

					    pixmap_formats:		List( xt::Pixmap_Format ),
					    max_request_length:	Int,

					    image_byte_order:		xt::Order,
					    bitmap_bit_order:		xt::Order,

					    bitmap_scanline_unit:	xt::Raw_Format,
					    bitmap_scanline_pad:	xt::Raw_Format,

					    min_keycode:		xt::Keycode,
					    max_keycode:		xt::Keycode,

					    next_xid:			Void -> xt::Xid					# resource id allocator. Implemented below by spawn_xid_factory_thread()    from   src/lib/x-kit/xclient/src/wire/display-old.pkg
					  };
			
		default_screen =   xj::default_screen_of  xsession;

		screen =  list::nth  (display_screens, default_screen_number);

		screen ->  dy::XSCREEN { root_window_id, root_visual, black_rgb8, white_rgb8, ... };

		background_pixel =  rgb8::rgb8_from_ints (128+64, 128+32, 128+16);
		border_pixel     =  black_rgb8;

		window_id        =  next_xid ();

		fire_run_gun ();

		window_has_received_first_expose_xevent_oneshot
			=
			make_oneshot_maildrop(): Oneshot_Maildrop(Void);

		fun wait_until_window_has_received_first_expose_xevent ()
		    =
		    get_from_oneshot  window_has_received_first_expose_xevent_oneshot;
			 

		fun xevent_sink ( route:		s2p::Envelope_Route,
				  event:		et::x::Event
				)
		    =
		    {   
			#
			case event
			    #
			    et::x::EXPOSE { exposed_window_id:  xt::Window_Id,				# The exposed window. 
					    boxes:              List( xg::Box ),			# The exposed rectangle.  The list is
													# so  that multiple events can be packed. 
					    count:              Int					# Number of subsequent expose events.
					  }
				=>  {
					printf "xevent_sink(): EXPOSE { exposed_window_id d=%d (window_id d=%d) count d=%d list::length boxes d=%d     -- xclient-unit-test.pkg\n"
					    (xt::xid_to_int exposed_window_id)
					    (xt::xid_to_int window_id)
					    count
					    (list::length boxes)
					;

					if (xt::same_xid (exposed_window_id, window_id))
					    #
					    put_in_oneshot (window_has_received_first_expose_xevent_oneshot, ());
					fi;
				    };

			    _   =>  printf "xevent_sink(): ignoring '%s' x event     -- xclient-unit-test.pkg\n" (x2s::xevent_name event);

			esac;
		    };

		xevent_to_window_port.note_new_topwindow
		  (
		    window_id,
		    xg::WINDOW_SITE  { upperleft    =>  xg::POINT { col => 0,   row => 0  },
				       size         =>  xg::SIZE { wide => 100, high => 100 },
				       border_thickness =>  1
				     },
		    xevent_sink
		  );

		case root_visual
		    #
		    xt::VISUAL { visual_id, depth as 24, red_mask => 0uxFF0000, green_mask => 0ux00FF00, blue_mask => 0ux0000FF, ... }		# Code currently assumes that we always get this case.
                        =>
                        {
			    create_window   xsequencer_port									# Create a window on the X server to draw stuff in etc.
			      {
				window_id,
				parent_window_id =>	root_window_id,

				visual_id        =>	xt::SAME_VISUAL_AS_PARENT,
				#
				depth,
				io_class	 =>	xt::INPUT_OUTPUT,
				#
				site		 =>    	xg::WINDOW_SITE
							  { upperleft    =>  xg::POINT { col=>0,   row=>0 },
							    size         =>  xg::SIZE { wide=>100, high=>100 },
							    border_thickness =>  1
							  },

				attributes	 =>     [ xt::a::BORDER_PIXEL     border_pixel,
							  xt::a::BACKGROUND_PIXEL background_pixel,
							  xt::a::EVENT_MASK       wi::standard_xevent_mask
							]
			      };

			    xsequencer_port.send_xrequest  (v2w::encode_map_window { window_id });				# "map" (make visible) our new window.


			    wait_until_window_has_received_first_expose_xevent ();


			    per_depth_imps = xj::per_depth_imps_for_depth (default_screen, depth);

			    per_depth_imps
				->
				xj::PER_DEPTH_IMPS    { depth:			Int,
							xserver_port:		exp::Xserver_Port,				# The xpacket encoder  for this depth on this screen.
							window_map_event_sink:	wme::Window_Map_Event_Sink
						      };									#

			    window = xj::WINDOW { window_id, screen => default_screen, per_depth_imps, xserver_port };		# Create a client-side xj::WINDOW to represent our new X server window.


			    (fire_end_gun, window);
			};

		    xt::VISUAL { visual_id, depth, red_mask, green_mask, blue_mask, ... }
                        =>
                        {   printf      "This code assumes root visual has depth=24 red_mask=0xff0000 green_mask=0x00ff00 blue_mask=0x0000ff\n\
					\but actually the  root visual has depth=%d red_mask=0x%06x green_mask=0x%06x blue_mask=0x%06x  -- app-window-for-x.pkg\n"  depth  (unt::to_int red_mask)  (unt::to_int green_mask)  (unt::to_int blue_mask);
			    raise exception FAIL "Unsupported X visual. -- app-window-for-x.pkg";
			};

		    xt::NO_VISUAL_FOR_THIS_DEPTH int
                        =>
                        {   # This case should never happen.
			    raise exception FAIL "root_visual is NO_VISUAL_FOR_THIS_DEPTH?! -- app-window-for-x.pkg";
			};
		esac;
	    };


	fun run {													# These values will be statically globally visible throughout the code body for the imp.
		    me:			App_Window_For_X_State,								# State which is preserved across imp shutdown/restart cycles.
		    imports:		Imports,									# Imps to which we send requests.
		    to:			Replyqueue,									# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':		End_Gun,									# We shut down the microthread when this fires.
		    label_q:		Label_Q										# 
		}
	    =
	    loop ()
	    where
		(create_x_window_plus_supporting_impnet ())
		    ->
		    ( fire_end_gun:	Void -> Void,
		      window:		xj::Window
		    );

		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                        ==>  shut_down_label_imp'),
			    (take_from_mailqueue' label_q    ==>  do_label_plea)
			];

			loop ();
		    }	
		    where
			fun shut_down_label_imp' ()
			    =
			    {   fire_end_gun ();
				#
				thread_exit { success => TRUE };							# Will not return.
			    };

			fun do_label_plea  (DO_SOMETHING i)
			        =>
				{   imports.int_sink i;									# Demonstrate use of imports.
				};

			    do_label_plea  (PASS_SOMETHING reply_oneshot)
				=>
				{   put_in_oneshot (reply_oneshot, 0);
				};
			end;
		    end;
	    end;	



	fun startup   (reply_oneshot:  Oneshot_Maildrop( (Configstate, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   configstate  =  make_mailslot  ()	:  Configstate;

		app_window_for_x_port
		    =
		    { do_something, pass_something };

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (configstate, { app_window_for_x_port }));				# Return value from make_app_window_for_x().

		(take_from_mailslot  configstate)									# Input args from configure_app_window_for_x().
		    ->
		    { me, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		run { me, label_q, imports, to, end_gun' };								# Will not return.
	    }
	    where
		label_q     =  make_mailqueue (get_current_microthread()):  Label_Q;

		fun do_something (i: Int)										# External entrypoint.
		    =	
		    put_in_mailqueue  (label_q, DO_SOMETHING i);


		fun pass_something  (replyqueue: Replyqueue)  (reply_handler: Int -> Void)				# External entrypoint.
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( Int );
			#
			put_in_mailqueue  (label_q, PASS_SOMETHING reply_oneshot);

			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };
	    end;


        ##########################################################################################
	# External entrypoints
	#
	fun make_app_window_for_x_state ()										# External entrypoint.
	    =
	    REF ();

	fun make_app_window_for_x  (name: String)									# External entrypoint.
	    =
	    {   reply_oneshot = make_oneshot_maildrop();
		#
		xlogger::make_thread  name  (startup  reply_oneshot);							# Note that startup() is curried.

		get_from_oneshot  reply_oneshot;
	    };

	fun configure_app_window_for_x											# External entrypoint.
	      (
		configstate:	Configstate,
		me:		App_Window_For_X_State,
		imports:	Imports,
		run_gun':	Run_Gun,
		end_gun':	End_Gun
	      )
	    =
	    put_in_mailslot  (configstate, { me, imports, run_gun', end_gun' });

    };

end;
