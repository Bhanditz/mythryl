## packed-theme-imp.pkg
#
# For the big picture see the imp dataflow diagrams in
#
#     src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
#

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;						# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;						# client_to_atom			is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;						# authentication			is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;							# cs_pixmap				is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;							# cs_pixmat				is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;							# display				is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package xet =  xevent_types;						# xevent_types				is from   src/lib/x-kit/xclient/src/wire/xevent-types.pkg
#   package w2x =  windowsystem_to_xserver;					# windowsystem_to_xserver		is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xserver.pkg
#   package fil =  file__premicrothread;					# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;							# font_index				is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;					# xevent_router_to_keymap		is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;							# rw_matrix				is from   src/lib/std/src/rw-matrix.pkg
#   package r8  =  rgb8;							# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
#   package rgb =  rgb;								# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
#   package rop =  ro_pixmap;							# ro_pixmap				is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;							# root_window				is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;							# rw_vector				is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;						# client_to_selection			is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;							# shade					is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;							# socket_junk				is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;					# xclient_to_sequencer			is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;							# logger				is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;					# thread_scheduler_is_running		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;						# one_byte_unt				is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;					# vector_of_one_byte_unts		is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;						# value_to_wire				is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;							# widget				is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;							# window				is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;					# window_map_event_sink			is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;					# client_to_window_watcher		is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;						# widget_style				is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package e2s =  xevent_to_string;						# xevent_to_string			is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
#   package xc  =  xclient;							# xclient				is from   src/lib/x-kit/xclient/xclient.pkg
#   package xg  =  xgeometry;							# xgeometry				is from   src/lib/std/2d/xgeometry.pkg
#   package xj  =  xsession_junk;						# xsession_junk				is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xt  =  xtypes;							# xtypes				is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
#   package xtr =  xlogger;							# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #	
    package g2a =  guiboss_to_windowsystem;					# guiboss_to_windowsystem		is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg
    #	
    package ps  =  guiboss_to_packedspace;					# guiboss_to_packedspace		is from   src/lib/x-kit/widget/space/packed/guiboss-to-packedspace.pkg
    package psi =  packedspace_imp;						# packedspace_imp			is from   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
    #	
    package w2p =  widget_to_packedspace;					# widget_to_packedspace			is from   src/lib/x-kit/widget/space/packed/widget-to-packedspace.pkg	
    #
    package sg  =  stopped_gui;							# stopped_gui				is from   src/lib/x-kit/widget/gui/stopped-gui.pkg
    package gp  =  gui_plan;							# gui_plan				is from   src/lib/x-kit/widget/gui/gui-plan.pkg
    package gd  =  gui_displaylist;						# gui_displaylist			is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    #
    package g2g =  gadget_to_guiboss;						# gadget_to_guiboss			is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg

    package c64 =  rgb;		# Colors with Float64 red-green-blue values.	# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package c8  =  rgb8;	# Colors with Unt8    red-green-blue values.	# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    #
    package xg  =  xgeometry;							# xgeometry				is from   src/lib/std/2d/xgeometry.pkg

    tracefile   =  "widget-unit-test.trace.log";
herein

    package packed_theme_imp
    :       Packed_Theme_Imp												# Packed_Theme_Imp		is from   src/lib/x-kit/widget/theme/packed/packed-theme-imp.api
    {
	#
	include package   packed_theme;											# packed_theme			is from   src/lib/x-kit/widget/theme/packed/packed-theme.pkg
	#
	Theme_State = Ref( Void );											# Holds all nonephemeral mutable state maintained by skin.

	Imports = {													# Ports we use, provided by other imps.
		    int_sink:			Int -> Void,
		    guiboss_to_windowsystem:	g2a::Guiboss_To_Windowsystem
		  };

	Me_Slot = Mailslot( { imports:	Imports,
			      me:	Theme_State,
			      run_gun':	Run_Gun,
			      end_gun':	End_Gun
			    }
			  );
	Exports	= {													# Ports we provide for use by other imps.
		    theme:		Packed_Theme
		  };


	Option = MICROTHREAD_NAME String;										# 

	Packed_Theme_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);

	Runstate =  {													# These values will be statically globally visible throughout the code body for the imp.
		      me:		Theme_State,									# State which is preserved across imp shutdown/restart cycles.
		      imports:		Imports,									# Imps to which we send requests.
		      to:		Replyqueue,									# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		      end_gun':		End_Gun										# We shut down the microthread when this fires.
		    };

	Theme_Q    = Mailqueue( Runstate -> Void );

	fun run ( theme_q:		Theme_Q,									# 
		  #
		  runstate as
		  {													# These values will be statically globally visible throughout the code body for the imp.
		    me:			Theme_State,									# State which is preserved across imp shutdown/restart cycles.
		    imports:		Imports,									# Imps to which we send requests.
		    to:			Replyqueue,									# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':		End_Gun										# We shut down the microthread when this fires.
		  }
		)
	    =
	    loop ()
	    where
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                        ==>  shut_down_theme_imp'),
			    (take_from_mailqueue' theme_q    ==>  do_theme_plea)
			];

			loop ();
		    }	
		    where
			fun do_theme_plea thunk
			    =
			    thunk runstate;

			fun shut_down_theme_imp' ()
			    =
			    {
				thread_exit { success => TRUE };							# Will not return.	
			    };
		    end;
	    end;	



	fun startup   (reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#

		# Functions like text_color refer to packed_theme
		# but packed_theme also refers to them.  We break
		# the cycle via a four-step dance:
		#
		#   1)  Define dummy fns.
		#   2)  Define packed_theme in terms of them.
		#   3)  Define real fns in terms of packed_theme.
		#   4)  Plug the real fns into packed_theme, replacing the dummy fns.
		#
		# Here are the dummies:
		#
		text_color		= REF (\\ _ = c64::white);
		normal_body_color	= REF (\\ _ = c64::white);
		mouse_focus_body_color	= REF (\\ _ = c64::white);
		sunny_bevel_color	= REF (\\ _ = c64::white);
		shady_bevel_color	= REF (\\ _ = c64::white);
		current_gadget_colors	= REF (\\ _ = { surround_color		=> c64::white,
							body_color		=> c64::white,
							text_color		=> c64::white,
							upperleft_bevel_color	=> c64::white,
							lowerright_bevel_color	=> c64::white
						      }
					      );
		frame3d			= REF (\\ _ = \\ _ = gd::POLY_POINT []);
		filled_frame3d		= REF (\\ _ = \\ _ = gd::POLY_POINT []);
		cartouche3d		= REF (\\ _ = \\ _ = gd::POLY_POINT []);
		polygon3d		= REF (\\ _ = \\ _ = gd::POLY_POINT []);


#		dummy_make_button_displaylist:	Ref ((g2g::Gadget_Mode, Bool) -> Displaylist)	# Bool is on/off state of button,  shown by interchanging roles of light_edge_color and dark_edge_color.


		# A few packed_theme fns don't refer to packed_theme,
		# so we can define the real versions of them before
		# defining packed_theme:

		fun slight_darkening ({ red, green, blue }: c64::Rgb) =
		  { red	  =>  red   * 0.9,
		    green =>  green * 0.9,
		    blue  =>  blue  * 0.9
		  };

		fun medium_darkening ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  red   * 0.5,
		    green =>  green * 0.5,
		    blue  =>  blue  * 0.5
		  };

		fun lavish_darkening ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  red   * 0.3,
		    green =>  green * 0.3,
		    blue  =>  blue  * 0.3
		  };



		fun slight_graying ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  red    -  (red   - 0.5) * 0.3,
		    green =>  green  -  (green - 0.5) * 0.3,
		    blue  =>  blue   -  (blue  - 0.5) * 0.3
		  };

		fun medium_graying ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  red    -  (red   - 0.5) * 0.5,
		    green =>  green  -  (green - 0.5) * 0.5,
		    blue  =>  blue   -  (blue  - 0.5) * 0.5
		  };

		fun lavish_graying ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  red    -  (red   - 0.5) * 0.9,
		    green =>  green  -  (green - 0.5) * 0.9,
		    blue  =>  blue   -  (blue  - 0.5) * 0.9
		  };



		fun slight_lightening ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  1.0 - ((1.0 -   red) * 0.9),
		    green =>  1.0 - ((1.0 - green) * 0.9),
		    blue  =>  1.0 - ((1.0 -  blue) * 0.9)
		  };

		fun medium_lightening ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  1.0 - ((1.0 -   red) * 0.5),
		    green =>  1.0 - ((1.0 - green) * 0.5),
		    blue  =>  1.0 - ((1.0 -  blue) * 0.5)
		  };

		fun lavish_lightening ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  1.0 - ((1.0 -   red) * 0.3),
		    green =>  1.0 - ((1.0 - green) * 0.3),
		    blue  =>  1.0 - ((1.0 -  blue) * 0.3)
		  };


		fun rgb_to_rgb8
		    ( { surround_color:			c64::Rgb,
			body_color:			c64::Rgb,
			text_color:			c64::Rgb,
			#
			upperleft_bevel_color:		c64::Rgb,
			lowerright_bevel_color:		c64::Rgb
		      } :				Gadget_Palette
		    )
	  	    =
		    {
		      { surround_color		=>	c8::rgb8_from_rgb	        surround_color,
			body_color		=>	c8::rgb8_from_rgb	            body_color,
			text_color		=>	c8::rgb8_from_rgb	            text_color,
			#
			upperleft_bevel_color	=>   	c8::rgb8_from_rgb	 upperleft_bevel_color,
			lowerright_bevel_color	=>	c8::rgb8_from_rgb	lowerright_bevel_color
		      }
		      :					Gadget_Palette8;
		    };

			
		theme =	  {								# We'll rename this to packed_theme later, for now a shorter name is nice.
			    do_something,
#			    packedspace,
			    #
			    surround_color  =>    REF { red	=> 0.2,			# Nice light gray background for GUI.
							green	=> 0.2,
							blue	=> 0.2
						      },
			    #
			    slight_darkening  =>  REF slight_darkening,			# Real fn.
			    medium_darkening  =>  REF medium_darkening,			# Real fn.
			    lavish_darkening  =>  REF lavish_darkening,			# Real fn.
			    #
			    slight_graying    =>  REF slight_graying,			# Real fn.
			    medium_graying    =>  REF medium_graying,			# Real fn.
			    lavish_graying    =>  REF lavish_graying,			# Real fn.
			    #
			    slight_lightening =>  REF slight_lightening,		# Real fn.
			    medium_lightening =>  REF medium_lightening,		# Real fn.
			    lavish_lightening =>  REF lavish_lightening,		# Real fn.
			    #
			    rgb_to_rgb8	      =>  REF rgb_to_rgb8,			# Real fn.
			    #
			    text_color,							# Dummy fn.
			    normal_body_color,						# Dummy fn.
			    mouse_focus_body_color,					# Dummy fn.
			    sunny_bevel_color,						# Dummy fn.
			    shady_bevel_color,						# Dummy fn.
			    frame3d,							# Dummy fn.
			    filled_frame3d,						# Dummy fn.
			    cartouche3d,						# Dummy fn.
			    polygon3d,							# Dummy fn.

			    current_gadget_colors

#			    dummy_make_button_displaylist
			  };



		# Time to define the real versions of the above dummy fns:

		fun text_color ()
		    =
		    {   (*theme.surround_color)
			    ->
			    { red, green, blue };

			text_color
			    =
			    if  ( ( abs (red   - 0.5)
				  + abs (green - 0.5)
				  + abs (blue  - 0.5)
				  )
				  >
				  0.3
				)

				{ red	=>  1.0 -   red,			# Normal case: Complement the color, which will turn white to black etc for good reading contrast.
				  green	=>  1.0 - green,
				  blue	=>  1.0 -  blue
				};
			    else
				{ red	=>  0.0,				# User's color is nearly neutral gray (meaning that complementing it will yield near-zero contrast) so go for black text instead.
				  green	=>  0.0,
				  blue	=>  0.0
				};
			    fi;				

			text_color;
		    };

		fun normal_body_color ()	=			     *theme.surround_color;
		fun mouse_focus_body_color ()   = *theme.slight_lightening   *theme.surround_color;
		fun sunny_bevel_color ()	= *theme.slight_darkening    *theme.surround_color;
		fun shady_bevel_color ()	= *theme.lavish_darkening    *theme.surround_color;
		#
		fun current_gadget_colors													# Compute appropriate gadget colors based on mode and on/off status. This avoids duplicating this logic in every button etc
		      {																# and provides a central place for customizing these decisions.
			gadget_is_on:	  Bool,
			#
			gadget => gadget as
				          {
					    is_active:				Bool,								# An inactive gadget is passed no user input. Inactive widgets are typically drawn "grayed-out".
					    has_mouse_focus:			Bool,								# A widget which has the mouse cursor on it may want to draw itself brigher or such.
					    has_keyboard_focus:			Bool,								# A widget which has the keyboard focus will often      draw a black outline around its text-entry rectangle.
					    mousebutton_is_down:		Bool								# I'm not sure if this belongs here. Not currently used.
					  } :					g2g::Gadget_Mode
		      }
		    =
		    {
			# Get our base colors from the theme:
			#
			surround_color		= *theme.surround_color;
			text_color		= *theme.text_color ();
			normal_body_color	= *theme.normal_body_color ();
			mouse_focus_body_color	= *theme.mouse_focus_body_color ();
			sunny_bevel_color	= *theme.sunny_bevel_color ();
			shady_bevel_color	= *theme.shady_bevel_color ();

			text_color =	if gadget.is_active					text_color;
					else				*theme.medium_graying	text_color;					# Gray out inactive widget.
					fi;

			body_color =	if gadget.has_mouse_focus				mouse_focus_body_color;
					else							normal_body_color;				# Gray out inactive widget.
					fi;

			my  ( upperleft_bevel_color,
			      lowerright_bevel_color
			    )
			    =
			    if gadget_is_on	(shady_bevel_color, sunny_bevel_color);								# Make button look pressed.
			    else		(sunny_bevel_color, shady_bevel_color);								# Make button look popped.
			    fi;


			{ surround_color,
			  body_color,
			  text_color,
			  #
			  upperleft_bevel_color,
			  lowerright_bevel_color
			} :				Gadget_Palette;
		    };

		fun frame3d
		      (palette:		Gadget_Palette)
		      (frame:		Frame3d)
		    =	
		    gd::POLY_POINT [];

		fun filled_frame3d
		      (palette:		Gadget_Palette)
		      (frame:		Frame3d)
		    =	
		    gd::POLY_POINT [];

		fun cartouche3d
		      (palette:		Gadget_Palette)
		      (cartouche:	Cartouche3d)
		    =	
		    gd::POLY_POINT [];

		fun polygon3d
		      (palette:		Gadget_Palette)
		      (polygon:		Polygon3d)
		    =	
		    gd::POLY_POINT [];


		# Finally we replace the dummy theme fns with the real ones:
		#
		theme.text_color		:=  text_color;
		theme.normal_body_color		:=  normal_body_color;
		theme.mouse_focus_body_color	:=  mouse_focus_body_color;
		theme.sunny_bevel_color		:=  sunny_bevel_color;
		theme.shady_bevel_color		:=  shady_bevel_color;
		theme.current_gadget_colors	:=  current_gadget_colors;
		theme.frame3d			:=         frame3d;
		theme.filled_frame3d		:=  filled_frame3d;
		theme.cartouche3d		:=     cartouche3d;
		theme.polygon3d			:=       polygon3d;


		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, { theme }));							# Return value from packed_theme_egg'().

		(take_from_mailslot  me_slot)										# Input args from packed_theme_egg'().
		    ->
		    { me, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		run (theme_q, { me, imports, to, end_gun' });								# Will not return.
	    }
	    where
		theme_q     =  make_mailqueue (get_current_microthread()):  Theme_Q;

		fun do_something (i: Int)										# PUBLIC.
		    =	
		    put_in_mailqueue  (theme_q,
			#
			\\ ({ me, imports, ... }: Runstate)
			    =
			    imports.int_sink i										# Demonstrate use of imports.
		    );


#		fun packedspace  (options: ps::Packedspace_Arg)								# PUBLIC.
#		    =
#		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( psi::Packedspace_Egg );
#			#
#			put_in_mailqueue  (theme_q,
#			    #
#			    \\ ({ me, ... })
#				=
#				{   (psi::make_packedspace_egg	options NULL) -> packedspace_egg;
#				    #
#				    put_in_oneshot (reply_oneshot, packedspace_egg);
#				}
#			);
#
#			get_from_oneshot reply_oneshot;
#		    };

	    end;


	fun process_options (options: List(Option), { name })
	    =
	    {   my_name   = REF name;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME n)  =   my_name := n;
		end;

		{ name => *my_name };
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_packed_theme_egg (options: List(Option))								# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	    =
	    {   (process_options (options, { name => "tmp" }))
		    ->
		    { name };
	
		me = REF ();

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );		# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  reply_oneshot);					# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3											# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, imports, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
