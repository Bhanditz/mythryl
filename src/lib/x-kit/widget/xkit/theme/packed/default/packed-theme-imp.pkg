## packed-theme-imp.pkg
#
# For the big picture see the imp dataflow diagrams in
#
#     src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
#

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;						# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;						# client_to_atom			is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;						# authentication			is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;							# cs_pixmap				is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;							# cs_pixmat				is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;							# display				is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package xet =  xevent_types;						# xevent_types				is from   src/lib/x-kit/xclient/src/wire/xevent-types.pkg
#   package w2x =  windowsystem_to_xserver;					# windowsystem_to_xserver		is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xserver.pkg
#   package fil =  file__premicrothread;					# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;							# font_index				is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;					# xevent_router_to_keymap		is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;							# rw_matrix				is from   src/lib/std/src/rw-matrix.pkg
#   package r8  =  rgb8;							# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
#   package rgb =  rgb;								# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
#   package rop =  ro_pixmap;							# ro_pixmap				is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;							# root_window				is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;							# rw_vector				is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;						# client_to_selection			is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;							# shade					is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;							# socket_junk				is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;					# xclient_to_sequencer			is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;							# logger				is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;					# thread_scheduler_is_running		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;						# one_byte_unt				is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;					# vector_of_one_byte_unts		is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;						# value_to_wire				is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;							# widget				is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;							# window				is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;					# window_map_event_sink			is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;					# client_to_window_watcher		is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;						# widget_style				is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package e2s =  xevent_to_string;						# xevent_to_string			is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
#   package xc  =  xclient;							# xclient				is from   src/lib/x-kit/xclient/xclient.pkg
#   package xg  =  xgeometry;							# xgeometry				is from   src/lib/std/2d/xgeometry.pkg
#   package xj  =  xsession_junk;						# xsession_junk				is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xt  =  xtypes;							# xtypes				is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
#   package xtr =  xlogger;							# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #	
    package g2a =  guiboss_to_windowsystem;					# guiboss_to_windowsystem		is from   src/lib/x-kit/widget/theme/guiboss-to-windowsystem.pkg
    #	
    package ps  =  guiboss_to_packedspace;					# guiboss_to_packedspace		is from   src/lib/x-kit/widget/space/packed/guiboss-to-packedspace.pkg
    package psi =  packedspace_imp;						# packedspace_imp			is from   src/lib/x-kit/widget/space/packed/packedspace-imp.pkg
    #	
    package w2p =  widget_to_packedspace;					# widget_to_packedspace			is from   src/lib/x-kit/widget/space/packed/widget-to-packedspace.pkg	
    #
    package sg  =  stopped_gui;							# stopped_gui				is from   src/lib/x-kit/widget/gui/stopped-gui.pkg
    package gp  =  gui_plan;							# gui_plan				is from   src/lib/x-kit/widget/gui/gui-plan.pkg
    package gd  =  gui_displaylist;						# gui_displaylist			is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    #
    package g2g =  gadget_to_guiboss;						# gadget_to_guiboss			is from   src/lib/x-kit/widget/gui/gadget-to-guiboss.pkg

    package c64 =  rgb;		# Colors with Float64 red-green-blue values.	# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package c8  =  rgb8;	# Colors with Unt8    red-green-blue values.	# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    #
    package xg  =  xgeometry;							# xgeometry				is from   src/lib/std/2d/xgeometry.pkg

    tracefile   =  "widget-unit-test.trace.log";
herein

    package packed_theme_imp
    :       Packed_Theme_Imp												# Packed_Theme_Imp		is from   src/lib/x-kit/widget/theme/packed/packed-theme-imp.api
    {
	#
	include package   packed_theme;											# packed_theme			is from   src/lib/x-kit/widget/theme/packed/packed-theme.pkg
	#
	Theme_State = Ref( Void );											# Holds all nonephemeral mutable state maintained by skin.

	Imports = {													# Ports we use, provided by other imps.
		    int_sink:			Int -> Void,
		    guiboss_to_windowsystem:	g2a::Guiboss_To_Windowsystem
		  };

	Me_Slot = Mailslot( { imports:	Imports,
			      me:	Theme_State,
			      run_gun':	Run_Gun,
			      end_gun':	End_Gun
			    }
			  );
	Exports	= {													# Ports we provide for use by other imps.
		    theme:		Packed_Theme
		  };


	Option = MICROTHREAD_NAME String;										# 

	Packed_Theme_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);

	Runstate =  {													# These values will be statically globally visible throughout the code body for the imp.
		      me:		Theme_State,									# State which is preserved across imp shutdown/restart cycles.
		      imports:		Imports,									# Imps to which we send requests.
		      to:		Replyqueue,									# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		      end_gun':		End_Gun										# We shut down the microthread when this fires.
		    };

	Theme_Q    = Mailqueue( Runstate -> Void );

	fun run ( theme_q:		Theme_Q,									# 
		  #
		  runstate as
		  {													# These values will be statically globally visible throughout the code body for the imp.
		    me:			Theme_State,									# State which is preserved across imp shutdown/restart cycles.
		    imports:		Imports,									# Imps to which we send requests.
		    to:			Replyqueue,									# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':		End_Gun										# We shut down the microthread when this fires.
		  }
		)
	    =
	    loop ()
	    where
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                        ==>  shut_down_theme_imp'),
			    (take_from_mailqueue' theme_q    ==>  do_theme_plea)
			];

			loop ();
		    }	
		    where
			fun do_theme_plea thunk
			    =
			    thunk runstate;

			fun shut_down_theme_imp' ()
			    =
			    {
				thread_exit { success => TRUE };							# Will not return.	
			    };
		    end;
	    end;	



	fun startup   (reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#

		# Functions like text_color refer to packed_theme
		# but packed_theme also refers to them.  We break
		# the cycle via a four-step dance:
		#
		#   1)  Define dummy fns.
		#   2)  Define packed_theme in terms of them.
		#   3)  Define real fns in terms of packed_theme.
		#   4)  Plug the real fns into packed_theme, replacing the dummy fns.
		#
		# Here are the dummies:
		#
		text_color		= REF (\\ _ = c64::white);
		normal_body_color	= REF (\\ _ = c64::white);
		mouse_focus_body_color	= REF (\\ _ = c64::white);
		sunny_bevel_color	= REF (\\ _ = c64::white);
		shady_bevel_color	= REF (\\ _ = c64::white);
		current_gadget_colors	= REF (\\ _ = { surround_color		=> c64::white,
							body_color		=> c64::white,
							text_color		=> c64::white,
							upperleft_bevel_color	=> c64::white,
							lowerright_bevel_color	=> c64::white
						      }
					      );
		frame3d			= REF (\\ _ = \\ _ = []: gd::Gui_Displaylist);
		filled_frame3d		= REF (\\ _ = \\ _ = []: gd::Gui_Displaylist);
		cartouche3d		= REF (\\ _ = \\ _ = []: gd::Gui_Displaylist);
		polygon3d		= REF (\\ _ = \\ _ = []: gd::Gui_Displaylist);


#		dummy_make_button_displaylist:	Ref ((g2g::Gadget_Mode, Bool) -> Displaylist)	# Bool is on/off state of button,  shown by interchanging roles of light_edge_color and dark_edge_color.


		# A few packed_theme fns don't refer to packed_theme,
		# so we can define the real versions of them before
		# defining packed_theme:

		fun slight_darkening ({ red, green, blue }: c64::Rgb) =
		  { red	  =>  red   * 0.9,
		    green =>  green * 0.9,
		    blue  =>  blue  * 0.9
		  };

		fun medium_darkening ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  red   * 0.5,
		    green =>  green * 0.5,
		    blue  =>  blue  * 0.5
		  };

		fun lavish_darkening ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  red   * 0.3,
		    green =>  green * 0.3,
		    blue  =>  blue  * 0.3
		  };



		fun slight_graying ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  red    -  (red   - 0.5) * 0.3,
		    green =>  green  -  (green - 0.5) * 0.3,
		    blue  =>  blue   -  (blue  - 0.5) * 0.3
		  };

		fun medium_graying ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  red    -  (red   - 0.5) * 0.5,
		    green =>  green  -  (green - 0.5) * 0.5,
		    blue  =>  blue   -  (blue  - 0.5) * 0.5
		  };

		fun lavish_graying ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  red    -  (red   - 0.5) * 0.9,
		    green =>  green  -  (green - 0.5) * 0.9,
		    blue  =>  blue   -  (blue  - 0.5) * 0.9
		  };



		fun slight_lightening ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  1.0 - ((1.0 -   red) * 0.9),
		    green =>  1.0 - ((1.0 - green) * 0.9),
		    blue  =>  1.0 - ((1.0 -  blue) * 0.9)
		  };

		fun medium_lightening ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  1.0 - ((1.0 -   red) * 0.5),
		    green =>  1.0 - ((1.0 - green) * 0.5),
		    blue  =>  1.0 - ((1.0 -  blue) * 0.5)
		  };

		fun lavish_lightening ({ red, green, blue }: c64::Rgb)
		  =
		  { red	  =>  1.0 - ((1.0 -   red) * 0.3),
		    green =>  1.0 - ((1.0 - green) * 0.3),
		    blue  =>  1.0 - ((1.0 -  blue) * 0.3)
		  };


		theme =	  {								# We'll rename this to packed_theme later, for now a shorter name is nice.
			    do_something,
#			    packedspace,
			    #
			    surround_color  =>    REF { red	=> 0.2,			# Nice light gray background for GUI.
							green	=> 0.2,
							blue	=> 0.2
						      },
			    #
			    slight_darkening  =>  REF slight_darkening,			# Real fn.
			    medium_darkening  =>  REF medium_darkening,			# Real fn.
			    lavish_darkening  =>  REF lavish_darkening,			# Real fn.
			    #
			    slight_graying    =>  REF slight_graying,			# Real fn.
			    medium_graying    =>  REF medium_graying,			# Real fn.
			    lavish_graying    =>  REF lavish_graying,			# Real fn.
			    #
			    slight_lightening =>  REF slight_lightening,		# Real fn.
			    medium_lightening =>  REF medium_lightening,		# Real fn.
			    lavish_lightening =>  REF lavish_lightening,		# Real fn.
			    #
			    text_color,							# Dummy fn.
			    normal_body_color,						# Dummy fn.
			    mouse_focus_body_color,					# Dummy fn.
			    sunny_bevel_color,						# Dummy fn.
			    shady_bevel_color,						# Dummy fn.
			    frame3d,							# Dummy fn.
			    filled_frame3d,						# Dummy fn.
			    cartouche3d,						# Dummy fn.
			    polygon3d,							# Dummy fn.

			    current_gadget_colors

#			    dummy_make_button_displaylist
			  };



		# Time to define the real versions of the above dummy fns:

		fun text_color ()
		    =
		    {   (*theme.surround_color)
			    ->
			    { red, green, blue };

			text_color
			    =
			    if  ( ( abs (red   - 0.5)
				  + abs (green - 0.5)
				  + abs (blue  - 0.5)
				  )
				  >
				  0.3
				)

				{ red	=>  1.0 -   red,			# Normal case: Complement the color, which will turn white to black etc for good reading contrast.
				  green	=>  1.0 - green,
				  blue	=>  1.0 -  blue
				};
			    else
				{ red	=>  0.0,				# User's color is nearly neutral gray (meaning that complementing it will yield near-zero contrast) so go for black text instead.
				  green	=>  0.0,
				  blue	=>  0.0
				};
			    fi;				

			text_color;
		    };

		fun normal_body_color ()	=			     *theme.surround_color;
		fun mouse_focus_body_color ()   = *theme.slight_lightening   *theme.surround_color;
		fun sunny_bevel_color ()	= *theme.slight_darkening    *theme.surround_color;
		fun shady_bevel_color ()	= *theme.lavish_darkening    *theme.surround_color;
		#
		fun current_gadget_colors													# Compute appropriate gadget colors based on mode and on/off status. This avoids duplicating this logic in every button etc
		      {																# and provides a central place for customizing these decisions.
			gadget_is_on:	  Bool,
			#
			gadget => gadget as
				          {
					    is_active:				Bool,								# An inactive gadget is passed no user input. Inactive widgets are typically drawn "grayed-out".
					    has_mouse_focus:			Bool,								# A widget which has the mouse cursor on it may want to draw itself brigher or such.
					    has_keyboard_focus:			Bool,								# A widget which has the keyboard focus will often      draw a black outline around its text-entry rectangle.
					    mousebutton_is_down:		Bool								# I'm not sure if this belongs here. Not currently used.
					  } :					g2g::Gadget_Mode
		      }
		    =
		    {
			# Get our base colors from the theme:
			#
			surround_color		= *theme.surround_color;
			text_color		= *theme.text_color ();
			normal_body_color	= *theme.normal_body_color ();
			mouse_focus_body_color	= *theme.mouse_focus_body_color ();
			sunny_bevel_color	= *theme.sunny_bevel_color ();
			shady_bevel_color	= *theme.shady_bevel_color ();

			text_color =	if gadget.is_active					text_color;
					else				*theme.medium_graying	text_color;					# Gray out inactive widget.
					fi;

			body_color =	if gadget.has_mouse_focus				mouse_focus_body_color;
					else							normal_body_color;				# Gray out inactive widget.
					fi;

			my  ( upperleft_bevel_color,
			      lowerright_bevel_color
			    )
			    =
			    if gadget_is_on	(shady_bevel_color, sunny_bevel_color);								# Make button look pressed.
			    else		(sunny_bevel_color, shady_bevel_color);								# Make button look popped.
			    fi;


			{ surround_color,
			  body_color,
			  text_color,
			  #
			  upperleft_bevel_color,
			  lowerright_bevel_color
			} :				Gadget_Palette;
		    };

		stipulate
#		    fun draw3drect ({ col, row, wide, high }: xg::Box, thick)				# Used by draw_box for FLAT, RAISED and SUNKEN.
#			=
#			{   points
#				=
#				[ { col,			row => row+high },
#				  { col,			row },
#				  { col => col+wide,	row },
#				  { col => col+wide-thick,	row => row+thick },
#				  { col => col+thick,	row => row+thick },
#				  { col => col+thick,	row => row+high-thick },
#				  { col,			row => row+high }
#				]; 
#
#			    box1 =  { col,                 row=>row+high-thick, wide,        high=>thick };
#			    box2 =  { col=>col+wide-thick, row,                 wide=>thick, high };
#
#			    thick2 = thick*2;
#
#			    if (wide < thick2 or high < thick2)
#				#
#				\\ _ = [];
#			    else
#				\\ { top, bottom }
#				    =
#				    [
#					gd::COLOR bottom [ gd::POLY_BOX [ box1 ] ],
#					gd::COLOR top    [ gd::POLY_BOX [ box2 ],
#							   gd::FILLED_POLYGON  points
#							 ]
#				    ];
#			    fi;
#			};
#
#		    fun draw3drect2 (box as ({ col, row, wide, high }: xg::Box ), width)				# Used by draw_box for GROOVE and RIDGE.
#			=
#			{   half_width = width / 2;
#			    half_width' = width - half_width;
#			    outer = draw3drect drawable (box, half_width');
#
#			    r' =   { col  => col+half_width',
#				     row  => row+half_width',
#				     #
#				     wide => wide - 2*half_width',
#				     high => high - 2*half_width'
#				   };
#
#			    inner = draw3drect drawable (r', half_width);
#
#			    \\ pens =   { outer pens; inner { top=> pens.bottom, bottom=> pens.top }; };
#			};
#
#		    fun draw_box { box: xg::Box, width, relief }
#			=
#			case relief
#			    #
#			    FLAT   =>
#				{   f = draw3drect (box, width);
#				    #
#				    \\ ( { base, ... }: wb::Shades)
#					=
#					f { top=>base, bottom=>base };
#				};
#
#			    RAISED
#				=>
#				{   f = draw3drect (box, width);
#				    #
#				    \\ { light, dark, ... }
#					=
#					f { top=>light, bottom=>dark };
#				};
#
#			    SUNKEN
#				=>
#				{   f = draw3drect (box, width);
#				    #
#				    \\ { light, dark, ... }
#					=
#					f { top=>dark, bottom=>light };
#				};
#
#			    RIDGE
#				=>
#				{   f = draw3drect2 (box, width);
#				    #
#				    \\ { light, dark, ... }
#					=
#					f { top=>light, bottom=>dark };
#				};
#
#			    GROOVE
#				=>
#				{   f = draw3drect2 (box, width);
#				    #
#				    \\ { light, dark, ... }
#					=
#					f { top=>dark, bottom=>light };
#				};
#			esac;
#
#		    fun draw_filled_box { box, relief=>FLAT, width } shades				# Same as draw_box except we fill the interior of the box in shades.base.
#			    =>
#			    xc::fill_box dr shades.base box; 
#
#			draw_filled_box { box, width=>0, relief => _ } shades
#			    =>
#			    xc::fill_box dr shades.base box; 
#
#			draw_filled_box (a as { box=>{ col, row, wide, high }, width, ... } ) shades
#			    =>
#			    {   delta = width + width;
#				box' = { col=>col+width, row=>row+width, wide=>wide - delta, high=>high - delta };		# box' is nested 'width' inside box 'a'.
#
#				xc::fill_box dr shades.base box';
#				draw_box dr a shades;
#			    };
#		    end;
#
#		    fun draw3dround_box { box, width, corner_wide, corner_high }				# Used by draw_round_box for FLAT, RAISED and SUNKEN.
#			=
#			{   box ->   { col, row, wide, high };
#			    #
#			    halfwidth = width / 2;
#
#			    col = col + halfwidth;
#			    row = row + halfwidth;
#
#			    w = wide - 2*halfwidth;
#			    h = high - 2*halfwidth;
#
#			    w2 = 2 * corner_wide;
#			    h2 = 2 * corner_high;
#
#			    my (ew, ew2) =   if  (w2 > w)  (0, 0);  else  (corner_wide, w2);  fi;
#			    my (eh, eh2) =   if  (h2 > h)  (0, 0);  else  (corner_high, h2);  fi;
#
#			    \\ { top, bottom }
#				=
#				{   top    =  xc::clone_pen (top,   [xc::p::LINE_WIDTH width]);
#				    bottom =  xc::clone_pen (bottom,[xc::p::LINE_WIDTH width]);
#
#				    xc::draw_arcs  drawable  top
#				      [
#					{ col=> col,         row=> row,         wide=> ew2,     high=> eh2,     angle1=> 180*64, angle2=> -90*64 },
#					{ col=> col+ew,      row=> row,         wide=> w - ew2, high=> 0,       angle1=> 180*64, angle2=> -180*64 },
#					{ col=> col,         row=> row+eh,      wide=> 0,       high=> h - eh2, angle1=> 270*64, angle2=> -180*64 },
#					{ col=> col+w - ew2, row=> row,         wide=> ew2,     high=> eh2,     angle1=> 45*64,  angle2=> 45*64 },
#					{ col=> col,         row=> row+h - eh2, wide=> ew2,     high=> eh2,     angle1=> 225*64, angle2=> -45*64 }
#				      ];
#
#				    xc::draw_arcs  drawable  bottom
#				      [
#					{ col=> col+w - ew2, row=> row,         wide=> ew2,     high=> eh2,     angle1=> 45*64,  angle2=> -45*64 },
#					{ col=> col+w,       row=> row+eh,      wide=> 0,       high=> h - eh2, angle1=> 90*64,  angle2=> -180*64 },
#					{ col=> col+w - ew2, row=> row+h - eh2, wide=> ew2,     high=> eh2,     angle1=> 0,      angle2=> -90*64 },
#					{ col=> col+ew,      row=> row+h,       wide=> w - ew2, high=> 0,       angle1=> 0,      angle2=> -180*64 },
#					{ col=> col,         row=> row+h - eh2, wide=> ew2,     high=> eh2,     angle1=> 270*64, angle2=> -45*64 }
#				      ];
#				};
#			};
#
#
#		    fun draw3dround_box2 { box as { col, row, wide, high }, width, corner_wide, corner_high }			# Used by draw_round_box for GROOVE and RIDGE.
#			=
#			{   half_width  =  width / 2;
#			    half_width' =  width - half_width;
#
#			    outer = draw3dround_box drawable 
#					  { box, width=>half_width', corner_wide, corner_high };
#
#			    r' =   { col  => col+half_width',
#				     row  => row+half_width',
#				     wide => wide - 2*half_width',
#				     high => high - 2*half_width'
#				   };
#
#			    inner = draw3dround_box drawable
#					  { box=>r', width=>half_width, corner_wide, corner_high };
#
#			    \\ pens =   { outer pens; inner { top=> pens.bottom, bottom=> pens.top }; };
#			};
#
#
#		    fun draw_round_box { box, width, corner_wide, corner_high, relief }
#			=
#			case relief
#			    #
#			    FLAT   => {   f = draw3dround_box { box, width, corner_wide, corner_high };
#
#					  \\ ( { base, ... }: wb::Shades)
#					      =
#					      f { top=>base, bottom=>base };
#				      };
#
#			    RAISED => {   f = draw3dround_box { box, width, corner_wide, corner_high };
#
#					  \\ { light, dark, ... }
#					      =
#					      f { top=>light, bottom=>dark };
#				      };
#
#			    SUNKEN => {   f = draw3dround_box { box, width, corner_wide, corner_high };
#
#					  \\ { light, dark, ... }
#					      =
#					      f { top=>dark, bottom=>light };
#				      };
#
#			    RIDGE  => {   f = draw3dround_box2 { box, width, corner_wide, corner_high };
#
#					  \\ { light, dark, ... }
#					      =
#					      f { top=>light, bottom=>dark };
#				      };
#
#			    GROOVE => {   f = draw3dround_box2 { box, width, corner_wide, corner_high };
#
#					  \\ { light, dark, ... }
#					      =
#					      f { top=>dark, bottom=>light };
#				      };
#			esac;
#
#
#
#
#		    # The table below is used for a quick approximation in
#		    # computing a new point parallel to a given line
#		    # An index into the table is 128 times the slope of the
#		    # original line (the slope must always be between 0.0
#		    # and 1.0).  The value of the table entry is 128 times
#		    # the  amount to displace the new line in row for each unit
#		    # of perpendicular distance. In other words, the table 
#		    # maps from the tangent of an angle to the inverse of 
#		    # its cosine.  If the slope of the original line is greater 
#		    # than 1, then the displacement is done in col rather than in row.
#		    #
#		    shift_table
#			=
#			{   fun compute i
#				=
#				{   tangent = (real i) / 128.0;
#				    #
#				    f8b::truncate ((128.0 / math::cos (math::atan tangent)) + 0.5);
#				};
#
#			     v = vector::from_fn (129, compute);
#
#			     \\ i = vector::get (v, i);
#			};
#
#		    # Given two points on a line, compute a point on a
#		    # new line that is parallel to the given line and
#		    # a given distance away from it.
#		    #
#		    fun shift_line (p1 as { col, row }, p2, distance)
#			=
#			{   fun (<<) (w, i) =  unt::to_int (unt::(<<) (unt::from_int w, i));
#			    fun (>>) (w, i) =  unt::to_int (unt::(>>) (unt::from_int w, i));
#
#			    infix my << >>;
#
#			    (xg::point::subtract (p2, p1))
#				->
#				{ col=>dx, row=>dy };
#
#			    my (dy, dy_neg) =  if (dy < 0)  (-dy, TRUE);  else (dy, FALSE);  fi;
#			    my (dx, dx_neg) =  if (dx < 0)  (-dx, TRUE);  else (dx, FALSE);  fi;
#
#			    fun adjust (dy, dx)
#				= 
#				((distance * shift_table((dy << 0u7) / dx)) + 64) >> 0u7;
#
#			    if (dy <= dx )
#			       #	
#			       dy = adjust (dy, dx);
#			       { col, row=> row + (if dx_neg  dy; else -dy;fi) };
#			    else
#			       dx = adjust (dx, dy);
#			       { col=> col + (if dy_neg  -dx; else dx;fi), row }; 
#			    fi;
#			};
#
#		    # Find the intersection of two lines
#		    # with the given endpoints.
#		    # Return NULL if lines are parallel
#		    #
#		    fun intersect
#			( a1 as ({ col=>a1x, row=>a1y } ), a2,
#			  b1 as ({ col=>b1x, row=>b1y } ), b2
#			)
#			=
#			{   my { col=>ax, row=>ay } = xg::point::subtract (a2, a1);
#			    my { col=>bx, row=>by } = xg::point::subtract (b2, b1);
#
#			    axby = ax * by;
#			    bxay = bx * ay;
#			    axbx = ax * bx;
#			    ayby = ay * by;
#
#			    fun solve (p, q)
#				=
#				{   my (p, q)
#					=
#					if   (q < 0   )   (-p,-q);
#						     else   ( p, q);   fi;
#
#				    if   (p < 0)
#
#					 -(((-p) + q / 2) / q);
#				    else
#					     (p + (q / 2)) / q;
#				    fi;
#				};
#
#			    if (axby == bxay)
#
#				 NULL;
#			    else 
#				 col = solve (a1x*bxay - b1x*axby + (b1y - a1y)*axbx, bxay - axby);
#				 row = solve (a1y*axby - b1y*bxay + (b1x - a1x)*ayby, axby - bxay);
#
#				 (THE ({ col, row } ));
#			    fi;
#			};
#
#
#		    fun make_perp
#			( { col, row },
#			  { col=>col', row=>row' }
#			)
#			=
#			{ col=>col+(row'-row), row=>row-(col'-col) };
#
#
#		    fun last2pts []       =>   raise exception lib_base::IMPOSSIBLE "three_d::last2Pts";
#			last2pts [v1, v2] =>   (v1, v2);
#			last2pts (v ! vs) =>   last2pts vs;
#		    end;
#
#		    /*
#		     * draw3DPoly draws a polygon of given width. The widening occurs
#		     * on the left of the polygon as it is traversed. If the width
#		     * is negative, the widening occurs on the right. Duplicate points
#		     * are ignored. If there are less than two distinct points, nothing
#		     * is drawn.
#		     * 
#		     * The main loop below (loop2) is executed once for each vertex in 
#		     * the polgon.  At the beginning of each iteration things get like this:
#		     *
#		     *          poly1       /
#		     *             *       /
#		     *             |      /
#		     *             b1   * poly0
#		     *             |    |
#		     *             |    |
#		     *             |    |
#		     *             |    |
#		     *             |    |
#		     *             |    | p1                 p2
#		     *             b2   *--------------------*
#		     *             |
#		     *             |
#		     *             *----*--------------------*
#		     *          poly2   newb1               newb2
#		     *
#		     * For each interation, we:
#		     * (a) Compute poly2 (the border corner corresponding to p1)
#		     *     As part of this process, compute a new b1 and b2 value 
#		     *     for the next side (p1-p2) of the polygon.
#		     * (b) Draw the polygon (poly0, poly1, poly2, p1)
#		     *
#		     * The above situation doesn't exist until two points have 
#		     * been processed. We start with the last two points in the list
#		     * (in loop0) to get an initial b1 and b2. Then, in loop1, we
#		     * use the first point to get a new b1 and b2, with which we
#		     * can calculate an initial poly1 (poly0 is the last point in
#		     * the list). At this point, we can start the main loop.
#		     *
#		     * If two consecutive segments of the polygon are parallel,
#		     * then things get more complex. (See findIntersect).
#		     * Consider the following diagram:
#		     *
#		     * poly1
#		     *    *----b1-----------b2------a
#		     *                                \
#		     *                                  \
#		     *         *---------*----------*    b
#		     *        poly0     p2         p1   /
#		     *                                /
#		     *              --*--------*----c
#		     *              newB1    newB2
#		     *
#		     * Instead of using the intersection and p1 as the last two points 
#		     * in the polygon and as poly1 and poly0 in the next iteration, we 
#		     * use a and b, and b and c, respectively.
#		     *
#		     * Do the computation in three stages:
#		     * 1. Compute a point "perp" such that the line p1-perp
#		     *    is perpendicular to p1-p2.
#		     * 2. Compute the points a and c by intersecting the lines
#		     *    b1-b2 and newb1-newb2 with p1-perp.
#		     * 3. Compute b by shifting p1-perp to the right and
#		     *    intersecting it with p1-p2.
#		     */
#
#		    fun draw3dpoly ([ ], _) _ =>  ();				# Used by draw_poly for FLAT, RAISED and SUNKEN.
#			draw3dpoly _ ([_], _) _ =>  ();
#
#			draw3dpoly (ps as (i_p ! _), width) { top, bottom }
#			    =>
#			    loop0 (p1, p2 ! ps)
#			    where 
#				(last2pts ps) ->  (p1, p2);
#
#				fun calc_off_points (v1, v2)
#				    =
#				    {   b1 = shift_line (v1, v2, width);
#					#	
#					(b1, xg::point::add (b1, xg::point::subtract (v2, v1)));
#				    };
#
#				fun find_intersect (p1, p2, newb1, newb2, b1, b2)
#				    =
#				    case (intersect (newb1, newb2, b1, b2))
#					#
#					THE col => (col, p1, col);
#					#
#					NULL =>
#					    (poly2, poly3, c)
#					    where 
#						perp    =  make_perp (p1, p2);
#						#
#						poly2   =  the (intersect (p1, perp, b1, b2));
#						c	    =  the (intersect (p1, perp, newb1, newb2));
#
#						shift1  =  shift_line (p1, perp, width);
#						shift2  =  xg::point::add (shift1, xg::point::subtract (perp, p1));
#
#						poly3   =  the (intersect (p1, p2, shift1, shift2));
#					    end;
#				    esac;
#
#				fun draw (p0, p1, p2, p3)
#				    =
#				    {   (xg::point::subtract (p3, p0))
#					    ->
#					    { col => dx,							# We color lines (polygons) "bottom" if pointing into the lower-right halfplane from the origin, else "top".
#					      row => dy								#
#					    };									#   "top"   /
#														    #          /
#					pen = if   (dx > 0)   if (dy <= dx) bottom; else top;   fi;			#         O
#					      elif (dy < dx)                bottom; else top;   fi;			#        /  "bottom"
#														    #       /
#					xc::fill_polygon drawable pen
#					  { verts => [p0, p1, p2, p3],
#					    shape => xc::CONVEX_SHAPE
#					  };
#				    };
#
#				fun loop2 (p1,[], b1, b2, poly0, poly1)
#					=> 
#					if (p1 != i_p)
#					    #
#					    (calc_off_points (p1, i_p))                      ->   (newb1, newb2);
#					    (find_intersect (p1, i_p, newb1, newb2, b1, b2)) ->   (poly2, poly3, _);
#
#					    draw (poly0, poly1, poly2, poly3); 
#					fi;
#
#				    loop2 (p1, p2 ! ps, b1, b2, poly0, poly1)
#					=>
#					if (p1 == p2)
#					    #
#					     loop2 (p1, ps, b1, b2, poly0, poly1);
#					else
#					    (calc_off_points (p1, p2))                      ->   (newb1, newb2);
#					    (find_intersect (p1, p2, newb1, newb2, b1, b2)) ->   (poly2, poly3, c);
#
#					     draw (poly0, poly1, poly2, poly3);
#
#					     loop2 (p2, ps, newb1, newb2, poly3, c);
#					fi;
#				end;
#
#				fun loop1 (p1,[], _, _) =>   ();
#				    loop1 (p1, p2 ! ps, b1, b2)
#					=>
#					if (p1 == p2)
#					    #
#					    loop1 (p1, ps, b1, b2);
#					else
#					    (calc_off_points (p1, p2))                      ->   (newb1, newb2);
#					    (find_intersect (p1, p2, newb1, newb2, b1, b2)) ->   (poly2, poly3, c);
#
#					    loop2 (p2, ps, newb1, newb2, poly3, c);
#					fi;
#				end;
#
#				fun loop0 (_,[]) =>   ();
#				    loop0 (p1, p2 ! ps)
#					=>
#					if (p1 == p2)
#					    #
#					    loop0 (p2, ps);
#					else
#					    (calc_off_points (p1, p2)) ->   (b1, b2);
#
#					    loop1 (p2, ps, b1, b2);
#					fi;
#				end;
#			    end;
#		    end;
#
#
#		    fun draw3dpoly2 (pts, width)				# Used by draw_poly for GROOVE and RIDGE.
#			=
#			{   half_width = width / 2;
#			    #
#			    outer =  draw3dpoly drawable (pts, half_width);
#			    inner =  draw3dpoly drawable (pts,-half_width);
#
#			    \\ pens
#				=
#				{   outer pens;
#				    inner { top=> pens.bottom, bottom=> pens.top };
#				};
#			};
#
#
#		    fun draw_poly { pts, width, relief }
#			=
#			case relief
#			    #
#			    FLAT   => {   f = draw3dpoly drawable (pts, width);
#
#					  \\ ( { base, ... }: wb::Shades)
#					      =
#					      f { top=>base, bottom=>base };
#				      };
#
#			    RAISED => {   f = draw3dpoly drawable (pts, width);
#
#					  \\ { light, dark, ... }
#					      =
#					      f { top=>light, bottom=>dark };
#				      };
#
#			    SUNKEN => {   f = draw3dpoly drawable (pts, width);
#
#					  \\ { light, dark, ... }
#					      =
#					      f { top=>dark, bottom=>light };
#				      };
#
#			    RIDGE  => {   f = draw3dpoly2 drawable (pts, width);
#
#					  \\ { light, dark, ... }
#					      =
#					      f { top=>light, bottom=>dark };
#				      };
#
#			    GROOVE => {   f = draw3dpoly2 drawable (pts, width);
#
#					  \\ { light, dark, ... }
#					      =
#					      f { top=>dark, bottom=>light };
#				      };
#			esac;

		herein
		    fun frame3d
			  (palette:		Gadget_Palette)
			  (frame:		Frame3d)
			=	
			[]: gd::Gui_Displaylist;

		    fun filled_frame3d
			  (palette:		Gadget_Palette)
			  (frame:		Frame3d)
			=	
			[]: gd::Gui_Displaylist;

		    fun cartouche3d
			  (palette:		Gadget_Palette)
			  (cartouche:	Cartouche3d)
			=	
			[]: gd::Gui_Displaylist;

		    fun polygon3d
			  (palette:		Gadget_Palette)
			  (polygon:		Polygon3d)
			=	
			[]: gd::Gui_Displaylist;
		end;


		# Finally we replace the dummy theme fns with the real ones:
		#
		theme.text_color		:=  text_color;
		theme.normal_body_color		:=  normal_body_color;
		theme.mouse_focus_body_color	:=  mouse_focus_body_color;
		theme.sunny_bevel_color		:=  sunny_bevel_color;
		theme.shady_bevel_color		:=  shady_bevel_color;
		theme.current_gadget_colors	:=  current_gadget_colors;
		theme.frame3d			:=         frame3d;
		theme.filled_frame3d		:=  filled_frame3d;
		theme.cartouche3d		:=     cartouche3d;
		theme.polygon3d			:=       polygon3d;


		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, { theme }));							# Return value from packed_theme_egg'().

		(take_from_mailslot  me_slot)										# Input args from packed_theme_egg'().
		    ->
		    { me, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		run (theme_q, { me, imports, to, end_gun' });								# Will not return.
	    }
	    where
		theme_q     =  make_mailqueue (get_current_microthread()):  Theme_Q;

		fun do_something (i: Int)										# PUBLIC.
		    =	
		    put_in_mailqueue  (theme_q,
			#
			\\ ({ me, imports, ... }: Runstate)
			    =
			    imports.int_sink i										# Demonstrate use of imports.
		    );


#		fun packedspace  (options: ps::Packedspace_Arg)								# PUBLIC.
#		    =
#		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( psi::Packedspace_Egg );
#			#
#			put_in_mailqueue  (theme_q,
#			    #
#			    \\ ({ me, ... })
#				=
#				{   (psi::make_packedspace_egg	options NULL) -> packedspace_egg;
#				    #
#				    put_in_oneshot (reply_oneshot, packedspace_egg);
#				}
#			);
#
#			get_from_oneshot reply_oneshot;
#		    };

	    end;


	fun process_options (options: List(Option), { name })
	    =
	    {   my_name   = REF name;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME n)  =   my_name := n;
		end;

		{ name => *my_name };
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_packed_theme_egg (options: List(Option))								# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	    =
	    {   (process_options (options, { name => "tmp" }))
		    ->
		    { name };
	
		me = REF ();

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );		# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  reply_oneshot);					# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3											# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, imports, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
