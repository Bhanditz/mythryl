# The following is from p45-50 of 
# REVITALIZING EXENE by Matthew Hoag
# http://mythryl.org/pub/exene/matt-thesis.pdf
#
(* selectable-list.sml
The Selectable list Widget is a slight modification of the button bar
that uses the button abstraction to simulate the selection of one or
more items (or buttons) from a list of buttons
*)

signature SELECTABLE_LIST =
sig
structure W: WIDGET
type selectable_list
(* creates a selectable_list widget with items labeled by the supplied strings;
   a boolean value is also required to identify whether or not the selectable
   list will operate in "single select" mode; if the mode is set to true, then
   then only one item from the list can be selected at a time; any type of
   interaction with the list will result in one and only one selection;
   otherwise if the mode is set to false, the items in the list may be
   selected by there different methods:
   SINGLE_CLICK: An item will be selected and all of the previously
                selected items will become unselected;
   SINGLE_CLICK WITH SHIFT: A range of items will be selected starting from
                the last click to the present click ADDING to the current selection;
    SINGLE_CLICK WITH CNTRL: A item will be toggled from the currently selected list; that
                is, if an item is currently selected it will become unselected
               and if it is unselected int will become selected;
               the widget may be customized using the following resource attributes:

    Name Type Default Semantics
    --------------------------------------------------------------------------
    background color white background color of widget’s window
    foreground color black foreground color of widget’s window
    selectBackground color grey selected background color of widget’s window
    selectForeground color white selected foreground color of widget’s window
    font font 9x15 font of widget’s window
    borderWidth int NoValue borderWidth surrounding text
    hpad int 5 horizonal justification for text (includes borderWidth)
    vpad int 0 (pixels) inter-button padding *)

45val selectableList : (W.root * W.view * W.arg list) -> (string list * bool) -> selectable_list
(* returns the widget of a selectable list *)

val widgetOf : selectable_list -> W.widget
val selEvtOf : selectable_list -> (int * string) list CML.event

(* getSelectedList returns a tuple list of the strings and their corresponding index which
   are currently selected by the widget; the index is constructed based on the initial
   order of the supplied string list
 *)
val getSelectedList : unit -> (int * string) list
end

structure SelectableList =
struct
open CML
(* This is a unique Toggle Button that is not constructed in the Toggle structure it uses
a view that was previously unavailable *)

structure SpecialTextToggle = ToggleCtrl (ListView)
(* Structures used more than once requiring a short hand *)
structure A = Attrs
structure TT = ToggleType
structure Q = Quark
structure SV = SyncVar
structure W = Widget
structure I = Interact
val attr_hpad = Q.quark "hpad"
val attr_vpad = Q.quark "vpad"
(*attributes used specifically for this widget*)

val nativeAttrs =
[([], attr_vpad, A.AT_Int, A.AV_Int 0)]
(*attributes used for each individual list item*)

val passedAttrs =
[([], A.attr_background, A.AT_Color, A.AV_Str "white"),
([], A.attr_foreground, A.AT_Color, A.AV_Str "black"),
([], A.attr_font, A.AT_Font, A.AV_Str "9x15"),
([], attr_hpad, A.AT_Int, A.AV_Int 5),
([], A.attr_halign, A.AT_HAlign,A.AV_HAlign W.HLeft),
([], A.attr_selectBackground, A.AT_Color, A.AV_Str "grey"),
([], A.attr_selectForeground, A.AT_Color, A.AV_Str "blue")
]
(*the type of actions that will modify the selected list*)

datatype clickType = SingleSelect | SingleToggle | AddMulti
(*identity for the type and operation of a selectable list *)

type selectable_list =
{widget : W.widget,
selEvt : (int * string) list event,
getSelected : unit -> (int*string) list}

(*varialbe constructor for a selectable list *)
fun selectableList (root, view as (name, style), args) (names, mode) =
let

(*modified view such that new W.findAttr will works properly *)
val conView = (Styles.extendView (name, "selectable-list"),style)
46val attrs = W.findAttr(W.attrs(conView, passedAttrs, []))
val bg = A.getColor(attrs A.attr_background)
val fg = A.getColor(attrs A.attr_foreground)
val font = A.getFont(attrs A.attr_font)
val hpad = A.getInt(attrs attr_hpad)
val sel_bg = A.getColor(attrs A.attr_selectBackground)
val sel_fg = A.getColor(attrs A.attr_selectForeground)
val halign = A.getHAlign(attrs A.attr_halign)
val nativeAttrs = W.findAttr(W.attrs(conView, nativeAttrs, []))
val vpad = A.getInt(nativeAttrs attr_vpad)
val padGlue = Box.Glue{nat = vpad, min = vpad, max = SOME vpad}

(*findClickType unrolls the ToggleType.Toggle datatype and classifies it as a clickType *)

fun findClickType (TT.Toggle(_,SOME(TT.BtnUp (mbut, modkeys)))) : clickType option =
if mode
then SOME SingleSelect
else
if I.shiftIsSet modkeys
then SOME AddMulti
else
if I.cntrlIsSet modkeys
then SOME SingleToggle
else SOME SingleSelect
| findClickType _ = NONE

(*isToggle unrolls the ToggleType.Toggle datatype and determines if there is a BtnUp msg*)

fun isToggle (TT.Toggle (_,SOME(TT.BtnUp _))) = true
| isToggle _ = false

(*item_data is the internal representation for each of the labeled toggle buttons
each item has a label containing its name, a item which is the event itself and
a upEvt which recieves the button click information*)

type item_data =
{ lab : string,
item : TT.toggle,
upEvt : TT.toggle_act event}
(*makeItem given a string constructs an instance of an item_data*)

val makeItem : string -> item_data =
fn lab =>
let val itemArgs =
[([], A.attr_label, A.AV_Str lab),
([], A.attr_background, A.AV_Color bg),
([], A.attr_foreground, A.AV_Color fg),
([], A.attr_selectBackground, A.AV_Color sel_bg),
([], A.attr_selectForeground, A.AV_Color sel_fg),
([], A.attr_font, A.AV_Font font),
([], A.attr_halign, A.AV_HAlign halign),
([], attr_hpad, A.AV_Int hpad)
]

val item = SpecialTextToggle.toggle (root, view, itemArgs)
(* the flushEvt is currently not used by this widget *)

val (valEvt, flushEvt) = FilterEvt.filterEvt isToggle (TT.evtOf item)
val itemData = {lab = lab,
item = item,
upEvt = valEvt}
in itemData
end
(*itemsToBoxes : item_data list -> Box.WBox list
takes in a list of items and constructs a vertical list of widgets*)
fun itemsToBoxes nil = nil
47| itemsToBoxes [b] =
[Box.WBox(TT.widgetOf b)]
| itemsToBoxes (b :: bs) =
Box.WBox(TT.widgetOf b) :: padGlue :: itemsToBoxes bs
val itemDatas = map makeItem names
val items = map #item itemDatas
val box = Box.VtLeft(itemsToBoxes items)
val layout = Box.layout(root, view, args) box
val widget = Box.widgetOf layout
val selCh : (int * string) list chan = channel()
(* the rqstChan is used to to make requests to the server thread *)
val rqstChan: ((int list) SV.ivar)chan = channel()
(* indexedData constructs (int * item_data) list effectively indexing the already
constructed itemDatas *)
val indexedDatas = let
fun makeIndex (num, []) = []
| makeIndex (num, item::tl) = [num] @ makeIndex (num+1, tl)
in ListPair.zip(makeIndex (0,itemDatas), itemDatas)
end
(* doSingleToggle: (selList: int list * index: int) -> int list
doSingleToggle adds the index to selList if it is not present and removes
it if it is present *)
fun doSingleToggle (selList,index) =
if (List.exists (fn x => x=index) selList)
then (List.filter (fn x => not(x=index)) selList)
else ([index]@selList)
(* doSingleSelect: (index:int)-> int list *)
fun doSingleSelect (index) =
[index]
(* makeMultiList: (last: int option * index : int) -> int list *)
fun makeMultiList (NONE, index) = [index]
| makeMultiList (SOME(last), index) =
let
fun makeIndex top bottom =
if top >= bottom
then (makeIndex (top-1) bottom)@[top]
else []
in
if index >= last
then makeIndex index last
else makeIndex last index
end
(* doAddMulti: (last: int option * selList: int list * index: int) -> int list *)
fun doAddMulti (last, selList, index) =
let
val addList = makeMultiList (last, index)
fun addUniqueItemsToList [] = []
| addUniqueItemsToList(h::tl) =
if (List.exists (fn x => x=h) selList)
then addUniqueItemsToList tl
else [h]@(addUniqueItemsToList tl)
in
selList@(addUniqueItemsToList addList)
end
48(* greaterThan : (int * int) -> bool *)
val greaterThan = fn (x, y) => x > y
(* doAction: (clickType option * int option * int list * int) -> int list *)
fun doAction (NONE,last, selList, index) = selList
| doAction (SOME(SingleToggle), last, selList, index) =
ListMergeSort.sort greaterThan (doSingleToggle (selList, index))
| doAction (SOME(SingleSelect), last, selList,index) = doSingleSelect (index)
| doAction (SOME(AddMulti), last, selList, index ) =
ListMergeSort.sort greaterThan (doAddMulti (last,selList, index))
fun getIndexedItem num =
let
fun grab [] = []
| grab ((index,{lab,...}:item_data)::tl) =
if num = index
then [(num,lab)]
else grab tl
in grab indexedDatas
end
fun getIndexedItems [] = []
| getIndexedItems (hd::tl) = (getIndexedItem hd)@(getIndexedItems tl)
(* unCoverClickAndServ (int option * int list * ( )*)
fun unCoverClickAndServ (last,selList, serv,(index,{upEvt, ...}:item_data)) =
[wrap(upEvt, fn click =>
let
val selList’ = (doAction((findClickType click),
last,
selList,
index
)
)
val evt = sendEvt(selCh, getIndexedItems(selList’))
fun loop () =
select
[wrap(evt, fn () => serv (SOME(index)) selList’)]
in loop ()(*serv (SOME(index)) selList’*)
end
)
]
fun makeSelect (last,selList,serv,[]) = []
| makeSelect (last,selList,serv,indexedData::tl) =
(unCoverClickAndServ (last,selList,serv,indexedData))
@ (makeSelect (last,selList,serv,tl))
fun syncButtonStateWithList selList =
let
fun syncList [] = ()
| syncList ((index,{item,...}:item_data)::tl) =
if (List.exists (fn x => x = index) selList)
then (TT.setState(item,true) ; syncList tl)
else (TT.setState(item,false); syncList tl)
in
syncList indexedDatas
end
fun server last selList = (syncButtonStateWithList selList;
select ([wrap(recvEvt rqstChan, fn iVar => (SV.iPut(iVar, selList);
server last selList ))]@
(makeSelect (last,selList,server,indexedDatas))
)
49)
fun getSelectedList () =
let
val iVar : (int list) SV.ivar = SV.iVar()
in send (rqstChan, iVar); getIndexedItems (SV.iGet iVar)
end
in
spawn(fn () => server NONE []);
{widget = widget,
selEvt = recvEvt selCh,
getSelected = getSelectedList}
end
fun widgetOf({widget,...}:selectable_list) = widget
fun selEvtOf({selEvt,...}:selectable_list) = selEvt
fun getSelectedList({getSelected,...}:selectable_list) = getSelected ()
end;
