# file-chooser.pkg
#
# Matthew Hoag implemented an eXene File Chooser
# widget for his 2007 KSU thesis "Revitalizing eXene"
#     http://mythryl.org/pub/exene/matt-thesis.pdf
# -- see pages 50-61.

(*fchooser.sml*)
signature FILE_CHOOSER =
sig
structure W: WIDGET
type filechooser
(* a filechooser widget allows you to browse through the file system and
perform operations on that file system. It is always in an active mode.
It requires a root, view, and args list as well as a button that will
provide the primary operation for the file chooser and a boolean value
that specifies the selection mode (true - Single Selection
false - Multiple Selection).
The widget may be customized using the following resource attributes:
Name Type Default Semantics
-----------------------------------------------------------------------
background color pink background color of widget’s window
foreground color black foreground color of widget’s window
hdir string OS.FileSys.getDir() Home Directory of the Widget
*)
val fileChooser : (W.root * W.view * W.arg list) -> (Button.button * bool) -> filechooser
(*returns widget of a filechooser*)
val widgetOf : filechooser -> W.widget
(*getCurrentDirectory returns the current Directory of the filechooser*)
val getCurrentDirectory : filechooser -> string
(*getCurrentText returns the current text (the selected files and anything that
the user has typed in*)
val getCurrentText : filechooser -> string
(*getCurrentSelection returns a list of the currently selected files and
with a corresponding directory identifier. i.e. true -> directory
false -> file *)
val getCurrentSelection : filechooser -> (string*bool) list
(*setDirectory is a function that takes in a string and attempts to
sets the filechooser’s current directory to that string*)
val setDirectory : filechooser -> string -> unit
51(*setError is a function that takes in a string and sets the text of the
error label to the string *)
val setError : filechooser -> string -> unit
end
structure FileChooser =
struct
open CML Widget Geometry Interact
structure Q = Quark
structure A = Attrs
structure W = Widget
structure SV = SyncVar
val attr_hDir = Q.quark "hDir"
val homeDir = OS.FileSys.getDir()
val attrs =
[([], A.attr_background, A.AT_Color, A.AV_Str "white"),
([], A.attr_foreground, A.AT_Color, A.AV_Str "black"),
([], attr_hDir, A.AT_Str, A.AV_Str homeDir)]
datatype setRequest = SetDirectory of string
| SetError of string
(*internal state consists of a directory list, a file list, the current
SelectableList and the current navigational directory*)
type state = {dirList : string list,
fileList : string list,
selList : SelectableList.selectable_list,
currentDir : string}
(*the filechooser type consist of a widget, and 5 functions that allow for
informational retrieval and state modification*)
type filechooser = {widget : W.widget,
currentDirectory : unit -> string,
currentText : unit -> string,
currentSelection : unit -> (string*bool) list,
setDirectory : string -> unit,
setError : string -> unit}
fun fileChooser(root, (name, style), args) (actionBttn, selectMode) =
let val view = (Styles.extendView (name, "file-chooser"), style)
val attrs = W.findAttr(W.attrs(view,attrs,[]))
val bg = A.getColor(attrs A.attr_background)
val fg = A.getColor(attrs A.attr_foreground)
val hDir = A.getString(attrs attr_hDir)
val focusMgr = FocusMgr.mkFocusMgr ()
(*Widget Construction*)
val dirPath = TextView.textView (root, view, [([], A.attr_maxLines, A.AV_Int 1),
([], A.attr_rows, A.AV_Int 1)])
("")
val _ = TextView.tvSetShowScrollbars (dirPath) (false)
val dirPathFF = FocusFrame.focusframe (root, view, [])
((TextView.widgetOf dirPath),(TextView.focusableOf dirPath))
(* val _ = FocusMgr.addFocusable focusMgr (FocusFrame.focusableOf dirPathFF)*)
val updArgs =
[([], A.attr_label,A.AV_Str "Update"),
52([], A.attr_borderWidth,A.AV_Int 5)]
val updBttn = Button.textBtn(root,view, updArgs)
val updEvt = Button.evtOf updBttn
val homeArgs =
[([], A.attr_label, A.AV_Str " Home "),
([], A.attr_borderWidth,A.AV_Int 5)]
val homeBttn = Button.textBtn(root, view, homeArgs)
val homeEvt = Button.evtOf homeBttn
val prevArgs =
[([], A.attr_label, A.AV_Str "Parent"),
([], A.attr_borderWidth,A.AV_Int 5)]
val prevBttn = Button.textBtn(root, view, prevArgs)
val prevEvt = Button.evtOf prevBttn
(*The "error label" is actually a button with no border width.
it was implemented as such to circumvent the problems of rigidity
caused by the label widget*)
val errArgs =
[([], A.attr_label, A.AV_Str "Error Message Output"),
([], A.attr_borderWidth,A.AV_Int 0),
([], A.attr_halign, A.AV_HAlign W.HLeft)]
val errorLabel = Button.textBtn(root, view, errArgs)
val listLayout = Box.layout (root, view, [])
(Box.VtLeft[Box.Glue{nat=100,min=100,max=SOME(100)}])
val scrollSelList = ScrollLayout.mkSBLayout root
{ widget = (Box.widgetOf listLayout),
hsb = NONE,
vsb = SOME {sb=(Scrollbar.widgetOf (Scrollbar.mkVScrollbar root {color=NONE, sz=16})), pad=0, left=false}}
val scrollLayout = Box.layout (root, view, [])
(Box.VtLeft[Box.WBox(ScrollLayout.widgetOf scrollSelList)])
val fileList = TextView.textView (root, view, [([], A.attr_maxLines, A.AV_Int 1),
([], A.attr_rows, A.AV_Int 1)])
("")
val _ = TextView.tvSetShowScrollbars (fileList) (false)
val fileListFF = FocusFrame.focusframe (root, view, [])
((TextView.widgetOf fileList),(TextView.focusableOf fileList))
(*val _ = FocusMgr.addFocusable focusMgr (FocusFrame.focusableOf fileListFF)*)
val dividerArgs = [([], A.attr_color, A.AV_Str "black"),
([], A.attr_width, A.AV_Int 3)]
(*horzDivider: unit -> W.widget
used to make all of the horizonal divider in the widget construction*)
fun horzDivider () = Divider.horzDivider(root,view,dividerArgs)
val padGlue = Box.Glue{nat = 10,min = 10, max = SOME(10)}
val topSect = Box.layout (root, view, [])
(Box.HzCenter[Box.WBox(FocusFrame.widgetOf dirPathFF),
padGlue,
Box.WBox(Shape.mkRigid(Button.widgetOf updBttn)),
padGlue,
Box.WBox(Shape.mkRigid(Button.widgetOf homeBttn)),
padGlue,
Box.WBox(Shape.mkRigid(Button.widgetOf prevBttn))])
53val midSect = Box.layout (root, view, [])
(Box.HzCenter[Box.WBox(Box.widgetOf(scrollLayout))])
val btmSect = Box.layout (root, view, [])
(Box.HzCenter[Box.WBox(FocusFrame.widgetOf fileListFF),
padGlue,
Box.WBox(Shape.mkRigid(Button.widgetOf actionBttn))])
val errSect = Box.layout (root, view, [])
(Box.VtLeft[Box.WBox(Button.widgetOf errorLabel)])
val padGlue = Box.Glue{nat = 4,min = 4, max = SOME(4)}
val overall = Box.layout (root, view, [])
(Box.VtLeft [padGlue,
Box.WBox(Box.widgetOf(topSect)),
padGlue,
Box.WBox(horzDivider ()),
padGlue,
Box.WBox(Box.widgetOf(midSect)),
padGlue,
Box.WBox(horzDivider ()),
padGlue,
Box.WBox(Box.widgetOf(btmSect)),
padGlue,
Box.WBox(horzDivider ()),
padGlue,
Box.WBox(Box.widgetOf(errSect))])
val widget = (Box.widgetOf(overall))
(*end widget construction*)
(*racErrorLabel: string -> unit
racErrorLabel stands for remove and create error label
since it is impossible to change the text of a button racErrorLabel
recreates the button with a new message*)
fun racErrorLabel msg =
let val errArgs =
[([], A.attr_label, A.AV_Str msg),
([], A.attr_borderWidth,A.AV_Int 0),
([], A.attr_halign, A.AV_HAlign W.HLeft)]
val errorLabel = Button.textBtn(root, view, errArgs)
in
(Box.delete errSect [0];
Box.insert errSect (0, [Box.WBox(Button.widgetOf errorLabel)]);
Box.mapBox errSect [0])
end
(*racDF: state -> state
racDF stands for remove and create Directorys and Files
racDF takes in the internal state and attempts to open and read
the currentDir. Once that is complete its reconstructs the
selectable list and remounts it on the list layout*)
fun racDF(state:state) =
let
val _ = OS.FileSys.chDir (#currentDir state)
val dirStream = OS.FileSys.openDir(#currentDir state)
val fileAndDirList =
let
fun createList dList fList =
(case OS.FileSys.readDir(dirStream) of
NONE => (dList, fList)
54| SOME file => if (OS.FileSys.isDir(file))
then (createList (dList@[(file)]) fList)
else (createList dList (fList@[(file)])))
in createList [] []
end
(* createSelectableList: (string list * string list) -> state
*)
fun createSelectableList(dList, fList) =
let
val _ = OS.FileSys.closeDir (dirStream)
val selectableList = SelectableList.selectableList (root,view,[])
(dList@fList,selectMode)
(*val scrollSelList = ScrollLayout.mkSBLayout root
{ widget = (SelectableList.widgetOf selectableList),
hsb = NONE,
vsb = SOME {sb=(Scrollbar.widgetOf
(Scrollbar.mkVScrollbar root
{color=NONE,
sz=16}
)),
pad=0,
left=false
}
}*)
(*fun sleep n = CML.sync(CML.timeOutEvt(Time.fromMilliseconds n))*)
in
((if (List.null( (#dirList state)@(#fileList state)))
then ()
else (Box.delete listLayout [0](*; sleep 100*)));
Box.insert listLayout (0, [Box.WBox(SelectableList.widgetOf selectableList)]);
Box.mapBox listLayout [0];
racErrorLabel "Error Message Output";
TextView.setString dirPath (#currentDir state);
TextView.setString fileList "";
{currentDir = #currentDir state,
dirList = dList,
fileList = fList,
selList = selectableList})
end
in
createSelectableList(fileAndDirList)
end
(*channel for getting the selection from the selectable list*)
val getSelChan : ((string*bool) list SV.ivar) chan = channel ();
(*channel for getting the current directory from the state*)
val getDirChan : (string SV.ivar) chan = channel ();
(*channel for getting the current text from the text edit widget*)
val getTexChan : (string SV.ivar) chan = channel ();
(*channel for setting the directory and setting the error message *)
val setReqChan : (setRequest) chan = channel ();
(*loop: state -> unit
main loop*)
fun loop(state:state) =
let
val _ = OS.FileSys.chDir (hDir)
val parentDir = OS.Path.getParent (OS.Path.toUnixPath(#currentDir state))
val updateDir = TextView.getString dirPath
55val selEvt = SelectableList.selEvtOf (#selList state)
(*function used to extract the file/directory names and identify their corresponding types*)
fun extract ((x,m)::tl) = ([(m,OS.FileSys.isDir ((#currentDir state)^"/"^m))] @ (extract tl))
| extract [] = []
(*handle the press of the home button
change the current directory to the home directory*)
fun handleHome (Button.BtnUp _) = let
val state’ = {currentDir = hDir,
dirList = #dirList state,
fileList = #fileList state,
selList = #selList state}
in
loop(racDF(state’))
end
| handleHome _ = loop(state)
(*handle the press of the parent button
attempts to change the directory to the parent directory
failure to do so raises an error message
*)
fun handleParent (Button.BtnUp _) = ((let
val state’ = {currentDir = parentDir,
dirList = #dirList state,
fileList = #fileList state,
selList = #selList state}
in
loop(racDF(state’))
end)
handle OS.SysErr (msg1, msg2) =>
(racErrorLabel msg1;
loop(state)))
| handleParent _ = loop(state)
(*handle the press of the update button
attempts to change the directory to the text in the dirPath
failure to do so raises an error message
*)
fun handleUpdate (Button.BtnUp _) =((let
val state’ = {currentDir = updateDir,
dirList = #dirList state,
fileList = #fileList state,
selList = #selList state}
in
loop(racDF(state’))
end)
handle OS.SysErr (msg1,msg2) =>
(racErrorLabel msg1;
loop (state)))
| handleUpdate _ = loop(state)
(*handle a selection made on the selectable list
*)
fun handleSelect selection =(let (*unpack:(int*string) list -> string
unpack constructs a string of the list of
files selected and set them as the text of
the fileList widget*)
fun unpack [] = ""
| unpack ((_,hd)::[]) = hd
56| unpack ((_,hd)::tl) = hd^", "^(unpack tl)
val sel = unpack selection
in
(TextView.setString fileList sel;
loop(state))
end)
(**)
fun handleChangeDir name =((let
val state’ = {currentDir = name,
dirList = #dirList state,
fileList = #fileList state,
selList = #selList state}
in
loop(racDF(state’))
end)
handle OS.SysErr (msg1,msg2) =>
(racErrorLabel msg1;
loop (state)))
fun handleGetSelection (iVar) = (SV.iPut(iVar, extract (SelectableList.getSelectedList (#selList state)));
loop(state))
fun handleGetDirectory (iVar) = (SV.iPut(iVar,(#currentDir state));
loop(state))
fun handleGetText (iVar) = (SV.iPut(iVar,(TextView.getString fileList));
loop(state))
fun handleSetRequest (req) = (case req of
SetDirectory x =>
((let
val state’ = {currentDir = x,
dirList = #dirList state,
fileList = #fileList state,
selList = #selList state}
in
loop(racDF(state’))
end)
handle OS.SysErr (msg1,msg2) =>
(racErrorLabel msg1;
loop (state)))
| SetError x =>
(racErrorLabel x; loop(state)))
in select
[wrap(homeEvt, handleHome),
wrap(prevEvt, handleParent),
wrap(updEvt, handleUpdate),
wrap(selEvt, handleSelect),
wrap(recvEvt getDirChan, handleGetDirectory),
wrap(recvEvt getTexChan, handleGetText),
wrap(recvEvt getSelChan, handleGetSelection),
wrap(recvEvt setReqChan, handleSetRequest)]
end
fun getCurrentDirectory() =
let val iVar : string SV.ivar = SV.iVar ()
in (send(getDirChan, (iVar));
(SV.iGet iVar))
57end
fun getCurrentText() =
let val iVar : string SV.ivar = SV.iVar ()
in (send(getTexChan, (iVar));
(SV.iGet iVar))
end
fun getCurrentSelection() =
let val iVar : (string * bool) list SV.ivar = SV.iVar ()
in (send(getSelChan, (iVar));
(SV.iGet iVar))
end
fun setDirectory s = send(setReqChan, (SetDirectory(s)))
fun setError s = send(setReqChan, (SetError(s)))
in
spawn(fn () => loop(racDF{currentDir = hDir,
dirList = [],
fileList = [],
selList = SelectableList.selectableList (root,view,[]) ([],false)}));
{widget = widget,
currentDirectory = getCurrentDirectory,
currentText = getCurrentText,
currentSelection = getCurrentSelection,
setDirectory = setDirectory,
setError = setError}
end
fun widgetOf({widget,...} : filechooser) = widget
fun getCurrentDirectory({currentDirectory,...} : filechooser) = currentDirectory ()
fun getCurrentText({currentText,...} : filechooser) = currentText ()
fun getCurrentSelection({currentSelection,...} : filechooser) = currentSelection ()
fun setDirectory({setDirectory,...} : filechooser) = setDirectory
fun setError({setError,...} : filechooser) = setError
end
58Appendix E
File Chooser Demo source code
(*
* Matt Hoag, Kansas State University.
*
* Based on basicwin.sml, (C) 1990 J.H. Reppy; and goodbye.sml, (C) 1990 AT&T.
*)
structure FCDemo : sig
val doit : string option * string list -> OS.Process.status
val main : (string * string list) -> OS.Process.status
end = struct
structure EXB = EXeneBase
structure S = Styles
structure A = Attrs
(* set up the option spec table. *)
val optSpec =
[(S.OPT_NAMED("help"), "-help", S.OPT_NOARG("on"), A.AT_Bool),
(S.OPT_NAMED("help"), "-nohelp", S.OPT_NOARG("off"), A.AT_Bool),
(S.OPT_NAMED("res"), "-res", S.OPT_RESARG, A.AT_Str),
(S.OPT_NAMED("skip"), "-skip", S.OPT_SKIPARG, A.AT_Str),
(S.OPT_NAMED("ign"), "-ignore", S.OPT_SKIPLINE, A.AT_Str),
(S.OPT_RESSPEC("*background"), "-bg", S.OPT_SEPARG, A.AT_Str),
(S.OPT_RESSPEC("*foreground"), "-fg", S.OPT_SEPARG, A.AT_Str),
(S.OPT_RESSPEC("*borderColor"),"-bc", S.OPT_SEPARG, A.AT_Str)]
(* set up application resource defaults. *)
val appResources =
["*background: white",
"*foreground: black"]
fun init (dpyOpt,args) =
let
val root = Widget.mkRoot(GetDpy.getDpy(dpyOpt))
handle EXB.BadAddr s =>
(TextIO.print s; RunCML.shutdown OS.Process.failure)
(* parse the command line arguments using the option spec table. *)
val (optDb,unargs) = Widget.parseCommand (optSpec) args
(* obtain the value of a named argument.
* note that in this case we let the last argument (the head of the returned list)
* override any previous arguments. *)
val help = (case (Widget.findNamedOpt optDb (Styles.OPT_NAMED("help")) root) of
59[] => false (* application must supply default here. *)
| Attrs.AV_Bool(b)::_ => b) (* let the last argument override. *)
(* create a style from the application default resource table. *)
val appStyle = Widget.styleFromStrings(root,appResources)
handle Styles.BadSpec (n,s) =>
(TextIO.print "bad resource specification: ";
TextIO.print(Int.toString n); TextIO.print (":"^s^"\n");
Widget.delRoot root; RunCML.shutdown OS.Process.failure)
(* create a style from the properties stored by xrdb. *)
val xrdStyle = Widget.styleFromXRDB(root)
handle Styles.BadSpec (n,s) =>
(TextIO.print "bad resource specification: ";
TextIO.print(Int.toString n); TextIO.print (":"^s^"\n");
Widget.delRoot root; RunCML.shutdown OS.Process.failure)
(* create a style from the resource options in the option db. *)
val argStyle = Widget.styleFromOptDb(root,optDb)
handle Styles.BadSpec (n,s) =>
(TextIO.print "bad resource specification: ";
TextIO.print(Int.toString n); TextIO.print (":"^s^"\n");
Widget.delRoot root; RunCML.shutdown OS.Process.failure)
(* Merge: xrdb strings with app style, overwriting any conflicting app styles.
* Then merge arg style with the result, giving priority to runtime args. *)
val mainStyle = Widget.mergeStyles(argStyle,Widget.mergeStyles(xrdStyle,appStyle))
val styleView = Styles.mkView{name = Styles.styleName["demores"],aliases = nil}
val view = (styleView, mainStyle)
(* widget setup. *)
fun quit () = (Widget.delRoot root; RunCML.shutdown OS.Process.success)
val quitBttn = Button.textBtn (root, view, [([], Attrs.attr_label, Attrs.AV_Str "Quit"),
([], Attrs.attr_borderWidth, Attrs.AV_Int 5)])
val quitEvt = Button.evtOf quitBttn
val openBttn = Button.textBtn (root, view, [([], Attrs.attr_label, Attrs.AV_Str "Open"),
([], Attrs.attr_borderWidth, Attrs.AV_Int 5)])
val openEvt = Button.evtOf openBttn
val attr_singleSelect = Quark.quark "singleselect"
val fileChooser = FileChooser.fileChooser (root, view, []) (openBttn, false)
val layout =
Box.layout (root, view, []) (Box.VtCenter[
Box.WBox(Button.widgetOf quitBttn),
Box.WBox(FileChooser.widgetOf fileChooser)
])
val shellArgs =
[([], Attrs.attr_title, Attrs.AV_Str "SelectableText Widget Demo"),
([], Attrs.attr_iconName, Attrs.AV_Str "demo-res")]
val shell = Shell.shell (root, view, shellArgs) (Box.widgetOf layout)
val hints = Shell.mkHints{size_hints=[],wm_hints=[ICCC.HINT_Input(true)]}
val _ = Shell.setWMHints shell hints
val cmEvt = Shell.deletionEvent shell
fun printList [] = (TextIO.print "\n")
| printList ((hd,_)::[]) = (TextIO.print (hd); printList [])
| printList ((hd,_)::tl) = (TextIO.print (hd^", "); printList tl)
60fun findNumOfFD selection =
let
fun aux ([],(dir,fil)) = (dir,fil)
| aux ((_,t)::tl,(dir,fil)) = aux (tl,(if t then (dir+1,fil) else (dir,fil+1)))
in
aux (selection,(0,0))
end
fun openFiles selection = (TextIO.print "Opening Files\n";printList selection)
fun openDirs [] = FileChooser.setError fileChooser "No Directory to Open"
| openDirs ((selection,_)::[]) = FileChooser.setDirectory fileChooser
((FileChooser.getCurrentDirectory fileChooser)
^"/"^selection
)
| openDirs (selection::tl) = (FileChooser.setError fileChooser "Cannot open multiple directories")
fun openDirOrFile selection =
let val (dir,fil) = findNumOfFD selection
fun choose (0,n) = openFiles selection
| choose (n,0) = openDirs selection
| choose _ = (FileChooser.setError fileChooser "Cannot select directories AND files")
in choose (dir,fil)
end
fun loop():unit =
let
fun handleOpen (Button.BtnUp _) = (openDirOrFile (FileChooser.getCurrentSelection fileChooser); loop ())
| handleOpen (_) = loop()
fun handleQuit (Button.BtnUp _) = (TextIO.print " [demo-res quitting]\n"; quit())
| handleQuit (_) = (loop())
in CML.select
[CML.wrap(openEvt, handleOpen),
CML.wrap(quitEvt, handleQuit),
CML.wrap(cmEvt, quit)
]
end
in
Shell.init shell;
loop()
end
fun doit (dpyOpt,args) =
(RunCML.doit (fn () => (init (dpyOpt,args)), NONE))
fun main (prog, "-display"::(server::args)) =
((TextIO.print ("display="^server)); doit(SOME server,args))
| main (prog, args) = doit(NONE,args)
end
