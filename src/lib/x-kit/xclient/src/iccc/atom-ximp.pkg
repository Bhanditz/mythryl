## atom-ximp.pkg
#
# A Client-side server for atoms.
#
# See also:
#
#     src/lib/x-kit/xclient/src/iccc/atom-old.pkg
#
# Q: Should we have an in-process cache so we
#    don't have to hit the X server every time?
#    Reppy apparently set one up but then didn't
#    use it...

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib



stipulate
    include threadkit;							# threadkit		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package xt  =  xtypes;						# xtypes		is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package w2v =  wire_to_value;					# wire_to_value		is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package v2w =  value_to_wire;					# value_to_wire		is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package sp  =  xsequencer;						# xsequencer		is from   src/lib/x-kit/xclient/src/wire/xsequencer.pkg
    package ap  =  atom_port;						# atom_port		is from   src/lib/x-kit/xclient/src/iccc/atom-port.pkg
herein

    # This imp is typically instantiated by:
    #
    #     src/lib/x-kit/xclient/src/window/xsession-junk.pkg

    package   atom_ximp
    : (weak)  Atom_Ximp							# Atom_Ximp		is from   src/lib/x-kit/xclient/src/iccc/atom-ximp.api
    {
	Atom_Ximp_State = Void;						# Opaque wrapper for all mutable state maintained by ximp.

	Exports	  = {							# Ports we export for use by other imps.
		      atom_port:		ap::Atom_Port
		    };

	Imports   = {							# Ports we use which are exported by other imps.
		      xsequencer:		sp::Xsequencer
		    };

	Option = MICROTHREAD_NAME String;							# 

	Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);

	Client_Plea
	  = PLEA_INTERN  (String,	Oneshot_Maildrop(          xt::Atom   ))
	  | PLEA_LOOKUP  (String,	Oneshot_Maildrop( Null_Or( xt::Atom ) ))
	  | PLEA_NAME    (xt::Atom,	Oneshot_Maildrop(          String     ))
	  ;

	Client_Q    = Mailqueue( Client_Plea );

	Me_Slot = Mailslot( { imports:	Imports,
				  me:		Atom_Ximp_State,
				  run_gun':	Run_Gun,
				  end_gun':	End_Gun
				}
			      );


	fun intern  (xsequencer:	sp::Xsequencer)
		    #
		    (arg:		{ name:			String,
					  only_if_exists:	Bool
                            		}
		    )
	    =
	    w2v::decode_intern_atom_reply
		(block_until_mailop_fires
#		 ========================				# XXX SUCKO FIXME
		    (xsequencer.send_xrequest_and_read_reply
			(v2w::encode_intern_atom  arg)
		)   );




	fun run {													# These values will be statically globally visible throughout the code body for the imp.
		  me:					Atom_Ximp_State,						# State which is preserved across imp shutdown/restart cycles.
		  imports:				Imports,							# Ximps to which we send requests.
		  to:					Replyqueue,							# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		  end_gun':				End_Gun,							# We shut down the microthread when this fires.
		  client_q:				Client_Q							# Requests from x-widgets and such via draw_imp, pen_imp or font_imp.
		}
	    =
	    loop ()
	    where

		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                        ==>  shut_down_atom_ximp'),
			    (take_from_mailqueue' client_q   ==>  do_client_plea)
			];

			loop ();
		    }	
		    where
			fun shut_down_atom_ximp' ()
			    =
			    thread_exit { success => TRUE };								# Will not return.	
			#

			stipulate
			    #

			herein
			    fun do_client_plea (PLEA_INTERN (id, reply_1shot))
				    =>
				    put_in_oneshot (reply_1shot, intern imports.xsequencer { name => id, only_if_exists => FALSE } );

				do_client_plea (PLEA_LOOKUP (id, reply_1shot))
				    =>
				    case (intern imports.xsequencer { name => id, only_if_exists => TRUE } )
					#
					(xt::XATOM 0u0) =>   put_in_oneshot (reply_1shot, NULL    );
					atom            =>   put_in_oneshot (reply_1shot, THE atom);
				    esac;

				do_client_plea (PLEA_NAME (atom, reply_1shot))
				    =>
				    put_in_oneshot (reply_1shot, name)
				    where 

					name =  w2v::decode_get_atom_name_reply (
						    block_until_mailop_fires (
#                                                   ========================                                XXX SUCKO FIXME
							imports.xsequencer.send_xrequest_and_read_reply  (
							    v2w::encode_get_atom_name { atom }
							)
						    )
						);
				   end;
			    end;
			end;
		    end;												# fun loop
	    end;													# fun run
	
	fun startup   (reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot     =  make_mailslot  ()	:  Me_Slot;
		#
		atom_port  =  { make_atom,
				find_atom,
				atom_to_string
			      };

		to             =  make_replyqueue();

		put_in_oneshot (reply_oneshot, (me_slot, { atom_port }));						# Return value from make_atom_ximp().

		(take_from_mailslot  me_slot)									# Input args from configure_sequencer_imp().
		    ->
		    { me, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		run { me, client_q, imports, to, end_gun' };								# Will not return.
	    }
	    where
		client_q  =  make_mailqueue (get_current_microthread())	:  Client_Q;

		fun make_atom  atom_name
		    =
		    {   reply_1shot =   make_oneshot_maildrop ();
			#
			put_in_mailqueue  (client_q,  PLEA_INTERN (atom_name, reply_1shot));

			get_from_oneshot  reply_1shot;
		    };

		fun find_atom  atom_name
		    =
		    {   reply_1shot =   make_oneshot_maildrop ();
			#
			put_in_mailqueue  (client_q,  PLEA_LOOKUP (atom_name, reply_1shot));

			get_from_oneshot  reply_1shot;
		    };

		fun atom_to_string  atom
		    =
		    {   reply_1shot =   make_oneshot_maildrop ();
			#
			put_in_mailqueue  (client_q,  PLEA_NAME (atom, reply_1shot));

			get_from_oneshot  reply_1shot;
		    };
	    end;


	fun process_options (options: List(Option), { name })
	    =
	    {   my_name   = REF name;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME n)  =   my_name := n;
		end;

		{ name => *my_name };
	    };



        ##########################################################################################
	# External entrypoints
	#
	fun make_atom_egg (options: List(Option))									# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	    =
	    {   (process_options (options, { name => "atom" }))
		    ->
		    { name };
	
		me = ();

		fn () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );		# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  reply_oneshot);					# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    phase3
				=
				fn  ( imports:	Imports,								# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				      run_gun':	Run_Gun,	
				      end_gun':	End_Gun
				    )
				    =
				    {
					put_in_mailslot  (me_slot, { me, imports, run_gun', end_gun' });
				    };

			    (exports, phase3);
			};
	    };
    };					#  atom_imp 
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2014,
## released per terms of SMLNJ-COPYRIGHT.
