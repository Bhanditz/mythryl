## sequencer-ximp.pkg
#
# For the big picture see the imp dataflow diagram in
#
#     src/lib/x-kit/xclient/src/window/xsession.pkg
#
# The sequencer is responsible for matching
# replies read from the X with requests sent
# to it.
#
# All requests to the X-server go through the sequencer,
# as do all replies from the X-server.
#
# The sequencer communicates on five fixed channels:
#
#   plea_mailslot       -- request messages from clients
#   from_x_mailslot     -- reply, error and event messages from the X server (via the input buffer)
#   to_x_mailslot       -- requests messages to the X server (via the output buffer)
#   xevent_mailslot     -- X-events to the X-event buffer (and thence to clients)
#   error_sink_mailslot -- errors to the error handler
#
# In addition, the sequencer sends replies
# to clients on the reply channel that was
# bundled with the request.
#
# We maintain a pending-reply queue of requests sent
# to the X server for which replies are expected but
# not yet received.
#     We represent it using the usual two-list arrangement,
# writing new entries to the rear list while reading them
# from the front list; when the front list is empty we
# reverse the rear list and make it the new front list.

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib





stipulate
    include threadkit;						# threadkit					is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    #
    package un  =  unt;						# unt						is from   src/lib/std/unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package w2v =  wire_to_value;				# wire_to_value					is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package xg  =  xgeometry;					# xgeometry					is from   src/lib/std/2d/xgeometry.pkg
    package xtr =  xlogger;					# xlogger					is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package op  =  outbuf_port;					# outbuf_port					is from   src/lib/x-kit/xclient/src/wire/outbuf-port.api
    package sp  =  sequencer_port;				# sequencer_port				is from   src/lib/x-kit/xclient/src/wire/sequencer-port.api
    package xms =  xmsg_sink;					# xmsg_sink					is from   src/lib/x-kit/xclient/src/wire/xmsg-sink.pkg

    #
    trace =  xtr::log_if  xtr::io_logging  0;			# Conditionally write strings to tracing.log or whatever.
herein


    package   sequencer_ximp
    : (weak)  Sequencer_Ximp					# Sequencer_Ximp				is from   src/lib/x-kit/xclient/src/wire/sequencer-ximp.api
    {

	exception LOST_REPLY;
	exception ERROR_REPLY  xerrors::Xerror;

	Run_Gun =  Mailop(Void);				# Purely for readability.
	End_Gun =  Mailop(Void);				# Purely for readability.

	max_bytes_per_socket_write = 2048;

	Xmsg_Plea =  XPLEA_NOTE_XMSG  xms::Xmsg;

	# Client pleas to sequencer:
	#
	Sequencer_Plea						# 'Plea_Mail' in xsocket.pkg
	  = PLEA             v1u::Vector
	  | PLEA_REPLY      (v1u::Vector, Mailslot(Reply_Mail))
#	  = PLEA_QUIT
#	  | PLEA_FLUSH
#	  | PLEA_AND_CHECK  (v1u::Vector, Mailslot(Reply_Mail))
#	  | PLEA_REPLIES    (v1u::Vector, Mailslot(Reply_Mail), (v1u::Vector -> Int))
#	  | PLEA_EXPOSURES  (v1u::Vector, Oneshot_Maildrop (Void -> List(xg::Box) ))


	# Sequencer replies to client requests:
	#
	also
	Reply_Mail
	  = REPLY_LOST				# The reply was lost somewhere in transit.
	  | REPLY        v1u::Vector		# A normal reply.
	  | REPLY_ERROR  v1u::Vector		# The server returned an error message.
	  ;




	Pending_Reply = ONE_REPLY       (un::Unt, Mailslot( Reply_Mail ))
		      | EXPOSURE_REPLY  (un::Unt, Oneshot_Maildrop( Void -> List( xg::Box ) ))
		      | ERROR_CHECK     (un::Unt, Mailslot( Reply_Mail ))
		      | MULTI_REPLY     (un::Unt, Mailslot( Reply_Mail ), (v1u::Vector -> Int), List( v1u::Vector ))
		      ;
	    #
	    # Above gives the kind of reply that is
	    # pending for an outstanding request in
	    # the outstanding-request queue.
	    #
	    # We use unsigneds to represent the
	    # sequence numbers.
	    #
	    # ONE_REPLY is the workhorse call:
	    #    A request generating a single reply.
	    #
	    # MULTI_REPLY is a currently unused call
	    #    supporting multiple responses to a single request:
	    #    we accumulate responses until the (v1u::Vector -> Int)
	    #    function argument ("remaining") returns 0. 
	    #    (The fourth slot is just the reply accumulator.)

	Sequencer_Ximp_State				# Opaque wrapper for all nonephemeral mutable state maintained by ximp.
	    =
	    { last_seqn_read: Ref(Unt),
              last_seqn_sent: Ref(Unt),
	      #	
	      pending_reply_queue:     {   front:    Ref( List( Pending_Reply ) ),
					    rear:    Ref( List( Pending_Reply ) )
				       }
	    };

	Outports  = { outbuf_port:		op::Outbuf_Port,
		      xerror_sink:		xms::Xmsg_Sink				# Sends errors to err_handler() in  src/lib/x-kit/xclient/src/wire/display.pkg  via  read_xerror() in  src/lib/x-kit/xclient/src/wire/xsocket.pkg
		    };

	Configport = Mailslot( {  outports:	Outports,
                                  me:		Sequencer_Ximp_State,
				  run_gun':	Run_Gun,
				  end_gun':	End_Gun
				}
			     );

	Sequencer_Q      = Mailqueue( Sequencer_Plea );
	Xmsg_Q  = Mailqueue( Xmsg_Plea );

	Inports	= { configport:		Configport,
		    xmsg_sink:		xms::Xmsg_Sink,						# From xserver via inbuf.
		    sequencer_port:	sp::Sequencer_Port					# Requests from widget/application code.
		  };


	empty_v =   v1u::from_list [];

	# Convert "abc" -> "61.62.63." etc:
	#
	fun string_to_hex s
	    =
	    string::translate
		(fn c =  number_string::pad_left '0' 2 (int::format number_string::HEX (char::to_int c)) + ".")
		 s;

	# As above, starting with byte-vector:
	#
	fun bytes_to_hex  bytes
	    =
	    string_to_hex (byte::unpack_string_vector(vector_slice_of_one_byte_unts::make_slice (bytes, 0, NULL)));

	# Show printing chars verbatim, everything
	# else as '.', per hexdump tradition:
	#
	fun string_to_ascii s
	    =
	    string::translate
		(fn c =  char::is_print c  ??  string::from_char c  ::  ".")
		s;

	# As above, starting with byte-vector:
	#
	fun bytes_to_ascii  bytes
	    =
	    string_to_ascii (byte::unpack_string_vector (vector_slice_of_one_byte_unts::make_slice (bytes, 0, NULL)));



#  +DEBUG 
	fun seqn_to_string  n					# "seqn" == "sequence number"
	    =
	    un::format  number_string::DECIMAL  n;

	#
	fun queue_element_to_string (ERROR_CHECK       (n, _)) => "  ERROR_CHECK seqn=="    + (seqn_to_string n);
	    queue_element_to_string (ONE_REPLY         (n, _)) => "  ONE_REPLY seqn=="      + (seqn_to_string n);
	    queue_element_to_string (MULTI_REPLY (n, _, _, _)) => "  MULTI_REPLY seqn=="    + (seqn_to_string n);
	    queue_element_to_string (EXPOSURE_REPLY    (n, _)) => "  EXPOSURE_REPLY seqn==" + (seqn_to_string n);
	end;
	#
	fun pending_reply_queue_to_string ([], [])
		=>
		"(pending reply queue is empty)";

	    pending_reply_queue_to_string (front, rear)
		=>
		"(" + (cat (queue_to_strings (front @ (reverse rear), []))) + ")"
		where
		    fun queue_to_strings ([], l)    =>  reverse l;
			queue_to_strings (x ! r, l) =>  queue_to_strings (r, ((queue_element_to_string x) + ";  ") ! l);
		    end;
		end;
	end;
#  -DEBUG 
	#
	fun seqn_of (ERROR_CHECK    (seqn, _      )) =>  seqn;
	    seqn_of (ONE_REPLY      (seqn, _      )) =>  seqn;
	    seqn_of (MULTI_REPLY    (seqn, _, _, _)) =>  seqn;
	    seqn_of (EXPOSURE_REPLY (seqn, _      )) =>  seqn;
	end;

	# Spawn throw-away thread to deliver
	# X server reply to requesting client
	# application thread.  This avoids
	# blocking our own thread until the
	# the client thread is ready:
	# 
	fun send_reply  arg
	    =
	    {   make_thread  "xsocket reply"  .{  put_in_mailslot arg;  };
		#
		();
	    };

	# Spawn throw-away thread to deliver
	# multiple X server replies.  This is
	# to handle the currently-unused MULTI_REPLY:
	#
	fun send_replies (slot, replies)
	    =
	    {   fun loop [] =>  ();
		    #
		    loop (s ! rest)
			=>
			{   put_in_mailslot (slot, REPLY s);
			    #
			    loop rest;
			};
		end;

		make_thread "xsocket replies"  .{
		    #
		    loop (reverse replies);
		};

		();
	    };



	# Search pending-reply queue for the
	# sequence number n, which is from the
	# latest X server message received.
	#
	# If we have any pending replies with
	# lower sequence numbers they must
	# correspond to lost X server requests,
	# so we do the best we can with them
	# and then drop them from the queue.
	#
	# We return the pair
	#
	#    { found_it, updated_queue }
	#
	# where:
	#
	#    updated_queue
	#        is the updated queue.
	#
	#    found_it
	#        is TRUE iff the head
	#        of updated_queue has
	#        sequence number n.
	#	
	fun get_pending_reply_n (n, q)
	    =
	    drop_outdated_pending_replies q
	    where
		fun drop_outdated_reply (ERROR_CHECK(_, slot)) =>  send_reply (slot, REPLY empty_v);
		    drop_outdated_reply (ONE_REPLY  (_, slot)) =>  send_reply (slot, REPLY_LOST);

		    drop_outdated_reply (MULTI_REPLY(_, slot, _, []     )) =>  send_reply   (slot, REPLY_LOST);
		    drop_outdated_reply (MULTI_REPLY(_, slot, _, replies)) =>  send_replies (slot, replies);

		    drop_outdated_reply (EXPOSURE_REPLY(_, sync_1shot))
			=>
			put_in_oneshot  (sync_1shot,  fn () = raise exception LOST_REPLY);
		end;

		#
		fun drop_outdated_pending_replies (q' as ([], []))
			=>
			{ found_it => FALSE, updated_queue => q' };

		    drop_outdated_pending_replies ([], rear)
			=>
			drop_outdated_pending_replies (reverse rear, []);

		    drop_outdated_pending_replies (q' as ((pending_reply ! r), rear))
			=>
			{   seqn =  seqn_of  pending_reply;
			    #
			    if (seqn < n)
				#
				drop_outdated_reply  pending_reply;
				#
				drop_outdated_pending_replies (r, rear);
			    else
				seqn > n  ??   { found_it => FALSE, updated_queue => q' }
					  ::   { found_it => TRUE,  updated_queue => q' };
			    fi;
			};
		  end;

	    end;



	# Extract the pending-reply queue entry 
	# with the sequence number n.
	#
	# If all of the expected X server replies
	# for that entry have been received then
	# send the extracted reply to the requesting
	# client.
	#
	fun handle_reply_message (seqn, reply, pending_reply_queue)
	    =
	    case (get_pending_reply_n (seqn, pending_reply_queue))
		#
		{ found_it => TRUE,  updated_queue => (ONE_REPLY(_, slot) ! r, rear) }
		    =>
		    {   send_reply (slot, REPLY reply);
			(r, rear);
		    };

		{ found_it => TRUE,  updated_queue => (MULTI_REPLY (seqn, slot, remaining, replies) ! rest, rear) }
		    =>
		    if (remaining reply  ==  0)
			#
			send_replies (slot, reply ! replies);
			(rest, rear);
		    else
			( MULTI_REPLY (seqn, slot, remaining, reply ! replies) ! rest,
			  rear
			);
		    fi;
												    # xgripe	is from   src/lib/x-kit/xclient/src/stuff/xgripe.pkg
		_   => 
		    {   # Debug support:
			#	
			trace  .{   sprintf "IMPOSSIBLE ERROR: xsocket::handle_reply_message(seqn==%s, reply x=%s (%d bytes)...): BOGUS PENDING REPLY QUEUE, queue =%s"
					(seqn_to_string seqn)
					(bytes_to_hex reply)
					(v1u::length reply)
					(pending_reply_queue_to_string pending_reply_queue);
				};
			xgripe::impossible (sprintf "XERROR: xsocket::handle_reply_message(seqn==%s,...): BOGUS PENDING REPLY QUEUE" (seqn_to_string seqn));
		    };
	   esac;


	# Extract the pending-reply queue entry
	# with seqence number n:
	#
	fun handle_expose_message (n, reply, pending_reply_queue)
	    =
	    {
		case (get_pending_reply_n (n, pending_reply_queue))
		    #
		    { found_it      =>  TRUE,
		      updated_queue =>  (EXPOSURE_REPLY(_, sync_1shot) ! rest,  rear)
		    }
			=>  {   put_in_oneshot  (sync_1shot,  fn () = reply);
				#
				(rest, rear);
			    };

		    # For now, just drop it.
		    # When the gc-server supports graphics-exposures,
		    # these shouldn't happen:				XXX SUCKO FIXME
		    #
		    _   =>  {
				pending_reply_queue;
			    };

		esac;

							    # +DEBUG 
							    # (dumpPendingQ (n, q);
							    #  xgripe::impossible "ERROR: xsocket::handle_expose_message: bogus pending reply queue]")
							    # -DEBUG
	    };

	# Extract the pending-reply queue entry
	# with seqence number n (corresponding
	# to the given error message):
	#
	fun handle_error_message (n, err, pending_reply_queue)
	    = 
	    case (get_pending_reply_n (n, pending_reply_queue))
		#
		{ found_it => TRUE,  updated_queue => (ERROR_CHECK(_, slot) ! rest,  rear) }
		    =>
		    {   send_reply (slot, REPLY_ERROR err);
			(rest, rear);
		    };

		{ found_it => TRUE,  updated_queue => (ONE_REPLY(_, slot) ! rest,  rear) }
		    =>
		    {   send_reply (slot, REPLY_ERROR err);
			(rest, rear);
		    };

		{ found_it => TRUE,  updated_queue => (MULTI_REPLY(_, slot, _, _) ! rest, rear) }
		    =>
		    {   send_reply (slot, REPLY_ERROR err);
			(rest, rear);
		    };

		{ found_it => TRUE,  updated_queue => (EXPOSURE_REPLY(_, sync_1shot) ! rest, rear) }
		    =>
		    {   put_in_oneshot  (sync_1shot,  fn () = raise exception ERROR_REPLY (w2v::decode_error err));
			(rest, rear);
		    };

		{ found_it => FALSE,  updated_queue => pending_reply_queue' }
		    =>
		    pending_reply_queue';

		_   =>
/* DEBUG */         {   trace .{ sprintf "IMPOSSIBLE ERROR: xsocket::handle_error_message(seqn==%s: BOGUS PENDING REPLY QUEUE, queue =%s" (seqn_to_string n) (pending_reply_queue_to_string pending_reply_queue);  };
			xgripe::impossible "ERROR: xsocket::handle_error_message: bogus pending reply queue]";
/* DEBUG */         };
	    esac;

	#
	fun handle_event_message (n, pending_reply_queue)
	    =
	    case (get_pending_reply_n (n, pending_reply_queue))
		#
		{ found_it => TRUE,  updated_queue => (ERROR_CHECK(_, slot) ! rest,  rear) }
		    =>
		    {   send_reply (slot, REPLY empty_v);
			(rest, rear);
		    };

		{ found_it,  updated_queue => pending_reply_queue' }
		    =>
		    pending_reply_queue';
	    esac;
# ABOVE CODE COMPILES BUT NOT YET CALLED.

	
	fun run { me:			Sequencer_Ximp_State,								# These four values will be statically globally visible
		  xmsg_q:		Xmsg_Q,										# throughout the code body for the imp.
		  sequencer_q:		Sequencer_Q,
		  outports:		Outports,
		  to:			Replyqueue(Void),								# The name makes   foo::pass_something(imp) to .{ ... }   syntax read well.
		  end_gun':		End_Gun										# We shut down the microthread when this fires.
		}
	    =
	    loop ()
	    where
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                               ==>  shut_down_sequencer_imp'),
			    (take_all_from_mailqueue' sequencer_q   ==>  do_sequencer_pleas),
			    (take_from_mailqueue'     xmsg_q  	    ==>  do_xmsg_plea)
			];

			loop ();
		    }	
		    where
			fun shut_down_sequencer_imp' ()
			    =
			    thread_exit { success => TRUE };								# Will not return.	
			#

			stipulate
			    fun add_to_pending_reply_queue  pending_reply
				=
				{   me.pending_reply_queue -> { front, rear };
				    #
				    rear :=  pending_reply ! *rear;
				};
			    #
			    fun send_request_reply (request, reply_mailslot)
				=
				{   n = *me.last_seqn_sent + 0u1;
				    me.last_seqn_sent := n;

				    outports.outbuf_port.send_bytes  request;

				    add_to_pending_reply_queue (ONE_REPLY (n, reply_mailslot));
				};

			    #
#			    fun send_request_and_check (req, reply_mailslot)
#				=
#				{   n = *me.last_seqn_sent + 0u1;
#
#				    me.last_seqn_sent := n;
#				    #
#				    put_in_mailslot (to_x_mailslot, ADD_TO_OUTBUF req);
#
#				    m.pending_reply_queue :=  add_to_pending_reply_queue (ERROR_CHECK (n, reply_mailslot), *me.pending_reply_queue);
#				};
#
#			    fun send_request_replies (req, reply_mailslot, remain)
#				=
#				{   n = *me.last_seqn_sent + 0u1;
#				    me.last_seqn_sent := n;
#				    #
#				    put_in_mailslot (to_x_mailslot, ADD_TO_OUTBUF req);
#
#				    me.pending_reply_queue :=  add_to_pending_reply_queue (MULTI_REPLY (n, reply_mailslot, remain, []), *me.pending_reply_queue);
#				};
#
#			    fun send_request_exposures (req, sync_v)
#				=
#				{   n = *me.last_seqn_sent + 0u1;
#				    me.last_seqn_sent := n;
#				    #
#				    put_in_mailslot (to_x_mailslot, ADD_TO_OUTBUF req);
#
#				    me.pending_reply_queue := add_to_pending_reply_queue (EXPOSURE_REPLY (n, sync_v), *me.pending_reply_queue);
#				};
			    #
			    fun do_clientplea (PLEA_REPLY     request) =>  send_request_reply     request;

#				do_clientplea (PLEA_AND_CHECK request) =>  send_request_and_check request;
#				do_clientplea (PLEA_REPLIES   request) =>  send_request_replies   request;
#				do_clientplea (PLEA_EXPOSURES request) =>  send_request_exposures request;
#				#
				do_clientplea (PLEA request)
				    =>
				    {   outports.outbuf_port.send_bytes  request;
					#
					me.last_seqn_sent := *me.last_seqn_sent + 0u1;
				    };
			    end;

			herein
			    fun do_xmsg_plea (XPLEA_NOTE_XMSG (xmsg as { code: v1u::Element,  msg: v1u::Vector }))
				=
				();

			    # Handle requests from clients
			    # (app threads on our side):
			    # 
			    fun do_sequencer_pleas  [] =>    ();
				#
				do_sequencer_pleas  pleas
				    =>
				    {   apply  do_clientplea  pleas;
					#	
				#       put_in_mailslot (to_x_mailslot, FLUSH_OUTBUF);
				    };
			    end;
			end;
		    end;												# fun loop
	    end;													# fun run
	
	fun startup   (reply_oneshot:  Oneshot_Maildrop( Inports ))   ()						# Root fn of imp microthread.  Note currying.
	    =
	    {   configport     =  make_mailslot  ()	:  Configport;

		xmsg_sink      =  { note_xmsg };

		sequencer_port =  { send_xrequest,
				    send_xrequest_and_read_reply
				  };

		to             =  make_replyqueue();

		put_in_oneshot (reply_oneshot, { configport, xmsg_sink, sequencer_port });				# Return value from make_sequencer_ximp().

		(take_from_mailslot  configport)									# Input args from configure_sequencer_imp().
		    ->
		    { me, outports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		run { me, xmsg_q, sequencer_q, outports, to, end_gun' };						# Will not return.
	    }
	    where
		xmsg_q       =  make_mailqueue (get_current_microthread())	:  Xmsg_Q;
		sequencer_q  =  make_mailqueue (get_current_microthread())	:  Sequencer_Q;

		# Reply handling in the Client-thread context.
		#
		# Most processing happens in our own microthread,
		# but any client-relevant exception
		# needs to be raised in the context of the
		# calling client thread.  That is our job here:
		#
		fun unwrap_reply  REPLY_LOST     =>  raise exception LOST_REPLY;
		    unwrap_reply (REPLY_ERROR s) =>  raise exception ERROR_REPLY (w2v::decode_error s);
		    unwrap_reply (REPLY s)       =>  s;
		end;
		#
		fun send_xrequest  (s: v1u::Vector)
		    =
		    {
			put_in_mailqueue (sequencer_q, PLEA s);
		    };

		# This is a workhorse call,
		# request-with-single-reply:
		# 
		fun send_xrequest_and_read_reply  (s: v1u::Vector)
		    =
		    {   reply_mailslot = make_mailslot ();
			#
			put_in_mailqueue (sequencer_q, PLEA_REPLY (s, reply_mailslot));

			take_from_mailslot'  reply_mailslot
			    ==>
			    unwrap_reply;
		    };
		#
		fun note_xmsg (xmsg: xms::Xmsg)										# External entrypoint.
		    =	
		    put_in_mailqueue  (xmsg_q, XPLEA_NOTE_XMSG xmsg);
	    end;

        ##########################################################################################
	# External entrypoints
	#
	fun make_sequencer_ximp_state ()										# External entrypoint.
	  =
	  { last_seqn_read	=>  REF 0u0,
	    last_seqn_sent	=>  REF 0u0,
	    pending_reply_queue	=>  { front =>  REF [],
				      rear  =>  REF []
				    }
	  };
	#
	fun make_sequencer_ximp  (name: String)										# External entrypoint.
	    =
	    {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( Inports );
		#
		xlogger::make_thread  name  (startup  reply_oneshot);							# Note that startup() is curried.

		get_from_oneshot  reply_oneshot;
	    };
	#
	#
	fun configure_sequencer_ximp											# External entrypoint.
	      (
		configport:	Configport,
		me:		Sequencer_Ximp_State,
		outports:	Outports,
		run_gun':	Run_Gun,
		end_gun':	End_Gun
	      )
	    =
	    put_in_mailslot  (configport, { me, outports, run_gun', end_gun' });

    };						# package sequencer_ximp
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
