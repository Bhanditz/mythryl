## sequencer-ximp.pkg
#
# For the big picture see the imp dataflow diagram in
#
#     src/lib/x-kit/xclient/src/window/xsession.pkg
#
# The sequencer is responsible for matching
# replies read from the X with requests sent
# to it.
#
# All requests to the X-server go through the sequencer,
# as do all replies from the X-server.
#
# The sequencer communicates on five fixed channels:
#
#   plea_mailslot       -- request messages from clients
#   from_x_mailslot     -- reply, error and event messages from the X server (via the input buffer)
#   to_x_mailslot       -- requests messages to the X server (via the output buffer)
#   xevent_mailslot     -- X-events to the X-event buffer (and thence to clients)
#   error_sink_mailslot -- errors to the error handler
#
# In addition, the sequencer sends replies
# to clients on the reply channel that was
# bundled with the request.
#
# We maintain a pending-reply queue of requests sent
# to the X server for which replies are expected but
# not yet received.
#     We represent it using the usual two-list arrangement,
# writing new entries to the rear list while reading them
# from the front list; when the front list is empty we
# reverse the rear list and make it the new front list.

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib





stipulate
    include threadkit;						# threadkit					is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    #
    package un  =  unt;						# unt						is from   src/lib/std/unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package w2v =  wire_to_value;				# wire_to_value					is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package xg  =  xgeometry;					# xgeometry					is from   src/lib/std/2d/xgeometry.pkg
    package xtr =  xlogger;					# xlogger					is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package op  =  outbuf_port;					# outbuf_port					is from   src/lib/x-kit/xclient/src/wire/outbuf-port.api
    package sp  =  sequencer_port;				# sequencer_port				is from   src/lib/x-kit/xclient/src/wire/sequencer-port.api
    package xes =  xerror_sink;					# xerror_sink					is from   src/lib/x-kit/xclient/src/wire/xmsg-error.pkg
    package xms =  xmsg_sink;					# xmsg_sink					is from   src/lib/x-kit/xclient/src/wire/xmsg-sink.pkg
    package xt  =  xtypes;					# xtypes					is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package et  =  event_types;					# event_types					is from   src/lib/x-kit/xclient/src/wire/event-types.pkg

    #
    trace =  xtr::log_if  xtr::io_logging  0;			# Conditionally write strings to tracing.log or whatever.
herein


    package   sequencer_ximp
    : (weak)  Sequencer_Ximp					# Sequencer_Ximp				is from   src/lib/x-kit/xclient/src/wire/sequencer-ximp.api
    {

	exception LOST_REPLY;
	exception ERROR_REPLY  xerrors::Xerror;

	Run_Gun =  Mailop(Void);				# Purely for readability.
	End_Gun =  Mailop(Void);				# Purely for readability.

	max_bytes_per_socket_write = 2048;

	Xmsg_Plea =  XPLEA_NOTE_XMSG  xms::Xmsg;

	# Client pleas to sequencer:
	#
	Sequencer_Plea						# 'Plea_Mail' in xsocket.pkg
	  = PLEA             v1u::Vector
	  | PLEA_REPLY      (v1u::Vector, Oneshot_Maildrop(Reply_Mail))
#	  = PLEA_QUIT
#	  | PLEA_FLUSH
#	  | PLEA_AND_CHECK  (v1u::Vector, Mailslot(Reply_Mail))
#	  | PLEA_REPLIES    (v1u::Vector, Mailslot(Reply_Mail), (v1u::Vector -> Int))
#	  | PLEA_EXPOSURES  (v1u::Vector, Oneshot_Maildrop (Void -> List(xg::Box) ))


	# Sequencer replies to client requests:
	#
	also
	Reply_Mail
	  = REPLY_LOST				# The reply was lost somewhere in transit.
	  | REPLY        v1u::Vector		# A normal reply.
	  | REPLY_ERROR  v1u::Vector		# The server returned an error message.
	  ;




	Pending_Reply = ONE_REPLY       (un::Unt, Oneshot_Maildrop( Reply_Mail ))
		      | EXPOSURE_REPLY  (un::Unt, Oneshot_Maildrop( Void -> List( xg::Box ) ))
		      | ERROR_CHECK     (un::Unt, Oneshot_Maildrop( Reply_Mail ))
#		      | MULTI_REPLY     (un::Unt, Oneshot_Maildrop( Reply_Mail ), (v1u::Vector -> Int), List( v1u::Vector ))
		      ;
	    #
	    # Above gives the kind of reply that is
	    # pending for an outstanding request in
	    # the outstanding-request queue.
	    #
	    # We use unsigneds to represent the
	    # sequence numbers.
	    #
	    # ONE_REPLY is the workhorse call:
	    #    A request generating a single reply.
	    #
	    # MULTI_REPLY is a currently unused call
	    #    supporting multiple responses to a single request:
	    #    we accumulate responses until the (v1u::Vector -> Int)
	    #    function argument ("remaining") returns 0. 
	    #    (The fourth slot is just the reply accumulator.)

	Sequencer_Ximp_State				# Opaque wrapper for all nonephemeral mutable state maintained by ximp.
	    =
	    { last_seqn_read: Ref(Unt),
              last_seqn_sent: Ref(Unt),
	      #	
	      pending_reply_queue: Ref {   front:    List( Pending_Reply ),
					    rear:    List( Pending_Reply )
				       }
	    };

	Outports  = { outbuf_port:		op::Outbuf_Port,
		      xmsg_sink:		xms::Xmsg_Sink,					# Forwards xmsgs to xevent_reader_ximp from   src/lib/x-kit/xclient/src/wire/xevent-reader-ximp.pkg
		      xerror_sink:		xes::Xerror_Sink				# Sends errors to err_handler() in  src/lib/x-kit/xclient/src/wire/display.pkg  via  read_xerror() in  src/lib/x-kit/xclient/src/wire/xsocket.pkg
		    };

	Configport = Mailslot( {  outports:	Outports,
                                  me:		Sequencer_Ximp_State,
				  run_gun':	Run_Gun,
				  end_gun':	End_Gun
				}
			     );

	Sequencer_Q      = Mailqueue( Sequencer_Plea );
	Xmsg_Q  = Mailqueue( Xmsg_Plea );

	Inports	= { configport:		Configport,
		    xmsg_sink:		xms::Xmsg_Sink,						# From xserver via inbuf.
		    sequencer_port:	sp::Sequencer_Port					# Requests from widget/application code.
		  };


	empty_v =   v1u::from_list [];

	# Convert "abc" -> "61.62.63." etc:
	#
	fun string_to_hex s
	    =
	    string::translate
		(fn c =  number_string::pad_left '0' 2 (int::format number_string::HEX (char::to_int c)) + ".")
		 s;

	# As above, starting with byte-vector:
	#
	fun bytes_to_hex  bytes
	    =
	    string_to_hex (byte::unpack_string_vector(vector_slice_of_one_byte_unts::make_slice (bytes, 0, NULL)));

	# Show printing chars verbatim, everything
	# else as '.', per hexdump tradition:
	#
	fun string_to_ascii s
	    =
	    string::translate
		(fn c =  char::is_print c  ??  string::from_char c  ::  ".")
		s;

	# As above, starting with byte-vector:
	#
	fun bytes_to_ascii  bytes
	    =
	    string_to_ascii (byte::unpack_string_vector (vector_slice_of_one_byte_unts::make_slice (bytes, 0, NULL)));



#  +DEBUG 
	fun seqn_to_string  n					# "seqn" == "sequence number"
	    =
	    un::format  number_string::DECIMAL  n;

	#
	fun queue_element_to_string (ERROR_CHECK       (n, _)) => "  ERROR_CHECK seqn=="    + (seqn_to_string n);
	    queue_element_to_string (ONE_REPLY         (n, _)) => "  ONE_REPLY seqn=="      + (seqn_to_string n);
#	    queue_element_to_string (MULTI_REPLY (n, _, _, _)) => "  MULTI_REPLY seqn=="    + (seqn_to_string n);
	    queue_element_to_string (EXPOSURE_REPLY    (n, _)) => "  EXPOSURE_REPLY seqn==" + (seqn_to_string n);
	end;
	#
	fun pending_reply_queue_to_string { front => [], rear => [] }
		=>
		"(pending reply queue is empty)";

	    pending_reply_queue_to_string { front, rear }
		=>
		"{" + (cat (queue_to_strings (front @ (reverse rear), []))) + "}"
		where
		    fun queue_to_strings ([], l)    =>  reverse l;
			queue_to_strings (x ! r, l) =>  queue_to_strings (r, ((queue_element_to_string x) + ";  ") ! l);
		    end;
		end;
	end;
#  -DEBUG 
	#
	fun seqn_of (ERROR_CHECK    (seqn, _      )) =>  seqn;
	    seqn_of (ONE_REPLY      (seqn, _      )) =>  seqn;
#	    seqn_of (MULTI_REPLY    (seqn, _, _, _)) =>  seqn;
	    seqn_of (EXPOSURE_REPLY (seqn, _      )) =>  seqn;
	end;


	# Spawn throw-away thread to deliver
	# multiple X server replies.  This is
	# to handle the currently-unused MULTI_REPLY:
	#
#	fun send_replies (slot, replies)
#	    =
#	    loop (reverse replies)
#	    where	
#	        fun loop [] =>  ();
#		    #
#		    loop (s ! rest)
#			=>
#			{   put_in_mailslot (slot, REPLY s);
#			    #
#			    loop rest;
#			};
#		end;
#	    end;



	# Search pending-reply queue for the
	# sequence number n, which is from the
	# latest X server message received.
	#
	# If we have any pending replies with
	# lower sequence numbers they must
	# correspond to lost X server requests,
	# so we do the best we can with them
	# and then drop them from the queue.
	#
	# We return the pair
	#
	#    { found_it, updated_queue }
	#
	# where:
	#
	#    updated_queue
	#        is the updated queue.
	#
	#    found_it
	#        is TRUE iff the head
	#        of updated_queue has
	#        sequence number n.
	#	
	fun get_pending_reply_n (n, q)
	    =
	    handle_lost_replies  q
	    where
		fun handle_lost_reply (ERROR_CHECK(_, oneshot)) =>  put_in_oneshot (oneshot, REPLY empty_v);
		    handle_lost_reply (ONE_REPLY  (_, oneshot)) =>  put_in_oneshot (oneshot, REPLY_LOST);

#		    handle_lost_reply (MULTI_REPLY(_, oneshot, _, []     )) =>  put_in_oneshot  (oneshot, REPLY_LOST);
#		    handle_lost_reply (MULTI_REPLY(_, oneshot, _, replies)) =>  put_in_oneshot  (oneshot, replies);

		    handle_lost_reply (EXPOSURE_REPLY(_, oneshot))
			=>
			put_in_oneshot  (oneshot,  fn () = raise exception LOST_REPLY);
		end;

		#
		fun handle_lost_replies (q' as { front => [], rear => [] })
			=>
			{ found_it => FALSE, updated_queue => q' };

		    handle_lost_replies { front => [], rear }
			=>
			handle_lost_replies { front => (reverse rear), rear => [] };

		    handle_lost_replies  (q' as  { front => pending_reply ! rest,  rear })
			=>
			{   seqn =  seqn_of  pending_reply;
			    #
			    if (seqn < n)
				#
				handle_lost_reply  pending_reply;
				#
				handle_lost_replies  { front => rest,  rear };
			    else
				seqn > n  ??   { found_it => FALSE, updated_queue => q' }
					  ::   { found_it => TRUE,  updated_queue => q' };
			    fi;
			};
		  end;

	    end;



	# Extract the pending-reply queue entry 
	# with the sequence number n.
	#
	# If all of the expected X server replies
	# for that entry have been received then
	# send the extracted reply to the requesting
	# client.
	#
	fun handle_reply_message (seqn, reply, pending_reply_queue)
	    =
	    case (get_pending_reply_n (seqn, pending_reply_queue))
		#
		{ found_it => TRUE,  updated_queue =>  { front => ONE_REPLY(_, oneshot) ! rest,  rear } }
		    =>
		    {   put_in_oneshot (oneshot, REPLY reply);
			{ front => rest, rear };
		    };

#		{ found_it => TRUE,  updated_queue => { front => MULTI_REPLY (seqn, slot, remaining, replies) ! rest,  rear } }
#		    =>
#		    if (remaining reply  ==  0)
#			#
#			send_replies (slot, reply ! replies);
#			(rest, rear);
#		    else
#			( MULTI_REPLY (seqn, slot, remaining, reply ! replies) ! rest,
#			  rear
#			);
#		    fi;

		_   => 
		    {   # Debug support:
			#	
			log::fatal
			   .{   sprintf "IMPOSSIBLE ERROR: xsocket::handle_reply_message(seqn==%s, reply x=%s (%d bytes)...): BOGUS PENDING REPLY QUEUE, queue =%s"
				    (seqn_to_string seqn)
				    (bytes_to_hex reply)
				    (v1u::length reply)
				    (pending_reply_queue_to_string  pending_reply_queue);
			    };									# Does not return

			pending_reply_queue;							# Cannot execute -- just to pacify compiler typechecker.
		    };
	   esac;


	# Extract the pending-reply queue entry
	# with seqence number n:
	#
	fun handle_expose_event_train (n, reply, pending_reply_queue)
	    =
	    {
		case (get_pending_reply_n (n, pending_reply_queue))
		    #
		    { found_it      =>  TRUE,
		      updated_queue =>  { front => EXPOSURE_REPLY(_, oneshot) ! rest,  rear }
		    }
			=>  {   put_in_oneshot  (oneshot,  fn () = reply);
				#
				{ front => rest, rear };
			    };

		    # For now, just drop it.
		    # When the gc-server supports graphics-exposures,
		    # these shouldn't happen:				XXX SUCKO FIXME
		    #
		    _   =>  {
				pending_reply_queue;
			    };

		esac;

							    # +DEBUG 
							    # (dumpPendingQ (n, q);
							    #  xgripe::impossible "ERROR: xsocket::handle_expose_event_train: bogus pending reply queue]")
							    # -DEBUG
	    };

	# Extract the pending-reply queue entry
	# with seqence number n (corresponding
	# to the given error message):
	#
	fun handle_error_message (n, err, pending_reply_queue)
	    = 
	    case (get_pending_reply_n (n, pending_reply_queue))
		#
		{ found_it => TRUE,  updated_queue => { front => ERROR_CHECK(_, oneshot) ! rest,  rear } }
		    =>
		    {   put_in_oneshot (oneshot, REPLY_ERROR err);
			#
			{ front => rest, rear };
		    };

		{ found_it => TRUE,  updated_queue => { front => ONE_REPLY(_, oneshot) ! rest,  rear } }
		    =>
		    {   put_in_oneshot (oneshot, REPLY_ERROR err);
			#
			{ front => rest, rear };
		    };

#		{ found_it => TRUE,  updated_queue => { front => MULTI_REPLY(_, oneshot, _, _) ! rest, rear } }
#		    =>
#		    {   put_in_oneshot (oneshot, REPLY_ERROR err);
#			{ front => rest, rear };
#		    };

		{ found_it => TRUE,  updated_queue => { front => EXPOSURE_REPLY(_, oneshot) ! rest, rear } }
		    =>
		    {   put_in_oneshot  (oneshot,  fn () = raise exception ERROR_REPLY (w2v::decode_error err));
			#
			{ front => rest, rear };
		    };

		{ found_it => FALSE,  updated_queue => pending_reply_queue' }
		    =>
		    pending_reply_queue';

		_   =>
/* DEBUG */         {   trace .{ sprintf "IMPOSSIBLE ERROR: xsocket::handle_error_message(seqn==%s: BOGUS PENDING REPLY QUEUE, queue =%s" (seqn_to_string n) (pending_reply_queue_to_string pending_reply_queue);  };
			xgripe::impossible "ERROR: xsocket::handle_error_message: bogus pending reply queue]";
/* DEBUG */         };
	    esac;

	#
	fun handle_event_message (n, pending_reply_queue)
	    =
	    case (get_pending_reply_n (n, pending_reply_queue))
		#
		{ found_it => TRUE,  updated_queue => { front => ERROR_CHECK(_, oneshot) ! rest,  rear } }
		    =>
		    {   put_in_oneshot (oneshot, REPLY empty_v);
			#
			{ front => rest, rear };
		    };

		{ found_it,  updated_queue => pending_reply_queue' }
		    =>
		    pending_reply_queue';
	    esac;
# ABOVE CODE COMPILES BUT NOT YET CALLED.

	
	fun run {													# These values will be statically globally visible throughout the code body for the imp.
		  me:				Sequencer_Ximp_State,							# State which is preserved across imp shutdown/restart cycles.
		  outports:			Outports,								# Ximps to which we send requests.
		  to:				Replyqueue(Void),							# The name makes   foo::pass_something(imp) to .{ ... }   syntax read well.
		  end_gun':			End_Gun,								# We shut down the microthread when this fires.
		  xmsg_q:			Xmsg_Q,									# Xmsgs from inbuf_ximp -- src/lib/x-kit/xclient/src/wire/inbuf-ximp.pkg
		  sequencer_q:			Sequencer_Q,								# Requests from x-widgets and such via draw_imp, pen_imp or font_imp.
		  expose_event_accumulator:	Ref (Null_Or( et::x::Graphics_Expose_Record -> Void ) )			# Extra state for handling sequences of x::GRAPHICS_EXPOSE events.
		}
	    =
	    loop ()
	    where
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                               ==>  shut_down_sequencer_imp'),
			    (take_all_from_mailqueue' sequencer_q   ==>  do_sequencer_pleas),
			    (take_from_mailqueue'     xmsg_q  	    ==>  do_xmsg_plea)
			];

			loop ();
		    }	
		    where
			fun shut_down_sequencer_imp' ()
			    =
			    thread_exit { success => TRUE };								# Will not return.	
			#

			stipulate
			    fun add_to_pending_reply_queue  pending_reply
				=
				{   (*me.pending_reply_queue) -> { front, rear };
				    #
				    me.pending_reply_queue := { front, rear =>  pending_reply ! rear };
				};
			    #
			    fun send_request_reply (request, reply_oneshot)
				=
				{   n = *me.last_seqn_sent + 0u1;
				    me.last_seqn_sent := n;

				    outports.outbuf_port.send_bytes  request;

				    add_to_pending_reply_queue (ONE_REPLY (n, reply_oneshot));
				};

			    #
#			    fun send_request_and_check (req, reply_mailslot)
#				=
#				{   n = *me.last_seqn_sent + 0u1;
#
#				    me.last_seqn_sent := n;
#				    #
#				    put_in_mailslot (to_x_mailslot, ADD_TO_OUTBUF req);
#
#				    m.pending_reply_queue :=  add_to_pending_reply_queue (ERROR_CHECK (n, reply_mailslot), *me.pending_reply_queue);
#				};
#
#			    fun send_request_replies (req, reply_mailslot, remain)
#				=
#				{   n = *me.last_seqn_sent + 0u1;
#				    me.last_seqn_sent := n;
#				    #
#				    put_in_mailslot (to_x_mailslot, ADD_TO_OUTBUF req);
#
#				    me.pending_reply_queue :=  add_to_pending_reply_queue (MULTI_REPLY (n, reply_mailslot, remain, []), *me.pending_reply_queue);
#				};
#
#			    fun send_request_exposures (req, sync_v)
#				=
#				{   n = *me.last_seqn_sent + 0u1;
#				    me.last_seqn_sent := n;
#				    #
#				    put_in_mailslot (to_x_mailslot, ADD_TO_OUTBUF req);
#
#				    me.pending_reply_queue := add_to_pending_reply_queue (EXPOSURE_REPLY (n, sync_v), *me.pending_reply_queue);
#				};
			    #
			    fun do_clientplea (PLEA_REPLY     request) =>  send_request_reply     request;

#				do_clientplea (PLEA_AND_CHECK request) =>  send_request_and_check request;
#				do_clientplea (PLEA_REPLIES   request) =>  send_request_replies   request;
#				do_clientplea (PLEA_EXPOSURES request) =>  send_request_exposures request;
#				#
				do_clientplea (PLEA request)
				    =>
				    {   outports.outbuf_port.send_bytes  request;
					#
					me.last_seqn_sent := *me.last_seqn_sent + 0u1;
				    };
			    end;

			herein
			    fun do_xmsg_plea (XPLEA_NOTE_XMSG (xmsg as { code: v1u::Element,  msg: v1u::Vector }))
				=
				{
				    # NOTE: this doesn't work if there are 2**17
				    # outgoing messages between replies/events.
				    #
				    # We need to track (last_seqn_sent - last_seqn_read),
				    # and if it gets bigger than some reasonable size,
				    # generate a synchronization (i.e., get_input_focus message).	XXX BUGGO FIXME

				    fun get_seq_n ()
					=
					{   short_seq_n =   un::from_large_unt (pack_big_endian_unt16::get_vec (msg, 1));
					    #
					    seqn' = un::bitwise_or
						      ( un::bitwise_and (*me.last_seqn_read, un::bitwise_not 0uxffff),
							short_seq_n
						      );

					    seqn' < *me.last_seqn_read
					      ??  seqn' + 0ux10000		#  NOTE: we should check for (seqn' + 0x10000) > lastReqOut    XXX BUGGO FIXME
					      ::  seqn';
					};

				    case code
					#
					0u0 =>  {   # Error message:
						    #
						    seqn = get_seq_n ();

						    me.last_seqn_read := seqn;	

						    outports.xerror_sink.note_xerror  { seqn, msg };

						    me.pending_reply_queue :=  handle_error_message (seqn, msg, *me.pending_reply_queue);
						};


					0u1 =>  {   # Reply message:
						    #
						    seqn = get_seq_n ();
						    me.last_seqn_read := seqn;

						    me.pending_reply_queue :=   handle_reply_message (seqn, msg, *me.pending_reply_queue);
						};


					0u11 => {   # KeymapNotify event:
						    #
						    outports.xmsg_sink.note_xmsg  { code, msg };

						    me.pending_reply_queue :=   handle_event_message (*me.last_seqn_read, *me.pending_reply_queue);
						};


					0u13 => {   # GraphicsExpose event:
						    #
						    seqn = get_seq_n ();
						    me.last_seqn_read := seqn;

						    include  et;														# event_types	is from   src/lib/x-kit/xclient/src/wire/event-types.pkg

						    (w2v::decode_graphics_expose  msg)
							->
							et::x::GRAPHICS_EXPOSE  graphics_expose_record;

						    case *expose_event_accumulator
							#
							NULL	        =>      accumulate_expose_events  []   graphics_expose_record;						# Start    accumulating expose events in a fresh  sequence.
							THE accumulator =>      accumulator                    graphics_expose_record;						# Continue accumulating expose events in existing sequence.
						    esac
						    where
							# The X server sends numbered trains of expose events.
							# We use our 'expose_event_accumulator' refcell to accumulate
							# a train of expose events, then handle it when complete:
							#
							fun accumulate_expose_events   boxes   ({ box, count=>0, ... }:  et::x::Graphics_Expose_Record)				# Note currying.
								=>
								{   me.pending_reply_queue   :=   handle_expose_event_train  (seqn,  box ! boxes,  *me.pending_reply_queue);	# Sequence complete -- pass boxes to client code.
								    #
								    expose_event_accumulator :=   NULL;										# Done with this expose event sequence.
								};

							    accumulate_expose_events   boxes   ({ box,           ... }:  et::x::Graphics_Expose_Record)				# Sequence not complete -- continue accumulation.
								=>
								{
								    expose_event_accumulator :=   THE (accumulate_expose_events (box ! boxes));					# Note partial application of curried fn.
								};
							end;
						    end;
						};


					0u14 => {   # NoExpose event:
						    #
						    seqn = get_seq_n ();
						    me.last_seqn_read := seqn;

						    me.pending_reply_queue :=   handle_expose_event_train (seqn, [], *me.pending_reply_queue);
						};


					_    => {   # Other event messages:
						    #
						    seqn = get_seq_n ();
						    me.last_seqn_read := seqn;

						    outports.xmsg_sink.note_xmsg { code, msg };

						    me.pending_reply_queue :=  handle_event_message (seqn, *me.pending_reply_queue);
						};
				    esac;
				};

			    # Handle requests from clients
			    # (app threads on our side):
			    # 
			    fun do_sequencer_pleas  [] =>    ();
				#
				do_sequencer_pleas  pleas
				    =>
				    {   apply  do_clientplea  pleas;
					#	
				#       put_in_mailslot (to_x_mailslot, FLUSH_OUTBUF);
				    };
			    end;
			end;
		    end;												# fun loop
	    end;													# fun run
	
	fun startup   (reply_oneshot:  Oneshot_Maildrop( Inports ))   ()						# Root fn of imp microthread.  Note currying.
	    =
	    {   configport     =  make_mailslot  ()	:  Configport;

		xmsg_sink      =  { note_xmsg };

		sequencer_port =  { send_xrequest,
				    send_xrequest_and_read_reply
				  };

		to             =  make_replyqueue();

		put_in_oneshot (reply_oneshot, { configport, xmsg_sink, sequencer_port });				# Return value from make_sequencer_ximp().

		(take_from_mailslot  configport)									# Input args from configure_sequencer_imp().
		    ->
		    { me, outports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		expose_event_accumulator = REF NULL;

		run { me, xmsg_q, sequencer_q, outports, to, end_gun', expose_event_accumulator };			# Will not return.
	    }
	    where
		xmsg_q       =  make_mailqueue (get_current_microthread())	:  Xmsg_Q;
		sequencer_q  =  make_mailqueue (get_current_microthread())	:  Sequencer_Q;

		# Reply handling in the Client-thread context.
		#
		# Most processing happens in our own microthread,
		# but any client-relevant exception
		# needs to be raised in the context of the
		# calling client thread.  That is our job here:
		#
		fun unwrap_reply  REPLY_LOST     =>  raise exception LOST_REPLY;
		    unwrap_reply (REPLY_ERROR s) =>  raise exception ERROR_REPLY (w2v::decode_error s);
		    unwrap_reply (REPLY s)       =>  s;
		end;
		#
		fun send_xrequest  (s: v1u::Vector)
		    =
		    {
			put_in_mailqueue (sequencer_q, PLEA s);
		    };

		# This is a workhorse call,
		# request-with-single-reply:
		# 
		fun send_xrequest_and_read_reply  (s: v1u::Vector)
		    =
		    {   reply_oneshot = make_oneshot_maildrop ();
			#
			put_in_mailqueue (sequencer_q, PLEA_REPLY (s, reply_oneshot));

			get_from_oneshot'  reply_oneshot
			    ==>
			    unwrap_reply;
		    };
		#
		fun note_xmsg (xmsg: xms::Xmsg)										# External entrypoint.
		    =	
		    put_in_mailqueue  (xmsg_q, XPLEA_NOTE_XMSG xmsg);
	    end;

        ##########################################################################################
	# External entrypoints
	#
	fun make_sequencer_ximp_state ()										# External entrypoint.
	  =
	  { last_seqn_read	=>  REF 0u0,
	    last_seqn_sent	=>  REF 0u0,
	    pending_reply_queue	=>  REF { front =>  [],
				           rear =>  []
				        }
	  };
	#
	fun make_sequencer_ximp  (name: String)										# External entrypoint.
	    =
	    {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( Inports );
		#
		xlogger::make_thread  name  (startup  reply_oneshot);							# Note that startup() is curried.

		get_from_oneshot  reply_oneshot;
	    };
	#
	#
	fun configure_sequencer_ximp											# External entrypoint.
	      (
		configport:	Configport,
		me:		Sequencer_Ximp_State,
		outports:	Outports,
		run_gun':	Run_Gun,
		end_gun':	End_Gun
	      )
	    =
	    put_in_mailslot  (configport, { me, outports, run_gun', end_gun' });

    };						# package sequencer_ximp
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
