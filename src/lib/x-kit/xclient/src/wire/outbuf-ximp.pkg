## outbuf-ximp.pkg
#
# For the big picture see the imp dataflow diagram in
#
#     src/lib/x-kit/xclient/src/window/xsession.pkg

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib




							# event_types				is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
							# xerrors				is from   src/lib/x-kit/xclient/src/wire/xerrors.pkg

stipulate
    include threadkit;					# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    #
    package skj =  socket_junk;				# socket_junk				is from   src/lib/internet/socket-junk.pkg
    package sok =  socket__premicrothread;		# socket__premicrothread		is from   src/lib/std/socket--premicrothread.pkg
    package v1u =  vector_of_one_byte_unts;		# vector_of_one_byte_unts		is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    #
    package xtr =  xlogger;				# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #
    trace =  xtr::log_if  xtr::io_logging  0;		# Conditionally write strings to tracing.log or whatever.
herein


    package   outbuf_ximp
    : (weak)  Outbuf_Ximp				# Outbuf_Ximp				is from   src/lib/x-kit/xclient/src/wire/outbuf-ximp.api
    {
	Initialplea =   START_ON  Mailop(Void)
		    ;
	Initialport = Mailslot( Initialplea );

	Controlplea =   STOP
		    ;
	Controlport = Mailslot( Controlplea );



	Runtimeplea =   v1u::Vector
		    ;
	Runtimeport = Mailqueue( Runtimeplea );


	Ports	= { initialport: Initialport,
		    runtimeport: Runtimeport,
		    controlport: Controlport
		  };



        ##########################################################################################
	# External entrypoints
	#
	fun make_outbuf_ximp  (name: String)  (socket: sok::Socket (X, sok::Stream(sok::Active)))			# External entrypoint.
	    =
	    {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( Ports );
		#
		xlogger::make_thread  name  (start_initial_loop  reply_oneshot);

		get_from_oneshot  reply_oneshot;
	    }
	    where
		fun start_initial_loop (result_oneshot: Oneshot_Maildrop( Ports )) ()
		    =
		    {   parameters = ();
			#
			initial_loop  parameters;									# Will not return.
		    }
		    where
		        initialport =  make_mailslot  ():  Mailslot(  Initialplea );
			controlport =  make_mailslot  ():  Mailslot(  Controlplea );
			runtimeport =  make_mailqueue ():  Mailqueue( Runtimeplea );

			put_in_oneshot (result_oneshot, { initialport, controlport, runtimeport });

			fun initial_loop  parameters
			    =
			    {   fun do_initialplea  (START_ON  starting_gun')
				    =
				    {   block_until_mailop_fires  starting_gun';					# Wait for the starting gun.
					#
					initial_state = ();

					runtime_loop  initial_state;							# Will not return.
				    };

				do_initialplea  (take_from_mailslot  initialport);
			    }
			    where
				fun runtime_loop state
				    =
				    do_one_mailop [
					#
					(take_from_mailslot'  controlport ==> do_controlplea),

					(take_all_from_mailqueue' runtimeport ==> do_runtimeplea)
				    ]
				    where
					fun shut_down_outbuf_imp ()
					    =
					    {   sok::close socket;
						thread_exit { success => TRUE };					# Will not return.	
					    };


					fun do_controlplea  STOP
					    =
					    shut_down_outbuf_imp ();							# Will not return.	

					fun do_runtimeplea  []
						=>
						runtime_loop  state;

					    do_runtimeplea  [ vector: v1u::Vector ]
						=>
						{   skj::send_vector  (socket, vector);
						    #
						    runtime_loop  state;
						};

					    do_runtimeplea  vectors
						=>
						{   skj::send_vector  (socket,  (v1u::cat  vectors));
						    #
						    runtime_loop  state;
						};
					end;
				    end;

			    end;
		    end;
	    end;

	
	fun send_bytes (args as (mailqueue: Runtimeport,  vector: v1u::Vector))						# External entrypoint.
	    =	
	    put_in_mailqueue args;

	package initial {
	    #
	    fun start_on  (mailslot: Initialport,   starting_gun': Mailop(Void))						# External entrypoint.
		=
		put_in_mailslot  (mailslot,  START_ON starting_gun');
	};

	package control {
	    #
	    fun stop  (mailslot: Controlport)										# External entrypoint.
		=
		put_in_mailslot  (mailslot,  STOP);
	};


    };						# package outbuf_ximp
end;

#	fun out_msg_to_string FLUSH_OUTBUF
#		=>
#		"OutFlush";
#
#	    out_msg_to_string SHUT_DOWN_OUTBUF
#		=>
#		"OutQuit";
#
#	    out_msg_to_string (ADD_TO_OUTBUF v)
#		=>
#		{   prefix_to_show
#			=
#			byte::unpack_string_vector
#			    (vector_slice_of_one_byte_unts::make_slice
#				(v, 0, max_chars_to_trace_per_send)
#			    );
#
#		    case max_chars_to_trace_per_send
#			#
#			THE n =>    cat [ "Sent to X server: ",   string_to_hex    prefix_to_show,
#					  "... == \"",            string_to_ascii  prefix_to_show,
#					  "\"... (", int::to_string (v1u::length v), " bytes)"
#					];
#
#			NULL =>    cat [ "Sent to X server: ",   string_to_hex prefix_to_show,
#					  " == \"",               string_to_ascii  prefix_to_show,
#					  "\"  (", int::to_string (v1u::length v), " bytes)"
#					];
#		    esac;
#		};	
#	end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
