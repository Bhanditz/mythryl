## xclient-unit-test.pkg
#
# NB: We must compile this locally via
#         xclient-internals.sublib
#     instead of globally via
#         src/lib/test/unit-tests.lib
#     like most unit tests, in order to have
#     access to required library internals.

# Compiled by:
#     src/lib/x-kit/xclient/xclient.sublib


# Run by:
#     src/lib/test/all-unit-tests.pkg

stipulate
    include unit_test;						# unit_test				is from   src/lib/src/unit-test.pkg
    include makelib::scripting_globals;
    include threadkit;						# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package fil =  file__premicrothread;			# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
    package mps =  microthread_preemptive_scheduler;		# microthread_preemptive_scheduler	is from   src/lib/src/lib/thread-kit/src/core-thread-kit/microthread-preemptive-scheduler.pkg
#   package tsc =  thread_scheduler_control;			# thread_scheduler_control		is from   src/lib/src/lib/thread-kit/src/posix/thread-scheduler-control.pkg
    package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
    package tr  =  logger;					# logger				is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
    package xtr =  xlogger;					# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    package sox =  socket_junk;					# socket_junk				is from   src/lib/internet/socket-junk.pkg
    package xj  =  xsession_junk;				# xsession_junk				is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package dy  =  display;					# display				is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package kp  =  keymap_port;					# keymap_port				is from   src/lib/x-kit/xclient/src/window/keymap-port.pkg
    package sp  =  xserver_port;				# xserver_port				is from   src/lib/x-kit/xclient/src/wire/xserver-port.pkg
    package sep =  selection_port;				# selection_port			is from   src/lib/x-kit/xclient/src/window/selection-port.pkg
    package wpp =  window_property_port;			# window_property_port			is from   src/lib/x-kit/xclient/src/window/window-property-port.pkg
    package ap  =  atom_port;					# atom_port				is from   src/lib/x-kit/xclient/src/iccc/atom-port.pkg
    package sj  =  socket_junk;					# socket_junk				is from   src/lib/internet/socket-junk.pkg
    package fti =  font_index;					# font_index				is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
    package s2p =  xevent_to_window_port;			# xevent_to_window_port			is from   src/lib/x-kit/xclient/src/window/xevent-to-window-port.pkg
    package xt  =  xtypes;					# xtypes				is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package au  =  authentication;				# authentication			is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package v2w =  value_to_wire;				# value_to_wire				is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package wi  =  window;					# window				is from   src/lib/x-kit/xclient/src/window/window.pkg
    package qk = quark;						# quark					is from   src/lib/x-kit/style/quark.pkg
    package xg  =  xgeometry;					# xgeometry				is from   src/lib/std/2d/xgeometry.pkg
    package hsv =  hue_saturation_value;			# hue_saturation_value			is from   src/lib/x-kit/xclient/src/color/hue-saturation-value.pkg
    package rpx =  ro_pixmap_ximp;				# ro_pixmap_ximp			is from   src/lib/x-kit/widget/lib/ro-pixmap-ximp.pkg
    package imx =  image_ximp;					# image_ximp				is from   src/lib/x-kit/widget/lib/image-ximp.pkg
    package shx =  shade_ximp;					# shade_ximp				is from   src/lib/x-kit/widget/lib/shade-ximp.pkg
    #
    tracefile   =  "xclient-unit-test.trace.log";
herein

    package xclient_unit_test {
	#
	name = "src/lib/x-kit/xclient/src/stuff/xclient-unit-test.pkg";

	trace =  xtr::log_if  xtr::io_logging 0;		# Conditionally write strings to tracing.log or whatever.

	default_time_quantum					# Copied from src/lib/x-kit/widget/lib/run-in-x-window-old.pkg
	    =
	    time::from_milliseconds 20;



	fun print_xauthentication  (xauthentication:  Null_Or(xt::Xauthentication))
	    =
	    case xauthentication
		#
		NULL => printf "make_root_window()/CCC xauthentication NULL   -- run-in-x-window.pkg\n";
		#
		THE (xt::XAUTHENTICATION
			  {
			    family:   Int,
			    address:  String,
			    display:  String,
			    name:     String,
			    data:     vector_of_one_byte_unts::Vector
			  })
		    => printf "make_root_window()/CCC xauthentication THE XAUTHENTICATION { family %d, address %s, display %s, name %s, data (...) }  -- run-in-x-window.pkg\n" family address display name;
	    esac; 


	fun exercise_window_stuff  ()
	    =
	    {
		(au::get_xdisplay_string_and_xauthentication  NULL)
		    ->
		    ( display_name:     String,						# Typically from $DISPLAY environment variable.
		      xauthentication:  Null_Or(xt::Xauthentication)			# Typically from ~/.Xauthority
		    );

		print_xauthentication  xauthentication;


#		trace .{ sprintf "xclient_unit_test: DISPLAY variable is set to '%s'" display_name; };

		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		xsession =  xj::open_xsession (run_gun', end_gun', display_name, xauthentication);

		xsession -> xj::XSESSION  { xdisplay:			dy::Xdisplay,          				#  
					    screens:			List( xj::Screen_Info ),

					    default_screen_info:   	xj::Screen_Info,

					    xevent_to_window_port:	s2p::Xevent_To_Window_Port,			# Feeds X events to appropriate toplevel window.

					    font_index:          	fti::Font_Index,
					    atom_port:          	ap::Atom_Port,

					    window_property_port:	wpp::Window_Property_Port,
					    selection_port:     	sep::Selection_Port,

					    xserver_port:		sp::Xserver_Port,
					    keymap_port:		kp::Keymap_Port
					  };

		xdisplay -> dy::XDISPLAY  { socket: 			sj::Stream_Socket(Int),				# Actual unix socket fd, wrapped up a bit. The 'Int' part is bogus -- I don't get what Reppy was trying to do with that phantom type.
					    #
					    name:			String,						# "host: display::screen" -- "foo.com:0.0" or such.
					    vendor:			String,						# Name of the server's vendor.

					    default_screen => default_screen_number:	Int,				# Number of the default screen.

					    screens => display_screens:	List( dy::Xscreen ),				# Screens attached to this display. 

					    pixmap_formats:		List( xt::Pixmap_Format ),
					    max_request_length:	Int,

					    image_byte_order:		xt::Order,
					    bitmap_bit_order:		xt::Order,

					    bitmap_scanline_unit:	xt::Raw_Format,
					    bitmap_scanline_pad:	xt::Raw_Format,

					    min_keycode:		xt::Keycode,
					    max_keycode:		xt::Keycode,

					    next_xid:			Void -> xt::Xid					# resource id allocator. Implemented below by spawn_xid_factory_thread()    from   src/lib/x-kit/xclient/src/wire/display-old.pkg
					  };
			
		default_screen =   xj::default_screen_of  xsession;

		assert (list::length         screens  >  0);
		assert (list::length display_screens  >  0);

printf "exercise_window_stuff doing make_image_ximp stuff   -- xclient-unit-test\n";

printf "exercise_window_stuff list::length         screens d=%d   -- xclient-unit-test\n" (list::length         screens);
printf "exercise_window_stuff list::length display_screens d=%d   -- xclient-unit-test\n" (list::length display_screens);
		(imx::make_image_ximp_state ()		  ) ->   image_ximp_state;
		(imx::make_image_ximp "image"		  ) ->  (image_ximp_configstate, image_ximp_exports);

printf "exercise_window_stuff doing make_ro_pixmap_ximp stuff   -- xclient-unit-test\n";
		(rpx::make_ro_pixmap_ximp_state ()	  ) ->   ro_pixmap_ximp_state;
		(rpx::make_ro_pixmap_ximp "ro_pixmap"	  ) ->  (ro_pixmap_ximp_configstate, ro_pixmap_ximp_exports);

printf "exercise_window_stuff doing make_shade_ximp stuff   -- xclient-unit-test\n";
		(shx::make_shade_ximp_state ()		  ) ->   shade_ximp_state;
		(shx::make_shade_ximp "shade"		  ) ->  (shade_ximp_configstate, shade_ximp_exports);

printf "exercise_window_stuff doing post-make_shade_ximp stuff   -- xclient-unit-test\n";
		image_port	=            image_ximp_exports.image_port;
		ro_pixmap_port	=        ro_pixmap_ximp_exports.ro_pixmap_port;
		shade_port	=            shade_ximp_exports.shade_port;

		fun name_to_cs_pixmap (name: qk::Quark)
		    =
		    raise exception FAIL "name_to_cs_pixmap not yet implemented";   # xc::Cs_Pixmap_Old

		rpx::configure_ro_pixmap_ximp
		  (
		    ro_pixmap_ximp_configstate,
		    ro_pixmap_ximp_state,
		    {  },
		    run_gun',
		    end_gun',
		    default_screen,
		    name_to_cs_pixmap
		  );

		shx::configure_shade_ximp
		  (
		    shade_ximp_configstate,
		    shade_ximp_state,
		    {  },
		    run_gun',
		    end_gun',
		    default_screen
		  );



		screen =  list::nth  (display_screens, default_screen_number);

		screen -> dy::XSCREEN { root_window_id => parent_window_id, root_visual, black_rgb8, white_rgb8, ... };

		green_pixel =  rgb8::rgb8_green;

		background_pixel =  green_pixel;
		border_pixel     =  black_rgb8;

		window_id        =  next_xid ();

#		take_xevent'     =  xok::take_xevent'  xsocket;
#
#
#		fun do_xevent (e: event_types::x::Event)
#		    =
#                    ();
#
#		case root_visual
#		    #
#		    xt::VISUAL { visual_id, depth => 24, red_mask => 0uxFF0000, green_mask => 0ux00FF00, blue_mask => 0ux0000FF, ... }
#                        =>
#                        {   # Set up a null thread to read and discard
#			    # incoming X events, since the xsocket logic
#			    # will deadlock if we do not:
#			    #	
#			    make_thread "Discard all X events" .{
#				#
#				for (;;) {
#				    #
#				    do_one_mailop [
#					#
#					take_xevent' ==>  do_xevent
#				    ];
#				};
#			    };
#	
#			    # Create a new X-window with the given xid 
#			    #
#			    fun create_window   (xsocket: xok::Xsocket)
#				{
#				  window_id:    	xt::Window_Id,
#				  parent_window_id:	xt::Window_Id,
#				  visual_id:		xt::Visual_Id_Choice,
#				  #	
#				  io_class:		xt::Io_Class,
#				  depth:		Int,
#				  site:			xg::Window_Site,
#				  attributes:		List( xt::a::Window_Attribute )
#				}
#				=
#				xok::send_xrequest  xsocket  msg
#				where 
#				    msg =   v2w::encode_create_window
#					      {
#						window_id,
#						parent_window_id,
#						visual_id,
#						io_class,
#						depth,
#						site,
#						attributes
#					      };
#
#				end;
#
#			    create_window   xsocket
#			      {
#				window_id,
#				parent_window_id,
#				visual_id => xt::SAME_VISUAL_AS_PARENT,
#				#
#				depth => 24,
#				io_class  => xt::INPUT_OUTPUT,
#				#
#				site =>
#				    xg::WINDOW_SITE
#				      { upperleft    =>  xg::POINT { col=>100, row=>100 },
#					size         =>  xg::SIZE { wide=>400, high=>400 },
#					border_thickness =>  1
#				      },
#
#				attributes
#				    =>
#				    [ xt::a::BORDER_PIXEL     border_pixel,
#				      xt::a::BACKGROUND_PIXEL background_pixel,
#				      xt::a::EVENT_MASK       wi::standard_xevent_mask
#				    ]
#			      };
#
#			    xok::send_xrequest  xsocket  (v2w::encode_map_window { window_id });
#			    xok::flush_xsocket  xsocket;
#
#			    sleep_for  0.1;
#
# trace .{ sprintf "xclient_unit_test: Now  writing create_window_request to socket."; };
##			    sox::send_vector (socket, create_window_request);
# trace .{ sprintf "xclient_unit_test: Done writing create_window_request to socket."; };
#
#
# trace .{ sprintf "xclient_unit_test: Now  reading back header of reply for create_window request."; };
##			    header = sox::receive_vector (socket, 8);
# trace .{ sprintf "xclient_unit_test: Done reading back header of reply for create_window request."; };
#			};
#
#		    xt::VISUAL { visual_id, depth, red_mask, green_mask, blue_mask, ... }
#                        =>
#                        {   printf "\nxclient-unit-test.pkg: exercise_window_stuff:\n";
#                            printf "This code assumes root visual has depth=24 red_mask=0xff0000 green_mask=0x00ff00 blue_mask=0x0000ff\n";
#                            printf "but actually the  root visual has depth=%d red_mask=0x%06x green_mask=0x%06x blue_mask=0x%06x\n"  depth  (unt::to_int red_mask)  (unt::to_int green_mask)  (unt::to_int blue_mask);
#			    printf "Skipping these unit tests.\n";
#			    assert FALSE;	
#			};
#
#		    xt::NO_VISUAL_FOR_THIS_DEPTH int
#                        =>
#                        {   # This case should never happen.
#			    assert FALSE;
#			    print "root_visual is NO_VISUAL_FOR_THIS_DEPTH?!\n";
#			};
#		esac;



#		window
#		    =
#	            create_window
#	    :
#	    xok::Xsocket
#	    ->
#	     { id:      xt::Window_Id,
#	       parent:  xt::Window_Id,
#	       #
#	       in_only: Null_Or( Bool ),
#	       depth:   Int,
#	       visual:  Null_Or( xt::Visual_Id ),
#	       #
#	       geometry:    xg::Window_Site,
#	       attributes:  List( Xwin_Val )
#	     }
#	    ->
#	    Void;

		();
	    };

	fun run ()
	    =
	    {   # Remove any old version of the tracefile:
		#
		if (isfile tracefile)  
		    unlink tracefile;
		fi;


		printf "\nDoing %s:\n" name;   


		# Open tracelog file and
                # select tracing level:
		#
		{   include logger;				# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
		    #
		    set_logger_to  (fil::LOG_TO_FILE tracefile);
		    #
#		    enable fil::all_logging;			# Gross overkill.
#		    enable xtr::xkit_logging;			# Lesser overkill.
#		    enable xtr::io_logging;			# Saner yet.	
		};

		assert  (tsr::thread_scheduler_is_running ());

		exercise_window_stuff  ();

		{
#		    xdisplay =  dy::open_xdisplay { display_name, xauthentication };	# Raises dy::XSERVER_CONNECT_ERROR on failure.

#		    trace .{ sprintf "xclient_unit_test: Done calling dy::open_xdisplay"; };


#		    do_it (make_root_window NULL);

#		    dy::close_xdisplay  xdisplay;

		} except
		    dy::XSERVER_CONNECT_ERROR string
			=
			{   fprintf fil::stderr "xclient_unit_test: Could not connect to X server: %s\n" string;
			    fprintf fil::stderr "xclient_unit_test: *** OMITTING XCLIENT UNIT TESTS. ***\n";

			    trace .{ sprintf "xclient_unit_test: Could not connect to X server: %s" string; };
			    trace .{         "xclient_unit_test: *** OMITTING XCLIENT UNIT TESTS. ***";     };

			    assert FALSE;
			};

		trace .{ sprintf "xclient-unit-test.pkg: Now  calling tsc::shut_down_thread_scheduler"; };



		assert TRUE;

		summarize_unit_tests  name;
	    };
    };

end;
