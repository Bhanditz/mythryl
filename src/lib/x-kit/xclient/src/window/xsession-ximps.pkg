## xsession-ximps.pkg
#
# For the big picture see the imp dataflow diagram in
#
#     src/lib/x-kit/xclient/src/window/xsession.pkg
#
# xsession-ximps wraps up the ximps
#
#    inbuf_ximp;						# inbuf_ximp					is from   src/lib/x-kit/xclient/src/wire/inbuf-ximp.pkg
#    outbuf_ximp;						# outbuf_ximp					is from   src/lib/x-kit/xclient/src/wire/outbuf-ximp.pkg
#    sequencer_ximp;						# sequencer_ximp				is from   src/lib/x-kit/xclient/src/wire/sequencer-ximp.pkg
#    decode_xpackets_ximp;					# decode_xpackets_ximp				is from   src/lib/x-kit/xclient/src/wire/decode-xpackets-ximp.pkg
#
# to look like a single logical ximp to the rest of
# the system.

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib





stipulate
    include threadkit;						# threadkit					is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    #
    package un  =  unt;						# unt						is from   src/lib/std/unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package w2v =  wire_to_value;				# wire_to_value					is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package xg  =  xgeometry;					# xgeometry					is from   src/lib/std/2d/xgeometry.pkg
    package xtr =  xlogger;					# xlogger					is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package sok =  socket__premicrothread;			# socket__premicrothread			is from   src/lib/std/socket--premicrothread.pkg

    package op  =  outbuf_port;					# outbuf_port					is from   src/lib/x-kit/xclient/src/wire/outbuf-port.pkg
    package xew =  xerror_well;					# xerror_well					is from   src/lib/x-kit/xclient/src/wire/xerror-well.pkg
    package sp  =  sequencer_port;				# sequencer_port				is from   src/lib/x-kit/xclient/src/wire/sequencer-port.pkg
    package xwp =  xevent_to_window_port;			# xevent_to_window_port				is from   src/lib/x-kit/xclient/src/window/xevent-to-window-port.pkg
    package xes =  xevent_sink;					# xevent_sink					is from   src/lib/x-kit/xclient/src/wire/xevent-sink.pkg
    package xt  =  xtypes;					# xtypes					is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package et  =  event_types;					# event_types					is from   src/lib/x-kit/xclient/src/wire/event-types.pkg

    package ix  =  inbuf_ximp;					# inbuf_ximp					is from   src/lib/x-kit/xclient/src/wire/inbuf-ximp.pkg
    package ox  =  outbuf_ximp;					# outbuf_ximp					is from   src/lib/x-kit/xclient/src/wire/outbuf-ximp.pkg
    package sx  =  sequencer_ximp;				# sequencer_ximp				is from   src/lib/x-kit/xclient/src/wire/sequencer-ximp.pkg
    package dxx =  decode_xpackets_ximp;			# decode_xpackets_ximp				is from   src/lib/x-kit/xclient/src/wire/decode-xpackets-ximp.pkg

    package fx  =  font_index;					# font_index					is from   src/lib/x-kit/xclient/src/window/font-index.pkg
    package kx  =  keymap_ximp;					# keymap_ximp					is from   src/lib/x-kit/xclient/src/window/keymap-ximp.pkg
    package kp  =  keymap_port;					# keymap_port					is from   src/lib/x-kit/xclient/src/window/keymap-port.pkg
    package xwx =  xevent_to_window_ximp;			# xevent_to_window_ximp				is from   src/lib/x-kit/xclient/src/window/xevent-to-window-ximp.pkg
    package sox =  xsocket_ximps;				# xsocket_ximps					is from   src/lib/x-kit/xclient/src/wire/xsocket-ximps.pkg
    package dy  =  display;					# display					is from   src/lib/x-kit/xclient/src/wire/display.pkg

    # These are purely temporary debug kludges to force these to compile:
    #
    Keymap_Ximp_Exports = keymap_ximp::Exports;			
    Xevent_To_Window_Ximp_Exports
        =
	xevent_to_window_ximp::Exports;				# xevent_to_window_ximp				is from   src/lib/x-kit/xclient/src/window/xevent-to-window-ximp.pkg
herein


    package   xsession_ximps
    :         Xsession_Ximps					# Xsession_Ximps				is from   src/lib/x-kit/xclient/src/wire/xsession-ximps.api
    {
	# Our state is just the collected
	# states of our sub-ximps:
	#
	Xsession_Ximps_State					# Opaque wrapper for all nonephemeral mutable state maintained by ximps.
	    =
	    { keymap_ximp_state:		kx::Keymap_Ximp_State,
	      xevent_to_window_ximp_state:	xwx::Xevent_To_Window_Ximp_State,
	      xsocket_ximps_state:		sox::Xsocket_Ximps_State
	    };

	Configstate(X)
	    =
	    { keymap_ximp_configstate:		  kx::Configstate,
	      xevent_to_window_ximp_configstate: xwx::Configstate,
	      xsocket_ximps_configstate:	 sox::Configstate(X),
	      #
	      keymap_ximp_exports:		kx::Exports,
	      xevent_to_window_ximp_exports:	xwx::Exports,
	      xsocket_ximps_exports:		sox::Exports
	    };

	Imports  =  {										# Ports we use, provided by other imps.
		      window_property_xevent_sink:		xes::Xevent_Sink,		# We'll forward X server PropertyNotify events to this sink.
		      selection_xevent_sink:		xes::Xevent_Sink		# We'll forward X server SelectionNotify, SelectionRequest and SelectionClear events to this sink.
		    };


	# We export two ports for use by external ximps,
	# who will send requests to them:
	#
	#  o Configstate for initial configuration.
	#  o sequencer_port for widget requests.
	#
	Exports    =  {										# Ports we provide for use by other imps.
			sequencer_port:		sp::Sequencer_Port,				# Requests from widget/application code.
		        xerror_well:		xew::Xerror_Well,				# Errors from the X server.
			keymap_port:		kp::Keymap_Port,				# Requests from widget/application code.
			xevent_to_window_port:	xwp::Xevent_To_Window_Port    			#
		      };




        ##########################################################################################
	# External entrypoints
	#
	fun make_xsession_ximps_state ()												# External entrypoint.
	    =
	    { keymap_ximp_state		  =>   kx::make_keymap_ximp_state (),
	      xevent_to_window_ximp_state =>  xwx::make_xevent_to_window_ximp_state (),
	      xsocket_ximps_state         =>  sox::make_xsocket_ximps_state ()
	    };

	#
	fun make_xsession_ximps  (name: String)											# External entrypoint.
	    =
	    {   ( kx::make_keymap_ximp			name) -> (          keymap_ximp_configstate,           keymap_ximp_exports);
		(xwx::make_xevent_to_window_ximp	name) -> (xevent_to_window_ximp_configstate, xevent_to_window_ximp_exports);
		(sox::make_xsocket_ximps		name) -> (        xsocket_ximps_configstate,         xsocket_ximps_exports);

		configstate = { keymap_ximp_configstate, xevent_to_window_ximp_configstate, xsocket_ximps_configstate,
				keymap_ximp_exports,     xevent_to_window_ximp_exports,     xsocket_ximps_exports
			      }; 

		keymap_port		=  keymap_ximp_exports.keymap_port;
		sequencer_port		=  xsocket_ximps_exports.sequencer_port;
		xerror_well		=  xsocket_ximps_exports.xerror_well;
		xevent_to_window_port	=  xevent_to_window_ximp_exports.xevent_to_window_port;

		(configstate, { sequencer_port, xerror_well, keymap_port, xevent_to_window_port });
	    };
	#
	#
	fun configure_xsession_ximps													# External entrypoint.
	      (
		cs:					Configstate(X),
		me:					Xsession_Ximps_State,

		{ window_property_xevent_sink:	xes::Xevent_Sink,								# We'll forward X server PropertyNotify events to this sink.
		  selection_xevent_sink:		xes::Xevent_Sink								# We'll forward X server SelectionNotify, SelectionRequest and SelectionClear events to this sink.
		}:					Imports,									# 

		run_gun':				Run_Gun,
		end_gun':				End_Gun,
	        display:				dy::Xdisplay,	
	        socket:					sok::Socket (X, sok::Stream(sok::Active))					# Socket to use.
	      )
	    =
	    {   sequencer_port	=  cs.xsocket_ximps_exports.sequencer_port;
		keymap_port	=  cs.keymap_ximp_exports.keymap_port;
		xevent_sink	=  cs.xevent_to_window_ximp_exports.xevent_sink;

		 #
		 kx::configure_keymap_ximp		(cs.keymap_ximp_configstate,		   me.keymap_ximp_state,		{  },				run_gun', end_gun', display);

		xwx::configure_xevent_to_window_ximp	(cs.xevent_to_window_ximp_configstate,	   me.xevent_to_window_ximp_state,	{ keymap_port,
																	  window_property_xevent_sink,
																	  selection_xevent_sink
																	},				run_gun', end_gun', display);

		sox::configure_xsocket_ximps		(cs.xsocket_ximps_configstate, 		   me.xsocket_ximps_state,		{ xevent_sink },	 	run_gun', end_gun', socket);
	    };
    };																	# package xsession_ximps
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
