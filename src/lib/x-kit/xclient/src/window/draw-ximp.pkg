## draw-ximp.pkg
#
#    ONCE THIS COMPILES, should clone it to produce zeroth-order versions of:
#
#        src/lib/x-kit/xclient/src/window/xevent-to-window-ximp.pkg
#        src/lib/x-kit/xclient/src/window/draw-ximp.pkg
#
# For the big picture see the imp dataflow diagram in
#
#     src/lib/x-kit/xclient/src/window/xsession.pkg
#
# The font is responsible for matching
# replies read from the X with requests sent
# to it.
#
# All requests to the X-server go through the font,
# as do all replies from the X-server.
#
# The font communicates on five fixed channels:
#
#   plea_mailslot       -- request messages from clients
#   from_x_mailslot     -- reply, error and event messages from the X server (via the input buffer)
#   to_x_mailslot       -- requests messages to the X server (via the output buffer)
#   xevent_mailslot     -- X-events to the X-event buffer (and thence to clients)
#   error_sink_mailslot -- errors to the error handler
#
# In addition, the font sends replies
# to clients on the reply channel that was
# bundled with the request.
#
# We maintain a pending-reply queue of requests sent
# to the X server for which replies are expected but
# not yet received.
#     We represent it using the usual two-list arrangement,
# writing new entries to the rear list while reading them
# from the front list; when the front list is empty we
# reverse the rear list and make it the new front list.

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib





stipulate
    include threadkit;						# threadkit					is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    #
    package un  =  unt;						# unt						is from   src/lib/std/unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package w2v =  wire_to_value;				# wire_to_value					is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package v2w =  value_to_wire;				# value_to_wire					is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package vu8 =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package xg  =  xgeometry;					# xgeometry					is from   src/lib/std/2d/xgeometry.pkg
    package xtr =  xlogger;					# xlogger					is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package xwp =  xevent_to_window_port;			# xevent_to_window_port				is from   src/lib/x-kit/xclient/src/window/xevent-to-window-port.pkg
    package pg  =  pen_guts;					# pen_guts					is from   src/lib/x-kit/xclient/src/window/pen-guts.pkg
    package dp  =  draw_port;					# draw_port					is from   src/lib/x-kit/xclient/src/wire/draw-port.pkg
    package pp  =  pen_port;					# pen_port					is from   src/lib/x-kit/xclient/src/window/pen-port.pkg
    package xps =  xpacket_sink;				# xpacket_sink					is from   src/lib/x-kit/xclient/src/wire/xpacket-sink.pkg
    package xt  =  xtypes;					# xtypes					is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package et  =  event_types;					# event_types					is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink				is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package xok =  xsocket;					# xsocket					is from   src/lib/x-kit/xclient/src/wire/xsocket.pkg

    #
    trace =  xtr::log_if  xtr::io_logging  0;			# Conditionally write strings to tracing.log or whatever.
herein


    package   draw_ximp
    : (weak)  Draw_Ximp						# Draw_Ximp					is from   src/lib/x-kit/xclient/src/wire/draw-ximp.api
    {

	# Client pleas to font:
	#
	package p {
	    #
	    Client_Plea						#
	    #
	    = DRAW_XOPS			(xt::Xid, pg::Pen, List( dp::x::Op ))
	    #
	    | DESTROY_WINDOW  xt::Window_Id
	    | DESTROY_PIXMAP  xt::Pixmap_Id
	    ;
	};



	Draw_Ximp_State				# Opaque wrapper for all nonephemeral mutable state maintained by ximp.
	    =
	    Void;

	Imports   = {										# Ports we use which are exported by other imps.
		      pen_port:			pp::Pen_Port,					#
		      xevent_to_window_port:	xwp::Xevent_To_Window_Port			# 
		    };

	Configstate = Mailslot( {  imports:	Imports,
				   me:		Draw_Ximp_State,
				   run_gun':	Run_Gun,
				   end_gun':	End_Gun,
				   socket:      xok::Xsocket
				 }
			      );

	Client_Q = Mailqueue( p::Client_Plea );

	Exports	  = {													# Ports we export for use by other imps.
		      window_map_event_sink:	wme::Window_Map_Event_Sink,						# Tells us when our window is un/mapped (hidden/revealed).
		      draw_port:		dp::Draw_Port								# Draw commands from widget/application code.
		    };



	
	fun run {													# These values will be statically globally visible throughout the code body for the imp.
		  me:					Draw_Ximp_State,						# State which is preserved across imp shutdown/restart cycles.
		  imports:				Imports,							# Ximps to which we send requests.
		  to:					Replyqueue,							# The name makes   foo::pass_something(imp) to .{ ... }   syntax read well.
		  end_gun':				End_Gun,							# We shut down the microthread when this fires.
		  client_q:				Client_Q,							# Requests from x-widgets and such via draw_imp, pen_imp or draw_imp.
		  socket:				xok::Xsocket
		}
	    =
	    loop ()
	    where
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                        ==>  shut_down_draw_imp'),
			    (take_from_mailqueue' client_q   ==>  do_clientplea)
			];

			loop ();
		    }	
		    where
			fun shut_down_draw_imp' ()
			    =
			    thread_exit { success => TRUE };								# Will not return.	
			#

			stipulate
			    fun send_draw_op (send_xrequest, send_xrequest_and_handle_exposures)
				=
				fn  (to, gc_id, _, dp::x::POLY_POINT (rel, points))
					=>
	    #			    send_xrequest (v2w::encode_poly_point { drawable=>to, gc_id, items=>points, relative=>rel } );	# Replaced by below code.
					{
					    # Discovered there's a limit to the number
					    # of points that can be sent to the X server.
					    # It's less than 65535, but at least 65400.
					    # I figure this is close enough:              -- Hue White 2011-11-24
					    #
					    x_limit = 65400;

					    send_xrequests points
					    where
						fun send_xrequests points
						    =
						    if (list::length(points) <= x_limit)
							#
							send_xrequest (v2w::encode_poly_point { drawable=>to, gc_id, items=>points, relative=>rel } );
						    else
							send_xrequest (v2w::encode_poly_point { drawable=>to, gc_id, items=>(list::take_n(points, x_limit)), relative=>rel } );
							send_xrequests (list::drop_n(points, x_limit));
						    fi;
					    end;
					};

				    (to, gc_id, _, dp::x::POLY_LINE (rel, points))
					=>
					send_xrequest (v2w::encode_poly_line { drawable=>to, gc_id, items=>points, relative=>rel } );

				    (to, gc_id, _, dp::x::POLY_SEG lines)
					=>
					send_xrequest (v2w::encode_poly_segment { drawable=>to, gc_id, items=>lines } );

				    (to, gc_id, _, dp::x::FILL_POLY (shape, rel, points))
					=>
	    #			    send_xrequest (v2w::encode_fill_poly { drawable=>to, gc_id, points, relative=>rel, shape } );
					{
					    msg = v2w::encode_fill_poly { drawable=>to, gc_id, points, relative=>rel, shape };

					    send_xrequest msg;
					};

				    (to, gc_id, _, dp::x::POLY_BOX boxes)
					=>
					send_xrequest (v2w::encode_poly_box { drawable=>to, gc_id, items=>boxes } );

				    (to, gc_id, _, dp::x::POLY_FILL_BOX boxes)
					=>
					send_xrequest (v2w::encode_poly_fill_box { drawable=>to, gc_id, items=>boxes } );

				    (to, gc_id, _, dp::x::POLY_ARC arcs)
					=>
					send_xrequest (v2w::encode_poly_arc { drawable=>to, gc_id, items=>arcs } );

				    (to, gc_id, _, dp::x::POLY_FILL_ARC arcs)
					=>
					send_xrequest (v2w::encode_poly_fill_arc { drawable=>to, gc_id, items=>arcs } );

				    (to, gc_id, _, dp::x::COPY_AREA (pt, from, box, sync_v))
					=>
					{   (xg::box::upperleft_and_size  box)
						->
						(p, size);

					    send_xrequest_and_handle_exposures (v2w::encode_copy_area { gc_id, from, to, from_point=>p, size, to_point=>pt }, sync_v);
					};

				    (to, gc_id, _, dp::x::COPY_PLANE (pt, from, box, plane, sync_v))
					=>
					{   (xg::box::upperleft_and_size  box)
						->
						(p, size);

					    send_xrequest_and_handle_exposures (v2w::encode_copy_plane { gc_id, from, to, from_point=>p, size, to_point=>pt, plane }, sync_v);
					};

				    (to, gc_id, _, dp::x::COPY_PMAREA (pt, from, box))
					=>
					{   (xg::box::upperleft_and_size  box)
						->
						(p, size);

					    send_xrequest (v2w::encode_copy_area { gc_id, from, to, from_point=>p, size, to_point=>pt });
					};

				    (to, gc_id, _, dp::x::COPY_PMPLANE (pt, from, box, plane))
					=>
					{   (xg::box::upperleft_and_size  box)
						->
						(p, size);

					    send_xrequest (v2w::encode_copy_plane { gc_id, from, to, from_point=>p, size, to_point=>pt, plane });
					};

				    (to, _, _, dp::x::CLEAR_AREA box)
					=>
					send_xrequest (v2w::encode_clear_area { window_id=>to, box, exposures => FALSE } );

				    (to, gc_id, _, dp::x::PUT_IMAGE im)
					=>
					send_xrequest
					    (v2w::encode_put_image
					      { drawable => to,
						gc_id,
						depth  => im.depth,
						to     => im.to_point,
						size   => im.size,
						lpad   => im.lpad,
						format => im.format,
						data   => im.data
					      }
					    );

				    (to, gc_id, cur_fid, dp::x::POLY_TEXT8 (fid, point, txt_items))
					=>
					{   last_fid
						=
						f (fid, txt_items)
						where
						    fun f (last_fid, [])                   =>  last_fid;
							f (last_fid, (dp::t::FONT id) ! r) =>  f (id, r);
							f (last_fid, _ ! r)                =>  f (last_fid, r);
						    end;
						end;

					    txt_items
						=
						last_fid == cur_fid
						?? txt_items
						:: txt_items @ [dp::t::FONT cur_fid];

					    txt_items
						=
						fid == cur_fid
						?? txt_items
						:: (dp::t::FONT fid) ! txt_items;


					    fun split_delta (0, l)
						    =>
						    l;

						split_delta (i, l)
						    =>
						    if (i < -128)

							 split_delta (i+128, -128 ! l);
						    else
							 i > 127
							 ?? split_delta (i - 127, 127 ! l)
							 :: i ! l;
						    fi;
					    end;


					    # Split a string into legal
					    # lengths for a PolyText8 command 
					    #
					    fun split_text ""
						    =>
						    [];

						split_text s
						    =>
						    {   n = string::length s;

							fun split (i, l)
							    =
							    n - i  > 254
							    ??  split (i+254,  substring (s, i, 254) ! l)
							    ::  list::reverse (substring (s, i, n-i) ! l);

							n > 254  ??  split (0, [])
								 ::  [s];
						    };
					    end;


					    fun split_item (dp::t::FONT id)
						    =>
						    [xt::FONT_ITEM id];

						split_item (dp::t::TEXT (delta, s))
						    =>
						    case (split_delta (delta, []), split_text s)
							#
							([], []) =>   [];
							([], sl) =>   (map (fn s = xt::TEXT_ITEM (0,  s)) sl);
							(dl, []) =>   (map (fn n = xt::TEXT_ITEM (n, "")) dl);

							([d], s ! sr)
							    =>
							    (xt::TEXT_ITEM (d, s) ! (map (fn s = xt::TEXT_ITEM (0, s)) sr));

							(d ! dr, s ! sr)
							    =>
							    ((map (fn n = xt::TEXT_ITEM (n, "")) dr)
							     @ (xt::TEXT_ITEM (d, s) ! (map (fn s = xt::TEXT_ITEM (0, s)) sr)));
						    esac;

					    end;

					    do_items
						=
						fold_backward
						    (fn (item, l) =  (split_item item) @ l)
						    [];

					    send_xrequest
						(v2w::encode_poly_text8
						    {
						      drawable=>to,
						      gc_id,
						      point,
						      items=>(do_items txt_items)
						    }
						);
					};

				    (to, gc_id, _, dp::x::IMAGE_TEXT8(_, point, string))
					=>
					send_xrequest (v2w::encode_image_text8 { drawable=>to, gc_id, point, string } );
				end;

			    fun do_draw_xops	(xid: xt::Xid, pen: pg::Pen, xops: List( dp::x::Op ))
				=
				{
				};

			    fun	do_destroy_window (wid: xt::Window_Id)
				=
				{
				};

			    fun	do_destroy_pixmap (pid: xt::Pixmap_Id)
				=
				{
				};

			herein
			    fun do_clientplea (p::DRAW_XOPS	  (arg as  (xid: xt::Xid,  pen: pg::Pen,  xops: List( dp::x::Op ))))	=>  do_draw_xops		arg;

				do_clientplea (p::DESTROY_WINDOW  (wid:  xt::Window_Id))						=>  do_destroy_window		wid;
				do_clientplea (p::DESTROY_PIXMAP  (pid:  xt::Pixmap_Id))						=>  do_destroy_pixmap		pid;
			    end;
			end;
		    end;												# fun loop
	    end;													# fun run
	
	fun startup   (reply_oneshot:  Oneshot_Maildrop( (Configstate, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   configstate     =  make_mailslot  ()	:  Configstate;
		#
		draw_port =   {
				draw_xops,
				destroy_window,
				destroy_pixmap
			      };
		window_map_event_sink =  { put_value };

		to             =  make_replyqueue();

		put_in_oneshot (reply_oneshot, (configstate, { draw_port, window_map_event_sink }));			# Return value from make_draw_ximp().

		(take_from_mailslot  configstate)									# Input args from configure_draw_imp().
		    ->
		    { me, imports, run_gun', end_gun', socket };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		graphics_expose_event_accumulator = REF NULL;

		run { me, client_q, imports, to, end_gun', socket };							# Will not return.
	    }
	    where
		client_q  =  make_mailqueue (get_current_microthread())	:  Client_Q;

		###################################################################################
		# window_map_event_sink
		#
		fun put_value (s: wme::s::Mapped_State) = ();

		###################################################################################
		# draw_port
		#
		fun draw_xops	(xid: xt::Xid) (pen: pg::Pen)  (xops: List( dp::x::Op ))
		    =
		    {
			put_in_mailqueue (client_q, p::DRAW_XOPS (xid, pen, xops));
		    };	

		#
		fun destroy_window		(wid: xt::Window_Id)
		    =
		    {
			put_in_mailqueue (client_q, p::DESTROY_WINDOW wid);
		    };	
		#
		fun destroy_pixmap		(pid: xt::Pixmap_Id)
		    =
		    {
			put_in_mailqueue (client_q, p::DESTROY_PIXMAP pid);
		    };	


	    end;

        ##########################################################################################
	# External entrypoints
	#
	fun make_draw_ximp_state ()											# External entrypoint.
	  =
	  ();

	#
	fun make_draw_ximp  (name: String)										# External entrypoint.
	    =
	    {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Configstate, Exports) );
		#
		xlogger::make_thread  name  (startup  reply_oneshot);							# Note that startup() is curried.

		get_from_oneshot  reply_oneshot;
	    };
	#
	#
	fun configure_draw_ximp												# External entrypoint.
	      (
		configstate:	Configstate,
		me:		Draw_Ximp_State,
		imports:	Imports,
		run_gun':	Run_Gun,
		end_gun':	End_Gun,
		socket:		xok::Xsocket
	      )
	    =
	    put_in_mailslot  (configstate, { me, imports, run_gun', end_gun', socket });

    };						# package draw_ximp
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
