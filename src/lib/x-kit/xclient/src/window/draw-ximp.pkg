## draw-ximp.pkg
#
#    ONCE THIS COMPILES, should clone it to produce zeroth-order versions of:
#
#        src/lib/x-kit/xclient/src/window/xevent-to-window-ximp.pkg
#        src/lib/x-kit/xclient/src/window/draw-ximp.pkg
#
# For the big picture see the imp dataflow diagram in
#
#     src/lib/x-kit/xclient/src/window/xsession.pkg
#
# The font is responsible for matching
# replies read from the X with requests sent
# to it.
#
# All requests to the X-server go through the font,
# as do all replies from the X-server.
#
# The font communicates on five fixed channels:
#
#   plea_mailslot       -- request messages from clients
#   from_x_mailslot     -- reply, error and event messages from the X server (via the input buffer)
#   to_x_mailslot       -- requests messages to the X server (via the output buffer)
#   xevent_mailslot     -- X-events to the X-event buffer (and thence to clients)
#   error_sink_mailslot -- errors to the error handler
#
# In addition, the font sends replies
# to clients on the reply channel that was
# bundled with the request.
#
# We maintain a pending-reply queue of requests sent
# to the X server for which replies are expected but
# not yet received.
#     We represent it using the usual two-list arrangement,
# writing new entries to the rear list while reading them
# from the front list; when the front list is empty we
# reverse the rear list and make it the new front list.

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib





stipulate
    include threadkit;						# threadkit					is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    #
    package un  =  unt;						# unt						is from   src/lib/std/unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package w2v =  wire_to_value;				# wire_to_value					is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package vu8 =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package xg  =  xgeometry;					# xgeometry					is from   src/lib/std/2d/xgeometry.pkg
    package xtr =  xlogger;					# xlogger					is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package xwp =  xevent_to_window_port;			# xevent_to_window_port				is from   src/lib/x-kit/xclient/src/window/xevent-to-window-port.pkg
    package pg  =  pen_guts;					# pen_guts					is from   src/lib/x-kit/xclient/src/window/pen-guts.pkg
    package dp  =  draw_port;					# draw_port					is from   src/lib/x-kit/xclient/src/wire/draw-port.api
    package pp  =  pen_port;					# pen_port					is from   src/lib/x-kit/xclient/src/window/pen-port.pkg
    package xps =  xpacket_sink;				# xpacket_sink					is from   src/lib/x-kit/xclient/src/wire/xpacket-sink.pkg
    package xt  =  xtypes;					# xtypes					is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package et  =  event_types;					# event_types					is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink				is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package xok =  xsocket;					# xsocket					is from   src/lib/x-kit/xclient/src/wire/xsocket.pkg

    #
    trace =  xtr::log_if  xtr::io_logging  0;			# Conditionally write strings to tracing.log or whatever.
herein


    package   draw_ximp
    : (weak)  Draw_Ximp						# Draw_Ximp					is from   src/lib/x-kit/xclient/src/wire/draw-ximp.api
    {

	# Client pleas to font:
	#
	package p {
	    #
	    Client_Plea						#
	    #
	    = DRAW_POLYPOINT		(xt::Xid, pg::Pen, Bool, List( xg::Point ))
	    | DRAW_POLYLINE		(xt::Xid, pg::Pen, Bool, List( xg::Point ))
	    | DRAW_FILLED_POLYGON	(xt::Xid, pg::Pen, xt::Shape, Bool, List( xg::Point ))
	    | DRAW_POLY_SEG		(xt::Xid, pg::Pen, List( xg::Line ))
	    | DRAW_POLY_BOX		(xt::Xid, pg::Pen, List( xg::Box  ))
	    | DRAW_POLY_FILLED_BOX	(xt::Xid, pg::Pen, List( xg::Box  ))
	    | DRAW_POLY_ARC		(xt::Xid, pg::Pen, List( xg::Arc  ))
	    | DRAW_POLY_FILLED_ARC	(xt::Xid, pg::Pen, List( xg::Arc  ))
	    #
	    | DRAW_IMAGE_TEXT8		(xt::Xid, pg::Pen, xt::Font_Id, xg::Point, String)
	    | DRAW_POLY_TEXT8		(xt::Xid, pg::Pen, xt::Font_Id, xg::Point, List( dp::t::Poly_Text ))
	    #
	    | COPY_PMAREA		(xt::Xid, pg::Pen, xg::Point, xt::Xid, xg::Box)
	    | COPY_PMPLANE		(xt::Xid, pg::Pen, xg::Point, xt::Xid, xg::Box, Int)
	    #
	    | CLEAR_AREA		(xt::Xid, pg::Pen, xg::Box)
	    #
	    | PUT_IMAGE			(xt::Xid, pg::Pen, { to_point:  xg::Point,
							     size:      xg::Size,
							     depth:     Int,
							     lpad:      Int,
							     format:    xt::Image_Format,
							     data:      vu8::Vector
							   })
	    #
	    | COPY_AREA			(xt::Xid, pg::Pen,  xg::Point, xt::Xid, xg::Box, Oneshot_Maildrop( List( xg::Box )))

	    | COPY_PLANE		(xt::Xid, pg::Pen,  xg::Point, xt::Xid, xg::Box, Int, Oneshot_Maildrop( List( xg::Box )))

	    #
	    | DESTROY_WINDOW  xt::Window_Id
	    | DESTROY_PIXMAP  xt::Pixmap_Id
	    ;
	};



	Draw_Ximp_State				# Opaque wrapper for all nonephemeral mutable state maintained by ximp.
	    =
	    Void;

	Imports   = {										# Ports we use which are exported by other imps.
		      pen_port:			pp::Pen_Port,					#
		      xevent_to_window_port:	xwp::Xevent_To_Window_Port			# 
		    };

	Configstate = Mailslot( {  imports:	Imports,
				   me:		Draw_Ximp_State,
				   run_gun':	Run_Gun,
				   end_gun':	End_Gun,
				   socket:      xok::Xsocket
				 }
			      );

	Client_Q = Mailqueue( p::Client_Plea );

	Exports	  = {													# Ports we export for use by other imps.
		      window_map_event_sink:	wme::Window_Map_Event_Sink,						# Tells us when our window is un/mapped (hidden/revealed).
		      draw_port:		dp::Draw_Port								# Draw commands from widget/application code.
		    };



	
	fun run {													# These values will be statically globally visible throughout the code body for the imp.
		  me:					Draw_Ximp_State,						# State which is preserved across imp shutdown/restart cycles.
		  imports:				Imports,							# Ximps to which we send requests.
		  to:					Replyqueue,							# The name makes   foo::pass_something(imp) to .{ ... }   syntax read well.
		  end_gun':				End_Gun,							# We shut down the microthread when this fires.
		  client_q:				Client_Q,							# Requests from x-widgets and such via draw_imp, pen_imp or draw_imp.
		  socket:				xok::Xsocket
		}
	    =
	    loop ()
	    where
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                        ==>  shut_down_draw_imp'),
			    (take_from_mailqueue' client_q   ==>  do_clientplea)
			];

			loop ();
		    }	
		    where
			fun shut_down_draw_imp' ()
			    =
			    thread_exit { success => TRUE };								# Will not return.	
			#

			stipulate
			    fun do_draw_polypoint	(xid: xt::Xid, pen: pg::Pen, bool: Bool, points: List( xg::Point ))
				=
				{
				};

			    fun	do_draw_polyline	(xid: xt::Xid, pen: pg::Pen, bool: Bool, points: List( xg::Point ))
				=
				{
				};

			    fun	do_draw_filled_polygon	(xid: xt::Xid, pen: pg::Pen, shape: xt::Shape, bool: Bool, points: List( xg::Point ))
				=
				{
				};

			    fun	do_draw_poly_seg	(xid: xt::Xid, pen: pg::Pen, lines: List( xg::Line ))
				=
				{
				};

			    fun	do_draw_poly_box	(xid: xt::Xid, pen: pg::Pen, boxes: List( xg::Box  ))
				=
				{
				};

			    fun	do_draw_filled_box	(xid: xt::Xid, pen: pg::Pen, boxes: List( xg::Box  ))
				=
				{
				};

			    fun	do_draw_poly_arc	(xid: xt::Xid, pen: pg::Pen, arcs: List( xg::Arc  ))
				=
				{
				};

			    fun	do_draw_poly_filled_arc	(xid: xt::Xid, pen: pg::Pen, arcs: List( xg::Arc  ))
				=
				{
				};

			    fun	do_draw_image_text8	(xid: xt::Xid, pen: pg::Pen, fontid: xt::Font_Id, point: xg::Point, string: String)
				=
				{
				};

			    fun	do_draw_poly_text8	(xid: xt::Xid, pen: pg::Pen, fontid: xt::Font_Id, point: xg::Point, texts: List( dp::t::Poly_Text ))
				=
				{
				};

			    fun	do_copy_pmarea		(xid: xt::Xid, pen: pg::Pen, point: xg::Point, xid2: xt::Xid, box: xg::Box)
				=
				{
				};

			    fun	do_copy_pmplane		(xid: xt::Xid, pen: pg::Pen, point: xg::Point, xid2: xt::Xid, box: xg::Box, i: Int)
				=
				{
				};

			    fun	do_clear_area		(xid: xt::Xid, pen: pg::Pen, box: xg::Box)
				=
				{
				};

			    fun	do_put_image (xid: xt::Xid, pen: pg::Pen,
					       { to_point:  xg::Point,
						 size:      xg::Size,
						 depth:     Int,
						 lpad:      Int,
						 format:    xt::Image_Format,
						 data:      vu8::Vector
					       })
				=
				{
				};

			    fun	do_copy_area  (xid: xt::Xid, pen: pg::Pen,  point: xg::Point, xid2: xt::Xid, box: xg::Box, reply_1shot: Oneshot_Maildrop( List( xg::Box )))
				=
				{
				};

			    fun	do_copy_plane (xid: xt::Xid, pen: pg::Pen, point: xg::Point, xid2: xt::Xid, box: xg::Box, i: Int, reply_1shot: Oneshot_Maildrop( List( xg::Box )))
				=
				{
				};

			    fun	do_destroy_window (wid: xt::Window_Id)
				=
				{
				};

			    fun	do_destroy_pixmap (pid: xt::Pixmap_Id)
				=
				{
				};

			herein
			    fun do_clientplea (p::DRAW_POLYPOINT	(arg as (xid: xt::Xid, pen: pg::Pen, bool: Bool, points: List( xg::Point ))))					=>  do_draw_polypoint		arg;
				do_clientplea (p::DRAW_POLYLINE		(arg as (xid: xt::Xid, pen: pg::Pen, bool: Bool, points: List( xg::Point ))))					=>  do_draw_polyline		arg;
				do_clientplea (p::DRAW_FILLED_POLYGON	(arg as (xid: xt::Xid, pen: pg::Pen, shape: xt::Shape, bool: Bool, points: List( xg::Point ))))			=>  do_draw_filled_polygon	arg;
				do_clientplea (p::DRAW_POLY_SEG		(arg as (xid: xt::Xid, pen: pg::Pen, lines: List( xg::Line ))))							=>  do_draw_poly_seg		arg;
				do_clientplea (p::DRAW_POLY_BOX		(arg as (xid: xt::Xid, pen: pg::Pen, boxes: List( xg::Box  ))))							=>  do_draw_poly_box		arg;
				do_clientplea (p::DRAW_POLY_FILLED_BOX	(arg as (xid: xt::Xid, pen: pg::Pen, boxes: List( xg::Box  ))))							=>  do_draw_filled_box		arg;
				do_clientplea (p::DRAW_POLY_ARC		(arg as (xid: xt::Xid, pen: pg::Pen, arcs: List( xg::Arc  ))))							=>  do_draw_poly_arc		arg;
				do_clientplea (p::DRAW_POLY_FILLED_ARC	(arg as (xid: xt::Xid, pen: pg::Pen, arcs: List( xg::Arc  ))))							=>  do_draw_poly_filled_arc	arg;
				do_clientplea (p::DRAW_IMAGE_TEXT8	(arg as (xid: xt::Xid, pen: pg::Pen, fontid: xt::Font_Id, point: xg::Point, string: String)))			=>  do_draw_image_text8		arg;
				do_clientplea (p::DRAW_POLY_TEXT8	(arg as (xid: xt::Xid, pen: pg::Pen, fontid: xt::Font_Id, point: xg::Point, texts: List( dp::t::Poly_Text ))))	=>  do_draw_poly_text8		arg;
				do_clientplea (p::COPY_PMAREA		(arg as (xid: xt::Xid, pen: pg::Pen, point: xg::Point, xid2: xt::Xid, box: xg::Box)))				=>  do_copy_pmarea		arg;
				do_clientplea (p::COPY_PMPLANE		(arg as (xid: xt::Xid, pen: pg::Pen, point: xg::Point, xid2: xt::Xid, box: xg::Box, i: Int)))			=>  do_copy_pmplane		arg;
				do_clientplea (p::CLEAR_AREA		(arg as (xid: xt::Xid, pen: pg::Pen, box: xg::Box)))								=>  do_clear_area		arg;

				do_clientplea (p::PUT_IMAGE (arg as (xid: xt::Xid, pen: pg::Pen,
									   { to_point:  xg::Point,
									     size:      xg::Size,
									     depth:     Int,
									     lpad:      Int,
									     format:    xt::Image_Format,
									     data:      vu8::Vector
									   })))														=>  do_put_image		arg;

				do_clientplea (p::COPY_AREA (arg as (xid: xt::Xid, pen: pg::Pen,  point: xg::Point, xid2: xt::Xid, box: xg::Box,
                                               reply_1shot: Oneshot_Maildrop( List( xg::Box )))))											=>  do_copy_area		arg;

				do_clientplea (p::COPY_PLANE (arg as (xid: xt::Xid, pen: pg::Pen, point: xg::Point, xid2: xt::Xid, box: xg::Box, i: Int,
						reply_1shot: Oneshot_Maildrop( List( xg::Box )))))											=>  do_copy_plane		arg;

				do_clientplea (p::DESTROY_WINDOW  (wid: xt::Window_Id))													=>  do_destroy_window		wid;
				do_clientplea (p::DESTROY_PIXMAP  (pid: xt::Pixmap_Id))													=>  do_destroy_pixmap		pid;
			    end;
			end;
		    end;												# fun loop
	    end;													# fun run
	
	fun startup   (reply_oneshot:  Oneshot_Maildrop( (Configstate, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   configstate     =  make_mailslot  ()	:  Configstate;
		#
		draw_port =   {
				draw_polypoint,
				draw_polyline,
				draw_filled_polygon,
				draw_poly_seg,
				draw_poly_box,
				draw_poly_filled_box,
				draw_poly_arc,
				draw_poly_filled_arc,
				draw_image_text8,
				draw_poly_text8,
				copy_pmarea,
				copy_pmplane,
				clear_area,
				put_image,
				copy_area_and_pass,
				copy_plane_and_pass,
				destroy_window,
				destroy_pixmap
			      };
		window_map_event_sink =  { put_value };

		to             =  make_replyqueue();

		put_in_oneshot (reply_oneshot, (configstate, { draw_port, window_map_event_sink }));			# Return value from make_draw_ximp().

		(take_from_mailslot  configstate)									# Input args from configure_draw_imp().
		    ->
		    { me, imports, run_gun', end_gun', socket };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		graphics_expose_event_accumulator = REF NULL;

		run { me, client_q, imports, to, end_gun', socket };							# Will not return.
	    }
	    where
		client_q  =  make_mailqueue (get_current_microthread())	:  Client_Q;

		###################################################################################
		# window_map_event_sink
		#
		fun put_value (s: wme::s::Mapped_State) = ();

		###################################################################################
		# draw_port
		#
		fun draw_polypoint		(xid: xt::Xid) (pen: pg::Pen)  (bool: Bool, points: List( xg::Point ))
		    =
		    {
			put_in_mailqueue (client_q, p::DRAW_POLYPOINT (xid, pen, bool, points));
		    };	

		#
		fun draw_polyline		(xid: xt::Xid) (pen: pg::Pen)  (bool: Bool, points: List( xg::Point ))
		    =
		    {
			put_in_mailqueue (client_q, p::DRAW_POLYLINE (xid, pen, bool, points));
		    };	

		#
		fun draw_filled_polygon		(xid: xt::Xid) (pen: pg::Pen)   (shape: xt::Shape, bool: Bool, points: List( xg::Point ))
		    =
		    {
			put_in_mailqueue (client_q, p::DRAW_FILLED_POLYGON (xid, pen, shape, bool, points));
		    };	

		#
		fun draw_poly_seg		(xid: xt::Xid) (pen: pg::Pen)   (lines: List( xg::Line ))
		    =
		    {
			put_in_mailqueue (client_q, p::DRAW_POLY_SEG (xid, pen, lines));
		    };	

		#
		fun draw_poly_box		(xid: xt::Xid) (pen: pg::Pen)   (boxes: List( xg::Box  ))
		    =
		    {
			put_in_mailqueue (client_q, p::DRAW_POLY_BOX (xid, pen, boxes));
		    };	

		#
		fun draw_poly_filled_box	(xid: xt::Xid) (pen: pg::Pen)   (boxes: List( xg::Box  ))
		    =
		    {
			put_in_mailqueue (client_q, p::DRAW_POLY_FILLED_BOX (xid, pen, boxes));
		    };	

		#
		fun draw_poly_arc		(xid: xt::Xid) (pen: pg::Pen)   (arcs: List( xg::Arc  ))
		    =
		    {
			put_in_mailqueue (client_q, p::DRAW_POLY_ARC (xid, pen, arcs));
		    };	

		#
		fun draw_poly_filled_arc	(xid: xt::Xid) (pen: pg::Pen)   (arcs: List( xg::Arc  ))
		    =
		    {
			put_in_mailqueue (client_q, p::DRAW_POLY_FILLED_ARC (xid, pen, arcs));
		    };	

		#
		fun draw_image_text8		(xid: xt::Xid) (pen: pg::Pen)
						( font_id:	xt::Font_Id,
						  point:	xg::Point,
						  string:	String
						)
		    =
		    {
			put_in_mailqueue (client_q, p::DRAW_IMAGE_TEXT8 (xid, pen, font_id, point, string));
		    };	

		#
		fun draw_poly_text8		(xid: xt::Xid) (pen: pg::Pen)
						( font_id:	xt::Font_Id,
						  point:	xg::Point,
						  polytexts:	List( dp::t::Poly_Text )
						)
		    =
		    {
			put_in_mailqueue (client_q, p::DRAW_POLY_TEXT8 (xid, pen, font_id, point, polytexts));
		    };	

		#
		fun copy_pmarea			(xid: xt::Xid) (pen: pg::Pen)
						( point:	xg::Point,
						  xid2:		xt::Xid,
						  box:		xg::Box
						)
		    =
		    {
			put_in_mailqueue (client_q, p::COPY_PMAREA (xid, pen, point, xid2, box));
		    };	

		#
		fun copy_pmplane		(xid: xt::Xid) (pen: pg::Pen)
						( point:	xg::Point,
						  xid2:		xt::Xid,
						  box:		xg::Box,
						  int:		Int
						)
		    =
		    {
			put_in_mailqueue (client_q, p::COPY_PMPLANE (xid, pen, point, xid2, box, int));
		    };	

		#
		fun clear_area			(xid: xt::Xid) (pen: pg::Pen)  (box: xg::Box)
		    =
		    {
			put_in_mailqueue (client_q, p::CLEAR_AREA (xid, pen, box));
		    };	

		#
		fun put_image			(xid: xt::Xid) (pen: pg::Pen)
						(arg as
						  { to_point:  xg::Point,
						    size:      xg::Size,
						    depth:     Int,
						    lpad:      Int,
						    format:    xt::Image_Format,
						    data:      vu8::Vector
						  }
						)
		    =
		    {
			put_in_mailqueue (client_q, p::PUT_IMAGE (xid, pen, arg));
		    };	

		#
		fun copy_area_and_pass		(xid: xt::Xid) (pen: pg::Pen)
						( point:	xg::Point,
						  xid2:		xt::Xid,
						  box:		xg::Box
						) 
						(replyqueue: Replyqueue)
						(reply_handler:	List( xg::Box ) -> Void)
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( List(xg::Box) );
			#
			put_in_mailqueue (client_q, p::COPY_AREA (xid, pen, point, xid2, box, reply_oneshot));

			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };	


		#
		fun copy_plane_and_pass		(xid: xt::Xid) (pen: pg::Pen)
						( point:	xg::Point,
						  xid2:		xt::Xid,
						  box:		xg::Box,
						  int:		Int
						)
						(replyqueue: Replyqueue)
						(reply_handler:  List( xg::Box ) -> Void)
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( List(xg::Box) );
			#
			put_in_mailqueue (client_q, p::COPY_PLANE (xid, pen, point, xid2, box, int, reply_oneshot));

			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };	

		#
		fun destroy_window		(wid: xt::Window_Id)
		    =
		    {
			put_in_mailqueue (client_q, p::DESTROY_WINDOW wid);
		    };	
		#
		fun destroy_pixmap		(pid: xt::Pixmap_Id)
		    =
		    {
			put_in_mailqueue (client_q, p::DESTROY_PIXMAP pid);
		    };	


	    end;

        ##########################################################################################
	# External entrypoints
	#
	fun make_draw_ximp_state ()											# External entrypoint.
	  =
	  ();

	#
	fun make_draw_ximp  (name: String)										# External entrypoint.
	    =
	    {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Configstate, Exports) );
		#
		xlogger::make_thread  name  (startup  reply_oneshot);							# Note that startup() is curried.

		get_from_oneshot  reply_oneshot;
	    };
	#
	#
	fun configure_draw_ximp												# External entrypoint.
	      (
		configstate:	Configstate,
		me:		Draw_Ximp_State,
		imports:	Imports,
		run_gun':	Run_Gun,
		end_gun':	End_Gun,
		socket:		xok::Xsocket
	      )
	    =
	    put_in_mailslot  (configstate, { me, imports, run_gun', end_gun', socket });

    };						# package draw_ximp
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
