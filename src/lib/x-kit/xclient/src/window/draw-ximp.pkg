## draw-ximp.pkg
#
#    ONCE THIS COMPILES, should clone it to produce zeroth-order versions of:
#
#        src/lib/x-kit/xclient/src/window/xevent-to-window-ximp.pkg
#        src/lib/x-kit/xclient/src/window/draw-ximp.pkg
#
# For the big picture see the imp dataflow diagram in
#
#     src/lib/x-kit/xclient/src/window/xsession.pkg
#
# The font is responsible for matching
# replies read from the X with requests sent
# to it.
#
# All requests to the X-server go through the font,
# as do all replies from the X-server.
#
# The font communicates on five fixed channels:
#
#   plea_mailslot       -- request messages from clients
#   from_x_mailslot     -- reply, error and event messages from the X server (via the input buffer)
#   to_x_mailslot       -- requests messages to the X server (via the output buffer)
#   xevent_mailslot     -- X-events to the X-event buffer (and thence to clients)
#   error_sink_mailslot -- errors to the error handler
#
# In addition, the font sends replies
# to clients on the reply channel that was
# bundled with the request.
#
# We maintain a pending-reply queue of requests sent
# to the X server for which replies are expected but
# not yet received.
#     We represent it using the usual two-list arrangement,
# writing new entries to the rear list while reading them
# from the front list; when the front list is empty we
# reverse the rear list and make it the new front list.

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib





stipulate
    include threadkit;						# threadkit					is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    #
    package un  =  unt;						# unt						is from   src/lib/std/unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package w2v =  wire_to_value;				# wire_to_value					is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package xg  =  xgeometry;					# xgeometry					is from   src/lib/std/2d/xgeometry.pkg
    package xtr =  xlogger;					# xlogger					is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package xwp =  xevent_to_window_port;			# xevent_to_window_port				is from   src/lib/x-kit/xclient/src/window/xevent-to-window-port.pkg
    package dp  =  draw_port;					# draw_port					is from   src/lib/x-kit/xclient/src/wire/draw-port.api
    package pp  =  pen_port;					# pen_port					is from   src/lib/x-kit/xclient/src/window/pen-port.pkg
    package xps =  xpacket_sink;				# xpacket_sink					is from   src/lib/x-kit/xclient/src/wire/xpacket-sink.pkg
    package xt  =  xtypes;					# xtypes					is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package et  =  event_types;					# event_types					is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink				is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package xok =  xsocket;					# xsocket					is from   src/lib/x-kit/xclient/src/wire/xsocket.pkg

    #
    trace =  xtr::log_if  xtr::io_logging  0;			# Conditionally write strings to tracing.log or whatever.
herein


    package   draw_ximp
    : (weak)  Draw_Ximp						# Draw_Ximp					is from   src/lib/x-kit/xclient/src/wire/draw-ximp.api
    {
	# Client pleas to font:
	#
	Client_Plea						#
	  = PLEA 
	  ;

	Draw_Ximp_State				# Opaque wrapper for all nonephemeral mutable state maintained by ximp.
	    =
	    Void;

	Imports   = {										# Ports we use which are exported by other imps.
		      pen_port:			pp::Pen_Port,					#
		      xevent_to_window_port:	xwp::Xevent_To_Window_Port			# 
		    };

	Configstate = Mailslot( {  imports:	Imports,
				   me:		Draw_Ximp_State,
				   run_gun':	Run_Gun,
				   end_gun':	End_Gun,
				   socket:      xok::Xsocket
				 }
			      );

	Client_Q = Mailqueue( Client_Plea );

	Exports	  = {										# Ports we export for use by other imps.
		      window_map_event_sink:	wme::Window_Map_Event_Sink,			# Tells us when our window is un/mapped (hidden/revealed).
		      draw_port:		dp::Draw_Port					# Draw commands from widget/application code.
		    };



	
	fun run {													# These values will be statically globally visible throughout the code body for the imp.
		  me:					Draw_Ximp_State,						# State which is preserved across imp shutdown/restart cycles.
		  imports:				Imports,							# Ximps to which we send requests.
		  to:					Replyqueue(Void),						# The name makes   foo::pass_something(imp) to .{ ... }   syntax read well.
		  end_gun':				End_Gun,							# We shut down the microthread when this fires.
		  client_q:				Client_Q,							# Requests from x-widgets and such via draw_imp, pen_imp or draw_imp.
		  socket:				xok::Xsocket
		}
	    =
	    loop ()
	    where
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                        ==>  shut_down_draw_imp'),
			    (take_from_mailqueue' client_q   ==>  do_clientplea)
			];

			loop ();
		    }	
		    where
			fun shut_down_draw_imp' ()
			    =
			    thread_exit { success => TRUE };								# Will not return.	
			#

			stipulate

			herein
			    fun do_clientplea (PLEA)
				    =
				    ();
			end;
		    end;												# fun loop
	    end;													# fun run
	
	fun startup   (reply_oneshot:  Oneshot_Maildrop( (Configstate, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   configstate     =  make_mailslot  ()	:  Configstate;
		#
		draw_port =  { 
			     };
		window_map_event_sink =  { put_value };

		to             =  make_replyqueue();

		put_in_oneshot (reply_oneshot, (configstate, { draw_port, window_map_event_sink }));			# Return value from make_draw_ximp().

		(take_from_mailslot  configstate)									# Input args from configure_draw_imp().
		    ->
		    { me, imports, run_gun', end_gun', socket };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		graphics_expose_event_accumulator = REF NULL;

		run { me, client_q, imports, to, end_gun', socket };							# Will not return.
	    }
	    where
		client_q  =  make_mailqueue (get_current_microthread())	:  Client_Q;

		fun put_value (s: wme::s::Mapped_State) = ();
	    end;

        ##########################################################################################
	# External entrypoints
	#
	fun make_draw_ximp_state ()											# External entrypoint.
	  =
	  ();

	#
	fun make_draw_ximp  (name: String)										# External entrypoint.
	    =
	    {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Configstate, Exports) );
		#
		xlogger::make_thread  name  (startup  reply_oneshot);							# Note that startup() is curried.

		get_from_oneshot  reply_oneshot;
	    };
	#
	#
	fun configure_draw_ximp												# External entrypoint.
	      (
		configstate:	Configstate,
		me:		Draw_Ximp_State,
		imports:	Imports,
		run_gun':	Run_Gun,
		end_gun':	End_Gun,
		socket:		xok::Xsocket
	      )
	    =
	    put_in_mailslot  (configstate, { me, imports, run_gun', end_gun', socket });

    };						# package draw_ximp
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
