## font-ximp.pkg
#
#    ONCE THIS COMPILES, should clone it to produce zeroth-order versions of:
#
#        src/lib/x-kit/xclient/src/window/xevent-to-window-ximp.pkg
#        src/lib/x-kit/xclient/src/window/keymap-ximp.pkg
#
# For the big picture see the imp dataflow diagram in
#
#     src/lib/x-kit/xclient/src/window/xsession.pkg
#
# The font is responsible for matching
# replies read from the X with requests sent
# to it.
#
# All requests to the X-server go through the font,
# as do all replies from the X-server.
#
# The font communicates on five fixed channels:
#
#   plea_mailslot       -- request messages from clients
#   from_x_mailslot     -- reply, error and event messages from the X server (via the input buffer)
#   to_x_mailslot       -- requests messages to the X server (via the output buffer)
#   xevent_mailslot     -- X-events to the X-event buffer (and thence to clients)
#   error_sink_mailslot -- errors to the error handler
#
# In addition, the font sends replies
# to clients on the reply channel that was
# bundled with the request.
#
# We maintain a pending-reply queue of requests sent
# to the X server for which replies are expected but
# not yet received.
#     We represent it using the usual two-list arrangement,
# writing new entries to the rear list while reading them
# from the front list; when the front list is empty we
# reverse the rear list and make it the new front list.

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib





stipulate
    include threadkit;						# threadkit					is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    #
    package vec =  rw_vector;					# rw_vector					is from   src/lib/std/src/rw-vector.pkg
    package dy  =  display;					# display					is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package un  =  unt;						# unt						is from   src/lib/std/unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire					is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package w2v =  wire_to_value;				# wire_to_value					is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package xg  =  xgeometry;					# xgeometry					is from   src/lib/std/2d/xgeometry.pkg
    package xtr =  xlogger;					# xlogger					is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package hs  =  hash_string;					# hash_string					is from   src/lib/src/hash-string.pkg
    package xok =  xsocket;					# xsocket					is from   src/lib/x-kit/xclient/src/wire/xsocket.pkg
    package op  =  outbuf_port;					# outbuf_port					is from   src/lib/x-kit/xclient/src/wire/outbuf-port.api
    package fb  =  font_base;					# font_base					is from   src/lib/x-kit/xclient/src/window/font-base.pkg
    package fp  =  font_port;					# font_port					is from   src/lib/x-kit/xclient/src/wire/font-port.api
    package xps =  xpacket_sink;				# xpacket_sink					is from   src/lib/x-kit/xclient/src/wire/xpacket-sink.pkg
    package xt  =  xtypes;					# xtypes					is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package et  =  event_types;					# event_types					is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package sp  =  sequencer_port;				# sequencer_port				is from   src/lib/x-kit/xclient/src/wire/sequencer-port.pkg

    #
    trace =  xtr::log_if  xtr::io_logging  0;			# Conditionally write strings to tracing.log or whatever.
herein


    package   font_ximp
    : (weak)  Font_Ximp						# Font_Ximp					is from   src/lib/x-kit/xclient/src/wire/font-ximp.api
    {
								# typelocked_hashtable_g			is from   src/lib/src/typelocked-hashtable-g.pkg

	# hashtables on font names:
	#
	package sht
	    =
	    typelocked_hashtable_g (

		Hash_Key = String;

		fun hash_value s
		    =
		    hs::hash_string s;

		fun same_key (s1:  String, s2:  String)
		    =
		    s1 == s2;
	    );



	# Client pleas to font-ximp:
	#
	Client_Plea
	  = PLEA_OPEN_FONT (String, Oneshot_Maildrop( Null_Or( fb::Font ) ))
	  ;



	Font_Ximp_State													# Opaque wrapper for all nonephemeral mutable state maintained by ximp.
	    =
	    {
	      font_map: 	sht::Hashtable( fb::Font )
	    };

	Imports   = { 													# Ports we use, provided by other imps.
		      sequencer_port:		sp::Sequencer_Port
		    };

	Configstate = Mailslot( {  imports:	Imports,
				   me:		Font_Ximp_State,
				   run_gun':	Run_Gun,
				   end_gun':	End_Gun,
				   display:     dy::Xdisplay
				 }
			      );

	Client_Q      = Mailqueue( Client_Plea );

	Exports	= { 													# Ports we provide for use by other imps.
		    font_port:	fp::Font_Port										# Requests from widget/application code.
		  };



	
	fun run {													# These values will be statically globally visible throughout the code body for the imp.
		  me:					Font_Ximp_State,						# State which is preserved across imp shutdown/restart cycles.
		  imports:				Imports,							# Ximps to which we send requests.
		  to:					Replyqueue,							# The name makes   foo::pass_something(imp) to .{ ... }   syntax read well.
		  end_gun':				End_Gun,							# We shut down the microthread when this fires.
		  client_q:				Client_Q,							# Requests from x-widgets and such via draw_imp, pen_imp or font_imp.
		  display:				dy::Xdisplay							# Extra state for handling sequences of x::GRAPHICS_EXPOSE events.
		}
	    =
	    loop ()
	    where
		display ->  dy::XDISPLAY { xsocket, next_xid, ... };
		#
	        send_xrequest_and_return_completion_mailop
                    =
                    imports.sequencer_port.send_xrequest_and_return_completion_mailop;

		insert     =  sht::set   me.font_map;
		find       =  sht::find  me.font_map;
		query_font =  xok::query_font  xsocket;

		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (take_from_mailqueue' client_q   ==>  do_client_plea)
			];

			loop ();
		    }	
		    where
			fun shut_down_font_imp' ()
			    =
			    thread_exit { success => TRUE };								# Will not return.	
			#

			fun make_font id
			    =
			    {   (query_font { font => id })
				    ->
				    { min_bounds, max_bounds,
				      min_char,   max_char,
				      default_char,
				      draw_dir,
				      all_chars_exist,
				      max_byte1,
				      font_ascent,
				      font_descent,
				      properties,
				      char_infos, ...
				    };

				fun in_range c
				    =
				    c >= min_char   and
				    c <= max_char;

				char_info
				    =
				    case char_infos
					#
					[] => if (in_range default_char)
						  #
						  fn _ =  min_bounds;
					      else
						  fn c =  in_range c  ??  min_bounds
								      ::  (raise exception fb::NO_CHAR_INFO);
					      fi;
					#
					l => {
						table = vec::from_list l;

						fun info_exists (xt::CHAR_INFO { char_width=>0, left_bearing=>0, right_bearing=>0, ... } )
							=>
							FALSE;

						    info_exists _
							=>
							TRUE;
						end;

						fun lookup c
						    =
						    if (in_range c)

							  case (vec::get (table, c - min_char))
							      #	
							      xt::CHAR_INFO { char_width=>0, left_bearing=>0, right_bearing=>0, ... }
								  =>
								  NULL;

							      per_compile_info
								  =>
								  THE per_compile_info;
							  esac;
						      else
							  NULL;
						      fi;

						fun get_info default c
						    =
						    if (in_range c)
							#
							case (lookup c)
							    #
							    THE c =>  c;
							    NULL  =>  default ();
							esac;
						    else
							default ();
						    fi;

						  case (lookup default_char)
						      #
						      NULL  => get_info (fn () =  raise exception fb::NO_CHAR_INFO);
						      THE c => get_info (fn () =  c);
						  esac;
					  };
				    esac;

				info = if (max_byte1 == 0)

					    fb::FINFO8
						{
						  min_bounds,
						  max_bounds,
						  min_char,
						  max_char,
						  default_char,
						  draw_dir,
						  all_chars_exist,
						  font_ascent,
						  font_descent,
						  properties,
						  char_info
						};
				      else
					   xgripe::impossible "[mkFont: 16-bit font]";
				      fi;

				  fb::FONT { id, xdpy => display, info };
			      };


			fun open_a_font name
			    =
			    font
			    where
				new_id = next_xid ();

				block_until_mailop_fires								# XXX BUGGO FIXME
				    (send_xrequest_and_return_completion_mailop
					 (v2w::encode_open_font { font => new_id, name } ));


				font = make_font  new_id;

				insert (name, font);
			    end;

			#
			fun do_client_plea (PLEA_OPEN_FONT (fontname, reply_oneshot))
			    =
			    {   result =    case (find fontname)
						#		  
						THE font =>   THE font;
						NULL     =>   THE (open_a_font fontname)
							      except
								  _ = NULL;
					    esac;

				put_in_oneshot (reply_oneshot, result);
			    };

		    end;												# fun loop
	    end;													# fun run
	
	fun startup   (reply_oneshot:  Oneshot_Maildrop( (Configstate, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   configstate =  make_mailslot  () :  Configstate;
		#
		font_port   =  { open_font, open_font_and_pass };

		to          =  make_replyqueue();

		put_in_oneshot (reply_oneshot, (configstate, { font_port }));						# Return value from make_font_ximp().

		(take_from_mailslot  configstate)									# Input args from configure_font_imp().
		    ->
		    { me, imports, run_gun', end_gun', display };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		run { me, client_q, imports, to, end_gun', display };							# Will not return.
	    }
	    where
		client_q  =  make_mailqueue (get_current_microthread())	:  Client_Q;

		#
		fun open_font (fontname: String)									# External entrypoint. inbuf-ximp calls this to pass us a packet from xserver.
		    =	
		    {   reply_oneshot = make_oneshot_maildrop ():  Oneshot_Maildrop( Null_Or( fb::Font ));
			#
			put_in_mailqueue  (client_q, (PLEA_OPEN_FONT (fontname, reply_oneshot)));

			get_from_oneshot  reply_oneshot;
		    };
		#
		fun open_font_and_pass 											# External entrypoint. inbuf-ximp calls this to pass us a packet from xserver.
			(fontname:	String)
			(replyqueue:	Replyqueue)
			(reply_handler: Null_Or(fb::Font) -> Void)
		    =	
		    {   reply_oneshot = make_oneshot_maildrop ():  Oneshot_Maildrop( Null_Or( fb::Font ));
			#
			put_in_mailqueue  (client_q, (PLEA_OPEN_FONT (fontname, reply_oneshot)));

			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };
	    end;

        ##########################################################################################
	# External entrypoints
	#
	fun make_font_ximp_state ()											# External entrypoint.
	    =
	    {
		font_map =  sht::make_hashtable  { size_hint => 32,  not_found_exception => FAIL "FontMap" }
			 :  sht::Hashtable( fb::Font );

		{ font_map };
	    };
	#
	fun make_font_ximp  (name: String)										# External entrypoint.
	    =
	    {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Configstate, Exports) );
		#
		xlogger::make_thread  name  (startup  reply_oneshot);							# Note that startup() is curried.

		get_from_oneshot  reply_oneshot;
	    };
	#
	#
	fun configure_font_ximp												# External entrypoint.
	      (
		configstate:	Configstate,
		me:		Font_Ximp_State,
		imports:	Imports,
		run_gun':	Run_Gun,
		end_gun':	End_Gun,
	        display:	dy::Xdisplay
	      )
	    =
	    put_in_mailslot  (configstate, { me, imports, run_gun', end_gun', display });

    };						# package font_ximp
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
