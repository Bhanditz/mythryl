## xclient-ximps-junk.pkg
#

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib





stipulate
    include threadkit;						# threadkit					is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    #
    package un  =  unt;						# unt						is from   src/lib/std/unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire					is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package w2v =  wire_to_value;				# wire_to_value					is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package xg  =  xgeometry;					# xgeometry					is from   src/lib/std/2d/xgeometry.pkg
    package xtr =  xlogger;					# xlogger					is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    package wnx =  winix__premicrothread;			# winix__premicrothread				is from   src/lib/std/winix--premicrothread.pkg
    package v8s =  vector_slice_of_one_byte_unts;		# vector_slice_of_one_byte_unts			is from   src/lib/std/src/vector-slice-of-one-byte-unts.pkg
    package w8v =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg

    package sok =  socket__premicrothread;			# socket__premicrothread			is from   src/lib/std/socket--premicrothread.pkg

    package dns =  dns_host_lookup;				# dns_host_lookup				is from   src/lib/std/src/socket/dns-host-lookup.pkg
    package exp =  encode_xpackets_port;			# encode_xpackets_port				is from   src/lib/x-kit/xclient/src/window/encode-xpackets-port.pkg
    package exx =  encode_xpackets_ximp;			# encode_xpackets_ximp				is from   src/lib/x-kit/xclient/src/window/encode-xpackets-ximp.pkg

    package kp  =  keymap_port;					# keymap_port					is from   src/lib/x-kit/xclient/src/window/keymap-port.pkg
    package pc  =  pen_cache;					# pen_cache					is from   src/lib/x-kit/xclient/src/window/pen-cache.pkg

    package sj  =  socket_junk;					# socket_junk					is from   src/lib/internet/socket-junk.pkg

    package op  =  outbuf_port;					# outbuf_port					is from   src/lib/x-kit/xclient/src/wire/outbuf-port.pkg
    package sp  =  sequencer_port;				# sequencer_port				is from   src/lib/x-kit/xclient/src/wire/sequencer-port.pkg
    package xes =  xevent_sink;					# xevent_sink					is from   src/lib/x-kit/xclient/src/wire/xevent-sink.pkg
    package xew =  xerror_well;					# xerror_well					is from   src/lib/x-kit/xclient/src/wire/xerror-well.pkg
    package xt  =  xtypes;					# xtypes					is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package et  =  event_types;					# event_types					is from   src/lib/x-kit/xclient/src/wire/event-types.pkg

    package ix  =  inbuf_ximp;					# inbuf_ximp					is from   src/lib/x-kit/xclient/src/wire/inbuf-ximp.pkg
    package ox  =  outbuf_ximp;					# outbuf_ximp					is from   src/lib/x-kit/xclient/src/wire/outbuf-ximp.pkg
    package sx  =  sequencer_ximp;				# sequencer_ximp				is from   src/lib/x-kit/xclient/src/wire/sequencer-ximp.pkg
    package dxx =  decode_xpackets_ximp;			# decode_xpackets_ximp				is from   src/lib/x-kit/xclient/src/wire/decode-xpackets-ximp.pkg
    package dy  =  display;					# display					is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package xdy =  xdisplay;					# xdisplay					is from   src/lib/x-kit/xclient/src/wire/xdisplay.pkg
    package cxa =  crack_xserver_address;			# crack_xserver_address				is from   src/lib/x-kit/xclient/src/wire/crack-xserver-address.pkg
    package uds =  unix_domain_socket__premicrothread;		# unix_domain_socket__premicrothread		is from   src/lib/std/src/socket/unix-domain-socket--premicrothread.pkg
    package is  =  internet_socket__premicrothread;		# internet_socket__premicrothread		is from   src/lib/std/src/socket/internet-socket--premicrothread.pkg

    package sox =  xsocket_ximps;				# xsocket_ximps					is from   src/lib/x-kit/xclient/src/wire/xsocket-ximps.pkg
    package sex =  xsession_ximps;				# xsession_ximps				is from   src/lib/x-kit/xclient/src/window/xsession-ximps.pkg
    package clx =  xclient_ximps;				# xclient_ximps					is from   src/lib/x-kit/xclient/src/window/xclient-ximps.pkg

    package aut =  authentication;				# authentication				is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg

    Dummy = xdy::Xdisplay;	# Temporary kludge to force xdisplay.pkg to compile.
herein


    package   xclient_ximps_junk
    :         Xclient_Ximps_Junk				# Xclient_Ximps_Junk				is from   src/lib/x-kit/xclient/src/wire/xclient-ximps-junk.api
    {
	Dummy = Int;


	# Handle initial handshake stuff with xserver via a
	# freshly opened unix- or internet-domain socket,
	# then build an xsocket threadset layer on top of it
	# (inbuf_imp, outbuf_imp, sequencer_imp, decode_xpackets_imp): 
	# 
	fun say_hello_to_xserver								# This fn copied from src/lib/x-kit/xclient/src/wire/display.pkg
	      { socket:				is::Stream_Socket(X),
		xauthentication:		Null_Or( xt::Xauthentication ),
		canonical_display_name:		String,
		screen:				Int
	      }
	    =
	    {

		connect_msg
		    =
		    v2w::encode_xserver_connection_request
		      {
			minor_version => 0,
			xauthentication
		      };


		sj::send_vector (socket, connect_msg);




												# exceptions			is from   src/lib/std/exceptions.pkg
												# large_unt			is from   src/lib/std/large-unt.pkg
												# pack_big_endian_unt16		is from   src/lib/std/src/pack-big-endian-unt16.pkg

		header = sj::receive_vector (socket, 8)
                         except
                             wnx::RUNTIME_EXCEPTION("closed socket", NULL)
                                 =
				 # I was getting this error when I failed to supply
				 # authentication -- you'd think the server would
				 # return a 0u2 "additional authentication required"
				 # reply, but apparently not.
                                 #
                                 # Anyhow, we can at least generate an error more
                                 # informative than "I/O to closed socket":      -- 2010-02-28 CrT
				 #
				 case xauthentication
				     #
                                     NULL => { msg = sprintf "X server %s closed connection without replying, perhaps because we supplied no authentication." canonical_display_name;  log::fatal .{ msg; };  raise exception FAIL msg; };
                                     _    => { msg = sprintf "X server %s closed connection without replying."                                                canonical_display_name;  log::fatal .{ msg; };  raise exception FAIL msg; };
                                 esac; 

		len = 4 * large_unt::to_int_x (pack_big_endian_unt16::get_vec (header, 3));	# "4 * ..." because X reports packet lengths in multiples of 32 bits.

		fun get_reply len
		    =
		    sj::receive_vector (socket, len);

		fun get_msg reply
		    =
		    byte::unpack_string_vector (
			v8s::make_slice(
			    reply,
			    0,
			    THE (one_byte_unt::to_int_x (w8v::get (header, 1)))
			)
		    );


		case (w8v::get (header, 0))
		    #
		    0u1 =>
			{
			    reply =  get_reply  len;

			    xserver_info = w2v::decode_connect_request_reply  (header, reply);

												# trace  .{ i2s::xserver_info_to_string  xserver_info; };

#			    xsocket =  xok::make_xsocket  socket;

			    { socket, xserver_info, canonical_display_name, screen };
			};

		    0u0 =>
			{   sok::close  socket;
			    msg = "X server refused connection: " + get_msg (get_reply len);
			    log::fatal .{ msg; };
			    raise exception FAIL msg;
			};

		    0u2 =>
			{   sok::close  socket;
			    msg = "X server demanded additional authentication";
			    log::fatal .{ msg; };
			    raise exception FAIL msg;
			};

		    x   =>
			{   sok::close  socket;
			    msg =  sprintf "X server returned unknown reply op %d" (one_byte_unt::to_int x);
			    log::fatal .{ msg; };
			    raise exception FAIL msg;
			};
		esac; 
	    };

	fun open_internet_domain_socket							# This fn copied from src/lib/x-kit/xclient/src/wire/display.pkg
	    (
	      address:  dns::Internet_Address,
	      port:     Int
	    )
	    =
	    {										# trace .{ sprintf "display.pkg: connect_to_xserver: open_internet_domain_socket: address = \"%s\", port d=%d" (dns::to_string  address) port; };

											# internet_socket__premicrothread	is from   src/lib/std/src/socket/internet-socket--premicrothread.pkg
		# Invoke the glibc socket() fn via
		# a few layers of wrapping:
		# 
		socket = internet_socket__premicrothread::tcp::make_socket ();

											# trace .{  sprintf "display.pkg: connect_to_xserver: open_internet_domain_socket: socket s='%s'"  (internet_socket__premicrothread::to_string  socket);  };

		sok::connect (socket, internet_socket__premicrothread::to_address (address, port))
		except
		    _ = {   msg = "Unable to connect to X server -- connect_to_xserver in src/lib/x-kit/xclient/src/window/xclient-ximps-junk.pkg";
			    log::fatal .{ msg; };					# Will not return.
			    raise exception FAIL msg;					# Cannot execute.
			};

		socket:		is::Stream_Socket(X);
	    };

	# Crack 'raw_display_name', open
        # a unix- or internet-domain
	# socket (as appropriate) and
	# do the initial handshake with
	# the X server:
	#
	fun connect_to_xserver									# This fn copied from src/lib/x-kit/xclient/src/wire/display.pkg
            ( raw_display_name: String,								# ":0.0" or "192.168.0.1:0.0" or such, often from unix DISPLAY environment variable.
              xauthentication:  Null_Or( xt::Xauthentication )					# Ultimately ~/.Xauthority
            )
	    =
	    {
		# Digest a user-level X server spec
		# into a form easier to work with:
		#
		(cxa::crack_xserver_address  raw_display_name)
		    ->
		    { address:                  cxa::Xserver_Address,
                      canonical_display_name:   String,
                      screen:	 	        Int
                    };

#												trace .{ sprintf "display.pkg: connect_to_xserver: address s='%s' screen d=%d canonical_display_name s='%s'" (cxa::to_string address) screen canonical_display_name; };



		case address
		    #
		    cxa::UNIX path
			=>
			{
			    socket =  uds::stream::make_socket ();
			    #
			    socket_address = uds::string_to_unix_domain_socket_address  path;

			    sok::connect (socket, socket_address)
			    except
				winix::RUNTIME_EXCEPTION (msg, _)
				    =
				    {   log::fatal .{ msg; };
					raise exception FAIL msg;
				    };

			    say_hello_to_xserver { socket, xauthentication, canonical_display_name, screen };
			};

		    cxa::INET_ADDRESS (host, port)
			=>
			case (dns::from_string  host)
			    #
			    THE address =>  {   socket = open_internet_domain_socket (address, port);
						say_hello_to_xserver { socket, xauthentication, canonical_display_name, screen };
					    };
			    NULL        =>  {   msg = "Bad IP address format";
						log::fatal .{ msg; };
						raise exception FAIL msg;
					    };
			esac;

		    cxa::INET_HOSTNAME (host, port)
			=>
			case (dns::get_by_name  host)
			    #
			    THE entry =>    {   socket = open_internet_domain_socket (dns::address entry, port);
						say_hello_to_xserver { socket, xauthentication, canonical_display_name, screen };
					    };
			    NULL      =>    {   msg = sprintf "Host '%s' not found" host;
						log::fatal .{ msg; };
						raise exception FAIL msg;
					    };
			esac;
		esac;
	    };				# fun connect_to_xserver

	fun make_root_window								# External entrypoint
                (display_or_null:  Null_Or( String ))					# Allow overriding of the DISPLAY environment variable setting.
	    =
	    {   (aut::get_xdisplay_string_and_xauthentication  display_or_null)
		    ->
		    ( raw_display_name:		String,					# Typically from $DISPLAY environment variable.
                      xauthentication:  Null_Or(xt::Xauthentication)			# Typically from ~/.Xauthority
                    );
		    
		(connect_to_xserver (raw_display_name, xauthentication))
		  ->
		  { socket:				is::Stream_Socket(X),
		    xserver_info:			xt::Xserver_Info,
		    canonical_display_name:		String,
		    screen:				Int
		  };

		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };


		(clx::make_xclient_ximps_state ()	  ) ->   xclient_ximps_state;
		(clx::make_xclient_ximps "xclient_ximps"  ) ->  (xclient_ximps_configstate, xclient_ximps_exports);

		window_property_xevent_sink =	{ put_value => 	(fn (event: et::x::Event) = ()) };	# Dummy to 'handle' X server PropertyNotify events.
		selection_xevent_sink	    =	{ put_value => 	(fn (event: et::x::Event) = ()) };	# Dummy to 'handle' X server SelectionNotify, SelectionRequest and SelectionClear events.

#		clx::configure_xclient_ximps
#		  ( xclient_ximps_configstate,
#		    xclient_ximps_state,
#		    { 
#		      window_property_xevent_sink:		xes::Xevent_Sink,		# We'll forward X server PropertyNotify events to this sink.
#		      selection_xevent_sink:			xes::Xevent_Sink		# We'll forward X server SelectionNotify, SelectionRequest and SelectionClear events to this sink.
#		    },
#		    run_gun',
#		    end_gun',
#		    dy::Xdisplay,	
#		    xt::Drawable_Id,
#		    socket 									# sok::Socket (X, sok::Stream(sok::Active))						# Socket to read.
#		  );




#		fire_run_gun ();
#		fire_end_gun ();

		();

#		wg::make_root_window (xdisplay, xauthentication)			# make_root_window is nominally from  src/lib/x-kit/widget/basic/widget.pkg   but actually from   src/lib/x-kit/widget/basic/root-window.pkg
#		except
#		    x as xclient::XSERVER_CONNECT_ERROR s
#			=
#			{   fil::write
#				( fil::stderr,
#				  string::cat
#				    [ "run_in_x_window: unable to open display \"",   xdisplay,   "\"\n",
#				      "  ",   s,   "\n"
#				    ]
#				);
#
#			    raise exception x;	
##			    shut_down_thread_scheduler  winix::process::failure;	# No longer kosher since 6.3
#			};
	      };



# We will want this eventually, but we do not yet have
# a newworld Root_Window:
#
#	fun run_in_x_window  do_it
#	    =
#	    {
#		{   do_it (make_root_window NULL);
#		    #
#		    winix__premicrothread::process::success;
#		}
#		except
#		    _ = winix__premicrothread::process::failure;
#
#		();
#	    };

    };															# package xclient_ximps
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
