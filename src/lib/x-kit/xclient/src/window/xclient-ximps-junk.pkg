## xclient-ximps-junk.pkg
#

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib





stipulate
    include threadkit;						# threadkit					is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    #
    package un  =  unt;						# unt						is from   src/lib/std/unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire					is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package w2v =  wire_to_value;				# wire_to_value					is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package xg  =  xgeometry;					# xgeometry					is from   src/lib/std/2d/xgeometry.pkg
    package xtr =  xlogger;					# xlogger					is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    package wnx =  winix__premicrothread;			# winix__premicrothread				is from   src/lib/std/winix--premicrothread.pkg
    package v8s =  vector_slice_of_one_byte_unts;		# vector_slice_of_one_byte_unts			is from   src/lib/std/src/vector-slice-of-one-byte-unts.pkg
    package w8v =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg

    package sok =  socket__premicrothread;			# socket__premicrothread			is from   src/lib/std/socket--premicrothread.pkg

    package dns =  dns_host_lookup;				# dns_host_lookup				is from   src/lib/std/src/socket/dns-host-lookup.pkg
    package exp =  encode_xpackets_port;			# encode_xpackets_port				is from   src/lib/x-kit/xclient/src/window/encode-xpackets-port.pkg
    package exx =  encode_xpackets_ximp;			# encode_xpackets_ximp				is from   src/lib/x-kit/xclient/src/window/encode-xpackets-ximp.pkg

    package kp  =  keymap_port;					# keymap_port					is from   src/lib/x-kit/xclient/src/window/keymap-port.pkg
    package pc  =  pen_cache;					# pen_cache					is from   src/lib/x-kit/xclient/src/window/pen-cache.pkg

    package sj  =  socket_junk;					# socket_junk					is from   src/lib/internet/socket-junk.pkg

    package op  =  outbuf_port;					# outbuf_port					is from   src/lib/x-kit/xclient/src/wire/outbuf-port.pkg
    package sp  =  sequencer_port;				# sequencer_port				is from   src/lib/x-kit/xclient/src/wire/sequencer-port.pkg
    package xes =  xevent_sink;					# xevent_sink					is from   src/lib/x-kit/xclient/src/wire/xevent-sink.pkg
    package xew =  xerror_well;					# xerror_well					is from   src/lib/x-kit/xclient/src/wire/xerror-well.pkg
    package xt  =  xtypes;					# xtypes					is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package et  =  event_types;					# event_types					is from   src/lib/x-kit/xclient/src/wire/event-types.pkg

    package ix  =  inbuf_ximp;					# inbuf_ximp					is from   src/lib/x-kit/xclient/src/wire/inbuf-ximp.pkg
    package ox  =  outbuf_ximp;					# outbuf_ximp					is from   src/lib/x-kit/xclient/src/wire/outbuf-ximp.pkg
    package sx  =  sequencer_ximp;				# sequencer_ximp				is from   src/lib/x-kit/xclient/src/wire/sequencer-ximp.pkg
    package dxx =  decode_xpackets_ximp;			# decode_xpackets_ximp				is from   src/lib/x-kit/xclient/src/wire/decode-xpackets-ximp.pkg
    package dy  =  display;					# display					is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package xdy =  xdisplay;					# xdisplay					is from   src/lib/x-kit/xclient/src/wire/xdisplay.pkg
    package cxa =  crack_xserver_address;			# crack_xserver_address				is from   src/lib/x-kit/xclient/src/wire/crack-xserver-address.pkg
    package uds =  unix_domain_socket__premicrothread;		# unix_domain_socket__premicrothread		is from   src/lib/std/src/socket/unix-domain-socket--premicrothread.pkg
    package is  =  internet_socket__premicrothread;		# internet_socket__premicrothread		is from   src/lib/std/src/socket/internet-socket--premicrothread.pkg

    package sox =  xsocket_ximps;				# xsocket_ximps					is from   src/lib/x-kit/xclient/src/wire/xsocket-ximps.pkg
    package sex =  xsession_ximps;				# xsession_ximps				is from   src/lib/x-kit/xclient/src/window/xsession-ximps.pkg
    package clx =  xclient_ximps;				# xclient_ximps					is from   src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
    package exp =  encode_xpackets_port;			# encode_xpackets_port				is from   src/lib/x-kit/xclient/src/wire/encode-xpackets-port.pkg

    package aut =  authentication;				# authentication				is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package ax  =  atom_ximp;					# atom_ximp					is from   src/lib/x-kit/xclient/src/iccc/atom-ximp.pkg

    package wpx =  window_property_ximp;			# window_property_ximp				is from   src/lib/x-kit/xclient/src/window/window-property-ximp.pkg
    package sel =  selection_ximp;				# selection_ximp				is from   src/lib/x-kit/xclient/src/window/selection-ximp.pkg
    package sep =  selection_port;				# selection_port				is from   src/lib/x-kit/xclient/src/window/selection-port.pkg

    Dummy = xdy::Xdisplay;		# Temporary kludge to force xdisplay.pkg  to compile.
    Dummi = ax::Configstate;		# Temporary kludge to force atom-ximp.pkg to compile.
    Dummu = sel::Selection_Handle;	# Temporary kludge to force compilation.
    Dummo = sep::Selection_Port;	# Temporary kludge to force compilation.
herein


    package   xclient_ximps_junk
    :         Xclient_Ximps_Junk				# Xclient_Ximps_Junk				is from   src/lib/x-kit/xclient/src/wire/xclient-ximps-junk.api
    {
	Dummy = Int;


	Screen_Info
	    =
	    SCREEN_INFO
	      {
		xscreen:    			xdy::Xscreen,				# Xscreen	def in    src/lib/x-kit/xclient/src/wire/xdisplay.pkg
		per_depth_pen_and_draw_imps:	List( Screen_Pen_And_Draw_Imps ),	# The pen-to-gcontext and draw imps for the supported depths on this screen.
		rootwindow_pen_and_draw_imps:         Screen_Pen_And_Draw_Imps		# The pen-to-gcontext and draw imps for the root window on this screen.
	      }

	also
	Screen_Pen_And_Draw_Imps
	    =
	    # For each combination of visual and depth
	    # we allocate a pair of imps, one to draw,
	    # one to manage graphics contexts.  This
	    # is forced because X requires that each
	    # gc and pixmap be associated with a
	    # particular screen, visual and depth:
	    #
	    SCREEN_PEN_AND_DRAW_IMPS {							# The pen-to-gcontext imp and draw_imp
		#									# for a given depth, visual and screen.
		depth:			Int,
		pen_cache:		pc::Pen_Cache,					# The pen-cache         for this depth on this screen.
		encode_xpackets_port:	exp::Encode_Xpackets_Port			# Rootwindow encode-imp for this depth on this screen.
	    }

	also
	Screen										# A screen handle for users.
	    =
	    SCREEN  {
#		xsession:      Xsession,
		screen_info:   Screen_Info
	    };

	#
	fun make_screen_info (xscreen as xdy::XSCREEN { root_window_id, root_visual, visuals, ... } )		# Adapted from make_screen_info in   src/lib/x-kit/xclient/src/window/xsession.pkg
	    =
	    {
#		rootwindow_pen_and_draw_imps
#		    =
#		    make_screen_pen_and_draw_imps
#		      (
#			dy::depth_of_visual  root_visual,
#			p2g::make_pen_to_gcontext_imp  (xdisplay, root_window_id)
#		      );
#
#		per_depth_pen_and_draw_imps
#		    =
#		    make_pen_imps (visuals, [ rootwindow_pen_and_draw_imps ]);
#
#		per_depth_pen_and_draw_imps
#		    =
#		    make_pen_imps ( [ xt::NO_VISUAL_FOR_THIS_DEPTH 1 ],
#				    per_depth_pen_and_draw_imps
#				  );
#
#		SCREEN_INFO
#		  {
#		    xscreen,
#		    per_depth_pen_and_draw_imps,
#		    rootwindow_pen_and_draw_imps
#		  };
	    };
#	    where
#		fun make_screen_pen_and_draw_imps (depth, pen_imp)
#		    =
#		    {   drawimp_mappedstate_slot =  make_mailslot ();
#
#			make_thread  "send FIRST_EXPOSE"  .{   put_in_mailslot (drawimp_mappedstate_slot, di::s::FIRST_EXPOSE);   };
#
#			SCREEN_PEN_AND_DRAW_IMPS {
#			    depth,
#			    pen_imp,
#			    to_screen_drawimp
#				=>
#				di::make_draw_imp
#				  ( take_from_mailslot'  drawimp_mappedstate_slot,
#				    pen_imp,
#				    xsocket
#				  )
#			};
#		    };
#		#
#		fun make_pen_imps ([], l)
#			=>
#			l;
#
#		    make_pen_imps (vd ! r, l)
#			=>
#			{
#			    visual_depth =  dy::depth_of_visual  vd;
#
#			    #
#			    fun make_imps ()
#				=
#				{   pixmap_id = next_xid ();
#
#				    # Make a pixmap to serve as the
#				    # witness drawable for the GC server:
#				    #
#				    xok::send_xrequest xsocket
#				      ( value_to_wire::encode_create_pixmap
#					  { pixmap_id,
#					    drawable_id =>  root_window_id,
#					    size        =>  xg::SIZE { wide=>1, high=>1 },
#					    depth       =>  visual_depth
#					  }
#				      );
#
#				    make_screen_pen_and_draw_imps
#					(visual_depth, p2g::make_pen_to_gcontext_imp (xdisplay, pixmap_id));
#				};
#
#			    #
#			    fun get []
#				    =>
#				    make_imps() ! l;
#
#				get (SCREEN_PEN_AND_DRAW_IMPS { depth, ... } ! rest)
#				    =>
#				    depth == visual_depth
#				     ??  l
#				     ::  get rest;
#			    end;
#
#
#			    make_pen_imps (r, get l);
#			};
#		end;
#	    end;

	fun make_root_window								# External entrypoint
                (display_or_null:  Null_Or( String ))					# Allow overriding of the DISPLAY environment variable setting.
	    =
	    {	(aut::get_xdisplay_string_and_xauthentication  display_or_null)		# This is from Reppy's oldworld make_root_window in src/lib/x-kit/widget/lib/run-in-x-window.pkg
		    ->
		    ( display_name:		String,					# Typically from $DISPLAY environment variable.
                      xauthentication:  Null_Or(xt::Xauthentication)			# Typically from ~/.Xauthority
                    );
											# Here canonical sequence calls make_root_window in src/lib/x-kit/widget/basic/root-window.pkg
											# which			  calls open_xsession    in src/lib/x-kit/xclient/src/window/xsession.pkg
											# which                   calls open_xdisplay    in src/lib/x-kit/xclient/src/wire/display.pkg
		(xdy::open_xdisplay { display_name, xauthentication })
		    ->
		    (xdisplay as xdy::XDISPLAY { default_screen, screens, socket, next_xid, ... } );	# Canonical sequence has 'xsocket' not 'socket' here.

		
		default_screen =    list::nth (screens, default_screen)
				    except
					SUBSCRIPT = {   msg = "Bad default_screen value -- make_root_window in xclient-ximps-junk.pkg";
							log::fatal .{ msg; };		# Doesn't return.
							raise exception FAIL msg;	# Should never get here.
						    };

		default_screen ->   xdy::XSCREEN { root_window_id, ... };

		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		(clx::make_xclient_ximps_state ()	  ) ->   xclient_ximps_state;
		(clx::make_xclient_ximps "xclient_ximps"  ) ->  (xclient_ximps_configstate, xclient_ximps_exports);

		(ax::make_atom_ximp_state ()		  ) ->   atom_ximp_state;
		(ax::make_atom_ximp "atom_ximp"		  ) ->  (atom_ximp_configstate, atom_ximp_exports);

		(wpx::make_window_property_ximp_state ()  ) ->   window_property_ximp_state;
		(wpx::make_window_property_ximp "wpx"	  ) ->  (window_property_ximp_configstate, window_property_ximp_exports);

# TBD: atom_ximp configuration
# TBD: window_property_ximp configuration

		window_property_xevent_sink =	{ put_value => 	(fn (event: et::x::Event) = { log::fatal .{ "window_property_xevent_sink called"; }; (); }) };	# Dummy to 'handle' X server PropertyNotify events.
		selection_xevent_sink	    =	{ put_value => 	(fn (event: et::x::Event) = { log::fatal .{ "selection_xevent_sink called"	; }; (); }) };	# Dummy to 'handle' X server SelectionNotify, SelectionRequest and SelectionClear events.

		clx::configure_xclient_ximps
		  (
		    xclient_ximps_configstate,
		    xclient_ximps_state,
		    { 
		      window_property_xevent_sink,
		      selection_xevent_sink
		    },
		    run_gun',
		    end_gun',
		    xdisplay,	
		    root_window_id,
		    socket 								# sok::Socket (X, sok::Stream(sok::Active))						# Socket to read.
		  );




#		xlg::make_thread  "err_handler"  err_handler;

											# Canonical sequence is now back in open_xsession in src/lib/x-kit/xclient/src/window/xsession.pkg

#		atom_imp   =   ai::make_atom_imp    xdisplay;
#		(wpi::make_window_property_imp (xdisplay, atom_imp)) -> (to_window_property_imp_slot, window_property_imp);
#		(si::make_selection_imp  xdisplay)		     -> (to_selection_imp_slot,  selection_imp);
#		xsocket_to_topwindow_router = s2t::make_xsocket_to_topwindow_router { ... }

#		screens =  map  make_screen_info  screens;
#		xsession = XSESSION { ... }  
											# Canonical sequence is now back in make_root_window in  src/lib/x-kit/widget/basic/root-window.pkg
#		screen = xc::default_screen_of xsession;				# NB: xsession is part of 'screen':  	fun default_screen_of  (xsession as XSESSION { default_screen_info, ... } ) = SCREEN { xsession, screen_info => default_screen_info };

#		is =  ii::make_image_imp  init_images;
#		ts =  pxc::make_readonly_pixmap_cache  (screen,  ii::get_image  is);
#		shade_imp =  si::make_shade_imp  screen;

#		tilef = pxc::get_ro_pixmap ts;
#		make_thread "widget_id factory" .{  widget_id_loop 0;  };
#		ROOT_WINDOW
#		  { id => REF (), 
#		    screen, 
#		    style   =>  wy::empty_style { screen, tilef }, 
#		    make_tile  =>  tilef,
#		    make_shade =>  si::get_shades  shade_imp,
#		    next_widget_id =>  fn () =  take_from_mailslot  widget_id_slot	# Gets used (only) in widget::make_widget, in  src/lib/x-kit/widget/basic/widget.pkg
#		  };									# Canonical sequence now returns from make_root_window in src/lib/x-kit/widget/basic/root-window.pkg
#											# to make_root_window in src/lib/x-kit/widget/lib/run-in-x-window.pkg
#											# to run_in_x_window which passes the ROOT_WINDOW to user do_it() fn.  EOF! :-)





#		fire_run_gun ();
#		fire_end_gun ();

		();

#		wg::make_root_window (xdisplay, xauthentication)			# make_root_window is nominally from  src/lib/x-kit/widget/basic/widget.pkg   but actually from   src/lib/x-kit/widget/basic/root-window.pkg
#		except
#		    x as xclient::XSERVER_CONNECT_ERROR s
#			=
#			{   fil::write
#				( fil::stderr,
#				  string::cat
#				    [ "run_in_x_window: unable to open display \"",   xdisplay,   "\"\n",
#				      "  ",   s,   "\n"
#				    ]
#				);
#
#			    raise exception x;	
##			    shut_down_thread_scheduler  winix::process::failure;	# No longer kosher since 6.3
#			};
	      };



# We will want this eventually, but we do not yet have
# a newworld Root_Window:
#
#	fun run_in_x_window  do_it
#	    =
#	    {
#		{   do_it (make_root_window NULL);
#		    #
#		    winix__premicrothread::process::success;
#		}
#		except
#		    _ = winix__premicrothread::process::failure;
#
#		();
#	    };

    };															# package xclient_ximps
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
