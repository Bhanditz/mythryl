## xsession-junk.pkg
#
# This package has the highest-level responsibility for
# managing all the state and operations relating to
# communication with a given X server.
#
#
# Architecture
# ------------
#
# Nomenclature:  An 'imp' is a server microthread.
#                (Like a daemon but smaller!)
#
#                A 'imp' is an X-specific imp. 
#
# An xsocket  is built of four  imps.
# An xsession adds three more   imps to make seven imps total.
# An xclient  adds two   more   imps to make nine  imps total.
# An X application adds an unbounded number of additional widget imps.
#
# Adapting from the page 8 diagram in
#     http:://mythryl.org/pub/exene/1991-ml-workshop.pdf
# our dataflow network for xsession looks like:
#
#       ----------------------
#       |  X server process  |
#       ----------------------
#            ^          |
#            |          v
#   -------<network socket>------------- network and process boundary.
#            ^          |xpackets
#            |xpackets  v                                          ---           ---              ---
#  --------------- ---------------                                  .             .                .
#  | outbuf_imp  | | inbuf_imp   |                                  .             .                .
#  --------------- ---------------                                  .             .                .
#        ^             | xpackets                                   .             .                .
#        | xpackets    v                                            .             .                .
#  -------------------------------                                  .             .                .
#  |       sequencer_imp         |--> (error handler)               ... xsocket   .                .
#  -------------------------------                                  .   imps      .                .
#    ^           ^        ^     | xpackets                          .             .                .
#    |           |        |     v                                   .             ... xsession     .
#    |           |        |  -------------------------              .             .   imps         .
#    |           |        |  | decode_xpackets_imp   |              .             .                .
#    |           |        |  -------------------------              .             .                .
#    |           |        |     | xevents                          ---            .                .
#    v           |        |     v                                                 .                .
#  ------------- |        |  -------------------------    ---------------         .                .
#  | font_imp  | |        |  | xevent_to_window_imp  |--> | keymap_imp  |         .                .
#  ------------- |        |  -------------------------    ---------------         .                .
#    ^           |        |     | xevents  ^                    ^                 .                .... xclient
#    |           |        |     |          |                    |                 .                .    imps
#    |           |        |     |          |                    |                 .                .
#    |           |        |     |          |                    |                ---               .
#    | ------------------ |     |          |                    |                                  .
#    | | pen_imp        | |     |          |                    |                                  .
#    | ------------------ |     |          |                    |                                  .
#    |      ^             |     |          |                    |                                  .
#    |      |             |     |          |                    |                                  .
#    |      v             |     |          |                    |                                  .
#    |    ------------------    |          |                    |                                  .
#    |    |   draw_imp     |    |          |                    |                                  .
#    |    ------------------    |          |                    |                                  .
#    |            ^             |          |get_window_site     |                                  .
#    |            |             | xevents  |note_new_topwindow  |                                  ---
#    v            |             v          |                    v
# (.................................to/from widget threads......................................)
#        ^                |	          ^                |	          ^                |	     
#        |xrequests       | xevents       |xrequests       | xevents      |xrequests       | xevents   
#        |                v	          |                v	          |                v	     
#     -------------------------	       -------------------------       -------------------------	             
#     | xevent_to_widget_imp  |	       | xevent_to_widget_imp  |       | xevent_to_widget_imp  |    ...
#     -------------------------	       -------------------------       -------------------------	             
#             /      \		               /      \		               /      \		     
#            / widget \		              / widget \	              / widget \		             
#           /   tree   \	             /   tree   \	             /   tree   \	     
#          /            \	            /            \	            /            \	     
#         /     ...      \                 /     ...      \                /     ...      \            
#
# Dramatis Personae:
#
#  o  The sequencer_imp matches replies to requests.
#     All traffic to/from the X server goes through it.
#         Implemented in:  src/lib/x-kit/xclient/src/wire/xsocket-old.pkg
#
#  o  The outbuf_imp optimizes network usage by
#     combining multiple requests per network packet.
#         Implemented in:  src/lib/x-kit/xclient/src/wire/xsocket-old.pkg
#
#  o  The inbuf_imp breaks the incoming bytestream
#     into individual replies and forwards them individually
#     to sequencer_imp.
#         Implemented in:  src/lib/x-kit/xclient/src/wire/xsocket-old.pkg
#
#  o  The decode_xpackets_imp cracks raw wire-format bytestrings into
#     event_types::x::Event values and combines multiple related Expose
#     events into a single logical Expose event for ease of downstream
#     processing.
#         Implemented in:  src/lib/x-kit/xclient/src/wire/xsocket-old.pkg
#
#  o  The   xevent_to_window_imp   imp receives all X events
#     (e.g. keystrokes and mouseclicks) and feeds each one to the
#     appropriate toplevel window, or more precisely to the
#     topwindow_to_widget_router   at the root of the widgettree for
#   ("xevent_to_widget_imp" might be a better name)
#     that window, there to trickle down the widgettree to its ultimate
#     target widget.
#
#     To do this, xevent_to_window_imp
#     tracks all X windows created by the application,
#     keyed by their X IDs.  (Toplevel X windows are
#     registered at creation by the window-old.pkg functions;
#     subwindows are registered when their X notify event
#     comes through.)
#
#         Implemented in:  src/lib/x-kit/xclient/src/window/xsocket-to-topwindow-router-old.pkg
#         See also:        src/lib/x-kit/xclient/src/window/topwindow-to-widget-router-old.pkg
#
#  o  The font_imp ...
#         Implemented in:  src/lib/x-kit/xclient/src/window/font-imp-old.pkg
#
#  o  The keymap_imp ...
#         Implemented in:  src/lib/x-kit/xclient/src/window/keymap-imp-old.pkg
#
#
#  o  The draw_imp buffers draw commands and combines
#     them into subsequences which can share a single
#     X server graphics context, in order to minimize
#     the number of graphics context switches required.
#     It works closely with the pen-to-gcontext-imp.
#         Implemented in:  src/lib/x-kit/xclient/src/window/draw-imp-old.pkg
#
#  o  The pen_to_gcontext_imp maps between the immutable "pens"
#     we provide to the application programmer and the mutable
#     graphics contexts actually supported by the X server. Given
#     a pen, it returns a matching graphics context, using an
#     existing one unchanged if possible, else modifying an
#     existing one appropropriately.
#         Implemented in:  src/lib/x-kit/xclient/src/window/pen-to-gcontext-imp-old.pkg
#
#
# All mouse and keyboard events flow down through the
# inbuf, sequencer, decoder and xevent-to-window imps
# and thence down through the widget hierarchy
# associated with the relevant topwindow.
#
# Client xserver requests and responses are sent
# directly to the sequencer imp, with the exception
# of font requests and responses, which run through
# the font imp.
#
# Keysym translations are handled by keymap_imp.

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib





###                "I have always wished that my computer
###                 would be as easy to use as my telephone.
###                 My wish has come true ... I no longer
###                 know how to use my telephone."
###
###                               -- Bjarne Stroustrup



stipulate
    include threadkit;					# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ax  =  atom_ximp;				# atom_ximp				is from   src/lib/x-kit/xclient/src/iccc/atom-ximp.pkg
    package xg  =  xgeometry;				# xgeometry				is from   src/lib/std/2d/xgeometry.pkg
    package cs  =  color_spec;				# color_spec				is from   src/lib/x-kit/xclient/src/window/color-spec.pkg
    package kab =  keys_and_buttons;			# keys_and_buttons			is from   src/lib/x-kit/xclient/src/wire/keys-and-buttons.pkg
    package v2w =  value_to_wire;			# value_to_wire				is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package s2w =  sendevent_to_wire;			# sendevent_to_wire			is from   src/lib/x-kit/xclient/src/wire/sendevent-to-wire.pkg
    package w2v =  wire_to_value;			# wire_to_value				is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package xt  =  xtypes;				# xtypes				is from	  src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package xtr =  xlogger;				# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    package clx =  xclient_ximps;			# xclient_ximps				is from   src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
    package wpx =  window_property_ximp;		# window_property_ximp			is from   src/lib/x-kit/xclient/src/window/window-property-ximp.pkg
    package sel =  selection_ximp;			# selection_ximp			is from   src/lib/x-kit/xclient/src/window/selection-ximp.pkg

# Not visible here:
#    package qk  =  quark;				# quark					is from   src/lib/x-kit/style/quark.pkg
#    package imx =  image_ximp;				# image_ximp				is from   src/lib/x-kit/widget/lib/image-ximp.pkg
#    package rpx =  ro_pixmap_ximp;			# ro_pixmap_ximp			is from   src/lib/x-kit/widget/lib/ro-pixmap-ximp.pkg
#    package shx =  shade_ximp;				# shade_ximp				is from   src/lib/x-kit/widget/lib/shade-ximp.pkg

    package mop =  mailop;				# mailop				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/mailop.pkg
    package wme =  window_map_event_sink;		# window_map_event_sink			is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg

#   package dy  =  display_old;				# display_old				is from   src/lib/x-kit/xclient/src/wire/display-old.pkg
    package dy  =  display;				# display				is from   src/lib/x-kit/xclient/src/wire/display.pkg

#   package fti =  font_imp_old; # "fi" is taken! :-)	# font_imp_old				is from   src/lib/x-kit/xclient/src/window/font-imp-old.pkg
    package fti =  font_index;				# font_index				is from	  src/lib/x-kit/xclient/src/window/font-index.pkg

#   package p2g =  pen_to_gcontext_imp_old;		# pen_to_gcontext_imp_old		is from   src/lib/x-kit/xclient/src/window/pen-to-gcontext-imp-old.pkg
    package p2g =  pen_cache; 				# pen_cache				is from	  src/lib/x-kit/xclient/src/window/pen-cache.pkg

#   package s2t =  xsocket_to_topwindow_router_old;	# xsocket_to_topwindow_router_old	is from   src/lib/x-kit/xclient/src/window/xsocket-to-topwindow-router-old.pkg
    package s2t =  xevent_to_window_ximp;		# xevent_to_window_ximp			is from   src/lib/x-kit/xclient/src/window/xevent-to-window-ximp.pkg
    package s2p =  xevent_to_window_port;		# xevent_to_window_port			is from   src/lib/x-kit/xclient/src/window/xevent-to-window-port.pkg
    #
#   package xok =  xsocket_old;				# xsocket_old				is from   src/lib/x-kit/xclient/src/wire/xsocket-old.pkg
    package sp  =  xserver_port;			# xserver_port				is from   src/lib/x-kit/xclient/src/wire/xserver-port.pkg
    package sj  =  socket_junk;				# socket_junk				is from   src/lib/internet/socket-junk.pkg

#   package ai  =  atom_imp_old;			# atom_imp_old				is from   src/lib/x-kit/xclient/src/iccc/atom-imp-old.pkg
    package ai  =  atom_ximp;				# atom_ximp				is from   src/lib/x-kit/xclient/src/iccc/atom-ximp.pkg
    package ap  =  atom_port;				# atom_port				is from   src/lib/x-kit/xclient/src/iccc/atom-port.pkg

#   package di  =  draw_imp_old;			# draw_imp_old				is from   src/lib/x-kit/xclient/src/window/draw-imp-old.pkg
    package di  =  encode_xpackets_ximp;		# encode_xpackets_ximp			is from	  src/lib/x-kit/xclient/src/window/encode-xpackets-ximp.pkg
    package dp  =  encode_xpackets_port;		# encode_xpackets_port			is from   src/lib/x-kit/xclient/src/window/encode-xpackets-port.pkg	

#   package ki  =  keymap_imp_old;			# keymap_imp_old			is from   src/lib/x-kit/xclient/src/window/keymap-imp-old.pkg
    package ki  =  keymap_ximp;				# keymap_ximp				is from	  src/lib/x-kit/xclient/src/window/keymap-ximp.pkg
    package kp  =  keymap_port;				# keymap_port				is from   src/lib/x-kit/xclient/src/window/keymap-port.pkg

    package xwp =  xevent_to_window_port;		# xevent_to_window_port			is from   src/lib/x-kit/xclient/src/window/xevent-to-window-port.pkg
    package exp =  encode_xpackets_port;		# encode_xpackets_port			is from   src/lib/x-kit/xclient/src/window/encode-xpackets-port.pkg
    package exx =  encode_xpackets_ximp;		# encode_xpackets_ximp			is from   src/lib/x-kit/xclient/src/window/encode-xpackets-ximp.pkg

#   package si  =  selection_imp_old;			# selection_imp_old			is from   src/lib/x-kit/xclient/src/window/selection-imp-old.pkg
    package si  =  selection_ximp;			# selection_ximp			is from	  src/lib/x-kit/xclient/src/window/selection-ximp.pkg
    package sep =  selection_port;			# selection_port			is from   src/lib/x-kit/xclient/src/window/selection-port.pkg

#   package wpi =  window_property_imp_old;		# window_property_imp_old		is from   src/lib/x-kit/xclient/src/window/window-property-imp-old.pkg
    package wpi =  window_property_ximp;		# window_property_ximp			is from	  src/lib/x-kit/xclient/src/window/window-property-ximp.pkg
    package wpp =  window_property_port;		# window_property_port			is from   src/lib/x-kit/xclient/src/window/window-property-port.pkg
    #
    trace =  xtr::log_if  xtr::io_logging  0;		# Conditionally write strings to tracing.log or whatever.
herein


    package   xsession_junk
    :         Xsession_Junk				# Xsession_Junk				is from   src/lib/x-kit/xclient/src/window/xsession-junk.api
    {
	Xsession =          XSESSION
			      {
				xdisplay:          	dy::Xdisplay,          				#  
				screens:           	List( Screen_Info ),

				default_screen_info:   	Screen_Info,

				xevent_to_window_port:  s2p::Xevent_To_Window_Port,			# Feeds X events to appropriate toplevel window.

				font_index:          	fti::Font_Index,
				atom_port:          	ap::Atom_Port,

				window_property_port:   wpp::Window_Property_Port,
				selection_port:     	sep::Selection_Port,

				xserver_port:           sp::Xserver_Port,
				keymap_port:            kp::Keymap_Port
			      }

	also
	Screen_Info =       SCREEN_INFO
			      {
				xscreen:    			dy::Xscreen,				# Xscreen	def in    src/lib/x-kit/xclient/src/wire/display-old.pkg
				per_depth_imps:			List( Per_Depth_Imps ),			# The pen-cache and draw imps for the supported depths on this screen.
				rootwindow_per_depth_imps:            Per_Depth_Imps			# The pen-cache and draw imps for the root window on this screen.
			      }

	also
	Per_Depth_Imps =    PER_DEPTH_IMPS								# The pen-cache and draw_ximp
			      {										# for a given depth, visual and screen.
				depth:			Int,
#				pen_cache:		p2g::Pen_Cache,					# The pen-to-cache     for this depth on this screen.
				encode_xpackets_port:	exp::Encode_Xpackets_Port,			# The xpacket encoder  for this depth on this screen.
				window_map_event_sink:  wme::Window_Map_Event_Sink
			      }										#
													# For each combination of visual and depth
													# we allocate a pair of imps, one to draw,
													# one to manage graphics contexts.
													#   This is forced because X requires that
													# each GraphicsContext and pixmap be associated
													# with a particular screen, visual and depth.

	also
	Screen =	    SCREEN									# A screen handle for users.
			      {
				xsession:		Xsession,
				screen_info:		Screen_Info
			      };

	#
	Window =            WINDOW									# An on-screen rectangular array of pixels on the X server.
			      {
				window_id:		xt::Window_Id,
				#
				screen:			Screen,
				per_depth_imps:		Per_Depth_Imps,
				#
				encode_xpackets_port:	exp::Encode_Xpackets_Port
			      };

	# Identity tests:
	#
	fun same_xsession
            ( XSESSION { xdisplay=>dy::XDISPLAY { socket => x1, ... }, ... },
              XSESSION { xdisplay=>dy::XDISPLAY { socket => x2, ... }, ... }
            )
	    =
	    (x1 == x2);
#	    xok::same_xsocket (x1, x2);	# Repply had this
	#
	fun same_screen ( SCREEN { xsession=>xsession1, screen_info=>SCREEN_INFO { xscreen => dy::XSCREEN { id=>id1, ... }, ... }},
			  SCREEN { xsession=>xsession2, screen_info=>SCREEN_INFO { xscreen => dy::XSCREEN { id=>id2, ... }, ... }}
			)
	    =
	    (id1 == id2)
	    and
	    same_xsession (xsession1, xsession2);
	#
	fun same_window (   WINDOW { window_id=>id1, screen=>s1, ... },
			    WINDOW { window_id=>id2, screen=>s2, ... }   )
	    =
	   (id1 == id2) and same_screen (s1, s2);

	# We are typically called from   open_xsession()   below:
	#
	fun make_xsession								# Called mainly from   make_root_window   in  src/lib/x-kit/widget/basic/root-window-old.pkg
	      {
		run_gun':		mop::Run_Gun,
		end_gun':		mop::End_Gun,
		xevent_to_window_port:	xwp::Xevent_To_Window_Port,			# Directs X mouseclicks etc to right topwindow.
		xserver_port:		sp::Xserver_Port,				# All drawing commands go to Xserver via sequencer then outbuf.
		atom_port:          	ap::Atom_Port,
		keymap_port:            kp::Keymap_Port,
		selection_port:     	sep::Selection_Port,
		window_property_port:   wpp::Window_Property_Port,
		xdisplay:		dy::Xdisplay,
		drawable:		xt::Drawable_Id

# display_name:     String,
#              xauthentication:  Null_Or( xt::Xauthentication )				# Xauthentication info comes ultimately from ~/.Xauthority
	      }
	    =
	    {
printf "make_xsession/AAA  -- xsession-junk.pkg\n";
		# We turn this off in close_xession, so for symmetry's
		# sake we turn it on here in open_xsession:
		#									# tracing		is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#		logger::disable  thread_deathwatch::logging;				# thread_deathwatch	is from   src/lib/src/lib/thread-kit/src/lib/thread-deathwatch.pkg


		xdisplay ->   dy::XDISPLAY { default_screen, screens, next_xid, ... };


		font_index =  fti::make_font_index ();

		#
		fun make_screen_info (xscreen as dy::XSCREEN { root_window_id, root_visual, visuals, ... } )
		    =
		    {   fun make_per_depth_imps  (depth, drawable)
			    =
			    {
#				drawimp_mappedstate_slot =  make_mailslot ();
#				make_thread  "send FIRST_EXPOSE"  .{   put_in_mailslot (drawimp_mappedstate_slot, di::s::FIRST_EXPOSE);   };

				(exx::make_encode_xpackets_ximp_state ()) ->   state;
				(exx::make_encode_xpackets_ximp "enc"   ) ->  (configstate, exports);			# String gives name for imp microthread.  Exports gives access to it.

				exx::configure_encode_xpackets_ximp							# Supply all information required for startup.
				  (
				    configstate,
				    state,
				    { xevent_to_window_port, xserver_port },
				    run_gun',
				    end_gun',
				    xdisplay,
				    drawable
				  );
				
				encode_xpackets_port  =   exports.encode_xpackets_port;
				window_map_event_sink =	  exports.window_map_event_sink;

				PER_DEPTH_IMPS { depth, encode_xpackets_port, window_map_event_sink };
			    };
			#
			fun make_pen_imps ([], l)
				=>
				l;

			    make_pen_imps (vd ! r, l)
				=>
				make_pen_imps (r, get l)
				where
				    visual_depth =  dy::depth_of_visual  vd;
				    #
				    fun make_imps ()
					=
					{   pixmap_id = next_xid ();

					    # Make a pixmap to serve as the
					    # witness drawable for the GC server:
					    #
					    xserver_port.send_xrequest
					      ( v2w::encode_create_pixmap
						  { pixmap_id,
						    drawable_id =>  root_window_id,
						    size        =>  xg::SIZE { wide=>1, high=>1 },
						    depth       =>  visual_depth
				                  }
                                              );

					    make_per_depth_imps	(visual_depth, pixmap_id);
				        };

				    #
				    fun get [] =>   make_imps() ! l;
					#
				        get (PER_DEPTH_IMPS { depth, ... } ! rest)
					    =>
					    depth == visual_depth
                                             ??  l
                                             ::  get rest;
                                    end;
				end;
			end;

			rootwindow_per_depth_imps
			    =
			    make_per_depth_imps  (dy::depth_of_visual  root_visual,  root_window_id);

			per_depth_imps
			    =
			    make_pen_imps (visuals, [ rootwindow_per_depth_imps ]);

			per_depth_imps
			    =
			    make_pen_imps ( [ xt::NO_VISUAL_FOR_THIS_DEPTH 1 ],
                                            per_depth_imps
                                          );

			SCREEN_INFO
                          {
			    xscreen,
			    per_depth_imps,
			    rootwindow_per_depth_imps
			  };
		    };

		screens =  map  make_screen_info  screens;

printf "make_xsession/ZZZ  -- xsession-junk.pkg\n";
		XSESSION
		  {
		    xdisplay,
		    default_screen_info =>  list::nth (screens, default_screen),
		    screens,
		    xevent_to_window_port,
		    atom_port,
		    font_index,
		    window_property_port,
		    selection_port,
		    xserver_port,
		    keymap_port
		  };
	  };							# fun make_xsession


	# We are typically called from   make_root_window()   in
	#
	#     src/lib/x-kit/widget/basic/root-window.pkg
	#
	fun open_xsession
              {
	        display_name:		String,
		xauthentication:	Null_Or( xt::Xauthentication ),
		run_gun':		mop::Run_Gun,
		end_gun':		mop::End_Gun
	      }
	    =
	    {
printf "open_xsession/AAA calling   open_xdisplay  display_name s='%s'  -- xsession-junk.pkg\n" display_name;
		(dy::open_xdisplay { display_name, xauthentication })
		    ->
		    (xdisplay as dy::XDISPLAY { default_screen, screens, socket, next_xid, ... } );	# Canonical sequence has 'xsocket' not 'socket' here.
printf "open_xsession/BBB back from open_xdisplay  display_name s='%s'  -- xsession-junk.pkg\n" display_name;

		
		default_screen =    list::nth (screens, default_screen)
				    except
					SUBSCRIPT = {   msg = "Bad default_screen value -- make_root_window in xclient-ximps-junk.pkg";
							log::fatal msg;			# Doesn't return.
							raise exception FAIL msg;	# Should never get here.
						    };

		default_screen ->   dy::XSCREEN { root_window_id, ... };

#		(make_run_gun ()) ->   { run_gun', fire_run_gun };
#		(make_end_gun ()) ->   { end_gun', fire_end_gun };


		(clx::make_xclient_ximps_state ()	  ) ->   xclient_ximps_state;
		(clx::make_xclient_ximps "xclient_ximps"  ) ->  (xclient_ximps_configstate, xclient_ximps_exports);

		(ax::make_atom_ximp_state ()		  ) ->   atom_ximp_state;
		(ax::make_atom_ximp "atom_ximp"		  ) ->  (atom_ximp_configstate, atom_ximp_exports);

		(wpx::make_window_property_ximp_state ()  ) ->   window_property_ximp_state;
		(wpx::make_window_property_ximp "wpx"	  ) ->  (window_property_ximp_configstate, window_property_ximp_exports);

		(sel::make_selection_ximp_state ()	  ) ->   selection_ximp_state;
		(sel::make_selection_ximp "sel"		  ) ->  (selection_ximp_configstate, selection_ximp_exports);


# This is done in xclient-ximps.pkg:
#		(exx::make_encode_xpackets_ximp_state ()  ) ->   encode_xpackets_ximp_state;
#		(exx::make_encode_xpackets_ximp "enc"	  ) ->  (encode_xpackets_ximp_configstate, encode_xpackets_ximp_exports);


		encode_xpackets_port		=	  xclient_ximps_exports.encode_xpackets_port;
		xevent_to_window_port		=	  xclient_ximps_exports.xevent_to_window_port;
		xserver_port			=         xclient_ximps_exports.xserver_port;
		xerror_well			=         xclient_ximps_exports.xerror_well;
		keymap_port			=         xclient_ximps_exports.keymap_port;

		window_property_port		=  window_property_ximp_exports.window_property_port;
		window_property_xevent_sink	=  window_property_ximp_exports.window_property_xevent_sink;

		selection_port			=        selection_ximp_exports.selection_port;
		selection_xevent_sink		=        selection_ximp_exports.selection_xevent_sink;


		atom_port			=             atom_ximp_exports.atom_port;




# not visible here.
#
# TBD: image_ximp	    configuration

#		window_property_xevent_sink =	{ put_value => 	(fn (event: et::x::Event) = { log::fatal  "window_property_xevent_sink called"; (); }) };	# Dummy to 'handle' X server PropertyNotify events.
#		selection_xevent_sink	    =	{ put_value => 	(fn (event: et::x::Event) = { log::fatal  "selection_xevent_sink called"      ; (); }) };	# Dummy to 'handle' X server SelectionNotify, SelectionRequest and SelectionClear events.

		clx::configure_xclient_ximps
		  (
		    xclient_ximps_configstate,
		    xclient_ximps_state,
		    { window_property_xevent_sink, selection_xevent_sink },
		    run_gun',
		    end_gun',
		    xdisplay,	
		    root_window_id,
		    socket 								# sok::Socket (X, sok::Stream(sok::Active))						# Socket to read.
		  );

		ax::configure_atom_ximp
		  (
		    atom_ximp_configstate,
		    atom_ximp_state,
		    { xserver_port },
		    run_gun',
		    end_gun'
		  );

		wpx::configure_window_property_ximp
		  (
		    window_property_ximp_configstate,
		    window_property_ximp_state,
		    { atom_port, xserver_port },
		    run_gun',
		    end_gun'
		  );

		sel::configure_selection_ximp
		  (
		    selection_ximp_configstate,
		    selection_ximp_state,
		    { xserver_port },
		    run_gun',
		    end_gun'
		  );


		xsession =  make_xsession
			      {
				run_gun',
				end_gun',
				xevent_to_window_port,
				xserver_port,
				atom_port,
				keymap_port,
				selection_port,
				window_property_port,
				xdisplay,
				drawable => root_window_id
			      };


printf "open_xsession/ZZZ  -- xsession-junk.pkg\n";
		xsession;
	    };							# fun open_xsession


	fun send_xrequest (XSESSION x) request
	    =
	    x.xserver_port.send_xrequest request;

	# X-server I/O.
	#
#	stipulate
#	    #
#	    fun apply_to_xsocket f (XSESSION { xdisplay=>dy::XDISPLAY { xsocket, ... }, ... } )
#                =
#                f xsocket;
#
#	herein
#
#	    send_xrequest  		      =  apply_to_xsocket  xok::send_xrequest;
#	    send_xrequest_and_return_completion_mailop  =  apply_to_xsocket  xok::send_xrequest_and_return_completion_mailop;
#
#	    send_xrequest_and_read_reply      =  apply_to_xsocket  xok::send_xrequest_and_read_reply;
#	    sent_xrequest_and_read_replies    =  apply_to_xsocket  xok::sent_xrequest_and_read_replies;
#
#	    flush_out          =  apply_to_xsocket  xok::flush_xsocket;
#
#	    query_best_size    =  apply_to_xsocket  xok::query_best_size;
#	    query_colors       =  apply_to_xsocket  xok::query_colors;
#	    query_font         =  apply_to_xsocket  xok::query_font;
#	    query_pointer      =  apply_to_xsocket  xok::query_pointer;
#	    query_text_extents =  apply_to_xsocket  xok::query_text_extents;
#	    query_tree         =  apply_to_xsocket  xok::query_tree;
#
#	end;

	# Get location of mouse pointer
	# plus related information:
	#
#	fun get_mouse_location
#	    (XSESSION
#	      { xdisplay            =>  dy::XDISPLAY { xsocket, ... },
#		default_screen_info =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
#		...
#	      }
#	    )
#	    =
#	    {   # The X server query_pointer call takes a window_id
#		# argument. This seems overcomplex for the typical
#		# Mythryl caller, so here we just default it to the
#		# the default-screen root-window:
#		#
#		(xok::query_pointer  xsocket  { window_id => root_window_id })
#		    ->
#		    { root_point, ... };
#
#		# The X server query_pointer call returns
#		# a load of stuff.  For now at least, a
#		# return value of simply the mouse location
#		# seems more convenient for the Mythryl app hacker:
#		#
#		root_point;
#	    };
	#
#	fun set_mouse_location
#	    (
#             XSESSION
#	      { xdisplay            =>  dy::XDISPLAY { xsocket, ... },
#		default_screen_info =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
#		...
#	      }
#	    )
#	    to_point
#	    =
#	    {   # This is an ignored dummy value:
#		#
#	        from_box =  xg::BOX { col => 0, row => 0, wide => 0, high => 0 };
#
#		command
#		    =
#		    v2w::encode_warp_pointer
#                      {
#			to_point,					# Move mouse pointer to this coordinate.
#                        to   =>  THE root_window_id,			# Position mouse relative to root window.
#			#						# (That is, in absolute screen coordinates.)
#	                from =>  NULL,
#			from_box					# Ignored because 'from' is NULL.
#                      };
#
#		xok::send_xrequest  xsocket  command;
#	    };

	# Map a point in the window's coordinate
	# system to the screen's coordinate system:
	#
	fun window_point_to_screen_point (WINDOW { window_id, screen, ... } ) pt
	    =
	    {   screen ->  SCREEN { xsession => XSESSION x, screen_info => SCREEN_INFO { xscreen => dy::XSCREEN { root_window_id, ... }, ... }, ... };
		#
		my { to_point, ... }
		    =
		    w2v::decode_translate_coordinates_reply
		      (
			block_until_mailop_fires
#                       ========================                XXX SUCKO FIXME
			  (x.xserver_port.send_xrequest_and_read_reply
			      (v2w::encode_translate_coordinates { from_window=>window_id, to_window=>root_window_id, from_point=>pt } )
			  )
		      );

		to_point;
	    };

	# Fake up an X server timestamp for the current time
	# by taking the time of day in milliseconds to 32-bit
        # accuracy and then jiggering the type appropriately:
	#
	fun bogus_current_x_timestamp ()
	    =
	    {    time =  time::get_current_time_utc ();			# Current time
		 ms   =  time::to_milliseconds  time;			# in milliseconds since the Epoch

		 ms32 =  large_int::(%) (ms, 256*256*256*256);		# truncated to 32-bit accuracy
                 ms32 =  one_word_unt::from_multiword_int  ms32;	# converted to 32-bit unsigned

                 ms32 =  xserver_timestamp::XSERVER_TIMESTAMP  ms32;	# wrapped up as a
                 ms32 =  xtypes::TIMESTAMP ms32;			# proper X timestamp value.
                 ms32;
	    };	
	#
	fun send_keyboard_key_press_xevent
	    (
             XSESSION
	      { xserver_port,
		default_screen_info =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
		...
	      }
	    )
	    { window =>  window as WINDOW { window_id, ... },		# Window handling the keyboard-key press event.
	      keycode,							# Keyboard key just "pressed".
	      point  =>  point as xg::POINT { row, col }		# Keypress location in local window coordinates.
	    }
	    =
	    {   # We need the keypress point in both
                # local and screen coords:
		#
# trace .{ sprintf "xsession: send_keyboard_key_press_event/TOP window_point = { row %d, col %d }." row col; };
		(window_point_to_screen_point  window  point)
		    ->
		    xg::POINT { row => screen_row,
                                col => screen_col
                              };

# trace .{ sprintf "xsession: send_keyboard_key_press_event/MID screen_point = { row %d, col %d }." screen_row screen_col; };
		# For the semantics of these three fields see
		#     p27 http://mythryl.org/pub/exene/X-protocol-R6.pdf
		#
	        send_event_to	=  xt::SEND_EVENT_TO_WINDOW  window_id;
		propagate	=  FALSE;
		event_mask	=  xt::EVENT_MASK 0u0;
		#
#		timestamp	=  xt::CURRENT_TIME;			# I had thought the X server would fill this in for us, but apparently it passes it through. :-(
		timestamp	=  bogus_current_x_timestamp ();	# This won't sync with real X server timestamps, but I don't see a simple way to make it do so.
									# Currently we never mix synthetic and natural X events, but this is a bug waiting to happen. XXX BUGGO FIXME.
		root_window_id	=  root_window_id;
		event_window_id	=  window_id;				# Window handling the keyboard-key "press" event.
		child_window_id	=  NULL;				# We'll assume specified window is a leaf.
		root_x		=  screen_col;				# Mouse position on root window at time of keypress.
		root_y		=  screen_row;
		event_x		=  col;					# Mouse position on recipient window at time of keypress.
		event_y		=  row;
		buttons		=  kab::make_mousebutton_state [ ];	# Mouse buttons state BEFORE keypress.

# trace .{ "xsession: send_keyboard_key_press_event/YYY calling s2w::encode_send_keypress_xevent"; };
		command
		    =
		    s2w::encode_send_keypress_xevent
		      {
			send_event_to,  propagate,  event_mask,
			timestamp,  root_window_id,  event_window_id,  child_window_id,  root_x,  root_y,  event_x,  event_y,  keycode, buttons
		      };

		xserver_port.send_xrequest  command;

# trace .{ "xsession: send_keyboard_key_press_event/BOT called  s2w::encode_send_keypress_xevent -- DONE"; };
		();
	    };
	#
	fun send_keyboard_key_release_xevent
	    (
             XSESSION
	      { xserver_port,
		default_screen_info =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
		...
	      }
	    )
	    { window =>  window as WINDOW { window_id, ... },		# Window handling the keyboard-key release event.
	      keycode,							# Keyboard key just "released".
	      point  =>  point as xg::POINT { row, col }		# Key release location in local window coordinates.
	    }
	    =
	    {   # We need the key release point in both
                # local and screen coords:
		#
# trace .{ sprintf "xsession: send_keyboard_key_release_event/TOP window_point = { row %d, col %d }." row col; };
		(window_point_to_screen_point  window  point)
		    ->
		    xg::POINT { row => screen_row,
                                col => screen_col
                              };

# trace .{ sprintf "xsession: send_keyboard_key_release_event/MID screen_point = { row %d, col %d }." screen_row screen_col; };
		# For the semantics of these three fields see
		#     p27 http://mythryl.org/pub/exene/X-protocol-R6.pdf
		#
	        send_event_to	=  xt::SEND_EVENT_TO_WINDOW  window_id;
		propagate	=  FALSE;
		event_mask	=  xt::EVENT_MASK 0u0;
		#
#		timestamp	=  xt::CURRENT_TIME;			# I had thought the X server would fill this in for us, but apparently it passes it through. :-(
		timestamp	=  bogus_current_x_timestamp ();	# This won't sync with real X server timestamps, but I don't see a simple way to make it do so.
									# Currently we never mix synthetic and natural X events, but this is a bug waiting to happen. XXX BUGGO FIXME.
		root_window_id	=  root_window_id;
		event_window_id	=  window_id;				# Window handling the keyboard-key "release" event.
		child_window_id	=  NULL;				# We'll assume specified window is a leaf.
		root_x		=  screen_col;				# Mouse position on root window at time of key "release".
		root_y		=  screen_row;
		event_x		=  col;					# Mouse position on recipient window at time of key "release".
		event_y		=  row;
		buttons		=  kab::make_mousebutton_state [ ];	# Mouse buttons state BEFORE key release.

# trace .{ "xsession: send_keyboard_key_release_event/YYY calling s2w::encode_send_keyrelease_xevent"; };
		command
		    =
		    s2w::encode_send_keyrelease_xevent
		      {
			send_event_to,  propagate,  event_mask,
			timestamp,  root_window_id,  event_window_id,  child_window_id,  root_x,  root_y,  event_x,  event_y,  keycode, buttons
		      };

		xserver_port.send_xrequest  command;

# trace .{ "xsession: send_keyboard_key_release_event/BOT called  s2w::encode_send_keyrelease_xevent -- DONE"; };
		();
	    };
	#
	fun send_mousebutton_press_xevent
	    (
             XSESSION
	      { xserver_port,
		default_screen_info =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
		...
	      }
	    )
	    { window =>  window as WINDOW { window_id, ... },		# Window handling the mouse-button click event.
	      button,							# Mouse button just "clicked" down.
	      point  =>  point as xg::POINT { row, col }		# Click location in local window coordinates.
	    }
	    =
	    {   # We need the clickpoint in both
                # local and screen coords:
		#
# trace .{ sprintf "xsession: send_mousebutton_press_event/TOP window_point = { row %d, col %d }." row col; };
		(window_point_to_screen_point  window  point)
		    ->
		    xg::POINT { row => screen_row,
                                col => screen_col
                              };

# trace .{ sprintf "xsession: send_mousebutton_press_event/MID screen_point = { row %d, col %d }." screen_row screen_col; };
		# For the semantics of these three fields see
		#     p27 http://mythryl.org/pub/exene/X-protocol-R6.pdf
		#
	        send_event_to	=  xt::SEND_EVENT_TO_WINDOW  window_id;
		propagate	=  FALSE;
		event_mask	=  xt::EVENT_MASK 0u0;
		#
#		timestamp	=  xt::CURRENT_TIME;			# I had thought the X server would fill this in for us, but apparently it passes it through. :-(
		timestamp	=  bogus_current_x_timestamp ();	# This won't sync with real X server timestamps, but I don't see a simple way to make it do so.
									# Currently we never mix synthetic and natural X events, but this is a bug waiting to happen. XXX BUGGO FIXME.
		root_window_id	=  root_window_id;
		event_window_id	=  window_id;				# Window handling the mouse-button release event.
		child_window_id	=  NULL;				# We'll assume specified window is a leaf.
		root_x		=  screen_col;				# Mouse position on root window at time of button release.
		root_y		=  screen_row;
		event_x		=  col;					# Mouse position on recipient window at time of button release.
		event_y		=  row;
		buttons		=  kab::make_mousebutton_state [ ];	# Mouse buttons state BEFORE button press.

# trace .{ "xsession: send_mousebutton_press_event/YYY calling s2w::encode_send_buttonpress_xevent"; };
		command =   s2w::encode_send_buttonpress_xevent
			      {
				send_event_to,  propagate,  event_mask,
				timestamp,  root_window_id,  event_window_id,  child_window_id,  root_x,  root_y,  event_x,  event_y,  button, buttons
			      };

		xserver_port.send_xrequest  command;

# trace .{ "xsession: send_mousebutton_press_event/BOT called  s2w::encode_send_buttonpress_xevent -- DONE"; };
		();
	    };
	#
	fun send_mousebutton_release_xevent
	    (
             XSESSION
	      { xserver_port,
		default_screen_info =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
		...
	      }
	    )
	    { window =>  window as WINDOW { window_id, ... },		# Window handling the mouse-button click event.
	      button,							# Mouse button just "clicked" down.
	      point  =>  point as xg::POINT { row, col }		# Click location in local window coordinates.
	    }
	    =
	    {   # We need the clickpoint in both
                # local and screen coords:
		#
# trace .{ sprintf "xsession: send_mousebutton_release_xevent/TOP window_point = { row %d, col %d }." row col; };
		(window_point_to_screen_point  window  point)
		    ->
		    xg::POINT { row => screen_row,
                                col => screen_col
                              };

# trace .{ sprintf "xsession: send_mousebutton_release_xevent/MID screen_point = { row %d, col %d }." screen_row screen_col; };
		# For the semantics of these three fields see
		#     p27 http://mythryl.org/pub/exene/X-protocol-R6.pdf
		#
	        send_event_to	=  xt::SEND_EVENT_TO_WINDOW  window_id;
		propagate	=  FALSE;
		event_mask	=  xt::EVENT_MASK 0u0;
		#
#		timestamp	=  xt::CURRENT_TIME;			# I had thought the X server would fill this in for us, but apparently it passes it through. :-(
		timestamp	=  bogus_current_x_timestamp ();	# This won't sync with real X server timestamps, but I don't see a simple way to make it do so.
									# Currently we never mix synthetic and natural X events, but this is a bug waiting to happen. XXX BUGGO FIXME.
		root_window_id	=  root_window_id;
		event_window_id	=  window_id;						# Window handling the mouse-button release event.
		child_window_id	=  NULL;						# We'll assume specified window is a leaf.
		root_x		=  screen_col;						# Mouse position on root window at time of button release.
		root_y		=  screen_row;
		event_x		=  col;							# Mouse position on recipient window at time of button release.
		event_y		=  row;
		buttons		=  kab::make_mousebutton_state [ button ];		# Mouse buttons state BEFORE button release.

# trace .{ "xsession: send_mousebutton_release_xevent/YYY calling s2w::encode_send_buttonpress_xevent"; };
		command =   s2w::encode_send_buttonrelease_xevent
			      {
				send_event_to,  propagate,  event_mask,
				timestamp,  root_window_id,  event_window_id,  child_window_id,  root_x,  root_y,  event_x,  event_y,  button, buttons
			      };

		xserver_port.send_xrequest    command;
# trace .{ "xsession: send_mousebutton_release_event/BOT called  s2w::encode_send_buttonpress_xevent -- DONE"; };
		();
	    };

	#
	fun send_mouse_motion_xevent
	    (
             XSESSION
	      { xserver_port,
		default_screen_info =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
		...
	      }
	    )
	    { window =>  window as WINDOW { window_id, ... },		# Window handling the mouse-moution event.
	      buttons,							# Mouse button(s) being dragged.
	      point  =>  point as xg::POINT { row, col }		# Motion location in local window coordinates.
	    }
	    =
	    {   # We need the clickpoint in both
                # local and screen coords:
		#
# trace .{ sprintf "xsession: send_mouse_motion_xevent/TOP window_point = { row %d, col %d }." row col; };
		(window_point_to_screen_point  window  point)
		    ->
		    xg::POINT { row => screen_row,
                                col => screen_col
                              };

# trace .{ sprintf "xsession: send_mouse_motion_xevent/MID screen_point = { row %d, col %d }." screen_row screen_col; };
		# For the semantics of these three fields see
		#     p27 http://mythryl.org/pub/exene/X-protocol-R6.pdf
		#
	        send_event_to	=  xt::SEND_EVENT_TO_WINDOW  window_id;
		propagate	=  FALSE;
		event_mask	=  xt::EVENT_MASK 0u0;
		#
#		timestamp	=  xt::CURRENT_TIME;			# I had thought the X server would fill this in for us, but apparently it passes it through. :-(
		timestamp	=  bogus_current_x_timestamp ();	# This won't sync with real X server timestamps, but I don't see a simple way to make it do so.
									# Currently we never mix synthetic and natural X events, but this is a bug waiting to happen. XXX BUGGO FIXME.
		root_window_id	=  root_window_id;
		event_window_id	=  window_id;						# Window handling the mouse-button release event.
		child_window_id	=  NULL;						# We'll assume specified window is a leaf.
		root_x		=  screen_col;						# Mouse position on root window at time of button release.
		root_y		=  screen_row;
		event_x		=  col;							# Mouse position on recipient window at time of button release.
		event_y		=  row;
		buttons		=  kab::make_mousebutton_state buttons;			# Mouse buttons being dragged

# trace .{ "xsession: send_mouse_motion_xevent/YYY calling s2w::encode_send_motionnotify_xevent"; };
		command =   s2w::encode_send_motionnotify_xevent
			      {
				send_event_to,  propagate,  event_mask,
				timestamp,  root_window_id,  event_window_id,  child_window_id,  root_x,  root_y,  event_x,  event_y,  buttons
			      };

		xserver_port.send_xrequest   command;
# trace .{ "xsession: send_mouse_motion_event/BOT called  s2w::encode_send_motionnotify_xevent -- DONE"; };
		();
	    };

	#
	fun send_''mouse_enter''_xevent
	    (
             XSESSION
	      { xserver_port,
		default_screen_info =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
		...
	      }
	    )
	    { window =>  window as WINDOW { window_id, ... },		# Window handling the mouse-button click event.
	      point  =>  point as xg::POINT { row, col }		# Click location in local window coordinates.
	    }
	    =
	    {   # We need the point in both
                # local and screen coords:
		#
# trace .{ sprintf "xsession: send_''mouse_enter''_xevent/TOP window_point = { row %d, col %d }." row col; };
		(window_point_to_screen_point  window  point)
		    ->
		    xg::POINT { row => screen_row,
                                col => screen_col
                              };

# trace .{ sprintf "xsession: send_''mouse_enter''_xevent/MID screen_point = { row %d, col %d }." screen_row screen_col; };
		# For the semantics of these three fields see
		#     p27 http://mythryl.org/pub/exene/X-protocol-R6.pdf
		#
	        send_event_to	=  xt::SEND_EVENT_TO_WINDOW  window_id;
		propagate	=  FALSE;
		event_mask	=  xt::EVENT_MASK 0u0;
		#
#		timestamp	=  xt::CURRENT_TIME;			# I had thought the X server would fill this in for us, but apparently it passes it through. :-(
		timestamp	=  bogus_current_x_timestamp ();	# This won't sync with real X server timestamps, but I don't see a simple way to make it do so.
									# Currently we never mix synthetic and natural X events, but this is a bug waiting to happen. XXX BUGGO FIXME.
		root_window_id	=  root_window_id;
		event_window_id	=  window_id;				# Window handling the mouse-button release event.
		child_window_id	=  NULL;				# We'll assume specified window is a leaf.
		root_x		=  screen_col;				# Mouse position on root window at time of button release.
		root_y		=  screen_row;
		event_x		=  col;					# Mouse position on recipient window at time of button release.
		event_y		=  row;
		buttons		=  xt::MOUSEBUTTON_STATE 0u0;

# trace .{ "xsession: send_''mouse_enter''_xevent/YYY calling s2w::encode_send_enternotify_xevent"; };
		command =   s2w::encode_send_enternotify_xevent
			      {
				send_event_to,  propagate,  event_mask,
				timestamp,  root_window_id,  event_window_id,  child_window_id,  root_x,  root_y,  event_x,  event_y, buttons
			      };

		xserver_port.send_xrequest   command;
# trace .{ "xsession: send_''mouse_enter''_xevent/BOT called  s2w::encode_send_enternotify_xevent -- DONE"; };
		();
	    };


	fun send_''mouse_leave''_xevent
	    (
             XSESSION
	      { xserver_port,
		default_screen_info =>  SCREEN_INFO  { xscreen => dy::XSCREEN  { root_window_id, ... }, ... },
		...
	      }
	    )
	    { window =>  window as WINDOW { window_id, ... },		# Window handling the mouse-button click event.
	      point  =>  point as xg::POINT { row, col }		# Click location in local window coordinates.
	    }
	    =
	    {   # We need the point in both
                # local and screen coords:
		#
# trace .{ sprintf "xsession: send_''mouse_leave''_xevent/TOP window_point = { row %d, col %d }." row col; };
		(window_point_to_screen_point  window  point)
		    ->
		    xg::POINT { row => screen_row,
                                col => screen_col
                              };

# trace .{ sprintf "xsession: send_''mouse_leave''_xevent/MID screen_point = { row %d, col %d }." screen_row screen_col; };
		# For the semantics of these three fields see
		#     p27 http://mythryl.org/pub/exene/X-protocol-R6.pdf
		#
	        send_event_to	=  xt::SEND_EVENT_TO_WINDOW  window_id;
		propagate	=  FALSE;
		event_mask	=  xt::EVENT_MASK 0u0;
		#
#		timestamp	=  xt::CURRENT_TIME;			# I had thought the X server would fill this in for us, but apparently it passes it through. :-(
		timestamp	=  bogus_current_x_timestamp ();	# This won't sync with real X server timestamps, but I don't see a simple way to make it do so.
									# Currently we never mix synthetic and natural X events, but this is a bug waiting to happen. XXX BUGGO FIXME.
		root_window_id	=  root_window_id;
		event_window_id	=  window_id;				# Window handling the mouse-button release event.
		child_window_id	=  NULL;				# We'll assume specified window is a leaf.
		root_x		=  screen_col;				# Mouse position on root window at time of button release.
		root_y		=  screen_row;
		event_x		=  col;					# Mouse position on recipient window at time of button release.
		event_y		=  row;
		buttons		=  xt::MOUSEBUTTON_STATE 0u0;

# trace .{ "xsession: send_''mouse_leave''_xevent/YYY calling s2w::encode_send_leavenotify_xevent"; };
		command =   s2w::encode_send_leavenotify_xevent
			      {
				send_event_to,  propagate,  event_mask,
				timestamp,  root_window_id,  event_window_id,  child_window_id,  root_x,  root_y,  event_x,  event_y, buttons
			      };

		xserver_port.send_xrequest    command;
# trace .{ "xsession: send_''mouse_leave''_xevent/BOT called  s2w::encode_send_leavenotify_xevent -- DONE"; };
		();
	    };


        # Close the xsession.
        # NOTE: there are probably other things
        # that should go on here, such as notifying
        # the xbuf_to_topwindow_xevent_router.           XXX BUGGO FIXME
        #
	fun close_xsession (XSESSION { xdisplay, ... } )
            =
	    {
# I am not at all convinced I want xsession-junk closing sockets
# -- I'd like to be able to close down and restart an xsession
# without the xserver having to know. So I'm going to plant this
# here to remind me to return to this at some point when other stuff
# is more under control:
log::fatal "close_xsession called -- xsession-junk.pkg";
		# Threads will die left and right as we shut down,
		# and scary warning messages will by default be
		# logged to stdout, so suppress that to avoid
		# spooking the user:
		#
		logger::disable  thread_deathwatch::logging;

		dy::close_xdisplay  xdisplay;
	    };

	# Return the maximum request size
	# supported by the display:
	#
#	fun max_request_length (XSESSION { xdisplay=>dy::XDISPLAY { max_request_length, ... }, ... } )
#	    =
#	    max_request_length;

	# Atom operations:
	#
#	stipulate
#	    #	
#	    fun wrap_atom_op f (XSESSION { atom_imp, ... } )
#                =
#                f atom_imp;
#	herein
#	    #
#	    make_atom      =  wrap_atom_op  ai::make_atom;
#	    find_atom      =  wrap_atom_op  ai::find_atom;
#	    atom_to_string =  wrap_atom_op  ai::atom_to_string;
#	end;



	fun find_font  (XSESSION { font_index, ... } )   font_name
	    =
	    case (fti::find_font  font_index  font_name)
		#
		THE font => font;
		#
		NULL	 => {   msg =   sprintf  "find_font unable to find font '%s' -- xsession-junk.pkg"  font_name;
				log::fatal msg;					# Should not return.
				raise exception FAIL msg;			# Should never get here.
			    };
	    esac;

	#
	fun default_screen_of  (xsession as XSESSION { default_screen_info, ... } )
	    =
	    SCREEN { xsession, screen_info => default_screen_info };

	#
#	fun get_''gui_startup_complete''_oneshot_of_xsession  (xsession as XSESSION { xsocket_to_topwindow_router, ... } )
#	    =
#	    s2t::get_''gui_startup_complete''_oneshot_of
#		#
#		xsocket_to_topwindow_router;

	#
#	fun screens_of  (xsession as XSESSION { screens, ... } )
#	    =
#	    map (fn s = SCREEN { xsession, screen_info => s })
#                screens;

	#
	fun ring_bell xsession percent
	    =
	    send_xrequest  xsession
		(value_to_wire::encode_bell { percent => int::min (100, int::max(-100, percent)) } );


	# Screen functions:
	#
#	color_of_screen
#	    =
#            cs::get_color;
	#
	fun xsession_of_screen (SCREEN { xsession, ... } )
	    =
            xsession;

	# Additions by ddeboer, May 2004.
	# Dusty deBoer, KSU CIS 705, Spring 2004.

	# Return the root window of a screen.
	# This is needed in obtaining strings from xrdb,
	# as they are stored in a property of the root window:
	#
	fun root_window_of_screen (SCREEN { screen_info => SCREEN_INFO { xscreen => dy::XSCREEN { root_window_id, ... }, ... }, ... } )
            =
            root_window_id;

	# End additions by ddeboer
	#
	fun size_of_screen (SCREEN { screen_info => SCREEN_INFO { xscreen => dy::XSCREEN { size_in_pixels, ... }, ... }, ... } )
	    =
	    size_in_pixels;
	#
	fun mm_size_of_screen (SCREEN { screen_info => SCREEN_INFO { xscreen => dy::XSCREEN { size_in_mm, ... }, ... }, ... } )
	    =
	    size_in_mm;
	#
	fun depth_of_screen (SCREEN { screen_info => SCREEN_INFO { xscreen => dy::XSCREEN { root_visual, ... }, ... }, ... } )
	    =
	    dy::depth_of_visual root_visual;
	#
	fun display_class_of_screen (SCREEN { screen_info => SCREEN_INFO { xscreen => dy::XSCREEN { root_visual, ... }, ... }, ... } )
	    =
	    case (dy::display_class_of_visual  root_visual)
		#
		THE c => c;
		_     => xgripe::impossible "[xsession::display_class_of_screen: bogus root visual]";
	    esac;

	# Return the pen-cache and draw imps
        # for given depth on given screen:
	#
	fun per_depth_imps_for_depth (SCREEN { screen_info => SCREEN_INFO { per_depth_imps, ... }, ... }, given_depth)
	    =
	    search  per_depth_imps
	    where
		fun search ((sd as PER_DEPTH_IMPS { depth, ... } ) ! rest)
			=>
			if (depth == given_depth)  sd;
                        else                       search rest;
                        fi;

		    search [] =>    {   msg = "invalid depth for screen";
					log::fatal  msg;
					raise exception FAIL msg;
				    };
		end;
	    end;
	#
#	fun keysym_to_keycode  (XSESSION  { keymap_imp, ... },  keysym)
#	    =
#	    ki::keysym_to_keycode (keymap_imp, keysym);	    

    };									# package xsession
end;									# stipulate.


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
