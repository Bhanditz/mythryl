## window-property-ximp.pkg
#
# The property imp maps PropertyChange X-events
# to those threads that are interested in them
# and manages a collection of unique property names.
#
# This could be done by two separate threads
# but it simplifies things to keep all of the
# property stuff in one place.

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib





###                   "Truth is much too complicated to
###                    allow anything but approximations."
###
###                                -- Johnny von Neumann

stipulate
    include threadkit;									# threadkit			is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package aht =  atom_table;								# atom_table			is from   src/lib/x-kit/xclient/src/iccc/atom-table.pkg
    package ap  =  atom_port;								# atom_port			is from   src/lib/x-kit/xclient/src/iccc/atom-port.pkg
#   package dy  =  display;								# display			is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package ts  =  xserver_timestamp;							# xserver_timestamp		is from   src/lib/x-kit/xclient/src/wire/xserver-timestamp.pkg
    package et  =  event_types;								# event_types			is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package xt  =  xtypes;								# xtypes			is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package wpp =  window_property_port;						# window_property_port		is from   src/lib/x-kit/xclient/src/window/window-property-port.pkg
    package xes =  xevent_sink;								# xevent_sink			is from   src/lib/x-kit/xclient/src/wire/xevent-sink.pkg
    package sp  =  xserver_port;							# xserver_port			is from   src/lib/x-kit/xclient/src/wire/xserver-port.pkg
herein


    package   window_property_ximp
    : (weak)  Window_Property_Ximp							# Window_Property_Ximp		is from   src/lib/x-kit/xclient/src/window/window-property-ximp-old.api
    {
	Exports	  = {									# Ports we export for use by other imps.
		      window_property_port:		wpp::Window_Property_Port,	# Register or look up X atoms.
		      window_property_xevent_sink:	xes::Xevent_Sink		# Relevant Xevents from the X server.
		    };

	Imports   = {									# Ports we use which are exported by other imps.
		      xserver_port:			sp::Xserver_Port,
		      atom_port:			ap::Atom_Port	
		    };

	Client_Plea
	  #
	  = ALLOC_PROP    ( xt::Window_Id,  Oneshot_Maildrop( xt::Atom ) )
	  #
	  | WATCH_PROP    { name:		xt::Atom,				# Watched property's name.
			    window:		xt::Window_Id,				# Watched property's window.
			    is_unique:		Bool,					# TRUE, if the property is an internally 
											# allocated uniquely named property. 
											#
			    notify_fn							# Fn which gets the property-change notifications.
			      :
			      (wpp::Property_Change, ts::Xserver_Timestamp)
			      ->
			      Void
			  }

	  ;

	Client_Q    = Mailqueue( Client_Plea  );
	Xevent_Q    = Mailqueue( et::x::Event );

	Watched_Property_Info
	    =
	    {   window:     xt::Window_Id,
		watchers:   List(   (wpp::Property_Change, ts::Xserver_Timestamp)  ->  Void   ),
		is_unique:  Bool
	    };

	Window_Property_Ximp_State
	  =
	  { prop_table:		aht::Hashtable( List( Watched_Property_Info ) ),
	    unique_props:	Ref( List( (xt::Atom, Ref(Bool)) ))
	  };

	Configstate = Mailslot( { imports:	Imports,
				  me:		Window_Property_Ximp_State,
				  run_gun':	Run_Gun,
				  end_gun':	End_Gun
				}
			      );

	fmt_prop_name						# Make unique property names.
	    =
	    sfprintf::sprintf' "_XKIT_%d";

	fun make_prop_name n
	    =
	    fmt_prop_name [sfprintf::INT n];




	# Operations on the property info tables.
	# Each item in the table is a list of
	# Watched_Property_Info values, one for each window
	# that has a property of the given name.
	#
	fun make_prop_table () :  aht::Hashtable( List( Watched_Property_Info ) )
	    =
	    aht::make_hashtable  { size_hint => 16,  not_found_exception => FAIL "PropTable" };


	fun find_prop (table, window, name)
	    =
	    {   fun get [] =>  NULL;
		    #
		    get ((item:  Watched_Property_Info) ! r)
			=>
			item.window == window
			    ##
			    ??   THE item
			    ::   get r;
		end;

		case (aht::find table name)
		     #	      
		     THE l =>  get l;
		     _     =>  NULL;
		esac;
	    };

	fun insert_watcher (table, window, name, notify_fn, is_unique)						# Insert a watcher of a property into the table. 
	    =
	    case (aht::find table name)
		#
		NULL  =>   aht::set   table   (name, [{ window => window, watchers => [notify_fn], is_unique } ]);
		#
		THE l =>   aht::set   table   (name, get l);
	    esac
	    where
	        fun get [] =>   [ { window, watchers => [notify_fn], is_unique } ];
		    #
		    get ((item:  Watched_Property_Info) ! r)
			=>
			if (item.window == window)
			    #
			    { window,
			      watchers  =>  notify_fn ! item.watchers,
			      is_unique =>  item.is_unique
			    }
			    !
			    r;
			else
			    item ! (get r);
			fi;
		end;
	    end;



	
	#
	fun insert_unique (table:  aht::Hashtable(  List(  Watched_Property_Info ) ), window, name)			# Insert a unique property into the table.  Since the property is unique,
	    =														# it should not be in the table.   NOTE: this will change if we do uniqueness by window.
	    aht::set table (name, [{ window => window, watchers => [], is_unique => TRUE } ]);


	fun remove_prop (table, window, name)
	    =
	    {   fun get [] =>   xgripe::impossible "window_property_imp::remove_prop";
		    #
		    get ((item:  Watched_Property_Info) ! r)
			=>
			item.window == window   ??   r
				    	        ::   item ! (get r);
		end;

		case (get (aht::get  table  name))
		    #	      
		    [] =>  {   aht::drop table   name;       };
		    l  =>  {   aht::set  table  (name, l);   };
		esac;
	    };





	fun run {													# These values will be statically globally visible throughout the code body for the imp.
		  me:					Window_Property_Ximp_State,					# State which is preserved across imp shutdown/restart cycles.
		  imports:				Imports,							# Ximps to which we send requests.
		  to:					Replyqueue,							# The name makes   foo::pass_something(imp) to .{ ... }   syntax read well.
		  end_gun':				End_Gun,							# We shut down the microthread when this fires.
		  client_q:				Client_Q,							# Requests from x-widgets and such via draw_imp, pen_imp or font_imp.
		  xevent_q:				Xevent_Q							# Requests from x-widgets and such via draw_imp, pen_imp or font_imp.
		}
	    =
	    loop ()
	    where

		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    end_gun'                        ==>  shut_down_window_property_ximp',
			    take_from_mailqueue' client_q   ==>  do_client_plea,
			    take_from_mailqueue' xevent_q   ==>  do_xevent_plea
			];

			loop ();
		    }	
		    where
			fun shut_down_window_property_ximp' ()
			    =
			    thread_exit { success => TRUE };								# Will not return.	

			fun do_alloc_prop   (window_id:  xt::Window_Id,   reply_1shot)
			    =
			    {   name =   get_prop ();
				#
				insert_unique (me.prop_table, window_id, name);

				put_in_oneshot (reply_1shot, name);
			    }
			    where
				fun get_prop ()
				    =
				    get (0, *me.unique_props)
				    where 
					fun get (n, [])
						=>
						{   atom =  imports.atom_port.make_atom  (make_prop_name n);
						    #
						    me.unique_props :=  (atom, REF FALSE) ! *me.unique_props;

						    atom;
						};

					    get (n, (atom, avail) ! r)
						=>
						if *avail
						    #
						    avail := FALSE;
						    atom;
						else
						    get (n+1, r);
						fi;
					end;
				    end;
			    end;

			fun do_watch_prop { name, window, is_unique, notify_fn }
			    =
			    insert_watcher (me.prop_table, window, name, notify_fn, is_unique); 


			stipulate

			    fun free_prop name
				=
				get *me.unique_props
				where 
				    fun get [] =>   xgripe::impossible "window_property_imp::free_prop";
					#
					get ((atom, avail) ! r)
					    =>
					    if (name == atom)   avail := TRUE;
					    else		get r;
					    fi;
				    end;
				end;


			    fun broadcast ([], msg) =>   ();
				#
				broadcast (notify_fn ! rest, msg)
				    =>
				    {   notify_fn  msg;
					#
					broadcast (rest, msg);
				    };
			    end;

			herein

			    fun do_xevent_plea  (et::x::PROPERTY_NOTIFY { changed_window_id, atom, timestamp, deleted } )	# Handle a window property related X-event 
				    =>
				    case (find_prop (me.prop_table, changed_window_id, atom), deleted)
					#
					(THE { watchers, ... }, FALSE)
					    =>
					    broadcast (watchers, (wpp::NEW_VALUE, timestamp));

					(THE { watchers, is_unique, ... }, TRUE)
					    =>
					    {   broadcast (watchers, (wpp::DELETED, timestamp));
						#
						remove_prop (me.prop_table, changed_window_id, atom);

						if is_unique    free_prop atom;   fi;
					    };

					(NULL, _) => ();
				   esac;

				do_xevent_plea  xevent =>   xgripe::impossible "window_property_imp::make_server::do_xevent";
			    end;
			end;

			fun do_client_plea (ALLOC_PROP arg) => do_alloc_prop arg;
			    #
			    do_client_plea (WATCH_PROP arg) => do_watch_prop arg;
			end;
		    end;												# fun loop
	    end;													# fun run
	
	fun startup   (reply_oneshot:  Oneshot_Maildrop( (Configstate, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   configstate		    =  make_mailslot  ()	:  Configstate;
		#
		window_property_port 	    =     { unused_property,
						    watch_property
						  };

		window_property_xevent_sink =     { put_value
						  };

		to			    =  make_replyqueue();

		put_in_oneshot
		  ( reply_oneshot,
		    ( configstate,
		      { window_property_port,
			window_property_xevent_sink
		      }
		  ) );													# Return value from make_window_property_ximp().

		(take_from_mailslot  configstate)									# Input args from configure_sequencer_imp().
		    ->
		    { me, imports, run_gun', end_gun' };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		run { me, client_q, xevent_q, imports, to, end_gun' };							# Will not return.
	    }
	    where
		xevent_q  =  make_mailqueue (get_current_microthread())	:  Xevent_Q;
		client_q  =  make_mailqueue (get_current_microthread())	:  Client_Q;


		fun put_value (xevent: et::x::Event)
		    =
		    put_in_mailqueue  (xevent_q,  xevent);
		    

		fun unused_property  window_id
		    =
		    {   reply_1shot =   make_oneshot_maildrop ();
			#
			put_in_mailqueue  (client_q,  ALLOC_PROP (window_id, reply_1shot));

			get_from_oneshot  reply_1shot;
		    };

		fun watch_property
		      ( name:		xt::Atom,
			window: 	xt::Window_Id,
			is_unique:	Bool,
			notify_fn:	(wpp::Property_Change, ts::Xserver_Timestamp) -> Void
		      )
		    =
		    put_in_mailqueue  (client_q,  WATCH_PROP { name, window, is_unique, notify_fn });
	    end;

        ##########################################################################################
	# External entrypoints
	#
	fun make_window_property_ximp_state ()										# External entrypoint.
	  =
	  { prop_table   =>   make_prop_table (),		#  A table of watched properties 
	    unique_props =>   REF []				#  A list of unique property names 
	  };

	#
	fun make_window_property_ximp  (name: String)									# External entrypoint.
	    =
	    {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Configstate, Exports) );
		#
		xlogger::make_thread  name  (startup  reply_oneshot);							# Note that startup() is curried.

		get_from_oneshot  reply_oneshot;
	    };
	#
	#
	fun configure_window_property_ximp												# External entrypoint.
	      (
		configstate:	Configstate,
		me:		Window_Property_Ximp_State,
		imports:	Imports,
		run_gun':	Run_Gun,
		end_gun':	End_Gun
	      )
	    =
	    put_in_mailslot  (configstate, { me, imports, run_gun', end_gun' });

    };									# package property-imp

end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1994 by AT&T Bell Laboratories.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
