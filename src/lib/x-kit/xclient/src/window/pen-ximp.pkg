## pen-ximp.pkg
#
#    ONCE THIS COMPILES, should clone it to produce zeroth-order versions of:
#
#        src/lib/x-kit/xclient/src/window/xevent-to-window-ximp.pkg
#        src/lib/x-kit/xclient/src/window/pen-ximp.pkg
#
# For the big picture see the imp dataflow diagram in
#
#     src/lib/x-kit/xclient/src/window/xsession.pkg
#
# The font is responsible for matching
# replies read from the X with requests sent
# to it.
#
# All requests to the X-server go through the font,
# as do all replies from the X-server.
#
# The font communicates on five fixed channels:
#
#   plea_mailslot       -- request messages from clients
#   from_x_mailslot     -- reply, error and event messages from the X server (via the input buffer)
#   to_x_mailslot       -- requests messages to the X server (via the output buffer)
#   xevent_mailslot     -- X-events to the X-event buffer (and thence to clients)
#   error_sink_mailslot -- errors to the error handler
#
# In addition, the font sends replies
# to clients on the reply channel that was
# bundled with the request.
#
# We maintain a pending-reply queue of requests sent
# to the X server for which replies are expected but
# not yet received.
#     We represent it using the usual two-list arrangement,
# writing new entries to the rear list while reading them
# from the front list; when the front list is empty we
# reverse the rear list and make it the new front list.

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib





stipulate
    include threadkit;						# threadkit					is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    #
    package un  =  unt;						# unt						is from   src/lib/std/unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts			is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire					is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package w2v =  wire_to_value;				# wire_to_value					is from   src/lib/x-kit/xclient/src/wire/wire-to-value.pkg
    package xg  =  xgeometry;					# xgeometry					is from   src/lib/std/2d/xgeometry.pkg
    package xtr =  xlogger;					# xlogger					is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package xok =  xsocket;					# xsocket					is from   src/lib/x-kit/xclient/src/wire/xsocket.pkg
    package pg  =  pen_guts;					# pen_guts					is from   src/lib/x-kit/xclient/src/window/pen-guts.pkg
    package op  =  outbuf_port;					# outbuf_port					is from   src/lib/x-kit/xclient/src/wire/outbuf-port.pkg
    package sp  =  sequencer_port;				# sequencer_port				is from   src/lib/x-kit/xclient/src/wire/sequencer-port.pkg
    package pp  =  pen_port;					# pen_port					is from   src/lib/x-kit/xclient/src/window/pen-port.pkg
    package xps =  xpacket_sink;				# xpacket_sink					is from   src/lib/x-kit/xclient/src/wire/xpacket-sink.pkg
    package xt  =  xtypes;					# xtypes					is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    package et  =  event_types;					# event_types					is from   src/lib/x-kit/xclient/src/wire/event-types.pkg
    package dy  =  display;					# display					is from   src/lib/x-kit/xclient/src/wire/display.pkg

    #
    trace =  xtr::log_if  xtr::io_logging  0;			# Conditionally write strings to tracing.log or whatever.
herein


    package   pen_ximp
    : (weak)  Pen_Ximp						# Pen_Ximp					is from   src/lib/x-kit/xclient/src/wire/pen-ximp.api
    {
	gc_slot_count = 23;
	font_gcslot   = 14;					# The slot in a GC for the font.

	clip_origin_penslot = 14;				# The slot in a pen for the clip origin.
	clip_mask_penslot   = 15;				# The slot in a pen for the clip mask.
	dash_offset_penslot = 16;				# The slot in a pen for the dash offset.
	dashlist_penslot    = 17;				# The slot in a pen for the dash list.

        min_hit_rate = 80;					# We want at least 80% of GC requests to be matched.

	# GC request/reply messages.				# "GC" == "graphics context" throughout this file.
	#
	# There are two basic requests: acquire and release a GC.
	# When acquiring a GC, one supplies a pen
	# and bit-vector telling which fields are
	# used by the drawing operation.
	#
	# For text drawing, there are two
	# forms of acquire request:
	#
	#     ACQUIRE_GC_WITH_FONT specifies that
	#         the font field is needed; the reply will be
	#         REPLY_GC_WITH_FONT and will specify the
	#         current value of the GC's font.  It is the
	#         drawing operation's (presumably a DrawText)
	#         responsibility to restore the font.
	#
	#     ACQUIRE_GC_AND_SET_FONT request requires
	#         that the GC have the requested font and
	#         will generate a normal REPLY_GC reply.
	#

	Client_Plea
	  #
	  = PLEA_ALLOCATE_GRAPHICS_CONTEXT              ({ pen:  pg::Pen, used: Unt                   }, Oneshot_Maildrop(  xt::Graphics_Context_Id               ))
	  | PLEA_ALLOCATE_GRAPHICS_CONTEXT_WITH_FONT    ({ pen:  pg::Pen, used: Unt, fid: xt::Font_Id }, Oneshot_Maildrop( (xt::Graphics_Context_Id, xt::Font_Id) ))
	  | PLEA_ALLOCATE_GRAPHICS_CONTEXT_AND_SET_FONT ({ pen:  pg::Pen, used: Unt, fid: xt::Font_Id }, Oneshot_Maildrop(  xt::Graphics_Context_Id               ))
	  #
	  | PLEA_FREE_GRAPHICS_CONTEXT              xt::Graphics_Context_Id
	  | PLEA_FREE_GRAPHICS_CONTEXT_AND_FONT     xt::Graphics_Context_Id
	  ;

	# A given graphics context may have
	# no associated font.  If it does have
	# an associated font, that font may be
	# in use or unused:
	#
	Font_Status
	  #
	  = NO_FONT					# No font has been set yet in this GC.
	  | UNUSED_FONT  xt::Font_Id		# There is a font set, but it is not currently being used. 
	  | IN_USE_FONT (xt::Font_Id, Int)		# In-use font plus current number of users.
	  ;

	Free_Gc
	  =
	  FREE_GC
	    { gc_id: xt::Graphics_Context_Id,	# 29-bit integer X id for X-server graphics context.
	      desc:  pg::Pen,			# A descriptor of the values of the GC.
	      font:  Font_Status	    		# The current font (if any).
	    };

	In_Use_Gc
	  =
	  IN_USE_GC
	    { gc_id: xt::Graphics_Context_Id,	# 29-bit integer X id for X-server graphics context.
	      desc:  pg::Pen,			# A descriptor of the values of the GC.
	      font:  Ref( Font_Status ),		# The current font (if any).
	      used:  Ref( Unt ),			# A bit-mask telling which components of the GC are being used.
	      refcount:  Ref( Int )			# The number of draw_imp clients using the GC, including those using the font. 
	    };



	Pen_Ximp_State				# Opaque wrapper for all nonephemeral mutable state maintained by ximp.
	    =
	    { hit:         Ref(Int),
	      miss:        Ref(Int),
	      in_use_gcs:  Ref( List(In_Use_Gc) ),
	      free_gcs:    Ref( List(  Free_Gc) )
	    };


	Imports   = {										# Ports we use which are exported by other imps.
		      sequencer_port:		sp::Sequencer_Port
		    };
	Exports	  = {										# Ports we export for use by other imps.
		      pen_port:			pp::Pen_Port					# Requests from widget/application code.
		    };


	Configstate = Mailslot( {  imports:	Imports,
				   me:		Pen_Ximp_State,
				   run_gun':	Run_Gun,
				   end_gun':	End_Gun,
				   display:	dy::Xdisplay,
				   drawable:    xt::Drawable_Id
				 }
			      );

	Client_Q = Mailqueue( Client_Plea );

	
	fun font_sts2s (NO_FONT)          =>  "NoFont";
	    font_sts2s (UNUSED_FONT f)    =>  string::cat ["UNUSED_FONT(", xt::xid_to_string f, ")"];
	    font_sts2s (IN_USE_FONT (f, n)) =>  string::cat [ "IN_USE_FONT(", xt::xid_to_string f, ", ", int::to_string n, ")" ];
	end;

	fun in_use_gc_to_string (IN_USE_GC { gc_id, desc, font, used, refcount } )
	    =
	    string::cat
	      [
		"IN_USE_GC { gc_id=", xt::xid_to_string gc_id, ", font=", font_sts2s *font,
		", refcount=", int::to_string *refcount, "}"
	      ];


	(|)  = unt::bitwise_or;
	(&)  = unt::bitwise_and;
	(>>) = unt::(>>);
	(<<) = unt::(<<);

	# Search a list of in-use GCs for
	# given gc_id and remove if free.
	#
	# We return NULL if gc did not become free,
	# otherwise the new	FREE_GC plus the input
	# list with it removed:	
	#
	fun find_in_use_gc (our_gc_id, font_used, in_use_gcs)
	    =
	    find  in_use_gcs
	    where
		fun find []
			=>
			xgripe::impossible "[pen_to_gcontext_imp: lost in-use graphics context]";

		    find ((x as IN_USE_GC { gc_id, ... } ) ! rest)
			=>
			if (gc_id != our_gc_id)
			    #	
			    case (find rest)
				#
				THE (free_gcs, l) =>  THE (free_gcs, x ! l);
				NULL              =>  NULL;
			    esac;

			else

			    case (font_used, x)
				#
				(FALSE, IN_USE_GC { refcount => REF 1, desc, font, ... })
				    =>
				    THE (FREE_GC { gc_id, desc, font => *font }, rest);		# Removing last reference makes GC free.

				(TRUE,  IN_USE_GC { refcount => REF 1, desc, font => REF (IN_USE_FONT (f, 1)), ... })
				    =>
				    THE (FREE_GC { gc_id, desc, font => UNUSED_FONT f }, rest);	# Ditto plus marking font as unused.

				(FALSE, IN_USE_GC { refcount as REF n, ... })
				    =>
				    {   refcount := n - 1;
					NULL;
				    };

				(TRUE,  IN_USE_GC { refcount as REF n, font as REF (IN_USE_FONT (f, 1)), ... })
				    =>
				    {   refcount := n - 1;
					font := (UNUSED_FONT f);
					NULL;
				    };

				(TRUE,  IN_USE_GC { refcount as REF n, font as REF (IN_USE_FONT (f, nf)), ... })
				    =>
				    {   refcount := n - 1;
					font := IN_USE_FONT (f, nf - 1);
					NULL;
				    };

				(_, gc)
				    =>
				    xgripe::impossible (string::cat [
					"[Pen_Imp::findUsedGC: bogus in-use GC; font_used = ",
					bool::to_string font_used, ", gc = ", in_use_gc_to_string gc, "]"
				    ]);
			    esac;
			fi;
		end;
	    end;

	my (penslot_to_gcmask, penslot_to_gcslot)
	    =
	    {
		l = [
		    [0],		#  pen-slot 0:  function 
		    [1],		#  pen-slot 1:  plane mask 
		    [2],		#  pen-slot 2:  foreground 
		    [3],		#  pen-slot 3:  background 
		    [4],		#  pen-slot 4:  line-width 
		    [5],		#  pen-slot 5:  line-style 
		    [6],		#  pen-slot 6:  cap-style 
		    [7],		#  pen-slot 7:  join-style 
		    [8],		#  pen-slot 8:  fill-style 
		    [9],		#  pen-slot 9:  fill-rule 
		    [10],		#  pen-slot 10: tile 
		    [11],		#  pen-slot 11: stipple 
		    [12, 13],	#  pen-slot 12: tile/stipple origin 
		    [15],		#  pen-slot 13: subwindow mode 
		    [17, 18],	#  pen-slot 14: clipping origin 
		    [19],		#  pen-slot 15: clipping mask 
		    [20],		#  pen-slot 16: dash offset 
		    [21],		#  pen-slot 17: dash list 
		    [22]		#  pen-slot 18: arc mode 
		  ];

		# Convert  [12, 13] to an unt
		# with bits 12, 13 set to 1, etc:
		#
		fun bitmask []      =>  0u0;
		    bitmask (i ! r) =>  (0u1 << unt::from_int i) | (bitmask r);
		end;

		(vector::from_list (map bitmask l), vector::from_list (map head l));
	    };

	fun pen_mask_to_gcmask  pen_mask
	    =
	    loop (pen_mask, 0, 0u0)
	    where 
		fun loop (0u0, _, m)
			=>
			m;

		    loop (mask, i, m)
			=>
			(mask & 0u1)  == 0u0
			    ##
			    ??  loop (mask >> 0u1, i+1, m)
			    ::  loop (mask >> 0u1, i+1, m | vector::get (penslot_to_gcmask, i));
		end;
	    end;


	fun run {													# These values will be statically globally visible throughout the code body for the imp.
		  me:							Pen_Ximp_State,					# State which is preserved across imp shutdown/restart cycles.
		  imports:						Imports,					# Ximps to which we send requests.
		  to:							Replyqueue,					# The name makes   foo::pass_something(imp) to .{ ... }   syntax read well.
		  end_gun':						End_Gun,					# We shut down the microthread when this fires.
		  client_q:						Client_Q,					# Requests from x-widgets and such via draw_imp, pen_imp or pen_imp.
		  display as dy::XDISPLAY { xsocket, next_xid, ... }:	dy::Xdisplay,					# 
		  drawable:						xt::Drawable_Id
		}
	    =
	    loop ()
	    where
		send_xrequest = xok::send_xrequest  xsocket;

		fun hit_rate (hits, misses)
		    =
		    {   total = hits + misses;

			if (total == 0)   100;
			else              int::quot((100 * hits), total);
			fi;
		    };


		# Map the values of a pen to an X-server
		# GC initialization rw_vector.
		#
		# "dst_mask" specifies which values
		# in the pen are to be mapped.
		#
		# Assume that all values are non-default:
		# we copy fields from the screen's
		# default GC for those.
		#
		fun pen_to_gcvals (pg::PEN { traits, ... }, dst_mask, font)
		    =
		    {   gc_vals = rw_vector::make_rw_vector (gc_slot_count, NULL);

			fun update   (i, v) = rw_vector::set (gc_vals, i, THE (unt::from_int v));
			fun update_u (i, v) = rw_vector::set (gc_vals, i, THE v);

			fun init_val (i, pg::IS_WIRE v)
				=>
				update_u (vector::get (penslot_to_gcslot, i), v);

			    init_val (i, pg::IS_POINT (xg::POINT { col, row } ))
				=>
				{   j = vector::get (penslot_to_gcslot, i);

				    update (j,   col);
				    update (j+1, row);
				};

			    init_val (i, pg::IS_PIXMAP xid)
				=>
				update_u (vector::get (penslot_to_gcslot, i), xt::xid_to_unt xid);

			    init_val _
				=>
				();
			end;

			fun init_vals (0u0, _)
				=>
				();

			    init_vals (m, i)
				=>
				{   if ((m & 0u1) != 0u0)
					#
					init_val (i, vector::get (traits, i));
				    fi;

				    init_vals (m >> 0u1, i+1);
				};
			end;

			case font
			    #
			    THE fid =>  update_u (font_gcslot, xt::xid_to_unt fid);
			    NULL    =>  ();
			esac;

			init_vals (dst_mask, 0);


			{ vals => xt::VALUE_LIST gc_vals,

			  clip_boxes
			      =>
			      if ((dst_mask & (0u1 << unt::from_int clip_mask_penslot)) == 0u0)
				  #	
				  NULL;
			      else
				  case (vector::get (traits, clip_mask_penslot))
				      #
				      pg::IS_BOXES boxes
					  =>
					  (THE (vector::get (traits, clip_origin_penslot), boxes));

				      _ => NULL;
				  esac;
			      fi,

			  dashes => if ((dst_mask & (0u1 << unt::from_int dashlist_penslot)) == 0u0)
					#
					NULL;
				    else
					case (vector::get (traits, dashlist_penslot))
					    #
					     pg::IS_DASHES dashes
						 =>
						 THE (vector::get (traits, dash_offset_penslot), dashes);

					     _ => NULL;
					esac;
				   fi
			  };
		    };				# fun pen_to_gcvals 


		fun set_dashes (_, NULL)
			=>
			();

		    set_dashes (gc_id, THE (pg::IS_WIRE offset, dashes))
			=>
			send_xrequest (v2w::encode_set_dashes { gc_id, dashes, dash_offset => unt::to_int_x offset });

		    set_dashes (gc_id, THE(_, dashes))
			=>
			send_xrequest (v2w::encode_set_dashes { gc_id, dashes, dash_offset => 0 });
		end;


		fun set_clip_boxes (_, NULL)
			=>
			();

		    set_clip_boxes (gc_id, THE (pg::IS_POINT pt, (order, boxes)))
			=>
			send_xrequest (v2w::encode_set_clip_boxes { gc_id, boxes, clip_origin => pt, ordering => order });

		    set_clip_boxes (gc_id, THE(_, (order, boxes)))
			=>
			send_xrequest (v2w::encode_set_clip_boxes { gc_id, clip_origin => xg::point::zero, ordering => order, boxes });
		end;


		# Set the font of a GC:
		#
		fun set_font  (gc_id,  fid)
		    =
		    {   vals = rw_vector::make_rw_vector (gc_slot_count, NULL);
			#
			rw_vector::set (vals, font_gcslot, THE (xt::xid_to_unt fid));

			send_xrequest (v2w::encode_change_gc { gc_id, vals => xt::VALUE_LIST vals } );
		    };


		# Create a new X-server GC.
		# It is in-use by definition:
		#
		fun make_gc (pen as pg::PEN { bitmask, ... }, used_mask, font)
		    =
		    {   (pen_to_gcvals (pen, bitmask, font))
			    ->
			    { vals, dashes, clip_boxes };

			gc_id = next_xid();

			send_xrequest (v2w::encode_create_gc { gc_id, drawable, vals } );

			set_dashes (gc_id, dashes);
			set_clip_boxes (gc_id, clip_boxes);

			IN_USE_GC
			  { gc_id,
			    desc =>  pen,
			    #
			    font =>  REF case font    NULL => NO_FONT;  (THE f) => IN_USE_FONT (f, 1); esac,
			    used =>  REF used_mask,
			    #
			    refcount => REF 1
			  };
		      };

		(make_gc (pg::default_pen, 0ux7FFFFF, NULL))
		    ->
		    default_gc as IN_USE_GC { gc_id => default_gcid, ... };

		# Update an X-server GC so that
		# it agrees with the given pen
		# on the used values:
		#
		fun change_gc
		    (
		      FREE_GC { gc_id, font=>cur_font, ... },
		      pen as pg::PEN { bitmask, ... },
		      used_mask,
		      new_font
		    )
		    =
		    {   non_default_mask =  bitmask & used_mask;

			default_mask = (unt::bitwise_not bitmask) & used_mask;

			my (different_font, font)
			    =
			    case (cur_font, new_font)
				#
				(_,                    NULL) =>  (FALSE, NO_FONT);
				(NO_FONT,          THE fid ) =>  (TRUE, IN_USE_FONT (fid, 1));
				(UNUSED_FONT fid1, THE fid2) =>  ((fid1 != fid2), IN_USE_FONT (fid2, 1));
				(IN_USE_FONT _,           _) =>  xgripe::impossible "[Pen_Imp: used font in free_gcs gc]";
			    esac;

			if (default_mask != 0u0)
			    #	
			    send_xrequest (
				v2w::encode_copy_gc
				    {  from =>  default_gcid,
				       to   =>  gc_id,
				       mask =>  xt::VALUE_MASK (pen_mask_to_gcmask  default_mask)
				    }
			    );
			fi;

			if (non_default_mask != 0u0
			or  different_font)

			    (pen_to_gcvals (pen, bitmask, new_font))
				->
				{ vals, dashes, clip_boxes };

			    send_xrequest (v2w::encode_change_gc { gc_id, vals } );
			    set_dashes (gc_id, dashes);
			    set_clip_boxes (gc_id, clip_boxes);
			fi;

			IN_USE_GC
			  {
			    gc_id,
			    desc     =>  pen,
			    font     =>  REF font,
			    used     =>  REF used_mask,
			    refcount =>  REF 1
			  };
		    };


		# Search a list of in-use GCs for
		# one that matches the given pen:
		#
		fun match_in_use_gc (pen, used_mask, font, in_use_gcs)
		    =
		    f in_use_gcs
		    where

			# NOTE: there may be used components in pen that are not used in arg, but that
			# are defined differently.  We could still use arg, but we'll have to update it.
			# The test for an approx. match would be:
			#		    if (pg::pen_match (m & used_mask, pen, desc)
			#
			match
			    =
			    case font
				#
				NULL
				    =>
				    (fn (IN_USE_GC { desc, ... } )
					=
					pg::pen_match (used_mask, pen, desc)
				    );

				THE f
				    =>
				    match
				    where
					fun match (IN_USE_GC { desc, font => REF (IN_USE_FONT (f', _)), ... } )
						=>
						(    f == f'
						and  pg::pen_match (used_mask, pen, desc)
						);

					    match (IN_USE_GC { desc, ... } )
						=>
						pg::pen_match (used_mask, pen, desc);
					end;
				    end;
			    esac;


			fun f []
				=>
				NULL;

			    f (arg ! r)
				=>
				if (match arg)
				    #
				    arg ->  IN_USE_GC { refcount, used, ... };
				    #
				    refcount := *refcount + 1;
				    used := (*used | used_mask);
				    THE arg;
				else
				    f r;
				fi;
			end;
		    end;

		# Search the list of free graphics contexts for a match.
		#
		# If none is found, then take the last one and
		# modify it to work.  If the list is empty,
		# then create a new graphics context.
		#
		fun match_free_gc (hit, miss, pen, used_mask, font, free_gcs)
		    =
		    f (free_gcs, [])
		    where

			# Append second argument to
			# reversed first argument:
			#
			fun revappend ([],    l) =>  l;
			    revappend (x ! r, l) =>  revappend (r, x ! l);
			end;

			my (match, make_used)
			    =
			    case font
				#
				NULL
				    =>
				    (match, make_used)
				    where
					fun match (FREE_GC { desc, ... } )
					    =
					    pg::pen_match (used_mask, pen, desc);

					fun make_used (FREE_GC { gc_id, desc, font } )
					    =
					    IN_USE_GC
					      { gc_id,
						desc,
						font     =>  REF font,
						used     =>  REF used_mask,
						refcount =>  REF 1
					      };
				    end;

				THE fid					# "fid" may be "font id"
				    =>
				    (match, make_used)
				    where

					fun match (FREE_GC { desc, font => NO_FONT, ... } )
						=>
						FALSE;

					    match (FREE_GC { desc, font => UNUSED_FONT f, ... } )
						=>
						f == fid
						and
						pg::pen_match (used_mask, pen, desc);

					    match (FREE_GC { font => (IN_USE_FONT _), ... } )
						=>
						xgripe::impossible "[Pen_Imp: used font in avail gc]";
					end;

					fun make_used (FREE_GC { gc_id, desc, ... } )
					    =
					    IN_USE_GC {
						gc_id,
						desc,
						font     =>  REF (IN_USE_FONT (fid, 1)),
						used     =>  REF used_mask,
						refcount =>  REF 1
					    };

				    end;

			    esac;


			fun f ([], l)
				=>
				(make_gc (pen, used_mask, font), 0, 0, revappend (l, []));

			    f ([last as FREE_GC _ ], l)
				=>
				if (match last)
				    #
				    (make_used last, hit+1, miss, revappend (l, []));
				else
				    if (hit_rate (hit, miss) < min_hit_rate)
					#
					(make_gc (pen, used_mask, font), 0, 0, revappend (l, [last]));
				    else
					(change_gc (last, pen, used_mask, font), hit, miss+1, revappend (l, []));
				    fi;
				fi;

			    f (x ! r, l)
				=>
				if (match x)
				    #
				    (make_used x, hit+1, miss, revappend (l, r));
				else
				    f (r, x ! l);
				fi;
			end;

		    end;



		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    (end_gun'                       ==>  shut_down_pen_imp'),
			    (take_from_mailqueue' client_q  ==>  do_client_plea)
			];

			loop ();
		    }	
		    where
			fun shut_down_pen_imp' ()
			    =
			    thread_exit { success => TRUE };								# Will not return.	
			#

			stipulate

			    fun do_allocate_graphics_context               ({ pen:  pg::Pen, used => used_mask },  reply_1shot: Oneshot_Maildrop(  xt::Graphics_Context_Id               ))
				=
				case (match_in_use_gc (pen, used_mask, NULL, *me.in_use_gcs))
				    #
				    THE (IN_USE_GC { gc_id, ... } )
					=>
					{   put_in_oneshot (reply_1shot, gc_id);
					    #
					    me.hit :=  *me.hit + 1;
					};

				    NULL
					=>
					{   (match_free_gc (*me.hit, *me.miss, pen, used_mask, NULL, *me.free_gcs))
						->
						(x as IN_USE_GC { gc_id, ... }, hit, miss, free_gcs);

					    put_in_oneshot (reply_1shot, gc_id);

					    me.hit        :=  hit;
					    me.miss       :=  miss;
					    me.in_use_gcs :=  x	! *me.in_use_gcs;
					    me.free_gcs   :=  free_gcs;
					};
				esac;


			    fun do_allocate_graphics_context_with_font     ({ pen, used => used_mask, fid => f_id },  reply_1shot: Oneshot_Maildrop( (xt::Graphics_Context_Id, xt::Font_Id) ))
				=
				case (match_in_use_gc (pen, used_mask, NULL, *me.in_use_gcs))
				    #
				    THE (IN_USE_GC { gc_id, font as (REF NO_FONT), ... } )
					=>
					{   set_font (gc_id, f_id);
					    #
					    font := IN_USE_FONT (f_id, 1);

					    put_in_oneshot (reply_1shot, (gc_id, f_id));

					    me.hit :=  *me.hit + 1;
					};

				    THE (IN_USE_GC { gc_id, font as (REF (UNUSED_FONT f)), ... } )
					=>
					{   if (f != f_id)
						  set_font (gc_id, f_id);
						  font := IN_USE_FONT (f_id, 1);
					    else  font := IN_USE_FONT (f_id, 1);
					    fi;

					    put_in_oneshot (reply_1shot, (gc_id, f_id));

					    me.hit :=  *me.hit + 1;
					};

				    THE (IN_USE_GC { gc_id, font as (REF (IN_USE_FONT (f, n))), ... } )
					=>
					{   font := IN_USE_FONT (f, n+1);
					    #
					    put_in_oneshot (reply_1shot, (gc_id, f));

					    me.hit :=  *me.hit + 1;
					};

				    NULL
					=>
					{   (match_free_gc (*me.hit, *me.miss, pen, used_mask, THE f_id, *me.free_gcs))
						->
						(x as IN_USE_GC { gc_id, ... }, hit, miss, free_gcs);

					    put_in_oneshot (reply_1shot, (gc_id, f_id));

					    me.hit        :=  hit;
					    me.miss       :=  miss;
					    me.in_use_gcs :=  x	! *me.in_use_gcs;
					    me.free_gcs   :=  free_gcs;
					};
				esac;

			    fun do_allocate_graphics_context_and_set_font  ({ pen, used => used_mask, fid => f_id },  reply_1shot: Oneshot_Maildrop(  xt::Graphics_Context_Id               ))
				=
				case (match_in_use_gc (pen, used_mask, THE f_id, *me.in_use_gcs))
				    #
				    THE (IN_USE_GC { gc_id, font as (REF NO_FONT), ... } )
					=>
					{   set_font (gc_id, f_id);
					    #
					    font := IN_USE_FONT (f_id, 1);

					    put_in_oneshot (reply_1shot, gc_id);

					    me.hit :=  *me.hit + 1;
					};

				    THE (IN_USE_GC { gc_id, font as (REF (UNUSED_FONT f)), ... } )
					=>
					{   if (f != f_id)
						set_font (gc_id, f_id);
					    fi;

					    font := IN_USE_FONT (f_id, 1);

					    put_in_oneshot (reply_1shot, gc_id);

					    me.hit :=  *me.hit + 1;
					};

				    THE (IN_USE_GC { gc_id, font as (REF (IN_USE_FONT (f, n))), ... } )
					=>
					{   font := IN_USE_FONT (f, n+1);		#  NOTE: f = fId! 
					    #
					    put_in_oneshot (reply_1shot, gc_id);

					    me.hit :=  *me.hit + 1;
					};

				    NULL =>
				        {   (match_free_gc (*me.hit, *me.miss, pen, used_mask, THE f_id, *me.free_gcs))
						->
						(x as IN_USE_GC { gc_id, ... }, hit, miss, free_gcs);

					    put_in_oneshot (reply_1shot, gc_id);

					    me.hit        :=  hit;
					    me.miss       :=  miss;
					    me.in_use_gcs :=  x	! *me.in_use_gcs;
					    me.free_gcs   :=  free_gcs;
				        };
				esac;


			    fun do_free_graphics_context                   (id: xt::Graphics_Context_Id)
				=
				case (find_in_use_gc (id, FALSE, *me.in_use_gcs))
				    #
				    THE (x, l) =>   {   me.in_use_gcs :=  l;
							me.free_gcs   :=  x !  *me.free_gcs;
						    };
				    NULL       =>   {   
						    };
				esac;

			    fun do_free_graphics_context_and_font	   (id: xt::Graphics_Context_Id)
				=
				case (find_in_use_gc (id, TRUE, *me.in_use_gcs))
				    #
				    THE (x, l) =>   {   me.in_use_gcs :=  l;
							me.free_gcs   :=  x !  *me.free_gcs;
						    };
				    NULL       =>   {   
						    };
				esac;

			herein

			    fun do_client_plea (PLEA_ALLOCATE_GRAPHICS_CONTEXT              request) =>  do_allocate_graphics_context               request;
				do_client_plea (PLEA_ALLOCATE_GRAPHICS_CONTEXT_WITH_FONT    request) =>  do_allocate_graphics_context_with_font     request;
				do_client_plea (PLEA_ALLOCATE_GRAPHICS_CONTEXT_AND_SET_FONT request) =>  do_allocate_graphics_context_and_set_font  request;
				do_client_plea (PLEA_FREE_GRAPHICS_CONTEXT                  request) =>  do_free_graphics_context                   request;
				do_client_plea (PLEA_FREE_GRAPHICS_CONTEXT_AND_FONT         request) =>  do_free_graphics_context_and_font	   request;
			    end;
			end;
		    end;												# fun loop
	    end;													# fun run
	
	fun startup   (reply_oneshot:  Oneshot_Maildrop( (Configstate, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   configstate     =  make_mailslot  ()	:  Configstate;
		#
		pen_port =  { allocate_graphics_context,
			      allocate_graphics_context_with_font,
			      allocate_graphics_context_and_set_font,
			      free_graphics_context,
			      free_graphics_context_and_font
			    };

		to             =  make_replyqueue();

		put_in_oneshot (reply_oneshot, (configstate, { pen_port }));						# Return value from make_pen_ximp().

		(take_from_mailslot  configstate)									# Input args from configure_pen_imp().
		    ->
		    { me, imports, run_gun', end_gun', display, drawable };

		block_until_mailop_fires  run_gun';									# Wait for the starting gun.

		graphics_expose_event_accumulator = REF NULL;

		run { me, client_q, imports, to, end_gun', display, drawable };						# Will not return.
	    }
	    where
		client_q  =  make_mailqueue (get_current_microthread())	:  Client_Q;

		fun allocate_graphics_context              (arg: { pen:  pg::Pen, used: Unt                   })
		    =
		    {   reply_oneshot =  make_oneshot_maildrop ();
			#
			put_in_mailqueue (client_q, PLEA_ALLOCATE_GRAPHICS_CONTEXT (arg, reply_oneshot));

			get_from_oneshot  reply_oneshot;
		    };

		fun allocate_graphics_context_with_font    (arg: { pen:  pg::Pen, used: Unt, fid: xt::Font_Id })
		    =
		    {   reply_oneshot =  make_oneshot_maildrop ();
			#
			put_in_mailqueue (client_q, PLEA_ALLOCATE_GRAPHICS_CONTEXT_WITH_FONT (arg, reply_oneshot));

			get_from_oneshot  reply_oneshot;
		    };

		fun allocate_graphics_context_and_set_font (arg: { pen:  pg::Pen, used: Unt, fid: xt::Font_Id })
		    =
		    {   reply_oneshot =  make_oneshot_maildrop ();
			#
			put_in_mailqueue (client_q, PLEA_ALLOCATE_GRAPHICS_CONTEXT_AND_SET_FONT (arg, reply_oneshot));

			get_from_oneshot  reply_oneshot;
		    };

		fun free_graphics_context  (gc: xt::Graphics_Context_Id)
		    =
		    put_in_mailqueue (client_q, PLEA_FREE_GRAPHICS_CONTEXT gc);

		fun free_graphics_context_and_font     (gc: xt::Graphics_Context_Id)
		    =
		    put_in_mailqueue (client_q, PLEA_FREE_GRAPHICS_CONTEXT_AND_FONT gc);
	    end;

        ##########################################################################################
	# External entrypoints
	#
	fun make_pen_ximp_state ()										# External entrypoint.
	  =
	  { hit		=>  REF 0,
	    miss	=>  REF 0,
	    in_use_gcs	=>  REF ([]:  List(In_Use_Gc)),
	    free_gcs	=>  REF ([]:  List(  Free_Gc))
	  };


	#
	fun make_pen_ximp  (name: String)									# External entrypoint.
	    =
	    {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Configstate, Exports) );
		#
		xlogger::make_thread  name  (startup  reply_oneshot);						# Note that startup() is curried.

		get_from_oneshot  reply_oneshot;
	    };
	#
	#
	fun configure_pen_ximp											# External entrypoint.
	      (
		configstate:	Configstate,
		me:		Pen_Ximp_State,
		imports:	Imports,
		run_gun':	Run_Gun,
		end_gun':	End_Gun,
		display:	dy::Xdisplay,
		drawable:	xt::Drawable_Id
	      )
	    =
	    put_in_mailslot  (configstate, { me, imports, run_gun', end_gun', display, drawable });

    };						# package pen_ximp
end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
