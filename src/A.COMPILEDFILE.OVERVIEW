# Context
# =======
#
# A .compiled file is the result of compiling one
# source file:
#
#     foo.api   compiles to   foo.api.compiled
#     foo.pkg   compiles to   foo.pkg.compiled
#
# Mythryl .compiled files serve much the same purpose
# as Unix .o files.  They contain executable code and
# a pickled symbol table listing its exported funs, vals etc.
#
# .compiled files are dynamically loaded into a running
# Mythryl process as needed and linked by calling a given
# entrypoint with the current process linking dictionary,
# which holds pointers to all the resources needed by the
# .compiled file, such as addresses of external functions it calls.



# LINKING BACKGROUND
# ==================
#
# Traditional linkers patch addresses within compiled code one by one
# using special maps of the compiled code internals.  Some of the
# patching is to relocate code compiled as though it were at address
# zero, but which is actually being loaded into memory at some other
# address.  Other patching is done to fix up calls in one compilation
# unit made to functions in other compilation units, since those
# external addresses are not known at compile time.
#
# Mythryl instead generates position-independent code which needs
# little linking.  The compiled code is treated as an opaque blob;
# the little linking needed is performed by invoking that blob as
# a function, passing in an argument containing all external resources
# required by the compiled code, and receiving in return a result
# containing all functions and values exported by the compiled code.
#
# More concretely, compiled Mythryl code requires two resource sets:
#
#    o Literal values: Lists, records etc from the source code.
#      These are generated by executing a bytecode program which
#      constructs them on the heap.
#
#    o Values exported from other Mythryl packages.
#
#      These packages are identified internally by a 'picklehash' --
#      a 16-byte message-digest style hash of the compiled package.
#
#      The exports from each package form essentially a tree of records.
#      A typical such 'tree' may consist of a single record containing
#      all the externally visible functions in the package.
#
#      Thus, any such resource may be specified by giving
#
#        1) The picklehash  identifying the compiled package in question;
#
#        2) A sequence of one or more integer offsets specifying a path
#           down the exported tree of records: "Get the record in
#           slot 3 in the root record, then get the value from slot 12
#           of the second record", say.
#
# We load a .compiled file via a four-step process:
#
#     1) We parse the 'import tree' segment of the file, locating
#        all functions etc from other packages needed by this package,
#        and bundling them all together in an 'imports' record.
#
#     2) Executing the literals bytecode in "code segment 0" to generate
#        all heap values needed by the package.  The result of doing this
#        is a 'literals' record.
#
#     3) We run the code in 'code segment 1' with an argument which
#        includes both the 'import' and 'literals' records.  The result
#        returned by this call is the 'exports' tree-of-records for the
#        package.
#
#     4) We save the 'exports' tree, indexed by this package's picklehash,
#        for use in processing later.compiled files dependent upon this one.

For more detailed information, see the comments in:

    src/lib/compiler/execution/compiledfile/compiledfile.pkg
